["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@popperjs/core/lib/createPopper.js"],"~:js","shadow$provide.module$node_modules$$popperjs$core$lib$createPopper=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}function areValidElements(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];return!args.some(function(element){return!(element&&\"function\"===typeof element.getBoundingClientRect)})}function popperGenerator(generatorOptions){void 0===generatorOptions&&(generatorOptions=\n{});var _generatorOptions$def=generatorOptions.defaultModifiers,defaultModifiers=void 0===_generatorOptions$def?[]:_generatorOptions$def;generatorOptions=generatorOptions.defaultOptions;var defaultOptions=void 0===generatorOptions?DEFAULT_OPTIONS:generatorOptions;return function(reference$jscomp$0,popper,options){function runModifierEffects(){state$jscomp$0.orderedModifiers.forEach(function(_ref3){var name=_ref3.name,_ref3$options=_ref3.options;_ref3$options=void 0===_ref3$options?{}:_ref3$options;\n_ref3=_ref3.effect;\"function\"===typeof _ref3&&(name=_ref3({state:state$jscomp$0,name,instance,options:_ref3$options}),effectCleanupFns.push(name||function(){}))})}function cleanupModifierEffects(){effectCleanupFns.forEach(function(fn){return fn()});effectCleanupFns=[]}void 0===options&&(options=defaultOptions);var state$jscomp$0={placement:\"bottom\",orderedModifiers:[],options:Object.assign({},DEFAULT_OPTIONS,defaultOptions),modifiersData:{},elements:{reference:reference$jscomp$0,popper},attributes:{},\nstyles:{}},effectCleanupFns=[],isDestroyed=!1,instance={state:state$jscomp$0,setOptions:function(setOptionsAction){setOptionsAction=\"function\"===typeof setOptionsAction?setOptionsAction(state$jscomp$0.options):setOptionsAction;cleanupModifierEffects();state$jscomp$0.options=Object.assign({},defaultOptions,state$jscomp$0.options,setOptionsAction);state$jscomp$0.scrollParents={reference:(0,_instanceOf.isElement)(reference$jscomp$0)?(0,_listScrollParents[\"default\"])(reference$jscomp$0):reference$jscomp$0.contextElement?\n(0,_listScrollParents[\"default\"])(reference$jscomp$0.contextElement):[],popper:(0,_listScrollParents[\"default\"])(popper)};setOptionsAction=(0,_orderModifiers[\"default\"])((0,_mergeByName[\"default\"])([].concat(defaultModifiers,state$jscomp$0.options.modifiers)));state$jscomp$0.orderedModifiers=setOptionsAction.filter(function(m){return m.enabled});setOptionsAction=(0,_uniqueBy[\"default\"])([].concat(setOptionsAction,state$jscomp$0.options.modifiers),function(_ref){return _ref.name});(0,_validateModifiers[\"default\"])(setOptionsAction);\n(0,_getBasePlacement[\"default\"])(state$jscomp$0.options.placement)===_enums.auto&&(state$jscomp$0.orderedModifiers.find(function(_ref2){return\"flip\"===_ref2.name})||console.error('Popper: \"auto\" placements require the \"flip\" modifier be present and enabled to work.'));setOptionsAction=(0,_getComputedStyle2[\"default\"])(popper);[setOptionsAction.marginTop,setOptionsAction.marginRight,setOptionsAction.marginBottom,setOptionsAction.marginLeft].some(function(margin){return parseFloat(margin)})&&console.warn('Popper: CSS \"margin\" styles cannot be used to apply padding between the popper and its reference element or boundary. To replicate margin, use the `offset` modifier, as well as the `padding` option in the `preventOverflow` and `flip` modifiers.');\nrunModifierEffects();return instance.update()},forceUpdate:function(){if(!isDestroyed){var _state$elements=state$jscomp$0.elements,reference=_state$elements.reference;_state$elements=_state$elements.popper;if(areValidElements(reference,_state$elements))for(state$jscomp$0.rects={reference:(0,_getCompositeRect[\"default\"])(reference,(0,_getOffsetParent[\"default\"])(_state$elements),\"fixed\"===state$jscomp$0.options.strategy),popper:(0,_getLayoutRect[\"default\"])(_state$elements)},state$jscomp$0.reset=!1,\nstate$jscomp$0.placement=state$jscomp$0.options.placement,state$jscomp$0.orderedModifiers.forEach(function(modifier){return state$jscomp$0.modifiersData[modifier.name]=Object.assign({},modifier.data)}),_state$elements=reference=0;_state$elements<state$jscomp$0.orderedModifiers.length;_state$elements++){reference+=1;if(100<reference){console.error(INFINITE_LOOP_ERROR);break}if(!0===state$jscomp$0.reset)state$jscomp$0.reset=!1,_state$elements=-1;else{var _state$orderedModifie=state$jscomp$0.orderedModifiers[_state$elements],\nfn=_state$orderedModifie.fn,_state$orderedModifie2=_state$orderedModifie.options;_state$orderedModifie2=void 0===_state$orderedModifie2?{}:_state$orderedModifie2;_state$orderedModifie=_state$orderedModifie.name;\"function\"===typeof fn&&(state$jscomp$0=fn({state:state$jscomp$0,options:_state$orderedModifie2,name:_state$orderedModifie,instance})||state$jscomp$0)}}else console.error(INVALID_ELEMENT_ERROR)}},update:(0,_debounce[\"default\"])(function(){return new Promise(function(resolve){instance.forceUpdate();\nresolve(state$jscomp$0)})}),destroy:function(){cleanupModifierEffects();isDestroyed=!0}};if(!areValidElements(reference$jscomp$0,popper))return console.error(INVALID_ELEMENT_ERROR),instance;instance.setOptions(options).then(function(state){if(!isDestroyed&&options.onFirstUpdate)options.onFirstUpdate(state)});return instance}}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.popperGenerator=popperGenerator;Object.defineProperty(exports,\"detectOverflow\",{enumerable:!0,get:function(){return _detectOverflow[\"default\"]}});\nexports.createPopper=void 0;var _getCompositeRect=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$dom_utils$getCompositeRect\")),_getLayoutRect=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$dom_utils$getLayoutRect\")),_listScrollParents=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$dom_utils$listScrollParents\")),_getOffsetParent=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$dom_utils$getOffsetParent\")),\n_getComputedStyle2=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$dom_utils$getComputedStyle\")),_orderModifiers=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$utils$orderModifiers\")),_debounce=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$utils$debounce\")),_validateModifiers=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$utils$validateModifiers\")),_uniqueBy=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$utils$uniqueBy\")),\n_getBasePlacement=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$utils$getBasePlacement\")),_mergeByName=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$utils$mergeByName\")),_detectOverflow=_interopRequireDefault(require(\"module$node_modules$$popperjs$core$lib$utils$detectOverflow\")),_instanceOf=require(\"module$node_modules$$popperjs$core$lib$dom_utils$instanceOf\"),_enums=require(\"module$node_modules$$popperjs$core$lib$enums\"),INVALID_ELEMENT_ERROR=\"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\",\nINFINITE_LOOP_ERROR=\"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\",DEFAULT_OPTIONS={placement:\"bottom\",modifiers:[],strategy:\"absolute\"};global=popperGenerator();exports.createPopper=global}","~:source","shadow$provide[\"module$node_modules$$popperjs$core$lib$createPopper\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.popperGenerator = popperGenerator;\nObject.defineProperty(exports, \"detectOverflow\", {\n  enumerable: true,\n  get: function get() {\n    return _detectOverflow[\"default\"];\n  }\n});\nexports.createPopper = void 0;\n\nvar _getCompositeRect = _interopRequireDefault(require(\"./dom-utils/getCompositeRect.js\"));\n\nvar _getLayoutRect = _interopRequireDefault(require(\"./dom-utils/getLayoutRect.js\"));\n\nvar _listScrollParents = _interopRequireDefault(require(\"./dom-utils/listScrollParents.js\"));\n\nvar _getOffsetParent = _interopRequireDefault(require(\"./dom-utils/getOffsetParent.js\"));\n\nvar _getComputedStyle2 = _interopRequireDefault(require(\"./dom-utils/getComputedStyle.js\"));\n\nvar _orderModifiers = _interopRequireDefault(require(\"./utils/orderModifiers.js\"));\n\nvar _debounce = _interopRequireDefault(require(\"./utils/debounce.js\"));\n\nvar _validateModifiers = _interopRequireDefault(require(\"./utils/validateModifiers.js\"));\n\nvar _uniqueBy = _interopRequireDefault(require(\"./utils/uniqueBy.js\"));\n\nvar _getBasePlacement = _interopRequireDefault(require(\"./utils/getBasePlacement.js\"));\n\nvar _mergeByName = _interopRequireDefault(require(\"./utils/mergeByName.js\"));\n\nvar _detectOverflow = _interopRequireDefault(require(\"./utils/detectOverflow.js\"));\n\nvar _instanceOf = require(\"./dom-utils/instanceOf.js\");\n\nvar _enums = require(\"./enums.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: (0, _instanceOf.isElement)(reference) ? (0, _listScrollParents[\"default\"])(reference) : reference.contextElement ? (0, _listScrollParents[\"default\"])(reference.contextElement) : [],\n          popper: (0, _listScrollParents[\"default\"])(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = (0, _orderModifiers[\"default\"])((0, _mergeByName[\"default\"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (process.env.NODE_ENV !== \"production\") {\n          var modifiers = (0, _uniqueBy[\"default\"])([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\n            var name = _ref.name;\n            return name;\n          });\n          (0, _validateModifiers[\"default\"])(modifiers);\n\n          if ((0, _getBasePlacement[\"default\"])(state.options.placement) === _enums.auto) {\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\n              var name = _ref2.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = (0, _getComputedStyle2[\"default\"])(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: (0, _getCompositeRect[\"default\"])(reference, (0, _getOffsetParent[\"default\"])(popper), state.options.strategy === 'fixed'),\n          popper: (0, _getLayoutRect[\"default\"])(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (process.env.NODE_ENV !== \"production\") {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: (0, _debounce[\"default\"])(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\n\nvar createPopper =\n/*#__PURE__*/\npopperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexports.createPopper = createPopper;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$popperjs$core$lib$enums","~$module$node_modules$$popperjs$core$lib$dom_utils$getOffsetParent","~$module$node_modules$$popperjs$core$lib$dom_utils$getComputedStyle","~$module$node_modules$$popperjs$core$lib$utils$orderModifiers","~$shadow.js","~$module$node_modules$$popperjs$core$lib$dom_utils$instanceOf","~$module$node_modules$$popperjs$core$lib$dom_utils$listScrollParents","~$module$node_modules$$popperjs$core$lib$utils$validateModifiers","~$module$node_modules$$popperjs$core$lib$utils$uniqueBy","~$module$node_modules$$popperjs$core$lib$dom_utils$getLayoutRect","~$module$node_modules$$popperjs$core$lib$utils$mergeByName","~$module$node_modules$$popperjs$core$lib$utils$getBasePlacement","~$module$node_modules$$popperjs$core$lib$utils$debounce","~$module$node_modules$$popperjs$core$lib$dom_utils$getCompositeRect","~$module$node_modules$$popperjs$core$lib$utils$detectOverflow"]],"~:properties",["^5",["setOptions","strategy","placement","__esModule","reset","update","createPopper","name","value","destroy","popperGenerator","enumerable","rects","styles","modifiers","instance","attributes","reference","scrollParents","state","modifiersData","orderedModifiers","options","forceUpdate","get","elements","detectOverflow","popper"]],"~:compiled-at",1630917514110,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$popperjs$core$lib$createPopper.js\",\n\"lineCount\":14,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@popperjs/core/lib/createPopper.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$popperjs$core$lib$createPopper\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.popperGenerator = popperGenerator;\\nObject.defineProperty(exports, \\\"detectOverflow\\\", {\\n  enumerable: true,\\n  get: function get() {\\n    return _detectOverflow[\\\"default\\\"];\\n  }\\n});\\nexports.createPopper = void 0;\\n\\nvar _getCompositeRect = _interopRequireDefault(require(\\\"./dom-utils/getCompositeRect.js\\\"));\\n\\nvar _getLayoutRect = _interopRequireDefault(require(\\\"./dom-utils/getLayoutRect.js\\\"));\\n\\nvar _listScrollParents = _interopRequireDefault(require(\\\"./dom-utils/listScrollParents.js\\\"));\\n\\nvar _getOffsetParent = _interopRequireDefault(require(\\\"./dom-utils/getOffsetParent.js\\\"));\\n\\nvar _getComputedStyle2 = _interopRequireDefault(require(\\\"./dom-utils/getComputedStyle.js\\\"));\\n\\nvar _orderModifiers = _interopRequireDefault(require(\\\"./utils/orderModifiers.js\\\"));\\n\\nvar _debounce = _interopRequireDefault(require(\\\"./utils/debounce.js\\\"));\\n\\nvar _validateModifiers = _interopRequireDefault(require(\\\"./utils/validateModifiers.js\\\"));\\n\\nvar _uniqueBy = _interopRequireDefault(require(\\\"./utils/uniqueBy.js\\\"));\\n\\nvar _getBasePlacement = _interopRequireDefault(require(\\\"./utils/getBasePlacement.js\\\"));\\n\\nvar _mergeByName = _interopRequireDefault(require(\\\"./utils/mergeByName.js\\\"));\\n\\nvar _detectOverflow = _interopRequireDefault(require(\\\"./utils/detectOverflow.js\\\"));\\n\\nvar _instanceOf = require(\\\"./dom-utils/instanceOf.js\\\");\\n\\nvar _enums = require(\\\"./enums.js\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \\\"default\\\": obj }; }\\n\\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\\nvar DEFAULT_OPTIONS = {\\n  placement: 'bottom',\\n  modifiers: [],\\n  strategy: 'absolute'\\n};\\n\\nfunction areValidElements() {\\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n    args[_key] = arguments[_key];\\n  }\\n\\n  return !args.some(function (element) {\\n    return !(element && typeof element.getBoundingClientRect === 'function');\\n  });\\n}\\n\\nfunction popperGenerator(generatorOptions) {\\n  if (generatorOptions === void 0) {\\n    generatorOptions = {};\\n  }\\n\\n  var _generatorOptions = generatorOptions,\\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\\n  return function createPopper(reference, popper, options) {\\n    if (options === void 0) {\\n      options = defaultOptions;\\n    }\\n\\n    var state = {\\n      placement: 'bottom',\\n      orderedModifiers: [],\\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\\n      modifiersData: {},\\n      elements: {\\n        reference: reference,\\n        popper: popper\\n      },\\n      attributes: {},\\n      styles: {}\\n    };\\n    var effectCleanupFns = [];\\n    var isDestroyed = false;\\n    var instance = {\\n      state: state,\\n      setOptions: function setOptions(setOptionsAction) {\\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\\n        cleanupModifierEffects();\\n        state.options = Object.assign({}, defaultOptions, state.options, options);\\n        state.scrollParents = {\\n          reference: (0, _instanceOf.isElement)(reference) ? (0, _listScrollParents[\\\"default\\\"])(reference) : reference.contextElement ? (0, _listScrollParents[\\\"default\\\"])(reference.contextElement) : [],\\n          popper: (0, _listScrollParents[\\\"default\\\"])(popper)\\n        }; // Orders the modifiers based on their dependencies and `phase`\\n        // properties\\n\\n        var orderedModifiers = (0, _orderModifiers[\\\"default\\\"])((0, _mergeByName[\\\"default\\\"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\\n\\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\\n          return m.enabled;\\n        }); // Validate the provided modifiers so that the consumer will get warned\\n        // if one of the modifiers is invalid for any reason\\n\\n        if (process.env.NODE_ENV !== \\\"production\\\") {\\n          var modifiers = (0, _uniqueBy[\\\"default\\\"])([].concat(orderedModifiers, state.options.modifiers), function (_ref) {\\n            var name = _ref.name;\\n            return name;\\n          });\\n          (0, _validateModifiers[\\\"default\\\"])(modifiers);\\n\\n          if ((0, _getBasePlacement[\\\"default\\\"])(state.options.placement) === _enums.auto) {\\n            var flipModifier = state.orderedModifiers.find(function (_ref2) {\\n              var name = _ref2.name;\\n              return name === 'flip';\\n            });\\n\\n            if (!flipModifier) {\\n              console.error(['Popper: \\\"auto\\\" placements require the \\\"flip\\\" modifier be', 'present and enabled to work.'].join(' '));\\n            }\\n          }\\n\\n          var _getComputedStyle = (0, _getComputedStyle2[\\\"default\\\"])(popper),\\n              marginTop = _getComputedStyle.marginTop,\\n              marginRight = _getComputedStyle.marginRight,\\n              marginBottom = _getComputedStyle.marginBottom,\\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\\n          // cause bugs with positioning, so we'll warn the consumer\\n\\n\\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\\n            return parseFloat(margin);\\n          })) {\\n            console.warn(['Popper: CSS \\\"margin\\\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\\n          }\\n        }\\n\\n        runModifierEffects();\\n        return instance.update();\\n      },\\n      // Sync update \\u2013 it will always be executed, even if not necessary. This\\n      // is useful for low frequency updates where sync behavior simplifies the\\n      // logic.\\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\\n      // prefer the async Popper#update method\\n      forceUpdate: function forceUpdate() {\\n        if (isDestroyed) {\\n          return;\\n        }\\n\\n        var _state$elements = state.elements,\\n            reference = _state$elements.reference,\\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\\n        // anymore\\n\\n        if (!areValidElements(reference, popper)) {\\n          if (process.env.NODE_ENV !== \\\"production\\\") {\\n            console.error(INVALID_ELEMENT_ERROR);\\n          }\\n\\n          return;\\n        } // Store the reference and popper rects to be read by modifiers\\n\\n\\n        state.rects = {\\n          reference: (0, _getCompositeRect[\\\"default\\\"])(reference, (0, _getOffsetParent[\\\"default\\\"])(popper), state.options.strategy === 'fixed'),\\n          popper: (0, _getLayoutRect[\\\"default\\\"])(popper)\\n        }; // Modifiers have the ability to reset the current update cycle. The\\n        // most common use case for this is the `flip` modifier changing the\\n        // placement, which then needs to re-run all the modifiers, because the\\n        // logic was previously ran for the previous placement and is therefore\\n        // stale/incorrect\\n\\n        state.reset = false;\\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\\n        // is filled with the initial data specified by the modifier. This means\\n        // it doesn't persist and is fresh on each update.\\n        // To ensure persistent data, use `${name}#persistent`\\n\\n        state.orderedModifiers.forEach(function (modifier) {\\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\\n        });\\n        var __debug_loops__ = 0;\\n\\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\\n          if (process.env.NODE_ENV !== \\\"production\\\") {\\n            __debug_loops__ += 1;\\n\\n            if (__debug_loops__ > 100) {\\n              console.error(INFINITE_LOOP_ERROR);\\n              break;\\n            }\\n          }\\n\\n          if (state.reset === true) {\\n            state.reset = false;\\n            index = -1;\\n            continue;\\n          }\\n\\n          var _state$orderedModifie = state.orderedModifiers[index],\\n              fn = _state$orderedModifie.fn,\\n              _state$orderedModifie2 = _state$orderedModifie.options,\\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\\n              name = _state$orderedModifie.name;\\n\\n          if (typeof fn === 'function') {\\n            state = fn({\\n              state: state,\\n              options: _options,\\n              name: name,\\n              instance: instance\\n            }) || state;\\n          }\\n        }\\n      },\\n      // Async and optimistically optimized update \\u2013 it will not be executed if\\n      // not necessary (debounced to run at most once-per-tick)\\n      update: (0, _debounce[\\\"default\\\"])(function () {\\n        return new Promise(function (resolve) {\\n          instance.forceUpdate();\\n          resolve(state);\\n        });\\n      }),\\n      destroy: function destroy() {\\n        cleanupModifierEffects();\\n        isDestroyed = true;\\n      }\\n    };\\n\\n    if (!areValidElements(reference, popper)) {\\n      if (process.env.NODE_ENV !== \\\"production\\\") {\\n        console.error(INVALID_ELEMENT_ERROR);\\n      }\\n\\n      return instance;\\n    }\\n\\n    instance.setOptions(options).then(function (state) {\\n      if (!isDestroyed && options.onFirstUpdate) {\\n        options.onFirstUpdate(state);\\n      }\\n    }); // Modifiers have the ability to execute arbitrary code before the first\\n    // update cycle runs. They will be executed in the same order as the update\\n    // cycle. This is useful when a modifier adds some persistent data that\\n    // other modifiers need to use, but the modifier is run after the dependent\\n    // one.\\n\\n    function runModifierEffects() {\\n      state.orderedModifiers.forEach(function (_ref3) {\\n        var name = _ref3.name,\\n            _ref3$options = _ref3.options,\\n            options = _ref3$options === void 0 ? {} : _ref3$options,\\n            effect = _ref3.effect;\\n\\n        if (typeof effect === 'function') {\\n          var cleanupFn = effect({\\n            state: state,\\n            name: name,\\n            instance: instance,\\n            options: options\\n          });\\n\\n          var noopFn = function noopFn() {};\\n\\n          effectCleanupFns.push(cleanupFn || noopFn);\\n        }\\n      });\\n    }\\n\\n    function cleanupModifierEffects() {\\n      effectCleanupFns.forEach(function (fn) {\\n        return fn();\\n      });\\n      effectCleanupFns = [];\\n    }\\n\\n    return instance;\\n  };\\n}\\n\\nvar createPopper =\\n/*#__PURE__*/\\npopperGenerator(); // eslint-disable-next-line import/no-unused-modules\\n\\nexports.createPopper = createPopper;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"areValidElements\",\"_len\",\"arguments\",\"length\",\"args\",\"Array\",\"_key\",\"some\",\"element\",\"getBoundingClientRect\",\"popperGenerator\",\"generatorOptions\",\"_generatorOptions$def\",\"_generatorOptions\",\"defaultModifiers\",\"_generatorOptions$def2\",\"defaultOptions\",\"DEFAULT_OPTIONS\",\"createPopper\",\"reference\",\"popper\",\"options\",\"runModifierEffects\",\"state\",\"orderedModifiers\",\"forEach\",\"_ref3\",\"name\",\"_ref3$options\",\"effect\",\"cleanupFn\",\"instance\",\"effectCleanupFns\",\"push\",\"noopFn\",\"cleanupModifierEffects\",\"fn\",\"placement\",\"Object\",\"assign\",\"modifiersData\",\"elements\",\"attributes\",\"styles\",\"isDestroyed\",\"setOptions\",\"setOptionsAction\",\"scrollParents\",\"_instanceOf\",\"isElement\",\"_listScrollParents\",\"contextElement\",\"_orderModifiers\",\"_mergeByName\",\"concat\",\"modifiers\",\"filter\",\"m\",\"enabled\",\"_uniqueBy\",\"_ref\",\"_validateModifiers\",\"_getBasePlacement\",\"_enums\",\"auto\",\"find\",\"flipModifier\",\"_ref2\",\"console\",\"error\",\"_getComputedStyle\",\"_getComputedStyle2\",\"marginTop\",\"marginRight\",\"marginBottom\",\"marginLeft\",\"margin\",\"parseFloat\",\"warn\",\"update\",\"forceUpdate\",\"_state$elements\",\"rects\",\"index\",\"_getCompositeRect\",\"_getOffsetParent\",\"strategy\",\"_getLayoutRect\",\"reset\",\"modifier\",\"data\",\"__debug_loops__\",\"INFINITE_LOOP_ERROR\",\"_state$orderedModifie\",\"_state$orderedModifie2\",\"_options\",\"INVALID_ELEMENT_ERROR\",\"_debounce\",\"Promise\",\"resolve\",\"destroy\",\"then\",\"onFirstUpdate\",\"defineProperty\",\"value\",\"enumerable\",\"get\",\"_detectOverflow\"]\n}\n"]