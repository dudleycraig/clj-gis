["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/bidi-js/dist/bidi.mjs"],"~:js","shadow$provide.module$node_modules$bidi_js$dist$bidi_mjs=function(global,require,module,exports$jscomp$0){Object.defineProperty(exports$jscomp$0,\"__esModule\",{value:!0});exports$jscomp$0[\"default\"]=void 0;exports$jscomp$0[\"default\"]=function(){return function(exports){function parseData(){if(!map$jscomp$0){map$jscomp$0=new Map;var loop=function(type){if(DATA.hasOwnProperty(type)){var lastCode=0;DATA[type].split(\",\").forEach(function(range){var ref=range.split(\"+\");range=ref[0];ref=ref[1];range=parseInt(range,\n36);ref=ref?parseInt(ref,36):0;map$jscomp$0.set(lastCode+=range,TYPES[type]);for(range=0;range<ref;range++)map$jscomp$0.set(++lastCode,TYPES[type])})}},type$jscomp$0;for(type$jscomp$0 in DATA)loop(type$jscomp$0)}}function getBidiCharType(_char){parseData();return map$jscomp$0.get(_char.codePointAt(0))||TYPES.L}function parseCharacterMap(encodedString,includeReverse){var lastCode=0,map=new Map,reverseMap=includeReverse&&new Map,prevPair;encodedString.split(\",\").forEach(function visit(entry){if(-1!==\nentry.indexOf(\"+\"))for(entry=+entry;entry--;)visit(prevPair);else{prevPair=entry;var ref=entry.split(\"\\x3e\");entry=ref[0];ref=ref[1];entry=String.fromCodePoint(lastCode+=parseInt(entry,36));ref=String.fromCodePoint(lastCode+=parseInt(ref,36));map.set(entry,ref);includeReverse&&reverseMap.set(ref,entry)}});return{map,reverseMap}}function parse$1(){if(!openToClose){var ref=parseCharacterMap(data$1.pairs,!0),reverseMap=ref.reverseMap;openToClose=ref.map;closeToOpen=reverseMap;canonical=parseCharacterMap(data$1.canonical,\n!1).map}}function openingToClosingBracket(_char3){parse$1();return openToClose.get(_char3)||null}function closingToOpeningBracket(_char4){parse$1();return closeToOpen.get(_char4)||null}function getCanonicalBracket(_char5){parse$1();return canonical.get(_char5)||null}function parse(){if(!mirrorMap){var ref=parseCharacterMap(\"14\\x3e1,j\\x3e2,t\\x3e2,u\\x3e2,1a\\x3eg,2v3\\x3e1,1\\x3e1,1ge\\x3e1,1wd\\x3e1,b\\x3e1,1j\\x3e1,f\\x3e1,ai\\x3e3,-2\\x3e3,+1,8\\x3e1k0,-1jq\\x3e1y7,-1y6\\x3e1hf,-1he\\x3e1h6,-1h5\\x3e1ha,-1h8\\x3e1qi,-1pu\\x3e1,6\\x3e3u,-3s\\x3e7,6\\x3e1,1\\x3e1,f\\x3e1,1\\x3e1,+2,3\\x3e1,1\\x3e1,+13,4\\x3e1,1\\x3e1,6\\x3e1eo,-1ee\\x3e1,3\\x3e1mg,-1me\\x3e1mk,-1mj\\x3e1mi,-1mg\\x3e1mi,-1md\\x3e1,1\\x3e1,+2,1\\x3e10k,-103\\x3e1,1\\x3e1,4\\x3e1,5\\x3e1,1\\x3e1,+10,3\\x3e1,1\\x3e8,-7\\x3e8,+1,-6\\x3e7,+1,a\\x3e1,1\\x3e1,u\\x3e1,u6\\x3e1,1\\x3e1,+5,26\\x3e1,1\\x3e1,2\\x3e1,2\\x3e2,8\\x3e1,7\\x3e1,4\\x3e1,1\\x3e1,+5,b8\\x3e1,1\\x3e1,+3,1\\x3e3,-2\\x3e1,2\\x3e1,1\\x3e1,+2,c\\x3e1,3\\x3e1,1\\x3e1,+2,h\\x3e1,3\\x3e1,a\\x3e1,1\\x3e1,2\\x3e1,3\\x3e1,1\\x3e1,d\\x3e1,f\\x3e1,3\\x3e1,1a\\x3e1,1\\x3e1,6\\x3e1,7\\x3e1,13\\x3e1,k\\x3e1,1\\x3e1,+19,4\\x3e1,1\\x3e1,+2,2\\x3e1,1\\x3e1,+18,m\\x3e1,a\\x3e1,1\\x3e1,lk\\x3e1,1\\x3e1,4\\x3e1,2\\x3e1,f\\x3e1,3\\x3e1,1\\x3e1,+3,db\\x3e1,1\\x3e1,+3,3\\x3e1,1\\x3e1,+2,14qm\\x3e1,1\\x3e1,+1,6\\x3e1,4j\\x3e1,j\\x3e2,t\\x3e2,u\\x3e2,2\\x3e1,+1\",\n!0),map=ref.map;ref.reverseMap.forEach(function(value,key){map.set(key,value)});mirrorMap=map}}function getMirroredCharacter(_char7){parse();return mirrorMap.get(_char7)||null}function getReorderSegments(string,embeddingLevelsResult,start,end){var strLen=string.length;start=Math.max(0,null==start?0:+start);end=Math.min(strLen-1,null==end?strLen-1:+end);var segments=[];embeddingLevelsResult.paragraphs.forEach(function(paragraph){var lineStart=Math.max(start,paragraph.start),lineEnd=Math.min(end,paragraph.end);\nif(lineStart<lineEnd){for(var lineLevels=embeddingLevelsResult.levels.slice(lineStart,lineEnd+1);lineEnd>=lineStart&&getBidiCharType(string[lineEnd])&TRAILING_TYPES;lineEnd--)lineLevels[lineEnd]=paragraph.level;lineStart=paragraph.level;paragraph=Infinity;for(lineEnd=0;lineEnd<lineLevels.length;lineEnd++){var level=lineLevels[lineEnd];level>lineStart&&(lineStart=level);level<paragraph&&(paragraph=level|1)}for(;lineStart>=paragraph;lineStart--)for(lineEnd=0;lineEnd<lineLevels.length;lineEnd++)if(lineLevels[lineEnd]>=\nlineStart){for(level=lineEnd;lineEnd+1<lineLevels.length&&lineLevels[lineEnd+1]>=lineStart;)lineEnd++;lineEnd>level&&segments.push([level+start,lineEnd+start])}}});return segments}function getReorderedIndices(string,embedLevelsResult,start,end$jscomp$0){embedLevelsResult=getReorderSegments(string,embedLevelsResult,start,end$jscomp$0);var indices=[];for(start=0;start<string.length;start++)indices[start]=start;embedLevelsResult.forEach(function(ref){var end=ref[1];ref=indices.slice(ref[0],end+1);for(var i=\nref.length;i--;)indices[end-i]=ref[i]});return indices}var DATA={R:\"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",EN:\"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",ES:\"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",ET:\"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",AN:\"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",CS:\"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\nB:\"a,3,f+2,2v,690\",S:\"9,2,k\",WS:\"c,k,4f4,1vk+a,u,1j,335\",ON:\"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\nBN:\"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",NSM:\"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\nAL:\"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",LRO:\"6ct\",RLO:\"6cu\",LRE:\"6cq\",RLE:\"6cr\",PDF:\"6cs\",LRI:\"6ee\",RLI:\"6ef\",FSI:\"6eg\",PDI:\"6eh\"},TYPES={},TYPES_TO_NAMES={};TYPES.L=1;TYPES_TO_NAMES[1]=\"L\";Object.keys(DATA).forEach(function(type,i){TYPES[type]=1<<i+1;TYPES_TO_NAMES[TYPES[type]]=type});Object.freeze(TYPES);var ISOLATE_INIT_TYPES=TYPES.LRI|TYPES.RLI|TYPES.FSI,STRONG_TYPES=TYPES.L|TYPES.R|TYPES.AL,NEUTRAL_ISOLATE_TYPES=\nTYPES.B|TYPES.S|TYPES.WS|TYPES.ON|TYPES.FSI|TYPES.LRI|TYPES.RLI|TYPES.PDI,BN_LIKE_TYPES=TYPES.BN|TYPES.RLE|TYPES.LRE|TYPES.RLO|TYPES.LRO|TYPES.PDF,TRAILING_TYPES=TYPES.S|TYPES.WS|TYPES.B|ISOLATE_INIT_TYPES|TYPES.PDI|BN_LIKE_TYPES,map$jscomp$0=null,data$1={pairs:\"14\\x3e1,1e\\x3e2,u\\x3e2,2wt\\x3e1,1\\x3e1,1ge\\x3e1,1wp\\x3e1,1j\\x3e1,f\\x3e1,hm\\x3e1,1\\x3e1,u\\x3e1,u6\\x3e1,1\\x3e1,+5,28\\x3e1,w\\x3e1,1\\x3e1,+3,b8\\x3e1,1\\x3e1,+3,1\\x3e3,-1\\x3e-1,3\\x3e1,1\\x3e1,+2,1s\\x3e1,1\\x3e1,x\\x3e1,th\\x3e1,1\\x3e1,+2,db\\x3e1,1\\x3e1,+3,3\\x3e1,1\\x3e1,+2,14qm\\x3e1,1\\x3e1,+1,4q\\x3e1,1e\\x3e2,u\\x3e2,2\\x3e1,+1\",\ncanonical:\"6f1\\x3e-6dx,6dy\\x3e-6dx,6ec\\x3e-6ed,6ee\\x3e-6ed,6ww\\x3e2jj,-2ji\\x3e2jj,14r4\\x3e-1e7l,1e7m\\x3e-1e7l,1e7m\\x3e-1e5c,1e5d\\x3e-1e5b,1e5c\\x3e-14qx,14qy\\x3e-14qx,14vn\\x3e-1ecg,1ech\\x3e-1ecg,1edu\\x3e-1ecg,1eci\\x3e-1ecg,1eda\\x3e-1ecg,1eci\\x3e-1ecg,1eci\\x3e-168q,168r\\x3e-168q,168s\\x3e-14ye,14yf\\x3e-14ye\"},openToClose,closeToOpen,canonical,TYPE_L=TYPES.L,TYPE_R=TYPES.R,TYPE_EN=TYPES.EN,TYPE_ES=TYPES.ES,TYPE_ET=TYPES.ET,TYPE_AN=TYPES.AN,TYPE_CS=TYPES.CS,TYPE_B=TYPES.B,TYPE_S=TYPES.S,TYPE_ON=TYPES.ON,\nTYPE_BN=TYPES.BN,TYPE_NSM=TYPES.NSM,TYPE_AL=TYPES.AL,TYPE_LRO=TYPES.LRO,TYPE_RLO=TYPES.RLO,TYPE_LRE=TYPES.LRE,TYPE_RLE=TYPES.RLE,TYPE_PDF=TYPES.PDF,TYPE_LRI=TYPES.LRI,TYPE_RLI=TYPES.RLI,TYPE_FSI=TYPES.FSI,TYPE_PDI=TYPES.PDI,mirrorMap;exports.closingToOpeningBracket=closingToOpeningBracket;exports.getBidiCharType=getBidiCharType;exports.getBidiCharTypeName=function(_char2){return TYPES_TO_NAMES[getBidiCharType(_char2)]};exports.getCanonicalBracket=getCanonicalBracket;exports.getEmbeddingLevels=function(string,\nbaseDirection){function changeCharType(i,type){var oldType=charTypes[i];charTypes[i]=type;charTypeCounts.set(oldType,charTypeCounts.get(oldType)-1);oldType&NEUTRAL_ISOLATE_TYPES&&charTypeCounts.set(NEUTRAL_ISOLATE_TYPES,charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)-1);charTypeCounts.set(type,(charTypeCounts.get(type)||0)+1);type&NEUTRAL_ISOLATE_TYPES&&charTypeCounts.set(NEUTRAL_ISOLATE_TYPES,(charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)||0)+1)}function determineAutoEmbedLevel(start,isFSI){for(var i=start;i<\nstring.length;i++){start=charTypes[i];if(start&(TYPE_R|TYPE_AL))return 1;if(start&(TYPE_B|TYPE_L)||isFSI&&start===TYPE_PDI)break;if(start&ISOLATE_INIT_TYPES){a:{start=1;for(i+=1;i<string.length;i++){var charType=charTypes[i];if(charType&TYPE_B)break;if(charType&TYPE_PDI){if(0===--start){start=i;break a}}else charType&ISOLATE_INIT_TYPES&&start++}start=-1}i=-1===start?string.length:start}}return 0}function getEmbedDirection(i){return embedLevels[i]&1?TYPE_R:TYPE_L}for(var charTypes=new Uint32Array(string.length),\ni$jscomp$0=0;i$jscomp$0<string.length;i$jscomp$0++)charTypes[i$jscomp$0]=getBidiCharType(string[i$jscomp$0]);for(var charTypeCounts=new Map,embedLevels=new Uint8Array(string.length),isolationPairs=new Map,paragraphs=[],paragraph=null,i$1=0;i$1<string.length;i$1++)paragraph||paragraphs.push(paragraph={start:i$1,end:string.length-1,level:\"rtl\"===baseDirection?1:\"ltr\"===baseDirection?0:determineAutoEmbedLevel(i$1,!1)}),charTypes[i$1]&TYPE_B&&(paragraph.end=i$1,paragraph=null);for(var FORMATTING_TYPES=\nTYPE_RLE|TYPE_LRE|TYPE_RLO|TYPE_LRO|ISOLATE_INIT_TYPES|TYPE_PDI|TYPE_PDF|TYPE_B,nextEven=function(n){return n+(n&1?1:2)},nextOdd=function(n){return n+(n&1?2:1)},paraIdx=0;paraIdx<paragraphs.length;paraIdx++){paragraph=paragraphs[paraIdx];var statusStack=[{_level:paragraph.level,_override:0,_isolate:0}],stackTop=void 0,overflowIsolateCount=0,overflowEmbeddingCount=0,validIsolateCount=0;charTypeCounts.clear();for(var i$2=paragraph.start;i$2<=paragraph.end;i$2++){var charType=charTypes[i$2];stackTop=\nstatusStack[statusStack.length-1];charTypeCounts.set(charType,(charTypeCounts.get(charType)||0)+1);charType&NEUTRAL_ISOLATE_TYPES&&charTypeCounts.set(NEUTRAL_ISOLATE_TYPES,(charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)||0)+1);if(charType&FORMATTING_TYPES)if(charType&(TYPE_RLE|TYPE_LRE)){embedLevels[i$2]=stackTop._level;var level=(charType===TYPE_RLE?nextOdd:nextEven)(stackTop._level);125>=level&&!overflowIsolateCount&&!overflowEmbeddingCount?statusStack.push({_level:level,_override:0,_isolate:0}):overflowIsolateCount||\noverflowEmbeddingCount++}else if(charType&(TYPE_RLO|TYPE_LRO)){embedLevels[i$2]=stackTop._level;var level$1=(charType===TYPE_RLO?nextOdd:nextEven)(stackTop._level);125>=level$1&&!overflowIsolateCount&&!overflowEmbeddingCount?statusStack.push({_level:level$1,_override:charType&TYPE_RLO?TYPE_R:TYPE_L,_isolate:0}):overflowIsolateCount||overflowEmbeddingCount++}else if(charType&ISOLATE_INIT_TYPES){charType&TYPE_FSI&&(charType=1===determineAutoEmbedLevel(i$2+1,!0)?TYPE_RLI:TYPE_LRI);embedLevels[i$2]=stackTop._level;\nstackTop._override&&changeCharType(i$2,stackTop._override);var level$2=(charType===TYPE_RLI?nextOdd:nextEven)(stackTop._level);125>=level$2&&0===overflowIsolateCount&&0===overflowEmbeddingCount?(validIsolateCount++,statusStack.push({_level:level$2,_override:0,_isolate:1,_isolInitIndex:i$2})):overflowIsolateCount++}else if(charType&TYPE_PDI){if(0<overflowIsolateCount)overflowIsolateCount--;else if(0<validIsolateCount){for(overflowEmbeddingCount=0;!statusStack[statusStack.length-1]._isolate;)statusStack.pop();\nvar isolInitIndex=statusStack[statusStack.length-1]._isolInitIndex;null!=isolInitIndex&&(isolationPairs.set(isolInitIndex,i$2),isolationPairs.set(i$2,isolInitIndex));statusStack.pop();validIsolateCount--}stackTop=statusStack[statusStack.length-1];embedLevels[i$2]=stackTop._level;stackTop._override&&changeCharType(i$2,stackTop._override)}else charType&TYPE_PDF?(0===overflowIsolateCount&&(0<overflowEmbeddingCount?overflowEmbeddingCount--:!stackTop._isolate&&1<statusStack.length&&(statusStack.pop(),\nstackTop=statusStack[statusStack.length-1])),embedLevels[i$2]=stackTop._level):charType&TYPE_B&&(embedLevels[i$2]=paragraph.level);else embedLevels[i$2]=stackTop._level,stackTop._override&&charType!==TYPE_BN&&changeCharType(i$2,stackTop._override)}for(var levelRuns=[],currentRun=null,i$3=paragraph.start;i$3<=paragraph.end;i$3++){var charType$1=charTypes[i$3];if(!(charType$1&BN_LIKE_TYPES)){var lvl=embedLevels[i$3],isIsolInit=charType$1&ISOLATE_INIT_TYPES,isPDI=charType$1===TYPE_PDI;currentRun&&lvl===\ncurrentRun._level?(currentRun._end=i$3,currentRun._endsWithIsolInit=isIsolInit):levelRuns.push(currentRun={_start:i$3,_end:i$3,_level:lvl,_startsWithPDI:isPDI,_endsWithIsolInit:isIsolInit})}}for(var isolatingRunSeqs=[],runIdx=0;runIdx<levelRuns.length;runIdx++){var run=levelRuns[runIdx];if(!run._startsWithPDI||run._startsWithPDI&&!isolationPairs.has(run._start)){for(var seqRuns=[currentRun=run],pdiIndex=void 0;currentRun&&currentRun._endsWithIsolInit&&null!=(pdiIndex=isolationPairs.get(currentRun._end));)for(var i$4=\nrunIdx+1;i$4<levelRuns.length;i$4++)if(levelRuns[i$4]._start===pdiIndex){seqRuns.push(currentRun=levelRuns[i$4]);break}for(var seqIndices=[],i$5=0;i$5<seqRuns.length;i$5++)for(var run$1=seqRuns[i$5],j=run$1._start;j<=run$1._end;j++)seqIndices.push(j);for(var firstLevel=embedLevels[seqIndices[0]],prevLevel=paragraph.level,i$6=seqIndices[0]-1;0<=i$6;i$6--)if(!(charTypes[i$6]&BN_LIKE_TYPES)){prevLevel=embedLevels[i$6];break}var lastIndex=seqIndices[seqIndices.length-1],lastLevel=embedLevels[lastIndex],\nnextLevel=paragraph.level;if(!(charTypes[lastIndex]&ISOLATE_INIT_TYPES))for(var i$7=lastIndex+1;i$7<=paragraph.end;i$7++)if(!(charTypes[i$7]&BN_LIKE_TYPES)){nextLevel=embedLevels[i$7];break}isolatingRunSeqs.push({_seqIndices:seqIndices,_sosType:Math.max(prevLevel,firstLevel)%2?TYPE_R:TYPE_L,_eosType:Math.max(nextLevel,lastLevel)%2?TYPE_R:TYPE_L})}}for(var seqIdx=0;seqIdx<isolatingRunSeqs.length;seqIdx++){var ref=isolatingRunSeqs[seqIdx],seqIndices$1=ref._seqIndices,sosType=ref._sosType,eosType=ref._eosType;\nif(charTypeCounts.get(TYPE_NSM))for(var si=0;si<seqIndices$1.length;si++){var i$8=seqIndices$1[si];if(charTypes[i$8]&TYPE_NSM){for(var prevType=sosType,sj=si-1;0<=sj;sj--)if(!(charTypes[seqIndices$1[sj]]&BN_LIKE_TYPES)){prevType=charTypes[seqIndices$1[sj]];break}changeCharType(i$8,prevType&(ISOLATE_INIT_TYPES|TYPE_PDI)?TYPE_ON:prevType)}}if(charTypeCounts.get(TYPE_EN))for(var si$1=0;si$1<seqIndices$1.length;si$1++){var i$9=seqIndices$1[si$1];if(charTypes[i$9]&TYPE_EN)for(var sj$1=si$1-1;-1<=sj$1;sj$1--){var prevCharType=\n-1===sj$1?sosType:charTypes[seqIndices$1[sj$1]];if(prevCharType&STRONG_TYPES){prevCharType===TYPE_AL&&changeCharType(i$9,TYPE_AN);break}}}if(charTypeCounts.get(TYPE_AL))for(var si$2=0;si$2<seqIndices$1.length;si$2++){var i$10=seqIndices$1[si$2];charTypes[i$10]&TYPE_AL&&changeCharType(i$10,TYPE_R)}if(charTypeCounts.get(TYPE_ES)||charTypeCounts.get(TYPE_CS))for(var si$3=1;si$3<seqIndices$1.length-1;si$3++){var i$11=seqIndices$1[si$3];if(charTypes[i$11]&(TYPE_ES|TYPE_CS)){for(var prevType$1=0,nextType=\n0,sj$2=si$3-1;0<=sj$2&&(prevType$1=charTypes[seqIndices$1[sj$2]],prevType$1&BN_LIKE_TYPES);sj$2--);for(var sj$3=si$3+1;sj$3<seqIndices$1.length&&(nextType=charTypes[seqIndices$1[sj$3]],nextType&BN_LIKE_TYPES);sj$3++);prevType$1===nextType&&(charTypes[i$11]===TYPE_ES?prevType$1===TYPE_EN:prevType$1&(TYPE_EN|TYPE_AN))&&changeCharType(i$11,prevType$1)}}if(charTypeCounts.get(TYPE_EN))for(var si$4=0;si$4<seqIndices$1.length;si$4++)if(charTypes[seqIndices$1[si$4]]&TYPE_EN){for(var sj$4=si$4-1;0<=sj$4&&\ncharTypes[seqIndices$1[sj$4]]&(TYPE_ET|BN_LIKE_TYPES);sj$4--)changeCharType(seqIndices$1[sj$4],TYPE_EN);for(var sj$5=si$4+1;sj$5<seqIndices$1.length&&charTypes[seqIndices$1[sj$5]]&(TYPE_ET|BN_LIKE_TYPES);sj$5++)changeCharType(seqIndices$1[sj$5],TYPE_EN)}if(charTypeCounts.get(TYPE_ET)||charTypeCounts.get(TYPE_ES)||charTypeCounts.get(TYPE_CS))for(var si$5=0;si$5<seqIndices$1.length;si$5++){var i$13=seqIndices$1[si$5];if(charTypes[i$13]&(TYPE_ET|TYPE_ES|TYPE_CS)){changeCharType(i$13,TYPE_ON);for(var sj$6=\nsi$5-1;0<=sj$6&&charTypes[seqIndices$1[sj$6]]&BN_LIKE_TYPES;sj$6--)changeCharType(seqIndices$1[sj$6],TYPE_ON);for(var sj$7=si$5+1;sj$7<seqIndices$1.length&&charTypes[seqIndices$1[sj$7]]&BN_LIKE_TYPES;sj$7++)changeCharType(seqIndices$1[sj$7],TYPE_ON)}}if(charTypeCounts.get(TYPE_EN))for(var si$6=0,prevStrongType=sosType;si$6<seqIndices$1.length;si$6++){var i$14=seqIndices$1[si$6],type$jscomp$0=charTypes[i$14];type$jscomp$0&TYPE_EN?prevStrongType===TYPE_L&&changeCharType(i$14,TYPE_L):type$jscomp$0&STRONG_TYPES&&\n(prevStrongType=type$jscomp$0)}if(charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)){for(var R_TYPES_FOR_N_STEPS=TYPE_R|TYPE_EN|TYPE_AN,STRONG_TYPES_FOR_N_STEPS=R_TYPES_FOR_N_STEPS|TYPE_L,bracketPairs=[],openerStack=[],si$7=0;si$7<seqIndices$1.length;si$7++)if(charTypes[seqIndices$1[si$7]]&NEUTRAL_ISOLATE_TYPES){var _char6=string[seqIndices$1[si$7]],oppositeBracket=void 0;if(null!==openingToClosingBracket(_char6))if(63>openerStack.length)openerStack.push({\"char\":_char6,seqIndex:si$7});else break;else if(null!==\n(oppositeBracket=closingToOpeningBracket(_char6)))for(var stackIdx=openerStack.length-1;0<=stackIdx;stackIdx--){var stackChar=openerStack[stackIdx][\"char\"];if(stackChar===oppositeBracket||stackChar===closingToOpeningBracket(getCanonicalBracket(_char6))||openingToClosingBracket(getCanonicalBracket(stackChar))===_char6){bracketPairs.push([openerStack[stackIdx].seqIndex,si$7]);openerStack.length=stackIdx;break}}}bracketPairs.sort(function(a,b){return a[0]-b[0]});for(var pairIdx=0;pairIdx<bracketPairs.length;pairIdx++){for(var ref$1=\nbracketPairs[pairIdx],openSeqIdx=ref$1[0],closeSeqIdx=ref$1[1],foundStrongType=!1,useStrongType=0,si$8=openSeqIdx+1;si$8<closeSeqIdx;si$8++){var i$15=seqIndices$1[si$8];if(charTypes[i$15]&STRONG_TYPES_FOR_N_STEPS){foundStrongType=!0;var lr=charTypes[i$15]&R_TYPES_FOR_N_STEPS?TYPE_R:TYPE_L;if(lr===getEmbedDirection(i$15)){useStrongType=lr;break}}}if(foundStrongType&&!useStrongType){useStrongType=sosType;for(var si$9=openSeqIdx-1;0<=si$9;si$9--){var i$16=seqIndices$1[si$9];if(charTypes[i$16]&STRONG_TYPES_FOR_N_STEPS){var lr$1=\ncharTypes[i$16]&R_TYPES_FOR_N_STEPS?TYPE_R:TYPE_L;useStrongType=lr$1!==getEmbedDirection(i$16)?lr$1:getEmbedDirection(i$16);break}}}if(useStrongType){charTypes[seqIndices$1[openSeqIdx]]=charTypes[seqIndices$1[closeSeqIdx]]=useStrongType;if(useStrongType!==getEmbedDirection(seqIndices$1[openSeqIdx]))for(var si$10=openSeqIdx+1;si$10<seqIndices$1.length;si$10++)if(!(charTypes[seqIndices$1[si$10]]&BN_LIKE_TYPES)){getBidiCharType(string[seqIndices$1[si$10]])&TYPE_NSM&&(charTypes[seqIndices$1[si$10]]=useStrongType);\nbreak}if(useStrongType!==getEmbedDirection(seqIndices$1[closeSeqIdx]))for(var si$11=closeSeqIdx+1;si$11<seqIndices$1.length;si$11++)if(!(charTypes[seqIndices$1[si$11]]&BN_LIKE_TYPES)){getBidiCharType(string[seqIndices$1[si$11]])&TYPE_NSM&&(charTypes[seqIndices$1[si$11]]=useStrongType);break}}}for(var si$12=0;si$12<seqIndices$1.length;si$12++)if(charTypes[seqIndices$1[si$12]]&NEUTRAL_ISOLATE_TYPES){for(var niRunStart=si$12,niRunEnd=si$12,prevType$2=sosType,si2=si$12-1;0<=si2;si2--)if(charTypes[seqIndices$1[si2]]&\nBN_LIKE_TYPES)niRunStart=si2;else{prevType$2=charTypes[seqIndices$1[si2]]&R_TYPES_FOR_N_STEPS?TYPE_R:TYPE_L;break}for(var nextType$1=eosType,si2$1=si$12+1;si2$1<seqIndices$1.length;si2$1++)if(charTypes[seqIndices$1[si2$1]]&(NEUTRAL_ISOLATE_TYPES|BN_LIKE_TYPES))niRunEnd=si2$1;else{nextType$1=charTypes[seqIndices$1[si2$1]]&R_TYPES_FOR_N_STEPS?TYPE_R:TYPE_L;break}for(var sj$8=niRunStart;sj$8<=niRunEnd;sj$8++)charTypes[seqIndices$1[sj$8]]=prevType$2===nextType$1?prevType$2:getEmbedDirection(seqIndices$1[sj$8]);\nsi$12=niRunEnd}}}for(var i$17=paragraph.start;i$17<=paragraph.end;i$17++){var type$1=charTypes[i$17];embedLevels[i$17]&1?type$1&(TYPE_L|TYPE_EN|TYPE_AN)&&embedLevels[i$17]++:type$1&TYPE_R?embedLevels[i$17]++:type$1&(TYPE_AN|TYPE_EN)&&(embedLevels[i$17]+=2);type$1&BN_LIKE_TYPES&&(embedLevels[i$17]=0===i$17?paragraph.level:embedLevels[i$17-1]);if(i$17===paragraph.end||getBidiCharType(string[i$17])&(TYPE_S|TYPE_B))for(var j$1=i$17;0<=j$1&&getBidiCharType(string[j$1])&TRAILING_TYPES;j$1--)embedLevels[j$1]=\nparagraph.level}}return{levels:embedLevels,paragraphs}};exports.getMirroredCharacter=getMirroredCharacter;exports.getMirroredCharactersMap=function(string,embeddingLevels,start,end){var strLen=string.length;start=Math.max(0,null==start?0:+start);end=Math.min(strLen-1,null==end?strLen-1:+end);for(strLen=new Map;start<=end;start++)if(embeddingLevels[start]&1){var mirror=getMirroredCharacter(string[start]);null!==mirror&&strLen.set(start,mirror)}return strLen};exports.getReorderSegments=getReorderSegments;\nexports.getReorderedIndices=getReorderedIndices;exports.getReorderedString=function(string,embedLevelsResult,start,end){start=getReorderedIndices(string,embedLevelsResult,start,end);var chars=[].concat(string);start.forEach(function(charIndex,i){chars[i]=(embedLevelsResult.levels[charIndex]&1?getMirroredCharacter(string[charIndex]):null)||string[charIndex]});return chars.join(\"\")};exports.openingToClosingBracket=openingToClosingBracket;Object.defineProperty(exports,\"__esModule\",{value:!0});return exports}({})}}","~:source","shadow$provide[\"module$node_modules$bidi_js$dist$bidi_mjs\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nfunction bidiFactory() {\n  var bidi = function (exports) {\n    // Bidi character types data, auto generated\n    var DATA = {\n      \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n      \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n      \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n      \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n      \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n      \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n      \"B\": \"a,3,f+2,2v,690\",\n      \"S\": \"9,2,k\",\n      \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n      \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n      \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n      \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n      \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n      \"LRO\": \"6ct\",\n      \"RLO\": \"6cu\",\n      \"LRE\": \"6cq\",\n      \"RLE\": \"6cr\",\n      \"PDF\": \"6cs\",\n      \"LRI\": \"6ee\",\n      \"RLI\": \"6ef\",\n      \"FSI\": \"6eg\",\n      \"PDI\": \"6eh\"\n    };\n    var TYPES = {};\n    var TYPES_TO_NAMES = {};\n    TYPES.L = 1; //L is the default\n\n    TYPES_TO_NAMES[1] = 'L';\n    Object.keys(DATA).forEach(function (type, i) {\n      TYPES[type] = 1 << i + 1;\n      TYPES_TO_NAMES[TYPES[type]] = type;\n    });\n    Object.freeze(TYPES);\n    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n    var map = null;\n\n    function parseData() {\n      if (!map) {\n        //const start = performance.now()\n        map = new Map();\n\n        var loop = function loop(type) {\n          if (DATA.hasOwnProperty(type)) {\n            var lastCode = 0;\n            DATA[type].split(',').forEach(function (range) {\n              var ref = range.split('+');\n              var skip = ref[0];\n              var step = ref[1];\n              skip = parseInt(skip, 36);\n              step = step ? parseInt(step, 36) : 0;\n              map.set(lastCode += skip, TYPES[type]);\n\n              for (var i = 0; i < step; i++) {\n                map.set(++lastCode, TYPES[type]);\n              }\n            });\n          }\n        };\n\n        for (var type in DATA) {\n          loop(type);\n        } //console.log(`char types parsed in ${performance.now() - start}ms`)\n\n      }\n    }\n    /**\n     * @param {string} char\n     * @return {number}\n     */\n\n\n    function getBidiCharType(_char) {\n      parseData();\n      return map.get(_char.codePointAt(0)) || TYPES.L;\n    }\n\n    function getBidiCharTypeName(_char2) {\n      return TYPES_TO_NAMES[getBidiCharType(_char2)];\n    } // Bidi bracket pairs data, auto generated\n\n\n    var data$1 = {\n      \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n      \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n    };\n    /**\n     * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n     * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n     * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n     * @param {string} encodedString\n     * @param {boolean} includeReverse - true if you want reverseMap in the output\n     * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n     */\n\n    function parseCharacterMap(encodedString, includeReverse) {\n      var radix = 36;\n      var lastCode = 0;\n      var map = new Map();\n      var reverseMap = includeReverse && new Map();\n      var prevPair;\n      encodedString.split(',').forEach(function visit(entry) {\n        if (entry.indexOf('+') !== -1) {\n          for (var i = +entry; i--;) {\n            visit(prevPair);\n          }\n        } else {\n          prevPair = entry;\n          var ref = entry.split('>');\n          var a = ref[0];\n          var b = ref[1];\n          a = String.fromCodePoint(lastCode += parseInt(a, radix));\n          b = String.fromCodePoint(lastCode += parseInt(b, radix));\n          map.set(a, b);\n          includeReverse && reverseMap.set(b, a);\n        }\n      });\n      return {\n        map: map,\n        reverseMap: reverseMap\n      };\n    }\n\n    var openToClose, closeToOpen, canonical;\n\n    function parse$1() {\n      if (!openToClose) {\n        //const start = performance.now()\n        var ref = parseCharacterMap(data$1.pairs, true);\n        var map = ref.map;\n        var reverseMap = ref.reverseMap;\n        openToClose = map;\n        closeToOpen = reverseMap;\n        canonical = parseCharacterMap(data$1.canonical, false).map; //console.log(`brackets parsed in ${performance.now() - start}ms`)\n      }\n    }\n\n    function openingToClosingBracket(_char3) {\n      parse$1();\n      return openToClose.get(_char3) || null;\n    }\n\n    function closingToOpeningBracket(_char4) {\n      parse$1();\n      return closeToOpen.get(_char4) || null;\n    }\n\n    function getCanonicalBracket(_char5) {\n      parse$1();\n      return canonical.get(_char5) || null;\n    } // Local type aliases\n\n\n    var TYPE_L = TYPES.L;\n    var TYPE_R = TYPES.R;\n    var TYPE_EN = TYPES.EN;\n    var TYPE_ES = TYPES.ES;\n    var TYPE_ET = TYPES.ET;\n    var TYPE_AN = TYPES.AN;\n    var TYPE_CS = TYPES.CS;\n    var TYPE_B = TYPES.B;\n    var TYPE_S = TYPES.S;\n    var TYPE_ON = TYPES.ON;\n    var TYPE_BN = TYPES.BN;\n    var TYPE_NSM = TYPES.NSM;\n    var TYPE_AL = TYPES.AL;\n    var TYPE_LRO = TYPES.LRO;\n    var TYPE_RLO = TYPES.RLO;\n    var TYPE_LRE = TYPES.LRE;\n    var TYPE_RLE = TYPES.RLE;\n    var TYPE_PDF = TYPES.PDF;\n    var TYPE_LRI = TYPES.LRI;\n    var TYPE_RLI = TYPES.RLI;\n    var TYPE_FSI = TYPES.FSI;\n    var TYPE_PDI = TYPES.PDI;\n    /**\n     * @typedef {object} GetEmbeddingLevelsResult\n     * @property {{start, end, level}[]} paragraphs\n     * @property {Uint8Array} levels\n     */\n\n    /**\n     * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n     * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n     * base embedding level.\n     *\n     * @param {string} string - The input string\n     * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n     *        otherwise a direction will be chosen automatically from each paragraph's contents.\n     * @return {GetEmbeddingLevelsResult}\n     */\n\n    function getEmbeddingLevels(string, baseDirection) {\n      var MAX_DEPTH = 125; // Start by mapping all characters to their unicode type, as a bitmask integer\n\n      var charTypes = new Uint32Array(string.length);\n\n      for (var i = 0; i < string.length; i++) {\n        charTypes[i] = getBidiCharType(string[i]);\n      }\n\n      var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n\n      function changeCharType(i, type) {\n        var oldType = charTypes[i];\n        charTypes[i] = type;\n        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n\n        if (oldType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n        }\n\n        charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n\n        if (type & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n      }\n\n      var embedLevels = new Uint8Array(string.length);\n      var isolationPairs = new Map(); //init->pdi and pdi->init\n      // === 3.3.1 The Paragraph Level ===\n      // 3.3.1 P1: Split the text into paragraphs\n\n      var paragraphs = []; // [{start, end, level}, ...]\n\n      var paragraph = null;\n\n      for (var i$1 = 0; i$1 < string.length; i$1++) {\n        if (!paragraph) {\n          paragraphs.push(paragraph = {\n            start: i$1,\n            end: string.length - 1,\n            // 3.3.1 P2-P3: Determine the paragraph level\n            level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n          });\n        }\n\n        if (charTypes[i$1] & TYPE_B) {\n          paragraph.end = i$1;\n          paragraph = null;\n        }\n      }\n\n      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n\n      var nextEven = function nextEven(n) {\n        return n + (n & 1 ? 1 : 2);\n      };\n\n      var nextOdd = function nextOdd(n) {\n        return n + (n & 1 ? 2 : 1);\n      }; // Everything from here on will operate per paragraph.\n\n\n      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n        paragraph = paragraphs[paraIdx];\n        var statusStack = [{\n          _level: paragraph.level,\n          _override: 0,\n          //0=neutral, 1=L, 2=R\n          _isolate: 0 //bool\n\n        }];\n        var stackTop = void 0;\n        var overflowIsolateCount = 0;\n        var overflowEmbeddingCount = 0;\n        var validIsolateCount = 0;\n        charTypeCounts.clear(); // === 3.3.2 Explicit Levels and Directions ===\n\n        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n          var charType = charTypes[i$2];\n          stackTop = statusStack[statusStack.length - 1]; // Set initial counts\n\n          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n\n          if (charType & NEUTRAL_ISOLATE_TYPES) {\n            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n          } // Explicit Embeddings: 3.3.2 X2 - X3\n\n\n          if (charType & FORMATTING_TYPES) {\n            //prefilter all formatters\n            if (charType & (TYPE_RLE | TYPE_LRE)) {\n              embedLevels[i$2] = stackTop._level; // 5.2\n\n              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n\n              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n                statusStack.push({\n                  _level: level,\n                  _override: 0,\n                  _isolate: 0\n                });\n              } else if (!overflowIsolateCount) {\n                overflowEmbeddingCount++;\n              }\n            } // Explicit Overrides: 3.3.2 X4 - X5\n            else if (charType & (TYPE_RLO | TYPE_LRO)) {\n                embedLevels[i$2] = stackTop._level; // 5.2\n\n                var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n\n                if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n                  statusStack.push({\n                    _level: level$1,\n                    _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,\n                    _isolate: 0\n                  });\n                } else if (!overflowIsolateCount) {\n                  overflowEmbeddingCount++;\n                }\n              } // Isolates: 3.3.2 X5a - X5c\n              else if (charType & ISOLATE_INIT_TYPES) {\n                  // X5c - FSI becomes either RLI or LRI\n                  if (charType & TYPE_FSI) {\n                    charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n                  }\n\n                  embedLevels[i$2] = stackTop._level;\n\n                  if (stackTop._override) {\n                    changeCharType(i$2, stackTop._override);\n                  }\n\n                  var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n\n                  if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n                    validIsolateCount++;\n                    statusStack.push({\n                      _level: level$2,\n                      _override: 0,\n                      _isolate: 1,\n                      _isolInitIndex: i$2\n                    });\n                  } else {\n                    overflowIsolateCount++;\n                  }\n                } // Terminating Isolates: 3.3.2 X6a\n                else if (charType & TYPE_PDI) {\n                    if (overflowIsolateCount > 0) {\n                      overflowIsolateCount--;\n                    } else if (validIsolateCount > 0) {\n                      overflowEmbeddingCount = 0;\n\n                      while (!statusStack[statusStack.length - 1]._isolate) {\n                        statusStack.pop();\n                      } // Add to isolation pairs bidirectional mapping:\n\n\n                      var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n\n                      if (isolInitIndex != null) {\n                        isolationPairs.set(isolInitIndex, i$2);\n                        isolationPairs.set(i$2, isolInitIndex);\n                      }\n\n                      statusStack.pop();\n                      validIsolateCount--;\n                    }\n\n                    stackTop = statusStack[statusStack.length - 1];\n                    embedLevels[i$2] = stackTop._level;\n\n                    if (stackTop._override) {\n                      changeCharType(i$2, stackTop._override);\n                    }\n                  } // Terminating Embeddings and Overrides: 3.3.2 X7\n                  else if (charType & TYPE_PDF) {\n                      if (overflowIsolateCount === 0) {\n                        if (overflowEmbeddingCount > 0) {\n                          overflowEmbeddingCount--;\n                        } else if (!stackTop._isolate && statusStack.length > 1) {\n                          statusStack.pop();\n                          stackTop = statusStack[statusStack.length - 1];\n                        }\n                      }\n\n                      embedLevels[i$2] = stackTop._level; // 5.2\n                    } // End of Paragraph: 3.3.2 X8\n                    else if (charType & TYPE_B) {\n                        embedLevels[i$2] = paragraph.level;\n                      }\n          } // Non-formatting characters: 3.3.2 X6\n          else {\n              embedLevels[i$2] = stackTop._level; // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n\n              if (stackTop._override && charType !== TYPE_BN) {\n                changeCharType(i$2, stackTop._override);\n              }\n            }\n        } // === 3.3.3 Preparations for Implicit Processing ===\n        // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n        // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n        // easily ignore them all from here on out.\n        // 3.3.3 X10\n        // Compute the set of isolating run sequences as specified by BD13\n\n\n        var levelRuns = [];\n        var currentRun = null;\n\n        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n          var charType$1 = charTypes[i$3];\n\n          if (!(charType$1 & BN_LIKE_TYPES)) {\n            var lvl = embedLevels[i$3];\n            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n            var isPDI = charType$1 === TYPE_PDI;\n\n            if (currentRun && lvl === currentRun._level) {\n              currentRun._end = i$3;\n              currentRun._endsWithIsolInit = isIsolInit;\n            } else {\n              levelRuns.push(currentRun = {\n                _start: i$3,\n                _end: i$3,\n                _level: lvl,\n                _startsWithPDI: isPDI,\n                _endsWithIsolInit: isIsolInit\n              });\n            }\n          }\n        }\n\n        var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n\n        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n          var run = levelRuns[runIdx];\n\n          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {\n            var seqRuns = [currentRun = run];\n\n            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n                if (levelRuns[i$4]._start === pdiIndex) {\n                  seqRuns.push(currentRun = levelRuns[i$4]);\n                  break;\n                }\n              }\n            } // build flat list of indices across all runs:\n\n\n            var seqIndices = [];\n\n            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n              var run$1 = seqRuns[i$5];\n\n              for (var j = run$1._start; j <= run$1._end; j++) {\n                seqIndices.push(j);\n              }\n            } // determine the sos/eos types:\n\n\n            var firstLevel = embedLevels[seqIndices[0]];\n            var prevLevel = paragraph.level;\n\n            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {\n                //5.2\n                prevLevel = embedLevels[i$6];\n                break;\n              }\n            }\n\n            var lastIndex = seqIndices[seqIndices.length - 1];\n            var lastLevel = embedLevels[lastIndex];\n            var nextLevel = paragraph.level;\n\n            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {\n                  //5.2\n                  nextLevel = embedLevels[i$7];\n                  break;\n                }\n              }\n            }\n\n            isolatingRunSeqs.push({\n              _seqIndices: seqIndices,\n              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n            });\n          }\n        } // The next steps are done per isolating run sequence\n\n\n        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n          var ref = isolatingRunSeqs[seqIdx];\n          var seqIndices$1 = ref._seqIndices;\n          var sosType = ref._sosType;\n          var eosType = ref._eosType; // === 3.3.4 Resolving Weak Types ===\n          // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n          // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n          // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n\n          if (charTypeCounts.get(TYPE_NSM)) {\n            for (var si = 0; si < seqIndices$1.length; si++) {\n              var i$8 = seqIndices$1[si];\n\n              if (charTypes[i$8] & TYPE_NSM) {\n                var prevType = sosType;\n\n                for (var sj = si - 1; sj >= 0; sj--) {\n                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {\n                    //5.2 scan back to first non-BN\n                    prevType = charTypes[seqIndices$1[sj]];\n                    break;\n                  }\n                }\n\n                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);\n              }\n            }\n          } // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n          // is found. If an AL is found, change the type of the European number to Arabic number.\n\n\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n              var i$9 = seqIndices$1[si$1];\n\n              if (charTypes[i$9] & TYPE_EN) {\n                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n\n                  if (prevCharType & STRONG_TYPES) {\n                    if (prevCharType === TYPE_AL) {\n                      changeCharType(i$9, TYPE_AN);\n                    }\n\n                    break;\n                  }\n                }\n              }\n            }\n          } // W3. Change all ALs to R\n\n\n          if (charTypeCounts.get(TYPE_AL)) {\n            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n              var i$10 = seqIndices$1[si$2];\n\n              if (charTypes[i$10] & TYPE_AL) {\n                changeCharType(i$10, TYPE_R);\n              }\n            }\n          } // W4. A single European separator between two European numbers changes to a European number. A single common\n          // separator between two numbers of the same type changes to that type.\n\n\n          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n              var i$11 = seqIndices$1[si$3];\n\n              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n                var prevType$1 = 0,\n                    nextType = 0;\n\n                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                  prevType$1 = charTypes[seqIndices$1[sj$2]];\n\n                  if (!(prevType$1 & BN_LIKE_TYPES)) {\n                    //5.2\n                    break;\n                  }\n                }\n\n                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                  nextType = charTypes[seqIndices$1[sj$3]];\n\n                  if (!(nextType & BN_LIKE_TYPES)) {\n                    //5.2\n                    break;\n                  }\n                }\n\n                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {\n                  changeCharType(i$11, prevType$1);\n                }\n              }\n            }\n          } // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n\n\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n              var i$12 = seqIndices$1[si$4];\n\n              if (charTypes[i$12] & TYPE_EN) {\n                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {\n                  changeCharType(seqIndices$1[sj$4], TYPE_EN);\n                }\n\n                for (var sj$5 = si$4 + 1; sj$5 < seqIndices$1.length && charTypes[seqIndices$1[sj$5]] & (TYPE_ET | BN_LIKE_TYPES); sj$5++) {\n                  changeCharType(seqIndices$1[sj$5], TYPE_EN);\n                }\n              }\n            }\n          } // W6. Otherwise, separators and terminators change to Other Neutral.\n\n\n          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n              var i$13 = seqIndices$1[si$5];\n\n              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n                changeCharType(i$13, TYPE_ON); // 5.2 transform adjacent BNs too:\n\n                for (var sj$6 = si$5 - 1; sj$6 >= 0 && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6--) {\n                  changeCharType(seqIndices$1[sj$6], TYPE_ON);\n                }\n\n                for (var sj$7 = si$5 + 1; sj$7 < seqIndices$1.length && charTypes[seqIndices$1[sj$7]] & BN_LIKE_TYPES; sj$7++) {\n                  changeCharType(seqIndices$1[sj$7], TYPE_ON);\n                }\n              }\n            }\n          } // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n          // is found. If an L is found, then change the type of the European number to L.\n          // NOTE: implemented in single forward pass for efficiency\n\n\n          if (charTypeCounts.get(TYPE_EN)) {\n            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n              var i$14 = seqIndices$1[si$6];\n              var type = charTypes[i$14];\n\n              if (type & TYPE_EN) {\n                if (prevStrongType === TYPE_L) {\n                  changeCharType(i$14, TYPE_L);\n                }\n              } else if (type & STRONG_TYPES) {\n                prevStrongType = type;\n              }\n            }\n          } // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n\n          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n            // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n            // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n            // types EN and AN are treated as R.\n            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;\n            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L; // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n\n            var bracketPairs = [];\n            {\n              var openerStack = [];\n\n              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n                // NOTE: for any potential bracket character we also test that it still carries a NI\n                // type, as that may have been changed earlier. This doesn't seem to be explicitly\n                // called out in the spec, but is required for passage of certain tests.\n                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                  var _char6 = string[seqIndices$1[si$7]];\n                  var oppositeBracket = void 0; // Opening bracket\n\n                  if (openingToClosingBracket(_char6) !== null) {\n                    if (openerStack.length < 63) {\n                      openerStack.push({\n                        \"char\": _char6,\n                        seqIndex: si$7\n                      });\n                    } else {\n                      break;\n                    }\n                  } // Closing bracket\n                  else if ((oppositeBracket = closingToOpeningBracket(_char6)) !== null) {\n                      for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                        var stackChar = openerStack[stackIdx][\"char\"];\n\n                        if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(_char6)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === _char6) {\n                          bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                          openerStack.length = stackIdx; //pop the matching bracket and all following\n\n                          break;\n                        }\n                      }\n                    }\n                }\n              }\n\n              bracketPairs.sort(function (a, b) {\n                return a[0] - b[0];\n              });\n            } // * For each bracket-pair element in the list of pairs of text positions\n\n            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n              var ref$1 = bracketPairs[pairIdx];\n              var openSeqIdx = ref$1[0];\n              var closeSeqIdx = ref$1[1]; // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n              // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n              // brackets in the pair to match the embedding direction.\n\n              var foundStrongType = false;\n              var useStrongType = 0;\n\n              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n                var i$15 = seqIndices$1[si$8];\n\n                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                  foundStrongType = true;\n                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n\n                  if (lr === getEmbedDirection(i$15)) {\n                    useStrongType = lr;\n                    break;\n                  }\n                }\n              } // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n              // for an established context with a preceding strong type by checking backwards before the opening paired\n              // bracket until the first strong type (L, R, or sos) is found.\n              //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n              //    set the type for both brackets in the pair to that direction.\n              //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n\n\n              if (foundStrongType && !useStrongType) {\n                useStrongType = sosType;\n\n                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                  var i$16 = seqIndices$1[si$9];\n\n                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n\n                    if (lr$1 !== getEmbedDirection(i$16)) {\n                      useStrongType = lr$1;\n                    } else {\n                      useStrongType = getEmbedDirection(i$16);\n                    }\n\n                    break;\n                  }\n                }\n              }\n\n              if (useStrongType) {\n                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType; // * Any number of characters that had original bidirectional character type NSM prior to the application\n                // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n                // the type of their preceding bracket.\n\n                if (useStrongType !== getEmbedDirection(seqIndices$1[openSeqIdx])) {\n                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                        charTypes[seqIndices$1[si$10]] = useStrongType;\n                      }\n\n                      break;\n                    }\n                  }\n                }\n\n                if (useStrongType !== getEmbedDirection(seqIndices$1[closeSeqIdx])) {\n                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                        charTypes[seqIndices$1[si$11]] = useStrongType;\n                      }\n\n                      break;\n                    }\n                  }\n                }\n              }\n            } // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n            // same direction.\n            // N2. Any remaining NIs take the embedding direction.\n\n\n            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n                var niRunStart = si$12,\n                    niRunEnd = si$12;\n                var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n\n                for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                    niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                  } else {\n                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n                    break;\n                  }\n                }\n\n                var nextType$1 = eosType;\n\n                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                    niRunEnd = si2$1;\n                  } else {\n                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\n                    break;\n                  }\n                }\n\n                for (var sj$8 = niRunStart; sj$8 <= niRunEnd; sj$8++) {\n                  charTypes[seqIndices$1[sj$8]] = prevType$2 === nextType$1 ? prevType$2 : getEmbedDirection(seqIndices$1[sj$8]);\n                }\n\n                si$12 = niRunEnd;\n              }\n            }\n          }\n        } // === 3.3.6 Resolving Implicit Levels ===\n\n\n        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n          var level$3 = embedLevels[i$17];\n          var type$1 = charTypes[i$17]; // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n\n          if (level$3 & 1) {\n            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n              embedLevels[i$17]++;\n            }\n          } // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n          // and those of type AN or EN go up two levels.\n          else {\n              if (type$1 & TYPE_R) {\n                embedLevels[i$17]++;\n              } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n                embedLevels[i$17] += 2;\n              }\n            } // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n          // and otherwise to the base level.\n\n\n          if (type$1 & BN_LIKE_TYPES) {\n            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n          } // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n          // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n          // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n\n\n          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {\n              embedLevels[j$1] = paragraph.level;\n            }\n          }\n        }\n      } // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n      // according to section 3.4 Reordering Resolved Levels\n\n\n      return {\n        levels: embedLevels,\n        paragraphs: paragraphs\n      };\n\n      function determineAutoEmbedLevel(start, isFSI) {\n        // 3.3.1 P2 - P3\n        for (var i = start; i < string.length; i++) {\n          var charType = charTypes[i];\n\n          if (charType & (TYPE_R | TYPE_AL)) {\n            return 1;\n          }\n\n          if (charType & (TYPE_B | TYPE_L) || isFSI && charType === TYPE_PDI) {\n            return 0;\n          }\n\n          if (charType & ISOLATE_INIT_TYPES) {\n            var pdi = indexOfMatchingPDI(i);\n            i = pdi === -1 ? string.length : pdi;\n          }\n        }\n\n        return 0;\n      }\n\n      function indexOfMatchingPDI(isolateStart) {\n        // 3.1.2 BD9\n        var isolationLevel = 1;\n\n        for (var i = isolateStart + 1; i < string.length; i++) {\n          var charType = charTypes[i];\n\n          if (charType & TYPE_B) {\n            break;\n          }\n\n          if (charType & TYPE_PDI) {\n            if (--isolationLevel === 0) {\n              return i;\n            }\n          } else if (charType & ISOLATE_INIT_TYPES) {\n            isolationLevel++;\n          }\n        }\n\n        return -1;\n      }\n\n      function getEmbedDirection(i) {\n        return embedLevels[i] & 1 ? TYPE_R : TYPE_L;\n      }\n    } // Bidi mirrored chars data, auto generated\n\n\n    var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n    var mirrorMap;\n\n    function parse() {\n      if (!mirrorMap) {\n        //const start = performance.now()\n        var ref = parseCharacterMap(data, true);\n        var map = ref.map;\n        var reverseMap = ref.reverseMap; // Combine both maps into one\n\n        reverseMap.forEach(function (value, key) {\n          map.set(key, value);\n        });\n        mirrorMap = map; //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n      }\n    }\n\n    function getMirroredCharacter(_char7) {\n      parse();\n      return mirrorMap.get(_char7) || null;\n    }\n    /**\n     * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n     * for any characters in right-to-left segments that have defined mirrored characters.\n     * @param string\n     * @param embeddingLevels\n     * @param [start]\n     * @param [end]\n     * @return {Map<number, string>}\n     */\n\n\n    function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n      var strLen = string.length;\n      start = Math.max(0, start == null ? 0 : +start);\n      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n      var map = new Map();\n\n      for (var i = start; i <= end; i++) {\n        if (embeddingLevels[i] & 1) {\n          //only odd (rtl) levels\n          var mirror = getMirroredCharacter(string[i]);\n\n          if (mirror !== null) {\n            map.set(i, mirror);\n          }\n        }\n      }\n\n      return map;\n    }\n    /**\n     * Given a start and end denoting a single line within a string, and a set of precalculated\n     * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n     * @param {string} string - the full input string\n     * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n     * @param {number} [start] - first character in a subset of the full string\n     * @param {number} [end] - last character in a subset of the full string\n     * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n     */\n\n\n    function getReorderSegments(string, embeddingLevelsResult, start, end) {\n      var strLen = string.length;\n      start = Math.max(0, start == null ? 0 : +start);\n      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n      var segments = [];\n      embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n        var lineStart = Math.max(start, paragraph.start);\n        var lineEnd = Math.min(end, paragraph.end);\n\n        if (lineStart < lineEnd) {\n          // Local slice for mutation\n          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1); // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n          // end of the line to the paragraph level.\n\n          for (var i = lineEnd; i >= lineStart && getBidiCharType(string[i]) & TRAILING_TYPES; i--) {\n            lineLevels[i] = paragraph.level;\n          } // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n          // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n\n\n          var maxLevel = paragraph.level;\n          var minOddLevel = Infinity;\n\n          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n            var level = lineLevels[i$1];\n\n            if (level > maxLevel) {\n              maxLevel = level;\n            }\n\n            if (level < minOddLevel) {\n              minOddLevel = level | 1;\n            }\n          }\n\n          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n              if (lineLevels[i$2] >= lvl) {\n                var segStart = i$2;\n\n                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                  i$2++;\n                }\n\n                if (i$2 > segStart) {\n                  segments.push([segStart + start, i$2 + start]);\n                }\n              }\n            }\n          }\n        }\n      });\n      return segments;\n    }\n    /**\n     * @param {string} string\n     * @param {GetEmbeddingLevelsResult} embedLevelsResult\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {string} the new string with bidi segments reordered\n     */\n\n\n    function getReorderedString(string, embedLevelsResult, start, end) {\n      var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n      var chars = [].concat(string);\n      indices.forEach(function (charIndex, i) {\n        chars[i] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];\n      });\n      return chars.join('');\n    }\n    /**\n     * @param {string} string\n     * @param {GetEmbeddingLevelsResult} embedLevelsResult\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {number[]} an array with character indices in their new bidi order\n     */\n\n\n    function getReorderedIndices(string, embedLevelsResult, start, end) {\n      var segments = getReorderSegments(string, embedLevelsResult, start, end); // Fill an array with indices\n\n      var indices = [];\n\n      for (var i = 0; i < string.length; i++) {\n        indices[i] = i;\n      } // Reverse each segment in order\n\n\n      segments.forEach(function (ref) {\n        var start = ref[0];\n        var end = ref[1];\n        var slice = indices.slice(start, end + 1);\n\n        for (var i = slice.length; i--;) {\n          indices[end - i] = slice[i];\n        }\n      });\n      return indices;\n    }\n\n    exports.closingToOpeningBracket = closingToOpeningBracket;\n    exports.getBidiCharType = getBidiCharType;\n    exports.getBidiCharTypeName = getBidiCharTypeName;\n    exports.getCanonicalBracket = getCanonicalBracket;\n    exports.getEmbeddingLevels = getEmbeddingLevels;\n    exports.getMirroredCharacter = getMirroredCharacter;\n    exports.getMirroredCharactersMap = getMirroredCharactersMap;\n    exports.getReorderSegments = getReorderSegments;\n    exports.getReorderedIndices = getReorderedIndices;\n    exports.getReorderedString = getReorderedString;\n    exports.openingToClosingBracket = openingToClosingBracket;\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    return exports;\n  }({});\n\n  return bidi;\n}\n\nvar _default = bidiFactory;\nexports[\"default\"] = _default;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["_override","map","getCanonicalBracket","closingToOpeningBracket","_end","L","getMirroredCharacter","getBidiCharType","__esModule","getEmbeddingLevels","_sosType","getReorderedString","openingToClosingBracket","_level","_eosType","_isolate","level","seqIndex","getBidiCharTypeName","value","getReorderSegments","start","getReorderedIndices","paragraphs","length","levels","_start","reverseMap","getMirroredCharactersMap","_startsWithPDI","_seqIndices","end","_endsWithIsolInit","_isolInitIndex"]],"~:compiled-at",1630917516100,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$bidi_js$dist$bidi_mjs.js\",\n\"lineCount\":40,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/bidi-js/dist/bidi.mjs\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$bidi_js$dist$bidi_mjs\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports[\\\"default\\\"] = void 0;\\n\\nfunction bidiFactory() {\\n  var bidi = function (exports) {\\n    // Bidi character types data, auto generated\\n    var DATA = {\\n      \\\"R\\\": \\\"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\\\",\\n      \\\"EN\\\": \\\"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\\\",\\n      \\\"ES\\\": \\\"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\\\",\\n      \\\"ET\\\": \\\"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\\\",\\n      \\\"AN\\\": \\\"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\\\",\\n      \\\"CS\\\": \\\"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\\\",\\n      \\\"B\\\": \\\"a,3,f+2,2v,690\\\",\\n      \\\"S\\\": \\\"9,2,k\\\",\\n      \\\"WS\\\": \\\"c,k,4f4,1vk+a,u,1j,335\\\",\\n      \\\"ON\\\": \\\"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\\\",\\n      \\\"BN\\\": \\\"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\\\",\\n      \\\"NSM\\\": \\\"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\\\",\\n      \\\"AL\\\": \\\"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\\\",\\n      \\\"LRO\\\": \\\"6ct\\\",\\n      \\\"RLO\\\": \\\"6cu\\\",\\n      \\\"LRE\\\": \\\"6cq\\\",\\n      \\\"RLE\\\": \\\"6cr\\\",\\n      \\\"PDF\\\": \\\"6cs\\\",\\n      \\\"LRI\\\": \\\"6ee\\\",\\n      \\\"RLI\\\": \\\"6ef\\\",\\n      \\\"FSI\\\": \\\"6eg\\\",\\n      \\\"PDI\\\": \\\"6eh\\\"\\n    };\\n    var TYPES = {};\\n    var TYPES_TO_NAMES = {};\\n    TYPES.L = 1; //L is the default\\n\\n    TYPES_TO_NAMES[1] = 'L';\\n    Object.keys(DATA).forEach(function (type, i) {\\n      TYPES[type] = 1 << i + 1;\\n      TYPES_TO_NAMES[TYPES[type]] = type;\\n    });\\n    Object.freeze(TYPES);\\n    var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\\n    var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\\n    var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\\n    var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\\n    var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\\n    var map = null;\\n\\n    function parseData() {\\n      if (!map) {\\n        //const start = performance.now()\\n        map = new Map();\\n\\n        var loop = function loop(type) {\\n          if (DATA.hasOwnProperty(type)) {\\n            var lastCode = 0;\\n            DATA[type].split(',').forEach(function (range) {\\n              var ref = range.split('+');\\n              var skip = ref[0];\\n              var step = ref[1];\\n              skip = parseInt(skip, 36);\\n              step = step ? parseInt(step, 36) : 0;\\n              map.set(lastCode += skip, TYPES[type]);\\n\\n              for (var i = 0; i < step; i++) {\\n                map.set(++lastCode, TYPES[type]);\\n              }\\n            });\\n          }\\n        };\\n\\n        for (var type in DATA) {\\n          loop(type);\\n        } //console.log(`char types parsed in ${performance.now() - start}ms`)\\n\\n      }\\n    }\\n    /**\\n     * @param {string} char\\n     * @return {number}\\n     */\\n\\n\\n    function getBidiCharType(_char) {\\n      parseData();\\n      return map.get(_char.codePointAt(0)) || TYPES.L;\\n    }\\n\\n    function getBidiCharTypeName(_char2) {\\n      return TYPES_TO_NAMES[getBidiCharType(_char2)];\\n    } // Bidi bracket pairs data, auto generated\\n\\n\\n    var data$1 = {\\n      \\\"pairs\\\": \\\"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\\\",\\n      \\\"canonical\\\": \\\"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\\\"\\n    };\\n    /**\\n     * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\\n     * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\\n     * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\\n     * @param {string} encodedString\\n     * @param {boolean} includeReverse - true if you want reverseMap in the output\\n     * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\\n     */\\n\\n    function parseCharacterMap(encodedString, includeReverse) {\\n      var radix = 36;\\n      var lastCode = 0;\\n      var map = new Map();\\n      var reverseMap = includeReverse && new Map();\\n      var prevPair;\\n      encodedString.split(',').forEach(function visit(entry) {\\n        if (entry.indexOf('+') !== -1) {\\n          for (var i = +entry; i--;) {\\n            visit(prevPair);\\n          }\\n        } else {\\n          prevPair = entry;\\n          var ref = entry.split('>');\\n          var a = ref[0];\\n          var b = ref[1];\\n          a = String.fromCodePoint(lastCode += parseInt(a, radix));\\n          b = String.fromCodePoint(lastCode += parseInt(b, radix));\\n          map.set(a, b);\\n          includeReverse && reverseMap.set(b, a);\\n        }\\n      });\\n      return {\\n        map: map,\\n        reverseMap: reverseMap\\n      };\\n    }\\n\\n    var openToClose, closeToOpen, canonical;\\n\\n    function parse$1() {\\n      if (!openToClose) {\\n        //const start = performance.now()\\n        var ref = parseCharacterMap(data$1.pairs, true);\\n        var map = ref.map;\\n        var reverseMap = ref.reverseMap;\\n        openToClose = map;\\n        closeToOpen = reverseMap;\\n        canonical = parseCharacterMap(data$1.canonical, false).map; //console.log(`brackets parsed in ${performance.now() - start}ms`)\\n      }\\n    }\\n\\n    function openingToClosingBracket(_char3) {\\n      parse$1();\\n      return openToClose.get(_char3) || null;\\n    }\\n\\n    function closingToOpeningBracket(_char4) {\\n      parse$1();\\n      return closeToOpen.get(_char4) || null;\\n    }\\n\\n    function getCanonicalBracket(_char5) {\\n      parse$1();\\n      return canonical.get(_char5) || null;\\n    } // Local type aliases\\n\\n\\n    var TYPE_L = TYPES.L;\\n    var TYPE_R = TYPES.R;\\n    var TYPE_EN = TYPES.EN;\\n    var TYPE_ES = TYPES.ES;\\n    var TYPE_ET = TYPES.ET;\\n    var TYPE_AN = TYPES.AN;\\n    var TYPE_CS = TYPES.CS;\\n    var TYPE_B = TYPES.B;\\n    var TYPE_S = TYPES.S;\\n    var TYPE_ON = TYPES.ON;\\n    var TYPE_BN = TYPES.BN;\\n    var TYPE_NSM = TYPES.NSM;\\n    var TYPE_AL = TYPES.AL;\\n    var TYPE_LRO = TYPES.LRO;\\n    var TYPE_RLO = TYPES.RLO;\\n    var TYPE_LRE = TYPES.LRE;\\n    var TYPE_RLE = TYPES.RLE;\\n    var TYPE_PDF = TYPES.PDF;\\n    var TYPE_LRI = TYPES.LRI;\\n    var TYPE_RLI = TYPES.RLI;\\n    var TYPE_FSI = TYPES.FSI;\\n    var TYPE_PDI = TYPES.PDI;\\n    /**\\n     * @typedef {object} GetEmbeddingLevelsResult\\n     * @property {{start, end, level}[]} paragraphs\\n     * @property {Uint8Array} levels\\n     */\\n\\n    /**\\n     * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\\n     * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\\n     * base embedding level.\\n     *\\n     * @param {string} string - The input string\\n     * @param {\\\"ltr\\\"|\\\"rtl\\\"|\\\"auto\\\"} [baseDirection] - Use \\\"ltr\\\" or \\\"rtl\\\" to force a base paragraph direction,\\n     *        otherwise a direction will be chosen automatically from each paragraph's contents.\\n     * @return {GetEmbeddingLevelsResult}\\n     */\\n\\n    function getEmbeddingLevels(string, baseDirection) {\\n      var MAX_DEPTH = 125; // Start by mapping all characters to their unicode type, as a bitmask integer\\n\\n      var charTypes = new Uint32Array(string.length);\\n\\n      for (var i = 0; i < string.length; i++) {\\n        charTypes[i] = getBidiCharType(string[i]);\\n      }\\n\\n      var charTypeCounts = new Map(); //will be cleared at start of each paragraph\\n\\n      function changeCharType(i, type) {\\n        var oldType = charTypes[i];\\n        charTypes[i] = type;\\n        charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\\n\\n        if (oldType & NEUTRAL_ISOLATE_TYPES) {\\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\\n        }\\n\\n        charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\\n\\n        if (type & NEUTRAL_ISOLATE_TYPES) {\\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\\n        }\\n      }\\n\\n      var embedLevels = new Uint8Array(string.length);\\n      var isolationPairs = new Map(); //init->pdi and pdi->init\\n      // === 3.3.1 The Paragraph Level ===\\n      // 3.3.1 P1: Split the text into paragraphs\\n\\n      var paragraphs = []; // [{start, end, level}, ...]\\n\\n      var paragraph = null;\\n\\n      for (var i$1 = 0; i$1 < string.length; i$1++) {\\n        if (!paragraph) {\\n          paragraphs.push(paragraph = {\\n            start: i$1,\\n            end: string.length - 1,\\n            // 3.3.1 P2-P3: Determine the paragraph level\\n            level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\\n          });\\n        }\\n\\n        if (charTypes[i$1] & TYPE_B) {\\n          paragraph.end = i$1;\\n          paragraph = null;\\n        }\\n      }\\n\\n      var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\\n\\n      var nextEven = function nextEven(n) {\\n        return n + (n & 1 ? 1 : 2);\\n      };\\n\\n      var nextOdd = function nextOdd(n) {\\n        return n + (n & 1 ? 2 : 1);\\n      }; // Everything from here on will operate per paragraph.\\n\\n\\n      for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\\n        paragraph = paragraphs[paraIdx];\\n        var statusStack = [{\\n          _level: paragraph.level,\\n          _override: 0,\\n          //0=neutral, 1=L, 2=R\\n          _isolate: 0 //bool\\n\\n        }];\\n        var stackTop = void 0;\\n        var overflowIsolateCount = 0;\\n        var overflowEmbeddingCount = 0;\\n        var validIsolateCount = 0;\\n        charTypeCounts.clear(); // === 3.3.2 Explicit Levels and Directions ===\\n\\n        for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\\n          var charType = charTypes[i$2];\\n          stackTop = statusStack[statusStack.length - 1]; // Set initial counts\\n\\n          charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\\n\\n          if (charType & NEUTRAL_ISOLATE_TYPES) {\\n            charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\\n          } // Explicit Embeddings: 3.3.2 X2 - X3\\n\\n\\n          if (charType & FORMATTING_TYPES) {\\n            //prefilter all formatters\\n            if (charType & (TYPE_RLE | TYPE_LRE)) {\\n              embedLevels[i$2] = stackTop._level; // 5.2\\n\\n              var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\\n\\n              if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\\n                statusStack.push({\\n                  _level: level,\\n                  _override: 0,\\n                  _isolate: 0\\n                });\\n              } else if (!overflowIsolateCount) {\\n                overflowEmbeddingCount++;\\n              }\\n            } // Explicit Overrides: 3.3.2 X4 - X5\\n            else if (charType & (TYPE_RLO | TYPE_LRO)) {\\n                embedLevels[i$2] = stackTop._level; // 5.2\\n\\n                var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\\n\\n                if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\\n                  statusStack.push({\\n                    _level: level$1,\\n                    _override: charType & TYPE_RLO ? TYPE_R : TYPE_L,\\n                    _isolate: 0\\n                  });\\n                } else if (!overflowIsolateCount) {\\n                  overflowEmbeddingCount++;\\n                }\\n              } // Isolates: 3.3.2 X5a - X5c\\n              else if (charType & ISOLATE_INIT_TYPES) {\\n                  // X5c - FSI becomes either RLI or LRI\\n                  if (charType & TYPE_FSI) {\\n                    charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\\n                  }\\n\\n                  embedLevels[i$2] = stackTop._level;\\n\\n                  if (stackTop._override) {\\n                    changeCharType(i$2, stackTop._override);\\n                  }\\n\\n                  var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\\n\\n                  if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\\n                    validIsolateCount++;\\n                    statusStack.push({\\n                      _level: level$2,\\n                      _override: 0,\\n                      _isolate: 1,\\n                      _isolInitIndex: i$2\\n                    });\\n                  } else {\\n                    overflowIsolateCount++;\\n                  }\\n                } // Terminating Isolates: 3.3.2 X6a\\n                else if (charType & TYPE_PDI) {\\n                    if (overflowIsolateCount > 0) {\\n                      overflowIsolateCount--;\\n                    } else if (validIsolateCount > 0) {\\n                      overflowEmbeddingCount = 0;\\n\\n                      while (!statusStack[statusStack.length - 1]._isolate) {\\n                        statusStack.pop();\\n                      } // Add to isolation pairs bidirectional mapping:\\n\\n\\n                      var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\\n\\n                      if (isolInitIndex != null) {\\n                        isolationPairs.set(isolInitIndex, i$2);\\n                        isolationPairs.set(i$2, isolInitIndex);\\n                      }\\n\\n                      statusStack.pop();\\n                      validIsolateCount--;\\n                    }\\n\\n                    stackTop = statusStack[statusStack.length - 1];\\n                    embedLevels[i$2] = stackTop._level;\\n\\n                    if (stackTop._override) {\\n                      changeCharType(i$2, stackTop._override);\\n                    }\\n                  } // Terminating Embeddings and Overrides: 3.3.2 X7\\n                  else if (charType & TYPE_PDF) {\\n                      if (overflowIsolateCount === 0) {\\n                        if (overflowEmbeddingCount > 0) {\\n                          overflowEmbeddingCount--;\\n                        } else if (!stackTop._isolate && statusStack.length > 1) {\\n                          statusStack.pop();\\n                          stackTop = statusStack[statusStack.length - 1];\\n                        }\\n                      }\\n\\n                      embedLevels[i$2] = stackTop._level; // 5.2\\n                    } // End of Paragraph: 3.3.2 X8\\n                    else if (charType & TYPE_B) {\\n                        embedLevels[i$2] = paragraph.level;\\n                      }\\n          } // Non-formatting characters: 3.3.2 X6\\n          else {\\n              embedLevels[i$2] = stackTop._level; // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\\n\\n              if (stackTop._override && charType !== TYPE_BN) {\\n                changeCharType(i$2, stackTop._override);\\n              }\\n            }\\n        } // === 3.3.3 Preparations for Implicit Processing ===\\n        // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\\n        // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\\n        // easily ignore them all from here on out.\\n        // 3.3.3 X10\\n        // Compute the set of isolating run sequences as specified by BD13\\n\\n\\n        var levelRuns = [];\\n        var currentRun = null;\\n\\n        for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\\n          var charType$1 = charTypes[i$3];\\n\\n          if (!(charType$1 & BN_LIKE_TYPES)) {\\n            var lvl = embedLevels[i$3];\\n            var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\\n            var isPDI = charType$1 === TYPE_PDI;\\n\\n            if (currentRun && lvl === currentRun._level) {\\n              currentRun._end = i$3;\\n              currentRun._endsWithIsolInit = isIsolInit;\\n            } else {\\n              levelRuns.push(currentRun = {\\n                _start: i$3,\\n                _end: i$3,\\n                _level: lvl,\\n                _startsWithPDI: isPDI,\\n                _endsWithIsolInit: isIsolInit\\n              });\\n            }\\n          }\\n        }\\n\\n        var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\\n\\n        for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\\n          var run = levelRuns[runIdx];\\n\\n          if (!run._startsWithPDI || run._startsWithPDI && !isolationPairs.has(run._start)) {\\n            var seqRuns = [currentRun = run];\\n\\n            for (var pdiIndex = void 0; currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\\n              for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\\n                if (levelRuns[i$4]._start === pdiIndex) {\\n                  seqRuns.push(currentRun = levelRuns[i$4]);\\n                  break;\\n                }\\n              }\\n            } // build flat list of indices across all runs:\\n\\n\\n            var seqIndices = [];\\n\\n            for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\\n              var run$1 = seqRuns[i$5];\\n\\n              for (var j = run$1._start; j <= run$1._end; j++) {\\n                seqIndices.push(j);\\n              }\\n            } // determine the sos/eos types:\\n\\n\\n            var firstLevel = embedLevels[seqIndices[0]];\\n            var prevLevel = paragraph.level;\\n\\n            for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\\n              if (!(charTypes[i$6] & BN_LIKE_TYPES)) {\\n                //5.2\\n                prevLevel = embedLevels[i$6];\\n                break;\\n              }\\n            }\\n\\n            var lastIndex = seqIndices[seqIndices.length - 1];\\n            var lastLevel = embedLevels[lastIndex];\\n            var nextLevel = paragraph.level;\\n\\n            if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\\n              for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\\n                if (!(charTypes[i$7] & BN_LIKE_TYPES)) {\\n                  //5.2\\n                  nextLevel = embedLevels[i$7];\\n                  break;\\n                }\\n              }\\n            }\\n\\n            isolatingRunSeqs.push({\\n              _seqIndices: seqIndices,\\n              _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\\n              _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\\n            });\\n          }\\n        } // The next steps are done per isolating run sequence\\n\\n\\n        for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\\n          var ref = isolatingRunSeqs[seqIdx];\\n          var seqIndices$1 = ref._seqIndices;\\n          var sosType = ref._sosType;\\n          var eosType = ref._eosType; // === 3.3.4 Resolving Weak Types ===\\n          // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\\n          // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\\n          // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\\n\\n          if (charTypeCounts.get(TYPE_NSM)) {\\n            for (var si = 0; si < seqIndices$1.length; si++) {\\n              var i$8 = seqIndices$1[si];\\n\\n              if (charTypes[i$8] & TYPE_NSM) {\\n                var prevType = sosType;\\n\\n                for (var sj = si - 1; sj >= 0; sj--) {\\n                  if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) {\\n                    //5.2 scan back to first non-BN\\n                    prevType = charTypes[seqIndices$1[sj]];\\n                    break;\\n                  }\\n                }\\n\\n                changeCharType(i$8, prevType & (ISOLATE_INIT_TYPES | TYPE_PDI) ? TYPE_ON : prevType);\\n              }\\n            }\\n          } // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\\n          // is found. If an AL is found, change the type of the European number to Arabic number.\\n\\n\\n          if (charTypeCounts.get(TYPE_EN)) {\\n            for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\\n              var i$9 = seqIndices$1[si$1];\\n\\n              if (charTypes[i$9] & TYPE_EN) {\\n                for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\\n                  var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\\n\\n                  if (prevCharType & STRONG_TYPES) {\\n                    if (prevCharType === TYPE_AL) {\\n                      changeCharType(i$9, TYPE_AN);\\n                    }\\n\\n                    break;\\n                  }\\n                }\\n              }\\n            }\\n          } // W3. Change all ALs to R\\n\\n\\n          if (charTypeCounts.get(TYPE_AL)) {\\n            for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\\n              var i$10 = seqIndices$1[si$2];\\n\\n              if (charTypes[i$10] & TYPE_AL) {\\n                changeCharType(i$10, TYPE_R);\\n              }\\n            }\\n          } // W4. A single European separator between two European numbers changes to a European number. A single common\\n          // separator between two numbers of the same type changes to that type.\\n\\n\\n          if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\\n            for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\\n              var i$11 = seqIndices$1[si$3];\\n\\n              if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\\n                var prevType$1 = 0,\\n                    nextType = 0;\\n\\n                for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\\n                  prevType$1 = charTypes[seqIndices$1[sj$2]];\\n\\n                  if (!(prevType$1 & BN_LIKE_TYPES)) {\\n                    //5.2\\n                    break;\\n                  }\\n                }\\n\\n                for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\\n                  nextType = charTypes[seqIndices$1[sj$3]];\\n\\n                  if (!(nextType & BN_LIKE_TYPES)) {\\n                    //5.2\\n                    break;\\n                  }\\n                }\\n\\n                if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : prevType$1 & (TYPE_EN | TYPE_AN))) {\\n                  changeCharType(i$11, prevType$1);\\n                }\\n              }\\n            }\\n          } // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\\n\\n\\n          if (charTypeCounts.get(TYPE_EN)) {\\n            for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\\n              var i$12 = seqIndices$1[si$4];\\n\\n              if (charTypes[i$12] & TYPE_EN) {\\n                for (var sj$4 = si$4 - 1; sj$4 >= 0 && charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES); sj$4--) {\\n                  changeCharType(seqIndices$1[sj$4], TYPE_EN);\\n                }\\n\\n                for (var sj$5 = si$4 + 1; sj$5 < seqIndices$1.length && charTypes[seqIndices$1[sj$5]] & (TYPE_ET | BN_LIKE_TYPES); sj$5++) {\\n                  changeCharType(seqIndices$1[sj$5], TYPE_EN);\\n                }\\n              }\\n            }\\n          } // W6. Otherwise, separators and terminators change to Other Neutral.\\n\\n\\n          if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\\n            for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\\n              var i$13 = seqIndices$1[si$5];\\n\\n              if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\\n                changeCharType(i$13, TYPE_ON); // 5.2 transform adjacent BNs too:\\n\\n                for (var sj$6 = si$5 - 1; sj$6 >= 0 && charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES; sj$6--) {\\n                  changeCharType(seqIndices$1[sj$6], TYPE_ON);\\n                }\\n\\n                for (var sj$7 = si$5 + 1; sj$7 < seqIndices$1.length && charTypes[seqIndices$1[sj$7]] & BN_LIKE_TYPES; sj$7++) {\\n                  changeCharType(seqIndices$1[sj$7], TYPE_ON);\\n                }\\n              }\\n            }\\n          } // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\\n          // is found. If an L is found, then change the type of the European number to L.\\n          // NOTE: implemented in single forward pass for efficiency\\n\\n\\n          if (charTypeCounts.get(TYPE_EN)) {\\n            for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\\n              var i$14 = seqIndices$1[si$6];\\n              var type = charTypes[i$14];\\n\\n              if (type & TYPE_EN) {\\n                if (prevStrongType === TYPE_L) {\\n                  changeCharType(i$14, TYPE_L);\\n                }\\n              } else if (type & STRONG_TYPES) {\\n                prevStrongType = type;\\n              }\\n            }\\n          } // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\\n\\n\\n          if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\\n            // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\\n            // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\\n            // types EN and AN are treated as R.\\n            var R_TYPES_FOR_N_STEPS = TYPE_R | TYPE_EN | TYPE_AN;\\n            var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L; // * Identify the bracket pairs in the current isolating run sequence according to BD16.\\n\\n            var bracketPairs = [];\\n            {\\n              var openerStack = [];\\n\\n              for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\\n                // NOTE: for any potential bracket character we also test that it still carries a NI\\n                // type, as that may have been changed earlier. This doesn't seem to be explicitly\\n                // called out in the spec, but is required for passage of certain tests.\\n                if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\\n                  var _char6 = string[seqIndices$1[si$7]];\\n                  var oppositeBracket = void 0; // Opening bracket\\n\\n                  if (openingToClosingBracket(_char6) !== null) {\\n                    if (openerStack.length < 63) {\\n                      openerStack.push({\\n                        \\\"char\\\": _char6,\\n                        seqIndex: si$7\\n                      });\\n                    } else {\\n                      break;\\n                    }\\n                  } // Closing bracket\\n                  else if ((oppositeBracket = closingToOpeningBracket(_char6)) !== null) {\\n                      for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\\n                        var stackChar = openerStack[stackIdx][\\\"char\\\"];\\n\\n                        if (stackChar === oppositeBracket || stackChar === closingToOpeningBracket(getCanonicalBracket(_char6)) || openingToClosingBracket(getCanonicalBracket(stackChar)) === _char6) {\\n                          bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\\n                          openerStack.length = stackIdx; //pop the matching bracket and all following\\n\\n                          break;\\n                        }\\n                      }\\n                    }\\n                }\\n              }\\n\\n              bracketPairs.sort(function (a, b) {\\n                return a[0] - b[0];\\n              });\\n            } // * For each bracket-pair element in the list of pairs of text positions\\n\\n            for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\\n              var ref$1 = bracketPairs[pairIdx];\\n              var openSeqIdx = ref$1[0];\\n              var closeSeqIdx = ref$1[1]; // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\\n              // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\\n              // brackets in the pair to match the embedding direction.\\n\\n              var foundStrongType = false;\\n              var useStrongType = 0;\\n\\n              for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\\n                var i$15 = seqIndices$1[si$8];\\n\\n                if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\\n                  foundStrongType = true;\\n                  var lr = charTypes[i$15] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\\n\\n                  if (lr === getEmbedDirection(i$15)) {\\n                    useStrongType = lr;\\n                    break;\\n                  }\\n                }\\n              } // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\\n              // for an established context with a preceding strong type by checking backwards before the opening paired\\n              // bracket until the first strong type (L, R, or sos) is found.\\n              //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\\n              //    set the type for both brackets in the pair to that direction.\\n              //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\\n\\n\\n              if (foundStrongType && !useStrongType) {\\n                useStrongType = sosType;\\n\\n                for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\\n                  var i$16 = seqIndices$1[si$9];\\n\\n                  if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\\n                    var lr$1 = charTypes[i$16] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\\n\\n                    if (lr$1 !== getEmbedDirection(i$16)) {\\n                      useStrongType = lr$1;\\n                    } else {\\n                      useStrongType = getEmbedDirection(i$16);\\n                    }\\n\\n                    break;\\n                  }\\n                }\\n              }\\n\\n              if (useStrongType) {\\n                charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType; // * Any number of characters that had original bidirectional character type NSM prior to the application\\n                // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\\n                // the type of their preceding bracket.\\n\\n                if (useStrongType !== getEmbedDirection(seqIndices$1[openSeqIdx])) {\\n                  for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\\n                    if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\\n                      if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\\n                        charTypes[seqIndices$1[si$10]] = useStrongType;\\n                      }\\n\\n                      break;\\n                    }\\n                  }\\n                }\\n\\n                if (useStrongType !== getEmbedDirection(seqIndices$1[closeSeqIdx])) {\\n                  for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\\n                    if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\\n                      if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\\n                        charTypes[seqIndices$1[si$11]] = useStrongType;\\n                      }\\n\\n                      break;\\n                    }\\n                  }\\n                }\\n              }\\n            } // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\\n            // same direction.\\n            // N2. Any remaining NIs take the embedding direction.\\n\\n\\n            for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\\n              if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\\n                var niRunStart = si$12,\\n                    niRunEnd = si$12;\\n                var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\\n\\n                for (var si2 = si$12 - 1; si2 >= 0; si2--) {\\n                  if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\\n                    niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\\n                  } else {\\n                    prevType$2 = charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\\n                    break;\\n                  }\\n                }\\n\\n                var nextType$1 = eosType;\\n\\n                for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\\n                  if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\\n                    niRunEnd = si2$1;\\n                  } else {\\n                    nextType$1 = charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS ? TYPE_R : TYPE_L;\\n                    break;\\n                  }\\n                }\\n\\n                for (var sj$8 = niRunStart; sj$8 <= niRunEnd; sj$8++) {\\n                  charTypes[seqIndices$1[sj$8]] = prevType$2 === nextType$1 ? prevType$2 : getEmbedDirection(seqIndices$1[sj$8]);\\n                }\\n\\n                si$12 = niRunEnd;\\n              }\\n            }\\n          }\\n        } // === 3.3.6 Resolving Implicit Levels ===\\n\\n\\n        for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\\n          var level$3 = embedLevels[i$17];\\n          var type$1 = charTypes[i$17]; // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\\n\\n          if (level$3 & 1) {\\n            if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\\n              embedLevels[i$17]++;\\n            }\\n          } // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\\n          // and those of type AN or EN go up two levels.\\n          else {\\n              if (type$1 & TYPE_R) {\\n                embedLevels[i$17]++;\\n              } else if (type$1 & (TYPE_AN | TYPE_EN)) {\\n                embedLevels[i$17] += 2;\\n              }\\n            } // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\\n          // and otherwise to the base level.\\n\\n\\n          if (type$1 & BN_LIKE_TYPES) {\\n            embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\\n          } // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\\n          // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\\n          // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\\n\\n\\n          if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\\n            for (var j$1 = i$17; j$1 >= 0 && getBidiCharType(string[j$1]) & TRAILING_TYPES; j$1--) {\\n              embedLevels[j$1] = paragraph.level;\\n            }\\n          }\\n        }\\n      } // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\\n      // according to section 3.4 Reordering Resolved Levels\\n\\n\\n      return {\\n        levels: embedLevels,\\n        paragraphs: paragraphs\\n      };\\n\\n      function determineAutoEmbedLevel(start, isFSI) {\\n        // 3.3.1 P2 - P3\\n        for (var i = start; i < string.length; i++) {\\n          var charType = charTypes[i];\\n\\n          if (charType & (TYPE_R | TYPE_AL)) {\\n            return 1;\\n          }\\n\\n          if (charType & (TYPE_B | TYPE_L) || isFSI && charType === TYPE_PDI) {\\n            return 0;\\n          }\\n\\n          if (charType & ISOLATE_INIT_TYPES) {\\n            var pdi = indexOfMatchingPDI(i);\\n            i = pdi === -1 ? string.length : pdi;\\n          }\\n        }\\n\\n        return 0;\\n      }\\n\\n      function indexOfMatchingPDI(isolateStart) {\\n        // 3.1.2 BD9\\n        var isolationLevel = 1;\\n\\n        for (var i = isolateStart + 1; i < string.length; i++) {\\n          var charType = charTypes[i];\\n\\n          if (charType & TYPE_B) {\\n            break;\\n          }\\n\\n          if (charType & TYPE_PDI) {\\n            if (--isolationLevel === 0) {\\n              return i;\\n            }\\n          } else if (charType & ISOLATE_INIT_TYPES) {\\n            isolationLevel++;\\n          }\\n        }\\n\\n        return -1;\\n      }\\n\\n      function getEmbedDirection(i) {\\n        return embedLevels[i] & 1 ? TYPE_R : TYPE_L;\\n      }\\n    } // Bidi mirrored chars data, auto generated\\n\\n\\n    var data = \\\"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\\\";\\n    var mirrorMap;\\n\\n    function parse() {\\n      if (!mirrorMap) {\\n        //const start = performance.now()\\n        var ref = parseCharacterMap(data, true);\\n        var map = ref.map;\\n        var reverseMap = ref.reverseMap; // Combine both maps into one\\n\\n        reverseMap.forEach(function (value, key) {\\n          map.set(key, value);\\n        });\\n        mirrorMap = map; //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\\n      }\\n    }\\n\\n    function getMirroredCharacter(_char7) {\\n      parse();\\n      return mirrorMap.get(_char7) || null;\\n    }\\n    /**\\n     * Given a string and its resolved embedding levels, build a map of indices to replacement chars\\n     * for any characters in right-to-left segments that have defined mirrored characters.\\n     * @param string\\n     * @param embeddingLevels\\n     * @param [start]\\n     * @param [end]\\n     * @return {Map<number, string>}\\n     */\\n\\n\\n    function getMirroredCharactersMap(string, embeddingLevels, start, end) {\\n      var strLen = string.length;\\n      start = Math.max(0, start == null ? 0 : +start);\\n      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\\n      var map = new Map();\\n\\n      for (var i = start; i <= end; i++) {\\n        if (embeddingLevels[i] & 1) {\\n          //only odd (rtl) levels\\n          var mirror = getMirroredCharacter(string[i]);\\n\\n          if (mirror !== null) {\\n            map.set(i, mirror);\\n          }\\n        }\\n      }\\n\\n      return map;\\n    }\\n    /**\\n     * Given a start and end denoting a single line within a string, and a set of precalculated\\n     * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\\n     * @param {string} string - the full input string\\n     * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\\n     * @param {number} [start] - first character in a subset of the full string\\n     * @param {number} [end] - last character in a subset of the full string\\n     * @return {number[][]} - the list of start/end segments that should be flipped, in order.\\n     */\\n\\n\\n    function getReorderSegments(string, embeddingLevelsResult, start, end) {\\n      var strLen = string.length;\\n      start = Math.max(0, start == null ? 0 : +start);\\n      end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\\n      var segments = [];\\n      embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\\n        var lineStart = Math.max(start, paragraph.start);\\n        var lineEnd = Math.min(end, paragraph.end);\\n\\n        if (lineStart < lineEnd) {\\n          // Local slice for mutation\\n          var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1); // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\\n          // end of the line to the paragraph level.\\n\\n          for (var i = lineEnd; i >= lineStart && getBidiCharType(string[i]) & TRAILING_TYPES; i--) {\\n            lineLevels[i] = paragraph.level;\\n          } // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\\n          // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\\n\\n\\n          var maxLevel = paragraph.level;\\n          var minOddLevel = Infinity;\\n\\n          for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\\n            var level = lineLevels[i$1];\\n\\n            if (level > maxLevel) {\\n              maxLevel = level;\\n            }\\n\\n            if (level < minOddLevel) {\\n              minOddLevel = level | 1;\\n            }\\n          }\\n\\n          for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\\n            for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\\n              if (lineLevels[i$2] >= lvl) {\\n                var segStart = i$2;\\n\\n                while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\\n                  i$2++;\\n                }\\n\\n                if (i$2 > segStart) {\\n                  segments.push([segStart + start, i$2 + start]);\\n                }\\n              }\\n            }\\n          }\\n        }\\n      });\\n      return segments;\\n    }\\n    /**\\n     * @param {string} string\\n     * @param {GetEmbeddingLevelsResult} embedLevelsResult\\n     * @param {number} [start]\\n     * @param {number} [end]\\n     * @return {string} the new string with bidi segments reordered\\n     */\\n\\n\\n    function getReorderedString(string, embedLevelsResult, start, end) {\\n      var indices = getReorderedIndices(string, embedLevelsResult, start, end);\\n      var chars = [].concat(string);\\n      indices.forEach(function (charIndex, i) {\\n        chars[i] = (embedLevelsResult.levels[charIndex] & 1 ? getMirroredCharacter(string[charIndex]) : null) || string[charIndex];\\n      });\\n      return chars.join('');\\n    }\\n    /**\\n     * @param {string} string\\n     * @param {GetEmbeddingLevelsResult} embedLevelsResult\\n     * @param {number} [start]\\n     * @param {number} [end]\\n     * @return {number[]} an array with character indices in their new bidi order\\n     */\\n\\n\\n    function getReorderedIndices(string, embedLevelsResult, start, end) {\\n      var segments = getReorderSegments(string, embedLevelsResult, start, end); // Fill an array with indices\\n\\n      var indices = [];\\n\\n      for (var i = 0; i < string.length; i++) {\\n        indices[i] = i;\\n      } // Reverse each segment in order\\n\\n\\n      segments.forEach(function (ref) {\\n        var start = ref[0];\\n        var end = ref[1];\\n        var slice = indices.slice(start, end + 1);\\n\\n        for (var i = slice.length; i--;) {\\n          indices[end - i] = slice[i];\\n        }\\n      });\\n      return indices;\\n    }\\n\\n    exports.closingToOpeningBracket = closingToOpeningBracket;\\n    exports.getBidiCharType = getBidiCharType;\\n    exports.getBidiCharTypeName = getBidiCharTypeName;\\n    exports.getCanonicalBracket = getCanonicalBracket;\\n    exports.getEmbeddingLevels = getEmbeddingLevels;\\n    exports.getMirroredCharacter = getMirroredCharacter;\\n    exports.getMirroredCharactersMap = getMirroredCharactersMap;\\n    exports.getReorderSegments = getReorderSegments;\\n    exports.getReorderedIndices = getReorderedIndices;\\n    exports.getReorderedString = getReorderedString;\\n    exports.openingToClosingBracket = openingToClosingBracket;\\n    Object.defineProperty(exports, '__esModule', {\\n      value: true\\n    });\\n    return exports;\\n  }({});\\n\\n  return bidi;\\n}\\n\\nvar _default = bidiFactory;\\nexports[\\\"default\\\"] = _default;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"bidiFactory\",\"parseData\",\"map\",\"Map\",\"loop\",\"type\",\"DATA\",\"hasOwnProperty\",\"lastCode\",\"split\",\"forEach\",\"range\",\"ref\",\"skip\",\"step\",\"parseInt\",\"set\",\"TYPES\",\"i\",\"getBidiCharType\",\"_char\",\"get\",\"codePointAt\",\"L\",\"parseCharacterMap\",\"encodedString\",\"includeReverse\",\"reverseMap\",\"prevPair\",\"visit\",\"entry\",\"indexOf\",\"a\",\"b\",\"String\",\"fromCodePoint\",\"radix\",\"parse$1\",\"openToClose\",\"data$1\",\"pairs\",\"closeToOpen\",\"canonical\",\"openingToClosingBracket\",\"_char3\",\"closingToOpeningBracket\",\"_char4\",\"getCanonicalBracket\",\"_char5\",\"parse\",\"mirrorMap\",\"data\",\"key\",\"getMirroredCharacter\",\"_char7\",\"getReorderSegments\",\"string\",\"embeddingLevelsResult\",\"start\",\"end\",\"strLen\",\"length\",\"Math\",\"max\",\"min\",\"segments\",\"paragraphs\",\"paragraph\",\"lineStart\",\"lineEnd\",\"lineLevels\",\"levels\",\"slice\",\"TRAILING_TYPES\",\"level\",\"maxLevel\",\"minOddLevel\",\"Infinity\",\"i$1\",\"lvl\",\"i$2\",\"segStart\",\"push\",\"getReorderedIndices\",\"embedLevelsResult\",\"indices\",\"TYPES_TO_NAMES\",\"keys\",\"freeze\",\"ISOLATE_INIT_TYPES\",\"LRI\",\"RLI\",\"FSI\",\"STRONG_TYPES\",\"R\",\"AL\",\"NEUTRAL_ISOLATE_TYPES\",\"B\",\"S\",\"WS\",\"ON\",\"PDI\",\"BN_LIKE_TYPES\",\"BN\",\"RLE\",\"LRE\",\"RLO\",\"LRO\",\"PDF\",\"TYPE_L\",\"TYPE_R\",\"TYPE_EN\",\"EN\",\"TYPE_ES\",\"ES\",\"TYPE_ET\",\"ET\",\"TYPE_AN\",\"AN\",\"TYPE_CS\",\"CS\",\"TYPE_B\",\"TYPE_S\",\"TYPE_ON\",\"TYPE_BN\",\"TYPE_NSM\",\"NSM\",\"TYPE_AL\",\"TYPE_LRO\",\"TYPE_RLO\",\"TYPE_LRE\",\"TYPE_RLE\",\"TYPE_PDF\",\"TYPE_LRI\",\"TYPE_RLI\",\"TYPE_FSI\",\"TYPE_PDI\",\"getBidiCharTypeName\",\"_char2\",\"getEmbeddingLevels\",\"baseDirection\",\"changeCharType\",\"oldType\",\"charTypes\",\"charTypeCounts\",\"determineAutoEmbedLevel\",\"isFSI\",\"charType\",\"isolationLevel\",\"pdi\",\"getEmbedDirection\",\"embedLevels\",\"Uint32Array\",\"Uint8Array\",\"isolationPairs\",\"FORMATTING_TYPES\",\"nextEven\",\"n\",\"nextOdd\",\"paraIdx\",\"statusStack\",\"_level\",\"_override\",\"_isolate\",\"stackTop\",\"overflowIsolateCount\",\"overflowEmbeddingCount\",\"validIsolateCount\",\"clear\",\"MAX_DEPTH\",\"level$1\",\"level$2\",\"_isolInitIndex\",\"pop\",\"isolInitIndex\",\"levelRuns\",\"currentRun\",\"i$3\",\"charType$1\",\"isIsolInit\",\"isPDI\",\"_end\",\"_endsWithIsolInit\",\"_start\",\"_startsWithPDI\",\"isolatingRunSeqs\",\"runIdx\",\"run\",\"has\",\"seqRuns\",\"pdiIndex\",\"i$4\",\"seqIndices\",\"i$5\",\"run$1\",\"j\",\"firstLevel\",\"prevLevel\",\"i$6\",\"lastIndex\",\"lastLevel\",\"nextLevel\",\"i$7\",\"_seqIndices\",\"_sosType\",\"_eosType\",\"seqIdx\",\"seqIndices$1\",\"sosType\",\"eosType\",\"si\",\"i$8\",\"prevType\",\"sj\",\"si$1\",\"i$9\",\"sj$1\",\"prevCharType\",\"si$2\",\"i$10\",\"si$3\",\"i$11\",\"prevType$1\",\"nextType\",\"sj$2\",\"sj$3\",\"si$4\",\"i$12\",\"sj$4\",\"sj$5\",\"si$5\",\"i$13\",\"sj$6\",\"sj$7\",\"si$6\",\"prevStrongType\",\"i$14\",\"R_TYPES_FOR_N_STEPS\",\"STRONG_TYPES_FOR_N_STEPS\",\"bracketPairs\",\"openerStack\",\"si$7\",\"_char6\",\"oppositeBracket\",\"seqIndex\",\"stackIdx\",\"stackChar\",\"sort\",\"pairIdx\",\"ref$1\",\"openSeqIdx\",\"closeSeqIdx\",\"foundStrongType\",\"useStrongType\",\"si$8\",\"i$15\",\"lr\",\"si$9\",\"i$16\",\"lr$1\",\"si$10\",\"si$11\",\"si$12\",\"niRunStart\",\"niRunEnd\",\"prevType$2\",\"si2\",\"nextType$1\",\"si2$1\",\"sj$8\",\"i$17\",\"type$1\",\"level$3\",\"j$1\",\"getMirroredCharactersMap\",\"embeddingLevels\",\"mirror\",\"getReorderedString\",\"chars\",\"concat\",\"charIndex\",\"join\",\"bidi\"]\n}\n"]