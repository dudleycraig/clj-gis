["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$parse$parser$traits$recoverable=function(global,require,module,exports){function InRuleRecoveryException(message){this.name=exports.IN_RULE_RECOVERY_EXCEPTION;this.message=message}function attemptInRepetitionRecovery(prodFunc,args,lookaheadFunc,dslMethodIdx,prodOccurrence,nextToksWalker,notStuck){dslMethodIdx=this.getKeyForAutomaticLookahead(dslMethodIdx,prodOccurrence);var firstAfterRepInfo=this.firstAfterRepMap[dslMethodIdx];void 0===firstAfterRepInfo&&\n(firstAfterRepInfo=this.getCurrRuleFullName(),firstAfterRepInfo=this.getGAstProductions()[firstAfterRepInfo],firstAfterRepInfo=(new nextToksWalker(firstAfterRepInfo,prodOccurrence)).startWalking(),this.firstAfterRepMap[dslMethodIdx]=firstAfterRepInfo);prodOccurrence=firstAfterRepInfo.token;nextToksWalker=firstAfterRepInfo.occurrence;dslMethodIdx=firstAfterRepInfo.isEndOfRule;1===this.RULE_STACK.length&&dslMethodIdx&&void 0===prodOccurrence&&(prodOccurrence=tokens_public_1.EOF,nextToksWalker=1);this.shouldInRepetitionRecoveryBeTried(prodOccurrence,\nnextToksWalker,notStuck)&&this.tryInRepetitionRecovery(prodFunc,args,lookaheadFunc,prodOccurrence)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.attemptInRepetitionRecovery=exports.Recoverable=exports.InRuleRecoveryException=exports.IN_RULE_RECOVERY_EXCEPTION=exports.EOF_FOLLOW_KEY=void 0;var tokens_public_1=require(\"module$node_modules$chevrotain$lib$src$scan$tokens_public\"),utils_1=require(\"module$node_modules$$chevrotain$utils$lib$src$api\"),exceptions_public_1=require(\"module$node_modules$chevrotain$lib$src$parse$exceptions_public\"),\nconstants_1=require(\"module$node_modules$chevrotain$lib$src$parse$constants\"),parser_1=require(\"module$node_modules$chevrotain$lib$src$parse$parser$parser\");exports.EOF_FOLLOW_KEY={};exports.IN_RULE_RECOVERY_EXCEPTION=\"InRuleRecoveryException\";exports.InRuleRecoveryException=InRuleRecoveryException;InRuleRecoveryException.prototype=Error.prototype;global=function(){function Recoverable(){}Recoverable.prototype.initRecoverable=function(config){this.firstAfterRepMap={};this.resyncFollows={};if(this.recoveryEnabled=\nutils_1.has(config,\"recoveryEnabled\")?config.recoveryEnabled:parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled)this.attemptInRepetitionRecovery=attemptInRepetitionRecovery};Recoverable.prototype.getTokenToInsert=function(tokType){tokType=tokens_public_1.createTokenInstance(tokType,\"\",NaN,NaN,NaN,NaN,NaN,NaN);tokType.isInsertedInRecovery=!0;return tokType};Recoverable.prototype.canTokenTypeBeInsertedInRecovery=function(tokType){return!0};Recoverable.prototype.tryInRepetitionRecovery=function(grammarRule,\ngrammarRuleArgs,lookAheadFunc,expectedTokType){for(var _this=this,reSyncTokType=this.findReSyncTokenType(),savedLexerState=this.exportLexerState(),resyncedTokens=[],passedResyncPoint=!1,nextTokenWithoutResync=this.LA(1),currToken=this.LA(1),generateErrorMessage=function(){var previousToken=_this.LA(0);previousToken=_this.errorMessageProvider.buildMismatchTokenMessage({expected:expectedTokType,actual:nextTokenWithoutResync,previous:previousToken,ruleName:_this.getCurrRuleFullName()});previousToken=\nnew exceptions_public_1.MismatchedTokenException(previousToken,nextTokenWithoutResync,_this.LA(0));previousToken.resyncedTokens=utils_1.dropRight(resyncedTokens);_this.SAVE_ERROR(previousToken)};!passedResyncPoint;){if(this.tokenMatcher(currToken,expectedTokType)){generateErrorMessage();return}if(lookAheadFunc.call(this)){generateErrorMessage();grammarRule.apply(this,grammarRuleArgs);return}this.tokenMatcher(currToken,reSyncTokType)?passedResyncPoint=!0:(currToken=this.SKIP_TOKEN(),this.addToResyncTokens(currToken,\nresyncedTokens))}this.importLexerState(savedLexerState)};Recoverable.prototype.shouldInRepetitionRecoveryBeTried=function(expectTokAfterLastMatch,nextTokIdx,notStuck){return!1===notStuck||void 0===expectTokAfterLastMatch||void 0===nextTokIdx||this.tokenMatcher(this.LA(1),expectTokAfterLastMatch)||this.isBackTracking()||this.canPerformInRuleRecovery(expectTokAfterLastMatch,this.getFollowsForInRuleRecovery(expectTokAfterLastMatch,nextTokIdx))?!1:!0};Recoverable.prototype.getFollowsForInRuleRecovery=\nfunction(tokType,tokIdxInRule){tokType=this.getCurrentGrammarPath(tokType,tokIdxInRule);return this.getNextPossibleTokenTypes(tokType)};Recoverable.prototype.tryInRuleRecovery=function(expectedTokType,follows){if(this.canRecoverWithSingleTokenInsertion(expectedTokType,follows))return this.getTokenToInsert(expectedTokType);if(this.canRecoverWithSingleTokenDeletion(expectedTokType))return expectedTokType=this.SKIP_TOKEN(),this.consumeToken(),expectedTokType;throw new InRuleRecoveryException(\"sad sad panda\");\n};Recoverable.prototype.canPerformInRuleRecovery=function(expectedToken,follows){return this.canRecoverWithSingleTokenInsertion(expectedToken,follows)||this.canRecoverWithSingleTokenDeletion(expectedToken)};Recoverable.prototype.canRecoverWithSingleTokenInsertion=function(expectedTokType,follows){var _this=this;if(!this.canTokenTypeBeInsertedInRecovery(expectedTokType)||utils_1.isEmpty(follows))return!1;var mismatchedTok=this.LA(1);return void 0!==utils_1.find(follows,function(possibleFollowsTokType){return _this.tokenMatcher(mismatchedTok,\npossibleFollowsTokType)})};Recoverable.prototype.canRecoverWithSingleTokenDeletion=function(expectedTokType){return this.tokenMatcher(this.LA(2),expectedTokType)};Recoverable.prototype.isInCurrentRuleReSyncSet=function(tokenTypeIdx){var followKey=this.getCurrFollowKey();followKey=this.getFollowSetFromFollowKey(followKey);return utils_1.contains(followKey,tokenTypeIdx)};Recoverable.prototype.findReSyncTokenType=function(){for(var allPossibleReSyncTokTypes=this.flattenFollowSet(),nextToken=this.LA(1),\nk=2;;){nextToken=nextToken.tokenType;if(utils_1.contains(allPossibleReSyncTokTypes,nextToken))return nextToken;nextToken=this.LA(k);k++}};Recoverable.prototype.getCurrFollowKey=function(){if(1===this.RULE_STACK.length)return exports.EOF_FOLLOW_KEY;var currRuleShortName=this.getLastExplicitRuleShortName(),currRuleIdx=this.getLastExplicitRuleOccurrenceIndex(),prevRuleShortName=this.getPreviousExplicitRuleShortName();return{ruleName:this.shortRuleNameToFullName(currRuleShortName),idxInCallingRule:currRuleIdx,\ninRule:this.shortRuleNameToFullName(prevRuleShortName)}};Recoverable.prototype.buildFullFollowKeyStack=function(){var _this=this,explicitRuleStack=this.RULE_STACK,explicitOccurrenceStack=this.RULE_OCCURRENCE_STACK;return utils_1.map(explicitRuleStack,function(ruleName,idx){return 0===idx?exports.EOF_FOLLOW_KEY:{ruleName:_this.shortRuleNameToFullName(ruleName),idxInCallingRule:explicitOccurrenceStack[idx],inRule:_this.shortRuleNameToFullName(explicitRuleStack[idx-1])}})};Recoverable.prototype.flattenFollowSet=\nfunction(){var _this=this,followStack=utils_1.map(this.buildFullFollowKeyStack(),function(currKey){return _this.getFollowSetFromFollowKey(currKey)});return utils_1.flatten(followStack)};Recoverable.prototype.getFollowSetFromFollowKey=function(followKey){return followKey===exports.EOF_FOLLOW_KEY?[tokens_public_1.EOF]:this.resyncFollows[followKey.ruleName+followKey.idxInCallingRule+constants_1.IN+followKey.inRule]};Recoverable.prototype.addToResyncTokens=function(token,resyncTokens){this.tokenMatcher(token,\ntokens_public_1.EOF)||resyncTokens.push(token);return resyncTokens};Recoverable.prototype.reSyncTo=function(tokType){for(var resyncedTokens=[],nextTok=this.LA(1);!1===this.tokenMatcher(nextTok,tokType);)nextTok=this.SKIP_TOKEN(),this.addToResyncTokens(nextTok,resyncedTokens);return utils_1.dropRight(resyncedTokens)};Recoverable.prototype.attemptInRepetitionRecovery=function(prodFunc,args,lookaheadFunc,dslMethodIdx,prodOccurrence,nextToksWalker,notStuck){};Recoverable.prototype.getCurrentGrammarPath=\nfunction(tokType,tokIdxInRule){var pathRuleStack=this.getHumanReadableRuleStack(),pathOccurrenceStack=utils_1.cloneArr(this.RULE_OCCURRENCE_STACK);return{ruleStack:pathRuleStack,occurrenceStack:pathOccurrenceStack,lastTok:tokType,lastTokOccurrence:tokIdxInRule}};Recoverable.prototype.getHumanReadableRuleStack=function(){var _this=this;return utils_1.map(this.RULE_STACK,function(currShortName){return _this.shortRuleNameToFullName(currShortName)})};return Recoverable}();exports.Recoverable=global;exports.attemptInRepetitionRecovery=\nattemptInRepetitionRecovery}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$parse$parser$traits$recoverable\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attemptInRepetitionRecovery = exports.Recoverable = exports.InRuleRecoveryException = exports.IN_RULE_RECOVERY_EXCEPTION = exports.EOF_FOLLOW_KEY = void 0;\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar exceptions_public_1 = require(\"../../exceptions_public\");\nvar constants_1 = require(\"../../constants\");\nvar parser_1 = require(\"../parser\");\nexports.EOF_FOLLOW_KEY = {};\nexports.IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nfunction InRuleRecoveryException(message) {\n    this.name = exports.IN_RULE_RECOVERY_EXCEPTION;\n    this.message = message;\n}\nexports.InRuleRecoveryException = InRuleRecoveryException;\nInRuleRecoveryException.prototype = Error.prototype;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nvar Recoverable = /** @class */ (function () {\n    function Recoverable() {\n    }\n    Recoverable.prototype.initRecoverable = function (config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = utils_1.has(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled\n            : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    };\n    Recoverable.prototype.getTokenToInsert = function (tokType) {\n        var tokToInsert = tokens_public_1.createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    };\n    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n        return true;\n    };\n    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        var _this = this;\n        // TODO: can the resyncTokenType be cached?\n        var reSyncTokType = this.findReSyncTokenType();\n        var savedLexerState = this.exportLexerState();\n        var resyncedTokens = [];\n        var passedResyncPoint = false;\n        var nextTokenWithoutResync = this.LA(1);\n        var currToken = this.LA(1);\n        var generateErrorMessage = function () {\n            var previousToken = _this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: _this.getCurrRuleFullName()\n            });\n            var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = utils_1.dropRight(resyncedTokens);\n            _this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    };\n    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // arguments to try and perform resync into the next iteration of the many are missing\n        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    };\n    // Error Recovery functionality\n    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        var follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    };\n    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            var nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    };\n    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n        var _this = this;\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if (utils_1.isEmpty(follows)) {\n            return false;\n        }\n        var mismatchedTok = this.LA(1);\n        var isMisMatchedTokInFollows = utils_1.find(follows, function (possibleFollowsTokType) {\n            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    };\n    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n        var followKey = this.getCurrFollowKey();\n        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return utils_1.contains(currentRuleReSyncSet, tokenTypeIdx);\n    };\n    Recoverable.prototype.findReSyncTokenType = function () {\n        var allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        var nextToken = this.LA(1);\n        var k = 2;\n        while (true) {\n            var nextTokenType = nextToken.tokenType;\n            if (utils_1.contains(allPossibleReSyncTokTypes, nextTokenType)) {\n                return nextTokenType;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    };\n    Recoverable.prototype.getCurrFollowKey = function () {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return exports.EOF_FOLLOW_KEY;\n        }\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n        };\n    };\n    Recoverable.prototype.buildFullFollowKeyStack = function () {\n        var _this = this;\n        var explicitRuleStack = this.RULE_STACK;\n        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return utils_1.map(explicitRuleStack, function (ruleName, idx) {\n            if (idx === 0) {\n                return exports.EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: _this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n        });\n    };\n    Recoverable.prototype.flattenFollowSet = function () {\n        var _this = this;\n        var followStack = utils_1.map(this.buildFullFollowKeyStack(), function (currKey) {\n            return _this.getFollowSetFromFollowKey(currKey);\n        });\n        return utils_1.flatten(followStack);\n    };\n    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n        if (followKey === exports.EOF_FOLLOW_KEY) {\n            return [tokens_public_1.EOF];\n        }\n        var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    };\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n        if (!this.tokenMatcher(token, tokens_public_1.EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    };\n    Recoverable.prototype.reSyncTo = function (tokType) {\n        var resyncedTokens = [];\n        var nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return utils_1.dropRight(resyncedTokens);\n    };\n    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    };\n    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n        var pathRuleStack = this.getHumanReadableRuleStack();\n        var pathOccurrenceStack = utils_1.cloneArr(this.RULE_OCCURRENCE_STACK);\n        var grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n        };\n        return grammarPath;\n    };\n    Recoverable.prototype.getHumanReadableRuleStack = function () {\n        var _this = this;\n        return utils_1.map(this.RULE_STACK, function (currShortName) {\n            return _this.shortRuleNameToFullName(currShortName);\n        });\n    };\n    return Recoverable;\n}());\nexports.Recoverable = Recoverable;\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    var firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        var currRuleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    var expectTokAfterLastMatch = firstAfterRepInfo.token;\n    var nextTokIdx = firstAfterRepInfo.occurrence;\n    var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = tokens_public_1.EOF;\n        nextTokIdx = 1;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\nexports.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n//# sourceMappingURL=recoverable.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$chevrotain$lib$src$parse$constants","~$module$node_modules$$chevrotain$utils$lib$src$api","~$shadow.js","~$module$node_modules$chevrotain$lib$src$scan$tokens_public","~$module$node_modules$chevrotain$lib$src$parse$exceptions_public","~$module$node_modules$chevrotain$lib$src$parse$parser$parser"]],"~:properties",["^5",["tryInRuleRecovery","canRecoverWithSingleTokenInsertion","canPerformInRuleRecovery","message","lastTok","findReSyncTokenType","getCurrFollowKey","idxInCallingRule","isInCurrentRuleReSyncSet","getFollowsForInRuleRecovery","shouldInRepetitionRecoveryBeTried","ruleName","prototype","Recoverable","__esModule","occurrenceStack","tryInRepetitionRecovery","InRuleRecoveryException","getCurrentGrammarPath","canTokenTypeBeInsertedInRecovery","EOF_FOLLOW_KEY","lastTokOccurrence","recoveryEnabled","initRecoverable","addToResyncTokens","expected","name","value","resyncFollows","getTokenToInsert","previous","attemptInRepetitionRecovery","isInsertedInRecovery","IN_RULE_RECOVERY_EXCEPTION","ruleStack","canRecoverWithSingleTokenDeletion","flattenFollowSet","firstAfterRepMap","resyncedTokens","reSyncTo","actual","getHumanReadableRuleStack","getFollowSetFromFollowKey","inRule","buildFullFollowKeyStack"]],"~:compiled-at",1630917515700,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$parse$parser$traits$recoverable.js\",\n\"lineCount\":17,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$parse$parser$traits$recoverable\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.attemptInRepetitionRecovery = exports.Recoverable = exports.InRuleRecoveryException = exports.IN_RULE_RECOVERY_EXCEPTION = exports.EOF_FOLLOW_KEY = void 0;\\nvar tokens_public_1 = require(\\\"../../../scan/tokens_public\\\");\\nvar utils_1 = require(\\\"@chevrotain/utils\\\");\\nvar exceptions_public_1 = require(\\\"../../exceptions_public\\\");\\nvar constants_1 = require(\\\"../../constants\\\");\\nvar parser_1 = require(\\\"../parser\\\");\\nexports.EOF_FOLLOW_KEY = {};\\nexports.IN_RULE_RECOVERY_EXCEPTION = \\\"InRuleRecoveryException\\\";\\nfunction InRuleRecoveryException(message) {\\n    this.name = exports.IN_RULE_RECOVERY_EXCEPTION;\\n    this.message = message;\\n}\\nexports.InRuleRecoveryException = InRuleRecoveryException;\\nInRuleRecoveryException.prototype = Error.prototype;\\n/**\\n * This trait is responsible for the error recovery and fault tolerant logic\\n */\\nvar Recoverable = /** @class */ (function () {\\n    function Recoverable() {\\n    }\\n    Recoverable.prototype.initRecoverable = function (config) {\\n        this.firstAfterRepMap = {};\\n        this.resyncFollows = {};\\n        this.recoveryEnabled = utils_1.has(config, \\\"recoveryEnabled\\\")\\n            ? config.recoveryEnabled\\n            : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;\\n        // performance optimization, NOOP will be inlined which\\n        // effectively means that this optional feature does not exist\\n        // when not used.\\n        if (this.recoveryEnabled) {\\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\\n        }\\n    };\\n    Recoverable.prototype.getTokenToInsert = function (tokType) {\\n        var tokToInsert = tokens_public_1.createTokenInstance(tokType, \\\"\\\", NaN, NaN, NaN, NaN, NaN, NaN);\\n        tokToInsert.isInsertedInRecovery = true;\\n        return tokToInsert;\\n    };\\n    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\\n        return true;\\n    };\\n    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\\n        var _this = this;\\n        // TODO: can the resyncTokenType be cached?\\n        var reSyncTokType = this.findReSyncTokenType();\\n        var savedLexerState = this.exportLexerState();\\n        var resyncedTokens = [];\\n        var passedResyncPoint = false;\\n        var nextTokenWithoutResync = this.LA(1);\\n        var currToken = this.LA(1);\\n        var generateErrorMessage = function () {\\n            var previousToken = _this.LA(0);\\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\\n            // the error that would have been thrown\\n            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\\n                expected: expectedTokType,\\n                actual: nextTokenWithoutResync,\\n                previous: previousToken,\\n                ruleName: _this.getCurrRuleFullName()\\n            });\\n            var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));\\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\\n            error.resyncedTokens = utils_1.dropRight(resyncedTokens);\\n            _this.SAVE_ERROR(error);\\n        };\\n        while (!passedResyncPoint) {\\n            // re-synced to a point where we can safely exit the repetition/\\n            if (this.tokenMatcher(currToken, expectedTokType)) {\\n                generateErrorMessage();\\n                return; // must return here to avoid reverting the inputIdx\\n            }\\n            else if (lookAheadFunc.call(this)) {\\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\\n                generateErrorMessage();\\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\\n                grammarRule.apply(this, grammarRuleArgs);\\n                return; // must return here to avoid reverting the inputIdx\\n            }\\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\\n                passedResyncPoint = true;\\n            }\\n            else {\\n                currToken = this.SKIP_TOKEN();\\n                this.addToResyncTokens(currToken, resyncedTokens);\\n            }\\n        }\\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\\n        // \\\"between rules\\\" resync recovery later in the flow.\\n        this.importLexerState(savedLexerState);\\n    };\\n    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\\n        // Edge case of arriving from a MANY repetition which is stuck\\n        // Attempting recovery in this case could cause an infinite loop\\n        if (notStuck === false) {\\n            return false;\\n        }\\n        // arguments to try and perform resync into the next iteration of the many are missing\\n        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\\n            return false;\\n        }\\n        // no need to recover, next token is what we expect...\\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\\n            return false;\\n        }\\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\\n        // and prefer some backtracking path that includes recovered errors.\\n        if (this.isBackTracking()) {\\n            return false;\\n        }\\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\\n        //noinspection RedundantIfStatementJS\\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\\n            return false;\\n        }\\n        return true;\\n    };\\n    // Error Recovery functionality\\n    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\\n        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\\n        var follows = this.getNextPossibleTokenTypes(grammarPath);\\n        return follows;\\n    };\\n    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\\n            return tokToInsert;\\n        }\\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\\n            var nextTok = this.SKIP_TOKEN();\\n            this.consumeToken();\\n            return nextTok;\\n        }\\n        throw new InRuleRecoveryException(\\\"sad sad panda\\\");\\n    };\\n    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\\n    };\\n    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\\n        var _this = this;\\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\\n            return false;\\n        }\\n        // must know the possible following tokens to perform single token insertion\\n        if (utils_1.isEmpty(follows)) {\\n            return false;\\n        }\\n        var mismatchedTok = this.LA(1);\\n        var isMisMatchedTokInFollows = utils_1.find(follows, function (possibleFollowsTokType) {\\n            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\\n        }) !== undefined;\\n        return isMisMatchedTokInFollows;\\n    };\\n    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\\n        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\\n        return isNextTokenWhatIsExpected;\\n    };\\n    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\\n        var followKey = this.getCurrFollowKey();\\n        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\\n        return utils_1.contains(currentRuleReSyncSet, tokenTypeIdx);\\n    };\\n    Recoverable.prototype.findReSyncTokenType = function () {\\n        var allPossibleReSyncTokTypes = this.flattenFollowSet();\\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\\n        var nextToken = this.LA(1);\\n        var k = 2;\\n        while (true) {\\n            var nextTokenType = nextToken.tokenType;\\n            if (utils_1.contains(allPossibleReSyncTokTypes, nextTokenType)) {\\n                return nextTokenType;\\n            }\\n            nextToken = this.LA(k);\\n            k++;\\n        }\\n    };\\n    Recoverable.prototype.getCurrFollowKey = function () {\\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\\n        if (this.RULE_STACK.length === 1) {\\n            return exports.EOF_FOLLOW_KEY;\\n        }\\n        var currRuleShortName = this.getLastExplicitRuleShortName();\\n        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\\n        var prevRuleShortName = this.getPreviousExplicitRuleShortName();\\n        return {\\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\\n            idxInCallingRule: currRuleIdx,\\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\\n        };\\n    };\\n    Recoverable.prototype.buildFullFollowKeyStack = function () {\\n        var _this = this;\\n        var explicitRuleStack = this.RULE_STACK;\\n        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\\n        return utils_1.map(explicitRuleStack, function (ruleName, idx) {\\n            if (idx === 0) {\\n                return exports.EOF_FOLLOW_KEY;\\n            }\\n            return {\\n                ruleName: _this.shortRuleNameToFullName(ruleName),\\n                idxInCallingRule: explicitOccurrenceStack[idx],\\n                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\\n            };\\n        });\\n    };\\n    Recoverable.prototype.flattenFollowSet = function () {\\n        var _this = this;\\n        var followStack = utils_1.map(this.buildFullFollowKeyStack(), function (currKey) {\\n            return _this.getFollowSetFromFollowKey(currKey);\\n        });\\n        return utils_1.flatten(followStack);\\n    };\\n    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\\n        if (followKey === exports.EOF_FOLLOW_KEY) {\\n            return [tokens_public_1.EOF];\\n        }\\n        var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;\\n        return this.resyncFollows[followName];\\n    };\\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\\n    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\\n        if (!this.tokenMatcher(token, tokens_public_1.EOF)) {\\n            resyncTokens.push(token);\\n        }\\n        return resyncTokens;\\n    };\\n    Recoverable.prototype.reSyncTo = function (tokType) {\\n        var resyncedTokens = [];\\n        var nextTok = this.LA(1);\\n        while (this.tokenMatcher(nextTok, tokType) === false) {\\n            nextTok = this.SKIP_TOKEN();\\n            this.addToResyncTokens(nextTok, resyncedTokens);\\n        }\\n        // the last token is not part of the error.\\n        return utils_1.dropRight(resyncedTokens);\\n    };\\n    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\\n        // by default this is a NO-OP\\n        // The actual implementation is with the function(not method) below\\n    };\\n    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\\n        var pathRuleStack = this.getHumanReadableRuleStack();\\n        var pathOccurrenceStack = utils_1.cloneArr(this.RULE_OCCURRENCE_STACK);\\n        var grammarPath = {\\n            ruleStack: pathRuleStack,\\n            occurrenceStack: pathOccurrenceStack,\\n            lastTok: tokType,\\n            lastTokOccurrence: tokIdxInRule\\n        };\\n        return grammarPath;\\n    };\\n    Recoverable.prototype.getHumanReadableRuleStack = function () {\\n        var _this = this;\\n        return utils_1.map(this.RULE_STACK, function (currShortName) {\\n            return _this.shortRuleNameToFullName(currShortName);\\n        });\\n    };\\n    return Recoverable;\\n}());\\nexports.Recoverable = Recoverable;\\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\\n    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\\n    var firstAfterRepInfo = this.firstAfterRepMap[key];\\n    if (firstAfterRepInfo === undefined) {\\n        var currRuleName = this.getCurrRuleFullName();\\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\\n        firstAfterRepInfo = walker.startWalking();\\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\\n    }\\n    var expectTokAfterLastMatch = firstAfterRepInfo.token;\\n    var nextTokIdx = firstAfterRepInfo.occurrence;\\n    var isEndOfRule = firstAfterRepInfo.isEndOfRule;\\n    // special edge case of a TOP most repetition after which the input should END.\\n    // this will force an attempt for inRule recovery in that scenario.\\n    if (this.RULE_STACK.length === 1 &&\\n        isEndOfRule &&\\n        expectTokAfterLastMatch === undefined) {\\n        expectTokAfterLastMatch = tokens_public_1.EOF;\\n        nextTokIdx = 1;\\n    }\\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\\n        // TODO: performance optimization: instead of passing the original args here, we modify\\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\\n        // to avoid searching the cache for it once more.\\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\\n    }\\n}\\nexports.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\\n//# sourceMappingURL=recoverable.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"InRuleRecoveryException\",\"message\",\"name\",\"IN_RULE_RECOVERY_EXCEPTION\",\"attemptInRepetitionRecovery\",\"prodFunc\",\"args\",\"lookaheadFunc\",\"dslMethodIdx\",\"prodOccurrence\",\"nextToksWalker\",\"notStuck\",\"key\",\"getKeyForAutomaticLookahead\",\"firstAfterRepInfo\",\"firstAfterRepMap\",\"undefined\",\"currRuleName\",\"getCurrRuleFullName\",\"ruleGrammar\",\"getGAstProductions\",\"startWalking\",\"walker\",\"expectTokAfterLastMatch\",\"token\",\"nextTokIdx\",\"occurrence\",\"isEndOfRule\",\"RULE_STACK\",\"length\",\"tokens_public_1\",\"EOF\",\"shouldInRepetitionRecoveryBeTried\",\"tryInRepetitionRecovery\",\"Object\",\"defineProperty\",\"value\",\"Recoverable\",\"EOF_FOLLOW_KEY\",\"utils_1\",\"exceptions_public_1\",\"constants_1\",\"parser_1\",\"prototype\",\"Error\",\"initRecoverable\",\"Recoverable.prototype.initRecoverable\",\"config\",\"resyncFollows\",\"recoveryEnabled\",\"has\",\"DEFAULT_PARSER_CONFIG\",\"getTokenToInsert\",\"Recoverable.prototype.getTokenToInsert\",\"tokType\",\"tokToInsert\",\"createTokenInstance\",\"NaN\",\"isInsertedInRecovery\",\"canTokenTypeBeInsertedInRecovery\",\"Recoverable.prototype.canTokenTypeBeInsertedInRecovery\",\"Recoverable.prototype.tryInRepetitionRecovery\",\"grammarRule\",\"grammarRuleArgs\",\"lookAheadFunc\",\"expectedTokType\",\"_this\",\"reSyncTokType\",\"findReSyncTokenType\",\"savedLexerState\",\"exportLexerState\",\"resyncedTokens\",\"passedResyncPoint\",\"nextTokenWithoutResync\",\"LA\",\"currToken\",\"generateErrorMessage\",\"previousToken\",\"msg\",\"errorMessageProvider\",\"buildMismatchTokenMessage\",\"expected\",\"actual\",\"previous\",\"ruleName\",\"error\",\"MismatchedTokenException\",\"dropRight\",\"SAVE_ERROR\",\"tokenMatcher\",\"call\",\"apply\",\"SKIP_TOKEN\",\"addToResyncTokens\",\"importLexerState\",\"Recoverable.prototype.shouldInRepetitionRecoveryBeTried\",\"isBackTracking\",\"canPerformInRuleRecovery\",\"getFollowsForInRuleRecovery\",\"Recoverable.prototype.getFollowsForInRuleRecovery\",\"tokIdxInRule\",\"grammarPath\",\"getCurrentGrammarPath\",\"getNextPossibleTokenTypes\",\"follows\",\"tryInRuleRecovery\",\"Recoverable.prototype.tryInRuleRecovery\",\"canRecoverWithSingleTokenInsertion\",\"canRecoverWithSingleTokenDeletion\",\"nextTok\",\"consumeToken\",\"Recoverable.prototype.canPerformInRuleRecovery\",\"expectedToken\",\"Recoverable.prototype.canRecoverWithSingleTokenInsertion\",\"isEmpty\",\"mismatchedTok\",\"find\",\"possibleFollowsTokType\",\"Recoverable.prototype.canRecoverWithSingleTokenDeletion\",\"isNextTokenWhatIsExpected\",\"isInCurrentRuleReSyncSet\",\"Recoverable.prototype.isInCurrentRuleReSyncSet\",\"tokenTypeIdx\",\"followKey\",\"getCurrFollowKey\",\"currentRuleReSyncSet\",\"getFollowSetFromFollowKey\",\"contains\",\"Recoverable.prototype.findReSyncTokenType\",\"allPossibleReSyncTokTypes\",\"flattenFollowSet\",\"nextToken\",\"k\",\"nextTokenType\",\"tokenType\",\"Recoverable.prototype.getCurrFollowKey\",\"currRuleShortName\",\"getLastExplicitRuleShortName\",\"currRuleIdx\",\"getLastExplicitRuleOccurrenceIndex\",\"prevRuleShortName\",\"getPreviousExplicitRuleShortName\",\"shortRuleNameToFullName\",\"idxInCallingRule\",\"inRule\",\"buildFullFollowKeyStack\",\"Recoverable.prototype.buildFullFollowKeyStack\",\"explicitRuleStack\",\"explicitOccurrenceStack\",\"RULE_OCCURRENCE_STACK\",\"map\",\"idx\",\"Recoverable.prototype.flattenFollowSet\",\"followStack\",\"currKey\",\"flatten\",\"Recoverable.prototype.getFollowSetFromFollowKey\",\"IN\",\"Recoverable.prototype.addToResyncTokens\",\"resyncTokens\",\"push\",\"reSyncTo\",\"Recoverable.prototype.reSyncTo\",\"Recoverable.prototype.attemptInRepetitionRecovery\",\"Recoverable.prototype.getCurrentGrammarPath\",\"pathRuleStack\",\"getHumanReadableRuleStack\",\"pathOccurrenceStack\",\"cloneArr\",\"ruleStack\",\"occurrenceStack\",\"lastTok\",\"lastTokOccurrence\",\"Recoverable.prototype.getHumanReadableRuleStack\",\"currShortName\"]\n}\n"]