["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$parse$parser$traits$recognizer_engine=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.RecognizerEngine=void 0;var utils_1=require(\"module$node_modules$$chevrotain$utils$lib$src$api\"),keys_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$keys\"),exceptions_public_1=require(\"module$node_modules$chevrotain$lib$src$parse$exceptions_public\"),lookahead_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$lookahead\"),\ninterpreter_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$interpreter\"),parser_1=require(\"module$node_modules$chevrotain$lib$src$parse$parser$parser\"),recoverable_1=require(\"module$node_modules$chevrotain$lib$src$parse$parser$traits$recoverable\"),tokens_public_1=require(\"module$node_modules$chevrotain$lib$src$scan$tokens_public\"),tokens_1=require(\"module$node_modules$chevrotain$lib$src$scan$tokens\"),lang_extensions_1=require(\"module$node_modules$chevrotain$lib$src$lang$lang_extensions\");\nglobal=function(){function RecognizerEngine(){}RecognizerEngine.prototype.initRecognizerEngine=function(tokenVocabulary,config){this.className=lang_extensions_1.classNameFromInstance(this);this.shortRuleNameToFull={};this.fullRuleNameToShort={};this.ruleShortNameIdx=256;this.tokenMatcher=tokens_1.tokenStructuredMatcherNoCategories;this.definedRulesNames=[];this.tokensMap={};this.isBackTrackingStack=[];this.RULE_STACK=[];this.RULE_OCCURRENCE_STACK=[];this.gastProductionsCache={};if(utils_1.has(config,\n\"serializedGrammar\"))throw Error(\"The Parser's configuration can no longer contain a \\x3cserializedGrammar\\x3e property.\\n\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\\tFor Further details.\");if(utils_1.isArray(tokenVocabulary)){if(utils_1.isEmpty(tokenVocabulary))throw Error(\"A Token Vocabulary cannot be empty.\\n\\tNote that the first argument for the parser constructor\\n\\tis no longer a Token vector (since v4.0).\");if(\"number\"===typeof tokenVocabulary[0].startOffset)throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\\tFor Further details.\");\n}if(utils_1.isArray(tokenVocabulary))this.tokensMap=utils_1.reduce(tokenVocabulary,function(acc,tokType){acc[tokType.name]=tokType;return acc},{});else if(utils_1.has(tokenVocabulary,\"modes\")&&utils_1.every(utils_1.flatten(utils_1.values(tokenVocabulary.modes)),tokens_1.isTokenType))config=utils_1.flatten(utils_1.values(tokenVocabulary.modes)),config=utils_1.uniq(config),this.tokensMap=utils_1.reduce(config,function(acc,tokType){acc[tokType.name]=tokType;return acc},{});else if(utils_1.isObject(tokenVocabulary))this.tokensMap=\nutils_1.cloneObj(tokenVocabulary);else throw Error(\"\\x3ctokensDictionary\\x3e argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");this.tokensMap.EOF=tokens_public_1.EOF;this.tokenMatcher=utils_1.every(utils_1.values(tokenVocabulary),function(tokenConstructor){return utils_1.isEmpty(tokenConstructor.categoryMatches)})?tokens_1.tokenStructuredMatcherNoCategories:tokens_1.tokenStructuredMatcher;tokens_1.augmentTokenTypes(utils_1.values(this.tokensMap))};\nRecognizerEngine.prototype.defineRule=function(ruleName,impl,config){if(this.selfAnalysisDone)throw Error(\"Grammar rule \\x3c\"+ruleName+\"\\x3e may not be defined after the 'performSelfAnalysis' method has been called'\\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");var resyncEnabled=utils_1.has(config,\"resyncEnabled\")?config.resyncEnabled:parser_1.DEFAULT_RULE_CONFIG.resyncEnabled,recoveryValueFunc=utils_1.has(config,\"recoveryValueFunc\")?config.recoveryValueFunc:\nparser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc,shortName=this.ruleShortNameIdx<<keys_1.BITS_FOR_METHOD_TYPE+keys_1.BITS_FOR_OCCURRENCE_IDX;this.ruleShortNameIdx++;this.shortRuleNameToFull[shortName]=ruleName;this.fullRuleNameToShort[ruleName]=shortName;config=function(idxInCallingRule,args){void 0===idxInCallingRule&&(idxInCallingRule=0);this.ruleInvocationStateUpdate(shortName,ruleName,idxInCallingRule);a:{try{if(!0===this.outputCst){impl.apply(this,args);var cst=this.CST_STACK[this.CST_STACK.length-\n1];this.cstPostRule(cst);var JSCompiler_inline_result=cst}else JSCompiler_inline_result=impl.apply(this,args);break a}catch(e){JSCompiler_inline_result=this.invokeRuleCatch(e,resyncEnabled,recoveryValueFunc);break a}finally{this.ruleFinallyStateUpdate()}JSCompiler_inline_result=void 0}return JSCompiler_inline_result};config.ruleName=ruleName;config.originalGrammarAction=impl;return config};RecognizerEngine.prototype.invokeRuleCatch=function(e,resyncEnabledConfig,recoveryValueFunc){var isFirstInvokedRule=\n1===this.RULE_STACK.length;resyncEnabledConfig=resyncEnabledConfig&&!this.isBackTracking()&&this.recoveryEnabled;if(exceptions_public_1.isRecognitionException(e)){if(resyncEnabledConfig){isFirstInvokedRule=this.findReSyncTokenType();if(this.isInCurrentRuleReSyncSet(isFirstInvokedRule))return e.resyncedTokens=this.reSyncTo(isFirstInvokedRule),this.outputCst?(recoveryValueFunc=this.CST_STACK[this.CST_STACK.length-1],recoveryValueFunc.recoveredNode=!0,recoveryValueFunc):recoveryValueFunc();this.outputCst&&\n(recoveryValueFunc=this.CST_STACK[this.CST_STACK.length-1],recoveryValueFunc.recoveredNode=!0,e.partialCstResult=recoveryValueFunc);throw e;}if(isFirstInvokedRule)return this.moveToTerminatedState(),recoveryValueFunc()}throw e;};RecognizerEngine.prototype.optionInternal=function(actionORMethodDef,occurrence){var key=this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX,occurrence);return this.optionInternalLogic(actionORMethodDef,occurrence,key)};RecognizerEngine.prototype.optionInternalLogic=function(actionORMethodDef,\noccurrence,key){var _this=this;occurrence=this.getLaFuncFromCache(key);if(void 0!==actionORMethodDef.DEF){key=actionORMethodDef.DEF;var predicate=actionORMethodDef.GATE;if(void 0!==predicate){var orgLookaheadFunction_1=occurrence;occurrence=function(){return predicate.call(_this)&&orgLookaheadFunction_1.call(_this)}}}else key=actionORMethodDef;if(!0===occurrence.call(this))return key.call(this)};RecognizerEngine.prototype.atLeastOneInternal=function(prodOccurrence,actionORMethodDef){var laKey=this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX,\nprodOccurrence);return this.atLeastOneInternalLogic(prodOccurrence,actionORMethodDef,laKey)};RecognizerEngine.prototype.atLeastOneInternalLogic=function(prodOccurrence,actionORMethodDef,key){var _this=this;key=this.getLaFuncFromCache(key);if(void 0!==actionORMethodDef.DEF){var action=actionORMethodDef.DEF;var predicate=actionORMethodDef.GATE;if(void 0!==predicate){var orgLookaheadFunction_2=key;key=function(){return predicate.call(_this)&&orgLookaheadFunction_2.call(_this)}}}else action=actionORMethodDef;\nif(!0===key.call(this))for(var notStuck=this.doSingleRepetition(action);!0===key.call(this)&&!0===notStuck;)notStuck=this.doSingleRepetition(action);else throw this.raiseEarlyExitException(prodOccurrence,lookahead_1.PROD_TYPE.REPETITION_MANDATORY,actionORMethodDef.ERR_MSG);this.attemptInRepetitionRecovery(this.atLeastOneInternal,[prodOccurrence,actionORMethodDef],key,keys_1.AT_LEAST_ONE_IDX,prodOccurrence,interpreter_1.NextTerminalAfterAtLeastOneWalker)};RecognizerEngine.prototype.atLeastOneSepFirstInternal=\nfunction(prodOccurrence,options){var laKey=this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX,prodOccurrence);this.atLeastOneSepFirstInternalLogic(prodOccurrence,options,laKey)};RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic=function(prodOccurrence,options,key){var _this=this,action=options.DEF,separator=options.SEP;if(!0===this.getLaFuncFromCache(key).call(this)){action.call(this);for(options=function(){return _this.tokenMatcher(_this.LA(1),separator)};!0===this.tokenMatcher(this.LA(1),\nseparator);)this.CONSUME(separator),action.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[prodOccurrence,separator,options,action,interpreter_1.NextTerminalAfterAtLeastOneSepWalker],options,keys_1.AT_LEAST_ONE_SEP_IDX,prodOccurrence,interpreter_1.NextTerminalAfterAtLeastOneSepWalker)}else throw this.raiseEarlyExitException(prodOccurrence,lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,options.ERR_MSG);};RecognizerEngine.prototype.manyInternal=function(prodOccurrence,\nactionORMethodDef){var laKey=this.getKeyForAutomaticLookahead(keys_1.MANY_IDX,prodOccurrence);return this.manyInternalLogic(prodOccurrence,actionORMethodDef,laKey)};RecognizerEngine.prototype.manyInternalLogic=function(prodOccurrence,actionORMethodDef,key){var _this=this;key=this.getLaFuncFromCache(key);if(void 0!==actionORMethodDef.DEF){var action=actionORMethodDef.DEF;var predicate=actionORMethodDef.GATE;if(void 0!==predicate){var orgLookaheadFunction_3=key;key=function(){return predicate.call(_this)&&\norgLookaheadFunction_3.call(_this)}}}else action=actionORMethodDef;for(var notStuck=!0;!0===key.call(this)&&!0===notStuck;)notStuck=this.doSingleRepetition(action);this.attemptInRepetitionRecovery(this.manyInternal,[prodOccurrence,actionORMethodDef],key,keys_1.MANY_IDX,prodOccurrence,interpreter_1.NextTerminalAfterManyWalker,notStuck)};RecognizerEngine.prototype.manySepFirstInternal=function(prodOccurrence,options){var laKey=this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX,prodOccurrence);this.manySepFirstInternalLogic(prodOccurrence,\noptions,laKey)};RecognizerEngine.prototype.manySepFirstInternalLogic=function(prodOccurrence,options,key){var _this=this,action=options.DEF,separator=options.SEP;if(!0===this.getLaFuncFromCache(key).call(this)){action.call(this);for(options=function(){return _this.tokenMatcher(_this.LA(1),separator)};!0===this.tokenMatcher(this.LA(1),separator);)this.CONSUME(separator),action.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[prodOccurrence,separator,options,action,interpreter_1.NextTerminalAfterManySepWalker],\noptions,keys_1.MANY_SEP_IDX,prodOccurrence,interpreter_1.NextTerminalAfterManySepWalker)}};RecognizerEngine.prototype.repetitionSepSecondInternal=function(prodOccurrence,separator,separatorLookAheadFunc,action,nextTerminalAfterWalker){for(;separatorLookAheadFunc();)this.CONSUME(separator),action.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[prodOccurrence,separator,separatorLookAheadFunc,action,nextTerminalAfterWalker],separatorLookAheadFunc,keys_1.AT_LEAST_ONE_SEP_IDX,\nprodOccurrence,nextTerminalAfterWalker)};RecognizerEngine.prototype.doSingleRepetition=function(action){var beforeIteration=this.getLexerPosition();action.call(this);return this.getLexerPosition()>beforeIteration};RecognizerEngine.prototype.orInternal=function(altsOrOpts,occurrence){var laKey=this.getKeyForAutomaticLookahead(keys_1.OR_IDX,occurrence),alts=utils_1.isArray(altsOrOpts)?altsOrOpts:altsOrOpts.DEF;laKey=this.getLaFuncFromCache(laKey).call(this,alts);if(void 0!==laKey)return alts[laKey].ALT.call(this);\nthis.raiseNoAltException(occurrence,altsOrOpts.ERR_MSG)};RecognizerEngine.prototype.ruleFinallyStateUpdate=function(){this.RULE_STACK.pop();this.RULE_OCCURRENCE_STACK.pop();this.cstFinallyStateUpdate();if(0===this.RULE_STACK.length&&!1===this.isAtEndOfInput()){var firstRedundantTok=this.LA(1),errMsg=this.errorMessageProvider.buildNotAllInputParsedMessage({firstRedundant:firstRedundantTok,ruleName:this.getCurrRuleFullName()});this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg,\nfirstRedundantTok))}};RecognizerEngine.prototype.subruleInternal=function(ruleToCall,idx,options){try{var ruleResult=ruleToCall.call(this,idx,void 0!==options?options.ARGS:void 0);this.cstPostNonTerminal(ruleResult,void 0!==options&&void 0!==options.LABEL?options.LABEL:ruleToCall.ruleName);return ruleResult}catch(e){this.subruleInternalError(e,options,ruleToCall.ruleName)}};RecognizerEngine.prototype.subruleInternalError=function(e,options,ruleName){exceptions_public_1.isRecognitionException(e)&&\nvoid 0!==e.partialCstResult&&(this.cstPostNonTerminal(e.partialCstResult,void 0!==options&&void 0!==options.LABEL?options.LABEL:ruleName),delete e.partialCstResult);throw e;};RecognizerEngine.prototype.consumeInternal=function(tokType,idx,options){try{var nextToken=this.LA(1);if(!0===this.tokenMatcher(nextToken,tokType)){this.consumeToken();var consumedToken=nextToken}else this.consumeInternalError(tokType,nextToken,options)}catch(eFromConsumption){consumedToken=this.consumeInternalRecovery(tokType,\nidx,eFromConsumption)}this.cstPostTerminal(void 0!==options&&void 0!==options.LABEL?options.LABEL:tokType.name,consumedToken);return consumedToken};RecognizerEngine.prototype.consumeInternalError=function(tokType,nextToken,options){var previousToken=this.LA(0);tokType=void 0!==options&&options.ERR_MSG?options.ERR_MSG:this.errorMessageProvider.buildMismatchTokenMessage({expected:tokType,actual:nextToken,previous:previousToken,ruleName:this.getCurrRuleFullName()});throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(tokType,\nnextToken,previousToken));};RecognizerEngine.prototype.consumeInternalRecovery=function(tokType,idx,eFromConsumption){if(this.recoveryEnabled&&\"MismatchedTokenException\"===eFromConsumption.name&&!this.isBackTracking()){idx=this.getFollowsForInRuleRecovery(tokType,idx);try{return this.tryInRuleRecovery(tokType,idx)}catch(eFromInRuleRecovery){if(eFromInRuleRecovery.name===recoverable_1.IN_RULE_RECOVERY_EXCEPTION)throw eFromConsumption;throw eFromInRuleRecovery;}}else throw eFromConsumption;};RecognizerEngine.prototype.saveRecogState=\nfunction(){var savedErrors=this.errors,savedRuleStack=utils_1.cloneArr(this.RULE_STACK);return{errors:savedErrors,lexerState:this.exportLexerState(),RULE_STACK:savedRuleStack,CST_STACK:this.CST_STACK}};RecognizerEngine.prototype.reloadRecogState=function(newState){this.errors=newState.errors;this.importLexerState(newState.lexerState);this.RULE_STACK=newState.RULE_STACK};RecognizerEngine.prototype.ruleInvocationStateUpdate=function(shortName,fullName,idxInCallingRule){this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\nthis.RULE_STACK.push(shortName);this.cstInvocationStateUpdate(fullName,shortName)};RecognizerEngine.prototype.isBackTracking=function(){return 0!==this.isBackTrackingStack.length};RecognizerEngine.prototype.getCurrRuleFullName=function(){var shortName=this.getLastExplicitRuleShortName();return this.shortRuleNameToFull[shortName]};RecognizerEngine.prototype.shortRuleNameToFullName=function(shortName){return this.shortRuleNameToFull[shortName]};RecognizerEngine.prototype.isAtEndOfInput=function(){return this.tokenMatcher(this.LA(1),\ntokens_public_1.EOF)};RecognizerEngine.prototype.reset=function(){this.resetLexerState();this.isBackTrackingStack=[];this.errors=[];this.RULE_STACK=[];this.CST_STACK=[];this.RULE_OCCURRENCE_STACK=[]};return RecognizerEngine}();exports.RecognizerEngine=global}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$parse$parser$traits$recognizer_engine\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RecognizerEngine = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar keys_1 = require(\"../../grammar/keys\");\nvar exceptions_public_1 = require(\"../../exceptions_public\");\nvar lookahead_1 = require(\"../../grammar/lookahead\");\nvar interpreter_1 = require(\"../../grammar/interpreter\");\nvar parser_1 = require(\"../parser\");\nvar recoverable_1 = require(\"./recoverable\");\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar tokens_1 = require(\"../../../scan/tokens\");\nvar lang_extensions_1 = require(\"../../../lang/lang_extensions\");\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nvar RecognizerEngine = /** @class */ (function () {\n    function RecognizerEngine() {\n    }\n    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\n        this.className = lang_extensions_1.classNameFromInstance(this);\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if (utils_1.has(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n                \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\n                \"\\tFor Further details.\");\n        }\n        if (utils_1.isArray(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if (utils_1.isEmpty(tokenVocabulary)) {\n                throw Error(\"A Token Vocabulary cannot be empty.\\n\" +\n                    \"\\tNote that the first argument for the parser constructor\\n\" +\n                    \"\\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n                throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\n                    \"\\tFor Further details.\");\n            }\n        }\n        if (utils_1.isArray(tokenVocabulary)) {\n            this.tokensMap = utils_1.reduce(tokenVocabulary, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (utils_1.has(tokenVocabulary, \"modes\") &&\n            utils_1.every(utils_1.flatten(utils_1.values(tokenVocabulary.modes)), tokens_1.isTokenType)) {\n            var allTokenTypes = utils_1.flatten(utils_1.values(tokenVocabulary.modes));\n            var uniqueTokens = utils_1.uniq(allTokenTypes);\n            this.tokensMap = utils_1.reduce(uniqueTokens, function (acc, tokType) {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if (utils_1.isObject(tokenVocabulary)) {\n            this.tokensMap = utils_1.cloneObj(tokenVocabulary);\n        }\n        else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors,\" +\n                \" A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message (\"expecting EOF but found ...\")\n        /* tslint:disable */\n        this.tokensMap[\"EOF\"] = tokens_public_1.EOF;\n        // TODO: This check may not be accurate for multi mode lexers\n        var noTokenCategoriesUsed = utils_1.every(utils_1.values(tokenVocabulary), function (tokenConstructor) { return utils_1.isEmpty(tokenConstructor.categoryMatches); });\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokens_1.tokenStructuredMatcherNoCategories\n            : tokens_1.tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        tokens_1.augmentTokenTypes(utils_1.values(this.tokensMap));\n    };\n    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(\"Grammar rule <\" + ruleName + \"> may not be defined after the 'performSelfAnalysis' method has been called'\\n\" +\n                \"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\");\n        }\n        var resyncEnabled = utils_1.has(config, \"resyncEnabled\")\n            ? config.resyncEnabled\n            : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;\n        var recoveryValueFunc = utils_1.has(config, \"recoveryValueFunc\")\n            ? config.recoveryValueFunc\n            : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        /* tslint:disable */\n        var shortName = this.ruleShortNameIdx << (keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX);\n        /* tslint:enable */\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        function invokeRuleWithTry(args) {\n            try {\n                if (this.outputCst === true) {\n                    impl.apply(this, args);\n                    var cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                else {\n                    return impl.apply(this, args);\n                }\n            }\n            catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n            }\n            finally {\n                this.ruleFinallyStateUpdate();\n            }\n        }\n        var wrappedGrammarRule = function (idxInCallingRule, args) {\n            if (idxInCallingRule === void 0) { idxInCallingRule = 0; }\n            this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\n            return invokeRuleWithTry.call(this, args);\n        };\n        var ruleNamePropName = \"ruleName\";\n        wrappedGrammarRule[ruleNamePropName] = ruleName;\n        wrappedGrammarRule[\"originalGrammarAction\"] = impl;\n        return wrappedGrammarRule;\n    };\n    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\n        var isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n        // path is really the most valid one\n        var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if (exceptions_public_1.isRecognitionException(e)) {\n            var recogError = e;\n            if (reSyncEnabled) {\n                var reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc();\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc();\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    };\n    // Implementation of parsing DSL\n    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\n        var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    };\n    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_1 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return predicate.call(_this) && orgLookaheadFunction_1.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    };\n    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookAheadFunc = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_2 = lookAheadFunc;\n                lookAheadFunc = function () {\n                    return predicate.call(_this) && orgLookaheadFunction_2.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            var notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            ;\n            action.call(this);\n            //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n            //  because it is only needed in error recovery scenarios.\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                interpreter_1.NextTerminalAfterAtLeastOneSepWalker\n            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    };\n    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    };\n    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\n        var _this = this;\n        var lookaheadFunction = this.getLaFuncFromCache(key);\n        var action;\n        var predicate;\n        if (actionORMethodDef.DEF !== undefined) {\n            action = actionORMethodDef.DEF;\n            predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                var orgLookaheadFunction_3 = lookaheadFunction;\n                lookaheadFunction = function () {\n                    return predicate.call(_this) && orgLookaheadFunction_3.call(_this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        var notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    };\n    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    };\n    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\n        var _this = this;\n        var action = options.DEF;\n        var separator = options.SEP;\n        var firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function () {\n                return _this.tokenMatcher(_this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                interpreter_1.NextTerminalAfterManySepWalker\n            ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);\n        }\n    };\n    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name 'second') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker\n        ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    };\n    RecognizerEngine.prototype.doSingleRepetition = function (action) {\n        var beforeIteration = this.getLexerPosition();\n        action.call(this);\n        var afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are \"stuck\" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    };\n    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);\n        var alts = utils_1.isArray(altsOrOpts)\n            ? altsOrOpts\n            : altsOrOpts.DEF;\n        var laFunc = this.getLaFuncFromCache(laKey);\n        var altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            var chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    };\n    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            var firstRedundantTok = this.LA(1);\n            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    };\n    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\n        var ruleResult;\n        try {\n            var args = options !== undefined ? options.ARGS : undefined;\n            ruleResult = ruleToCall.call(this, idx, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    };\n    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\n        if (exceptions_public_1.isRecognitionException(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    };\n    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\n        var consumedToken;\n        try {\n            var nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    };\n    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\n        var msg;\n        var previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName()\n            });\n        }\n        throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));\n    };\n    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === \"MismatchedTokenException\" &&\n            !this.isBackTracking()) {\n            var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    };\n    RecognizerEngine.prototype.saveRecogState = function () {\n        // errors is a getter which will clone the errors array\n        var savedErrors = this.errors;\n        var savedRuleStack = utils_1.cloneArr(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK\n        };\n    };\n    RecognizerEngine.prototype.reloadRecogState = function (newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    };\n    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName, shortName);\n    };\n    RecognizerEngine.prototype.isBackTracking = function () {\n        return this.isBackTrackingStack.length !== 0;\n    };\n    RecognizerEngine.prototype.getCurrRuleFullName = function () {\n        var shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\n        return this.shortRuleNameToFull[shortName];\n    };\n    RecognizerEngine.prototype.isAtEndOfInput = function () {\n        return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);\n    };\n    RecognizerEngine.prototype.reset = function () {\n        this.resetLexerState();\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        // TODO: extract a specific reset for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    };\n    return RecognizerEngine;\n}());\nexports.RecognizerEngine = RecognizerEngine;\n//# sourceMappingURL=recognizer_engine.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$chevrotain$utils$lib$src$api","~$module$node_modules$chevrotain$lib$src$parse$grammar$interpreter","~$module$node_modules$chevrotain$lib$src$scan$tokens","~$shadow.js","~$module$node_modules$chevrotain$lib$src$parse$parser$traits$recoverable","~$module$node_modules$chevrotain$lib$src$parse$grammar$keys","~$module$node_modules$chevrotain$lib$src$scan$tokens_public","~$module$node_modules$chevrotain$lib$src$lang$lang_extensions","~$module$node_modules$chevrotain$lib$src$parse$exceptions_public","~$module$node_modules$chevrotain$lib$src$parse$parser$parser","~$module$node_modules$chevrotain$lib$src$parse$grammar$lookahead"]],"~:properties",["^5",["repetitionSepSecondInternal","shortRuleNameToFull","getCurrRuleFullName","defineRule","atLeastOneInternalLogic","ruleName","isBackTrackingStack","atLeastOneInternal","gastProductionsCache","CST_STACK","className","ruleFinallyStateUpdate","consumeInternalRecovery","tokenMatcher","atLeastOneSepFirstInternal","__esModule","doSingleRepetition","subruleInternal","reset","errors","reloadRecogState","saveRecogState","RecognizerEngine","RULE_STACK","expected","ruleShortNameIdx","value","ruleInvocationStateUpdate","previous","RULE_OCCURRENCE_STACK","definedRulesNames","isBackTracking","manyInternal","optionInternal","partialCstResult","orInternal","recoveredNode","consumeInternal","firstRedundant","shortRuleNameToFullName","manySepFirstInternalLogic","consumeInternalError","optionInternalLogic","resyncedTokens","isAtEndOfInput","tokensMap","actual","manyInternalLogic","initRecognizerEngine","lexerState","subruleInternalError","manySepFirstInternal","invokeRuleCatch","atLeastOneSepFirstInternalLogic","fullRuleNameToShort"]],"~:compiled-at",1630917515713,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$parse$parser$traits$recognizer_engine.js\",\n\"lineCount\":29,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$parse$parser$traits$recognizer_engine\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.RecognizerEngine = void 0;\\nvar utils_1 = require(\\\"@chevrotain/utils\\\");\\nvar keys_1 = require(\\\"../../grammar/keys\\\");\\nvar exceptions_public_1 = require(\\\"../../exceptions_public\\\");\\nvar lookahead_1 = require(\\\"../../grammar/lookahead\\\");\\nvar interpreter_1 = require(\\\"../../grammar/interpreter\\\");\\nvar parser_1 = require(\\\"../parser\\\");\\nvar recoverable_1 = require(\\\"./recoverable\\\");\\nvar tokens_public_1 = require(\\\"../../../scan/tokens_public\\\");\\nvar tokens_1 = require(\\\"../../../scan/tokens\\\");\\nvar lang_extensions_1 = require(\\\"../../../lang/lang_extensions\\\");\\n/**\\n * This trait is responsible for the runtime parsing engine\\n * Used by the official API (recognizer_api.ts)\\n */\\nvar RecognizerEngine = /** @class */ (function () {\\n    function RecognizerEngine() {\\n    }\\n    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {\\n        this.className = lang_extensions_1.classNameFromInstance(this);\\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\\n        this.shortRuleNameToFull = {};\\n        this.fullRuleNameToShort = {};\\n        this.ruleShortNameIdx = 256;\\n        this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;\\n        this.definedRulesNames = [];\\n        this.tokensMap = {};\\n        this.isBackTrackingStack = [];\\n        this.RULE_STACK = [];\\n        this.RULE_OCCURRENCE_STACK = [];\\n        this.gastProductionsCache = {};\\n        if (utils_1.has(config, \\\"serializedGrammar\\\")) {\\n            throw Error(\\\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\\\n\\\" +\\n                \\\"\\\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\\\n\\\" +\\n                \\\"\\\\tFor Further details.\\\");\\n        }\\n        if (utils_1.isArray(tokenVocabulary)) {\\n            // This only checks for Token vocabularies provided as arrays.\\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\\n            // rather than all edge cases of empty Token vocabularies.\\n            if (utils_1.isEmpty(tokenVocabulary)) {\\n                throw Error(\\\"A Token Vocabulary cannot be empty.\\\\n\\\" +\\n                    \\\"\\\\tNote that the first argument for the parser constructor\\\\n\\\" +\\n                    \\\"\\\\tis no longer a Token vector (since v4.0).\\\");\\n            }\\n            if (typeof tokenVocabulary[0].startOffset === \\\"number\\\") {\\n                throw Error(\\\"The Parser constructor no longer accepts a token vector as the first argument.\\\\n\\\" +\\n                    \\\"\\\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\\\n\\\" +\\n                    \\\"\\\\tFor Further details.\\\");\\n            }\\n        }\\n        if (utils_1.isArray(tokenVocabulary)) {\\n            this.tokensMap = utils_1.reduce(tokenVocabulary, function (acc, tokType) {\\n                acc[tokType.name] = tokType;\\n                return acc;\\n            }, {});\\n        }\\n        else if (utils_1.has(tokenVocabulary, \\\"modes\\\") &&\\n            utils_1.every(utils_1.flatten(utils_1.values(tokenVocabulary.modes)), tokens_1.isTokenType)) {\\n            var allTokenTypes = utils_1.flatten(utils_1.values(tokenVocabulary.modes));\\n            var uniqueTokens = utils_1.uniq(allTokenTypes);\\n            this.tokensMap = utils_1.reduce(uniqueTokens, function (acc, tokType) {\\n                acc[tokType.name] = tokType;\\n                return acc;\\n            }, {});\\n        }\\n        else if (utils_1.isObject(tokenVocabulary)) {\\n            this.tokensMap = utils_1.cloneObj(tokenVocabulary);\\n        }\\n        else {\\n            throw new Error(\\\"<tokensDictionary> argument must be An Array of Token constructors,\\\" +\\n                \\\" A dictionary of Token constructors or an IMultiModeLexerDefinition\\\");\\n        }\\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\\n        // parsed with a clear error message (\\\"expecting EOF but found ...\\\")\\n        /* tslint:disable */\\n        this.tokensMap[\\\"EOF\\\"] = tokens_public_1.EOF;\\n        // TODO: This check may not be accurate for multi mode lexers\\n        var noTokenCategoriesUsed = utils_1.every(utils_1.values(tokenVocabulary), function (tokenConstructor) { return utils_1.isEmpty(tokenConstructor.categoryMatches); });\\n        this.tokenMatcher = noTokenCategoriesUsed\\n            ? tokens_1.tokenStructuredMatcherNoCategories\\n            : tokens_1.tokenStructuredMatcher;\\n        // Because ES2015+ syntax should be supported for creating Token classes\\n        // We cannot assume that the Token classes were created using the \\\"extendToken\\\" utilities\\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\\n        tokens_1.augmentTokenTypes(utils_1.values(this.tokensMap));\\n    };\\n    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {\\n        if (this.selfAnalysisDone) {\\n            throw Error(\\\"Grammar rule <\\\" + ruleName + \\\"> may not be defined after the 'performSelfAnalysis' method has been called'\\\\n\\\" +\\n                \\\"Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\\\");\\n        }\\n        var resyncEnabled = utils_1.has(config, \\\"resyncEnabled\\\")\\n            ? config.resyncEnabled\\n            : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;\\n        var recoveryValueFunc = utils_1.has(config, \\\"recoveryValueFunc\\\")\\n            ? config.recoveryValueFunc\\n            : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;\\n        // performance optimization: Use small integers as keys for the longer human readable \\\"full\\\" rule names.\\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\\n        /* tslint:disable */\\n        var shortName = this.ruleShortNameIdx << (keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX);\\n        /* tslint:enable */\\n        this.ruleShortNameIdx++;\\n        this.shortRuleNameToFull[shortName] = ruleName;\\n        this.fullRuleNameToShort[ruleName] = shortName;\\n        function invokeRuleWithTry(args) {\\n            try {\\n                if (this.outputCst === true) {\\n                    impl.apply(this, args);\\n                    var cst = this.CST_STACK[this.CST_STACK.length - 1];\\n                    this.cstPostRule(cst);\\n                    return cst;\\n                }\\n                else {\\n                    return impl.apply(this, args);\\n                }\\n            }\\n            catch (e) {\\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\\n            }\\n            finally {\\n                this.ruleFinallyStateUpdate();\\n            }\\n        }\\n        var wrappedGrammarRule = function (idxInCallingRule, args) {\\n            if (idxInCallingRule === void 0) { idxInCallingRule = 0; }\\n            this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);\\n            return invokeRuleWithTry.call(this, args);\\n        };\\n        var ruleNamePropName = \\\"ruleName\\\";\\n        wrappedGrammarRule[ruleNamePropName] = ruleName;\\n        wrappedGrammarRule[\\\"originalGrammarAction\\\"] = impl;\\n        return wrappedGrammarRule;\\n    };\\n    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {\\n        var isFirstInvokedRule = this.RULE_STACK.length === 1;\\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\\n        // reSync with EOF and just output some INVALID ParseTree\\n        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\\n        // path is really the most valid one\\n        var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\\n        if (exceptions_public_1.isRecognitionException(e)) {\\n            var recogError = e;\\n            if (reSyncEnabled) {\\n                var reSyncTokType = this.findReSyncTokenType();\\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\\n                    if (this.outputCst) {\\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\\n                        partialCstResult.recoveredNode = true;\\n                        return partialCstResult;\\n                    }\\n                    else {\\n                        return recoveryValueFunc();\\n                    }\\n                }\\n                else {\\n                    if (this.outputCst) {\\n                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\\n                        partialCstResult.recoveredNode = true;\\n                        recogError.partialCstResult = partialCstResult;\\n                    }\\n                    // to be handled Further up the call stack\\n                    throw recogError;\\n                }\\n            }\\n            else if (isFirstInvokedRule) {\\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\\n                this.moveToTerminatedState();\\n                // the parser should never throw one of its own errors outside its flow.\\n                // even if error recovery is disabled\\n                return recoveryValueFunc();\\n            }\\n            else {\\n                // to be recovered Further up the call stack\\n                throw recogError;\\n            }\\n        }\\n        else {\\n            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\\n            throw e;\\n        }\\n    };\\n    // Implementation of parsing DSL\\n    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {\\n        var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);\\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\\n    };\\n    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {\\n        var _this = this;\\n        var lookAheadFunc = this.getLaFuncFromCache(key);\\n        var action;\\n        var predicate;\\n        if (actionORMethodDef.DEF !== undefined) {\\n            action = actionORMethodDef.DEF;\\n            predicate = actionORMethodDef.GATE;\\n            // predicate present\\n            if (predicate !== undefined) {\\n                var orgLookaheadFunction_1 = lookAheadFunc;\\n                lookAheadFunc = function () {\\n                    return predicate.call(_this) && orgLookaheadFunction_1.call(_this);\\n                };\\n            }\\n        }\\n        else {\\n            action = actionORMethodDef;\\n        }\\n        if (lookAheadFunc.call(this) === true) {\\n            return action.call(this);\\n        }\\n        return undefined;\\n    };\\n    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {\\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);\\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\\n    };\\n    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\\n        var _this = this;\\n        var lookAheadFunc = this.getLaFuncFromCache(key);\\n        var action;\\n        var predicate;\\n        if (actionORMethodDef.DEF !== undefined) {\\n            action = actionORMethodDef.DEF;\\n            predicate = actionORMethodDef.GATE;\\n            // predicate present\\n            if (predicate !== undefined) {\\n                var orgLookaheadFunction_2 = lookAheadFunc;\\n                lookAheadFunc = function () {\\n                    return predicate.call(_this) && orgLookaheadFunction_2.call(_this);\\n                };\\n            }\\n        }\\n        else {\\n            action = actionORMethodDef;\\n        }\\n        if (lookAheadFunc.call(this) === true) {\\n            var notStuck = this.doSingleRepetition(action);\\n            while (lookAheadFunc.call(this) === true &&\\n                notStuck === true) {\\n                notStuck = this.doSingleRepetition(action);\\n            }\\n        }\\n        else {\\n            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\\n        }\\n        // note that while it may seem that this can cause an error because by using a recursive call to\\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\\n        // Performance optimization: \\\"attemptInRepetitionRecovery\\\" will be defined as NOOP unless recovery is enabled\\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);\\n    };\\n    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {\\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);\\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\\n    };\\n    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {\\n        var _this = this;\\n        var action = options.DEF;\\n        var separator = options.SEP;\\n        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\\n        // 1st iteration\\n        if (firstIterationLookaheadFunc.call(this) === true) {\\n            ;\\n            action.call(this);\\n            //  TODO: Optimization can move this function construction into \\\"attemptInRepetitionRecovery\\\"\\n            //  because it is only needed in error recovery scenarios.\\n            var separatorLookAheadFunc = function () {\\n                return _this.tokenMatcher(_this.LA(1), separator);\\n            };\\n            // 2nd..nth iterations\\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\\n                // note that this CONSUME will never enter recovery because\\n                // the separatorLookAheadFunc checks that the separator really does exist.\\n                this.CONSUME(separator);\\n                action.call(this);\\n            }\\n            // Performance optimization: \\\"attemptInRepetitionRecovery\\\" will be defined as NOOP unless recovery is enabled\\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\\n                prodOccurrence,\\n                separator,\\n                separatorLookAheadFunc,\\n                action,\\n                interpreter_1.NextTerminalAfterAtLeastOneSepWalker\\n            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);\\n        }\\n        else {\\n            throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\\n        }\\n    };\\n    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {\\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);\\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\\n    };\\n    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {\\n        var _this = this;\\n        var lookaheadFunction = this.getLaFuncFromCache(key);\\n        var action;\\n        var predicate;\\n        if (actionORMethodDef.DEF !== undefined) {\\n            action = actionORMethodDef.DEF;\\n            predicate = actionORMethodDef.GATE;\\n            // predicate present\\n            if (predicate !== undefined) {\\n                var orgLookaheadFunction_3 = lookaheadFunction;\\n                lookaheadFunction = function () {\\n                    return predicate.call(_this) && orgLookaheadFunction_3.call(_this);\\n                };\\n            }\\n        }\\n        else {\\n            action = actionORMethodDef;\\n        }\\n        var notStuck = true;\\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\\n            notStuck = this.doSingleRepetition(action);\\n        }\\n        // Performance optimization: \\\"attemptInRepetitionRecovery\\\" will be defined as NOOP unless recovery is enabled\\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker, \\n        // The notStuck parameter is only relevant when \\\"attemptInRepetitionRecovery\\\"\\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\\n        // An infinite loop cannot occur as:\\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\\n        notStuck);\\n    };\\n    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {\\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);\\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\\n    };\\n    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {\\n        var _this = this;\\n        var action = options.DEF;\\n        var separator = options.SEP;\\n        var firstIterationLaFunc = this.getLaFuncFromCache(key);\\n        // 1st iteration\\n        if (firstIterationLaFunc.call(this) === true) {\\n            action.call(this);\\n            var separatorLookAheadFunc = function () {\\n                return _this.tokenMatcher(_this.LA(1), separator);\\n            };\\n            // 2nd..nth iterations\\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\\n                // note that this CONSUME will never enter recovery because\\n                // the separatorLookAheadFunc checks that the separator really does exist.\\n                this.CONSUME(separator);\\n                // No need for checking infinite loop here due to consuming the separator.\\n                action.call(this);\\n            }\\n            // Performance optimization: \\\"attemptInRepetitionRecovery\\\" will be defined as NOOP unless recovery is enabled\\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\\n                prodOccurrence,\\n                separator,\\n                separatorLookAheadFunc,\\n                action,\\n                interpreter_1.NextTerminalAfterManySepWalker\\n            ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);\\n        }\\n    };\\n    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\\n        while (separatorLookAheadFunc()) {\\n            // note that this CONSUME will never enter recovery because\\n            // the separatorLookAheadFunc checks that the separator really does exist.\\n            this.CONSUME(separator);\\n            action.call(this);\\n        }\\n        // we can only arrive to this function after an error\\n        // has occurred (hence the name 'second') so the following\\n        // IF will always be entered, its possible to remove it...\\n        // however it is kept to avoid confusion and be consistent.\\n        // Performance optimization: \\\"attemptInRepetitionRecovery\\\" will be defined as NOOP unless recovery is enabled\\n        /* istanbul ignore else */\\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\\n            prodOccurrence,\\n            separator,\\n            separatorLookAheadFunc,\\n            action,\\n            nextTerminalAfterWalker\\n        ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\\n    };\\n    RecognizerEngine.prototype.doSingleRepetition = function (action) {\\n        var beforeIteration = this.getLexerPosition();\\n        action.call(this);\\n        var afterIteration = this.getLexerPosition();\\n        // This boolean will indicate if this repetition progressed\\n        // or if we are \\\"stuck\\\" (potential infinite loop in the repetition).\\n        return afterIteration > beforeIteration;\\n    };\\n    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {\\n        var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);\\n        var alts = utils_1.isArray(altsOrOpts)\\n            ? altsOrOpts\\n            : altsOrOpts.DEF;\\n        var laFunc = this.getLaFuncFromCache(laKey);\\n        var altIdxToTake = laFunc.call(this, alts);\\n        if (altIdxToTake !== undefined) {\\n            var chosenAlternative = alts[altIdxToTake];\\n            return chosenAlternative.ALT.call(this);\\n        }\\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\\n    };\\n    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {\\n        this.RULE_STACK.pop();\\n        this.RULE_OCCURRENCE_STACK.pop();\\n        // NOOP when cst is disabled\\n        this.cstFinallyStateUpdate();\\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\\n            var firstRedundantTok = this.LA(1);\\n            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\\n                firstRedundant: firstRedundantTok,\\n                ruleName: this.getCurrRuleFullName()\\n            });\\n            this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));\\n        }\\n    };\\n    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {\\n        var ruleResult;\\n        try {\\n            var args = options !== undefined ? options.ARGS : undefined;\\n            ruleResult = ruleToCall.call(this, idx, args);\\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\\n                ? options.LABEL\\n                : ruleToCall.ruleName);\\n            return ruleResult;\\n        }\\n        catch (e) {\\n            this.subruleInternalError(e, options, ruleToCall.ruleName);\\n        }\\n    };\\n    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {\\n        if (exceptions_public_1.isRecognitionException(e) && e.partialCstResult !== undefined) {\\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\\n                ? options.LABEL\\n                : ruleName);\\n            delete e.partialCstResult;\\n        }\\n        throw e;\\n    };\\n    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {\\n        var consumedToken;\\n        try {\\n            var nextToken = this.LA(1);\\n            if (this.tokenMatcher(nextToken, tokType) === true) {\\n                this.consumeToken();\\n                consumedToken = nextToken;\\n            }\\n            else {\\n                this.consumeInternalError(tokType, nextToken, options);\\n            }\\n        }\\n        catch (eFromConsumption) {\\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\\n        }\\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\\n            ? options.LABEL\\n            : tokType.name, consumedToken);\\n        return consumedToken;\\n    };\\n    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {\\n        var msg;\\n        var previousToken = this.LA(0);\\n        if (options !== undefined && options.ERR_MSG) {\\n            msg = options.ERR_MSG;\\n        }\\n        else {\\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\\n                expected: tokType,\\n                actual: nextToken,\\n                previous: previousToken,\\n                ruleName: this.getCurrRuleFullName()\\n            });\\n        }\\n        throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));\\n    };\\n    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {\\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\\n        if (this.recoveryEnabled &&\\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\\n            eFromConsumption.name === \\\"MismatchedTokenException\\\" &&\\n            !this.isBackTracking()) {\\n            var follows = this.getFollowsForInRuleRecovery(tokType, idx);\\n            try {\\n                return this.tryInRuleRecovery(tokType, follows);\\n            }\\n            catch (eFromInRuleRecovery) {\\n                if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {\\n                    // failed in RuleRecovery.\\n                    // throw the original error in order to trigger reSync error recovery\\n                    throw eFromConsumption;\\n                }\\n                else {\\n                    throw eFromInRuleRecovery;\\n                }\\n            }\\n        }\\n        else {\\n            throw eFromConsumption;\\n        }\\n    };\\n    RecognizerEngine.prototype.saveRecogState = function () {\\n        // errors is a getter which will clone the errors array\\n        var savedErrors = this.errors;\\n        var savedRuleStack = utils_1.cloneArr(this.RULE_STACK);\\n        return {\\n            errors: savedErrors,\\n            lexerState: this.exportLexerState(),\\n            RULE_STACK: savedRuleStack,\\n            CST_STACK: this.CST_STACK\\n        };\\n    };\\n    RecognizerEngine.prototype.reloadRecogState = function (newState) {\\n        this.errors = newState.errors;\\n        this.importLexerState(newState.lexerState);\\n        this.RULE_STACK = newState.RULE_STACK;\\n    };\\n    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {\\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\\n        this.RULE_STACK.push(shortName);\\n        // NOOP when cst is disabled\\n        this.cstInvocationStateUpdate(fullName, shortName);\\n    };\\n    RecognizerEngine.prototype.isBackTracking = function () {\\n        return this.isBackTrackingStack.length !== 0;\\n    };\\n    RecognizerEngine.prototype.getCurrRuleFullName = function () {\\n        var shortName = this.getLastExplicitRuleShortName();\\n        return this.shortRuleNameToFull[shortName];\\n    };\\n    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {\\n        return this.shortRuleNameToFull[shortName];\\n    };\\n    RecognizerEngine.prototype.isAtEndOfInput = function () {\\n        return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);\\n    };\\n    RecognizerEngine.prototype.reset = function () {\\n        this.resetLexerState();\\n        this.isBackTrackingStack = [];\\n        this.errors = [];\\n        this.RULE_STACK = [];\\n        // TODO: extract a specific reset for TreeBuilder trait\\n        this.CST_STACK = [];\\n        this.RULE_OCCURRENCE_STACK = [];\\n    };\\n    return RecognizerEngine;\\n}());\\nexports.RecognizerEngine = RecognizerEngine;\\n//# sourceMappingURL=recognizer_engine.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"RecognizerEngine\",\"utils_1\",\"keys_1\",\"exceptions_public_1\",\"lookahead_1\",\"interpreter_1\",\"parser_1\",\"recoverable_1\",\"tokens_public_1\",\"tokens_1\",\"lang_extensions_1\",\"prototype\",\"initRecognizerEngine\",\"RecognizerEngine.prototype.initRecognizerEngine\",\"tokenVocabulary\",\"config\",\"className\",\"classNameFromInstance\",\"shortRuleNameToFull\",\"fullRuleNameToShort\",\"ruleShortNameIdx\",\"tokenMatcher\",\"tokenStructuredMatcherNoCategories\",\"definedRulesNames\",\"tokensMap\",\"isBackTrackingStack\",\"RULE_STACK\",\"RULE_OCCURRENCE_STACK\",\"gastProductionsCache\",\"has\",\"Error\",\"isArray\",\"isEmpty\",\"startOffset\",\"reduce\",\"acc\",\"tokType\",\"name\",\"every\",\"flatten\",\"values\",\"modes\",\"isTokenType\",\"allTokenTypes\",\"uniqueTokens\",\"uniq\",\"isObject\",\"cloneObj\",\"EOF\",\"noTokenCategoriesUsed\",\"tokenConstructor\",\"categoryMatches\",\"tokenStructuredMatcher\",\"augmentTokenTypes\",\"defineRule\",\"RecognizerEngine.prototype.defineRule\",\"ruleName\",\"impl\",\"selfAnalysisDone\",\"resyncEnabled\",\"DEFAULT_RULE_CONFIG\",\"recoveryValueFunc\",\"shortName\",\"BITS_FOR_METHOD_TYPE\",\"BITS_FOR_OCCURRENCE_IDX\",\"wrappedGrammarRule\",\"idxInCallingRule\",\"args\",\"ruleInvocationStateUpdate\",\"outputCst\",\"apply\",\"cst\",\"CST_STACK\",\"length\",\"cstPostRule\",\"e\",\"invokeRuleCatch\",\"ruleFinallyStateUpdate\",\"RecognizerEngine.prototype.invokeRuleCatch\",\"resyncEnabledConfig\",\"isFirstInvokedRule\",\"reSyncEnabled\",\"isBackTracking\",\"recoveryEnabled\",\"isRecognitionException\",\"reSyncTokType\",\"findReSyncTokenType\",\"isInCurrentRuleReSyncSet\",\"resyncedTokens\",\"reSyncTo\",\"partialCstResult\",\"recoveredNode\",\"moveToTerminatedState\",\"optionInternal\",\"RecognizerEngine.prototype.optionInternal\",\"actionORMethodDef\",\"occurrence\",\"key\",\"getKeyForAutomaticLookahead\",\"OPTION_IDX\",\"optionInternalLogic\",\"RecognizerEngine.prototype.optionInternalLogic\",\"_this\",\"lookAheadFunc\",\"getLaFuncFromCache\",\"undefined\",\"DEF\",\"action\",\"predicate\",\"GATE\",\"orgLookaheadFunction_1\",\"call\",\"atLeastOneInternal\",\"RecognizerEngine.prototype.atLeastOneInternal\",\"prodOccurrence\",\"laKey\",\"AT_LEAST_ONE_IDX\",\"atLeastOneInternalLogic\",\"RecognizerEngine.prototype.atLeastOneInternalLogic\",\"orgLookaheadFunction_2\",\"notStuck\",\"doSingleRepetition\",\"raiseEarlyExitException\",\"PROD_TYPE\",\"REPETITION_MANDATORY\",\"ERR_MSG\",\"attemptInRepetitionRecovery\",\"NextTerminalAfterAtLeastOneWalker\",\"atLeastOneSepFirstInternal\",\"RecognizerEngine.prototype.atLeastOneSepFirstInternal\",\"options\",\"AT_LEAST_ONE_SEP_IDX\",\"atLeastOneSepFirstInternalLogic\",\"RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic\",\"separator\",\"SEP\",\"firstIterationLookaheadFunc\",\"separatorLookAheadFunc\",\"LA\",\"CONSUME\",\"repetitionSepSecondInternal\",\"NextTerminalAfterAtLeastOneSepWalker\",\"REPETITION_MANDATORY_WITH_SEPARATOR\",\"manyInternal\",\"RecognizerEngine.prototype.manyInternal\",\"MANY_IDX\",\"manyInternalLogic\",\"RecognizerEngine.prototype.manyInternalLogic\",\"lookaheadFunction\",\"orgLookaheadFunction_3\",\"NextTerminalAfterManyWalker\",\"manySepFirstInternal\",\"RecognizerEngine.prototype.manySepFirstInternal\",\"MANY_SEP_IDX\",\"manySepFirstInternalLogic\",\"RecognizerEngine.prototype.manySepFirstInternalLogic\",\"firstIterationLaFunc\",\"NextTerminalAfterManySepWalker\",\"RecognizerEngine.prototype.repetitionSepSecondInternal\",\"nextTerminalAfterWalker\",\"RecognizerEngine.prototype.doSingleRepetition\",\"beforeIteration\",\"getLexerPosition\",\"afterIteration\",\"orInternal\",\"RecognizerEngine.prototype.orInternal\",\"altsOrOpts\",\"OR_IDX\",\"alts\",\"altIdxToTake\",\"laFunc\",\"chosenAlternative\",\"ALT\",\"raiseNoAltException\",\"RecognizerEngine.prototype.ruleFinallyStateUpdate\",\"pop\",\"cstFinallyStateUpdate\",\"isAtEndOfInput\",\"firstRedundantTok\",\"errMsg\",\"errorMessageProvider\",\"buildNotAllInputParsedMessage\",\"firstRedundant\",\"getCurrRuleFullName\",\"SAVE_ERROR\",\"NotAllInputParsedException\",\"subruleInternal\",\"RecognizerEngine.prototype.subruleInternal\",\"ruleToCall\",\"idx\",\"ruleResult\",\"ARGS\",\"cstPostNonTerminal\",\"LABEL\",\"subruleInternalError\",\"RecognizerEngine.prototype.subruleInternalError\",\"consumeInternal\",\"RecognizerEngine.prototype.consumeInternal\",\"nextToken\",\"consumeToken\",\"consumedToken\",\"consumeInternalError\",\"eFromConsumption\",\"consumeInternalRecovery\",\"cstPostTerminal\",\"RecognizerEngine.prototype.consumeInternalError\",\"previousToken\",\"msg\",\"buildMismatchTokenMessage\",\"expected\",\"actual\",\"previous\",\"MismatchedTokenException\",\"RecognizerEngine.prototype.consumeInternalRecovery\",\"follows\",\"getFollowsForInRuleRecovery\",\"tryInRuleRecovery\",\"eFromInRuleRecovery\",\"IN_RULE_RECOVERY_EXCEPTION\",\"saveRecogState\",\"RecognizerEngine.prototype.saveRecogState\",\"savedErrors\",\"errors\",\"savedRuleStack\",\"cloneArr\",\"lexerState\",\"exportLexerState\",\"reloadRecogState\",\"RecognizerEngine.prototype.reloadRecogState\",\"newState\",\"importLexerState\",\"RecognizerEngine.prototype.ruleInvocationStateUpdate\",\"fullName\",\"push\",\"cstInvocationStateUpdate\",\"RecognizerEngine.prototype.isBackTracking\",\"RecognizerEngine.prototype.getCurrRuleFullName\",\"getLastExplicitRuleShortName\",\"shortRuleNameToFullName\",\"RecognizerEngine.prototype.shortRuleNameToFullName\",\"RecognizerEngine.prototype.isAtEndOfInput\",\"reset\",\"RecognizerEngine.prototype.reset\",\"resetLexerState\"]\n}\n"]