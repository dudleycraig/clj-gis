["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/curves/NURBSSurface.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$curves$NURBSSurface=function(global,require,module,exports){function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);\nstaticProps&&_defineProperties(Constructor,staticProps);return Constructor}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.NURBSSurface=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_NURBSUtils=require(\"module$node_modules$three_stdlib$curves$NURBSUtils\");global=function(){function NURBSSurface(degree1,degree2,knots1,knots2,controlPoints){if(!(this instanceof NURBSSurface))throw new TypeError(\"Cannot call a class as a function\");this.degree1=degree1;this.degree2=\ndegree2;this.knots1=knots1;this.knots2=knots2;this.controlPoints=[];degree1=knots1.length-degree1-1;degree2=knots2.length-degree2-1;for(knots2=0;knots2<degree1;++knots2)for(this.controlPoints[knots2]=[],knots1=0;knots1<degree2;++knots1){var point=controlPoints[knots2][knots1];this.controlPoints[knots2][knots1]=new _three.Vector4(point.x,point.y,point.z,point.w)}}_createClass(NURBSSurface,[{key:\"getPoint\",value:function(t1,t2,target){t1=this.knots1[0]+t1*(this.knots1[this.knots1.length-1]-this.knots1[0]);\nt2=this.knots2[0]+t2*(this.knots2[this.knots2.length-1]-this.knots2[0]);(0,_NURBSUtils.calcSurfacePoint)(this.degree1,this.degree2,this.knots1,this.knots2,this.controlPoints,t1,t2,target)}}]);return NURBSSurface}();exports.NURBSSurface=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$curves$NURBSSurface\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NURBSSurface = void 0;\n\nvar _three = require(\"three\");\n\nvar _NURBSUtils = require(\"./NURBSUtils.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * NURBS surface object\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n **/\nvar NURBSSurface =\n/*#__PURE__*/\nfunction () {\n  function NURBSSurface(degree1, degree2, knots1, knots2\n  /* arrays of reals */\n  , controlPoints\n  /* array^2 of Vector(2|3|4) */\n  ) {\n    _classCallCheck(this, NURBSSurface);\n\n    this.degree1 = degree1;\n    this.degree2 = degree2;\n    this.knots1 = knots1;\n    this.knots2 = knots2;\n    this.controlPoints = [];\n    var len1 = knots1.length - degree1 - 1;\n    var len2 = knots2.length - degree2 - 1; // ensure Vector4 for control points\n\n    for (var i = 0; i < len1; ++i) {\n      this.controlPoints[i] = [];\n\n      for (var j = 0; j < len2; ++j) {\n        var point = controlPoints[i][j];\n        this.controlPoints[i][j] = new _three.Vector4(point.x, point.y, point.z, point.w);\n      }\n    }\n  }\n\n  _createClass(NURBSSurface, [{\n    key: \"getPoint\",\n    value: function getPoint(t1, t2, target) {\n      var u = this.knots1[0] + t1 * (this.knots1[this.knots1.length - 1] - this.knots1[0]); // linear mapping t1->u\n\n      var v = this.knots2[0] + t2 * (this.knots2[this.knots2.length - 1] - this.knots2[0]); // linear mapping t2->u\n\n      (0, _NURBSUtils.calcSurfacePoint)(this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target);\n    }\n  }]);\n\n  return NURBSSurface;\n}();\n\nexports.NURBSSurface = NURBSSurface;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_stdlib$curves$NURBSUtils","~$shadow.js"]],"~:properties",["^5",["key","__esModule","controlPoints","degree1","configurable","value","enumerable","knots1","writable","knots2","NURBSSurface","degree2"]],"~:compiled-at",1630917516062,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$curves$NURBSSurface.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/curves/NURBSSurface.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$curves$NURBSSurface\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.NURBSSurface = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _NURBSUtils = require(\\\"./NURBSUtils.js\\\");\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n/**\\n * NURBS surface object\\n *\\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\\n **/\\nvar NURBSSurface =\\n/*#__PURE__*/\\nfunction () {\\n  function NURBSSurface(degree1, degree2, knots1, knots2\\n  /* arrays of reals */\\n  , controlPoints\\n  /* array^2 of Vector(2|3|4) */\\n  ) {\\n    _classCallCheck(this, NURBSSurface);\\n\\n    this.degree1 = degree1;\\n    this.degree2 = degree2;\\n    this.knots1 = knots1;\\n    this.knots2 = knots2;\\n    this.controlPoints = [];\\n    var len1 = knots1.length - degree1 - 1;\\n    var len2 = knots2.length - degree2 - 1; // ensure Vector4 for control points\\n\\n    for (var i = 0; i < len1; ++i) {\\n      this.controlPoints[i] = [];\\n\\n      for (var j = 0; j < len2; ++j) {\\n        var point = controlPoints[i][j];\\n        this.controlPoints[i][j] = new _three.Vector4(point.x, point.y, point.z, point.w);\\n      }\\n    }\\n  }\\n\\n  _createClass(NURBSSurface, [{\\n    key: \\\"getPoint\\\",\\n    value: function getPoint(t1, t2, target) {\\n      var u = this.knots1[0] + t1 * (this.knots1[this.knots1.length - 1] - this.knots1[0]); // linear mapping t1->u\\n\\n      var v = this.knots2[0] + t2 * (this.knots2[this.knots2.length - 1] - this.knots2[0]); // linear mapping t2->u\\n\\n      (0, _NURBSUtils.calcSurfacePoint)(this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target);\\n    }\\n  }]);\\n\\n  return NURBSSurface;\\n}();\\n\\nexports.NURBSSurface = NURBSSurface;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"prototype\",\"value\",\"NURBSSurface\",\"_three\",\"_NURBSUtils\",\"degree1\",\"degree2\",\"knots1\",\"knots2\",\"controlPoints\",\"instance\",\"TypeError\",\"len1\",\"len2\",\"j\",\"point\",\"Vector4\",\"x\",\"y\",\"z\",\"w\",\"getPoint\",\"t1\",\"t2\",\"u\",\"v\",\"calcSurfacePoint\"]\n}\n"]