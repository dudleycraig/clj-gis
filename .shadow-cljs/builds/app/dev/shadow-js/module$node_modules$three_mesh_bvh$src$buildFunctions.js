["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-mesh-bvh/src/buildFunctions.js"],"~:js","shadow$provide.module$node_modules$three_mesh_bvh$src$buildFunctions=function(global,require,module,exports){function ensureIndex(geo){if(!geo.index){var vertexCount=geo.attributes.position.count,index=new (65535<vertexCount?Uint32Array:Uint16Array)(vertexCount);geo.setIndex(new _three.BufferAttribute(index,1));for(geo=0;geo<vertexCount;geo++)index[geo]=geo}}function getRootIndexRanges(geo){if(!geo.groups||!geo.groups.length)return[{offset:0,count:geo.index.count/3}];var ranges=[],rangeBoundaries=\nnew Set,_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=geo.groups[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var group=_step.value;rangeBoundaries.add(group.start);rangeBoundaries.add(group.start+group.count)}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{if(!_iteratorNormalCompletion&&null!=_iterator[\"return\"])_iterator[\"return\"]()}finally{if(_didIteratorError)throw _iteratorError;\n}}geo=Array.from(rangeBoundaries.values()).sort(function(a,b){return a-b});for(rangeBoundaries=0;rangeBoundaries<geo.length-1;rangeBoundaries++)_iteratorNormalCompletion=geo[rangeBoundaries],ranges.push({offset:_iteratorNormalCompletion/3,count:(geo[rangeBoundaries+1]-_iteratorNormalCompletion)/3});return ranges}function getBounds(triangleBounds,offset,count,target){for(var centroidTarget=4<arguments.length&&void 0!==arguments[4]?arguments[4]:null,minx=Infinity,miny=Infinity,minz=Infinity,maxx=-Infinity,\nmaxy=-Infinity,maxz=-Infinity,cminx=Infinity,cminy=Infinity,cminz=Infinity,cmaxx=-Infinity,cmaxy=-Infinity,cmaxz=-Infinity,includeCentroid=null!==centroidTarget,i=6*offset,end=6*(offset+count);i<end;i+=6){var cx=triangleBounds[i+0],hx=triangleBounds[i+1],lx=cx-hx;hx=cx+hx;lx<minx&&(minx=lx);hx>maxx&&(maxx=hx);includeCentroid&&cx<cminx&&(cminx=cx);includeCentroid&&cx>cmaxx&&(cmaxx=cx);cx=triangleBounds[i+2];hx=triangleBounds[i+3];lx=cx-hx;hx=cx+hx;lx<miny&&(miny=lx);hx>maxy&&(maxy=hx);includeCentroid&&\ncx<cminy&&(cminy=cx);includeCentroid&&cx>cmaxy&&(cmaxy=cx);cx=triangleBounds[i+4];hx=triangleBounds[i+5];lx=cx-hx;hx=cx+hx;lx<minz&&(minz=lx);hx>maxz&&(maxz=hx);includeCentroid&&cx<cminz&&(cminz=cx);includeCentroid&&cx>cmaxz&&(cmaxz=cx)}target[0]=minx;target[1]=miny;target[2]=minz;target[3]=maxx;target[4]=maxy;target[5]=maxz;includeCentroid&&(centroidTarget[0]=cminx,centroidTarget[1]=cminy,centroidTarget[2]=cminz,centroidTarget[3]=cmaxx,centroidTarget[4]=cmaxy,centroidTarget[5]=cmaxz)}function getCentroidBounds(triangleBounds,\noffset,count,centroidTarget){var cminx=Infinity,cminy=Infinity,cminz=Infinity,cmaxx=-Infinity,cmaxy=-Infinity,cmaxz=-Infinity,i=6*offset;for(offset=6*(offset+count);i<offset;i+=6)count=triangleBounds[i+0],count<cminx&&(cminx=count),count>cmaxx&&(cmaxx=count),count=triangleBounds[i+2],count<cminy&&(cminy=count),count>cmaxy&&(cmaxy=count),count=triangleBounds[i+4],count<cminz&&(cminz=count),count>cmaxz&&(cmaxz=count);centroidTarget[0]=cminx;centroidTarget[1]=cminy;centroidTarget[2]=cminz;centroidTarget[3]=\ncmaxx;centroidTarget[4]=cmaxy;centroidTarget[5]=cmaxz}function computeTriangleBounds(geo){var posAttr=geo.attributes.position,posArr=posAttr.array;geo=geo.index.array;var triCount=geo.length/3,triangleBounds=new Float32Array(6*triCount),bufferOffset=posAttr.offset||0,stride=3;posAttr.isInterleavedBufferAttribute&&(stride=posAttr.data.stride);for(posAttr=0;posAttr<triCount;posAttr++){var tri3=3*posAttr,tri6=6*posAttr,ai=geo[tri3+0]*stride+bufferOffset,bi=geo[tri3+1]*stride+bufferOffset;tri3=geo[tri3+\n2]*stride+bufferOffset;for(var el=0;3>el;el++){var a=posArr[ai+el],b=posArr[bi+el],c=posArr[tri3+el],min=a;b<min&&(min=b);c<min&&(min=c);b>a&&(a=b);c>a&&(a=c);b=(a-min)/2;c=2*el;triangleBounds[tri6+c+0]=min+b;triangleBounds[tri6+c+1]=b+(Math.abs(min)+b)*FLOAT32_EPSILON}}return triangleBounds}function buildTree(geo,options){function splitNode(node,offset,count){var centroidBoundingData=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null,depth=4<arguments.length&&void 0!==arguments[4]?arguments[4]:\n0;!reachedMaxDepth&&depth>=maxDepth&&(reachedMaxDepth=!0,verbose&&(console.warn(\"MeshBVH: Max depth of \".concat(maxDepth,\" reached when generating BVH. Consider increasing maxDepth.\")),console.warn(this,geo)));if(count<=maxLeafTris||depth>=maxDepth)return node.offset=offset,node.count=count,node;var nodeBoundingData=node.boundingData;var JSCompiler_object_inline_axis_6657=triangleBounds;var strategy=strategy$jscomp$0;var JSCompiler_object_inline_pos_6658=-1;var pos=0;if(strategy===_Constants.CENTER)JSCompiler_object_inline_pos_6658=\n(0,_ArrayBoxUtilities.getLongestEdgeIndex)(centroidBoundingData),-1!==JSCompiler_object_inline_pos_6658&&(pos=(centroidBoundingData[JSCompiler_object_inline_pos_6658]+centroidBoundingData[JSCompiler_object_inline_pos_6658+3])/2);else if(strategy===_Constants.AVERAGE){if(JSCompiler_object_inline_pos_6658=(0,_ArrayBoxUtilities.getLongestEdgeIndex)(nodeBoundingData),-1!==JSCompiler_object_inline_pos_6658){pos=0;centroidBoundingData=offset;for(nodeBoundingData=offset+count;centroidBoundingData<nodeBoundingData;centroidBoundingData++)pos+=\nJSCompiler_object_inline_axis_6657[6*centroidBoundingData+2*JSCompiler_object_inline_pos_6658];pos/=count}}else if(strategy===_Constants.SAH){nodeBoundingData=(0,_ArrayBoxUtilities.computeSurfaceArea)(nodeBoundingData);strategy=_Constants.TRIANGLE_INTERSECT_COST*count;for(var cStart=6*offset,cEnd=6*(offset+count),a=0;3>a;a++){for(var axisLeft=centroidBoundingData[a],binWidth=(centroidBoundingData[a+3]-axisLeft)/BIN_COUNT,i=0;i<BIN_COUNT;i++){var bin=sahBins[i];bin.count=0;bin.candidate=axisLeft+binWidth+\ni*binWidth;bin=bin.bounds;for(var d=0;3>d;d++)bin[d]=Infinity,bin[d+3]=-Infinity}for(i=cStart;i<cEnd;i+=6)for(bin=~~((JSCompiler_object_inline_axis_6657[i+2*a]-axisLeft)/binWidth),bin>=BIN_COUNT&&(bin=BIN_COUNT-1),bin=sahBins[bin],bin.count++,bin=bin.bounds,d=0;3>d;d++){var tCenter=JSCompiler_object_inline_axis_6657[i+2*d],tHalf=JSCompiler_object_inline_axis_6657[i+2*d+1],tMin=tCenter-tHalf;tCenter+=tHalf;tMin<bin[d]&&(bin[d]=tMin);tCenter>bin[d+3]&&(bin[d+3]=tCenter)}axisLeft=sahBins[BIN_COUNT-1];\n(0,_ArrayBoxUtilities.copyBounds)(axisLeft.bounds,axisLeft.rightCacheBounds);for(axisLeft=BIN_COUNT-2;0<=axisLeft;axisLeft--)binWidth=sahBins[axisLeft],i=sahBins[axisLeft+1],(0,_ArrayBoxUtilities.unionBounds)(binWidth.bounds,i.rightCacheBounds,binWidth.rightCacheBounds);for(binWidth=axisLeft=0;binWidth<BIN_COUNT-1;binWidth++)i=sahBins[binWidth],d=i.count,tMin=i.bounds,bin=sahBins[binWidth+1].rightCacheBounds,0!==d&&(0===axisLeft?(0,_ArrayBoxUtilities.copyBounds)(tMin,leftBounds):(0,_ArrayBoxUtilities.unionBounds)(tMin,\nleftBounds,leftBounds)),axisLeft+=d,tMin=d=0,0!==axisLeft&&(d=(0,_ArrayBoxUtilities.computeSurfaceArea)(leftBounds)/nodeBoundingData),tCenter=count-axisLeft,0!==tCenter&&(tMin=(0,_ArrayBoxUtilities.computeSurfaceArea)(bin)/nodeBoundingData),bin=_Constants.TRAVERSAL_COST+_Constants.TRIANGLE_INTERSECT_COST*(d*axisLeft+tMin*tCenter),bin<strategy&&(JSCompiler_object_inline_pos_6658=a,strategy=bin,pos=i.candidate)}}JSCompiler_object_inline_axis_6657=JSCompiler_object_inline_pos_6658;JSCompiler_object_inline_pos_6658=\npos;if(-1===JSCompiler_object_inline_axis_6657)return node.offset=offset,node.count=count,node;a:for(pos=indexArray,centroidBoundingData=triangleBounds,nodeBoundingData=offset,strategy=offset+count-1,cStart=2*JSCompiler_object_inline_axis_6657;;){for(;nodeBoundingData<=strategy&&centroidBoundingData[6*nodeBoundingData+cStart]<JSCompiler_object_inline_pos_6658;)nodeBoundingData++;for(;nodeBoundingData<=strategy&&centroidBoundingData[6*strategy+cStart]>=JSCompiler_object_inline_pos_6658;)strategy--;\nif(nodeBoundingData<strategy){for(cEnd=0;3>cEnd;cEnd++)a=pos[3*nodeBoundingData+cEnd],pos[3*nodeBoundingData+cEnd]=pos[3*strategy+cEnd],pos[3*strategy+cEnd]=a,a=centroidBoundingData[6*nodeBoundingData+2*cEnd],centroidBoundingData[6*nodeBoundingData+2*cEnd]=centroidBoundingData[6*strategy+2*cEnd],centroidBoundingData[6*strategy+2*cEnd]=a,a=centroidBoundingData[6*nodeBoundingData+2*cEnd+1],centroidBoundingData[6*nodeBoundingData+2*cEnd+1]=centroidBoundingData[6*strategy+2*cEnd+1],centroidBoundingData[6*\nstrategy+2*cEnd+1]=a;nodeBoundingData++;strategy--}else{JSCompiler_object_inline_pos_6658=nodeBoundingData;break a}}JSCompiler_object_inline_pos_6658===offset||JSCompiler_object_inline_pos_6658===offset+count?(node.offset=offset,node.count=count):(node.splitAxis=JSCompiler_object_inline_axis_6657,pos=new _MeshBVHNode[\"default\"],JSCompiler_object_inline_axis_6657=JSCompiler_object_inline_pos_6658-offset,node.left=pos,pos.boundingData=new Float32Array(6),getBounds(triangleBounds,offset,JSCompiler_object_inline_axis_6657,\npos.boundingData,cacheCentroidBoundingData),splitNode(pos,offset,JSCompiler_object_inline_axis_6657,cacheCentroidBoundingData,depth+1),pos=new _MeshBVHNode[\"default\"],JSCompiler_object_inline_axis_6657=count-JSCompiler_object_inline_axis_6657,node.right=pos,pos.boundingData=new Float32Array(6),getBounds(triangleBounds,JSCompiler_object_inline_pos_6658,JSCompiler_object_inline_axis_6657,pos.boundingData,cacheCentroidBoundingData),splitNode(pos,JSCompiler_object_inline_pos_6658,JSCompiler_object_inline_axis_6657,\ncacheCentroidBoundingData,depth+1));return node}ensureIndex(geo);var cacheCentroidBoundingData=new Float32Array(6),triangleBounds=computeTriangleBounds(geo),indexArray=geo.index.array,maxDepth=options.maxDepth,verbose=options.verbose,maxLeafTris=options.maxLeafTris,strategy$jscomp$0=options.strategy,reachedMaxDepth=!1;options=[];var ranges=getRootIndexRanges(geo);if(1===ranges.length){var root=new _MeshBVHNode[\"default\"];ranges=ranges[0];null!=geo.boundingBox?(root.boundingData=(0,_ArrayBoxUtilities.boxToArray)(geo.boundingBox),\ngetCentroidBounds(triangleBounds,ranges.offset,ranges.count,cacheCentroidBoundingData)):(root.boundingData=new Float32Array(6),getBounds(triangleBounds,ranges.offset,ranges.count,root.boundingData,cacheCentroidBoundingData));splitNode(root,ranges.offset,ranges.count,cacheCentroidBoundingData);options.push(root)}else{var _iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{root=ranges[Symbol.iterator]();for(var _step2;!(_iteratorNormalCompletion2=(_step2=root.next()).done);_iteratorNormalCompletion2=\n!0){var _range=_step2.value,_root=new _MeshBVHNode[\"default\"];_root.boundingData=new Float32Array(6);getBounds(triangleBounds,_range.offset,_range.count,_root.boundingData,cacheCentroidBoundingData);splitNode(_root,_range.offset,_range.count,cacheCentroidBoundingData);options.push(_root)}}catch(err){_didIteratorError2=!0,_iteratorError2=err}finally{try{if(!_iteratorNormalCompletion2&&null!=root[\"return\"])root[\"return\"]()}finally{if(_didIteratorError2)throw _iteratorError2;}}}return options}Object.defineProperty(exports,\n\"__esModule\",{value:!0});exports.buildTree=buildTree;exports.buildPackedTree=function(geo,options){function countNodes(node){return node.count?1:1+countNodes(node.left)+countNodes(node.right)}function populateBuffer(byteOffset,node){for(var stride4Offset=byteOffset/4,stride2Offset=byteOffset/2,isLeaf=!!node.count,boundingData=node.boundingData,_i3=0;6>_i3;_i3++)float32Array[stride4Offset+_i3]=boundingData[_i3];if(isLeaf)return isLeaf=node.count,uint32Array[stride4Offset+6]=node.offset,uint16Array[stride2Offset+\n14]=isLeaf,uint16Array[stride2Offset+15]=IS_LEAFNODE_FLAG,byteOffset+BYTES_PER_NODE;stride2Offset=node.right;isLeaf=node.splitAxis;byteOffset=populateBuffer(byteOffset+BYTES_PER_NODE,node.left);if(byteOffset/4>Math.pow(2,32))throw Error(\"MeshBVH: Cannot store child pointer greater than 32 bits.\");uint32Array[stride4Offset+6]=byteOffset/4;byteOffset=populateBuffer(byteOffset,stride2Offset);uint32Array[stride4Offset+7]=isLeaf;return byteOffset}geo=buildTree(geo,options);options=[];for(var i=0;i<geo.length;i++){var root=\ngeo[i],nodeCount=countNodes(root);nodeCount=new ArrayBuffer(BYTES_PER_NODE*nodeCount);var float32Array=new Float32Array(nodeCount);var uint32Array=new Uint32Array(nodeCount);var uint16Array=new Uint16Array(nodeCount);populateBuffer(0,root);options.push(nodeCount)}return options};exports.IS_LEAFNODE_FLAG=exports.BYTES_PER_NODE=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_MeshBVHNode=function(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}(require(\"module$node_modules$three_mesh_bvh$src$MeshBVHNode\")),\n_ArrayBoxUtilities=require(\"module$node_modules$three_mesh_bvh$src$Utils$ArrayBoxUtilities\"),_Constants=require(\"module$node_modules$three_mesh_bvh$src$Constants\"),FLOAT32_EPSILON=Math.pow(2,-24),BIN_COUNT=32,sahBins=Array(BIN_COUNT).fill().map(function(){return{count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),candidate:0}}),leftBounds=new Float32Array(6),BYTES_PER_NODE=32;exports.BYTES_PER_NODE=BYTES_PER_NODE;var IS_LEAFNODE_FLAG=65535;exports.IS_LEAFNODE_FLAG=IS_LEAFNODE_FLAG}","~:source","shadow$provide[\"module$node_modules$three_mesh_bvh$src$buildFunctions\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildTree = buildTree;\nexports.buildPackedTree = buildPackedTree;\nexports.IS_LEAFNODE_FLAG = exports.BYTES_PER_NODE = void 0;\n\nvar _three = require(\"three\");\n\nvar _MeshBVHNode = _interopRequireDefault(require(\"./MeshBVHNode.js\"));\n\nvar _ArrayBoxUtilities = require(\"./Utils/ArrayBoxUtilities.js\");\n\nvar _Constants = require(\"./Constants.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nvar FLOAT32_EPSILON = Math.pow(2, -24);\n\nfunction ensureIndex(geo) {\n  if (!geo.index) {\n    var vertexCount = geo.attributes.position.count;\n    var index = new (vertexCount > 65535 ? Uint32Array : Uint16Array)(vertexCount);\n    geo.setIndex(new _three.BufferAttribute(index, 1));\n\n    for (var i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n} // Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\n\n\nfunction getRootIndexRanges(geo) {\n  if (!geo.groups || !geo.groups.length) {\n    return [{\n      offset: 0,\n      count: geo.index.count / 3\n    }];\n  }\n\n  var ranges = [];\n  var rangeBoundaries = new Set();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = geo.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var group = _step.value;\n      rangeBoundaries.add(group.start);\n      rangeBoundaries.add(group.start + group.count);\n    } // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var sortedBoundaries = Array.from(rangeBoundaries.values()).sort(function (a, b) {\n    return a - b;\n  });\n\n  for (var i = 0; i < sortedBoundaries.length - 1; i++) {\n    var start = sortedBoundaries[i],\n        end = sortedBoundaries[i + 1];\n    ranges.push({\n      offset: start / 3,\n      count: (end - start) / 3\n    });\n  }\n\n  return ranges;\n} // computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\n\n\nfunction getBounds(triangleBounds, offset, count, target) {\n  var centroidTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var minx = Infinity;\n  var miny = Infinity;\n  var minz = Infinity;\n  var maxx = -Infinity;\n  var maxy = -Infinity;\n  var maxz = -Infinity;\n  var cminx = Infinity;\n  var cminy = Infinity;\n  var cminz = Infinity;\n  var cmaxx = -Infinity;\n  var cmaxy = -Infinity;\n  var cmaxz = -Infinity;\n  var includeCentroid = centroidTarget !== null;\n\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    var cx = triangleBounds[i + 0];\n    var hx = triangleBounds[i + 1];\n    var lx = cx - hx;\n    var rx = cx + hx;\n    if (lx < minx) minx = lx;\n    if (rx > maxx) maxx = rx;\n    if (includeCentroid && cx < cminx) cminx = cx;\n    if (includeCentroid && cx > cmaxx) cmaxx = cx;\n    var cy = triangleBounds[i + 2];\n    var hy = triangleBounds[i + 3];\n    var ly = cy - hy;\n    var ry = cy + hy;\n    if (ly < miny) miny = ly;\n    if (ry > maxy) maxy = ry;\n    if (includeCentroid && cy < cminy) cminy = cy;\n    if (includeCentroid && cy > cmaxy) cmaxy = cy;\n    var cz = triangleBounds[i + 4];\n    var hz = triangleBounds[i + 5];\n    var lz = cz - hz;\n    var rz = cz + hz;\n    if (lz < minz) minz = lz;\n    if (rz > maxz) maxz = rz;\n    if (includeCentroid && cz < cminz) cminz = cz;\n    if (includeCentroid && cz > cmaxz) cmaxz = cz;\n  }\n\n  target[0] = minx;\n  target[1] = miny;\n  target[2] = minz;\n  target[3] = maxx;\n  target[4] = maxy;\n  target[5] = maxz;\n\n  if (includeCentroid) {\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n  }\n} // A stand alone function for retrieving the centroid bounds.\n\n\nfunction getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n  var cminx = Infinity;\n  var cminy = Infinity;\n  var cminz = Infinity;\n  var cmaxx = -Infinity;\n  var cmaxy = -Infinity;\n  var cmaxz = -Infinity;\n\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    var cx = triangleBounds[i + 0];\n    if (cx < cminx) cminx = cx;\n    if (cx > cmaxx) cmaxx = cx;\n    var cy = triangleBounds[i + 2];\n    if (cy < cminy) cminy = cy;\n    if (cy > cmaxy) cmaxy = cy;\n    var cz = triangleBounds[i + 4];\n    if (cz < cminz) cminz = cz;\n    if (cz > cmaxz) cmaxz = cz;\n  }\n\n  centroidTarget[0] = cminx;\n  centroidTarget[1] = cminy;\n  centroidTarget[2] = cminz;\n  centroidTarget[3] = cmaxx;\n  centroidTarget[4] = cmaxy;\n  centroidTarget[5] = cmaxz;\n} // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\n\n\nfunction partition(index, triangleBounds, offset, count, split) {\n  var left = offset;\n  var right = offset + count - 1;\n  var pos = split.pos;\n  var axisOffset = split.axis * 2; // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\n  while (true) {\n    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {\n      left++;\n    } // if a triangle center lies on the partition plane it is considered to be on the right side\n\n\n    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {\n      right--;\n    }\n\n    if (left < right) {\n      // we need to swap all of the information associated with the triangles at index\n      // left and right; that's the verts in the geometry index, the bounds,\n      // and perhaps the SAH planes\n      for (var i = 0; i < 3; i++) {\n        var t0 = index[left * 3 + i];\n        index[left * 3 + i] = index[right * 3 + i];\n        index[right * 3 + i] = t0;\n        var t1 = triangleBounds[left * 6 + i * 2 + 0];\n        triangleBounds[left * 6 + i * 2 + 0] = triangleBounds[right * 6 + i * 2 + 0];\n        triangleBounds[right * 6 + i * 2 + 0] = t1;\n        var t2 = triangleBounds[left * 6 + i * 2 + 1];\n        triangleBounds[left * 6 + i * 2 + 1] = triangleBounds[right * 6 + i * 2 + 1];\n        triangleBounds[right * 6 + i * 2 + 1] = t2;\n      }\n\n      left++;\n      right--;\n    } else {\n      return left;\n    }\n  }\n}\n\nvar BIN_COUNT = 32;\nvar sahBins = new Array(BIN_COUNT).fill().map(function () {\n  return {\n    count: 0,\n    bounds: new Float32Array(6),\n    rightCacheBounds: new Float32Array(6),\n    candidate: 0\n  };\n});\nvar leftBounds = new Float32Array(6);\n\nfunction getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n  var axis = -1;\n  var pos = 0; // Center\n\n  if (strategy === _Constants.CENTER) {\n    axis = (0, _ArrayBoxUtilities.getLongestEdgeIndex)(centroidBoundingData);\n\n    if (axis !== -1) {\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n    }\n  } else if (strategy === _Constants.AVERAGE) {\n    axis = (0, _ArrayBoxUtilities.getLongestEdgeIndex)(nodeBoundingData);\n\n    if (axis !== -1) {\n      pos = getAverage(triangleBounds, offset, count, axis);\n    }\n  } else if (strategy === _Constants.SAH) {\n    var rootSurfaceArea = (0, _ArrayBoxUtilities.computeSurfaceArea)(nodeBoundingData);\n    var bestCost = _Constants.TRIANGLE_INTERSECT_COST * count; // iterate over all axes\n\n    var cStart = offset * 6;\n    var cEnd = (offset + count) * 6;\n\n    for (var a = 0; a < 3; a++) {\n      var axisLeft = centroidBoundingData[a];\n      var axisRight = centroidBoundingData[a + 3];\n      var axisLength = axisRight - axisLeft;\n      var binWidth = axisLength / BIN_COUNT; // reset the bins\n\n      for (var i = 0; i < BIN_COUNT; i++) {\n        var bin = sahBins[i];\n        bin.count = 0;\n        bin.candidate = axisLeft + binWidth + i * binWidth;\n        var bounds = bin.bounds;\n\n        for (var d = 0; d < 3; d++) {\n          bounds[d] = Infinity;\n          bounds[d + 3] = -Infinity;\n        }\n      } // iterate over all center positions\n\n\n      for (var c = cStart; c < cEnd; c += 6) {\n        var triCenter = triangleBounds[c + 2 * a];\n        var relativeCenter = triCenter - axisLeft; // in the partition function if the centroid lies on the split plane then it is\n        // considered to be on the right side of the split\n\n        var binIndex = ~~(relativeCenter / binWidth);\n        if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\n        var _bin = sahBins[binIndex];\n        _bin.count++;\n        var _bounds = _bin.bounds;\n\n        for (var _d = 0; _d < 3; _d++) {\n          var tCenter = triangleBounds[c + 2 * _d];\n          var tHalf = triangleBounds[c + 2 * _d + 1];\n          var tMin = tCenter - tHalf;\n          var tMax = tCenter + tHalf;\n\n          if (tMin < _bounds[_d]) {\n            _bounds[_d] = tMin;\n          }\n\n          if (tMax > _bounds[_d + 3]) {\n            _bounds[_d + 3] = tMax;\n          }\n        }\n      } // cache the unioned bounds from right to left so we don't have to regenerate them each time\n\n\n      var lastBin = sahBins[BIN_COUNT - 1];\n      (0, _ArrayBoxUtilities.copyBounds)(lastBin.bounds, lastBin.rightCacheBounds);\n\n      for (var _i = BIN_COUNT - 2; _i >= 0; _i--) {\n        var _bin2 = sahBins[_i];\n        var nextBin = sahBins[_i + 1];\n        (0, _ArrayBoxUtilities.unionBounds)(_bin2.bounds, nextBin.rightCacheBounds, _bin2.rightCacheBounds);\n      }\n\n      var leftCount = 0;\n\n      for (var _i2 = 0; _i2 < BIN_COUNT - 1; _i2++) {\n        var _bin3 = sahBins[_i2];\n        var binCount = _bin3.count;\n        var _bounds2 = _bin3.bounds;\n        var _nextBin = sahBins[_i2 + 1];\n        var rightBounds = _nextBin.rightCacheBounds; // dont do anything with the bounds if the new bounds have no triangles\n\n        if (binCount !== 0) {\n          if (leftCount === 0) {\n            (0, _ArrayBoxUtilities.copyBounds)(_bounds2, leftBounds);\n          } else {\n            (0, _ArrayBoxUtilities.unionBounds)(_bounds2, leftBounds, leftBounds);\n          }\n        }\n\n        leftCount += binCount; // check the cost of this split\n\n        var leftProb = 0;\n        var rightProb = 0;\n\n        if (leftCount !== 0) {\n          leftProb = (0, _ArrayBoxUtilities.computeSurfaceArea)(leftBounds) / rootSurfaceArea;\n        }\n\n        var rightCount = count - leftCount;\n\n        if (rightCount !== 0) {\n          rightProb = (0, _ArrayBoxUtilities.computeSurfaceArea)(rightBounds) / rootSurfaceArea;\n        }\n\n        var cost = _Constants.TRAVERSAL_COST + _Constants.TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n\n        if (cost < bestCost) {\n          axis = a;\n          bestCost = cost;\n          pos = _bin3.candidate;\n        }\n      }\n    }\n  }\n\n  return {\n    axis: axis,\n    pos: pos\n  };\n} // returns the average coordinate on the specified axis of the all the provided triangles\n\n\nfunction getAverage(triangleBounds, offset, count, axis) {\n  var avg = 0;\n\n  for (var i = offset, end = offset + count; i < end; i++) {\n    avg += triangleBounds[i * 6 + axis * 2];\n  }\n\n  return avg / count;\n} // precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\n\n\nfunction computeTriangleBounds(geo) {\n  var posAttr = geo.attributes.position;\n  var posArr = posAttr.array;\n  var index = geo.index.array;\n  var triCount = index.length / 3;\n  var triangleBounds = new Float32Array(triCount * 6); // support for an interleaved position buffer\n\n  var bufferOffset = posAttr.offset || 0;\n  var stride = 3;\n\n  if (posAttr.isInterleavedBufferAttribute) {\n    stride = posAttr.data.stride;\n  }\n\n  for (var tri = 0; tri < triCount; tri++) {\n    var tri3 = tri * 3;\n    var tri6 = tri * 6;\n    var ai = index[tri3 + 0] * stride + bufferOffset;\n    var bi = index[tri3 + 1] * stride + bufferOffset;\n    var ci = index[tri3 + 2] * stride + bufferOffset;\n\n    for (var el = 0; el < 3; el++) {\n      var a = posArr[ai + el];\n      var b = posArr[bi + el];\n      var c = posArr[ci + el];\n      var min = a;\n      if (b < min) min = b;\n      if (c < min) min = c;\n      var max = a;\n      if (b > max) max = b;\n      if (c > max) max = c; // Increase the bounds size by float32 epsilon to avoid precision errors when\n      // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n      // worked with.\n\n      var halfExtents = (max - min) / 2;\n      var el2 = el * 2;\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\n    }\n  }\n\n  return triangleBounds;\n}\n\nfunction buildTree(geo, options) {\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count) {\n    var centroidBoundingData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n\n      if (verbose) {\n        console.warn(\"MeshBVH: Max depth of \".concat(maxDepth, \" reached when generating BVH. Consider increasing maxDepth.\"));\n        console.warn(this, geo);\n      }\n    } // early out if we've met our capacity\n\n\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      node.offset = offset;\n      node.count = count;\n      return node;\n    } // Find where to split the volume\n\n\n    var split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n\n    if (split.axis === -1) {\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    var splitOffset = partition(indexArray, triangleBounds, offset, count, split); // create the two new child nodes\n\n    if (splitOffset === offset || splitOffset === offset + count) {\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis; // create the left child and compute its bounding box\n\n      var left = new _MeshBVHNode[\"default\"]();\n      var lstart = offset;\n      var lcount = splitOffset - offset;\n      node.left = left;\n      left.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1); // repeat for right\n\n      var right = new _MeshBVHNode[\"default\"]();\n      var rstart = splitOffset;\n      var rcount = count - lcount;\n      node.right = right;\n      right.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n\n    return node;\n  }\n\n  ensureIndex(geo);\n  var cacheCentroidBoundingData = new Float32Array(6);\n  var triangleBounds = computeTriangleBounds(geo);\n  var indexArray = geo.index.array;\n  var maxDepth = options.maxDepth;\n  var verbose = options.verbose;\n  var maxLeafTris = options.maxLeafTris;\n  var strategy = options.strategy;\n  var reachedMaxDepth = false;\n  var roots = [];\n  var ranges = getRootIndexRanges(geo);\n\n  if (ranges.length === 1) {\n    var root = new _MeshBVHNode[\"default\"]();\n    var range = ranges[0];\n\n    if (geo.boundingBox != null) {\n      root.boundingData = (0, _ArrayBoxUtilities.boxToArray)(geo.boundingBox);\n      getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n    } else {\n      root.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\n    }\n\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n    roots.push(root);\n  } else {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _range = _step2.value;\n\n        var _root = new _MeshBVHNode[\"default\"]();\n\n        _root.boundingData = new Float32Array(6);\n        getBounds(triangleBounds, _range.offset, _range.count, _root.boundingData, cacheCentroidBoundingData);\n        splitNode(_root, _range.offset, _range.count, cacheCentroidBoundingData);\n        roots.push(_root);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  return roots;\n}\n\nvar BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexports.BYTES_PER_NODE = BYTES_PER_NODE;\nvar IS_LEAFNODE_FLAG = 0xFFFF;\nexports.IS_LEAFNODE_FLAG = IS_LEAFNODE_FLAG;\n\nfunction buildPackedTree(geo, options) {\n  // boundingData  \t\t\t\t: 6 float32\n  // right / offset \t\t\t\t: 1 uint32\n  // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n  var roots = buildTree(geo, options);\n  var float32Array;\n  var uint32Array;\n  var uint16Array;\n  var packedRoots = [];\n\n  for (var i = 0; i < roots.length; i++) {\n    var root = roots[i];\n    var nodeCount = countNodes(root);\n    var buffer = new ArrayBuffer(BYTES_PER_NODE * nodeCount);\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    populateBuffer(0, root);\n    packedRoots.push(buffer);\n  }\n\n  return packedRoots;\n\n  function countNodes(node) {\n    if (node.count) {\n      return 1;\n    } else {\n      return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n  }\n\n  function populateBuffer(byteOffset, node) {\n    var stride4Offset = byteOffset / 4;\n    var stride2Offset = byteOffset / 2;\n    var isLeaf = !!node.count;\n    var boundingData = node.boundingData;\n\n    for (var _i3 = 0; _i3 < 6; _i3++) {\n      float32Array[stride4Offset + _i3] = boundingData[_i3];\n    }\n\n    if (isLeaf) {\n      var offset = node.offset;\n      var count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    } else {\n      var left = node.left;\n      var right = node.right;\n      var splitAxis = node.splitAxis;\n      var nextUnusedPointer;\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\n\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n        throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\n      }\n\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n      uint32Array[stride4Offset + 7] = splitAxis;\n      return nextUnusedPointer;\n    }\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_mesh_bvh$src$Utils$ArrayBoxUtilities","~$shadow.js","~$module$node_modules$three_mesh_bvh$src$MeshBVHNode","~$module$node_modules$three_mesh_bvh$src$Constants"]],"~:properties",["^5",["BYTES_PER_NODE","splitAxis","right","offset","boundingData","IS_LEAFNODE_FLAG","buildTree","__esModule","count","value","buildPackedTree","rightCacheBounds","bounds","candidate","left"]],"~:compiled-at",1630917516170,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_mesh_bvh$src$buildFunctions.js\",\n\"lineCount\":25,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-mesh-bvh/src/buildFunctions.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_mesh_bvh$src$buildFunctions\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.buildTree = buildTree;\\nexports.buildPackedTree = buildPackedTree;\\nexports.IS_LEAFNODE_FLAG = exports.BYTES_PER_NODE = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _MeshBVHNode = _interopRequireDefault(require(\\\"./MeshBVHNode.js\\\"));\\n\\nvar _ArrayBoxUtilities = require(\\\"./Utils/ArrayBoxUtilities.js\\\");\\n\\nvar _Constants = require(\\\"./Constants.js\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \\\"default\\\": obj }; }\\n\\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\\nvar FLOAT32_EPSILON = Math.pow(2, -24);\\n\\nfunction ensureIndex(geo) {\\n  if (!geo.index) {\\n    var vertexCount = geo.attributes.position.count;\\n    var index = new (vertexCount > 65535 ? Uint32Array : Uint16Array)(vertexCount);\\n    geo.setIndex(new _three.BufferAttribute(index, 1));\\n\\n    for (var i = 0; i < vertexCount; i++) {\\n      index[i] = i;\\n    }\\n  }\\n} // Computes the set of { offset, count } ranges which need independent BVH roots. Each\\n// region in the geometry index that belongs to a different set of material groups requires\\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\\n// with triangle indices belongs to another group. For example, if the groups were like this:\\n//\\n// [-------------------------------------------------------------]\\n// |__________________|\\n//   g0 = [0, 20]  |______________________||_____________________|\\n//                      g1 = [16, 40]           g2 = [41, 60]\\n//\\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\\n\\n\\nfunction getRootIndexRanges(geo) {\\n  if (!geo.groups || !geo.groups.length) {\\n    return [{\\n      offset: 0,\\n      count: geo.index.count / 3\\n    }];\\n  }\\n\\n  var ranges = [];\\n  var rangeBoundaries = new Set();\\n  var _iteratorNormalCompletion = true;\\n  var _didIteratorError = false;\\n  var _iteratorError = undefined;\\n\\n  try {\\n    for (var _iterator = geo.groups[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n      var group = _step.value;\\n      rangeBoundaries.add(group.start);\\n      rangeBoundaries.add(group.start + group.count);\\n    } // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\\n\\n  } catch (err) {\\n    _didIteratorError = true;\\n    _iteratorError = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion && _iterator[\\\"return\\\"] != null) {\\n        _iterator[\\\"return\\\"]();\\n      }\\n    } finally {\\n      if (_didIteratorError) {\\n        throw _iteratorError;\\n      }\\n    }\\n  }\\n\\n  var sortedBoundaries = Array.from(rangeBoundaries.values()).sort(function (a, b) {\\n    return a - b;\\n  });\\n\\n  for (var i = 0; i < sortedBoundaries.length - 1; i++) {\\n    var start = sortedBoundaries[i],\\n        end = sortedBoundaries[i + 1];\\n    ranges.push({\\n      offset: start / 3,\\n      count: (end - start) / 3\\n    });\\n  }\\n\\n  return ranges;\\n} // computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\\n// These are computed together to avoid redundant accesses to bounds array.\\n\\n\\nfunction getBounds(triangleBounds, offset, count, target) {\\n  var centroidTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\\n  var minx = Infinity;\\n  var miny = Infinity;\\n  var minz = Infinity;\\n  var maxx = -Infinity;\\n  var maxy = -Infinity;\\n  var maxz = -Infinity;\\n  var cminx = Infinity;\\n  var cminy = Infinity;\\n  var cminz = Infinity;\\n  var cmaxx = -Infinity;\\n  var cmaxy = -Infinity;\\n  var cmaxz = -Infinity;\\n  var includeCentroid = centroidTarget !== null;\\n\\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\\n    var cx = triangleBounds[i + 0];\\n    var hx = triangleBounds[i + 1];\\n    var lx = cx - hx;\\n    var rx = cx + hx;\\n    if (lx < minx) minx = lx;\\n    if (rx > maxx) maxx = rx;\\n    if (includeCentroid && cx < cminx) cminx = cx;\\n    if (includeCentroid && cx > cmaxx) cmaxx = cx;\\n    var cy = triangleBounds[i + 2];\\n    var hy = triangleBounds[i + 3];\\n    var ly = cy - hy;\\n    var ry = cy + hy;\\n    if (ly < miny) miny = ly;\\n    if (ry > maxy) maxy = ry;\\n    if (includeCentroid && cy < cminy) cminy = cy;\\n    if (includeCentroid && cy > cmaxy) cmaxy = cy;\\n    var cz = triangleBounds[i + 4];\\n    var hz = triangleBounds[i + 5];\\n    var lz = cz - hz;\\n    var rz = cz + hz;\\n    if (lz < minz) minz = lz;\\n    if (rz > maxz) maxz = rz;\\n    if (includeCentroid && cz < cminz) cminz = cz;\\n    if (includeCentroid && cz > cmaxz) cmaxz = cz;\\n  }\\n\\n  target[0] = minx;\\n  target[1] = miny;\\n  target[2] = minz;\\n  target[3] = maxx;\\n  target[4] = maxy;\\n  target[5] = maxz;\\n\\n  if (includeCentroid) {\\n    centroidTarget[0] = cminx;\\n    centroidTarget[1] = cminy;\\n    centroidTarget[2] = cminz;\\n    centroidTarget[3] = cmaxx;\\n    centroidTarget[4] = cmaxy;\\n    centroidTarget[5] = cmaxz;\\n  }\\n} // A stand alone function for retrieving the centroid bounds.\\n\\n\\nfunction getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\\n  var cminx = Infinity;\\n  var cminy = Infinity;\\n  var cminz = Infinity;\\n  var cmaxx = -Infinity;\\n  var cmaxy = -Infinity;\\n  var cmaxz = -Infinity;\\n\\n  for (var i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\\n    var cx = triangleBounds[i + 0];\\n    if (cx < cminx) cminx = cx;\\n    if (cx > cmaxx) cmaxx = cx;\\n    var cy = triangleBounds[i + 2];\\n    if (cy < cminy) cminy = cy;\\n    if (cy > cmaxy) cmaxy = cy;\\n    var cz = triangleBounds[i + 4];\\n    if (cz < cminz) cminz = cz;\\n    if (cz > cmaxz) cmaxz = cz;\\n  }\\n\\n  centroidTarget[0] = cminx;\\n  centroidTarget[1] = cminy;\\n  centroidTarget[2] = cminz;\\n  centroidTarget[3] = cmaxx;\\n  centroidTarget[4] = cmaxy;\\n  centroidTarget[5] = cmaxz;\\n} // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\\n// will be on the left and elements on the right side of the split will be on the right. returns the index\\n// of the first element on the right side, or offset + count if there are no elements on the right side.\\n\\n\\nfunction partition(index, triangleBounds, offset, count, split) {\\n  var left = offset;\\n  var right = offset + count - 1;\\n  var pos = split.pos;\\n  var axisOffset = split.axis * 2; // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\\n\\n  while (true) {\\n    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {\\n      left++;\\n    } // if a triangle center lies on the partition plane it is considered to be on the right side\\n\\n\\n    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {\\n      right--;\\n    }\\n\\n    if (left < right) {\\n      // we need to swap all of the information associated with the triangles at index\\n      // left and right; that's the verts in the geometry index, the bounds,\\n      // and perhaps the SAH planes\\n      for (var i = 0; i < 3; i++) {\\n        var t0 = index[left * 3 + i];\\n        index[left * 3 + i] = index[right * 3 + i];\\n        index[right * 3 + i] = t0;\\n        var t1 = triangleBounds[left * 6 + i * 2 + 0];\\n        triangleBounds[left * 6 + i * 2 + 0] = triangleBounds[right * 6 + i * 2 + 0];\\n        triangleBounds[right * 6 + i * 2 + 0] = t1;\\n        var t2 = triangleBounds[left * 6 + i * 2 + 1];\\n        triangleBounds[left * 6 + i * 2 + 1] = triangleBounds[right * 6 + i * 2 + 1];\\n        triangleBounds[right * 6 + i * 2 + 1] = t2;\\n      }\\n\\n      left++;\\n      right--;\\n    } else {\\n      return left;\\n    }\\n  }\\n}\\n\\nvar BIN_COUNT = 32;\\nvar sahBins = new Array(BIN_COUNT).fill().map(function () {\\n  return {\\n    count: 0,\\n    bounds: new Float32Array(6),\\n    rightCacheBounds: new Float32Array(6),\\n    candidate: 0\\n  };\\n});\\nvar leftBounds = new Float32Array(6);\\n\\nfunction getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\\n  var axis = -1;\\n  var pos = 0; // Center\\n\\n  if (strategy === _Constants.CENTER) {\\n    axis = (0, _ArrayBoxUtilities.getLongestEdgeIndex)(centroidBoundingData);\\n\\n    if (axis !== -1) {\\n      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\\n    }\\n  } else if (strategy === _Constants.AVERAGE) {\\n    axis = (0, _ArrayBoxUtilities.getLongestEdgeIndex)(nodeBoundingData);\\n\\n    if (axis !== -1) {\\n      pos = getAverage(triangleBounds, offset, count, axis);\\n    }\\n  } else if (strategy === _Constants.SAH) {\\n    var rootSurfaceArea = (0, _ArrayBoxUtilities.computeSurfaceArea)(nodeBoundingData);\\n    var bestCost = _Constants.TRIANGLE_INTERSECT_COST * count; // iterate over all axes\\n\\n    var cStart = offset * 6;\\n    var cEnd = (offset + count) * 6;\\n\\n    for (var a = 0; a < 3; a++) {\\n      var axisLeft = centroidBoundingData[a];\\n      var axisRight = centroidBoundingData[a + 3];\\n      var axisLength = axisRight - axisLeft;\\n      var binWidth = axisLength / BIN_COUNT; // reset the bins\\n\\n      for (var i = 0; i < BIN_COUNT; i++) {\\n        var bin = sahBins[i];\\n        bin.count = 0;\\n        bin.candidate = axisLeft + binWidth + i * binWidth;\\n        var bounds = bin.bounds;\\n\\n        for (var d = 0; d < 3; d++) {\\n          bounds[d] = Infinity;\\n          bounds[d + 3] = -Infinity;\\n        }\\n      } // iterate over all center positions\\n\\n\\n      for (var c = cStart; c < cEnd; c += 6) {\\n        var triCenter = triangleBounds[c + 2 * a];\\n        var relativeCenter = triCenter - axisLeft; // in the partition function if the centroid lies on the split plane then it is\\n        // considered to be on the right side of the split\\n\\n        var binIndex = ~~(relativeCenter / binWidth);\\n        if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\\n        var _bin = sahBins[binIndex];\\n        _bin.count++;\\n        var _bounds = _bin.bounds;\\n\\n        for (var _d = 0; _d < 3; _d++) {\\n          var tCenter = triangleBounds[c + 2 * _d];\\n          var tHalf = triangleBounds[c + 2 * _d + 1];\\n          var tMin = tCenter - tHalf;\\n          var tMax = tCenter + tHalf;\\n\\n          if (tMin < _bounds[_d]) {\\n            _bounds[_d] = tMin;\\n          }\\n\\n          if (tMax > _bounds[_d + 3]) {\\n            _bounds[_d + 3] = tMax;\\n          }\\n        }\\n      } // cache the unioned bounds from right to left so we don't have to regenerate them each time\\n\\n\\n      var lastBin = sahBins[BIN_COUNT - 1];\\n      (0, _ArrayBoxUtilities.copyBounds)(lastBin.bounds, lastBin.rightCacheBounds);\\n\\n      for (var _i = BIN_COUNT - 2; _i >= 0; _i--) {\\n        var _bin2 = sahBins[_i];\\n        var nextBin = sahBins[_i + 1];\\n        (0, _ArrayBoxUtilities.unionBounds)(_bin2.bounds, nextBin.rightCacheBounds, _bin2.rightCacheBounds);\\n      }\\n\\n      var leftCount = 0;\\n\\n      for (var _i2 = 0; _i2 < BIN_COUNT - 1; _i2++) {\\n        var _bin3 = sahBins[_i2];\\n        var binCount = _bin3.count;\\n        var _bounds2 = _bin3.bounds;\\n        var _nextBin = sahBins[_i2 + 1];\\n        var rightBounds = _nextBin.rightCacheBounds; // dont do anything with the bounds if the new bounds have no triangles\\n\\n        if (binCount !== 0) {\\n          if (leftCount === 0) {\\n            (0, _ArrayBoxUtilities.copyBounds)(_bounds2, leftBounds);\\n          } else {\\n            (0, _ArrayBoxUtilities.unionBounds)(_bounds2, leftBounds, leftBounds);\\n          }\\n        }\\n\\n        leftCount += binCount; // check the cost of this split\\n\\n        var leftProb = 0;\\n        var rightProb = 0;\\n\\n        if (leftCount !== 0) {\\n          leftProb = (0, _ArrayBoxUtilities.computeSurfaceArea)(leftBounds) / rootSurfaceArea;\\n        }\\n\\n        var rightCount = count - leftCount;\\n\\n        if (rightCount !== 0) {\\n          rightProb = (0, _ArrayBoxUtilities.computeSurfaceArea)(rightBounds) / rootSurfaceArea;\\n        }\\n\\n        var cost = _Constants.TRAVERSAL_COST + _Constants.TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\\n\\n        if (cost < bestCost) {\\n          axis = a;\\n          bestCost = cost;\\n          pos = _bin3.candidate;\\n        }\\n      }\\n    }\\n  }\\n\\n  return {\\n    axis: axis,\\n    pos: pos\\n  };\\n} // returns the average coordinate on the specified axis of the all the provided triangles\\n\\n\\nfunction getAverage(triangleBounds, offset, count, axis) {\\n  var avg = 0;\\n\\n  for (var i = offset, end = offset + count; i < end; i++) {\\n    avg += triangleBounds[i * 6 + axis * 2];\\n  }\\n\\n  return avg / count;\\n} // precomputes the bounding box for each triangle; required for quickly calculating tree splits.\\n// result is an array of size tris.length * 6 where triangle i maps to a\\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\\n// representing the center and half-extent in each dimension of triangle i\\n\\n\\nfunction computeTriangleBounds(geo) {\\n  var posAttr = geo.attributes.position;\\n  var posArr = posAttr.array;\\n  var index = geo.index.array;\\n  var triCount = index.length / 3;\\n  var triangleBounds = new Float32Array(triCount * 6); // support for an interleaved position buffer\\n\\n  var bufferOffset = posAttr.offset || 0;\\n  var stride = 3;\\n\\n  if (posAttr.isInterleavedBufferAttribute) {\\n    stride = posAttr.data.stride;\\n  }\\n\\n  for (var tri = 0; tri < triCount; tri++) {\\n    var tri3 = tri * 3;\\n    var tri6 = tri * 6;\\n    var ai = index[tri3 + 0] * stride + bufferOffset;\\n    var bi = index[tri3 + 1] * stride + bufferOffset;\\n    var ci = index[tri3 + 2] * stride + bufferOffset;\\n\\n    for (var el = 0; el < 3; el++) {\\n      var a = posArr[ai + el];\\n      var b = posArr[bi + el];\\n      var c = posArr[ci + el];\\n      var min = a;\\n      if (b < min) min = b;\\n      if (c < min) min = c;\\n      var max = a;\\n      if (b > max) max = b;\\n      if (c > max) max = c; // Increase the bounds size by float32 epsilon to avoid precision errors when\\n      // converting to 32 bit float. Scale the epsilon by the size of the numbers being\\n      // worked with.\\n\\n      var halfExtents = (max - min) / 2;\\n      var el2 = el * 2;\\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\\n    }\\n  }\\n\\n  return triangleBounds;\\n}\\n\\nfunction buildTree(geo, options) {\\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\\n  function splitNode(node, offset, count) {\\n    var centroidBoundingData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\\n    var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\\n\\n    if (!reachedMaxDepth && depth >= maxDepth) {\\n      reachedMaxDepth = true;\\n\\n      if (verbose) {\\n        console.warn(\\\"MeshBVH: Max depth of \\\".concat(maxDepth, \\\" reached when generating BVH. Consider increasing maxDepth.\\\"));\\n        console.warn(this, geo);\\n      }\\n    } // early out if we've met our capacity\\n\\n\\n    if (count <= maxLeafTris || depth >= maxDepth) {\\n      node.offset = offset;\\n      node.count = count;\\n      return node;\\n    } // Find where to split the volume\\n\\n\\n    var split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\\n\\n    if (split.axis === -1) {\\n      node.offset = offset;\\n      node.count = count;\\n      return node;\\n    }\\n\\n    var splitOffset = partition(indexArray, triangleBounds, offset, count, split); // create the two new child nodes\\n\\n    if (splitOffset === offset || splitOffset === offset + count) {\\n      node.offset = offset;\\n      node.count = count;\\n    } else {\\n      node.splitAxis = split.axis; // create the left child and compute its bounding box\\n\\n      var left = new _MeshBVHNode[\\\"default\\\"]();\\n      var lstart = offset;\\n      var lcount = splitOffset - offset;\\n      node.left = left;\\n      left.boundingData = new Float32Array(6);\\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1); // repeat for right\\n\\n      var right = new _MeshBVHNode[\\\"default\\\"]();\\n      var rstart = splitOffset;\\n      var rcount = count - lcount;\\n      node.right = right;\\n      right.boundingData = new Float32Array(6);\\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\\n    }\\n\\n    return node;\\n  }\\n\\n  ensureIndex(geo);\\n  var cacheCentroidBoundingData = new Float32Array(6);\\n  var triangleBounds = computeTriangleBounds(geo);\\n  var indexArray = geo.index.array;\\n  var maxDepth = options.maxDepth;\\n  var verbose = options.verbose;\\n  var maxLeafTris = options.maxLeafTris;\\n  var strategy = options.strategy;\\n  var reachedMaxDepth = false;\\n  var roots = [];\\n  var ranges = getRootIndexRanges(geo);\\n\\n  if (ranges.length === 1) {\\n    var root = new _MeshBVHNode[\\\"default\\\"]();\\n    var range = ranges[0];\\n\\n    if (geo.boundingBox != null) {\\n      root.boundingData = (0, _ArrayBoxUtilities.boxToArray)(geo.boundingBox);\\n      getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\\n    } else {\\n      root.boundingData = new Float32Array(6);\\n      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\\n    }\\n\\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\\n    roots.push(root);\\n  } else {\\n    var _iteratorNormalCompletion2 = true;\\n    var _didIteratorError2 = false;\\n    var _iteratorError2 = undefined;\\n\\n    try {\\n      for (var _iterator2 = ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n        var _range = _step2.value;\\n\\n        var _root = new _MeshBVHNode[\\\"default\\\"]();\\n\\n        _root.boundingData = new Float32Array(6);\\n        getBounds(triangleBounds, _range.offset, _range.count, _root.boundingData, cacheCentroidBoundingData);\\n        splitNode(_root, _range.offset, _range.count, cacheCentroidBoundingData);\\n        roots.push(_root);\\n      }\\n    } catch (err) {\\n      _didIteratorError2 = true;\\n      _iteratorError2 = err;\\n    } finally {\\n      try {\\n        if (!_iteratorNormalCompletion2 && _iterator2[\\\"return\\\"] != null) {\\n          _iterator2[\\\"return\\\"]();\\n        }\\n      } finally {\\n        if (_didIteratorError2) {\\n          throw _iteratorError2;\\n        }\\n      }\\n    }\\n  }\\n\\n  return roots;\\n}\\n\\nvar BYTES_PER_NODE = 6 * 4 + 4 + 4;\\nexports.BYTES_PER_NODE = BYTES_PER_NODE;\\nvar IS_LEAFNODE_FLAG = 0xFFFF;\\nexports.IS_LEAFNODE_FLAG = IS_LEAFNODE_FLAG;\\n\\nfunction buildPackedTree(geo, options) {\\n  // boundingData  \\t\\t\\t\\t: 6 float32\\n  // right / offset \\t\\t\\t\\t: 1 uint32\\n  // splitAxis / isLeaf + count \\t: 1 uint32 / 2 uint16\\n  var roots = buildTree(geo, options);\\n  var float32Array;\\n  var uint32Array;\\n  var uint16Array;\\n  var packedRoots = [];\\n\\n  for (var i = 0; i < roots.length; i++) {\\n    var root = roots[i];\\n    var nodeCount = countNodes(root);\\n    var buffer = new ArrayBuffer(BYTES_PER_NODE * nodeCount);\\n    float32Array = new Float32Array(buffer);\\n    uint32Array = new Uint32Array(buffer);\\n    uint16Array = new Uint16Array(buffer);\\n    populateBuffer(0, root);\\n    packedRoots.push(buffer);\\n  }\\n\\n  return packedRoots;\\n\\n  function countNodes(node) {\\n    if (node.count) {\\n      return 1;\\n    } else {\\n      return 1 + countNodes(node.left) + countNodes(node.right);\\n    }\\n  }\\n\\n  function populateBuffer(byteOffset, node) {\\n    var stride4Offset = byteOffset / 4;\\n    var stride2Offset = byteOffset / 2;\\n    var isLeaf = !!node.count;\\n    var boundingData = node.boundingData;\\n\\n    for (var _i3 = 0; _i3 < 6; _i3++) {\\n      float32Array[stride4Offset + _i3] = boundingData[_i3];\\n    }\\n\\n    if (isLeaf) {\\n      var offset = node.offset;\\n      var count = node.count;\\n      uint32Array[stride4Offset + 6] = offset;\\n      uint16Array[stride2Offset + 14] = count;\\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\\n      return byteOffset + BYTES_PER_NODE;\\n    } else {\\n      var left = node.left;\\n      var right = node.right;\\n      var splitAxis = node.splitAxis;\\n      var nextUnusedPointer;\\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\\n\\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\\n        throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\\n      }\\n\\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\\n      uint32Array[stride4Offset + 7] = splitAxis;\\n      return nextUnusedPointer;\\n    }\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"ensureIndex\",\"geo\",\"index\",\"vertexCount\",\"attributes\",\"position\",\"count\",\"Uint32Array\",\"Uint16Array\",\"setIndex\",\"_three\",\"BufferAttribute\",\"i\",\"getRootIndexRanges\",\"groups\",\"length\",\"offset\",\"ranges\",\"rangeBoundaries\",\"Set\",\"_iteratorNormalCompletion\",\"_didIteratorError\",\"_iteratorError\",\"undefined\",\"_iterator\",\"Symbol\",\"iterator\",\"_step\",\"done\",\"next\",\"group\",\"value\",\"add\",\"start\",\"err\",\"sortedBoundaries\",\"Array\",\"from\",\"values\",\"sort\",\"a\",\"b\",\"push\",\"end\",\"getBounds\",\"triangleBounds\",\"target\",\"centroidTarget\",\"arguments\",\"minx\",\"Infinity\",\"miny\",\"minz\",\"maxx\",\"maxy\",\"maxz\",\"cminx\",\"cminy\",\"cminz\",\"cmaxx\",\"cmaxy\",\"cmaxz\",\"includeCentroid\",\"cx\",\"hx\",\"lx\",\"rx\",\"cy\",\"hy\",\"ly\",\"ry\",\"cz\",\"hz\",\"lz\",\"rz\",\"getCentroidBounds\",\"computeTriangleBounds\",\"posAttr\",\"posArr\",\"array\",\"triCount\",\"Float32Array\",\"bufferOffset\",\"stride\",\"isInterleavedBufferAttribute\",\"data\",\"tri\",\"tri3\",\"tri6\",\"ai\",\"bi\",\"ci\",\"el\",\"c\",\"min\",\"max\",\"halfExtents\",\"el2\",\"Math\",\"abs\",\"FLOAT32_EPSILON\",\"buildTree\",\"options\",\"splitNode\",\"node\",\"centroidBoundingData\",\"depth\",\"reachedMaxDepth\",\"maxDepth\",\"verbose\",\"console\",\"warn\",\"concat\",\"maxLeafTris\",\"boundingData\",\"strategy\",\"axis\",\"pos\",\"_Constants\",\"CENTER\",\"_ArrayBoxUtilities\",\"getLongestEdgeIndex\",\"AVERAGE\",\"nodeBoundingData\",\"avg\",\"SAH\",\"rootSurfaceArea\",\"computeSurfaceArea\",\"bestCost\",\"TRIANGLE_INTERSECT_COST\",\"cStart\",\"cEnd\",\"axisLeft\",\"binWidth\",\"axisRight\",\"BIN_COUNT\",\"bin\",\"sahBins\",\"candidate\",\"bounds\",\"d\",\"binIndex\",\"_d\",\"triCenter\",\"_bin\",\"_bounds\",\"tCenter\",\"tHalf\",\"tMin\",\"tMax\",\"lastBin\",\"copyBounds\",\"rightCacheBounds\",\"_i\",\"_bin2\",\"nextBin\",\"unionBounds\",\"_i2\",\"leftCount\",\"_bin3\",\"binCount\",\"_bounds2\",\"rightBounds\",\"_nextBin\",\"leftBounds\",\"rightProb\",\"leftProb\",\"rightCount\",\"cost\",\"TRAVERSAL_COST\",\"indexArray\",\"axisOffset\",\"left\",\"right\",\"t0\",\"t1\",\"t2\",\"splitOffset\",\"splitAxis\",\"_MeshBVHNode\",\"lcount\",\"cacheCentroidBoundingData\",\"rcount\",\"rstart\",\"roots\",\"root\",\"range\",\"boundingBox\",\"boxToArray\",\"_iteratorNormalCompletion2\",\"_didIteratorError2\",\"_iteratorError2\",\"_iterator2\",\"_step2\",\"_range\",\"_root\",\"Object\",\"defineProperty\",\"buildPackedTree\",\"countNodes\",\"populateBuffer\",\"byteOffset\",\"stride4Offset\",\"stride2Offset\",\"isLeaf\",\"_i3\",\"float32Array\",\"uint32Array\",\"uint16Array\",\"IS_LEAFNODE_FLAG\",\"BYTES_PER_NODE\",\"nextUnusedPointer\",\"pow\",\"Error\",\"packedRoots\",\"nodeCount\",\"buffer\",\"ArrayBuffer\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"fill\",\"map\"]\n}\n"]