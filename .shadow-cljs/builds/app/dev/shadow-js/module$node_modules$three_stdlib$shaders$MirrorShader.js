["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/MirrorShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$MirrorShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.MirrorShader=void 0;exports.MirrorShader={uniforms:{tDiffuse:{value:null},side:{value:1}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform sampler2D tDiffuse;\\nuniform int side;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec2 p \\x3d vUv;\\n\\tif (side \\x3d\\x3d 0){\\n\\t\\tif (p.x \\x3e 0.5) p.x \\x3d 1.0 - p.x;\\n\\t}else if (side \\x3d\\x3d 1){\\n\\t\\tif (p.x \\x3c 0.5) p.x \\x3d 1.0 - p.x;\\n\\t}else if (side \\x3d\\x3d 2){\\n\\t\\tif (p.y \\x3c 0.5) p.y \\x3d 1.0 - p.y;\\n\\t}else if (side \\x3d\\x3d 3){\\n\\t\\tif (p.y \\x3e 0.5) p.y \\x3d 1.0 - p.y;\\n\\t} \\n\\tvec4 color \\x3d texture2D(tDiffuse, p);\\n\\tgl_FragColor \\x3d color;\\n}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$MirrorShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MirrorShader = void 0;\n\n/**\n * Mirror Shader\n * Copies half the input to the other half\n *\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\n */\nvar MirrorShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    side: {\n      value: 1\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform int side;', 'varying vec2 vUv;', 'void main() {', '\tvec2 p = vUv;', '\tif (side == 0){', '\t\tif (p.x > 0.5) p.x = 1.0 - p.x;', '\t}else if (side == 1){', '\t\tif (p.x < 0.5) p.x = 1.0 - p.x;', '\t}else if (side == 2){', '\t\tif (p.y < 0.5) p.y = 1.0 - p.y;', '\t}else if (side == 3){', '\t\tif (p.y > 0.5) p.y = 1.0 - p.y;', '\t} ', '\tvec4 color = texture2D(tDiffuse, p);', '\tgl_FragColor = color;', '}'].join('\\n')\n};\nexports.MirrorShader = MirrorShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["fragmentShader","side","__esModule","MirrorShader","tDiffuse","vertexShader","value","uniforms"]],"~:compiled-at",1630917515578,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$MirrorShader.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAA,qDAAA,CAA0E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGlHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,YAAR,CAAuB,IAAK,EAoB5BJ,QAAQI,CAAAA,YAAR,CAZmBA,CACjBC,SAAU,CACRC,SAAU,CACRH,MAAO,IADC,CADF,CAIRI,KAAM,CACJJ,MAAO,CADH,CAJE,CADOC,CASjBI,aAAiJ,qIAThIJ,CAUjBK,eAA6b,wdAV5aL,CAd+F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/MirrorShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$MirrorShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.MirrorShader = void 0;\\n\\n/**\\n * Mirror Shader\\n * Copies half the input to the other half\\n *\\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\\n */\\nvar MirrorShader = {\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    side: {\\n      value: 1\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform int side;', 'varying vec2 vUv;', 'void main() {', '\\tvec2 p = vUv;', '\\tif (side == 0){', '\\t\\tif (p.x > 0.5) p.x = 1.0 - p.x;', '\\t}else if (side == 1){', '\\t\\tif (p.x < 0.5) p.x = 1.0 - p.x;', '\\t}else if (side == 2){', '\\t\\tif (p.y < 0.5) p.y = 1.0 - p.y;', '\\t}else if (side == 3){', '\\t\\tif (p.y > 0.5) p.y = 1.0 - p.y;', '\\t} ', '\\tvec4 color = texture2D(tDiffuse, p);', '\\tgl_FragColor = color;', '}'].join('\\\\n')\\n};\\nexports.MirrorShader = MirrorShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"MirrorShader\",\"uniforms\",\"tDiffuse\",\"side\",\"vertexShader\",\"fragmentShader\"]\n}\n"]