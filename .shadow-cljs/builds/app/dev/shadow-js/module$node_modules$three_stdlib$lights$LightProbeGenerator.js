["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/lights/LightProbeGenerator.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$lights$LightProbeGenerator=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.LightProbeGenerator=void 0;var _three=require(\"module$node_modules$three$build$three_module\");exports.LightProbeGenerator={fromCubeTexture:function(cubeTexture){for(var lengthSq,totalWeight=0,coord=new _three.Vector3,dir=new _three.Vector3,color=new _three.Color,shBasis=[0,0,0,0,0,0,0,0,0],sh=new _three.SphericalHarmonics3,\nshCoefficients=sh.coefficients,faceIndex=0;6>faceIndex;faceIndex++){var image=cubeTexture.image[faceIndex],width=image.width,height=image.height,canvas=document.createElement(\"canvas\");canvas.width=width;canvas.height=height;canvas=canvas.getContext(\"2d\");canvas.drawImage(image,0,0,width,height);width=canvas.getImageData(0,0,width,height);image=width.data;width=width.width;height=2/width;canvas=0;for(var il=image.length;canvas<il;canvas+=4){color.setRGB(image[canvas]/255,image[canvas+1]/255,image[canvas+\n2]/255);convertColorToLinear(color,cubeTexture.encoding);var pixelIndex=canvas/4;lengthSq=-1+(pixelIndex%width+.5)*height;pixelIndex=1-(Math.floor(pixelIndex/width)+.5)*height;switch(faceIndex){case 0:coord.set(-1,pixelIndex,-lengthSq);break;case 1:coord.set(1,pixelIndex,lengthSq);break;case 2:coord.set(-lengthSq,1,-pixelIndex);break;case 3:coord.set(-lengthSq,-1,pixelIndex);break;case 4:coord.set(-lengthSq,pixelIndex,1);break;case 5:coord.set(lengthSq,pixelIndex,-1)}lengthSq=coord.lengthSq();lengthSq=\n4/(Math.sqrt(lengthSq)*lengthSq);totalWeight+=lengthSq;dir.copy(coord).normalize();_three.SphericalHarmonics3.getBasisAt(dir,shBasis);for(pixelIndex=0;9>pixelIndex;pixelIndex++)shCoefficients[pixelIndex].x+=shBasis[pixelIndex]*color.r*lengthSq,shCoefficients[pixelIndex].y+=shBasis[pixelIndex]*color.g*lengthSq,shCoefficients[pixelIndex].z+=shBasis[pixelIndex]*color.b*lengthSq}}cubeTexture=4*Math.PI/totalWeight;for(totalWeight=0;9>totalWeight;totalWeight++)shCoefficients[totalWeight].x*=cubeTexture,\nshCoefficients[totalWeight].y*=cubeTexture,shCoefficients[totalWeight].z*=cubeTexture;return new _three.LightProbe(sh)},fromCubeRenderTarget:function(renderer,cubeRenderTarget){for(var lengthSq,totalWeight=0,coord=new _three.Vector3,dir=new _three.Vector3,color=new _three.Color,shBasis=[0,0,0,0,0,0,0,0,0],sh=new _three.SphericalHarmonics3,shCoefficients=sh.coefficients,faceIndex=0;6>faceIndex;faceIndex++){var imageWidth=cubeRenderTarget.width,data=new Uint8Array(imageWidth*imageWidth*4);renderer.readRenderTargetPixels(cubeRenderTarget,\n0,0,imageWidth,imageWidth,data,faceIndex);for(var pixelSize=2/imageWidth,i=0,il=data.length;i<il;i+=4){color.setRGB(data[i]/255,data[i+1]/255,data[i+2]/255);convertColorToLinear(color,cubeRenderTarget.texture.encoding);var pixelIndex=i/4;lengthSq=-1+(pixelIndex%imageWidth+.5)*pixelSize;pixelIndex=1-(Math.floor(pixelIndex/imageWidth)+.5)*pixelSize;switch(faceIndex){case 0:coord.set(1,pixelIndex,-lengthSq);break;case 1:coord.set(-1,pixelIndex,lengthSq);break;case 2:coord.set(lengthSq,1,-pixelIndex);\nbreak;case 3:coord.set(lengthSq,-1,pixelIndex);break;case 4:coord.set(lengthSq,pixelIndex,1);break;case 5:coord.set(-lengthSq,pixelIndex,-1)}lengthSq=coord.lengthSq();lengthSq=4/(Math.sqrt(lengthSq)*lengthSq);totalWeight+=lengthSq;dir.copy(coord).normalize();_three.SphericalHarmonics3.getBasisAt(dir,shBasis);for(pixelIndex=0;9>pixelIndex;pixelIndex++)shCoefficients[pixelIndex].x+=shBasis[pixelIndex]*color.r*lengthSq,shCoefficients[pixelIndex].y+=shBasis[pixelIndex]*color.g*lengthSq,shCoefficients[pixelIndex].z+=\nshBasis[pixelIndex]*color.b*lengthSq}}renderer=4*Math.PI/totalWeight;for(cubeRenderTarget=0;9>cubeRenderTarget;cubeRenderTarget++)shCoefficients[cubeRenderTarget].x*=renderer,shCoefficients[cubeRenderTarget].y*=renderer,shCoefficients[cubeRenderTarget].z*=renderer;return new _three.LightProbe(sh)}};var convertColorToLinear=function(color,encoding){switch(encoding){case _three.sRGBEncoding:color.convertSRGBToLinear();break;case _three.LinearEncoding:break;default:console.warn(\"WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.\")}return color}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$lights$LightProbeGenerator\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LightProbeGenerator = void 0;\n\nvar _three = require(\"three\");\n\nvar LightProbeGenerator = {\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\n  fromCubeTexture: function fromCubeTexture(cubeTexture) {\n    var norm,\n        lengthSq,\n        weight,\n        totalWeight = 0;\n    var coord = new _three.Vector3();\n    var dir = new _three.Vector3();\n    var color = new _three.Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new _three.SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n\n    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var image = cubeTexture.image[faceIndex];\n      var width = image.width;\n      var height = image.height;\n      var canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext('2d');\n      context.drawImage(image, 0, 0, width, height);\n      var imageData = context.getImageData(0, 0, width, height);\n      var data = imageData.data;\n      var imageWidth = imageData.width; // assumed to be square\n\n      var pixelSize = 2 / imageWidth;\n\n      for (var i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeTexture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col);\n            break;\n\n          case 1:\n            coord.set(1, row, col);\n            break;\n\n          case 2:\n            coord.set(-col, 1, -row);\n            break;\n\n          case 3:\n            coord.set(-col, -1, row);\n            break;\n\n          case 4:\n            coord.set(-col, row, 1);\n            break;\n\n          case 5:\n            coord.set(col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        _three.SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n\n        for (var j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n\n    norm = 4 * Math.PI / totalWeight;\n\n    for (var _j = 0; _j < 9; _j++) {\n      shCoefficients[_j].x *= norm;\n      shCoefficients[_j].y *= norm;\n      shCoefficients[_j].z *= norm;\n    }\n\n    return new _three.LightProbe(sh);\n  },\n  fromCubeRenderTarget: function fromCubeRenderTarget(renderer, cubeRenderTarget) {\n    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n    var norm,\n        lengthSq,\n        weight,\n        totalWeight = 0;\n    var coord = new _three.Vector3();\n    var dir = new _three.Vector3();\n    var color = new _three.Color();\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var sh = new _three.SphericalHarmonics3();\n    var shCoefficients = sh.coefficients;\n\n    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n      var imageWidth = cubeRenderTarget.width; // assumed to be square\n\n      var data = new Uint8Array(imageWidth * imageWidth * 4);\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\n      var pixelSize = 2 / imageWidth;\n\n      for (var i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\n\n        convertColorToLinear(color, cubeRenderTarget.texture.encoding); // pixel coordinate on unit cube\n\n        var pixelIndex = i / 4;\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(1, row, -col);\n            break;\n\n          case 1:\n            coord.set(-1, row, col);\n            break;\n\n          case 2:\n            coord.set(col, 1, -row);\n            break;\n\n          case 3:\n            coord.set(col, -1, row);\n            break;\n\n          case 4:\n            coord.set(col, row, 1);\n            break;\n\n          case 5:\n            coord.set(-col, row, -1);\n            break;\n        } // weight assigned to this pixel\n\n\n        lengthSq = coord.lengthSq();\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n        totalWeight += weight; // direction vector to this pixel\n\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\n\n        _three.SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\n\n\n        for (var j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\n        }\n      }\n    } // normalize\n\n\n    norm = 4 * Math.PI / totalWeight;\n\n    for (var _j2 = 0; _j2 < 9; _j2++) {\n      shCoefficients[_j2].x *= norm;\n      shCoefficients[_j2].y *= norm;\n      shCoefficients[_j2].z *= norm;\n    }\n\n    return new _three.LightProbe(sh);\n  }\n};\nexports.LightProbeGenerator = LightProbeGenerator;\n\nvar convertColorToLinear = function convertColorToLinear(color, encoding) {\n  switch (encoding) {\n    case _three.sRGBEncoding:\n      color.convertSRGBToLinear();\n      break;\n\n    case _three.LinearEncoding:\n      break;\n\n    default:\n      console.warn('WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.');\n      break;\n  }\n\n  return color;\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["LightProbeGenerator","z","width","height","x","__esModule","fromCubeTexture","value","y","fromCubeRenderTarget"]],"~:compiled-at",1630917516062,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$lights$LightProbeGenerator.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/lights/LightProbeGenerator.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$lights$LightProbeGenerator\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.LightProbeGenerator = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar LightProbeGenerator = {\\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\\n  fromCubeTexture: function fromCubeTexture(cubeTexture) {\\n    var norm,\\n        lengthSq,\\n        weight,\\n        totalWeight = 0;\\n    var coord = new _three.Vector3();\\n    var dir = new _three.Vector3();\\n    var color = new _three.Color();\\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\\n    var sh = new _three.SphericalHarmonics3();\\n    var shCoefficients = sh.coefficients;\\n\\n    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\\n      var image = cubeTexture.image[faceIndex];\\n      var width = image.width;\\n      var height = image.height;\\n      var canvas = document.createElement('canvas');\\n      canvas.width = width;\\n      canvas.height = height;\\n      var context = canvas.getContext('2d');\\n      context.drawImage(image, 0, 0, width, height);\\n      var imageData = context.getImageData(0, 0, width, height);\\n      var data = imageData.data;\\n      var imageWidth = imageData.width; // assumed to be square\\n\\n      var pixelSize = 2 / imageWidth;\\n\\n      for (var i = 0, il = data.length; i < il; i += 4) {\\n        // RGBA assumed\\n        // pixel color\\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\\n\\n        convertColorToLinear(color, cubeTexture.encoding); // pixel coordinate on unit cube\\n\\n        var pixelIndex = i / 4;\\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\\n\\n        switch (faceIndex) {\\n          case 0:\\n            coord.set(-1, row, -col);\\n            break;\\n\\n          case 1:\\n            coord.set(1, row, col);\\n            break;\\n\\n          case 2:\\n            coord.set(-col, 1, -row);\\n            break;\\n\\n          case 3:\\n            coord.set(-col, -1, row);\\n            break;\\n\\n          case 4:\\n            coord.set(-col, row, 1);\\n            break;\\n\\n          case 5:\\n            coord.set(col, row, -1);\\n            break;\\n        } // weight assigned to this pixel\\n\\n\\n        lengthSq = coord.lengthSq();\\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\\n        totalWeight += weight; // direction vector to this pixel\\n\\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\\n\\n        _three.SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\\n\\n\\n        for (var j = 0; j < 9; j++) {\\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\\n        }\\n      }\\n    } // normalize\\n\\n\\n    norm = 4 * Math.PI / totalWeight;\\n\\n    for (var _j = 0; _j < 9; _j++) {\\n      shCoefficients[_j].x *= norm;\\n      shCoefficients[_j].y *= norm;\\n      shCoefficients[_j].z *= norm;\\n    }\\n\\n    return new _three.LightProbe(sh);\\n  },\\n  fromCubeRenderTarget: function fromCubeRenderTarget(renderer, cubeRenderTarget) {\\n    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\\n    var norm,\\n        lengthSq,\\n        weight,\\n        totalWeight = 0;\\n    var coord = new _three.Vector3();\\n    var dir = new _three.Vector3();\\n    var color = new _three.Color();\\n    var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\\n    var sh = new _three.SphericalHarmonics3();\\n    var shCoefficients = sh.coefficients;\\n\\n    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\\n      var imageWidth = cubeRenderTarget.width; // assumed to be square\\n\\n      var data = new Uint8Array(imageWidth * imageWidth * 4);\\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\\n      var pixelSize = 2 / imageWidth;\\n\\n      for (var i = 0, il = data.length; i < il; i += 4) {\\n        // RGBA assumed\\n        // pixel color\\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255); // convert to linear color space\\n\\n        convertColorToLinear(color, cubeRenderTarget.texture.encoding); // pixel coordinate on unit cube\\n\\n        var pixelIndex = i / 4;\\n        var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\\n        var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\\n\\n        switch (faceIndex) {\\n          case 0:\\n            coord.set(1, row, -col);\\n            break;\\n\\n          case 1:\\n            coord.set(-1, row, col);\\n            break;\\n\\n          case 2:\\n            coord.set(col, 1, -row);\\n            break;\\n\\n          case 3:\\n            coord.set(col, -1, row);\\n            break;\\n\\n          case 4:\\n            coord.set(col, row, 1);\\n            break;\\n\\n          case 5:\\n            coord.set(-col, row, -1);\\n            break;\\n        } // weight assigned to this pixel\\n\\n\\n        lengthSq = coord.lengthSq();\\n        weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\\n        totalWeight += weight; // direction vector to this pixel\\n\\n        dir.copy(coord).normalize(); // evaluate SH basis functions in direction dir\\n\\n        _three.SphericalHarmonics3.getBasisAt(dir, shBasis); // accummuulate\\n\\n\\n        for (var j = 0; j < 9; j++) {\\n          shCoefficients[j].x += shBasis[j] * color.r * weight;\\n          shCoefficients[j].y += shBasis[j] * color.g * weight;\\n          shCoefficients[j].z += shBasis[j] * color.b * weight;\\n        }\\n      }\\n    } // normalize\\n\\n\\n    norm = 4 * Math.PI / totalWeight;\\n\\n    for (var _j2 = 0; _j2 < 9; _j2++) {\\n      shCoefficients[_j2].x *= norm;\\n      shCoefficients[_j2].y *= norm;\\n      shCoefficients[_j2].z *= norm;\\n    }\\n\\n    return new _three.LightProbe(sh);\\n  }\\n};\\nexports.LightProbeGenerator = LightProbeGenerator;\\n\\nvar convertColorToLinear = function convertColorToLinear(color, encoding) {\\n  switch (encoding) {\\n    case _three.sRGBEncoding:\\n      color.convertSRGBToLinear();\\n      break;\\n\\n    case _three.LinearEncoding:\\n      break;\\n\\n    default:\\n      console.warn('WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.');\\n      break;\\n  }\\n\\n  return color;\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"LightProbeGenerator\",\"_three\",\"fromCubeTexture\",\"cubeTexture\",\"lengthSq\",\"totalWeight\",\"coord\",\"Vector3\",\"dir\",\"color\",\"Color\",\"shBasis\",\"sh\",\"SphericalHarmonics3\",\"shCoefficients\",\"coefficients\",\"faceIndex\",\"image\",\"width\",\"height\",\"canvas\",\"document\",\"createElement\",\"context\",\"getContext\",\"drawImage\",\"imageData\",\"getImageData\",\"data\",\"imageWidth\",\"pixelSize\",\"i\",\"il\",\"length\",\"setRGB\",\"convertColorToLinear\",\"encoding\",\"pixelIndex\",\"col\",\"row\",\"Math\",\"floor\",\"set\",\"weight\",\"sqrt\",\"copy\",\"normalize\",\"getBasisAt\",\"j\",\"x\",\"r\",\"y\",\"g\",\"z\",\"b\",\"norm\",\"PI\",\"_j\",\"LightProbe\",\"fromCubeRenderTarget\",\"renderer\",\"cubeRenderTarget\",\"Uint8Array\",\"readRenderTargetPixels\",\"texture\",\"_j2\",\"sRGBEncoding\",\"convertSRGBToLinear\",\"LinearEncoding\",\"console\",\"warn\"]\n}\n"]