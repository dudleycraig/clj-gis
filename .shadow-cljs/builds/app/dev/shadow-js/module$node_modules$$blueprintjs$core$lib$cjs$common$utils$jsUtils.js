["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@blueprintjs/core/lib/cjs/common/utils/jsUtils.js"],"~:js","shadow$provide.module$node_modules$$blueprintjs$core$lib$cjs$common$utils$jsUtils=function(global,require,module,exports){var process=require(\"module$node_modules$process$browser\");\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0});exports.uniqueId=exports.countDecimalPlaces=exports.clamp=exports.approxEqual=exports.arrayLengthCompare=exports.isNodeEnv=void 0;var errors_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$common$errors\");exports.isNodeEnv=function(env){return\"undefined\"!==\ntypeof process&&process.env&&\"development\"===env};exports.arrayLengthCompare=function(a,b){void 0===a&&(a=[]);void 0===b&&(b=[]);return a.length-b.length};exports.approxEqual=function(a,b,tolerance){void 0===tolerance&&(tolerance=1E-5);return Math.abs(a-b)<=tolerance};exports.clamp=function(val,min,max){if(null==val)return val;if(max<min)throw Error(errors_1.CLAMP_MIN_MAX);return Math.min(Math.max(val,min),max)};exports.countDecimalPlaces=function(num){if(!isFinite(num))return 0;for(var e=1,p=0;Math.round(num*\ne)/e!==num;)e*=10,p++;return p};var uniqueCountForNamespace=new Map;exports.uniqueId=function(namespace){var _a,curCount=null!==(_a=uniqueCountForNamespace.get(namespace))&&void 0!==_a?_a:0;uniqueCountForNamespace.set(namespace,curCount+1);return namespace+\"-\"+curCount}}","~:source","shadow$provide[\"module$node_modules$$blueprintjs$core$lib$cjs$common$utils$jsUtils\"] = function(global,require,module,exports) {\nvar process = require('process');\n\"use strict\";\n/*\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uniqueId = exports.countDecimalPlaces = exports.clamp = exports.approxEqual = exports.arrayLengthCompare = exports.isNodeEnv = void 0;\nvar errors_1 = require(\"../errors\");\n/** Returns whether `process.env.NODE_ENV` exists and equals `env`. */\nfunction isNodeEnv(env) {\n    return typeof process !== \"undefined\" && process.env && process.env.NODE_ENV === env;\n}\nexports.isNodeEnv = isNodeEnv;\n/**\n * Returns the difference in length between two arrays. A `null` argument is\n * considered an empty list. The return value will be positive if `a` is longer\n * than `b`, negative if the opposite is true, and zero if their lengths are\n * equal.\n */\nfunction arrayLengthCompare(a, b) {\n    if (a === void 0) { a = []; }\n    if (b === void 0) { b = []; }\n    return a.length - b.length;\n}\nexports.arrayLengthCompare = arrayLengthCompare;\n/**\n * Returns true if the two numbers are within the given tolerance of each other.\n * This is useful to correct for floating point precision issues, less useful\n * for integers.\n */\nfunction approxEqual(a, b, tolerance) {\n    if (tolerance === void 0) { tolerance = 0.00001; }\n    return Math.abs(a - b) <= tolerance;\n}\nexports.approxEqual = approxEqual;\n/**\n * Clamps the given number between min and max values. Returns value if within\n * range, or closest bound.\n */\nfunction clamp(val, min, max) {\n    if (val == null) {\n        return val;\n    }\n    if (max < min) {\n        throw new Error(errors_1.CLAMP_MIN_MAX);\n    }\n    return Math.min(Math.max(val, min), max);\n}\nexports.clamp = clamp;\n/** Returns the number of decimal places in the given number. */\nfunction countDecimalPlaces(num) {\n    if (!isFinite(num)) {\n        return 0;\n    }\n    var e = 1;\n    var p = 0;\n    while (Math.round(num * e) / e !== num) {\n        e *= 10;\n        p++;\n    }\n    return p;\n}\nexports.countDecimalPlaces = countDecimalPlaces;\nvar uniqueCountForNamespace = new Map();\n/** Generate a unique ID within a given namespace, using a simple counter-based implementation to avoid collisions. */\nfunction uniqueId(namespace) {\n    var _a;\n    var curCount = (_a = uniqueCountForNamespace.get(namespace)) !== null && _a !== void 0 ? _a : 0;\n    uniqueCountForNamespace.set(namespace, curCount + 1);\n    return namespace + \"-\" + curCount;\n}\nexports.uniqueId = uniqueId;\n//# sourceMappingURL=jsUtils.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$process$browser","~$shadow.js","~$module$node_modules$$blueprintjs$core$lib$cjs$common$errors"]],"~:properties",["^5",["countDecimalPlaces","uniqueId","__esModule","value","clamp","approxEqual","isNodeEnv","arrayLengthCompare"]],"~:compiled-at",1630405504901,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$blueprintjs$core$lib$cjs$common$utils$jsUtils.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,kEAAA,CAAuF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAC/H,IAAIC,QAAUH,OAAA,CAAQ,qCAAR,CACd,aAgBAI,OAAOC,CAAAA,cAAP,CAAsBH,OAAtB,CAA+B,YAA/B,CAA6C,CAAEI,MAAO,CAAA,CAAT,CAA7C,CACAJ,QAAQK,CAAAA,QAAR,CAAmBL,OAAQM,CAAAA,kBAA3B,CAAgDN,OAAQO,CAAAA,KAAxD,CAAgEP,OAAQQ,CAAAA,WAAxE,CAAsFR,OAAQS,CAAAA,kBAA9F,CAAmHT,OAAQU,CAAAA,SAA3H,CAAuI,IAAK,EAC5I,KAAIC,SAAWb,OAAA,CAAQ,6DAAR,CAKfE,QAAQU,CAAAA,SAAR,CAHAA,QAAkB,CAACE,GAAD,CAAM,CACpB,MAA0B,WAA1B;AAAO,MAAOX,QAAd,EAAyCA,OAAQW,CAAAA,GAAjD,EAAoEC,aAApE,GAAiFD,GAD7D,CAexBZ,QAAQS,CAAAA,kBAAR,CALAA,QAA2B,CAACK,CAAD,CAAIC,CAAJ,CAAO,CACpB,IAAK,EAAf,GAAID,CAAJ,GAAoBA,CAApB,CAAwB,EAAxB,CACU,KAAK,EAAf,GAAIC,CAAJ,GAAoBA,CAApB,CAAwB,EAAxB,CACA,OAAOD,EAAEE,CAAAA,MAAT,CAAkBD,CAAEC,CAAAA,MAHU,CAelChB,QAAQQ,CAAAA,WAAR,CAJAA,QAAoB,CAACM,CAAD,CAAIC,CAAJ,CAAOE,SAAP,CAAkB,CAChB,IAAK,EAAvB,GAAIA,SAAJ,GAA4BA,SAA5B,CAAwC,IAAxC,CACA,OAAOC,KAAKC,CAAAA,GAAL,CAASL,CAAT,CAAaC,CAAb,CAAP,EAA0BE,SAFQ,CAkBtCjB,QAAQO,CAAAA,KAAR,CATAA,QAAc,CAACa,GAAD,CAAMC,GAAN,CAAWC,GAAX,CAAgB,CAC1B,GAAW,IAAX,EAAIF,GAAJ,CACI,MAAOA,IAEX,IAAIE,GAAJ,CAAUD,GAAV,CACI,KAAUE,MAAJ,CAAUZ,QAASa,CAAAA,aAAnB,CAAN,CAEJ,MAAON,KAAKG,CAAAA,GAAL,CAASH,IAAKI,CAAAA,GAAL,CAASF,GAAT,CAAcC,GAAd,CAAT,CAA6BC,GAA7B,CAPmB,CAuB9BtB,QAAQM,CAAAA,kBAAR,CAZAA,QAA2B,CAACmB,GAAD,CAAM,CAC7B,GAAI,CAACC,QAAA,CAASD,GAAT,CAAL,CACI,MAAO,EAIX,KAFA,IAAIE,EAAI,CAAR,CACIC,EAAI,CACR,CAAOV,IAAKW,CAAAA,KAAL,CAAWJ,GAAX;AAAiBE,CAAjB,CAAP,CAA6BA,CAA7B,GAAmCF,GAAnC,CAAA,CACIE,CACA,EADK,EACL,CAAAC,CAAA,EAEJ,OAAOA,EAVsB,CAajC,KAAIE,wBAA0B,IAAIC,GAQlC/B,QAAQK,CAAAA,QAAR,CANAA,QAAiB,CAAC2B,SAAD,CAAY,CACzB,IAAIC,EAAJ,CACIC,SAA6D,IAAlD,IAACD,EAAD,CAAMH,uBAAwBK,CAAAA,GAAxB,CAA4BH,SAA5B,CAAN,GAAiE,IAAK,EAAtE,GAA0DC,EAA1D,CAA0EA,EAA1E,CAA+E,CAC9FH,wBAAwBM,CAAAA,GAAxB,CAA4BJ,SAA5B,CAAuCE,QAAvC,CAAkD,CAAlD,CACA,OAAOF,UAAP,CAAmB,GAAnB,CAAyBE,QAJA,CA9EkG;\",\n\"sources\":[\"node_modules/@blueprintjs/core/lib/cjs/common/utils/jsUtils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$blueprintjs$core$lib$cjs$common$utils$jsUtils\\\"] = function(global,require,module,exports) {\\nvar process = require('process');\\n\\\"use strict\\\";\\n/*\\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.uniqueId = exports.countDecimalPlaces = exports.clamp = exports.approxEqual = exports.arrayLengthCompare = exports.isNodeEnv = void 0;\\nvar errors_1 = require(\\\"../errors\\\");\\n/** Returns whether `process.env.NODE_ENV` exists and equals `env`. */\\nfunction isNodeEnv(env) {\\n    return typeof process !== \\\"undefined\\\" && process.env && process.env.NODE_ENV === env;\\n}\\nexports.isNodeEnv = isNodeEnv;\\n/**\\n * Returns the difference in length between two arrays. A `null` argument is\\n * considered an empty list. The return value will be positive if `a` is longer\\n * than `b`, negative if the opposite is true, and zero if their lengths are\\n * equal.\\n */\\nfunction arrayLengthCompare(a, b) {\\n    if (a === void 0) { a = []; }\\n    if (b === void 0) { b = []; }\\n    return a.length - b.length;\\n}\\nexports.arrayLengthCompare = arrayLengthCompare;\\n/**\\n * Returns true if the two numbers are within the given tolerance of each other.\\n * This is useful to correct for floating point precision issues, less useful\\n * for integers.\\n */\\nfunction approxEqual(a, b, tolerance) {\\n    if (tolerance === void 0) { tolerance = 0.00001; }\\n    return Math.abs(a - b) <= tolerance;\\n}\\nexports.approxEqual = approxEqual;\\n/**\\n * Clamps the given number between min and max values. Returns value if within\\n * range, or closest bound.\\n */\\nfunction clamp(val, min, max) {\\n    if (val == null) {\\n        return val;\\n    }\\n    if (max < min) {\\n        throw new Error(errors_1.CLAMP_MIN_MAX);\\n    }\\n    return Math.min(Math.max(val, min), max);\\n}\\nexports.clamp = clamp;\\n/** Returns the number of decimal places in the given number. */\\nfunction countDecimalPlaces(num) {\\n    if (!isFinite(num)) {\\n        return 0;\\n    }\\n    var e = 1;\\n    var p = 0;\\n    while (Math.round(num * e) / e !== num) {\\n        e *= 10;\\n        p++;\\n    }\\n    return p;\\n}\\nexports.countDecimalPlaces = countDecimalPlaces;\\nvar uniqueCountForNamespace = new Map();\\n/** Generate a unique ID within a given namespace, using a simple counter-based implementation to avoid collisions. */\\nfunction uniqueId(namespace) {\\n    var _a;\\n    var curCount = (_a = uniqueCountForNamespace.get(namespace)) !== null && _a !== void 0 ? _a : 0;\\n    uniqueCountForNamespace.set(namespace, curCount + 1);\\n    return namespace + \\\"-\\\" + curCount;\\n}\\nexports.uniqueId = uniqueId;\\n//# sourceMappingURL=jsUtils.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"process\",\"Object\",\"defineProperty\",\"value\",\"uniqueId\",\"countDecimalPlaces\",\"clamp\",\"approxEqual\",\"arrayLengthCompare\",\"isNodeEnv\",\"errors_1\",\"env\",\"NODE_ENV\",\"a\",\"b\",\"length\",\"tolerance\",\"Math\",\"abs\",\"val\",\"min\",\"max\",\"Error\",\"CLAMP_MIN_MAX\",\"num\",\"isFinite\",\"e\",\"p\",\"round\",\"uniqueCountForNamespace\",\"Map\",\"namespace\",\"_a\",\"curCount\",\"get\",\"set\"]\n}\n"]