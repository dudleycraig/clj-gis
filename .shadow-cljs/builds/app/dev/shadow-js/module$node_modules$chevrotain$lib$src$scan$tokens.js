["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/scan/tokens.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$scan$tokens=function(global,require,module,exports){function expandCategories(tokenTypes){for(var result=utils_1.cloneArr(tokenTypes),searching=!0;searching;){tokenTypes=utils_1.compact(utils_1.flatten(utils_1.map(tokenTypes,function(currTokType){return currTokType.CATEGORIES})));var newCategories=utils_1.difference(tokenTypes,result);result=result.concat(newCategories);utils_1.isEmpty(newCategories)?searching=!1:tokenTypes=newCategories}return result}\nfunction assignTokenDefaultProps(tokenTypes){utils_1.forEach(tokenTypes,function(currTokType){hasShortKeyProperty(currTokType)||(exports.tokenIdxToClass[exports.tokenShortNameIdx]=currTokType,currTokType.tokenTypeIdx=exports.tokenShortNameIdx++);hasCategoriesProperty(currTokType)&&!utils_1.isArray(currTokType.CATEGORIES)&&(currTokType.CATEGORIES=[currTokType.CATEGORIES]);hasCategoriesProperty(currTokType)||(currTokType.CATEGORIES=[]);hasExtendingTokensTypesProperty(currTokType)||(currTokType.categoryMatches=\n[]);hasExtendingTokensTypesMapProperty(currTokType)||(currTokType.categoryMatchesMap={})})}function assignCategoriesTokensProp(tokenTypes){utils_1.forEach(tokenTypes,function(currTokType){currTokType.categoryMatches=[];utils_1.forEach(currTokType.categoryMatchesMap,function(val,key){currTokType.categoryMatches.push(exports.tokenIdxToClass[key].tokenTypeIdx)})})}function assignCategoriesMapProp(tokenTypes){utils_1.forEach(tokenTypes,function(currTokType){singleAssignCategoriesToksMap([],currTokType)})}\nfunction singleAssignCategoriesToksMap(path,nextNode){utils_1.forEach(path,function(pathNode){nextNode.categoryMatchesMap[pathNode.tokenTypeIdx]=!0});utils_1.forEach(nextNode.CATEGORIES,function(nextCategory){var newPath=path.concat(nextNode);utils_1.contains(newPath,nextCategory)||singleAssignCategoriesToksMap(newPath,nextCategory)})}function hasShortKeyProperty(tokType){return utils_1.has(tokType,\"tokenTypeIdx\")}function hasCategoriesProperty(tokType){return utils_1.has(tokType,\"CATEGORIES\")}function hasExtendingTokensTypesProperty(tokType){return utils_1.has(tokType,\n\"categoryMatches\")}function hasExtendingTokensTypesMapProperty(tokType){return utils_1.has(tokType,\"categoryMatchesMap\")}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.isTokenType=exports.hasExtendingTokensTypesMapProperty=exports.hasExtendingTokensTypesProperty=exports.hasCategoriesProperty=exports.hasShortKeyProperty=exports.singleAssignCategoriesToksMap=exports.assignCategoriesMapProp=exports.assignCategoriesTokensProp=exports.assignTokenDefaultProps=exports.expandCategories=exports.augmentTokenTypes=\nexports.tokenIdxToClass=exports.tokenShortNameIdx=exports.tokenStructuredMatcherNoCategories=exports.tokenStructuredMatcher=void 0;var utils_1=require(\"module$node_modules$$chevrotain$utils$lib$src$api\");exports.tokenStructuredMatcher=function(tokInstance,tokConstructor){tokInstance=tokInstance.tokenTypeIdx;return tokInstance===tokConstructor.tokenTypeIdx?!0:!0===tokConstructor.isParent&&!0===tokConstructor.categoryMatchesMap[tokInstance]};exports.tokenStructuredMatcherNoCategories=function(token,\ntokType){return token.tokenTypeIdx===tokType.tokenTypeIdx};exports.tokenShortNameIdx=1;exports.tokenIdxToClass={};exports.augmentTokenTypes=function(tokenTypes){tokenTypes=expandCategories(tokenTypes);assignTokenDefaultProps(tokenTypes);assignCategoriesMapProp(tokenTypes);assignCategoriesTokensProp(tokenTypes);utils_1.forEach(tokenTypes,function(tokType){tokType.isParent=0<tokType.categoryMatches.length})};exports.expandCategories=expandCategories;exports.assignTokenDefaultProps=assignTokenDefaultProps;\nexports.assignCategoriesTokensProp=assignCategoriesTokensProp;exports.assignCategoriesMapProp=assignCategoriesMapProp;exports.singleAssignCategoriesToksMap=singleAssignCategoriesToksMap;exports.hasShortKeyProperty=hasShortKeyProperty;exports.hasCategoriesProperty=hasCategoriesProperty;exports.hasExtendingTokensTypesProperty=hasExtendingTokensTypesProperty;exports.hasExtendingTokensTypesMapProperty=hasExtendingTokensTypesMapProperty;exports.isTokenType=function(tokType){return utils_1.has(tokType,\n\"tokenTypeIdx\")}}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$scan$tokens\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isTokenType = exports.hasExtendingTokensTypesMapProperty = exports.hasExtendingTokensTypesProperty = exports.hasCategoriesProperty = exports.hasShortKeyProperty = exports.singleAssignCategoriesToksMap = exports.assignCategoriesMapProp = exports.assignCategoriesTokensProp = exports.assignTokenDefaultProps = exports.expandCategories = exports.augmentTokenTypes = exports.tokenIdxToClass = exports.tokenShortNameIdx = exports.tokenStructuredMatcherNoCategories = exports.tokenStructuredMatcher = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n    var instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\nexports.tokenStructuredMatcher = tokenStructuredMatcher;\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexports.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;\nexports.tokenShortNameIdx = 1;\nexports.tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    var tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    utils_1.forEach(tokenTypesAndParents, function (tokType) {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nexports.augmentTokenTypes = augmentTokenTypes;\nfunction expandCategories(tokenTypes) {\n    var result = utils_1.cloneArr(tokenTypes);\n    var categories = tokenTypes;\n    var searching = true;\n    while (searching) {\n        categories = utils_1.compact(utils_1.flatten(utils_1.map(categories, function (currTokType) { return currTokType.CATEGORIES; })));\n        var newCategories = utils_1.difference(categories, result);\n        result = result.concat(newCategories);\n        if (utils_1.isEmpty(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nexports.expandCategories = expandCategories;\nfunction assignTokenDefaultProps(tokenTypes) {\n    utils_1.forEach(tokenTypes, function (currTokType) {\n        if (!hasShortKeyProperty(currTokType)) {\n            exports.tokenIdxToClass[exports.tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = exports.tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !utils_1.isArray(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nexports.assignTokenDefaultProps = assignTokenDefaultProps;\nfunction assignCategoriesTokensProp(tokenTypes) {\n    utils_1.forEach(tokenTypes, function (currTokType) {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        utils_1.forEach(currTokType.categoryMatchesMap, function (val, key) {\n            currTokType.categoryMatches.push(exports.tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nexports.assignCategoriesTokensProp = assignCategoriesTokensProp;\nfunction assignCategoriesMapProp(tokenTypes) {\n    utils_1.forEach(tokenTypes, function (currTokType) {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nexports.assignCategoriesMapProp = assignCategoriesMapProp;\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n    utils_1.forEach(path, function (pathNode) {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    utils_1.forEach(nextNode.CATEGORIES, function (nextCategory) {\n        var newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!utils_1.contains(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nexports.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;\nfunction hasShortKeyProperty(tokType) {\n    return utils_1.has(tokType, \"tokenTypeIdx\");\n}\nexports.hasShortKeyProperty = hasShortKeyProperty;\nfunction hasCategoriesProperty(tokType) {\n    return utils_1.has(tokType, \"CATEGORIES\");\n}\nexports.hasCategoriesProperty = hasCategoriesProperty;\nfunction hasExtendingTokensTypesProperty(tokType) {\n    return utils_1.has(tokType, \"categoryMatches\");\n}\nexports.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n    return utils_1.has(tokType, \"categoryMatchesMap\");\n}\nexports.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;\nfunction isTokenType(tokType) {\n    return utils_1.has(tokType, \"tokenTypeIdx\");\n}\nexports.isTokenType = isTokenType;\n//# sourceMappingURL=tokens.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$chevrotain$utils$lib$src$api","~$shadow.js"]],"~:properties",["^5",["expandCategories","tokenStructuredMatcherNoCategories","tokenIdxToClass","tokenShortNameIdx","assignTokenDefaultProps","isTokenType","__esModule","CATEGORIES","hasExtendingTokensTypesProperty","assignCategoriesTokensProp","hasCategoriesProperty","isParent","augmentTokenTypes","value","tokenTypeIdx","singleAssignCategoriesToksMap","categoryMatches","categoryMatchesMap","assignCategoriesMapProp","tokenStructuredMatcher","hasShortKeyProperty","hasExtendingTokensTypesMapProperty"]],"~:compiled-at",1630917515674,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$scan$tokens.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/chevrotain/lib/src/scan/tokens.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$scan$tokens\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.isTokenType = exports.hasExtendingTokensTypesMapProperty = exports.hasExtendingTokensTypesProperty = exports.hasCategoriesProperty = exports.hasShortKeyProperty = exports.singleAssignCategoriesToksMap = exports.assignCategoriesMapProp = exports.assignCategoriesTokensProp = exports.assignTokenDefaultProps = exports.expandCategories = exports.augmentTokenTypes = exports.tokenIdxToClass = exports.tokenShortNameIdx = exports.tokenStructuredMatcherNoCategories = exports.tokenStructuredMatcher = void 0;\\nvar utils_1 = require(\\\"@chevrotain/utils\\\");\\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\\n    var instanceType = tokInstance.tokenTypeIdx;\\n    if (instanceType === tokConstructor.tokenTypeIdx) {\\n        return true;\\n    }\\n    else {\\n        return (tokConstructor.isParent === true &&\\n            tokConstructor.categoryMatchesMap[instanceType] === true);\\n    }\\n}\\nexports.tokenStructuredMatcher = tokenStructuredMatcher;\\n// Optimized tokenMatcher in case our grammar does not use token categories\\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\\n}\\nexports.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;\\nexports.tokenShortNameIdx = 1;\\nexports.tokenIdxToClass = {};\\nfunction augmentTokenTypes(tokenTypes) {\\n    // collect the parent Token Types as well.\\n    var tokenTypesAndParents = expandCategories(tokenTypes);\\n    // add required tokenType and categoryMatches properties\\n    assignTokenDefaultProps(tokenTypesAndParents);\\n    // fill up the categoryMatches\\n    assignCategoriesMapProp(tokenTypesAndParents);\\n    assignCategoriesTokensProp(tokenTypesAndParents);\\n    utils_1.forEach(tokenTypesAndParents, function (tokType) {\\n        tokType.isParent = tokType.categoryMatches.length > 0;\\n    });\\n}\\nexports.augmentTokenTypes = augmentTokenTypes;\\nfunction expandCategories(tokenTypes) {\\n    var result = utils_1.cloneArr(tokenTypes);\\n    var categories = tokenTypes;\\n    var searching = true;\\n    while (searching) {\\n        categories = utils_1.compact(utils_1.flatten(utils_1.map(categories, function (currTokType) { return currTokType.CATEGORIES; })));\\n        var newCategories = utils_1.difference(categories, result);\\n        result = result.concat(newCategories);\\n        if (utils_1.isEmpty(newCategories)) {\\n            searching = false;\\n        }\\n        else {\\n            categories = newCategories;\\n        }\\n    }\\n    return result;\\n}\\nexports.expandCategories = expandCategories;\\nfunction assignTokenDefaultProps(tokenTypes) {\\n    utils_1.forEach(tokenTypes, function (currTokType) {\\n        if (!hasShortKeyProperty(currTokType)) {\\n            exports.tokenIdxToClass[exports.tokenShortNameIdx] = currTokType;\\n            currTokType.tokenTypeIdx = exports.tokenShortNameIdx++;\\n        }\\n        // CATEGORIES? : TokenType | TokenType[]\\n        if (hasCategoriesProperty(currTokType) &&\\n            !utils_1.isArray(currTokType.CATEGORIES)\\n        // &&\\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\\n        ) {\\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\\n        }\\n        if (!hasCategoriesProperty(currTokType)) {\\n            currTokType.CATEGORIES = [];\\n        }\\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\\n            currTokType.categoryMatches = [];\\n        }\\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\\n            currTokType.categoryMatchesMap = {};\\n        }\\n    });\\n}\\nexports.assignTokenDefaultProps = assignTokenDefaultProps;\\nfunction assignCategoriesTokensProp(tokenTypes) {\\n    utils_1.forEach(tokenTypes, function (currTokType) {\\n        // avoid duplications\\n        currTokType.categoryMatches = [];\\n        utils_1.forEach(currTokType.categoryMatchesMap, function (val, key) {\\n            currTokType.categoryMatches.push(exports.tokenIdxToClass[key].tokenTypeIdx);\\n        });\\n    });\\n}\\nexports.assignCategoriesTokensProp = assignCategoriesTokensProp;\\nfunction assignCategoriesMapProp(tokenTypes) {\\n    utils_1.forEach(tokenTypes, function (currTokType) {\\n        singleAssignCategoriesToksMap([], currTokType);\\n    });\\n}\\nexports.assignCategoriesMapProp = assignCategoriesMapProp;\\nfunction singleAssignCategoriesToksMap(path, nextNode) {\\n    utils_1.forEach(path, function (pathNode) {\\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\\n    });\\n    utils_1.forEach(nextNode.CATEGORIES, function (nextCategory) {\\n        var newPath = path.concat(nextNode);\\n        // avoids infinite loops due to cyclic categories.\\n        if (!utils_1.contains(newPath, nextCategory)) {\\n            singleAssignCategoriesToksMap(newPath, nextCategory);\\n        }\\n    });\\n}\\nexports.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;\\nfunction hasShortKeyProperty(tokType) {\\n    return utils_1.has(tokType, \\\"tokenTypeIdx\\\");\\n}\\nexports.hasShortKeyProperty = hasShortKeyProperty;\\nfunction hasCategoriesProperty(tokType) {\\n    return utils_1.has(tokType, \\\"CATEGORIES\\\");\\n}\\nexports.hasCategoriesProperty = hasCategoriesProperty;\\nfunction hasExtendingTokensTypesProperty(tokType) {\\n    return utils_1.has(tokType, \\\"categoryMatches\\\");\\n}\\nexports.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;\\nfunction hasExtendingTokensTypesMapProperty(tokType) {\\n    return utils_1.has(tokType, \\\"categoryMatchesMap\\\");\\n}\\nexports.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;\\nfunction isTokenType(tokType) {\\n    return utils_1.has(tokType, \\\"tokenTypeIdx\\\");\\n}\\nexports.isTokenType = isTokenType;\\n//# sourceMappingURL=tokens.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"expandCategories\",\"tokenTypes\",\"result\",\"utils_1\",\"cloneArr\",\"searching\",\"categories\",\"compact\",\"flatten\",\"map\",\"currTokType\",\"CATEGORIES\",\"newCategories\",\"difference\",\"concat\",\"isEmpty\",\"assignTokenDefaultProps\",\"forEach\",\"hasShortKeyProperty\",\"tokenIdxToClass\",\"tokenShortNameIdx\",\"tokenTypeIdx\",\"hasCategoriesProperty\",\"isArray\",\"hasExtendingTokensTypesProperty\",\"categoryMatches\",\"hasExtendingTokensTypesMapProperty\",\"categoryMatchesMap\",\"assignCategoriesTokensProp\",\"val\",\"key\",\"push\",\"assignCategoriesMapProp\",\"singleAssignCategoriesToksMap\",\"path\",\"nextNode\",\"pathNode\",\"nextCategory\",\"newPath\",\"contains\",\"tokType\",\"has\",\"Object\",\"defineProperty\",\"value\",\"isTokenType\",\"augmentTokenTypes\",\"tokenStructuredMatcherNoCategories\",\"tokenStructuredMatcher\",\"tokInstance\",\"tokConstructor\",\"instanceType\",\"isParent\",\"token\",\"tokenTypesAndParents\",\"length\"]\n}\n"]