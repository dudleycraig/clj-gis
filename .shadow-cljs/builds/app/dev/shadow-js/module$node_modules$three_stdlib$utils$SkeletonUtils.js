["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/utils/SkeletonUtils.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$utils$SkeletonUtils=function(global,require,module,exports){function parallelTraverse(a,b,callback){callback(a,b);for(var i=0;i<a.children.length;i++)parallelTraverse(a.children[i],b.children[i],callback)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.SkeletonUtils=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global={retarget:function(){var pos=new _three.Vector3,quat=new _three.Quaternion,scale=new _three.Vector3,\nbindBoneMatrix=new _three.Matrix4,relativeMatrix=new _three.Matrix4,globalMatrix=new _three.Matrix4;return function(target,source,options){options=options||{};options.preserveMatrix=void 0!==options.preserveMatrix?options.preserveMatrix:!0;options.preservePosition=void 0!==options.preservePosition?options.preservePosition:!0;options.preserveHipPosition=void 0!==options.preserveHipPosition?options.preserveHipPosition:!1;options.useTargetMatrix=void 0!==options.useTargetMatrix?options.useTargetMatrix:\n!1;options.hip=void 0!==options.hip?options.hip:\"hip\";options.names=options.names||{};source=source.isObject3D?source.skeleton.bones:this.getBones(source);var bones=target.isObject3D?target.skeleton.bones:this.getBones(target),i;target.isObject3D?target.skeleton.pose():(options.useTargetMatrix=!0,options.preserveMatrix=!1);if(options.preservePosition){var bonesPosition=[];for(i=0;i<bones.length;i++)bonesPosition.push(bones[i].position.clone())}if(options.preserveMatrix)for(target.updateMatrixWorld(),\ntarget.matrixWorld.identity(),i=0;i<target.children.length;++i)target.children[i].updateMatrixWorld(!0);if(options.offsets){var bindBones=[];for(i=0;i<bones.length;++i){var bone=bones[i];var name=options.names[bone.name]||bone.name;options.offsets&&options.offsets[name]&&(bone.matrix.multiply(options.offsets[name]),bone.matrix.decompose(bone.position,bone.quaternion,bone.scale),bone.updateMatrixWorld());bindBones.push(bone.matrixWorld.clone())}}for(i=0;i<bones.length;++i){bone=bones[i];name=options.names[bone.name]||\nbone.name;var boneTo=this.getBoneByName(name,source);globalMatrix.copy(bone.matrixWorld);boneTo&&(boneTo.updateMatrixWorld(),options.useTargetMatrix?relativeMatrix.copy(boneTo.matrixWorld):(relativeMatrix.copy(target.matrixWorld).invert(),relativeMatrix.multiply(boneTo.matrixWorld)),scale.setFromMatrixScale(relativeMatrix),relativeMatrix.scale(scale.set(1/scale.x,1/scale.y,1/scale.z)),globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix)),target.isObject3D&&(boneTo=bones.indexOf(bone),\nboneTo=bindBones?bindBones[boneTo]:bindBoneMatrix.copy(target.skeleton.boneInverses[boneTo]).invert(),globalMatrix.multiply(boneTo)),globalMatrix.copyPosition(relativeMatrix));bone.parent&&bone.parent.isBone?(bone.matrix.copy(bone.parent.matrixWorld).invert(),bone.matrix.multiply(globalMatrix)):bone.matrix.copy(globalMatrix);options.preserveHipPosition&&name===options.hip&&bone.matrix.setPosition(pos.set(0,bone.position.y,0));bone.matrix.decompose(bone.position,bone.quaternion,bone.scale);bone.updateMatrixWorld()}if(options.preservePosition)for(i=\n0;i<bones.length;++i)bone=bones[i],name=options.names[bone.name]||bone.name,name!==options.hip&&bone.position.copy(bonesPosition[i]);options.preserveMatrix&&target.updateMatrixWorld(!0)}}(),retargetClip:function(target,source,clip,options){options=options||{};options.useFirstFramePosition=void 0!==options.useFirstFramePosition?options.useFirstFramePosition:!1;options.fps=void 0!==options.fps?options.fps:30;options.names=options.names||[];source.isObject3D||(source=this.getHelperFromSkeleton(source));\nvar numFrames=Math.round(options.fps/1E3*clip.duration*1E3),delta=1/options.fps,convertedTracks=[],mixer=new _three.AnimationMixer(source),bones=this.getBones(target.skeleton),boneDatas=[],positionOffset,bone,i,j;mixer.clipAction(clip).play();mixer.update(0);source.updateMatrixWorld();for(i=0;i<numFrames;++i){var time=i*delta;this.retarget(target,source,options);for(j=0;j<bones.length;++j){var name=options.names[bones[j].name]||bones[j].name;if(bone=this.getBoneByName(name,source.skeleton)){bone=\nbones[j];var boneData=boneDatas[j]=boneDatas[j]||{bone};options.hip===name&&(boneData.pos||(boneData.pos={times:new Float32Array(numFrames),values:new Float32Array(3*numFrames)}),options.useFirstFramePosition&&(0===i&&(positionOffset=bone.position.clone()),bone.position.sub(positionOffset)),boneData.pos.times[i]=time,bone.position.toArray(boneData.pos.values,3*i));boneData.quat||(boneData.quat={times:new Float32Array(numFrames),values:new Float32Array(4*numFrames)});boneData.quat.times[i]=time;bone.quaternion.toArray(boneData.quat.values,\n4*i)}}mixer.update(delta);source.updateMatrixWorld()}for(i=0;i<boneDatas.length;++i)if(boneData=boneDatas[i])boneData.pos&&convertedTracks.push(new _three.VectorKeyframeTrack(\".bones[\"+boneData.bone.name+\"].position\",boneData.pos.times,boneData.pos.values)),convertedTracks.push(new _three.QuaternionKeyframeTrack(\".bones[\"+boneData.bone.name+\"].quaternion\",boneData.quat.times,boneData.quat.values));mixer.uncacheAction(clip);return new _three.AnimationClip(clip.name,-1,convertedTracks)},getHelperFromSkeleton:function(skeleton){var source=\nnew _three.SkeletonHelper(skeleton.bones[0]);source.skeleton=skeleton;return source},getSkeletonOffsets:function(){var targetParentPos=new _three.Vector3,targetPos=new _three.Vector3,sourceParentPos=new _three.Vector3,sourcePos=new _three.Vector3,targetDir=new _three.Vector2,sourceDir=new _three.Vector2;return function(target,source,options){options=options||{};options.hip=void 0!==options.hip?options.hip:\"hip\";options.names=options.names||{};source.isObject3D||(source=this.getHelperFromSkeleton(source));\nvar nameKeys=Object.keys(options.names),nameValues=Object.values(options.names);source=source.isObject3D?source.skeleton.bones:this.getBones(source);var bones=target.isObject3D?target.skeleton.bones:this.getBones(target),offsets=[],boneTo,i;target.skeleton.pose();for(i=0;i<bones.length;++i){target=bones[i];var name=options.names[target.name]||target.name;if((boneTo=this.getBoneByName(name,source))&&name!==options.hip){var boneParent=this.getNearestBone(target.parent,nameKeys),boneToParent=this.getNearestBone(boneTo.parent,\nnameValues);boneParent.updateMatrixWorld();boneToParent.updateMatrixWorld();targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);targetPos.setFromMatrixPosition(target.matrixWorld);sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);sourcePos.setFromMatrixPosition(boneTo.matrixWorld);targetDir.subVectors(new _three.Vector2(targetPos.x,targetPos.y),new _three.Vector2(targetParentPos.x,targetParentPos.y)).normalize();sourceDir.subVectors(new _three.Vector2(sourcePos.x,sourcePos.y),\nnew _three.Vector2(sourceParentPos.x,sourceParentPos.y)).normalize();boneTo=targetDir.angle()-sourceDir.angle();boneTo=(new _three.Matrix4).makeRotationFromEuler(new _three.Euler(0,0,boneTo));target.matrix.multiply(boneTo);target.matrix.decompose(target.position,target.quaternion,target.scale);target.updateMatrixWorld();offsets[name]=boneTo}}return offsets}}(),renameBones:function(skeleton,names){skeleton=this.getBones(skeleton);for(var i=0;i<skeleton.length;++i){var bone=skeleton[i];names[bone.name]&&\n(bone.name=names[bone.name])}return this},getBones:function(skeleton){return Array.isArray(skeleton)?skeleton:skeleton.bones},getBoneByName:function(name,skeleton){var i=0;for(skeleton=this.getBones(skeleton);i<skeleton.length;i++)if(name===skeleton[i].name)return skeleton[i]},getNearestBone:function(bone,names){for(;bone.isBone;){if(-1!==names.indexOf(bone.name))return bone;bone=bone.parent}},findBoneTrackData:function(name,tracks){for(var regexp=/\\[(.*)\\]\\.(.*)/,result={name},i=0;i<tracks.length;++i){var trackData=\nregexp.exec(tracks[i].name);trackData&&name===trackData[1]&&(result[trackData[2]]=i)}return result},getEqualsBonesNames:function(skeleton,targetSkeleton){skeleton=this.getBones(skeleton);targetSkeleton=this.getBones(targetSkeleton);var bones=[],i=0;a:for(;i<skeleton.length;i++)for(var boneName=skeleton[i].name,j=0;j<targetSkeleton.length;j++)if(boneName===targetSkeleton[j].name){bones.push(boneName);continue a}return bones},clone:function(source){var sourceLookup=new Map,cloneLookup=new Map,clone=\nsource.clone();parallelTraverse(source,clone,function(sourceNode,clonedNode){sourceLookup.set(clonedNode,sourceNode);cloneLookup.set(sourceNode,clonedNode)});clone.traverse(function(node){if(node.isSkinnedMesh){var sourceMesh=sourceLookup.get(node),sourceBones=sourceMesh.skeleton.bones;node.skeleton=sourceMesh.skeleton.clone();node.bindMatrix.copy(sourceMesh.bindMatrix);node.skeleton.bones=sourceBones.map(function(bone){return cloneLookup.get(bone)});node.bind(node.skeleton,node.bindMatrix)}});return clone}};\nexports.SkeletonUtils=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$utils$SkeletonUtils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SkeletonUtils = void 0;\n\nvar _three = require(\"three\");\n\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new _three.Vector3(),\n        quat = new _three.Quaternion(),\n        scale = new _three.Vector3(),\n        bindBoneMatrix = new _three.Matrix4(),\n        relativeMatrix = new _three.Matrix4(),\n        globalMatrix = new _three.Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function retargetClip(target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new _three.AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new _three.VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new _three.QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new _three.AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function getHelperFromSkeleton(skeleton) {\n    var source = new _three.SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new _three.Vector3(),\n        targetPos = new _three.Vector3(),\n        sourceParentPos = new _three.Vector3(),\n        sourcePos = new _three.Vector3(),\n        targetDir = new _three.Vector2(),\n        sourceDir = new _three.Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new _three.Vector2(targetPos.x, targetPos.y), new _three.Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new _three.Vector2(sourcePos.x, sourcePos.y), new _three.Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new _three.Matrix4().makeRotationFromEuler(new _three.Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function renameBones(skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (var i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function getBones(skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function getBoneByName(name, skeleton) {\n    for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function getNearestBone(bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function findBoneTrackData(name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (var i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function getEqualsBonesNames(skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (var i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (var j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function clone(source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\nexports.SkeletonUtils = SkeletonUtils;\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (var i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["preserveMatrix","values","pos","bone","getEqualsBonesNames","retargetClip","skeleton","__esModule","preservePosition","hip","findBoneTrackData","getNearestBone","times","name","value","getBones","useFirstFramePosition","bones","names","useTargetMatrix","retarget","clone","SkeletonUtils","fps","getBoneByName","quat","preserveHipPosition","getSkeletonOffsets","renameBones","getHelperFromSkeleton"]],"~:compiled-at",1630917515400,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$utils$SkeletonUtils.js\",\n\"lineCount\":18,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/utils/SkeletonUtils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$utils$SkeletonUtils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.SkeletonUtils = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar SkeletonUtils = {\\n  retarget: function () {\\n    var pos = new _three.Vector3(),\\n        quat = new _three.Quaternion(),\\n        scale = new _three.Vector3(),\\n        bindBoneMatrix = new _three.Matrix4(),\\n        relativeMatrix = new _three.Matrix4(),\\n        globalMatrix = new _three.Matrix4();\\n    return function (target, source, options) {\\n      options = options || {};\\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\\n      options.names = options.names || {};\\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\\n          bindBones,\\n          bone,\\n          name,\\n          boneTo,\\n          bonesPosition,\\n          i; // reset bones\\n\\n      if (target.isObject3D) {\\n        target.skeleton.pose();\\n      } else {\\n        options.useTargetMatrix = true;\\n        options.preserveMatrix = false;\\n      }\\n\\n      if (options.preservePosition) {\\n        bonesPosition = [];\\n\\n        for (i = 0; i < bones.length; i++) {\\n          bonesPosition.push(bones[i].position.clone());\\n        }\\n      }\\n\\n      if (options.preserveMatrix) {\\n        // reset matrix\\n        target.updateMatrixWorld();\\n        target.matrixWorld.identity(); // reset children matrix\\n\\n        for (i = 0; i < target.children.length; ++i) {\\n          target.children[i].updateMatrixWorld(true);\\n        }\\n      }\\n\\n      if (options.offsets) {\\n        bindBones = [];\\n\\n        for (i = 0; i < bones.length; ++i) {\\n          bone = bones[i];\\n          name = options.names[bone.name] || bone.name;\\n\\n          if (options.offsets && options.offsets[name]) {\\n            bone.matrix.multiply(options.offsets[name]);\\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\\n            bone.updateMatrixWorld();\\n          }\\n\\n          bindBones.push(bone.matrixWorld.clone());\\n        }\\n      }\\n\\n      for (i = 0; i < bones.length; ++i) {\\n        bone = bones[i];\\n        name = options.names[bone.name] || bone.name;\\n        boneTo = this.getBoneByName(name, sourceBones);\\n        globalMatrix.copy(bone.matrixWorld);\\n\\n        if (boneTo) {\\n          boneTo.updateMatrixWorld();\\n\\n          if (options.useTargetMatrix) {\\n            relativeMatrix.copy(boneTo.matrixWorld);\\n          } else {\\n            relativeMatrix.copy(target.matrixWorld).invert();\\n            relativeMatrix.multiply(boneTo.matrixWorld);\\n          } // ignore scale to extract rotation\\n\\n\\n          scale.setFromMatrixScale(relativeMatrix);\\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\\n\\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\\n\\n          if (target.isObject3D) {\\n            var boneIndex = bones.indexOf(bone),\\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\\n            globalMatrix.multiply(wBindMatrix);\\n          }\\n\\n          globalMatrix.copyPosition(relativeMatrix);\\n        }\\n\\n        if (bone.parent && bone.parent.isBone) {\\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\\n          bone.matrix.multiply(globalMatrix);\\n        } else {\\n          bone.matrix.copy(globalMatrix);\\n        }\\n\\n        if (options.preserveHipPosition && name === options.hip) {\\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\\n        }\\n\\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\\n        bone.updateMatrixWorld();\\n      }\\n\\n      if (options.preservePosition) {\\n        for (i = 0; i < bones.length; ++i) {\\n          bone = bones[i];\\n          name = options.names[bone.name] || bone.name;\\n\\n          if (name !== options.hip) {\\n            bone.position.copy(bonesPosition[i]);\\n          }\\n        }\\n      }\\n\\n      if (options.preserveMatrix) {\\n        // restore matrix\\n        target.updateMatrixWorld(true);\\n      }\\n    };\\n  }(),\\n  retargetClip: function retargetClip(target, source, clip, options) {\\n    options = options || {};\\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\\n    options.fps = options.fps !== undefined ? options.fps : 30;\\n    options.names = options.names || [];\\n\\n    if (!source.isObject3D) {\\n      source = this.getHelperFromSkeleton(source);\\n    }\\n\\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\\n        delta = 1 / options.fps,\\n        convertedTracks = [],\\n        mixer = new _three.AnimationMixer(source),\\n        bones = this.getBones(target.skeleton),\\n        boneDatas = [],\\n        positionOffset,\\n        bone,\\n        boneTo,\\n        boneData,\\n        name,\\n        i,\\n        j;\\n    mixer.clipAction(clip).play();\\n    mixer.update(0);\\n    source.updateMatrixWorld();\\n\\n    for (i = 0; i < numFrames; ++i) {\\n      var time = i * delta;\\n      this.retarget(target, source, options);\\n\\n      for (j = 0; j < bones.length; ++j) {\\n        name = options.names[bones[j].name] || bones[j].name;\\n        boneTo = this.getBoneByName(name, source.skeleton);\\n\\n        if (boneTo) {\\n          bone = bones[j];\\n          boneData = boneDatas[j] = boneDatas[j] || {\\n            bone: bone\\n          };\\n\\n          if (options.hip === name) {\\n            if (!boneData.pos) {\\n              boneData.pos = {\\n                times: new Float32Array(numFrames),\\n                values: new Float32Array(numFrames * 3)\\n              };\\n            }\\n\\n            if (options.useFirstFramePosition) {\\n              if (i === 0) {\\n                positionOffset = bone.position.clone();\\n              }\\n\\n              bone.position.sub(positionOffset);\\n            }\\n\\n            boneData.pos.times[i] = time;\\n            bone.position.toArray(boneData.pos.values, i * 3);\\n          }\\n\\n          if (!boneData.quat) {\\n            boneData.quat = {\\n              times: new Float32Array(numFrames),\\n              values: new Float32Array(numFrames * 4)\\n            };\\n          }\\n\\n          boneData.quat.times[i] = time;\\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\\n        }\\n      }\\n\\n      mixer.update(delta);\\n      source.updateMatrixWorld();\\n    }\\n\\n    for (i = 0; i < boneDatas.length; ++i) {\\n      boneData = boneDatas[i];\\n\\n      if (boneData) {\\n        if (boneData.pos) {\\n          convertedTracks.push(new _three.VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\\n        }\\n\\n        convertedTracks.push(new _three.QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\\n      }\\n    }\\n\\n    mixer.uncacheAction(clip);\\n    return new _three.AnimationClip(clip.name, -1, convertedTracks);\\n  },\\n  getHelperFromSkeleton: function getHelperFromSkeleton(skeleton) {\\n    var source = new _three.SkeletonHelper(skeleton.bones[0]);\\n    source.skeleton = skeleton;\\n    return source;\\n  },\\n  getSkeletonOffsets: function () {\\n    var targetParentPos = new _three.Vector3(),\\n        targetPos = new _three.Vector3(),\\n        sourceParentPos = new _three.Vector3(),\\n        sourcePos = new _three.Vector3(),\\n        targetDir = new _three.Vector2(),\\n        sourceDir = new _three.Vector2();\\n    return function (target, source, options) {\\n      options = options || {};\\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\\n      options.names = options.names || {};\\n\\n      if (!source.isObject3D) {\\n        source = this.getHelperFromSkeleton(source);\\n      }\\n\\n      var nameKeys = Object.keys(options.names),\\n          nameValues = Object.values(options.names),\\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\\n          offsets = [],\\n          bone,\\n          boneTo,\\n          name,\\n          i;\\n      target.skeleton.pose();\\n\\n      for (i = 0; i < bones.length; ++i) {\\n        bone = bones[i];\\n        name = options.names[bone.name] || bone.name;\\n        boneTo = this.getBoneByName(name, sourceBones);\\n\\n        if (boneTo && name !== options.hip) {\\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\\n          boneParent.updateMatrixWorld();\\n          boneToParent.updateMatrixWorld();\\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\\n          targetDir.subVectors(new _three.Vector2(targetPos.x, targetPos.y), new _three.Vector2(targetParentPos.x, targetParentPos.y)).normalize();\\n          sourceDir.subVectors(new _three.Vector2(sourcePos.x, sourcePos.y), new _three.Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\\n          var offset = new _three.Matrix4().makeRotationFromEuler(new _three.Euler(0, 0, laterialAngle));\\n          bone.matrix.multiply(offset);\\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\\n          bone.updateMatrixWorld();\\n          offsets[name] = offset;\\n        }\\n      }\\n\\n      return offsets;\\n    };\\n  }(),\\n  renameBones: function renameBones(skeleton, names) {\\n    var bones = this.getBones(skeleton);\\n\\n    for (var i = 0; i < bones.length; ++i) {\\n      var bone = bones[i];\\n\\n      if (names[bone.name]) {\\n        bone.name = names[bone.name];\\n      }\\n    }\\n\\n    return this;\\n  },\\n  getBones: function getBones(skeleton) {\\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\\n  },\\n  getBoneByName: function getBoneByName(name, skeleton) {\\n    for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\\n      if (name === bones[i].name) return bones[i];\\n    }\\n  },\\n  getNearestBone: function getNearestBone(bone, names) {\\n    while (bone.isBone) {\\n      if (names.indexOf(bone.name) !== -1) {\\n        return bone;\\n      }\\n\\n      bone = bone.parent;\\n    }\\n  },\\n  findBoneTrackData: function findBoneTrackData(name, tracks) {\\n    var regexp = /\\\\[(.*)\\\\]\\\\.(.*)/,\\n        result = {\\n      name: name\\n    };\\n\\n    for (var i = 0; i < tracks.length; ++i) {\\n      // 1 is track name\\n      // 2 is track type\\n      var trackData = regexp.exec(tracks[i].name);\\n\\n      if (trackData && name === trackData[1]) {\\n        result[trackData[2]] = i;\\n      }\\n    }\\n\\n    return result;\\n  },\\n  getEqualsBonesNames: function getEqualsBonesNames(skeleton, targetSkeleton) {\\n    var sourceBones = this.getBones(skeleton),\\n        targetBones = this.getBones(targetSkeleton),\\n        bones = [];\\n\\n    search: for (var i = 0; i < sourceBones.length; i++) {\\n      var boneName = sourceBones[i].name;\\n\\n      for (var j = 0; j < targetBones.length; j++) {\\n        if (boneName === targetBones[j].name) {\\n          bones.push(boneName);\\n          continue search;\\n        }\\n      }\\n    }\\n\\n    return bones;\\n  },\\n  clone: function clone(source) {\\n    var sourceLookup = new Map();\\n    var cloneLookup = new Map();\\n    var clone = source.clone();\\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\\n      sourceLookup.set(clonedNode, sourceNode);\\n      cloneLookup.set(sourceNode, clonedNode);\\n    });\\n    clone.traverse(function (node) {\\n      if (!node.isSkinnedMesh) return;\\n      var clonedMesh = node;\\n      var sourceMesh = sourceLookup.get(node);\\n      var sourceBones = sourceMesh.skeleton.bones;\\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\\n        return cloneLookup.get(bone);\\n      });\\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\\n    });\\n    return clone;\\n  }\\n};\\nexports.SkeletonUtils = SkeletonUtils;\\n\\nfunction parallelTraverse(a, b, callback) {\\n  callback(a, b);\\n\\n  for (var i = 0; i < a.children.length; i++) {\\n    parallelTraverse(a.children[i], b.children[i], callback);\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"parallelTraverse\",\"a\",\"b\",\"callback\",\"i\",\"children\",\"length\",\"Object\",\"defineProperty\",\"value\",\"SkeletonUtils\",\"_three\",\"retarget\",\"pos\",\"Vector3\",\"quat\",\"Quaternion\",\"scale\",\"bindBoneMatrix\",\"Matrix4\",\"relativeMatrix\",\"globalMatrix\",\"target\",\"source\",\"options\",\"preserveMatrix\",\"undefined\",\"preservePosition\",\"preserveHipPosition\",\"useTargetMatrix\",\"hip\",\"names\",\"sourceBones\",\"isObject3D\",\"skeleton\",\"bones\",\"getBones\",\"pose\",\"bonesPosition\",\"push\",\"position\",\"clone\",\"updateMatrixWorld\",\"matrixWorld\",\"identity\",\"offsets\",\"bindBones\",\"bone\",\"name\",\"matrix\",\"multiply\",\"decompose\",\"quaternion\",\"boneTo\",\"getBoneByName\",\"copy\",\"invert\",\"setFromMatrixScale\",\"set\",\"x\",\"y\",\"z\",\"makeRotationFromQuaternion\",\"setFromRotationMatrix\",\"boneIndex\",\"indexOf\",\"wBindMatrix\",\"boneInverses\",\"copyPosition\",\"parent\",\"isBone\",\"setPosition\",\"retargetClip\",\"clip\",\"useFirstFramePosition\",\"fps\",\"getHelperFromSkeleton\",\"numFrames\",\"Math\",\"round\",\"duration\",\"delta\",\"convertedTracks\",\"mixer\",\"AnimationMixer\",\"boneDatas\",\"positionOffset\",\"j\",\"clipAction\",\"play\",\"update\",\"time\",\"boneData\",\"times\",\"Float32Array\",\"values\",\"sub\",\"toArray\",\"VectorKeyframeTrack\",\"QuaternionKeyframeTrack\",\"uncacheAction\",\"AnimationClip\",\"SkeletonHelper\",\"getSkeletonOffsets\",\"targetParentPos\",\"targetPos\",\"sourceParentPos\",\"sourcePos\",\"targetDir\",\"Vector2\",\"sourceDir\",\"nameKeys\",\"keys\",\"nameValues\",\"boneParent\",\"getNearestBone\",\"boneToParent\",\"setFromMatrixPosition\",\"subVectors\",\"normalize\",\"laterialAngle\",\"angle\",\"offset\",\"makeRotationFromEuler\",\"Euler\",\"renameBones\",\"Array\",\"isArray\",\"findBoneTrackData\",\"tracks\",\"regexp\",\"result\",\"trackData\",\"exec\",\"getEqualsBonesNames\",\"targetSkeleton\",\"targetBones\",\"boneName\",\"sourceLookup\",\"Map\",\"cloneLookup\",\"sourceNode\",\"clonedNode\",\"traverse\",\"node\",\"isSkinnedMesh\",\"sourceMesh\",\"get\",\"bindMatrix\",\"map\",\"bind\"]\n}\n"]