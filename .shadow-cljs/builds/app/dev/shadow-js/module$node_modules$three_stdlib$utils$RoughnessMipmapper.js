["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/utils/RoughnessMipmapper.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$utils$RoughnessMipmapper=function(global,require,module,exports){function RoughnessMipmapper(renderer){_renderer=renderer;_renderer.compile(_mesh,_flatCamera)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.RoughnessMipmapper=RoughnessMipmapper;var _three=require(\"module$node_modules$three$build$three_module\"),_mipmapMaterial=function(){var shaderMaterial=new _three.RawShaderMaterial({uniforms:{roughnessMap:{value:null},normalMap:{value:null},\ntexelSize:{value:new _three.Vector2(1,1)}},vertexShader:\"\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tattribute vec3 position;\\n\\t\\t\\tattribute vec2 uv;\\n\\n\\t\\t\\tvarying vec2 vUv;\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvUv \\x3d uv;\\n\\n\\t\\t\\t\\tgl_Position \\x3d vec4( position, 1.0 );\\n\\n\\t\\t\\t}\\n\\t\\t\",fragmentShader:\"\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec2 vUv;\\n\\n\\t\\t\\tuniform sampler2D roughnessMap;\\n\\t\\t\\tuniform sampler2D normalMap;\\n\\t\\t\\tuniform vec2 texelSize;\\n\\n\\t\\t\\t#define ENVMAP_TYPE_CUBE_UV\\n\\n\\t\\t\\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\\n\\n\\t\\t\\t#include \\x3ccube_uv_reflection_fragment\\x3e\\n\\n\\t\\t\\tfloat roughnessToVariance( float roughness ) {\\n\\n\\t\\t\\t\\tfloat variance \\x3d 0.0;\\n\\n\\t\\t\\t\\tif ( roughness \\x3e\\x3d r1 ) {\\n\\n\\t\\t\\t\\t\\tvariance \\x3d ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\\n\\n\\t\\t\\t\\t} else if ( roughness \\x3e\\x3d r4 ) {\\n\\n\\t\\t\\t\\t\\tvariance \\x3d ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\\n\\n\\t\\t\\t\\t} else if ( roughness \\x3e\\x3d r5 ) {\\n\\n\\t\\t\\t\\t\\tvariance \\x3d ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tfloat roughness2 \\x3d roughness * roughness;\\n\\n\\t\\t\\t\\t\\tvariance \\x3d 1.79 * roughness2 * roughness2;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn variance;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfloat varianceToRoughness( float variance ) {\\n\\n\\t\\t\\t\\tfloat roughness \\x3d 0.0;\\n\\n\\t\\t\\t\\tif ( variance \\x3e\\x3d v1 ) {\\n\\n\\t\\t\\t\\t\\troughness \\x3d ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\\n\\n\\t\\t\\t\\t} else if ( variance \\x3e\\x3d v4 ) {\\n\\n\\t\\t\\t\\t\\troughness \\x3d ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\\n\\n\\t\\t\\t\\t} else if ( variance \\x3e\\x3d v5 ) {\\n\\n\\t\\t\\t\\t\\troughness \\x3d ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\troughness \\x3d pow( 0.559 * variance, 0.25 ); // 0.559 \\x3d 1.0 / 1.79\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn roughness;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tgl_FragColor \\x3d texture2D( roughnessMap, vUv, - 1.0 );\\n\\n\\t\\t\\t\\tif ( texelSize.x \\x3d\\x3d 0.0 ) return;\\n\\n\\t\\t\\t\\tfloat roughness \\x3d gl_FragColor.g;\\n\\n\\t\\t\\t\\tfloat variance \\x3d roughnessToVariance( roughness );\\n\\n\\t\\t\\t\\tvec3 avgNormal;\\n\\n\\t\\t\\t\\tfor ( float x \\x3d - 1.0; x \\x3c 2.0; x +\\x3d 2.0 ) {\\n\\n\\t\\t\\t\\t\\tfor ( float y \\x3d - 1.0; y \\x3c 2.0; y +\\x3d 2.0 ) {\\n\\n\\t\\t\\t\\t\\t\\tvec2 uv \\x3d vUv + vec2( x, y ) * 0.25 * texelSize;\\n\\n\\t\\t\\t\\t\\t\\tavgNormal +\\x3d normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvariance +\\x3d 1.0 - 0.25 * length( avgNormal );\\n\\n\\t\\t\\t\\tgl_FragColor.g \\x3d varianceToRoughness( variance );\\n\\n\\t\\t\\t}\\n\\t\\t\",\nblending:_three.NoBlending,depthTest:!1,depthWrite:!1});shaderMaterial.type=\"RoughnessMipmapper\";return shaderMaterial}(),_mesh=new _three.Mesh(new _three.PlaneGeometry(2,2),_mipmapMaterial),_flatCamera=new _three.OrthographicCamera(0,1,0,1,0,1),_tempTarget=null,_renderer=null;RoughnessMipmapper.prototype={constructor:RoughnessMipmapper,generateMipmaps:function(material){if(!1!==\"roughnessMap\"in material){var roughnessMap=material.roughnessMap,normalMap=material.normalMap;if(null!==roughnessMap&&\nnull!==normalMap&&roughnessMap.generateMipmaps&&!material.userData.roughnessUpdated){material.userData.roughnessUpdated=!0;var width=Math.max(roughnessMap.image.width,normalMap.image.width),height=Math.max(roughnessMap.image.height,normalMap.image.height);if(_three.MathUtils.isPowerOfTwo(width)&&_three.MathUtils.isPowerOfTwo(height)){var oldTarget=_renderer.getRenderTarget(),autoClear=_renderer.autoClear;_renderer.autoClear=!1;if(null===_tempTarget||_tempTarget.width!==width||_tempTarget.height!==\nheight)null!==_tempTarget&&_tempTarget.dispose(),_tempTarget=new _three.WebGLRenderTarget(width,height,{depthBuffer:!1}),_tempTarget.scissorTest=!0;if(width!==roughnessMap.image.width||height!==roughnessMap.image.height){var newRoughnessTarget=new _three.WebGLRenderTarget(width,height,{wrapS:roughnessMap.wrapS,wrapT:roughnessMap.wrapT,magFilter:roughnessMap.magFilter,minFilter:roughnessMap.minFilter,depthBuffer:!1});newRoughnessTarget.texture.generateMipmaps=!0;_renderer.setRenderTarget(newRoughnessTarget);\nmaterial.roughnessMap=newRoughnessTarget.texture;material.metalnessMap==roughnessMap&&(material.metalnessMap=material.roughnessMap);material.aoMap==roughnessMap&&(material.aoMap=material.roughnessMap)}_mipmapMaterial.uniforms.roughnessMap.value=roughnessMap;_mipmapMaterial.uniforms.normalMap.value=normalMap;normalMap=new _three.Vector2(0,0);newRoughnessTarget=_mipmapMaterial.uniforms.texelSize.value;for(var mip=0;1<=width&&1<=height;++mip,width/=2,height/=2)newRoughnessTarget.set(1/width,1/height),\n0==mip&&newRoughnessTarget.set(0,0),_tempTarget.viewport.set(normalMap.x,normalMap.y,width,height),_tempTarget.scissor.set(normalMap.x,normalMap.y,width,height),_renderer.setRenderTarget(_tempTarget),_renderer.render(_mesh,_flatCamera),_renderer.copyFramebufferToTexture(normalMap,material.roughnessMap,mip),_mipmapMaterial.uniforms.roughnessMap.value=material.roughnessMap;roughnessMap!==material.roughnessMap&&roughnessMap.dispose();_renderer.setRenderTarget(oldTarget);_renderer.autoClear=autoClear}}}},\ndispose:function(){_mipmapMaterial.dispose();_mesh.geometry.dispose();null!=_tempTarget&&_tempTarget.dispose()}}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$utils$RoughnessMipmapper\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RoughnessMipmapper = RoughnessMipmapper;\n\nvar _three = require(\"three\");\n\n/**\n * This class generates custom mipmaps for a roughness map by encoding the lost variation in the\n * normal map mip levels as increased roughness in the corresponding roughness mip levels. This\n * helps with rendering accuracy for MeshStandardMaterial, and also helps with anti-aliasing when\n * using PMREM. If the normal map is larger than the roughness map, the roughness map will be\n * enlarged to match the dimensions of the normal map.\n */\nvar _mipmapMaterial = _getMipmapMaterial();\n\nvar _mesh = new _three.Mesh(new _three.PlaneGeometry(2, 2), _mipmapMaterial);\n\nvar _flatCamera = new _three.OrthographicCamera(0, 1, 0, 1, 0, 1);\n\nvar _tempTarget = null;\nvar _renderer = null;\n\nfunction RoughnessMipmapper(renderer) {\n  _renderer = renderer;\n\n  _renderer.compile(_mesh, _flatCamera);\n}\n\nRoughnessMipmapper.prototype = {\n  constructor: RoughnessMipmapper,\n  generateMipmaps: function generateMipmaps(material) {\n    if ('roughnessMap' in material === false) return;\n    var roughnessMap = material.roughnessMap,\n        normalMap = material.normalMap;\n    if (roughnessMap === null || normalMap === null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) return;\n    material.userData.roughnessUpdated = true;\n    var width = Math.max(roughnessMap.image.width, normalMap.image.width);\n    var height = Math.max(roughnessMap.image.height, normalMap.image.height);\n    if (!_three.MathUtils.isPowerOfTwo(width) || !_three.MathUtils.isPowerOfTwo(height)) return;\n\n    var oldTarget = _renderer.getRenderTarget();\n\n    var autoClear = _renderer.autoClear;\n    _renderer.autoClear = false;\n\n    if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {\n      if (_tempTarget !== null) _tempTarget.dispose();\n      _tempTarget = new _three.WebGLRenderTarget(width, height, {\n        depthBuffer: false\n      });\n      _tempTarget.scissorTest = true;\n    }\n\n    if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {\n      var params = {\n        wrapS: roughnessMap.wrapS,\n        wrapT: roughnessMap.wrapT,\n        magFilter: roughnessMap.magFilter,\n        minFilter: roughnessMap.minFilter,\n        depthBuffer: false\n      };\n      var newRoughnessTarget = new _three.WebGLRenderTarget(width, height, params);\n      newRoughnessTarget.texture.generateMipmaps = true; // Setting the render target causes the memory to be allocated.\n\n      _renderer.setRenderTarget(newRoughnessTarget);\n\n      material.roughnessMap = newRoughnessTarget.texture;\n      if (material.metalnessMap == roughnessMap) material.metalnessMap = material.roughnessMap;\n      if (material.aoMap == roughnessMap) material.aoMap = material.roughnessMap;\n    }\n\n    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\n    _mipmapMaterial.uniforms.normalMap.value = normalMap;\n    var position = new _three.Vector2(0, 0);\n    var texelSize = _mipmapMaterial.uniforms.texelSize.value;\n\n    for (var mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {\n      // Rendering to a mip level is not allowed in webGL1. Instead we must set\n      // up a secondary texture to write the result to, then copy it back to the\n      // proper mipmap level.\n      texelSize.set(1.0 / width, 1.0 / height);\n      if (mip == 0) texelSize.set(0.0, 0.0);\n\n      _tempTarget.viewport.set(position.x, position.y, width, height);\n\n      _tempTarget.scissor.set(position.x, position.y, width, height);\n\n      _renderer.setRenderTarget(_tempTarget);\n\n      _renderer.render(_mesh, _flatCamera);\n\n      _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);\n\n      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\n    }\n\n    if (roughnessMap !== material.roughnessMap) roughnessMap.dispose();\n\n    _renderer.setRenderTarget(oldTarget);\n\n    _renderer.autoClear = autoClear;\n  },\n  dispose: function dispose() {\n    _mipmapMaterial.dispose();\n\n    _mesh.geometry.dispose();\n\n    if (_tempTarget != null) _tempTarget.dispose();\n  }\n};\n\nfunction _getMipmapMaterial() {\n  var shaderMaterial = new _three.RawShaderMaterial({\n    uniforms: {\n      roughnessMap: {\n        value: null\n      },\n      normalMap: {\n        value: null\n      },\n      texelSize: {\n        value: new _three.Vector2(1, 1)\n      }\n    },\n    vertexShader:\n    /* glsl */\n    \"\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tattribute vec3 position;\\n\\t\\t\\tattribute vec2 uv;\\n\\n\\t\\t\\tvarying vec2 vUv;\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvUv = uv;\\n\\n\\t\\t\\t\\tgl_Position = vec4( position, 1.0 );\\n\\n\\t\\t\\t}\\n\\t\\t\",\n    fragmentShader:\n    /* glsl */\n    \"\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec2 vUv;\\n\\n\\t\\t\\tuniform sampler2D roughnessMap;\\n\\t\\t\\tuniform sampler2D normalMap;\\n\\t\\t\\tuniform vec2 texelSize;\\n\\n\\t\\t\\t#define ENVMAP_TYPE_CUBE_UV\\n\\n\\t\\t\\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\\n\\n\\t\\t\\t#include <cube_uv_reflection_fragment>\\n\\n\\t\\t\\tfloat roughnessToVariance( float roughness ) {\\n\\n\\t\\t\\t\\tfloat variance = 0.0;\\n\\n\\t\\t\\t\\tif ( roughness >= r1 ) {\\n\\n\\t\\t\\t\\t\\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\\n\\n\\t\\t\\t\\t} else if ( roughness >= r4 ) {\\n\\n\\t\\t\\t\\t\\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\\n\\n\\t\\t\\t\\t} else if ( roughness >= r5 ) {\\n\\n\\t\\t\\t\\t\\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tfloat roughness2 = roughness * roughness;\\n\\n\\t\\t\\t\\t\\tvariance = 1.79 * roughness2 * roughness2;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn variance;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfloat varianceToRoughness( float variance ) {\\n\\n\\t\\t\\t\\tfloat roughness = 0.0;\\n\\n\\t\\t\\t\\tif ( variance >= v1 ) {\\n\\n\\t\\t\\t\\t\\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\\n\\n\\t\\t\\t\\t} else if ( variance >= v4 ) {\\n\\n\\t\\t\\t\\t\\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\\n\\n\\t\\t\\t\\t} else if ( variance >= v5 ) {\\n\\n\\t\\t\\t\\t\\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn roughness;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\\n\\n\\t\\t\\t\\tif ( texelSize.x == 0.0 ) return;\\n\\n\\t\\t\\t\\tfloat roughness = gl_FragColor.g;\\n\\n\\t\\t\\t\\tfloat variance = roughnessToVariance( roughness );\\n\\n\\t\\t\\t\\tvec3 avgNormal;\\n\\n\\t\\t\\t\\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\\n\\n\\t\\t\\t\\t\\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\\n\\n\\t\\t\\t\\t\\t\\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\\n\\n\\t\\t\\t\\t\\t\\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvariance += 1.0 - 0.25 * length( avgNormal );\\n\\n\\t\\t\\t\\tgl_FragColor.g = varianceToRoughness( variance );\\n\\n\\t\\t\\t}\\n\\t\\t\",\n    blending: _three.NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  shaderMaterial.type = 'RoughnessMipmapper';\n  return shaderMaterial;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","wrapS","depthTest","scissorTest","blending","RoughnessMipmapper","prototype","depthBuffer","roughnessMap","__esModule","dispose","normalMap","aoMap","vertexShader","value","magFilter","autoClear","metalnessMap","type","wrapT","texelSize","depthWrite","generateMipmaps","uniforms","roughnessUpdated","minFilter","constructor"]],"~:compiled-at",1630917515399,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$utils$RoughnessMipmapper.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/utils/RoughnessMipmapper.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$utils$RoughnessMipmapper\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.RoughnessMipmapper = RoughnessMipmapper;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * This class generates custom mipmaps for a roughness map by encoding the lost variation in the\\n * normal map mip levels as increased roughness in the corresponding roughness mip levels. This\\n * helps with rendering accuracy for MeshStandardMaterial, and also helps with anti-aliasing when\\n * using PMREM. If the normal map is larger than the roughness map, the roughness map will be\\n * enlarged to match the dimensions of the normal map.\\n */\\nvar _mipmapMaterial = _getMipmapMaterial();\\n\\nvar _mesh = new _three.Mesh(new _three.PlaneGeometry(2, 2), _mipmapMaterial);\\n\\nvar _flatCamera = new _three.OrthographicCamera(0, 1, 0, 1, 0, 1);\\n\\nvar _tempTarget = null;\\nvar _renderer = null;\\n\\nfunction RoughnessMipmapper(renderer) {\\n  _renderer = renderer;\\n\\n  _renderer.compile(_mesh, _flatCamera);\\n}\\n\\nRoughnessMipmapper.prototype = {\\n  constructor: RoughnessMipmapper,\\n  generateMipmaps: function generateMipmaps(material) {\\n    if ('roughnessMap' in material === false) return;\\n    var roughnessMap = material.roughnessMap,\\n        normalMap = material.normalMap;\\n    if (roughnessMap === null || normalMap === null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) return;\\n    material.userData.roughnessUpdated = true;\\n    var width = Math.max(roughnessMap.image.width, normalMap.image.width);\\n    var height = Math.max(roughnessMap.image.height, normalMap.image.height);\\n    if (!_three.MathUtils.isPowerOfTwo(width) || !_three.MathUtils.isPowerOfTwo(height)) return;\\n\\n    var oldTarget = _renderer.getRenderTarget();\\n\\n    var autoClear = _renderer.autoClear;\\n    _renderer.autoClear = false;\\n\\n    if (_tempTarget === null || _tempTarget.width !== width || _tempTarget.height !== height) {\\n      if (_tempTarget !== null) _tempTarget.dispose();\\n      _tempTarget = new _three.WebGLRenderTarget(width, height, {\\n        depthBuffer: false\\n      });\\n      _tempTarget.scissorTest = true;\\n    }\\n\\n    if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {\\n      var params = {\\n        wrapS: roughnessMap.wrapS,\\n        wrapT: roughnessMap.wrapT,\\n        magFilter: roughnessMap.magFilter,\\n        minFilter: roughnessMap.minFilter,\\n        depthBuffer: false\\n      };\\n      var newRoughnessTarget = new _three.WebGLRenderTarget(width, height, params);\\n      newRoughnessTarget.texture.generateMipmaps = true; // Setting the render target causes the memory to be allocated.\\n\\n      _renderer.setRenderTarget(newRoughnessTarget);\\n\\n      material.roughnessMap = newRoughnessTarget.texture;\\n      if (material.metalnessMap == roughnessMap) material.metalnessMap = material.roughnessMap;\\n      if (material.aoMap == roughnessMap) material.aoMap = material.roughnessMap;\\n    }\\n\\n    _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\\n    _mipmapMaterial.uniforms.normalMap.value = normalMap;\\n    var position = new _three.Vector2(0, 0);\\n    var texelSize = _mipmapMaterial.uniforms.texelSize.value;\\n\\n    for (var mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {\\n      // Rendering to a mip level is not allowed in webGL1. Instead we must set\\n      // up a secondary texture to write the result to, then copy it back to the\\n      // proper mipmap level.\\n      texelSize.set(1.0 / width, 1.0 / height);\\n      if (mip == 0) texelSize.set(0.0, 0.0);\\n\\n      _tempTarget.viewport.set(position.x, position.y, width, height);\\n\\n      _tempTarget.scissor.set(position.x, position.y, width, height);\\n\\n      _renderer.setRenderTarget(_tempTarget);\\n\\n      _renderer.render(_mesh, _flatCamera);\\n\\n      _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);\\n\\n      _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\\n    }\\n\\n    if (roughnessMap !== material.roughnessMap) roughnessMap.dispose();\\n\\n    _renderer.setRenderTarget(oldTarget);\\n\\n    _renderer.autoClear = autoClear;\\n  },\\n  dispose: function dispose() {\\n    _mipmapMaterial.dispose();\\n\\n    _mesh.geometry.dispose();\\n\\n    if (_tempTarget != null) _tempTarget.dispose();\\n  }\\n};\\n\\nfunction _getMipmapMaterial() {\\n  var shaderMaterial = new _three.RawShaderMaterial({\\n    uniforms: {\\n      roughnessMap: {\\n        value: null\\n      },\\n      normalMap: {\\n        value: null\\n      },\\n      texelSize: {\\n        value: new _three.Vector2(1, 1)\\n      }\\n    },\\n    vertexShader:\\n    /* glsl */\\n    \\\"\\\\n\\\\t\\\\t\\\\tprecision mediump float;\\\\n\\\\t\\\\t\\\\tprecision mediump int;\\\\n\\\\n\\\\t\\\\t\\\\tattribute vec3 position;\\\\n\\\\t\\\\t\\\\tattribute vec2 uv;\\\\n\\\\n\\\\t\\\\t\\\\tvarying vec2 vUv;\\\\n\\\\n\\\\t\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvUv = uv;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tgl_Position = vec4( position, 1.0 );\\\\n\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\",\\n    fragmentShader:\\n    /* glsl */\\n    \\\"\\\\n\\\\t\\\\t\\\\tprecision mediump float;\\\\n\\\\t\\\\t\\\\tprecision mediump int;\\\\n\\\\n\\\\t\\\\t\\\\tvarying vec2 vUv;\\\\n\\\\n\\\\t\\\\t\\\\tuniform sampler2D roughnessMap;\\\\n\\\\t\\\\t\\\\tuniform sampler2D normalMap;\\\\n\\\\t\\\\t\\\\tuniform vec2 texelSize;\\\\n\\\\n\\\\t\\\\t\\\\t#define ENVMAP_TYPE_CUBE_UV\\\\n\\\\n\\\\t\\\\t\\\\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\\\\n\\\\n\\\\t\\\\t\\\\t#include <cube_uv_reflection_fragment>\\\\n\\\\n\\\\t\\\\t\\\\tfloat roughnessToVariance( float roughness ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat variance = 0.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tif ( roughness >= r1 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t} else if ( roughness >= r4 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t} else if ( roughness >= r5 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat roughness2 = roughness * roughness;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvariance = 1.79 * roughness2 * roughness2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\treturn variance;\\\\n\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfloat varianceToRoughness( float variance ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat roughness = 0.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tif ( variance >= v1 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t} else if ( variance >= v4 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t} else if ( variance >= v5 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\treturn roughness;\\\\n\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tif ( texelSize.x == 0.0 ) return;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat roughness = gl_FragColor.g;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat variance = roughnessToVariance( roughness );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec3 avgNormal;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvariance += 1.0 - 0.25 * length( avgNormal );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tgl_FragColor.g = varianceToRoughness( variance );\\\\n\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\",\\n    blending: _three.NoBlending,\\n    depthTest: false,\\n    depthWrite: false\\n  });\\n  shaderMaterial.type = 'RoughnessMipmapper';\\n  return shaderMaterial;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"RoughnessMipmapper\",\"renderer\",\"_renderer\",\"compile\",\"_mesh\",\"_flatCamera\",\"Object\",\"defineProperty\",\"value\",\"_three\",\"_mipmapMaterial\",\"_getMipmapMaterial\",\"shaderMaterial\",\"RawShaderMaterial\",\"uniforms\",\"roughnessMap\",\"normalMap\",\"texelSize\",\"Vector2\",\"vertexShader\",\"fragmentShader\",\"blending\",\"NoBlending\",\"depthTest\",\"depthWrite\",\"type\",\"Mesh\",\"PlaneGeometry\",\"OrthographicCamera\",\"_tempTarget\",\"prototype\",\"constructor\",\"generateMipmaps\",\"material\",\"roughnessUpdated\",\"userData\",\"width\",\"Math\",\"max\",\"image\",\"height\",\"MathUtils\",\"isPowerOfTwo\",\"oldTarget\",\"getRenderTarget\",\"autoClear\",\"dispose\",\"WebGLRenderTarget\",\"depthBuffer\",\"scissorTest\",\"newRoughnessTarget\",\"params\",\"wrapS\",\"wrapT\",\"magFilter\",\"minFilter\",\"texture\",\"setRenderTarget\",\"metalnessMap\",\"aoMap\",\"position\",\"mip\",\"set\",\"viewport\",\"x\",\"y\",\"scissor\",\"render\",\"copyFramebufferToTexture\",\"geometry\"]\n}\n"]