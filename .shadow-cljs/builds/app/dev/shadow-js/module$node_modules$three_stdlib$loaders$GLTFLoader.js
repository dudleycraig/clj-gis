["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/GLTFLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$GLTFLoader=function(global,require,module,exports){function _get(target$jscomp$0,property$jscomp$0,receiver$jscomp$0){_get=\"undefined\"!==typeof Reflect&&Reflect.get?Reflect.get:function(target,property,receiver){for(;!Object.prototype.hasOwnProperty.call(target,property)&&(target=_getPrototypeOf(target),null!==target););if(target)return property=Object.getOwnPropertyDescriptor(target,property),property.get?property.get.call(receiver):property.value};\nreturn _get(target$jscomp$0,property$jscomp$0,receiver$jscomp$0||target$jscomp$0)}function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");\n}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _possibleConstructorReturn(self,\ncall){return!call||\"object\"!==_typeof(call)&&\"function\"!==typeof call?_assertThisInitialized(self):call}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==\ntypeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}function GLTFRegistry(){var objects={};return{get:function(key){return objects[key]},\nadd:function(key,object){objects[key]=object},remove:function(key){delete objects[key]},removeAll:function(){objects={}}}}function resolveURL(url,path){if(\"string\"!==typeof url||\"\"===url)return\"\";/^https?:\\/\\//i.test(path)&&/^\\//.test(url)&&(path=path.replace(/(^https?:\\/\\/[^\\/]+).*/i,\"$1\"));return/^(https?:)?\\/\\//i.test(url)||/^data:.*,.*$/i.test(url)||/^blob:.*$/i.test(url)?url:path+url}function createDefaultMaterial(cache){void 0===cache.DefaultMaterial&&(cache.DefaultMaterial=new _three.MeshStandardMaterial({color:16777215,\nemissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:_three.FrontSide}));return cache.DefaultMaterial}function addUnknownExtensionsToUserData(knownExtensions,object,objectDef){for(var name in objectDef.extensions)void 0===knownExtensions[name]&&(object.userData.gltfExtensions=object.userData.gltfExtensions||{},object.userData.gltfExtensions[name]=objectDef.extensions[name])}function assignExtrasToUserData(object,gltfDef){void 0!==gltfDef.extras&&(\"object\"===_typeof(gltfDef.extras)?\nObject.assign(object.userData,gltfDef.extras):console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \"+gltfDef.extras))}function addMorphTargets(geometry,targets,parser){for(var hasMorphPosition=!1,hasMorphNormal=!1,i=0,il=targets.length;i<il;i++){var target=targets[i];void 0!==target.POSITION&&(hasMorphPosition=!0);void 0!==target.NORMAL&&(hasMorphNormal=!0);if(hasMorphPosition&&hasMorphNormal)break}if(!hasMorphPosition&&!hasMorphNormal)return Promise.resolve(geometry);i=[];il=[];target=\n0;for(var _il=targets.length;target<_il;target++){var _target=targets[target];if(hasMorphPosition){var pendingAccessor=void 0!==_target.POSITION?parser.getDependency(\"accessor\",_target.POSITION):geometry.attributes.position;i.push(pendingAccessor)}hasMorphNormal&&(_target=void 0!==_target.NORMAL?parser.getDependency(\"accessor\",_target.NORMAL):geometry.attributes.normal,il.push(_target))}return Promise.all([Promise.all(i),Promise.all(il)]).then(function(accessors){var morphPositions=accessors[0];accessors=\naccessors[1];hasMorphPosition&&(geometry.morphAttributes.position=morphPositions);hasMorphNormal&&(geometry.morphAttributes.normal=accessors);geometry.morphTargetsRelative=!0;return geometry})}function createPrimitiveKey(primitiveDef){var dracoExtension=primitiveDef.extensions&&primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];return dracoExtension?\"draco:\"+dracoExtension.bufferView+\":\"+dracoExtension.indices+\":\"+createAttributesKey(dracoExtension.attributes):primitiveDef.indices+\":\"+\ncreateAttributesKey(primitiveDef.attributes)+\":\"+primitiveDef.mode}function createAttributesKey(attributes){for(var attributesKey=\"\",keys=Object.keys(attributes).sort(),i=0,il=keys.length;i<il;i++)attributesKey+=keys[i]+\":\"+attributes[keys[i]]+\";\";return attributesKey}function getNormalizedComponentScale(constructor){switch(constructor){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n}}function buildNodeHierachy(nodeId,parentObject,json,parser){var nodeDef=json.nodes[nodeId];return parser.getDependency(\"node\",nodeId).then(function(node){if(void 0===nodeDef.skin)return node;var skinEntry;return parser.getDependency(\"skin\",nodeDef.skin).then(function(skin){skinEntry=skin;skin=[];for(var i=0,il=skinEntry.joints.length;i<il;i++)skin.push(parser.getDependency(\"node\",skinEntry.joints[i]));return Promise.all(skin)}).then(function(jointNodes){node.traverse(function(mesh){if(mesh.isMesh){for(var bones=\n[],boneInverses=[],j=0,jl=jointNodes.length;j<jl;j++){var jointNode=jointNodes[j];jointNode?(bones.push(jointNode),jointNode=new _three.Matrix4,void 0!==skinEntry.inverseBindMatrices&&jointNode.fromArray(skinEntry.inverseBindMatrices.array,16*j),boneInverses.push(jointNode)):console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.',skinEntry.joints[j])}mesh.bind(new _three.Skeleton(bones,boneInverses),mesh.matrixWorld)}});return node})}).then(function(node){parentObject.add(node);var pending=\n[];if(nodeDef.children)for(var children=nodeDef.children,i=0,il=children.length;i<il;i++)pending.push(buildNodeHierachy(children[i],node,json,parser));return Promise.all(pending)})}function computeBounds(geometry,primitiveDef,parser){var attributes=primitiveDef.attributes,box=new _three.Box3;if(void 0!==attributes.POSITION){attributes=parser.json.accessors[attributes.POSITION];var min=attributes.min,max=attributes.max;if(void 0!==min&&void 0!==max){box.set(new _three.Vector3(min[0],min[1],min[2]),\nnew _three.Vector3(max[0],max[1],max[2]));attributes.normalized&&(attributes=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[attributes.componentType]),box.min.multiplyScalar(attributes),box.max.multiplyScalar(attributes));primitiveDef=primitiveDef.targets;if(void 0!==primitiveDef){attributes=new _three.Vector3;min=new _three.Vector3;max=0;for(var il=primitiveDef.length;max<il;max++){var target=primitiveDef[max];if(void 0!==target.POSITION){target=parser.json.accessors[target.POSITION];var _min=\ntarget.min,_max=target.max;void 0!==_min&&void 0!==_max?(min.setX(Math.max(Math.abs(_min[0]),Math.abs(_max[0]))),min.setY(Math.max(Math.abs(_min[1]),Math.abs(_max[1]))),min.setZ(Math.max(Math.abs(_min[2]),Math.abs(_max[2]))),target.normalized&&(target=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[target.componentType]),min.multiplyScalar(target)),attributes.max(min)):console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\")}}box.expandByVector(attributes)}geometry.boundingBox=\nbox;parser=new _three.Sphere;box.getCenter(parser.center);parser.radius=box.min.distanceTo(box.max)/2;geometry.boundingSphere=parser}else console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\")}}function addPrimitiveAttributes(geometry,primitiveDef,parser){function assignAttributeAccessor(accessorIndex,attributeName){return parser.getDependency(\"accessor\",accessorIndex).then(function(accessor){geometry.setAttribute(attributeName,accessor)})}var attributes=primitiveDef.attributes,\npending=[],gltfAttributeName;for(gltfAttributeName in attributes){var threeAttributeName=ATTRIBUTES[gltfAttributeName]||gltfAttributeName.toLowerCase();threeAttributeName in geometry.attributes||pending.push(assignAttributeAccessor(attributes[gltfAttributeName],threeAttributeName))}void 0===primitiveDef.indices||geometry.index||(attributes=parser.getDependency(\"accessor\",primitiveDef.indices).then(function(accessor){geometry.setIndex(accessor)}),pending.push(attributes));assignExtrasToUserData(geometry,\nprimitiveDef);computeBounds(geometry,primitiveDef,parser);return Promise.all(pending).then(function(){return void 0!==primitiveDef.targets?addMorphTargets(geometry,primitiveDef.targets,parser):geometry})}function toTrianglesDrawMode(geometry,drawMode){var index=geometry.getIndex();if(null===index){var indices=[];index=geometry.getAttribute(\"position\");if(void 0!==index){for(var i=0;i<index.count;i++)indices.push(i);geometry.setIndex(indices);index=geometry.getIndex()}else return console.error(\"THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"),\ngeometry}i=index.count-2;indices=[];if(drawMode===_three.TriangleFanDrawMode)for(drawMode=1;drawMode<=i;drawMode++)indices.push(index.getX(0)),indices.push(index.getX(drawMode)),indices.push(index.getX(drawMode+1));else for(drawMode=0;drawMode<i;drawMode++)0===drawMode%2?(indices.push(index.getX(drawMode)),indices.push(index.getX(drawMode+1)),indices.push(index.getX(drawMode+2))):(indices.push(index.getX(drawMode+2)),indices.push(index.getX(drawMode+1)),indices.push(index.getX(drawMode)));indices.length/\n3!==i&&console.error(\"THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");geometry=geometry.clone();geometry.setIndex(indices);return geometry}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.GLTFLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_Loader){function GLTFLoader(manager){_classCallCheck(this,GLTFLoader);manager=_possibleConstructorReturn(this,_getPrototypeOf(GLTFLoader).call(this,manager));\nmanager.dracoLoader=null;manager.ktx2Loader=null;manager.meshoptDecoder=null;manager.pluginCallbacks=[];manager.register(function(parser){return new GLTFMaterialsClearcoatExtension(parser)});manager.register(function(parser){return new GLTFTextureBasisUExtension(parser)});manager.register(function(parser){return new GLTFTextureWebPExtension(parser)});manager.register(function(parser){return new GLTFMaterialsTransmissionExtension(parser)});manager.register(function(parser){return new GLTFMaterialsVolumeExtension(parser)});\nmanager.register(function(parser){return new GLTFMaterialsIorExtension(parser)});manager.register(function(parser){return new GLTFMaterialsSpecularExtension(parser)});manager.register(function(parser){return new GLTFLightsExtension(parser)});manager.register(function(parser){return new GLTFMeshoptCompression(parser)});return manager}_inherits(GLTFLoader,_Loader);_createClass(GLTFLoader,[{key:\"load\",value:function(url,onLoad,onProgress,onError){var scope=this;var resourcePath=\"\"!==this.resourcePath?\nthis.resourcePath:\"\"!==this.path?this.path:_three.LoaderUtils.extractUrlBase(url);this.manager.itemStart(url);var _onError=function(e){onError?onError(e):console.error(e);scope.manager.itemError(url);scope.manager.itemEnd(url)},loader=new _three.FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType(\"arraybuffer\");loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);loader.load(url,function(data){try{scope.parse(data,resourcePath,function(gltf){onLoad(gltf);\nscope.manager.itemEnd(url)},_onError)}catch(e){_onError(e)}},onProgress,_onError)}},{key:\"setDRACOLoader\",value:function(dracoLoader){this.dracoLoader=dracoLoader;return this}},{key:\"setDDSLoader\",value:function(){throw Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');}},{key:\"setKTX2Loader\",value:function(ktx2Loader){this.ktx2Loader=ktx2Loader;return this}},{key:\"setMeshoptDecoder\",value:function(meshoptDecoder){this.meshoptDecoder=meshoptDecoder;\nreturn this}},{key:\"register\",value:function(callback){-1===this.pluginCallbacks.indexOf(callback)&&this.pluginCallbacks.push(callback);return this}},{key:\"unregister\",value:function(callback){-1!==this.pluginCallbacks.indexOf(callback)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback),1);return this}},{key:\"parse\",value:function(data,path,onLoad,onError){var extensions={},plugins={};if(\"string\"!==typeof data)if(_three.LoaderUtils.decodeText(new Uint8Array(data,0,4))===BINARY_EXTENSION_HEADER_MAGIC){try{extensions[EXTENSIONS.KHR_BINARY_GLTF]=\nnew GLTFBinaryExtension(data)}catch(error){onError&&onError(error);return}data=extensions[EXTENSIONS.KHR_BINARY_GLTF].content}else data=_three.LoaderUtils.decodeText(new Uint8Array(data));data=JSON.parse(data);if(void 0===data.asset||2>data.asset.version[0])onError&&onError(Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions \\x3e\\x3d2.0 are supported.\"));else{path=new GLTFParser(data,{path:path||this.resourcePath||\"\",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,\nktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});path.fileLoader.setRequestHeader(this.requestHeader);for(var i=0;i<this.pluginCallbacks.length;i++){var plugin=this.pluginCallbacks[i](path);plugins[plugin.name]=plugin;extensions[plugin.name]=!0}if(data.extensionsUsed)for(i=0;i<data.extensionsUsed.length;++i){plugin=data.extensionsUsed[i];var extensionsRequired=data.extensionsRequired||[];switch(plugin){case EXTENSIONS.KHR_MATERIALS_UNLIT:extensions[plugin]=new GLTFMaterialsUnlitExtension$jscomp$0;\nbreak;case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:extensions[plugin]=new GLTFMaterialsPbrSpecularGlossinessExtension;break;case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:extensions[plugin]=new GLTFDracoMeshCompressionExtension(data,this.dracoLoader);break;case EXTENSIONS.KHR_TEXTURE_TRANSFORM:extensions[plugin]=new GLTFTextureTransformExtension;break;case EXTENSIONS.KHR_MESH_QUANTIZATION:extensions[plugin]=new GLTFMeshQuantizationExtension;break;default:0<=extensionsRequired.indexOf(plugin)&&\nvoid 0===plugins[plugin]&&console.warn('THREE.GLTFLoader: Unknown extension \"'+plugin+'\".')}}path.setExtensions(extensions);path.setPlugins(plugins);path.parse(onLoad,onError)}}}]);return GLTFLoader}(_three.Loader);exports.GLTFLoader=global;var EXTENSIONS={KHR_BINARY_GLTF:\"KHR_binary_glTF\",KHR_DRACO_MESH_COMPRESSION:\"KHR_draco_mesh_compression\",KHR_LIGHTS_PUNCTUAL:\"KHR_lights_punctual\",KHR_MATERIALS_CLEARCOAT:\"KHR_materials_clearcoat\",KHR_MATERIALS_IOR:\"KHR_materials_ior\",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\"KHR_materials_pbrSpecularGlossiness\",\nKHR_MATERIALS_SPECULAR:\"KHR_materials_specular\",KHR_MATERIALS_TRANSMISSION:\"KHR_materials_transmission\",KHR_MATERIALS_UNLIT:\"KHR_materials_unlit\",KHR_MATERIALS_VOLUME:\"KHR_materials_volume\",KHR_TEXTURE_BASISU:\"KHR_texture_basisu\",KHR_TEXTURE_TRANSFORM:\"KHR_texture_transform\",KHR_MESH_QUANTIZATION:\"KHR_mesh_quantization\",EXT_TEXTURE_WEBP:\"EXT_texture_webp\",EXT_MESHOPT_COMPRESSION:\"EXT_meshopt_compression\"},GLTFLightsExtension=function(){function GLTFLightsExtension(parser){_classCallCheck(this,GLTFLightsExtension);\nthis.parser=parser;this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL;this.cache={refs:{},uses:{}}}_createClass(GLTFLightsExtension,[{key:\"_markDefs\",value:function(){for(var parser=this.parser,nodeDefs=this.parser.json.nodes||[],nodeIndex=0,nodeLength=nodeDefs.length;nodeIndex<nodeLength;nodeIndex++){var nodeDef=nodeDefs[nodeIndex];nodeDef.extensions&&nodeDef.extensions[this.name]&&void 0!==nodeDef.extensions[this.name].light&&parser._addNodeRef(this.cache,nodeDef.extensions[this.name].light)}}},{key:\"_loadLight\",\nvalue:function(lightIndex){var parser=this.parser,cacheKey=\"light:\"+lightIndex,dependency=parser.cache.get(cacheKey);if(dependency)return dependency;dependency=parser.json;dependency=((dependency.extensions&&dependency.extensions[this.name]||{}).lights||[])[lightIndex];var lightNode=new _three.Color(16777215);void 0!==dependency.color&&lightNode.fromArray(dependency.color);var range=void 0!==dependency.range?dependency.range:0;switch(dependency.type){case \"directional\":lightNode=new _three.DirectionalLight(lightNode);\nlightNode.target.position.set(0,0,-1);lightNode.add(lightNode.target);break;case \"point\":lightNode=new _three.PointLight(lightNode);lightNode.distance=range;break;case \"spot\":lightNode=new _three.SpotLight(lightNode);lightNode.distance=range;dependency.spot=dependency.spot||{};dependency.spot.innerConeAngle=void 0!==dependency.spot.innerConeAngle?dependency.spot.innerConeAngle:0;dependency.spot.outerConeAngle=void 0!==dependency.spot.outerConeAngle?dependency.spot.outerConeAngle:Math.PI/4;lightNode.angle=\ndependency.spot.outerConeAngle;lightNode.penumbra=1-dependency.spot.innerConeAngle/dependency.spot.outerConeAngle;lightNode.target.position.set(0,0,-1);lightNode.add(lightNode.target);break;default:throw Error(\"THREE.GLTFLoader: Unexpected light type: \"+dependency.type);}lightNode.position.set(0,0,0);lightNode.decay=2;void 0!==dependency.intensity&&(lightNode.intensity=dependency.intensity);lightNode.name=parser.createUniqueName(dependency.name||\"light_\"+lightIndex);dependency=Promise.resolve(lightNode);\nparser.cache.add(cacheKey,dependency);return dependency}},{key:\"createNodeAttachment\",value:function(nodeIndex){var self=this,parser=this.parser;nodeIndex=parser.json.nodes[nodeIndex];var lightIndex=(nodeIndex.extensions&&nodeIndex.extensions[this.name]||{}).light;return void 0===lightIndex?null:this._loadLight(lightIndex).then(function(light){return parser._getNodeRef(self.cache,lightIndex,light)})}}]);return GLTFLightsExtension}(),GLTFMaterialsUnlitExtension$jscomp$0=function(){function GLTFMaterialsUnlitExtension(){_classCallCheck(this,\nGLTFMaterialsUnlitExtension);this.name=EXTENSIONS.KHR_MATERIALS_UNLIT}_createClass(GLTFMaterialsUnlitExtension,[{key:\"getMaterialType\",value:function(){return _three.MeshBasicMaterial}},{key:\"extendParams\",value:function(materialParams,materialDef,parser){var pending=[];materialParams.color=new _three.Color(1,1,1);materialParams.opacity=1;if(materialDef=materialDef.pbrMetallicRoughness){if(Array.isArray(materialDef.baseColorFactor)){var array=materialDef.baseColorFactor;materialParams.color.fromArray(array);\nmaterialParams.opacity=array[3]}void 0!==materialDef.baseColorTexture&&pending.push(parser.assignTexture(materialParams,\"map\",materialDef.baseColorTexture))}return Promise.all(pending)}}]);return GLTFMaterialsUnlitExtension}(),GLTFMaterialsClearcoatExtension=function(){function GLTFMaterialsClearcoatExtension(parser){_classCallCheck(this,GLTFMaterialsClearcoatExtension);this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_CLEARCOAT}_createClass(GLTFMaterialsClearcoatExtension,[{key:\"getMaterialType\",\nvalue:function(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}},{key:\"extendMaterialParams\",value:function(materialIndex,materialParams){var parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];void 0!==materialDef.clearcoatFactor&&\n(materialParams.clearcoat=materialDef.clearcoatFactor);void 0!==materialDef.clearcoatTexture&&materialIndex.push(parser.assignTexture(materialParams,\"clearcoatMap\",materialDef.clearcoatTexture));void 0!==materialDef.clearcoatRoughnessFactor&&(materialParams.clearcoatRoughness=materialDef.clearcoatRoughnessFactor);void 0!==materialDef.clearcoatRoughnessTexture&&materialIndex.push(parser.assignTexture(materialParams,\"clearcoatRoughnessMap\",materialDef.clearcoatRoughnessTexture));void 0!==materialDef.clearcoatNormalTexture&&\n(materialIndex.push(parser.assignTexture(materialParams,\"clearcoatNormalMap\",materialDef.clearcoatNormalTexture)),void 0!==materialDef.clearcoatNormalTexture.scale&&(parser=materialDef.clearcoatNormalTexture.scale,materialParams.clearcoatNormalScale=new _three.Vector2(parser,-parser)));return Promise.all(materialIndex)}}]);return GLTFMaterialsClearcoatExtension}(),GLTFMaterialsTransmissionExtension=function(){function GLTFMaterialsTransmissionExtension(parser){_classCallCheck(this,GLTFMaterialsTransmissionExtension);\nthis.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_TRANSMISSION}_createClass(GLTFMaterialsTransmissionExtension,[{key:\"getMaterialType\",value:function(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}},{key:\"extendMaterialParams\",value:function(materialIndex,materialParams){var parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||\n!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];void 0!==materialDef.transmissionFactor&&(materialParams.transmission=materialDef.transmissionFactor);void 0!==materialDef.transmissionTexture&&materialIndex.push(parser.assignTexture(materialParams,\"transmissionMap\",materialDef.transmissionTexture));return Promise.all(materialIndex)}}]);return GLTFMaterialsTransmissionExtension}(),GLTFMaterialsVolumeExtension=function(){function GLTFMaterialsVolumeExtension(parser){_classCallCheck(this,\nGLTFMaterialsVolumeExtension);this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_VOLUME}_createClass(GLTFMaterialsVolumeExtension,[{key:\"getMaterialType\",value:function(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}},{key:\"extendMaterialParams\",value:function(materialIndex,materialParams){var parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||\n!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];materialParams.thickness=void 0!==materialDef.thicknessFactor?materialDef.thicknessFactor:0;void 0!==materialDef.thicknessTexture&&materialIndex.push(parser.assignTexture(materialParams,\"thicknessMap\",materialDef.thicknessTexture));materialParams.attenuationDistance=materialDef.attenuationDistance||0;parser=materialDef.attenuationColor||[1,1,1];materialParams.attenuationTint=\nnew _three.Color(parser[0],parser[1],parser[2]);return Promise.all(materialIndex)}}]);return GLTFMaterialsVolumeExtension}(),GLTFMaterialsIorExtension=function(){function GLTFMaterialsIorExtension(parser){_classCallCheck(this,GLTFMaterialsIorExtension);this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_IOR}_createClass(GLTFMaterialsIorExtension,[{key:\"getMaterialType\",value:function(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?\n_three.MeshPhysicalMaterial:null}},{key:\"extendMaterialParams\",value:function(materialIndex,materialParams){materialIndex=this.parser.json.materials[materialIndex];if(!materialIndex.extensions||!materialIndex.extensions[this.name])return Promise.resolve();materialIndex=materialIndex.extensions[this.name];materialParams.ior=void 0!==materialIndex.ior?materialIndex.ior:1.5;return Promise.resolve()}}]);return GLTFMaterialsIorExtension}(),GLTFMaterialsSpecularExtension=function(){function GLTFMaterialsSpecularExtension(parser){_classCallCheck(this,\nGLTFMaterialsSpecularExtension);this.parser=parser;this.name=EXTENSIONS.KHR_MATERIALS_SPECULAR}_createClass(GLTFMaterialsSpecularExtension,[{key:\"getMaterialType\",value:function(materialIndex){materialIndex=this.parser.json.materials[materialIndex];return materialIndex.extensions&&materialIndex.extensions[this.name]?_three.MeshPhysicalMaterial:null}},{key:\"extendMaterialParams\",value:function(materialIndex,materialParams){var parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||\n!materialDef.extensions[this.name])return Promise.resolve();materialIndex=[];materialDef=materialDef.extensions[this.name];materialParams.specularIntensity=void 0!==materialDef.specularFactor?materialDef.specularFactor:1;void 0!==materialDef.specularTexture&&materialIndex.push(parser.assignTexture(materialParams,\"specularIntensityMap\",materialDef.specularTexture));var colorArray=materialDef.specularColorFactor||[1,1,1];materialParams.specularTint=new _three.Color(colorArray[0],colorArray[1],colorArray[2]);\nvoid 0!==materialDef.specularColorTexture&&materialIndex.push(parser.assignTexture(materialParams,\"specularTintMap\",materialDef.specularColorTexture).then(function(texture){texture.encoding=_three.sRGBEncoding}));return Promise.all(materialIndex)}}]);return GLTFMaterialsSpecularExtension}(),GLTFTextureBasisUExtension=function(){function GLTFTextureBasisUExtension(parser){_classCallCheck(this,GLTFTextureBasisUExtension);this.parser=parser;this.name=EXTENSIONS.KHR_TEXTURE_BASISU}_createClass(GLTFTextureBasisUExtension,\n[{key:\"loadTexture\",value:function(textureIndex){var parser=this.parser,json=parser.json,textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[this.name])return null;textureDef=json.images[textureDef.extensions[this.name].source];var loader=parser.options.ktx2Loader;if(!loader){if(json.extensionsRequired&&0<=json.extensionsRequired.indexOf(this.name))throw Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");return null}return parser.loadTextureImage(textureIndex,\ntextureDef,loader)}}]);return GLTFTextureBasisUExtension}(),GLTFTextureWebPExtension=function(){function GLTFTextureWebPExtension(parser){_classCallCheck(this,GLTFTextureWebPExtension);this.parser=parser;this.name=EXTENSIONS.EXT_TEXTURE_WEBP;this.isSupported=null}_createClass(GLTFTextureWebPExtension,[{key:\"loadTexture\",value:function(textureIndex){var name=this.name,parser=this.parser,json=parser.json,textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[name])return null;\nvar source=json.images[textureDef.extensions[name].source],loader=parser.textureLoader;source.uri&&(textureDef=parser.options.manager.getHandler(source.uri),null!==textureDef&&(loader=textureDef));return this.detectSupport().then(function(isSupported){if(isSupported)return parser.loadTextureImage(textureIndex,source,loader);if(json.extensionsRequired&&0<=json.extensionsRequired.indexOf(name))throw Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");return parser.loadTexture(textureIndex)})}},\n{key:\"detectSupport\",value:function(){this.isSupported||(this.isSupported=new Promise(function(resolve){var image=new Image;image.src=\"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";image.onload=image.onerror=function(){resolve(1===image.height)}}));return this.isSupported}}]);return GLTFTextureWebPExtension}(),GLTFMeshoptCompression=function(){function GLTFMeshoptCompression(parser){_classCallCheck(this,GLTFMeshoptCompression);this.name=EXTENSIONS.EXT_MESHOPT_COMPRESSION;\nthis.parser=parser}_createClass(GLTFMeshoptCompression,[{key:\"loadBufferView\",value:function(index){var json=this.parser.json;index=json.bufferViews[index];if(index.extensions&&index.extensions[this.name]){var extensionDef=index.extensions[this.name];index=this.parser.getDependency(\"buffer\",extensionDef.buffer);var decoder=this.parser.options.meshoptDecoder;if(!decoder||!decoder.supported){if(json.extensionsRequired&&0<=json.extensionsRequired.indexOf(this.name))throw Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\nreturn null}return Promise.all([index,decoder.ready]).then(function(res){var byteOffset=extensionDef.byteOffset||0,byteLength=extensionDef.byteLength||0,count=extensionDef.count,stride=extensionDef.byteStride,result=new ArrayBuffer(count*stride);res=new Uint8Array(res[0],byteOffset,byteLength);decoder.decodeGltfBuffer(new Uint8Array(result),count,stride,res,extensionDef.mode,extensionDef.filter);return result})}return null}}]);return GLTFMeshoptCompression}(),BINARY_EXTENSION_HEADER_MAGIC=\"glTF\",\nGLTFBinaryExtension=function GLTFBinaryExtension(data){_classCallCheck(this,GLTFBinaryExtension);this.name=EXTENSIONS.KHR_BINARY_GLTF;this.body=this.content=null;var headerView=new DataView(data,0,12);this.header={magic:_three.LoaderUtils.decodeText(new Uint8Array(data.slice(0,4))),version:headerView.getUint32(4,!0),length:headerView.getUint32(8,!0)};if(this.header.magic!==BINARY_EXTENSION_HEADER_MAGIC)throw Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");if(2>this.header.version)throw Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\nheaderView=this.header.length-12;for(var chunkView=new DataView(data,12),chunkIndex=0;chunkIndex<headerView;){var chunkLength=chunkView.getUint32(chunkIndex,!0);chunkIndex+=4;var chunkType=chunkView.getUint32(chunkIndex,!0);chunkIndex+=4;1313821514===chunkType?(chunkType=new Uint8Array(data,12+chunkIndex,chunkLength),this.content=_three.LoaderUtils.decodeText(chunkType)):5130562===chunkType&&(chunkType=12+chunkIndex,this.body=data.slice(chunkType,chunkType+chunkLength));chunkIndex+=chunkLength}if(null===\nthis.content)throw Error(\"THREE.GLTFLoader: JSON content not found.\");},GLTFDracoMeshCompressionExtension=function(){function GLTFDracoMeshCompressionExtension(json,dracoLoader){_classCallCheck(this,GLTFDracoMeshCompressionExtension);if(!dracoLoader)throw Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;this.json=json;this.dracoLoader=dracoLoader;this.dracoLoader.preload()}_createClass(GLTFDracoMeshCompressionExtension,[{key:\"decodePrimitive\",\nvalue:function(primitive,parser){var json=this.json,dracoLoader=this.dracoLoader,bufferViewIndex=primitive.extensions[this.name].bufferView,gltfAttributeMap=primitive.extensions[this.name].attributes,threeAttributeMap={},attributeNormalizedMap={},attributeTypeMap={};for(attributeName in gltfAttributeMap){var threeAttributeName=ATTRIBUTES[attributeName]||attributeName.toLowerCase();threeAttributeMap[threeAttributeName]=gltfAttributeMap[attributeName]}for(var _attributeName in primitive.attributes){var attributeName=\nATTRIBUTES[_attributeName]||_attributeName.toLowerCase();void 0!==gltfAttributeMap[_attributeName]&&(threeAttributeName=json.accessors[primitive.attributes[_attributeName]],attributeTypeMap[attributeName]=WEBGL_COMPONENT_TYPES[threeAttributeName.componentType],attributeNormalizedMap[attributeName]=!0===threeAttributeName.normalized)}return parser.getDependency(\"bufferView\",bufferViewIndex).then(function(bufferView){return new Promise(function(resolve){dracoLoader.decodeDracoFile(bufferView,function(geometry){for(var _attributeName2 in geometry.attributes){var attribute=\ngeometry.attributes[_attributeName2],normalized=attributeNormalizedMap[_attributeName2];void 0!==normalized&&(attribute.normalized=normalized)}resolve(geometry)},threeAttributeMap,attributeTypeMap)})})}}]);return GLTFDracoMeshCompressionExtension}(),GLTFTextureTransformExtension=function(){function GLTFTextureTransformExtension(){_classCallCheck(this,GLTFTextureTransformExtension);this.name=EXTENSIONS.KHR_TEXTURE_TRANSFORM}_createClass(GLTFTextureTransformExtension,[{key:\"extendTexture\",value:function(texture,\ntransform){void 0!==transform.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in \"'+this.name+'\" extension not yet supported.');if(void 0===transform.offset&&void 0===transform.rotation&&void 0===transform.scale)return texture;texture=texture.clone();void 0!==transform.offset&&texture.offset.fromArray(transform.offset);void 0!==transform.rotation&&(texture.rotation=transform.rotation);void 0!==transform.scale&&texture.repeat.fromArray(transform.scale);texture.needsUpdate=!0;return texture}}]);\nreturn GLTFTextureTransformExtension}(),GLTFMeshStandardSGMaterial=function(_MeshStandardMaterial){function GLTFMeshStandardSGMaterial(params){_classCallCheck(this,GLTFMeshStandardSGMaterial);var _this2=_possibleConstructorReturn(this,_getPrototypeOf(GLTFMeshStandardSGMaterial).call(this));_this2.isGLTFSpecularGlossinessMaterial=!0;var uniforms={specular:{value:(new _three.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};_this2._extraUniforms=uniforms;\n_this2.onBeforeCompile=function(shader){for(var uniformName in uniforms)shader.uniforms[uniformName]=uniforms[uniformName];shader.fragmentShader=shader.fragmentShader.replace(\"uniform float roughness;\",\"uniform vec3 specular;\").replace(\"uniform float metalness;\",\"uniform float glossiness;\").replace(\"#include \\x3croughnessmap_pars_fragment\\x3e\",\"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\").replace(\"#include \\x3cmetalnessmap_pars_fragment\\x3e\",\"#ifdef USE_GLOSSINESSMAP\\n\\tuniform sampler2D glossinessMap;\\n#endif\").replace(\"#include \\x3croughnessmap_fragment\\x3e\",\n\"vec3 specularFactor \\x3d specular;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular \\x3d texture2D( specularMap, vUv );\\n\\ttexelSpecular \\x3d sRGBToLinear( texelSpecular );\\n\\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture\\n\\tspecularFactor *\\x3d texelSpecular.rgb;\\n#endif\").replace(\"#include \\x3cmetalnessmap_fragment\\x3e\",\"float glossinessFactor \\x3d glossiness;\\n#ifdef USE_GLOSSINESSMAP\\n\\tvec4 texelGlossiness \\x3d texture2D( glossinessMap, vUv );\\n\\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture\\n\\tglossinessFactor *\\x3d texelGlossiness.a;\\n#endif\").replace(\"#include \\x3clights_physical_fragment\\x3e\",\n\"PhysicalMaterial material;\\nmaterial.diffuseColor \\x3d diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );\\nvec3 dxy \\x3d max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness \\x3d max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.specularRoughness \\x3d max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\\nmaterial.specularRoughness +\\x3d geometryRoughness;\\nmaterial.specularRoughness \\x3d min( material.specularRoughness, 1.0 );\\nmaterial.specularColor \\x3d specularFactor;\")};\nObject.defineProperties(_assertThisInitialized(_this2),{specular:{get:function(){return uniforms.specular.value},set:function(v){uniforms.specular.value=v}},specularMap:{get:function(){return uniforms.specularMap.value},set:function(v){(uniforms.specularMap.value=v)?this.defines.USE_SPECULARMAP=\"\":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return uniforms.glossiness.value},set:function(v){uniforms.glossiness.value=v}},glossinessMap:{get:function(){return uniforms.glossinessMap.value},\nset:function(v){(uniforms.glossinessMap.value=v)?(this.defines.USE_GLOSSINESSMAP=\"\",this.defines.USE_UV=\"\"):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}});delete _this2.metalness;delete _this2.roughness;delete _this2.metalnessMap;delete _this2.roughnessMap;_this2.setValues(params);return _this2}_inherits(GLTFMeshStandardSGMaterial,_MeshStandardMaterial);_createClass(GLTFMeshStandardSGMaterial,[{key:\"copy\",value:function(source){_get(_getPrototypeOf(GLTFMeshStandardSGMaterial.prototype),\n\"copy\",this).call(this,source);this.specularMap=source.specularMap;this.specular.copy(source.specular);this.glossinessMap=source.glossinessMap;this.glossiness=source.glossiness;delete this.metalness;delete this.roughness;delete this.metalnessMap;delete this.roughnessMap;return this}}]);return GLTFMeshStandardSGMaterial}(_three.MeshStandardMaterial),GLTFMaterialsPbrSpecularGlossinessExtension=function(){function GLTFMaterialsPbrSpecularGlossinessExtension(){_classCallCheck(this,GLTFMaterialsPbrSpecularGlossinessExtension);\nthis.name=EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;this.specularGlossinessParams=\"color map lightMap lightMapIntensity aoMap aoMapIntensity emissive emissiveIntensity emissiveMap bumpMap bumpScale normalMap normalMapType displacementMap displacementScale displacementBias specularMap specular glossinessMap glossiness alphaMap envMap envMapIntensity refractionRatio\".split(\" \")}_createClass(GLTFMaterialsPbrSpecularGlossinessExtension,[{key:\"getMaterialType\",value:function(){return GLTFMeshStandardSGMaterial}},\n{key:\"extendParams\",value:function(materialParams,materialDef,parser){var pbrSpecularGlossiness=materialDef.extensions[this.name];materialParams.color=new _three.Color(1,1,1);materialParams.opacity=1;materialDef=[];if(Array.isArray(pbrSpecularGlossiness.diffuseFactor)){var array=pbrSpecularGlossiness.diffuseFactor;materialParams.color.fromArray(array);materialParams.opacity=array[3]}void 0!==pbrSpecularGlossiness.diffuseTexture&&materialDef.push(parser.assignTexture(materialParams,\"map\",pbrSpecularGlossiness.diffuseTexture));\nmaterialParams.emissive=new _three.Color(0,0,0);materialParams.glossiness=void 0!==pbrSpecularGlossiness.glossinessFactor?pbrSpecularGlossiness.glossinessFactor:1;materialParams.specular=new _three.Color(1,1,1);Array.isArray(pbrSpecularGlossiness.specularFactor)&&materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);void 0!==pbrSpecularGlossiness.specularGlossinessTexture&&(pbrSpecularGlossiness=pbrSpecularGlossiness.specularGlossinessTexture,materialDef.push(parser.assignTexture(materialParams,\n\"glossinessMap\",pbrSpecularGlossiness)),materialDef.push(parser.assignTexture(materialParams,\"specularMap\",pbrSpecularGlossiness)));return Promise.all(materialDef)}},{key:\"createMaterial\",value:function(materialParams){var material=new GLTFMeshStandardSGMaterial(materialParams);material.fog=!0;material.color=materialParams.color;material.map=void 0===materialParams.map?null:materialParams.map;material.lightMap=null;material.lightMapIntensity=1;material.aoMap=void 0===materialParams.aoMap?null:materialParams.aoMap;\nmaterial.aoMapIntensity=1;material.emissive=materialParams.emissive;material.emissiveIntensity=1;material.emissiveMap=void 0===materialParams.emissiveMap?null:materialParams.emissiveMap;material.bumpMap=void 0===materialParams.bumpMap?null:materialParams.bumpMap;material.bumpScale=1;material.normalMap=void 0===materialParams.normalMap?null:materialParams.normalMap;material.normalMapType=_three.TangentSpaceNormalMap;materialParams.normalScale&&(material.normalScale=materialParams.normalScale);material.displacementMap=\nnull;material.displacementScale=1;material.displacementBias=0;material.specularMap=void 0===materialParams.specularMap?null:materialParams.specularMap;material.specular=materialParams.specular;material.glossinessMap=void 0===materialParams.glossinessMap?null:materialParams.glossinessMap;material.glossiness=materialParams.glossiness;material.alphaMap=null;material.envMap=void 0===materialParams.envMap?null:materialParams.envMap;material.envMapIntensity=1;material.refractionRatio=.98;return material}}]);\nreturn GLTFMaterialsPbrSpecularGlossinessExtension}(),GLTFMeshQuantizationExtension=function GLTFMeshQuantizationExtension(){_classCallCheck(this,GLTFMeshQuantizationExtension);this.name=EXTENSIONS.KHR_MESH_QUANTIZATION},GLTFCubicSplineInterpolant=function(_Interpolant){function GLTFCubicSplineInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){_classCallCheck(this,GLTFCubicSplineInterpolant);return _possibleConstructorReturn(this,_getPrototypeOf(GLTFCubicSplineInterpolant).call(this,\nparameterPositions,sampleValues,sampleSize,resultBuffer))}_inherits(GLTFCubicSplineInterpolant,_Interpolant);_createClass(GLTFCubicSplineInterpolant,[{key:\"copySampleValue_\",value:function(index){var result=this.resultBuffer,values=this.sampleValues,valueSize=this.valueSize;index=index*valueSize*3+valueSize;for(var i=0;i!==valueSize;i++)result[i]=values[index+i];return result}}]);return GLTFCubicSplineInterpolant}(_three.Interpolant);GLTFCubicSplineInterpolant.prototype.beforeStart_=GLTFCubicSplineInterpolant.prototype.copySampleValue_;\nGLTFCubicSplineInterpolant.prototype.afterEnd_=GLTFCubicSplineInterpolant.prototype.copySampleValue_;GLTFCubicSplineInterpolant.prototype.interpolate_=function(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,stride2=2*stride,stride3=3*stride;t1-=t0;t0=(t-t0)/t1;t=t0*t0;var ppp=t*t0;i1*=stride3;stride3=i1-stride3;var s2=-2*ppp+3*t;ppp-=t;var s0=1-s2;t0=ppp-t+t0;for(t=0;t!==stride;t++)result[t]=s0*values[stride3+t+stride]+t0*values[stride3+t+stride2]*t1+s2*values[i1+\nt+stride]+ppp*values[i1+t]*t1;return result};var WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS={9728:_three.NearestFilter,9729:_three.LinearFilter,9984:_three.NearestMipmapNearestFilter,9985:_three.LinearMipmapNearestFilter,9986:_three.NearestMipmapLinearFilter,9987:_three.LinearMipmapLinearFilter},WEBGL_WRAPPINGS={33071:_three.ClampToEdgeWrapping,33648:_three.MirroredRepeatWrapping,10497:_three.RepeatWrapping},\nWEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES={POSITION:\"position\",NORMAL:\"normal\",TANGENT:\"tangent\",TEXCOORD_0:\"uv\",TEXCOORD_1:\"uv2\",COLOR_0:\"color\",WEIGHTS_0:\"skinWeight\",JOINTS_0:\"skinIndex\"},PATH_PROPERTIES={scale:\"scale\",translation:\"position\",rotation:\"quaternion\",weights:\"morphTargetInfluences\"},INTERPOLATION={CUBICSPLINE:void 0,LINEAR:_three.InterpolateLinear,STEP:_three.InterpolateDiscrete},GLTFParser=function(){function GLTFParser(){var json=0<arguments.length&&\nvoid 0!==arguments[0]?arguments[0]:{},options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,GLTFParser);this.json=json;this.extensions={};this.plugins={};this.options=options;this.cache=new GLTFRegistry;this.associations=new Map;this.primitiveCache={};this.meshCache={refs:{},uses:{}};this.cameraCache={refs:{},uses:{}};this.lightCache={refs:{},uses:{}};this.textureCache={};this.nodeNamesUsed={};\"undefined\"!==typeof createImageBitmap&&!1===/Firefox/.test(navigator.userAgent)?\nthis.textureLoader=new _three.ImageBitmapLoader(this.options.manager):this.textureLoader=new _three.TextureLoader(this.options.manager);this.textureLoader.setCrossOrigin(this.options.crossOrigin);this.textureLoader.setRequestHeader(this.options.requestHeader);this.fileLoader=new _three.FileLoader(this.options.manager);this.fileLoader.setResponseType(\"arraybuffer\");\"use-credentials\"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}_createClass(GLTFParser,[{key:\"setExtensions\",value:function(extensions){this.extensions=\nextensions}},{key:\"setPlugins\",value:function(plugins){this.plugins=plugins}},{key:\"parse\",value:function(onLoad,onError){var parser=this,json=this.json,extensions=this.extensions;this.cache.removeAll();this._invokeAll(function(ext){return ext._markDefs&&ext._markDefs()});Promise.all(this._invokeAll(function(ext){return ext.beforeRoot&&ext.beforeRoot()})).then(function(){return Promise.all([parser.getDependencies(\"scene\"),parser.getDependencies(\"animation\"),parser.getDependencies(\"camera\")])}).then(function(dependencies){var result=\n{scene:dependencies[0][json.scene||0],scenes:dependencies[0],animations:dependencies[1],cameras:dependencies[2],asset:json.asset,parser,userData:{}};addUnknownExtensionsToUserData(extensions,result,json);assignExtrasToUserData(result,json);Promise.all(parser._invokeAll(function(ext){return ext.afterRoot&&ext.afterRoot(result)})).then(function(){onLoad(result)})})[\"catch\"](onError)}},{key:\"_markDefs\",value:function(){for(var nodeDefs=this.json.nodes||[],skinDefs=this.json.skins||[],meshDefs=this.json.meshes||\n[],skinIndex=0,skinLength=skinDefs.length;skinIndex<skinLength;skinIndex++)for(var joints=skinDefs[skinIndex].joints,i=0,il=joints.length;i<il;i++)nodeDefs[joints[i]].isBone=!0;skinDefs=0;for(skinIndex=nodeDefs.length;skinDefs<skinIndex;skinDefs++)skinLength=nodeDefs[skinDefs],void 0!==skinLength.mesh&&(this._addNodeRef(this.meshCache,skinLength.mesh),void 0!==skinLength.skin&&(meshDefs[skinLength.mesh].isSkinnedMesh=!0)),void 0!==skinLength.camera&&this._addNodeRef(this.cameraCache,skinLength.camera)}},\n{key:\"_addNodeRef\",value:function(cache,index){void 0!==index&&(void 0===cache.refs[index]&&(cache.refs[index]=cache.uses[index]=0),cache.refs[index]++)}},{key:\"_getNodeRef\",value:function(cache,index,object){if(1>=cache.refs[index])return object;object=object.clone();object.name+=\"_instance_\"+cache.uses[index]++;return object}},{key:\"_invokeOne\",value:function(func){var extensions=Object.values(this.plugins);extensions.push(this);for(var i=0;i<extensions.length;i++){var result=func(extensions[i]);\nif(result)return result}return null}},{key:\"_invokeAll\",value:function(func){var extensions=Object.values(this.plugins);extensions.unshift(this);for(var pending=[],i=0;i<extensions.length;i++){var result=func(extensions[i]);result&&pending.push(result)}return pending}},{key:\"getDependency\",value:function(type,index){var cacheKey=type+\":\"+index,dependency=this.cache.get(cacheKey);if(!dependency){switch(type){case \"scene\":dependency=this.loadScene(index);break;case \"node\":dependency=this.loadNode(index);\nbreak;case \"mesh\":dependency=this._invokeOne(function(ext){return ext.loadMesh&&ext.loadMesh(index)});break;case \"accessor\":dependency=this.loadAccessor(index);break;case \"bufferView\":dependency=this._invokeOne(function(ext){return ext.loadBufferView&&ext.loadBufferView(index)});break;case \"buffer\":dependency=this.loadBuffer(index);break;case \"material\":dependency=this._invokeOne(function(ext){return ext.loadMaterial&&ext.loadMaterial(index)});break;case \"texture\":dependency=this._invokeOne(function(ext){return ext.loadTexture&&\next.loadTexture(index)});break;case \"skin\":dependency=this.loadSkin(index);break;case \"animation\":dependency=this.loadAnimation(index);break;case \"camera\":dependency=this.loadCamera(index);break;default:throw Error(\"Unknown type: \"+type);}this.cache.add(cacheKey,dependency)}return dependency}},{key:\"getDependencies\",value:function(type){var dependencies=this.cache.get(type);if(!dependencies){var parser=this;dependencies=Promise.all((this.json[type+(\"mesh\"===type?\"es\":\"s\")]||[]).map(function(def,index){return parser.getDependency(type,\nindex)}));this.cache.add(type,dependencies)}return dependencies}},{key:\"loadBuffer\",value:function(bufferIndex){var bufferDef=this.json.buffers[bufferIndex],loader=this.fileLoader;if(bufferDef.type&&\"arraybuffer\"!==bufferDef.type)throw Error(\"THREE.GLTFLoader: \"+bufferDef.type+\" buffer type is not supported.\");if(void 0===bufferDef.uri&&0===bufferIndex)return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);var options=this.options;return new Promise(function(resolve,reject){loader.load(resolveURL(bufferDef.uri,\noptions.path),resolve,void 0,function(){reject(Error('THREE.GLTFLoader: Failed to load buffer \"'+bufferDef.uri+'\".'))})})}},{key:\"loadBufferView\",value:function(bufferViewIndex){var bufferViewDef=this.json.bufferViews[bufferViewIndex];return this.getDependency(\"buffer\",bufferViewDef.buffer).then(function(buffer){var byteOffset=bufferViewDef.byteOffset||0;return buffer.slice(byteOffset,byteOffset+(bufferViewDef.byteLength||0))})}},{key:\"loadAccessor\",value:function(accessorIndex){var parser=this,json=\nthis.json,accessorDef=this.json.accessors[accessorIndex];if(void 0===accessorDef.bufferView&&void 0===accessorDef.sparse)return Promise.resolve(null);accessorIndex=[];void 0!==accessorDef.bufferView?accessorIndex.push(this.getDependency(\"bufferView\",accessorDef.bufferView)):accessorIndex.push(null);void 0!==accessorDef.sparse&&(accessorIndex.push(this.getDependency(\"bufferView\",accessorDef.sparse.indices.bufferView)),accessorIndex.push(this.getDependency(\"bufferView\",accessorDef.sparse.values.bufferView)));\nreturn Promise.all(accessorIndex).then(function(bufferViews){var bufferView=bufferViews[0],itemSize=WEBGL_TYPE_SIZES[accessorDef.type],TypedArray=WEBGL_COMPONENT_TYPES[accessorDef.componentType],elementBytes=TypedArray.BYTES_PER_ELEMENT,byteOffset=accessorDef.byteOffset||0,byteStride=void 0!==accessorDef.bufferView?json.bufferViews[accessorDef.bufferView].byteStride:void 0,normalized=!0===accessorDef.normalized;if(byteStride&&byteStride!==elementBytes*itemSize){var array=Math.floor(byteOffset/byteStride);\nvar ibCacheKey=\"InterleavedBuffer:\"+accessorDef.bufferView+\":\"+accessorDef.componentType+\":\"+array+\":\"+accessorDef.count,ib=parser.cache.get(ibCacheKey);ib||(array=new TypedArray(bufferView,array*byteStride,accessorDef.count*byteStride/elementBytes),ib=new _three.InterleavedBuffer(array,byteStride/elementBytes),parser.cache.add(ibCacheKey,ib));elementBytes=new _three.InterleavedBufferAttribute(ib,itemSize,byteOffset%byteStride/elementBytes,normalized)}else array=null===bufferView?new TypedArray(accessorDef.count*\nitemSize):new TypedArray(bufferView,byteOffset,accessorDef.count*itemSize),elementBytes=new _three.BufferAttribute(array,itemSize,normalized);if(void 0!==accessorDef.sparse)for(byteStride=accessorDef.sparse.values.byteOffset||0,byteOffset=new WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType](bufferViews[1],accessorDef.sparse.indices.byteOffset||0,accessorDef.sparse.count*WEBGL_TYPE_SIZES.SCALAR),bufferViews=new TypedArray(bufferViews[2],byteStride,accessorDef.sparse.count*itemSize),\nnull!==bufferView&&(elementBytes=new _three.BufferAttribute(elementBytes.array.slice(),elementBytes.itemSize,elementBytes.normalized)),bufferView=0,TypedArray=byteOffset.length;bufferView<TypedArray;bufferView++)if(byteStride=byteOffset[bufferView],elementBytes.setX(byteStride,bufferViews[bufferView*itemSize]),2<=itemSize&&elementBytes.setY(byteStride,bufferViews[bufferView*itemSize+1]),3<=itemSize&&elementBytes.setZ(byteStride,bufferViews[bufferView*itemSize+2]),4<=itemSize&&elementBytes.setW(byteStride,\nbufferViews[bufferView*itemSize+3]),5<=itemSize)throw Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");return elementBytes})}},{key:\"loadTexture\",value:function(textureIndex){var json=this.json,options=this.options;json=json.images[json.textures[textureIndex].source];var loader=this.textureLoader;json.uri&&(options=options.manager.getHandler(json.uri),null!==options&&(loader=options));return this.loadTextureImage(textureIndex,json,loader)}},{key:\"loadTextureImage\",value:function(textureIndex,\nsource,loader){var parser=this,json=this.json,options=this.options,textureDef=json.textures[textureIndex],cacheKey=(source.uri||source.bufferView)+\":\"+textureDef.sampler;if(this.textureCache[cacheKey])return this.textureCache[cacheKey];var URL=self.URL||self.webkitURL,sourceURI=source.uri||\"\",isObjectURL=!1,hasAlpha=!0,isJPEG=0<sourceURI.search(/\\.jpe?g($|\\?)/i)||0===sourceURI.search(/^data:image\\/jpeg/);if(\"image/jpeg\"===source.mimeType||isJPEG)hasAlpha=!1;if(void 0!==source.bufferView)sourceURI=\nparser.getDependency(\"bufferView\",source.bufferView).then(function(bufferView){if(\"image/png\"===source.mimeType){var colorType=(new DataView(bufferView,25,1)).getUint8(0,!1);hasAlpha=6===colorType||4===colorType||3===colorType}isObjectURL=!0;bufferView=new Blob([bufferView],{type:source.mimeType});return sourceURI=URL.createObjectURL(bufferView)});else if(void 0===source.uri)throw Error(\"THREE.GLTFLoader: Image \"+textureIndex+\" is missing URI and bufferView\");isJPEG=Promise.resolve(sourceURI).then(function(sourceURI){return new Promise(function(resolve,\nreject){var onLoad=resolve;!0===loader.isImageBitmapLoader&&(onLoad=function(imageBitmap){imageBitmap=new _three.Texture(imageBitmap);imageBitmap.needsUpdate=!0;resolve(imageBitmap)});loader.load(resolveURL(sourceURI,options.path),onLoad,void 0,reject)})}).then(function(texture){!0===isObjectURL&&URL.revokeObjectURL(sourceURI);texture.flipY=!1;textureDef.name&&(texture.name=textureDef.name);hasAlpha||(texture.format=_three.RGBFormat);var sampler=(json.samplers||{})[textureDef.sampler]||{};texture.magFilter=\nWEBGL_FILTERS[sampler.magFilter]||_three.LinearFilter;texture.minFilter=WEBGL_FILTERS[sampler.minFilter]||_three.LinearMipmapLinearFilter;texture.wrapS=WEBGL_WRAPPINGS[sampler.wrapS]||_three.RepeatWrapping;texture.wrapT=WEBGL_WRAPPINGS[sampler.wrapT]||_three.RepeatWrapping;parser.associations.set(texture,{type:\"textures\",index:textureIndex});return texture})[\"catch\"](function(){console.error(\"THREE.GLTFLoader: Couldn't load texture\",sourceURI);return null});return this.textureCache[cacheKey]=isJPEG}},\n{key:\"assignTexture\",value:function(materialParams,mapName,mapDef){var parser=this;return this.getDependency(\"texture\",mapDef.index).then(function(texture){void 0===mapDef.texCoord||0==mapDef.texCoord||\"aoMap\"===mapName&&1==mapDef.texCoord||console.warn(\"THREE.GLTFLoader: Custom UV set \"+mapDef.texCoord+\" for texture \"+mapName+\" not yet supported.\");if(parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){var transform=void 0!==mapDef.extensions?mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:\nvoid 0;if(transform){var gltfReference=parser.associations.get(texture);texture=parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture,transform);parser.associations.set(texture,gltfReference)}}return materialParams[mapName]=texture})}},{key:\"assignFinalMaterial\",value:function(mesh){var geometry=mesh.geometry,material=mesh.material,useVertexTangents=void 0!==geometry.attributes.tangent,useVertexColors=void 0!==geometry.attributes.color,useFlatShading=void 0===geometry.attributes.normal;\nif(mesh.isPoints){var cacheKey=\"PointsMaterial:\"+material.uuid,pointsMaterial=this.cache.get(cacheKey);pointsMaterial||(pointsMaterial=new _three.PointsMaterial,_three.Material.prototype.copy.call(pointsMaterial,material),pointsMaterial.color.copy(material.color),pointsMaterial.map=material.map,pointsMaterial.sizeAttenuation=!1,this.cache.add(cacheKey,pointsMaterial));material=pointsMaterial}else mesh.isLine&&(cacheKey=\"LineBasicMaterial:\"+material.uuid,pointsMaterial=this.cache.get(cacheKey),pointsMaterial||\n(pointsMaterial=new _three.LineBasicMaterial,_three.Material.prototype.copy.call(pointsMaterial,material),pointsMaterial.color.copy(material.color),this.cache.add(cacheKey,pointsMaterial)),material=pointsMaterial);if(useVertexTangents||useVertexColors||useFlatShading)cacheKey=\"ClonedMaterial:\"+material.uuid+\":\",material.isGLTFSpecularGlossinessMaterial&&(cacheKey+=\"specular-glossiness:\"),useVertexTangents&&(cacheKey+=\"vertex-tangents:\"),useVertexColors&&(cacheKey+=\"vertex-colors:\"),useFlatShading&&\n(cacheKey+=\"flat-shading:\"),pointsMaterial=this.cache.get(cacheKey),pointsMaterial||(pointsMaterial=material.clone(),useVertexColors&&(pointsMaterial.vertexColors=!0),useFlatShading&&(pointsMaterial.flatShading=!0),useVertexTangents&&(pointsMaterial.normalScale&&(pointsMaterial.normalScale.y*=-1),pointsMaterial.clearcoatNormalScale&&(pointsMaterial.clearcoatNormalScale.y*=-1)),this.cache.add(cacheKey,pointsMaterial),this.associations.set(pointsMaterial,this.associations.get(material))),material=pointsMaterial;\nmaterial.aoMap&&void 0===geometry.attributes.uv2&&void 0!==geometry.attributes.uv&&geometry.setAttribute(\"uv2\",geometry.attributes.uv);mesh.material=material}},{key:\"getMaterialType\",value:function(){return _three.MeshStandardMaterial}},{key:\"loadMaterial\",value:function(materialIndex){var parser=this,extensions=this.extensions,materialDef=this.json.materials[materialIndex],materialParams={},materialExtensions=materialDef.extensions||{},pending=[];if(materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){materialExtensions=\nextensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];var materialType=materialExtensions.getMaterialType();pending.push(materialExtensions.extendParams(materialParams,materialDef,parser))}else if(materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT])materialExtensions=extensions[EXTENSIONS.KHR_MATERIALS_UNLIT],materialType=materialExtensions.getMaterialType(),pending.push(materialExtensions.extendParams(materialParams,materialDef,parser));else{materialExtensions=materialDef.pbrMetallicRoughness||\n{};materialParams.color=new _three.Color(1,1,1);materialParams.opacity=1;if(Array.isArray(materialExtensions.baseColorFactor)){var array=materialExtensions.baseColorFactor;materialParams.color.fromArray(array);materialParams.opacity=array[3]}void 0!==materialExtensions.baseColorTexture&&pending.push(parser.assignTexture(materialParams,\"map\",materialExtensions.baseColorTexture));materialParams.metalness=void 0!==materialExtensions.metallicFactor?materialExtensions.metallicFactor:1;materialParams.roughness=\nvoid 0!==materialExtensions.roughnessFactor?materialExtensions.roughnessFactor:1;void 0!==materialExtensions.metallicRoughnessTexture&&(pending.push(parser.assignTexture(materialParams,\"metalnessMap\",materialExtensions.metallicRoughnessTexture)),pending.push(parser.assignTexture(materialParams,\"roughnessMap\",materialExtensions.metallicRoughnessTexture)));materialType=this._invokeOne(function(ext){return ext.getMaterialType&&ext.getMaterialType(materialIndex)});pending.push(Promise.all(this._invokeAll(function(ext){return ext.extendMaterialParams&&\next.extendMaterialParams(materialIndex,materialParams)})))}!0===materialDef.doubleSided&&(materialParams.side=_three.DoubleSide);materialExtensions=materialDef.alphaMode||\"OPAQUE\";\"BLEND\"===materialExtensions?(materialParams.transparent=!0,materialParams.depthWrite=!1):(materialParams.transparent=!1,\"MASK\"===materialExtensions&&(materialParams.alphaTest=void 0!==materialDef.alphaCutoff?materialDef.alphaCutoff:.5));void 0!==materialDef.normalTexture&&materialType!==_three.MeshBasicMaterial&&(pending.push(parser.assignTexture(materialParams,\n\"normalMap\",materialDef.normalTexture)),materialParams.normalScale=new _three.Vector2(1,-1),void 0!==materialDef.normalTexture.scale&&materialParams.normalScale.set(materialDef.normalTexture.scale,-materialDef.normalTexture.scale));void 0!==materialDef.occlusionTexture&&materialType!==_three.MeshBasicMaterial&&(pending.push(parser.assignTexture(materialParams,\"aoMap\",materialDef.occlusionTexture)),void 0!==materialDef.occlusionTexture.strength&&(materialParams.aoMapIntensity=materialDef.occlusionTexture.strength));\nvoid 0!==materialDef.emissiveFactor&&materialType!==_three.MeshBasicMaterial&&(materialParams.emissive=(new _three.Color).fromArray(materialDef.emissiveFactor));void 0!==materialDef.emissiveTexture&&materialType!==_three.MeshBasicMaterial&&pending.push(parser.assignTexture(materialParams,\"emissiveMap\",materialDef.emissiveTexture));return Promise.all(pending).then(function(){var material=materialType===GLTFMeshStandardSGMaterial?extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams):\nnew materialType(materialParams);materialDef.name&&(material.name=materialDef.name);material.map&&(material.map.encoding=_three.sRGBEncoding);material.emissiveMap&&(material.emissiveMap.encoding=_three.sRGBEncoding);assignExtrasToUserData(material,materialDef);parser.associations.set(material,{type:\"materials\",index:materialIndex});materialDef.extensions&&addUnknownExtensionsToUserData(extensions,material,materialDef);return material})}},{key:\"createUniqueName\",value:function(originalName){for(var name=\noriginalName=_three.PropertyBinding.sanitizeNodeName(originalName||\"\"),i=1;this.nodeNamesUsed[name];++i)name=originalName+\"_\"+i;this.nodeNamesUsed[name]=!0;return name}},{key:\"loadGeometries\",value:function(primitives){function createDracoPrimitive(primitive){return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive,parser).then(function(geometry){return addPrimitiveAttributes(geometry,primitive,parser)})}for(var parser=this,extensions=this.extensions,cache=this.primitiveCache,\npending=[],i=0,il=primitives.length;i<il;i++){var primitive$jscomp$0=primitives[i],cacheKey=createPrimitiveKey(primitive$jscomp$0),cached=cache[cacheKey];cached?pending.push(cached.promise):(cached=void 0,cached=primitive$jscomp$0.extensions&&primitive$jscomp$0.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?createDracoPrimitive(primitive$jscomp$0):addPrimitiveAttributes(new _three.BufferGeometry,primitive$jscomp$0,parser),cache[cacheKey]={primitive:primitive$jscomp$0,promise:cached},pending.push(cached))}return Promise.all(pending)}},\n{key:\"loadMesh\",value:function(meshIndex){for(var parser=this,extensions=this.extensions,meshDef$jscomp$0=this.json.meshes[meshIndex],primitives=meshDef$jscomp$0.primitives,pending=[],i$jscomp$0=0,il$jscomp$0=primitives.length;i$jscomp$0<il$jscomp$0;i$jscomp$0++){var material=void 0===primitives[i$jscomp$0].material?createDefaultMaterial(this.cache):this.getDependency(\"material\",primitives[i$jscomp$0].material);pending.push(material)}pending.push(parser.loadGeometries(primitives));return Promise.all(pending).then(function(results){var materials=\nresults.slice(0,results.length-1),geometries=results[results.length-1];results=[];for(var _i4=0,_il3=geometries.length;_i4<_il3;_i4++){var geometry=geometries[_i4],primitive=primitives[_i4],_material=materials[_i4];if(4===primitive.mode||5===primitive.mode||6===primitive.mode||void 0===primitive.mode)geometry=!0===meshDef$jscomp$0.isSkinnedMesh?new _three.SkinnedMesh(geometry,_material):new _three.Mesh(geometry,_material),!0!==geometry.isSkinnedMesh||geometry.geometry.attributes.skinWeight.normalized||\ngeometry.normalizeSkinWeights(),5===primitive.mode?geometry.geometry=toTrianglesDrawMode(geometry.geometry,_three.TriangleStripDrawMode):6===primitive.mode&&(geometry.geometry=toTrianglesDrawMode(geometry.geometry,_three.TriangleFanDrawMode));else if(1===primitive.mode)geometry=new _three.LineSegments(geometry,_material);else if(3===primitive.mode)geometry=new _three.Line(geometry,_material);else if(2===primitive.mode)geometry=new _three.LineLoop(geometry,_material);else if(0===primitive.mode)geometry=\nnew _three.Points(geometry,_material);else throw Error(\"THREE.GLTFLoader: Primitive mode unsupported: \"+primitive.mode);if(0<Object.keys(geometry.geometry.morphAttributes).length){_material=geometry;var meshDef=meshDef$jscomp$0;_material.updateMorphTargets();if(void 0!==meshDef.weights)for(var i=0,il=meshDef.weights.length;i<il;i++)_material.morphTargetInfluences[i]=meshDef.weights[i];if(meshDef.extras&&Array.isArray(meshDef.extras.targetNames))if(meshDef=meshDef.extras.targetNames,_material.morphTargetInfluences.length===\nmeshDef.length)for(_material.morphTargetDictionary={},i=0,il=meshDef.length;i<il;i++)_material.morphTargetDictionary[meshDef[i]]=i;else console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\")}geometry.name=parser.createUniqueName(meshDef$jscomp$0.name||\"mesh_\"+meshIndex);assignExtrasToUserData(geometry,meshDef$jscomp$0);primitive.extensions&&addUnknownExtensionsToUserData(extensions,geometry,primitive);parser.assignFinalMaterial(geometry);results.push(geometry)}if(1===\nresults.length)return results[0];materials=new _three.Group;geometries=0;for(_i4=results.length;geometries<_i4;geometries++)materials.add(results[geometries]);return materials})}},{key:\"loadCamera\",value:function(cameraIndex){var camera;cameraIndex=this.json.cameras[cameraIndex];var params=cameraIndex[cameraIndex.type];if(params)return\"perspective\"===cameraIndex.type?camera=new _three.PerspectiveCamera(_three.MathUtils.radToDeg(params.yfov),params.aspectRatio||1,params.znear||1,params.zfar||2E6):\n\"orthographic\"===cameraIndex.type&&(camera=new _three.OrthographicCamera(-params.xmag,params.xmag,params.ymag,-params.ymag,params.znear,params.zfar)),cameraIndex.name&&(camera.name=this.createUniqueName(cameraIndex.name)),assignExtrasToUserData(camera,cameraIndex),Promise.resolve(camera);console.warn(\"THREE.GLTFLoader: Missing camera parameters.\")}},{key:\"loadSkin\",value:function(skinIndex){skinIndex=this.json.skins[skinIndex];var skinEntry={joints:skinIndex.joints};return void 0===skinIndex.inverseBindMatrices?\nPromise.resolve(skinEntry):this.getDependency(\"accessor\",skinIndex.inverseBindMatrices).then(function(accessor){skinEntry.inverseBindMatrices=accessor;return skinEntry})}},{key:\"loadAnimation\",value:function(animationIndex){for(var animationDef=this.json.animations[animationIndex],pendingNodes=[],pendingInputAccessors=[],pendingOutputAccessors=[],pendingSamplers=[],pendingTargets=[],i=0,il=animationDef.channels.length;i<il;i++){var channel=animationDef.channels[i],sampler$jscomp$0=animationDef.samplers[channel.sampler];\nchannel=channel.target;var input=void 0!==animationDef.parameters?animationDef.parameters[sampler$jscomp$0.input]:sampler$jscomp$0.input,output=void 0!==animationDef.parameters?animationDef.parameters[sampler$jscomp$0.output]:sampler$jscomp$0.output;pendingNodes.push(this.getDependency(\"node\",void 0!==channel.node?channel.node:channel.id));pendingInputAccessors.push(this.getDependency(\"accessor\",input));pendingOutputAccessors.push(this.getDependency(\"accessor\",output));pendingSamplers.push(sampler$jscomp$0);\npendingTargets.push(channel)}return Promise.all([Promise.all(pendingNodes),Promise.all(pendingInputAccessors),Promise.all(pendingOutputAccessors),Promise.all(pendingSamplers),Promise.all(pendingTargets)]).then(function(dependencies){var nodes=dependencies[0],inputAccessors=dependencies[1],outputAccessors=dependencies[2],samplers=dependencies[3],targets=dependencies[4],tracks=[];dependencies=function(_i6,_il5){var node=nodes[_i6];_il5=inputAccessors[_i6];var outputAccessor=outputAccessors[_i6],sampler=\nsamplers[_i6];_i6=targets[_i6];if(void 0===node)return\"continue\";node.updateMatrix();node.matrixAutoUpdate=!0;var TypedKeyframeTrack=void 0;switch(PATH_PROPERTIES[_i6.path]){case PATH_PROPERTIES.weights:TypedKeyframeTrack=_three.NumberKeyframeTrack;break;case PATH_PROPERTIES.rotation:TypedKeyframeTrack=_three.QuaternionKeyframeTrack;break;default:TypedKeyframeTrack=_three.VectorKeyframeTrack}var targetName=node.name?node.name:node.uuid,interpolation=void 0!==sampler.interpolation?INTERPOLATION[sampler.interpolation]:\n_three.InterpolateLinear,targetNames=[];PATH_PROPERTIES[_i6.path]===PATH_PROPERTIES.weights?node.traverse(function(object){!0===object.isMesh&&object.morphTargetInfluences&&targetNames.push(object.name?object.name:object.uuid)}):targetNames.push(targetName);node=outputAccessor.array;if(outputAccessor.normalized){outputAccessor=getNormalizedComponentScale(node.constructor);targetName=new Float32Array(node.length);for(var j=0,jl=node.length;j<jl;j++)targetName[j]=node[j]*outputAccessor;node=targetName}outputAccessor=\n0;for(targetName=targetNames.length;outputAccessor<targetName;outputAccessor++)j=new TypedKeyframeTrack(targetNames[outputAccessor]+\".\"+PATH_PROPERTIES[_i6.path],_il5.array,node,interpolation),\"CUBICSPLINE\"===sampler.interpolation&&(j.createInterpolant=function(result){return new GLTFCubicSplineInterpolant(this.times,this.values,this.getValueSize()/3,result)},j.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),tracks.push(j)};for(var _i6$jscomp$0=0,_il5$jscomp$0=nodes.length;_i6$jscomp$0<\n_il5$jscomp$0;_i6$jscomp$0++)dependencies(_i6$jscomp$0,_il5$jscomp$0);return new _three.AnimationClip(animationDef.name?animationDef.name:\"animation_\"+animationIndex,void 0,tracks)})}},{key:\"createNodeMesh\",value:function(nodeIndex){var parser=this,nodeDef=this.json.nodes[nodeIndex];return void 0===nodeDef.mesh?null:parser.getDependency(\"mesh\",nodeDef.mesh).then(function(mesh){mesh=parser._getNodeRef(parser.meshCache,nodeDef.mesh,mesh);void 0!==nodeDef.weights&&mesh.traverse(function(o){if(o.isMesh)for(var i=\n0,il=nodeDef.weights.length;i<il;i++)o.morphTargetInfluences[i]=nodeDef.weights[i]});return mesh})}},{key:\"loadNode\",value:function(nodeIndex){var extensions=this.extensions,parser=this,nodeDef=this.json.nodes[nodeIndex],nodeName=nodeDef.name?parser.createUniqueName(nodeDef.name):\"\";return function(){var pending=[],meshPromise=parser._invokeOne(function(ext){return ext.createNodeMesh&&ext.createNodeMesh(nodeIndex)});meshPromise&&pending.push(meshPromise);void 0!==nodeDef.camera&&pending.push(parser.getDependency(\"camera\",\nnodeDef.camera).then(function(camera){return parser._getNodeRef(parser.cameraCache,nodeDef.camera,camera)}));parser._invokeAll(function(ext){return ext.createNodeAttachment&&ext.createNodeAttachment(nodeIndex)}).forEach(function(promise){pending.push(promise)});return Promise.all(pending)}().then(function(objects){var node=!0===nodeDef.isBone?new _three.Bone:1<objects.length?new _three.Group:1===objects.length?objects[0]:new _three.Object3D;if(node!==objects[0])for(var i=0,il=objects.length;i<il;i++)node.add(objects[i]);\nnodeDef.name&&(node.userData.name=nodeDef.name,node.name=nodeName);assignExtrasToUserData(node,nodeDef);nodeDef.extensions&&addUnknownExtensionsToUserData(extensions,node,nodeDef);void 0!==nodeDef.matrix?(objects=new _three.Matrix4,objects.fromArray(nodeDef.matrix),node.applyMatrix4(objects)):(void 0!==nodeDef.translation&&node.position.fromArray(nodeDef.translation),void 0!==nodeDef.rotation&&node.quaternion.fromArray(nodeDef.rotation),void 0!==nodeDef.scale&&node.scale.fromArray(nodeDef.scale));\nparser.associations.set(node,{type:\"nodes\",index:nodeIndex});return node})}},{key:\"loadScene\",value:function(sceneIndex){var json=this.json,extensions=this.extensions;sceneIndex=this.json.scenes[sceneIndex];var scene=new _three.Group;sceneIndex.name&&(scene.name=this.createUniqueName(sceneIndex.name));assignExtrasToUserData(scene,sceneIndex);sceneIndex.extensions&&addUnknownExtensionsToUserData(extensions,scene,sceneIndex);extensions=sceneIndex.nodes||[];sceneIndex=[];for(var i=0,il=extensions.length;i<\nil;i++)sceneIndex.push(buildNodeHierachy(extensions[i],scene,json,this));return Promise.all(sceneIndex).then(function(){return scene})}}]);return GLTFParser}()}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$GLTFLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GLTFLoader = void 0;\n\nvar _three = require(\"three\");\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar GLTFLoader =\n/*#__PURE__*/\nfunction (_Loader) {\n  _inherits(GLTFLoader, _Loader);\n\n  function GLTFLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, GLTFLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTFLoader).call(this, manager));\n    _this.dracoLoader = null;\n    _this.ktx2Loader = null;\n    _this.meshoptDecoder = null;\n    _this.pluginCallbacks = [];\n\n    _this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n\n    _this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n\n    _this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n\n    _this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n\n    _this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n\n    _this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n\n    _this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n\n    _this.register(function (parser) {\n      return new GLTFLightsExtension(parser);\n    });\n\n    _this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n\n    return _this;\n  }\n\n  _createClass(GLTFLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var resourcePath;\n\n      if (this.resourcePath !== '') {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== '') {\n        resourcePath = this.path;\n      } else {\n        resourcePath = _three.LoaderUtils.extractUrlBase(url);\n      } // Tells the LoadingManager to track an extra item, which resolves after\n      // the model is fully loaded. This means the count of items loaded will\n      // be incorrect, but ensures manager.onLoad() does not fire early.\n\n\n      this.manager.itemStart(url);\n\n      var _onError = function _onError(e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      };\n\n      var loader = new _three.FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          scope.parse(data, resourcePath, function (gltf) {\n            onLoad(gltf);\n            scope.manager.itemEnd(url);\n          }, _onError);\n        } catch (e) {\n          _onError(e);\n        }\n      }, onProgress, _onError);\n    }\n  }, {\n    key: \"setDRACOLoader\",\n    value: function setDRACOLoader(dracoLoader) {\n      this.dracoLoader = dracoLoader;\n      return this;\n    }\n  }, {\n    key: \"setDDSLoader\",\n    value: function setDDSLoader() {\n      throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n    }\n  }, {\n    key: \"setKTX2Loader\",\n    value: function setKTX2Loader(ktx2Loader) {\n      this.ktx2Loader = ktx2Loader;\n      return this;\n    }\n  }, {\n    key: \"setMeshoptDecoder\",\n    value: function setMeshoptDecoder(meshoptDecoder) {\n      this.meshoptDecoder = meshoptDecoder;\n      return this;\n    }\n  }, {\n    key: \"register\",\n    value: function register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, path, onLoad, onError) {\n      var content;\n      var extensions = {};\n      var plugins = {};\n\n      if (typeof data === 'string') {\n        content = data;\n      } else {\n        var magic = _three.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n          try {\n            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n          } catch (error) {\n            if (onError) onError(error);\n            return;\n          }\n\n          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n        } else {\n          content = _three.LoaderUtils.decodeText(new Uint8Array(data));\n        }\n      }\n\n      var json = JSON.parse(content);\n\n      if (json.asset === undefined || json.asset.version[0] < 2) {\n        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\n        return;\n      }\n\n      var parser = new GLTFParser(json, {\n        path: path || this.resourcePath || '',\n        crossOrigin: this.crossOrigin,\n        requestHeader: this.requestHeader,\n        manager: this.manager,\n        ktx2Loader: this.ktx2Loader,\n        meshoptDecoder: this.meshoptDecoder\n      });\n      parser.fileLoader.setRequestHeader(this.requestHeader);\n\n      for (var i = 0; i < this.pluginCallbacks.length; i++) {\n        var plugin = this.pluginCallbacks[i](parser);\n        plugins[plugin.name] = plugin; // Workaround to avoid determining as unknown extension\n        // in addUnknownExtensionsToUserData().\n        // Remove this workaround if we move all the existing\n        // extension handlers to plugin system\n\n        extensions[plugin.name] = true;\n      }\n\n      if (json.extensionsUsed) {\n        for (var _i = 0; _i < json.extensionsUsed.length; ++_i) {\n          var extensionName = json.extensionsUsed[_i];\n          var extensionsRequired = json.extensionsRequired || [];\n\n          switch (extensionName) {\n            case EXTENSIONS.KHR_MATERIALS_UNLIT:\n              extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n              break;\n\n            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n              break;\n\n            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n              extensions[extensionName] = new GLTFTextureTransformExtension();\n              break;\n\n            case EXTENSIONS.KHR_MESH_QUANTIZATION:\n              extensions[extensionName] = new GLTFMeshQuantizationExtension();\n              break;\n\n            default:\n              if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n                console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n              }\n\n          }\n        }\n      }\n\n      parser.setExtensions(extensions);\n      parser.setPlugins(plugins);\n      parser.parse(onLoad, onError);\n    }\n  }]);\n\n  return GLTFLoader;\n}(_three.Loader);\n/* GLTFREGISTRY */\n\n\nexports.GLTFLoader = GLTFLoader;\n\nfunction GLTFRegistry() {\n  var objects = {};\n  return {\n    get: function get(key) {\n      return objects[key];\n    },\n    add: function add(key, object) {\n      objects[key] = object;\n    },\n    remove: function remove(key) {\n      delete objects[key];\n    },\n    removeAll: function removeAll() {\n      objects = {};\n    }\n  };\n}\n/*********************************/\n\n/********** EXTENSIONS ***********/\n\n/*********************************/\n\n\nvar EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\n};\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\n\nvar GLTFLightsExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFLightsExtension(parser) {\n    _classCallCheck(this, GLTFLightsExtension);\n\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // Object3D instance caches\n\n    this.cache = {\n      refs: {},\n      uses: {}\n    };\n  }\n\n  _createClass(GLTFLightsExtension, [{\n    key: \"_markDefs\",\n    value: function _markDefs() {\n      var parser = this.parser;\n      var nodeDefs = this.parser.json.nodes || [];\n\n      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n        var nodeDef = nodeDefs[nodeIndex];\n\n        if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n          parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n        }\n      }\n    }\n  }, {\n    key: \"_loadLight\",\n    value: function _loadLight(lightIndex) {\n      var parser = this.parser;\n      var cacheKey = 'light:' + lightIndex;\n      var dependency = parser.cache.get(cacheKey);\n      if (dependency) return dependency;\n      var json = parser.json;\n      var extensions = json.extensions && json.extensions[this.name] || {};\n      var lightDefs = extensions.lights || [];\n      var lightDef = lightDefs[lightIndex];\n      var lightNode;\n      var color = new _three.Color(0xffffff);\n      if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n      var range = lightDef.range !== undefined ? lightDef.range : 0;\n\n      switch (lightDef.type) {\n        case 'directional':\n          lightNode = new _three.DirectionalLight(color);\n          lightNode.target.position.set(0, 0, -1);\n          lightNode.add(lightNode.target);\n          break;\n\n        case 'point':\n          lightNode = new _three.PointLight(color);\n          lightNode.distance = range;\n          break;\n\n        case 'spot':\n          lightNode = new _three.SpotLight(color);\n          lightNode.distance = range; // Handle spotlight properties.\n\n          lightDef.spot = lightDef.spot || {};\n          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n          lightNode.angle = lightDef.spot.outerConeAngle;\n          lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n          lightNode.target.position.set(0, 0, -1);\n          lightNode.add(lightNode.target);\n          break;\n\n        default:\n          throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);\n      } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n      // here, because node-level parsing will only override position if explicitly specified.\n\n\n      lightNode.position.set(0, 0, 0);\n      lightNode.decay = 2;\n      if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n      lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);\n      dependency = Promise.resolve(lightNode);\n      parser.cache.add(cacheKey, dependency);\n      return dependency;\n    }\n  }, {\n    key: \"createNodeAttachment\",\n    value: function createNodeAttachment(nodeIndex) {\n      var self = this;\n      var parser = this.parser;\n      var json = parser.json;\n      var nodeDef = json.nodes[nodeIndex];\n      var lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n      var lightIndex = lightDef.light;\n      if (lightIndex === undefined) return null;\n      return this._loadLight(lightIndex).then(function (light) {\n        return parser._getNodeRef(self.cache, lightIndex, light);\n      });\n    }\n  }]);\n\n  return GLTFLightsExtension;\n}();\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\n\n\nvar GLTFMaterialsUnlitExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFMaterialsUnlitExtension() {\n    _classCallCheck(this, GLTFMaterialsUnlitExtension);\n\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  _createClass(GLTFMaterialsUnlitExtension, [{\n    key: \"getMaterialType\",\n    value: function getMaterialType() {\n      return _three.MeshBasicMaterial;\n    }\n  }, {\n    key: \"extendParams\",\n    value: function extendParams(materialParams, materialDef, parser) {\n      var pending = [];\n      materialParams.color = new _three.Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n      var metallicRoughness = materialDef.pbrMetallicRoughness;\n\n      if (metallicRoughness) {\n        if (Array.isArray(metallicRoughness.baseColorFactor)) {\n          var array = metallicRoughness.baseColorFactor;\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n        }\n\n        if (metallicRoughness.baseColorTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n        }\n      }\n\n      return Promise.all(pending);\n    }\n  }]);\n\n  return GLTFMaterialsUnlitExtension;\n}();\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\n\n\nvar GLTFMaterialsClearcoatExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFMaterialsClearcoatExtension(parser) {\n    _classCallCheck(this, GLTFMaterialsClearcoatExtension);\n\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n\n  _createClass(GLTFMaterialsClearcoatExtension, [{\n    key: \"getMaterialType\",\n    value: function getMaterialType(materialIndex) {\n      var parser = this.parser;\n      var materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n      return _three.MeshPhysicalMaterial;\n    }\n  }, {\n    key: \"extendMaterialParams\",\n    value: function extendMaterialParams(materialIndex, materialParams) {\n      var parser = this.parser;\n      var materialDef = parser.json.materials[materialIndex];\n\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n        return Promise.resolve();\n      }\n\n      var pending = [];\n      var extension = materialDef.extensions[this.name];\n\n      if (extension.clearcoatFactor !== undefined) {\n        materialParams.clearcoat = extension.clearcoatFactor;\n      }\n\n      if (extension.clearcoatTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));\n      }\n\n      if (extension.clearcoatRoughnessFactor !== undefined) {\n        materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n      }\n\n      if (extension.clearcoatRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));\n      }\n\n      if (extension.clearcoatNormalTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));\n\n        if (extension.clearcoatNormalTexture.scale !== undefined) {\n          var scale = extension.clearcoatNormalTexture.scale; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n          materialParams.clearcoatNormalScale = new _three.Vector2(scale, -scale);\n        }\n      }\n\n      return Promise.all(pending);\n    }\n  }]);\n\n  return GLTFMaterialsClearcoatExtension;\n}();\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\n\n\nvar GLTFMaterialsTransmissionExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFMaterialsTransmissionExtension(parser) {\n    _classCallCheck(this, GLTFMaterialsTransmissionExtension);\n\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n\n  _createClass(GLTFMaterialsTransmissionExtension, [{\n    key: \"getMaterialType\",\n    value: function getMaterialType(materialIndex) {\n      var parser = this.parser;\n      var materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n      return _three.MeshPhysicalMaterial;\n    }\n  }, {\n    key: \"extendMaterialParams\",\n    value: function extendMaterialParams(materialIndex, materialParams) {\n      var parser = this.parser;\n      var materialDef = parser.json.materials[materialIndex];\n\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n        return Promise.resolve();\n      }\n\n      var pending = [];\n      var extension = materialDef.extensions[this.name];\n\n      if (extension.transmissionFactor !== undefined) {\n        materialParams.transmission = extension.transmissionFactor;\n      }\n\n      if (extension.transmissionTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));\n      }\n\n      return Promise.all(pending);\n    }\n  }]);\n\n  return GLTFMaterialsTransmissionExtension;\n}();\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\n\n\nvar GLTFMaterialsVolumeExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFMaterialsVolumeExtension(parser) {\n    _classCallCheck(this, GLTFMaterialsVolumeExtension);\n\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n\n  _createClass(GLTFMaterialsVolumeExtension, [{\n    key: \"getMaterialType\",\n    value: function getMaterialType(materialIndex) {\n      var parser = this.parser;\n      var materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n      return _three.MeshPhysicalMaterial;\n    }\n  }, {\n    key: \"extendMaterialParams\",\n    value: function extendMaterialParams(materialIndex, materialParams) {\n      var parser = this.parser;\n      var materialDef = parser.json.materials[materialIndex];\n\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n        return Promise.resolve();\n      }\n\n      var pending = [];\n      var extension = materialDef.extensions[this.name];\n      materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n      if (extension.thicknessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));\n      }\n\n      materialParams.attenuationDistance = extension.attenuationDistance || 0;\n      var colorArray = extension.attenuationColor || [1, 1, 1];\n      materialParams.attenuationTint = new _three.Color(colorArray[0], colorArray[1], colorArray[2]);\n      return Promise.all(pending);\n    }\n  }]);\n\n  return GLTFMaterialsVolumeExtension;\n}();\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\n\n\nvar GLTFMaterialsIorExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFMaterialsIorExtension(parser) {\n    _classCallCheck(this, GLTFMaterialsIorExtension);\n\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n\n  _createClass(GLTFMaterialsIorExtension, [{\n    key: \"getMaterialType\",\n    value: function getMaterialType(materialIndex) {\n      var parser = this.parser;\n      var materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n      return _three.MeshPhysicalMaterial;\n    }\n  }, {\n    key: \"extendMaterialParams\",\n    value: function extendMaterialParams(materialIndex, materialParams) {\n      var parser = this.parser;\n      var materialDef = parser.json.materials[materialIndex];\n\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n        return Promise.resolve();\n      }\n\n      var extension = materialDef.extensions[this.name];\n      materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n      return Promise.resolve();\n    }\n  }]);\n\n  return GLTFMaterialsIorExtension;\n}();\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\n\n\nvar GLTFMaterialsSpecularExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFMaterialsSpecularExtension(parser) {\n    _classCallCheck(this, GLTFMaterialsSpecularExtension);\n\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n\n  _createClass(GLTFMaterialsSpecularExtension, [{\n    key: \"getMaterialType\",\n    value: function getMaterialType(materialIndex) {\n      var parser = this.parser;\n      var materialDef = parser.json.materials[materialIndex];\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n      return _three.MeshPhysicalMaterial;\n    }\n  }, {\n    key: \"extendMaterialParams\",\n    value: function extendMaterialParams(materialIndex, materialParams) {\n      var parser = this.parser;\n      var materialDef = parser.json.materials[materialIndex];\n\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n        return Promise.resolve();\n      }\n\n      var pending = [];\n      var extension = materialDef.extensions[this.name];\n      materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n      if (extension.specularTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));\n      }\n\n      var colorArray = extension.specularColorFactor || [1, 1, 1];\n      materialParams.specularTint = new _three.Color(colorArray[0], colorArray[1], colorArray[2]);\n\n      if (extension.specularColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'specularTintMap', extension.specularColorTexture).then(function (texture) {\n          texture.encoding = _three.sRGBEncoding;\n        }));\n      }\n\n      return Promise.all(pending);\n    }\n  }]);\n\n  return GLTFMaterialsSpecularExtension;\n}();\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\n\n\nvar GLTFTextureBasisUExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFTextureBasisUExtension(parser) {\n    _classCallCheck(this, GLTFTextureBasisUExtension);\n\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n\n  _createClass(GLTFTextureBasisUExtension, [{\n    key: \"loadTexture\",\n    value: function loadTexture(textureIndex) {\n      var parser = this.parser;\n      var json = parser.json;\n      var textureDef = json.textures[textureIndex];\n\n      if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n        return null;\n      }\n\n      var extension = textureDef.extensions[this.name];\n      var source = json.images[extension.source];\n      var loader = parser.options.ktx2Loader;\n\n      if (!loader) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');\n        } else {\n          // Assumes that the extension is optional and that a fallback texture is present\n          return null;\n        }\n      }\n\n      return parser.loadTextureImage(textureIndex, source, loader);\n    }\n  }]);\n\n  return GLTFTextureBasisUExtension;\n}();\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\n\n\nvar GLTFTextureWebPExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFTextureWebPExtension(parser) {\n    _classCallCheck(this, GLTFTextureWebPExtension);\n\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n\n  _createClass(GLTFTextureWebPExtension, [{\n    key: \"loadTexture\",\n    value: function loadTexture(textureIndex) {\n      var name = this.name;\n      var parser = this.parser;\n      var json = parser.json;\n      var textureDef = json.textures[textureIndex];\n\n      if (!textureDef.extensions || !textureDef.extensions[name]) {\n        return null;\n      }\n\n      var extension = textureDef.extensions[name];\n      var source = json.images[extension.source];\n      var loader = parser.textureLoader;\n\n      if (source.uri) {\n        var handler = parser.options.manager.getHandler(source.uri);\n        if (handler !== null) loader = handler;\n      }\n\n      return this.detectSupport().then(function (isSupported) {\n        if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);\n\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n          throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');\n        } // Fall back to PNG or JPEG.\n\n\n        return parser.loadTexture(textureIndex);\n      });\n    }\n  }, {\n    key: \"detectSupport\",\n    value: function detectSupport() {\n      if (!this.isSupported) {\n        this.isSupported = new Promise(function (resolve) {\n          var image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all\n          // WebP images, unfortunately.\n\n          image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n          image.onload = image.onerror = function () {\n            resolve(image.height === 1);\n          };\n        });\n      }\n\n      return this.isSupported;\n    }\n  }]);\n\n  return GLTFTextureWebPExtension;\n}();\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\n\n\nvar GLTFMeshoptCompression =\n/*#__PURE__*/\nfunction () {\n  function GLTFMeshoptCompression(parser) {\n    _classCallCheck(this, GLTFMeshoptCompression);\n\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n\n  _createClass(GLTFMeshoptCompression, [{\n    key: \"loadBufferView\",\n    value: function loadBufferView(index) {\n      var json = this.parser.json;\n      var bufferView = json.bufferViews[index];\n\n      if (bufferView.extensions && bufferView.extensions[this.name]) {\n        var extensionDef = bufferView.extensions[this.name];\n        var buffer = this.parser.getDependency('buffer', extensionDef.buffer);\n        var decoder = this.parser.options.meshoptDecoder;\n\n        if (!decoder || !decoder.supported) {\n          if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n            throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');\n          } else {\n            // Assumes that the extension is optional and that fallback buffer data is present\n            return null;\n          }\n        }\n\n        return Promise.all([buffer, decoder.ready]).then(function (res) {\n          var byteOffset = extensionDef.byteOffset || 0;\n          var byteLength = extensionDef.byteLength || 0;\n          var count = extensionDef.count;\n          var stride = extensionDef.byteStride;\n          var result = new ArrayBuffer(count * stride);\n          var source = new Uint8Array(res[0], byteOffset, byteLength);\n          decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n          return result;\n        });\n      } else {\n        return null;\n      }\n    }\n  }]);\n\n  return GLTFMeshoptCompression;\n}();\n/* BINARY EXTENSION */\n\n\nvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nvar BINARY_EXTENSION_HEADER_LENGTH = 12;\nvar BINARY_EXTENSION_CHUNK_TYPES = {\n  JSON: 0x4e4f534a,\n  BIN: 0x004e4942\n};\n\nvar GLTFBinaryExtension = function GLTFBinaryExtension(data) {\n  _classCallCheck(this, GLTFBinaryExtension);\n\n  this.name = EXTENSIONS.KHR_BINARY_GLTF;\n  this.content = null;\n  this.body = null;\n  var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n  this.header = {\n    magic: _three.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n    version: headerView.getUint32(4, true),\n    length: headerView.getUint32(8, true)\n  };\n\n  if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n    throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n  } else if (this.header.version < 2.0) {\n    throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\n  }\n\n  var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n  var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n  var chunkIndex = 0;\n\n  while (chunkIndex < chunkContentsLength) {\n    var chunkLength = chunkView.getUint32(chunkIndex, true);\n    chunkIndex += 4;\n    var chunkType = chunkView.getUint32(chunkIndex, true);\n    chunkIndex += 4;\n\n    if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n      var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n      this.content = _three.LoaderUtils.decodeText(contentArray);\n    } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n      var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n      this.body = data.slice(byteOffset, byteOffset + chunkLength);\n    } // Clients must ignore chunks with unknown types.\n\n\n    chunkIndex += chunkLength;\n  }\n\n  if (this.content === null) {\n    throw new Error('THREE.GLTFLoader: JSON content not found.');\n  }\n};\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\n\n\nvar GLTFDracoMeshCompressionExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {\n    _classCallCheck(this, GLTFDracoMeshCompressionExtension);\n\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n\n  _createClass(GLTFDracoMeshCompressionExtension, [{\n    key: \"decodePrimitive\",\n    value: function decodePrimitive(primitive, parser) {\n      var json = this.json;\n      var dracoLoader = this.dracoLoader;\n      var bufferViewIndex = primitive.extensions[this.name].bufferView;\n      var gltfAttributeMap = primitive.extensions[this.name].attributes;\n      var threeAttributeMap = {};\n      var attributeNormalizedMap = {};\n      var attributeTypeMap = {};\n\n      for (var attributeName in gltfAttributeMap) {\n        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n      }\n\n      for (var _attributeName in primitive.attributes) {\n        var _threeAttributeName = ATTRIBUTES[_attributeName] || _attributeName.toLowerCase();\n\n        if (gltfAttributeMap[_attributeName] !== undefined) {\n          var accessorDef = json.accessors[primitive.attributes[_attributeName]];\n          var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n          attributeTypeMap[_threeAttributeName] = componentType;\n          attributeNormalizedMap[_threeAttributeName] = accessorDef.normalized === true;\n        }\n      }\n\n      return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n        return new Promise(function (resolve) {\n          dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n            for (var _attributeName2 in geometry.attributes) {\n              var attribute = geometry.attributes[_attributeName2];\n              var normalized = attributeNormalizedMap[_attributeName2];\n              if (normalized !== undefined) attribute.normalized = normalized;\n            }\n\n            resolve(geometry);\n          }, threeAttributeMap, attributeTypeMap);\n        });\n      });\n    }\n  }]);\n\n  return GLTFDracoMeshCompressionExtension;\n}();\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\n\n\nvar GLTFTextureTransformExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFTextureTransformExtension() {\n    _classCallCheck(this, GLTFTextureTransformExtension);\n\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  _createClass(GLTFTextureTransformExtension, [{\n    key: \"extendTexture\",\n    value: function extendTexture(texture, transform) {\n      if (transform.texCoord !== undefined) {\n        console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n      }\n\n      if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {\n        // See https://github.com/mrdoob/three.js/issues/21819.\n        return texture;\n      }\n\n      texture = texture.clone();\n\n      if (transform.offset !== undefined) {\n        texture.offset.fromArray(transform.offset);\n      }\n\n      if (transform.rotation !== undefined) {\n        texture.rotation = transform.rotation;\n      }\n\n      if (transform.scale !== undefined) {\n        texture.repeat.fromArray(transform.scale);\n      }\n\n      texture.needsUpdate = true;\n      return texture;\n    }\n  }]);\n\n  return GLTFTextureTransformExtension;\n}();\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n */\n\n/**\n * A sub class of StandardMaterial with some of the functionality\n * changed via the `onBeforeCompile` callback\n * @pailhead\n */\n\n\nvar GLTFMeshStandardSGMaterial =\n/*#__PURE__*/\nfunction (_MeshStandardMaterial) {\n  _inherits(GLTFMeshStandardSGMaterial, _MeshStandardMaterial);\n\n  function GLTFMeshStandardSGMaterial(params) {\n    var _this2;\n\n    _classCallCheck(this, GLTFMeshStandardSGMaterial);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(GLTFMeshStandardSGMaterial).call(this));\n    _this2.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing\n\n    var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n    var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n    var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n    var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n    var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\\n');\n    var uniforms = {\n      specular: {\n        value: new _three.Color().setHex(0xffffff)\n      },\n      glossiness: {\n        value: 1\n      },\n      specularMap: {\n        value: null\n      },\n      glossinessMap: {\n        value: null\n      }\n    };\n    _this2._extraUniforms = uniforms;\n\n    _this2.onBeforeCompile = function (shader) {\n      for (var uniformName in uniforms) {\n        shader.uniforms[uniformName] = uniforms[uniformName];\n      }\n\n      shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n    };\n\n    Object.defineProperties(_assertThisInitialized(_this2), {\n      specular: {\n        get: function get() {\n          return uniforms.specular.value;\n        },\n        set: function set(v) {\n          uniforms.specular.value = v;\n        }\n      },\n      specularMap: {\n        get: function get() {\n          return uniforms.specularMap.value;\n        },\n        set: function set(v) {\n          uniforms.specularMap.value = v;\n\n          if (v) {\n            this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\n          } else {\n            delete this.defines.USE_SPECULARMAP;\n          }\n        }\n      },\n      glossiness: {\n        get: function get() {\n          return uniforms.glossiness.value;\n        },\n        set: function set(v) {\n          uniforms.glossiness.value = v;\n        }\n      },\n      glossinessMap: {\n        get: function get() {\n          return uniforms.glossinessMap.value;\n        },\n        set: function set(v) {\n          uniforms.glossinessMap.value = v;\n\n          if (v) {\n            this.defines.USE_GLOSSINESSMAP = '';\n            this.defines.USE_UV = '';\n          } else {\n            delete this.defines.USE_GLOSSINESSMAP;\n            delete this.defines.USE_UV;\n          }\n        }\n      }\n    });\n    delete _this2.metalness;\n    delete _this2.roughness;\n    delete _this2.metalnessMap;\n    delete _this2.roughnessMap;\n\n    _this2.setValues(params);\n\n    return _this2;\n  }\n\n  _createClass(GLTFMeshStandardSGMaterial, [{\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(GLTFMeshStandardSGMaterial.prototype), \"copy\", this).call(this, source);\n\n      this.specularMap = source.specularMap;\n      this.specular.copy(source.specular);\n      this.glossinessMap = source.glossinessMap;\n      this.glossiness = source.glossiness;\n      delete this.metalness;\n      delete this.roughness;\n      delete this.metalnessMap;\n      delete this.roughnessMap;\n      return this;\n    }\n  }]);\n\n  return GLTFMeshStandardSGMaterial;\n}(_three.MeshStandardMaterial);\n\nvar GLTFMaterialsPbrSpecularGlossinessExtension =\n/*#__PURE__*/\nfunction () {\n  function GLTFMaterialsPbrSpecularGlossinessExtension() {\n    _classCallCheck(this, GLTFMaterialsPbrSpecularGlossinessExtension);\n\n    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n    this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];\n  }\n\n  _createClass(GLTFMaterialsPbrSpecularGlossinessExtension, [{\n    key: \"getMaterialType\",\n    value: function getMaterialType() {\n      return GLTFMeshStandardSGMaterial;\n    }\n  }, {\n    key: \"extendParams\",\n    value: function extendParams(materialParams, materialDef, parser) {\n      var pbrSpecularGlossiness = materialDef.extensions[this.name];\n      materialParams.color = new _three.Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n      var pending = [];\n\n      if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n        var array = pbrSpecularGlossiness.diffuseFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n      }\n\n      materialParams.emissive = new _three.Color(0.0, 0.0, 0.0);\n      materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n      materialParams.specular = new _three.Color(1.0, 1.0, 1.0);\n\n      if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n        materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n      }\n\n      if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n        var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n        pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n        pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n      }\n\n      return Promise.all(pending);\n    }\n  }, {\n    key: \"createMaterial\",\n    value: function createMaterial(materialParams) {\n      var material = new GLTFMeshStandardSGMaterial(materialParams);\n      material.fog = true;\n      material.color = materialParams.color;\n      material.map = materialParams.map === undefined ? null : materialParams.map;\n      material.lightMap = null;\n      material.lightMapIntensity = 1.0;\n      material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n      material.aoMapIntensity = 1.0;\n      material.emissive = materialParams.emissive;\n      material.emissiveIntensity = 1.0;\n      material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n      material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n      material.bumpScale = 1;\n      material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n      material.normalMapType = _three.TangentSpaceNormalMap;\n      if (materialParams.normalScale) material.normalScale = materialParams.normalScale;\n      material.displacementMap = null;\n      material.displacementScale = 1;\n      material.displacementBias = 0;\n      material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n      material.specular = materialParams.specular;\n      material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n      material.glossiness = materialParams.glossiness;\n      material.alphaMap = null;\n      material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n      material.envMapIntensity = 1.0;\n      material.refractionRatio = 0.98;\n      return material;\n    }\n  }]);\n\n  return GLTFMaterialsPbrSpecularGlossinessExtension;\n}();\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\n\n\nvar GLTFMeshQuantizationExtension = function GLTFMeshQuantizationExtension() {\n  _classCallCheck(this, GLTFMeshQuantizationExtension);\n\n  this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n};\n/*********************************/\n\n/********** INTERPOLATION ********/\n\n/*********************************/\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\nvar GLTFCubicSplineInterpolant =\n/*#__PURE__*/\nfunction (_Interpolant) {\n  _inherits(GLTFCubicSplineInterpolant, _Interpolant);\n\n  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    _classCallCheck(this, GLTFCubicSplineInterpolant);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GLTFCubicSplineInterpolant).call(this, parameterPositions, sampleValues, sampleSize, resultBuffer));\n  }\n\n  _createClass(GLTFCubicSplineInterpolant, [{\n    key: \"copySampleValue_\",\n    value: function copySampleValue_(index) {\n      // Copies a sample value to the result buffer. See description of glTF\n      // CUBICSPLINE values layout in interpolate_() function below.\n      var result = this.resultBuffer,\n          values = this.sampleValues,\n          valueSize = this.valueSize,\n          offset = index * valueSize * 3 + valueSize;\n\n      for (var i = 0; i !== valueSize; i++) {\n        result[i] = values[offset + i];\n      }\n\n      return result;\n    }\n  }]);\n\n  return GLTFCubicSplineInterpolant;\n}(_three.Interpolant);\n\nGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\nGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n  var result = this.resultBuffer;\n  var values = this.sampleValues;\n  var stride = this.valueSize;\n  var stride2 = stride * 2;\n  var stride3 = stride * 3;\n  var td = t1 - t0;\n  var p = (t - t0) / td;\n  var pp = p * p;\n  var ppp = pp * p;\n  var offset1 = i1 * stride3;\n  var offset0 = offset1 - stride3;\n  var s2 = -2 * ppp + 3 * pp;\n  var s3 = ppp - pp;\n  var s0 = 1 - s2;\n  var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\n  //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n  for (var i = 0; i !== stride; i++) {\n    var p0 = values[offset0 + i + stride]; // splineVertex_k\n\n    var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n    var p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n    var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n  }\n\n  return result;\n};\n/*********************************/\n\n/********** INTERNALS ************/\n\n/*********************************/\n\n/* CONSTANTS */\n\n\nvar WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nvar WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nvar WEBGL_FILTERS = {\n  9728: _three.NearestFilter,\n  9729: _three.LinearFilter,\n  9984: _three.NearestMipmapNearestFilter,\n  9985: _three.LinearMipmapNearestFilter,\n  9986: _three.NearestMipmapLinearFilter,\n  9987: _three.LinearMipmapLinearFilter\n};\nvar WEBGL_WRAPPINGS = {\n  33071: _three.ClampToEdgeWrapping,\n  33648: _three.MirroredRepeatWrapping,\n  10497: _three.RepeatWrapping\n};\nvar WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nvar ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  TEXCOORD_0: 'uv',\n  TEXCOORD_1: 'uv2',\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex'\n};\nvar PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences'\n};\nvar INTERPOLATION = {\n  CUBICSPLINE: undefined,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: _three.InterpolateLinear,\n  STEP: _three.InterpolateDiscrete\n};\nvar ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND'\n};\n/* UTILITY FUNCTIONS */\n\nfunction resolveURL(url, path) {\n  // Invalid URL\n  if (typeof url !== 'string' || url === '') return ''; // Host Relative URL\n\n  if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n    path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n  } // Absolute URL http://,https://,//\n\n\n  if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n  if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n  if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n  return path + url;\n}\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\n\n\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new _three.MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: _three.FrontSide\n    });\n  }\n\n  return cache['DefaultMaterial'];\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n  for (var name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\n\n\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (_typeof(gltfDef.extras) === 'object') {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n    }\n  }\n}\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\n\n\nfunction addMorphTargets(geometry, targets, parser) {\n  var hasMorphPosition = false;\n  var hasMorphNormal = false;\n\n  for (var i = 0, il = targets.length; i < il; i++) {\n    var target = targets[i];\n    if (target.POSITION !== undefined) hasMorphPosition = true;\n    if (target.NORMAL !== undefined) hasMorphNormal = true;\n    if (hasMorphPosition && hasMorphNormal) break;\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n  var pendingPositionAccessors = [];\n  var pendingNormalAccessors = [];\n\n  for (var _i2 = 0, _il = targets.length; _i2 < _il; _i2++) {\n    var _target = targets[_i2];\n\n    if (hasMorphPosition) {\n      var pendingAccessor = _target.POSITION !== undefined ? parser.getDependency('accessor', _target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n\n    if (hasMorphNormal) {\n      var _pendingAccessor = _target.NORMAL !== undefined ? parser.getDependency('accessor', _target.NORMAL) : geometry.attributes.normal;\n\n      pendingNormalAccessors.push(_pendingAccessor);\n    }\n  }\n\n  return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\n    var morphPositions = accessors[0];\n    var morphNormals = accessors[1];\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\n\n\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n\n  if (meshDef.weights !== undefined) {\n    for (var i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    var targetNames = meshDef.extras.targetNames;\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n\n      for (var _i3 = 0, _il2 = targetNames.length; _i3 < _il2; _i3++) {\n        mesh.morphTargetDictionary[targetNames[_i3]] = _i3;\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  var geometryKey;\n\n  if (dracoExtension) {\n    geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n  }\n\n  return geometryKey;\n}\n\nfunction createAttributesKey(attributes) {\n  var attributesKey = '';\n  var keys = Object.keys(attributes).sort();\n\n  for (var i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n  }\n\n  return attributesKey;\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n\n    case Uint8Array:\n      return 1 / 255;\n\n    case Int16Array:\n      return 1 / 32767;\n\n    case Uint16Array:\n      return 1 / 65535;\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');\n  }\n}\n/* GLTF PARSER */\n\n\nvar GLTFParser =\n/*#__PURE__*/\nfunction () {\n  function GLTFParser() {\n    var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, GLTFParser);\n\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options; // loader object cache\n\n    this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements\n\n    this.associations = new Map(); // BufferGeometry caching\n\n    this.primitiveCache = {}; // Object3D instance caches\n\n    this.meshCache = {\n      refs: {},\n      uses: {}\n    };\n    this.cameraCache = {\n      refs: {},\n      uses: {}\n    };\n    this.lightCache = {\n      refs: {},\n      uses: {}\n    };\n    this.textureCache = {}; // Track node names, to ensure no duplicates\n\n    this.nodeNamesUsed = {}; // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {\n      this.textureLoader = new _three.ImageBitmapLoader(this.options.manager);\n    } else {\n      this.textureLoader = new _three.TextureLoader(this.options.manager);\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new _three.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n\n  _createClass(GLTFParser, [{\n    key: \"setExtensions\",\n    value: function setExtensions(extensions) {\n      this.extensions = extensions;\n    }\n  }, {\n    key: \"setPlugins\",\n    value: function setPlugins(plugins) {\n      this.plugins = plugins;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(onLoad, onError) {\n      var parser = this;\n      var json = this.json;\n      var extensions = this.extensions; // Clear the loader cache\n\n      this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n      this._invokeAll(function (ext) {\n        return ext._markDefs && ext._markDefs();\n      });\n\n      Promise.all(this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      })).then(function () {\n        return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);\n      }).then(function (dependencies) {\n        var result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {}\n        };\n        addUnknownExtensionsToUserData(extensions, result, json);\n        assignExtrasToUserData(result, json);\n        Promise.all(parser._invokeAll(function (ext) {\n          return ext.afterRoot && ext.afterRoot(result);\n        })).then(function () {\n          onLoad(result);\n        });\n      })[\"catch\"](onError);\n    }\n    /**\n     * Marks the special nodes/meshes in json for efficient parse.\n     */\n\n  }, {\n    key: \"_markDefs\",\n    value: function _markDefs() {\n      var nodeDefs = this.json.nodes || [];\n      var skinDefs = this.json.skins || [];\n      var meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a Bone or an\n      // Object3D. Use the skins' joint references to mark bones.\n\n      for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n        var joints = skinDefs[skinIndex].joints;\n\n        for (var i = 0, il = joints.length; i < il; i++) {\n          nodeDefs[joints[i]].isBone = true;\n        }\n      } // Iterate over all nodes, marking references to shared resources,\n      // as well as skeleton joints.\n\n\n      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n        var nodeDef = nodeDefs[nodeIndex];\n\n        if (nodeDef.mesh !== undefined) {\n          this._addNodeRef(this.meshCache, nodeDef.mesh); // Nothing in the mesh definition indicates whether it is\n          // a SkinnedMesh or Mesh. Use the node's mesh reference\n          // to mark SkinnedMesh if node has skin.\n\n\n          if (nodeDef.skin !== undefined) {\n            meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n          }\n        }\n\n        if (nodeDef.camera !== undefined) {\n          this._addNodeRef(this.cameraCache, nodeDef.camera);\n        }\n      }\n    }\n    /**\n     * Counts references to shared node / Object3D resources. These resources\n     * can be reused, or \"instantiated\", at multiple nodes in the scene\n     * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n     * be marked. Non-scenegraph resources (like Materials, Geometries, and\n     * Textures) can be reused directly and are not marked here.\n     *\n     * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n     */\n\n  }, {\n    key: \"_addNodeRef\",\n    value: function _addNodeRef(cache, index) {\n      if (index === undefined) return;\n\n      if (cache.refs[index] === undefined) {\n        cache.refs[index] = cache.uses[index] = 0;\n      }\n\n      cache.refs[index]++;\n    }\n    /** Returns a reference to a shared resource, cloning it if necessary. */\n\n  }, {\n    key: \"_getNodeRef\",\n    value: function _getNodeRef(cache, index, object) {\n      if (cache.refs[index] <= 1) return object;\n      var ref = object.clone();\n      ref.name += '_instance_' + cache.uses[index]++;\n      return ref;\n    }\n  }, {\n    key: \"_invokeOne\",\n    value: function _invokeOne(func) {\n      var extensions = Object.values(this.plugins);\n      extensions.push(this);\n\n      for (var i = 0; i < extensions.length; i++) {\n        var result = func(extensions[i]);\n        if (result) return result;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_invokeAll\",\n    value: function _invokeAll(func) {\n      var extensions = Object.values(this.plugins);\n      extensions.unshift(this);\n      var pending = [];\n\n      for (var i = 0; i < extensions.length; i++) {\n        var result = func(extensions[i]);\n        if (result) pending.push(result);\n      }\n\n      return pending;\n    }\n    /**\n     * Requests the specified dependency asynchronously, with caching.\n     * @param {string} type\n     * @param {number} index\n     * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n     */\n\n  }, {\n    key: \"getDependency\",\n    value: function getDependency(type, index) {\n      var cacheKey = type + ':' + index;\n      var dependency = this.cache.get(cacheKey);\n\n      if (!dependency) {\n        switch (type) {\n          case 'scene':\n            dependency = this.loadScene(index);\n            break;\n\n          case 'node':\n            dependency = this.loadNode(index);\n            break;\n\n          case 'mesh':\n            dependency = this._invokeOne(function (ext) {\n              return ext.loadMesh && ext.loadMesh(index);\n            });\n            break;\n\n          case 'accessor':\n            dependency = this.loadAccessor(index);\n            break;\n\n          case 'bufferView':\n            dependency = this._invokeOne(function (ext) {\n              return ext.loadBufferView && ext.loadBufferView(index);\n            });\n            break;\n\n          case 'buffer':\n            dependency = this.loadBuffer(index);\n            break;\n\n          case 'material':\n            dependency = this._invokeOne(function (ext) {\n              return ext.loadMaterial && ext.loadMaterial(index);\n            });\n            break;\n\n          case 'texture':\n            dependency = this._invokeOne(function (ext) {\n              return ext.loadTexture && ext.loadTexture(index);\n            });\n            break;\n\n          case 'skin':\n            dependency = this.loadSkin(index);\n            break;\n\n          case 'animation':\n            dependency = this.loadAnimation(index);\n            break;\n\n          case 'camera':\n            dependency = this.loadCamera(index);\n            break;\n\n          default:\n            throw new Error('Unknown type: ' + type);\n        }\n\n        this.cache.add(cacheKey, dependency);\n      }\n\n      return dependency;\n    }\n    /**\n     * Requests all dependencies of the specified type asynchronously, with caching.\n     * @param {string} type\n     * @return {Promise<Array<Object>>}\n     */\n\n  }, {\n    key: \"getDependencies\",\n    value: function getDependencies(type) {\n      var dependencies = this.cache.get(type);\n\n      if (!dependencies) {\n        var parser = this;\n        var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n        dependencies = Promise.all(defs.map(function (def, index) {\n          return parser.getDependency(type, index);\n        }));\n        this.cache.add(type, dependencies);\n      }\n\n      return dependencies;\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n     * @param {number} bufferIndex\n     * @return {Promise<ArrayBuffer>}\n     */\n\n  }, {\n    key: \"loadBuffer\",\n    value: function loadBuffer(bufferIndex) {\n      var bufferDef = this.json.buffers[bufferIndex];\n      var loader = this.fileLoader;\n\n      if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n        throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n      } // If present, GLB container is required to be the first buffer.\n\n\n      if (bufferDef.uri === undefined && bufferIndex === 0) {\n        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n      }\n\n      var options = this.options;\n      return new Promise(function (resolve, reject) {\n        loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n          reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n        });\n      });\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n     * @param {number} bufferViewIndex\n     * @return {Promise<ArrayBuffer>}\n     */\n\n  }, {\n    key: \"loadBufferView\",\n    value: function loadBufferView(bufferViewIndex) {\n      var bufferViewDef = this.json.bufferViews[bufferViewIndex];\n      return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n        var byteLength = bufferViewDef.byteLength || 0;\n        var byteOffset = bufferViewDef.byteOffset || 0;\n        return buffer.slice(byteOffset, byteOffset + byteLength);\n      });\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n     * @param {number} accessorIndex\n     * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n     */\n\n  }, {\n    key: \"loadAccessor\",\n    value: function loadAccessor(accessorIndex) {\n      var parser = this;\n      var json = this.json;\n      var accessorDef = this.json.accessors[accessorIndex];\n\n      if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n        // Ignore empty accessors, which may be used to declare runtime\n        // information about attributes coming from another source (e.g. Draco\n        // compression extension).\n        return Promise.resolve(null);\n      }\n\n      var pendingBufferViews = [];\n\n      if (accessorDef.bufferView !== undefined) {\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n      } else {\n        pendingBufferViews.push(null);\n      }\n\n      if (accessorDef.sparse !== undefined) {\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n      }\n\n      return Promise.all(pendingBufferViews).then(function (bufferViews) {\n        var bufferView = bufferViews[0];\n        var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n        var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n        var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n        var itemBytes = elementBytes * itemSize;\n        var byteOffset = accessorDef.byteOffset || 0;\n        var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n        var normalized = accessorDef.normalized === true;\n        var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n        if (byteStride && byteStride !== itemBytes) {\n          // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n          // This makes sure that IBA.count reflects accessor.count properly\n          var ibSlice = Math.floor(byteOffset / byteStride);\n          var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n          var ib = parser.cache.get(ibCacheKey);\n\n          if (!ib) {\n            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n            ib = new _three.InterleavedBuffer(array, byteStride / elementBytes);\n            parser.cache.add(ibCacheKey, ib);\n          }\n\n          bufferAttribute = new _three.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n        } else {\n          if (bufferView === null) {\n            array = new TypedArray(accessorDef.count * itemSize);\n          } else {\n            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n          }\n\n          bufferAttribute = new _three.BufferAttribute(array, itemSize, normalized);\n        } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n        if (accessorDef.sparse !== undefined) {\n          var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n          var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n          var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n          var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n          var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n          var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n          if (bufferView !== null) {\n            // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n            bufferAttribute = new _three.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n          }\n\n          for (var i = 0, il = sparseIndices.length; i < il; i++) {\n            var index = sparseIndices[i];\n            bufferAttribute.setX(index, sparseValues[i * itemSize]);\n            if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n            if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n            if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n            if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n          }\n        }\n\n        return bufferAttribute;\n      });\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n     * @param {number} textureIndex\n     * @return {Promise<THREE.Texture>}\n     */\n\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture(textureIndex) {\n      var json = this.json;\n      var options = this.options;\n      var textureDef = json.textures[textureIndex];\n      var source = json.images[textureDef.source];\n      var loader = this.textureLoader;\n\n      if (source.uri) {\n        var handler = options.manager.getHandler(source.uri);\n        if (handler !== null) loader = handler;\n      }\n\n      return this.loadTextureImage(textureIndex, source, loader);\n    }\n  }, {\n    key: \"loadTextureImage\",\n    value: function loadTextureImage(textureIndex, source, loader) {\n      var parser = this;\n      var json = this.json;\n      var options = this.options;\n      var textureDef = json.textures[textureIndex];\n      var cacheKey = (source.uri || source.bufferView) + ':' + textureDef.sampler;\n\n      if (this.textureCache[cacheKey]) {\n        // See https://github.com/mrdoob/three.js/issues/21559.\n        return this.textureCache[cacheKey];\n      }\n\n      var URL = self.URL || self.webkitURL;\n      var sourceURI = source.uri || '';\n      var isObjectURL = false;\n      var hasAlpha = true;\n      var isJPEG = sourceURI.search(/\\.jpe?g($|\\?)/i) > 0 || sourceURI.search(/^data\\:image\\/jpeg/) === 0;\n      if (source.mimeType === 'image/jpeg' || isJPEG) hasAlpha = false;\n\n      if (source.bufferView !== undefined) {\n        // Load binary image data from bufferView, if provided.\n        sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n          if (source.mimeType === 'image/png') {\n            // Inspect the PNG 'IHDR' chunk to determine whether the image could have an\n            // alpha channel. This check is conservative — the image could have an alpha\n            // channel with all values == 1, and the indexed type (colorType == 3) only\n            // sometimes contains alpha.\n            //\n            // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\n            var colorType = new DataView(bufferView, 25, 1).getUint8(0, false);\n            hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\n          }\n\n          isObjectURL = true;\n          var blob = new Blob([bufferView], {\n            type: source.mimeType\n          });\n          sourceURI = URL.createObjectURL(blob);\n          return sourceURI;\n        });\n      } else if (source.uri === undefined) {\n        throw new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView');\n      }\n\n      var promise = Promise.resolve(sourceURI).then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          var onLoad = resolve;\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function onLoad(imageBitmap) {\n              var texture = new _three.Texture(imageBitmap);\n              texture.needsUpdate = true;\n              resolve(texture);\n            };\n          }\n\n          loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);\n        });\n      }).then(function (texture) {\n        // Clean up resources and configure Texture.\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI);\n        }\n\n        texture.flipY = false;\n        if (textureDef.name) texture.name = textureDef.name; // When there is definitely no alpha channel in the texture, set RGBFormat to save space.\n\n        if (!hasAlpha) texture.format = _three.RGBFormat;\n        var samplers = json.samplers || {};\n        var sampler = samplers[textureDef.sampler] || {};\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || _three.LinearFilter;\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || _three.LinearMipmapLinearFilter;\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || _three.RepeatWrapping;\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || _three.RepeatWrapping;\n        parser.associations.set(texture, {\n          type: 'textures',\n          index: textureIndex\n        });\n        return texture;\n      })[\"catch\"](function () {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n        return null;\n      });\n      this.textureCache[cacheKey] = promise;\n      return promise;\n    }\n    /**\n     * Asynchronously assigns a texture to the given material parameters.\n     * @param {Object} materialParams\n     * @param {string} mapName\n     * @param {Object} mapDef\n     * @return {Promise<Texture>}\n     */\n\n  }, {\n    key: \"assignTexture\",\n    value: function assignTexture(materialParams, mapName, mapDef) {\n      var parser = this;\n      return this.getDependency('texture', mapDef.index).then(function (texture) {\n        // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n        // However, we will copy UV set 0 to UV set 1 on demand for aoMap\n        if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\n          console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\n        }\n\n        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n          var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n          if (transform) {\n            var gltfReference = parser.associations.get(texture);\n            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n            parser.associations.set(texture, gltfReference);\n          }\n        }\n\n        materialParams[mapName] = texture;\n        return texture;\n      });\n    }\n    /**\n     * Assigns final material to a Mesh, Line, or Points instance. The instance\n     * already has a material (generated from the glTF material options alone)\n     * but reuse of the same glTF material may require multiple threejs materials\n     * to accommodate different primitive types, defines, etc. New materials will\n     * be created if necessary, and reused from a cache.\n     * @param  {Object3D} mesh Mesh, Line, or Points instance.\n     */\n\n  }, {\n    key: \"assignFinalMaterial\",\n    value: function assignFinalMaterial(mesh) {\n      var geometry = mesh.geometry;\n      var material = mesh.material;\n      var useVertexTangents = geometry.attributes.tangent !== undefined;\n      var useVertexColors = geometry.attributes.color !== undefined;\n      var useFlatShading = geometry.attributes.normal === undefined;\n\n      if (mesh.isPoints) {\n        var cacheKey = 'PointsMaterial:' + material.uuid;\n        var pointsMaterial = this.cache.get(cacheKey);\n\n        if (!pointsMaterial) {\n          pointsMaterial = new _three.PointsMaterial();\n\n          _three.Material.prototype.copy.call(pointsMaterial, material);\n\n          pointsMaterial.color.copy(material.color);\n          pointsMaterial.map = material.map;\n          pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n          this.cache.add(cacheKey, pointsMaterial);\n        }\n\n        material = pointsMaterial;\n      } else if (mesh.isLine) {\n        var _cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n        var lineMaterial = this.cache.get(_cacheKey);\n\n        if (!lineMaterial) {\n          lineMaterial = new _three.LineBasicMaterial();\n\n          _three.Material.prototype.copy.call(lineMaterial, material);\n\n          lineMaterial.color.copy(material.color);\n          this.cache.add(_cacheKey, lineMaterial);\n        }\n\n        material = lineMaterial;\n      } // Clone the material if it will be modified\n\n\n      if (useVertexTangents || useVertexColors || useFlatShading) {\n        var _cacheKey2 = 'ClonedMaterial:' + material.uuid + ':';\n\n        if (material.isGLTFSpecularGlossinessMaterial) _cacheKey2 += 'specular-glossiness:';\n        if (useVertexTangents) _cacheKey2 += 'vertex-tangents:';\n        if (useVertexColors) _cacheKey2 += 'vertex-colors:';\n        if (useFlatShading) _cacheKey2 += 'flat-shading:';\n        var cachedMaterial = this.cache.get(_cacheKey2);\n\n        if (!cachedMaterial) {\n          cachedMaterial = material.clone();\n          if (useVertexColors) cachedMaterial.vertexColors = true;\n          if (useFlatShading) cachedMaterial.flatShading = true;\n\n          if (useVertexTangents) {\n            // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n            if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n            if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n          }\n\n          this.cache.add(_cacheKey2, cachedMaterial);\n          this.associations.set(cachedMaterial, this.associations.get(material));\n        }\n\n        material = cachedMaterial;\n      } // workarounds for mesh and geometry\n\n\n      if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n        geometry.setAttribute('uv2', geometry.attributes.uv);\n      }\n\n      mesh.material = material;\n    }\n  }, {\n    key: \"getMaterialType\",\n    value: function getMaterialType()\n    /* materialIndex */\n    {\n      return _three.MeshStandardMaterial;\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n     * @param {number} materialIndex\n     * @return {Promise<Material>}\n     */\n\n  }, {\n    key: \"loadMaterial\",\n    value: function loadMaterial(materialIndex) {\n      var parser = this;\n      var json = this.json;\n      var extensions = this.extensions;\n      var materialDef = json.materials[materialIndex];\n      var materialType;\n      var materialParams = {};\n      var materialExtensions = materialDef.extensions || {};\n      var pending = [];\n\n      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n        var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n        materialType = sgExtension.getMaterialType();\n        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n      } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n        var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n        materialType = kmuExtension.getMaterialType();\n        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n      } else {\n        // Specification:\n        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n        var metallicRoughness = materialDef.pbrMetallicRoughness || {};\n        materialParams.color = new _three.Color(1.0, 1.0, 1.0);\n        materialParams.opacity = 1.0;\n\n        if (Array.isArray(metallicRoughness.baseColorFactor)) {\n          var array = metallicRoughness.baseColorFactor;\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n        }\n\n        if (metallicRoughness.baseColorTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n        }\n\n        materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n        materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n        if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n          pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n        }\n\n        materialType = this._invokeOne(function (ext) {\n          return ext.getMaterialType && ext.getMaterialType(materialIndex);\n        });\n        pending.push(Promise.all(this._invokeAll(function (ext) {\n          return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n        })));\n      }\n\n      if (materialDef.doubleSided === true) {\n        materialParams.side = _three.DoubleSide;\n      }\n\n      var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n      if (alphaMode === ALPHA_MODES.BLEND) {\n        materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706\n\n        materialParams.depthWrite = false;\n      } else {\n        materialParams.transparent = false;\n\n        if (alphaMode === ALPHA_MODES.MASK) {\n          materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n        }\n      }\n\n      if (materialDef.normalTexture !== undefined && materialType !== _three.MeshBasicMaterial) {\n        pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture)); // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n        materialParams.normalScale = new _three.Vector2(1, -1);\n\n        if (materialDef.normalTexture.scale !== undefined) {\n          materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);\n        }\n      }\n\n      if (materialDef.occlusionTexture !== undefined && materialType !== _three.MeshBasicMaterial) {\n        pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n        if (materialDef.occlusionTexture.strength !== undefined) {\n          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n        }\n      }\n\n      if (materialDef.emissiveFactor !== undefined && materialType !== _three.MeshBasicMaterial) {\n        materialParams.emissive = new _three.Color().fromArray(materialDef.emissiveFactor);\n      }\n\n      if (materialDef.emissiveTexture !== undefined && materialType !== _three.MeshBasicMaterial) {\n        pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n      }\n\n      return Promise.all(pending).then(function () {\n        var material;\n\n        if (materialType === GLTFMeshStandardSGMaterial) {\n          material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n        } else {\n          material = new materialType(materialParams);\n        }\n\n        if (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\n        if (material.map) material.map.encoding = _three.sRGBEncoding;\n        if (material.emissiveMap) material.emissiveMap.encoding = _three.sRGBEncoding;\n        assignExtrasToUserData(material, materialDef);\n        parser.associations.set(material, {\n          type: 'materials',\n          index: materialIndex\n        });\n        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n        return material;\n      });\n    }\n    /** When Object3D instances are targeted by animation, they need unique names. */\n\n  }, {\n    key: \"createUniqueName\",\n    value: function createUniqueName(originalName) {\n      var sanitizedName = _three.PropertyBinding.sanitizeNodeName(originalName || '');\n\n      var name = sanitizedName;\n\n      for (var i = 1; this.nodeNamesUsed[name]; ++i) {\n        name = sanitizedName + '_' + i;\n      }\n\n      this.nodeNamesUsed[name] = true;\n      return name;\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n     *\n     * Creates BufferGeometries from primitives.\n     *\n     * @param {Array<GLTF.Primitive>} primitives\n     * @return {Promise<Array<BufferGeometry>>}\n     */\n\n  }, {\n    key: \"loadGeometries\",\n    value: function loadGeometries(primitives) {\n      var parser = this;\n      var extensions = this.extensions;\n      var cache = this.primitiveCache;\n\n      function createDracoPrimitive(primitive) {\n        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser);\n        });\n      }\n\n      var pending = [];\n\n      for (var i = 0, il = primitives.length; i < il; i++) {\n        var primitive = primitives[i];\n        var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n        var cached = cache[cacheKey];\n\n        if (cached) {\n          // Use the cached geometry if it exists\n          pending.push(cached.promise);\n        } else {\n          var geometryPromise = void 0;\n\n          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n            // Use DRACO geometry if available\n            geometryPromise = createDracoPrimitive(primitive);\n          } else {\n            // Otherwise create a new geometry\n            geometryPromise = addPrimitiveAttributes(new _three.BufferGeometry(), primitive, parser);\n          } // Cache this geometry\n\n\n          cache[cacheKey] = {\n            primitive: primitive,\n            promise: geometryPromise\n          };\n          pending.push(geometryPromise);\n        }\n      }\n\n      return Promise.all(pending);\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n     * @param {number} meshIndex\n     * @return {Promise<Group|Mesh|SkinnedMesh>}\n     */\n\n  }, {\n    key: \"loadMesh\",\n    value: function loadMesh(meshIndex) {\n      var parser = this;\n      var json = this.json;\n      var extensions = this.extensions;\n      var meshDef = json.meshes[meshIndex];\n      var primitives = meshDef.primitives;\n      var pending = [];\n\n      for (var i = 0, il = primitives.length; i < il; i++) {\n        var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\n        pending.push(material);\n      }\n\n      pending.push(parser.loadGeometries(primitives));\n      return Promise.all(pending).then(function (results) {\n        var materials = results.slice(0, results.length - 1);\n        var geometries = results[results.length - 1];\n        var meshes = [];\n\n        for (var _i4 = 0, _il3 = geometries.length; _i4 < _il3; _i4++) {\n          var geometry = geometries[_i4];\n          var primitive = primitives[_i4]; // 1. create Mesh\n\n          var mesh = void 0;\n          var _material = materials[_i4];\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n            // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n            mesh = meshDef.isSkinnedMesh === true ? new _three.SkinnedMesh(geometry, _material) : new _three.Mesh(geometry, _material);\n\n            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n              // we normalize floating point skin weight array to fix malformed assets (see #15319)\n              // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n              mesh.normalizeSkinWeights();\n            }\n\n            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n              mesh.geometry = toTrianglesDrawMode(mesh.geometry, _three.TriangleStripDrawMode);\n            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n              mesh.geometry = toTrianglesDrawMode(mesh.geometry, _three.TriangleFanDrawMode);\n            }\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n            mesh = new _three.LineSegments(geometry, _material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n            mesh = new _three.Line(geometry, _material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n            mesh = new _three.LineLoop(geometry, _material);\n          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n            mesh = new _three.Points(geometry, _material);\n          } else {\n            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n          }\n\n          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n            updateMorphTargets(mesh, meshDef);\n          }\n\n          mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);\n          assignExtrasToUserData(mesh, meshDef);\n          if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n          parser.assignFinalMaterial(mesh);\n          meshes.push(mesh);\n        }\n\n        if (meshes.length === 1) {\n          return meshes[0];\n        }\n\n        var group = new _three.Group();\n\n        for (var _i5 = 0, _il4 = meshes.length; _i5 < _il4; _i5++) {\n          group.add(meshes[_i5]);\n        }\n\n        return group;\n      });\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n     * @param {number} cameraIndex\n     * @return {Promise<THREE.Camera>}\n     */\n\n  }, {\n    key: \"loadCamera\",\n    value: function loadCamera(cameraIndex) {\n      var camera;\n      var cameraDef = this.json.cameras[cameraIndex];\n      var params = cameraDef[cameraDef.type];\n\n      if (!params) {\n        console.warn('THREE.GLTFLoader: Missing camera parameters.');\n        return;\n      }\n\n      if (cameraDef.type === 'perspective') {\n        camera = new _three.PerspectiveCamera(_three.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n      } else if (cameraDef.type === 'orthographic') {\n        camera = new _three.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n      }\n\n      if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n      assignExtrasToUserData(camera, cameraDef);\n      return Promise.resolve(camera);\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n     * @param {number} skinIndex\n     * @return {Promise<Object>}\n     */\n\n  }, {\n    key: \"loadSkin\",\n    value: function loadSkin(skinIndex) {\n      var skinDef = this.json.skins[skinIndex];\n      var skinEntry = {\n        joints: skinDef.joints\n      };\n\n      if (skinDef.inverseBindMatrices === undefined) {\n        return Promise.resolve(skinEntry);\n      }\n\n      return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n        skinEntry.inverseBindMatrices = accessor;\n        return skinEntry;\n      });\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n     * @param {number} animationIndex\n     * @return {Promise<AnimationClip>}\n     */\n\n  }, {\n    key: \"loadAnimation\",\n    value: function loadAnimation(animationIndex) {\n      var json = this.json;\n      var animationDef = json.animations[animationIndex];\n      var pendingNodes = [];\n      var pendingInputAccessors = [];\n      var pendingOutputAccessors = [];\n      var pendingSamplers = [];\n      var pendingTargets = [];\n\n      for (var i = 0, il = animationDef.channels.length; i < il; i++) {\n        var channel = animationDef.channels[i];\n        var sampler = animationDef.samplers[channel.sampler];\n        var target = channel.target;\n        var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n        var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n        var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n        pendingNodes.push(this.getDependency('node', name));\n        pendingInputAccessors.push(this.getDependency('accessor', input));\n        pendingOutputAccessors.push(this.getDependency('accessor', output));\n        pendingSamplers.push(sampler);\n        pendingTargets.push(target);\n      }\n\n      return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n        var nodes = dependencies[0];\n        var inputAccessors = dependencies[1];\n        var outputAccessors = dependencies[2];\n        var samplers = dependencies[3];\n        var targets = dependencies[4];\n        var tracks = [];\n\n        var _loop = function _loop(_i6, _il5) {\n          var node = nodes[_i6];\n          var inputAccessor = inputAccessors[_i6];\n          var outputAccessor = outputAccessors[_i6];\n          var sampler = samplers[_i6];\n          var target = targets[_i6];\n          if (node === undefined) return \"continue\";\n          node.updateMatrix();\n          node.matrixAutoUpdate = true;\n          var TypedKeyframeTrack = void 0;\n\n          switch (PATH_PROPERTIES[target.path]) {\n            case PATH_PROPERTIES.weights:\n              TypedKeyframeTrack = _three.NumberKeyframeTrack;\n              break;\n\n            case PATH_PROPERTIES.rotation:\n              TypedKeyframeTrack = _three.QuaternionKeyframeTrack;\n              break;\n\n            case PATH_PROPERTIES.position:\n            case PATH_PROPERTIES.scale:\n            default:\n              TypedKeyframeTrack = _three.VectorKeyframeTrack;\n              break;\n          }\n\n          var targetName = node.name ? node.name : node.uuid;\n          var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : _three.InterpolateLinear;\n          var targetNames = [];\n\n          if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n            // Node may be a Group (glTF mesh with several primitives) or a Mesh.\n            node.traverse(function (object) {\n              if (object.isMesh === true && object.morphTargetInfluences) {\n                targetNames.push(object.name ? object.name : object.uuid);\n              }\n            });\n          } else {\n            targetNames.push(targetName);\n          }\n\n          var outputArray = outputAccessor.array;\n\n          if (outputAccessor.normalized) {\n            var scale = getNormalizedComponentScale(outputArray.constructor);\n            var scaled = new Float32Array(outputArray.length);\n\n            for (var j = 0, jl = outputArray.length; j < jl; j++) {\n              scaled[j] = outputArray[j] * scale;\n            }\n\n            outputArray = scaled;\n          }\n\n          for (var _j = 0, _jl = targetNames.length; _j < _jl; _j++) {\n            var track = new TypedKeyframeTrack(targetNames[_j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\n\n            if (sampler.interpolation === 'CUBICSPLINE') {\n              track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n                // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n                // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n                // must be divided by three to get the interpolant's sampleSize argument.\n                return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n              }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n\n              track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n            }\n\n            tracks.push(track);\n          }\n        };\n\n        for (var _i6 = 0, _il5 = nodes.length; _i6 < _il5; _i6++) {\n          var _ret = _loop(_i6, _il5);\n\n          if (_ret === \"continue\") continue;\n        }\n\n        var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n        return new _three.AnimationClip(name, undefined, tracks);\n      });\n    }\n  }, {\n    key: \"createNodeMesh\",\n    value: function createNodeMesh(nodeIndex) {\n      var json = this.json;\n      var parser = this;\n      var nodeDef = json.nodes[nodeIndex];\n      if (nodeDef.mesh === undefined) return null;\n      return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n        var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh); // if weights are provided on the node, override weights on the mesh.\n\n\n        if (nodeDef.weights !== undefined) {\n          node.traverse(function (o) {\n            if (!o.isMesh) return;\n\n            for (var i = 0, il = nodeDef.weights.length; i < il; i++) {\n              o.morphTargetInfluences[i] = nodeDef.weights[i];\n            }\n          });\n        }\n\n        return node;\n      });\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n     * @param {number} nodeIndex\n     * @return {Promise<Object3D>}\n     */\n\n  }, {\n    key: \"loadNode\",\n    value: function loadNode(nodeIndex) {\n      var json = this.json;\n      var extensions = this.extensions;\n      var parser = this;\n      var nodeDef = json.nodes[nodeIndex]; // reserve node's name before its dependencies, so the root has the intended name.\n\n      var nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';\n      return function () {\n        var pending = [];\n\n        var meshPromise = parser._invokeOne(function (ext) {\n          return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n        });\n\n        if (meshPromise) {\n          pending.push(meshPromise);\n        }\n\n        if (nodeDef.camera !== undefined) {\n          pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n            return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n          }));\n        }\n\n        parser._invokeAll(function (ext) {\n          return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n        }).forEach(function (promise) {\n          pending.push(promise);\n        });\n\n        return Promise.all(pending);\n      }().then(function (objects) {\n        var node; // .isBone isn't in glTF spec. See ._markDefs\n\n        if (nodeDef.isBone === true) {\n          node = new _three.Bone();\n        } else if (objects.length > 1) {\n          node = new _three.Group();\n        } else if (objects.length === 1) {\n          node = objects[0];\n        } else {\n          node = new _three.Object3D();\n        }\n\n        if (node !== objects[0]) {\n          for (var i = 0, il = objects.length; i < il; i++) {\n            node.add(objects[i]);\n          }\n        }\n\n        if (nodeDef.name) {\n          node.userData.name = nodeDef.name;\n          node.name = nodeName;\n        }\n\n        assignExtrasToUserData(node, nodeDef);\n        if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n        if (nodeDef.matrix !== undefined) {\n          var matrix = new _three.Matrix4();\n          matrix.fromArray(nodeDef.matrix);\n          node.applyMatrix4(matrix);\n        } else {\n          if (nodeDef.translation !== undefined) {\n            node.position.fromArray(nodeDef.translation);\n          }\n\n          if (nodeDef.rotation !== undefined) {\n            node.quaternion.fromArray(nodeDef.rotation);\n          }\n\n          if (nodeDef.scale !== undefined) {\n            node.scale.fromArray(nodeDef.scale);\n          }\n        }\n\n        parser.associations.set(node, {\n          type: 'nodes',\n          index: nodeIndex\n        });\n        return node;\n      });\n    }\n    /**\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n     * @param {number} sceneIndex\n     * @return {Promise<Group>}\n     */\n\n  }, {\n    key: \"loadScene\",\n    value: function loadScene(sceneIndex) {\n      var json = this.json;\n      var extensions = this.extensions;\n      var sceneDef = this.json.scenes[sceneIndex];\n      var parser = this; // Loader returns Group, not Scene.\n      // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\n      var scene = new _three.Group();\n      if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n      assignExtrasToUserData(scene, sceneDef);\n      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n      var nodeIds = sceneDef.nodes || [];\n      var pending = [];\n\n      for (var i = 0, il = nodeIds.length; i < il; i++) {\n        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n      }\n\n      return Promise.all(pending).then(function () {\n        return scene;\n      });\n    }\n  }]);\n\n  return GLTFParser;\n}();\n\nfunction buildNodeHierachy(nodeId, parentObject, json, parser) {\n  var nodeDef = json.nodes[nodeId];\n  return parser.getDependency('node', nodeId).then(function (node) {\n    if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n    var skinEntry;\n    return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n      skinEntry = skin;\n      var pendingJoints = [];\n\n      for (var i = 0, il = skinEntry.joints.length; i < il; i++) {\n        pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n      }\n\n      return Promise.all(pendingJoints);\n    }).then(function (jointNodes) {\n      node.traverse(function (mesh) {\n        if (!mesh.isMesh) return;\n        var bones = [];\n        var boneInverses = [];\n\n        for (var j = 0, jl = jointNodes.length; j < jl; j++) {\n          var jointNode = jointNodes[j];\n\n          if (jointNode) {\n            bones.push(jointNode);\n            var mat = new _three.Matrix4();\n\n            if (skinEntry.inverseBindMatrices !== undefined) {\n              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n            }\n\n            boneInverses.push(mat);\n          } else {\n            console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n          }\n        }\n\n        mesh.bind(new _three.Skeleton(bones, boneInverses), mesh.matrixWorld);\n      });\n      return node;\n    });\n  }).then(function (node) {\n    // build node hierachy\n    parentObject.add(node);\n    var pending = [];\n\n    if (nodeDef.children) {\n      var children = nodeDef.children;\n\n      for (var i = 0, il = children.length; i < il; i++) {\n        var child = children[i];\n        pending.push(buildNodeHierachy(child, node, json, parser));\n      }\n    }\n\n    return Promise.all(pending);\n  });\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\n\n\nfunction computeBounds(geometry, primitiveDef, parser) {\n  var attributes = primitiveDef.attributes;\n  var box = new _three.Box3();\n\n  if (attributes.POSITION !== undefined) {\n    var accessor = parser.json.accessors[attributes.POSITION];\n    var min = accessor.min;\n    var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new _three.Vector3(min[0], min[1], min[2]), new _three.Vector3(max[0], max[1], max[2]));\n\n      if (accessor.normalized) {\n        var boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n      return;\n    }\n  } else {\n    return;\n  }\n\n  var targets = primitiveDef.targets;\n\n  if (targets !== undefined) {\n    var maxDisplacement = new _three.Vector3();\n    var vector = new _three.Vector3();\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n\n      if (target.POSITION !== undefined) {\n        var _accessor = parser.json.accessors[target.POSITION];\n        var _min = _accessor.min;\n        var _max = _accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (_min !== undefined && _max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(_min[0]), Math.abs(_max[0])));\n          vector.setY(Math.max(Math.abs(_min[1]), Math.abs(_max[1])));\n          vector.setZ(Math.max(Math.abs(_min[2]), Math.abs(_max[2])));\n\n          if (_accessor.normalized) {\n            var _boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[_accessor.componentType]);\n\n            vector.multiplyScalar(_boxScale);\n          } // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\n\n          maxDisplacement.max(vector);\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n        }\n      }\n    } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\n\n    box.expandByVector(maxDisplacement);\n  }\n\n  geometry.boundingBox = box;\n  var sphere = new _three.Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\n\n\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  var attributes = primitiveDef.attributes;\n  var pending = [];\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n\n  for (var gltfAttributeName in attributes) {\n    var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n    if (threeAttributeName in geometry.attributes) continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor);\n    });\n    pending.push(accessor);\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {Number} drawMode\n * @return {BufferGeometry}\n */\n\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  var index = geometry.getIndex(); // generate index if not present\n\n  if (index === null) {\n    var indices = [];\n    var position = geometry.getAttribute('position');\n\n    if (position !== undefined) {\n      for (var i = 0; i < position.count; i++) {\n        indices.push(i);\n      }\n\n      geometry.setIndex(indices);\n      index = geometry.getIndex();\n    } else {\n      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n      return geometry;\n    }\n  } //\n\n\n  var numberOfTriangles = index.count - 2;\n  var newIndices = [];\n\n  if (drawMode === _three.TriangleFanDrawMode) {\n    // gl.TRIANGLE_FAN\n    for (var _i7 = 1; _i7 <= numberOfTriangles; _i7++) {\n      newIndices.push(index.getX(0));\n      newIndices.push(index.getX(_i7));\n      newIndices.push(index.getX(_i7 + 1));\n    }\n  } else {\n    // gl.TRIANGLE_STRIP\n    for (var _i8 = 0; _i8 < numberOfTriangles; _i8++) {\n      if (_i8 % 2 === 0) {\n        newIndices.push(index.getX(_i8));\n        newIndices.push(index.getX(_i8 + 1));\n        newIndices.push(index.getX(_i8 + 2));\n      } else {\n        newIndices.push(index.getX(_i8 + 2));\n        newIndices.push(index.getX(_i8 + 1));\n        newIndices.push(index.getX(_i8));\n      }\n    }\n  }\n\n  if (newIndices.length / 3 !== numberOfTriangles) {\n    console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n  } // build final geometry\n\n\n  var newGeometry = geometry.clone();\n  newGeometry.setIndex(newIndices);\n  return newGeometry;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","json","KHR_MATERIALS_TRANSMISSION","clearcoat","extensions","lightMap","glossinessMap","map","intensity","gltfExtensions","weights","cameraCache","wrapS","lightCache","promise","pluginCallbacks","clearcoatNormalScale","parser","beforeStart_","transmission","TEXCOORD_1","depthTest","NORMAL","glossiness","onerror","body","index","specularGlossinessParams","GLTFLoader","needsUpdate","ktx2Loader","specularTint","isInterpolantFactoryMethodGLTFCubicSpline","displacementMap","prototype","spot","KHR_BINARY_GLTF","scale","transparent","textureLoader","TEXCOORD_0","meshoptDecoder","side","magic","USE_GLOSSINESSMAP","createInterpolant","fog","afterEnd_","emissive","specularIntensity","SCALAR","interpolate_","key","STEP","ior","__esModule","clearcoatRoughness","radius","path","POSITION","alphaMap","matrixAutoUpdate","KHR_MATERIALS_UNLIT","KHR_LIGHTS_PUNCTUAL","flatShading","scenes","asset","encoding","associations","normalMap","aoMap","bumpMap","MAT4","outerConeAngle","primitive","src","isSkinnedMesh","JOINTS_0","textureCache","normal","cache","specular","COLOR_0","angle","position","KHR_MATERIALS_SPECULAR","MAT3","name","boundingSphere","configurable","emissiveMap","value","KHR_MATERIALS_IOR","TANGENT","attenuationTint","geometry","enumerable","boundingBox","isGLTFSpecularGlossinessMaterial","vertexColors","VEC3","_extraUniforms","morphTargetDictionary","userData","magFilter","remove","MAT2","writable","distance","dracoLoader","content","innerConeAngle","rotation","lightMapIntensity","EXT_TEXTURE_WEBP","onload","length","isBone","penumbra","nodeNamesUsed","WEIGHTS_0","envMapIntensity","animations","fileLoader","EXT_MESHOPT_COMPRESSION","VEC2","normalized","type","attenuationDistance","y","onBeforeCompile","wrapT","sizeAttenuation","uses","version","__proto__","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","KHR_MESH_QUANTIZATION","cameras","isSupported","aoMapIntensity","joints","primitiveCache","depthWrite","decay","envMap","manager","add","specularMap","set","bumpScale","normalMapType","KHR_TEXTURE_TRANSFORM","LINEAR","morphTargetsRelative","metalness","KHR_MATERIALS_CLEARCOAT","minFilter","options","requestHeader","flipY","displacementScale","roughness","thickness","removeAll","alphaTest","refractionRatio","get","KHR_DRACO_MESH_COMPRESSION","emissiveIntensity","color","opacity","crossOrigin","plugins","header","USE_UV","CUBICSPLINE","KHR_MATERIALS_VOLUME","translation","inverseBindMatrices","displacementBias","normalScale","KHR_TEXTURE_BASISU","format","USE_SPECULARMAP","VEC4","constructor","scene","meshCache","material","refs"]],"~:compiled-at",1630917515656,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$GLTFLoader.js\",\n\"lineCount\":136,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/GLTFLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$GLTFLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.GLTFLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _get(target, property, receiver) { if (typeof Reflect !== \\\"undefined\\\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\\n\\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar GLTFLoader =\\n/*#__PURE__*/\\nfunction (_Loader) {\\n  _inherits(GLTFLoader, _Loader);\\n\\n  function GLTFLoader(manager) {\\n    var _this;\\n\\n    _classCallCheck(this, GLTFLoader);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GLTFLoader).call(this, manager));\\n    _this.dracoLoader = null;\\n    _this.ktx2Loader = null;\\n    _this.meshoptDecoder = null;\\n    _this.pluginCallbacks = [];\\n\\n    _this.register(function (parser) {\\n      return new GLTFMaterialsClearcoatExtension(parser);\\n    });\\n\\n    _this.register(function (parser) {\\n      return new GLTFTextureBasisUExtension(parser);\\n    });\\n\\n    _this.register(function (parser) {\\n      return new GLTFTextureWebPExtension(parser);\\n    });\\n\\n    _this.register(function (parser) {\\n      return new GLTFMaterialsTransmissionExtension(parser);\\n    });\\n\\n    _this.register(function (parser) {\\n      return new GLTFMaterialsVolumeExtension(parser);\\n    });\\n\\n    _this.register(function (parser) {\\n      return new GLTFMaterialsIorExtension(parser);\\n    });\\n\\n    _this.register(function (parser) {\\n      return new GLTFMaterialsSpecularExtension(parser);\\n    });\\n\\n    _this.register(function (parser) {\\n      return new GLTFLightsExtension(parser);\\n    });\\n\\n    _this.register(function (parser) {\\n      return new GLTFMeshoptCompression(parser);\\n    });\\n\\n    return _this;\\n  }\\n\\n  _createClass(GLTFLoader, [{\\n    key: \\\"load\\\",\\n    value: function load(url, onLoad, onProgress, onError) {\\n      var scope = this;\\n      var resourcePath;\\n\\n      if (this.resourcePath !== '') {\\n        resourcePath = this.resourcePath;\\n      } else if (this.path !== '') {\\n        resourcePath = this.path;\\n      } else {\\n        resourcePath = _three.LoaderUtils.extractUrlBase(url);\\n      } // Tells the LoadingManager to track an extra item, which resolves after\\n      // the model is fully loaded. This means the count of items loaded will\\n      // be incorrect, but ensures manager.onLoad() does not fire early.\\n\\n\\n      this.manager.itemStart(url);\\n\\n      var _onError = function _onError(e) {\\n        if (onError) {\\n          onError(e);\\n        } else {\\n          console.error(e);\\n        }\\n\\n        scope.manager.itemError(url);\\n        scope.manager.itemEnd(url);\\n      };\\n\\n      var loader = new _three.FileLoader(this.manager);\\n      loader.setPath(this.path);\\n      loader.setResponseType('arraybuffer');\\n      loader.setRequestHeader(this.requestHeader);\\n      loader.setWithCredentials(this.withCredentials);\\n      loader.load(url, function (data) {\\n        try {\\n          scope.parse(data, resourcePath, function (gltf) {\\n            onLoad(gltf);\\n            scope.manager.itemEnd(url);\\n          }, _onError);\\n        } catch (e) {\\n          _onError(e);\\n        }\\n      }, onProgress, _onError);\\n    }\\n  }, {\\n    key: \\\"setDRACOLoader\\\",\\n    value: function setDRACOLoader(dracoLoader) {\\n      this.dracoLoader = dracoLoader;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"setDDSLoader\\\",\\n    value: function setDDSLoader() {\\n      throw new Error('THREE.GLTFLoader: \\\"MSFT_texture_dds\\\" no longer supported. Please update to \\\"KHR_texture_basisu\\\".');\\n    }\\n  }, {\\n    key: \\\"setKTX2Loader\\\",\\n    value: function setKTX2Loader(ktx2Loader) {\\n      this.ktx2Loader = ktx2Loader;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"setMeshoptDecoder\\\",\\n    value: function setMeshoptDecoder(meshoptDecoder) {\\n      this.meshoptDecoder = meshoptDecoder;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"register\\\",\\n    value: function register(callback) {\\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\\n        this.pluginCallbacks.push(callback);\\n      }\\n\\n      return this;\\n    }\\n  }, {\\n    key: \\\"unregister\\\",\\n    value: function unregister(callback) {\\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\\n      }\\n\\n      return this;\\n    }\\n  }, {\\n    key: \\\"parse\\\",\\n    value: function parse(data, path, onLoad, onError) {\\n      var content;\\n      var extensions = {};\\n      var plugins = {};\\n\\n      if (typeof data === 'string') {\\n        content = data;\\n      } else {\\n        var magic = _three.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\\n\\n        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\\n          try {\\n            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\\n          } catch (error) {\\n            if (onError) onError(error);\\n            return;\\n          }\\n\\n          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\\n        } else {\\n          content = _three.LoaderUtils.decodeText(new Uint8Array(data));\\n        }\\n      }\\n\\n      var json = JSON.parse(content);\\n\\n      if (json.asset === undefined || json.asset.version[0] < 2) {\\n        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\\n        return;\\n      }\\n\\n      var parser = new GLTFParser(json, {\\n        path: path || this.resourcePath || '',\\n        crossOrigin: this.crossOrigin,\\n        requestHeader: this.requestHeader,\\n        manager: this.manager,\\n        ktx2Loader: this.ktx2Loader,\\n        meshoptDecoder: this.meshoptDecoder\\n      });\\n      parser.fileLoader.setRequestHeader(this.requestHeader);\\n\\n      for (var i = 0; i < this.pluginCallbacks.length; i++) {\\n        var plugin = this.pluginCallbacks[i](parser);\\n        plugins[plugin.name] = plugin; // Workaround to avoid determining as unknown extension\\n        // in addUnknownExtensionsToUserData().\\n        // Remove this workaround if we move all the existing\\n        // extension handlers to plugin system\\n\\n        extensions[plugin.name] = true;\\n      }\\n\\n      if (json.extensionsUsed) {\\n        for (var _i = 0; _i < json.extensionsUsed.length; ++_i) {\\n          var extensionName = json.extensionsUsed[_i];\\n          var extensionsRequired = json.extensionsRequired || [];\\n\\n          switch (extensionName) {\\n            case EXTENSIONS.KHR_MATERIALS_UNLIT:\\n              extensions[extensionName] = new GLTFMaterialsUnlitExtension();\\n              break;\\n\\n            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\\n              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\\n              break;\\n\\n            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\\n              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\\n              break;\\n\\n            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\\n              extensions[extensionName] = new GLTFTextureTransformExtension();\\n              break;\\n\\n            case EXTENSIONS.KHR_MESH_QUANTIZATION:\\n              extensions[extensionName] = new GLTFMeshQuantizationExtension();\\n              break;\\n\\n            default:\\n              if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\\n                console.warn('THREE.GLTFLoader: Unknown extension \\\"' + extensionName + '\\\".');\\n              }\\n\\n          }\\n        }\\n      }\\n\\n      parser.setExtensions(extensions);\\n      parser.setPlugins(plugins);\\n      parser.parse(onLoad, onError);\\n    }\\n  }]);\\n\\n  return GLTFLoader;\\n}(_three.Loader);\\n/* GLTFREGISTRY */\\n\\n\\nexports.GLTFLoader = GLTFLoader;\\n\\nfunction GLTFRegistry() {\\n  var objects = {};\\n  return {\\n    get: function get(key) {\\n      return objects[key];\\n    },\\n    add: function add(key, object) {\\n      objects[key] = object;\\n    },\\n    remove: function remove(key) {\\n      delete objects[key];\\n    },\\n    removeAll: function removeAll() {\\n      objects = {};\\n    }\\n  };\\n}\\n/*********************************/\\n\\n/********** EXTENSIONS ***********/\\n\\n/*********************************/\\n\\n\\nvar EXTENSIONS = {\\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\\n  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'\\n};\\n/**\\n * Punctual Lights Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\\n */\\n\\nvar GLTFLightsExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFLightsExtension(parser) {\\n    _classCallCheck(this, GLTFLightsExtension);\\n\\n    this.parser = parser;\\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL; // Object3D instance caches\\n\\n    this.cache = {\\n      refs: {},\\n      uses: {}\\n    };\\n  }\\n\\n  _createClass(GLTFLightsExtension, [{\\n    key: \\\"_markDefs\\\",\\n    value: function _markDefs() {\\n      var parser = this.parser;\\n      var nodeDefs = this.parser.json.nodes || [];\\n\\n      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\\n        var nodeDef = nodeDefs[nodeIndex];\\n\\n        if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\\n          parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"_loadLight\\\",\\n    value: function _loadLight(lightIndex) {\\n      var parser = this.parser;\\n      var cacheKey = 'light:' + lightIndex;\\n      var dependency = parser.cache.get(cacheKey);\\n      if (dependency) return dependency;\\n      var json = parser.json;\\n      var extensions = json.extensions && json.extensions[this.name] || {};\\n      var lightDefs = extensions.lights || [];\\n      var lightDef = lightDefs[lightIndex];\\n      var lightNode;\\n      var color = new _three.Color(0xffffff);\\n      if (lightDef.color !== undefined) color.fromArray(lightDef.color);\\n      var range = lightDef.range !== undefined ? lightDef.range : 0;\\n\\n      switch (lightDef.type) {\\n        case 'directional':\\n          lightNode = new _three.DirectionalLight(color);\\n          lightNode.target.position.set(0, 0, -1);\\n          lightNode.add(lightNode.target);\\n          break;\\n\\n        case 'point':\\n          lightNode = new _three.PointLight(color);\\n          lightNode.distance = range;\\n          break;\\n\\n        case 'spot':\\n          lightNode = new _three.SpotLight(color);\\n          lightNode.distance = range; // Handle spotlight properties.\\n\\n          lightDef.spot = lightDef.spot || {};\\n          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\\n          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\\n          lightNode.angle = lightDef.spot.outerConeAngle;\\n          lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\\n          lightNode.target.position.set(0, 0, -1);\\n          lightNode.add(lightNode.target);\\n          break;\\n\\n        default:\\n          throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type);\\n      } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\\n      // here, because node-level parsing will only override position if explicitly specified.\\n\\n\\n      lightNode.position.set(0, 0, 0);\\n      lightNode.decay = 2;\\n      if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\\n      lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex);\\n      dependency = Promise.resolve(lightNode);\\n      parser.cache.add(cacheKey, dependency);\\n      return dependency;\\n    }\\n  }, {\\n    key: \\\"createNodeAttachment\\\",\\n    value: function createNodeAttachment(nodeIndex) {\\n      var self = this;\\n      var parser = this.parser;\\n      var json = parser.json;\\n      var nodeDef = json.nodes[nodeIndex];\\n      var lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\\n      var lightIndex = lightDef.light;\\n      if (lightIndex === undefined) return null;\\n      return this._loadLight(lightIndex).then(function (light) {\\n        return parser._getNodeRef(self.cache, lightIndex, light);\\n      });\\n    }\\n  }]);\\n\\n  return GLTFLightsExtension;\\n}();\\n/**\\n * Unlit Materials Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\\n */\\n\\n\\nvar GLTFMaterialsUnlitExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFMaterialsUnlitExtension() {\\n    _classCallCheck(this, GLTFMaterialsUnlitExtension);\\n\\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\\n  }\\n\\n  _createClass(GLTFMaterialsUnlitExtension, [{\\n    key: \\\"getMaterialType\\\",\\n    value: function getMaterialType() {\\n      return _three.MeshBasicMaterial;\\n    }\\n  }, {\\n    key: \\\"extendParams\\\",\\n    value: function extendParams(materialParams, materialDef, parser) {\\n      var pending = [];\\n      materialParams.color = new _three.Color(1.0, 1.0, 1.0);\\n      materialParams.opacity = 1.0;\\n      var metallicRoughness = materialDef.pbrMetallicRoughness;\\n\\n      if (metallicRoughness) {\\n        if (Array.isArray(metallicRoughness.baseColorFactor)) {\\n          var array = metallicRoughness.baseColorFactor;\\n          materialParams.color.fromArray(array);\\n          materialParams.opacity = array[3];\\n        }\\n\\n        if (metallicRoughness.baseColorTexture !== undefined) {\\n          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\\n        }\\n      }\\n\\n      return Promise.all(pending);\\n    }\\n  }]);\\n\\n  return GLTFMaterialsUnlitExtension;\\n}();\\n/**\\n * Clearcoat Materials Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\\n */\\n\\n\\nvar GLTFMaterialsClearcoatExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFMaterialsClearcoatExtension(parser) {\\n    _classCallCheck(this, GLTFMaterialsClearcoatExtension);\\n\\n    this.parser = parser;\\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\\n  }\\n\\n  _createClass(GLTFMaterialsClearcoatExtension, [{\\n    key: \\\"getMaterialType\\\",\\n    value: function getMaterialType(materialIndex) {\\n      var parser = this.parser;\\n      var materialDef = parser.json.materials[materialIndex];\\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\\n      return _three.MeshPhysicalMaterial;\\n    }\\n  }, {\\n    key: \\\"extendMaterialParams\\\",\\n    value: function extendMaterialParams(materialIndex, materialParams) {\\n      var parser = this.parser;\\n      var materialDef = parser.json.materials[materialIndex];\\n\\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\\n        return Promise.resolve();\\n      }\\n\\n      var pending = [];\\n      var extension = materialDef.extensions[this.name];\\n\\n      if (extension.clearcoatFactor !== undefined) {\\n        materialParams.clearcoat = extension.clearcoatFactor;\\n      }\\n\\n      if (extension.clearcoatTexture !== undefined) {\\n        pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));\\n      }\\n\\n      if (extension.clearcoatRoughnessFactor !== undefined) {\\n        materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\\n      }\\n\\n      if (extension.clearcoatRoughnessTexture !== undefined) {\\n        pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));\\n      }\\n\\n      if (extension.clearcoatNormalTexture !== undefined) {\\n        pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));\\n\\n        if (extension.clearcoatNormalTexture.scale !== undefined) {\\n          var scale = extension.clearcoatNormalTexture.scale; // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\\n\\n          materialParams.clearcoatNormalScale = new _three.Vector2(scale, -scale);\\n        }\\n      }\\n\\n      return Promise.all(pending);\\n    }\\n  }]);\\n\\n  return GLTFMaterialsClearcoatExtension;\\n}();\\n/**\\n * Transmission Materials Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\\n */\\n\\n\\nvar GLTFMaterialsTransmissionExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFMaterialsTransmissionExtension(parser) {\\n    _classCallCheck(this, GLTFMaterialsTransmissionExtension);\\n\\n    this.parser = parser;\\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\\n  }\\n\\n  _createClass(GLTFMaterialsTransmissionExtension, [{\\n    key: \\\"getMaterialType\\\",\\n    value: function getMaterialType(materialIndex) {\\n      var parser = this.parser;\\n      var materialDef = parser.json.materials[materialIndex];\\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\\n      return _three.MeshPhysicalMaterial;\\n    }\\n  }, {\\n    key: \\\"extendMaterialParams\\\",\\n    value: function extendMaterialParams(materialIndex, materialParams) {\\n      var parser = this.parser;\\n      var materialDef = parser.json.materials[materialIndex];\\n\\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\\n        return Promise.resolve();\\n      }\\n\\n      var pending = [];\\n      var extension = materialDef.extensions[this.name];\\n\\n      if (extension.transmissionFactor !== undefined) {\\n        materialParams.transmission = extension.transmissionFactor;\\n      }\\n\\n      if (extension.transmissionTexture !== undefined) {\\n        pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));\\n      }\\n\\n      return Promise.all(pending);\\n    }\\n  }]);\\n\\n  return GLTFMaterialsTransmissionExtension;\\n}();\\n/**\\n * Materials Volume Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\\n */\\n\\n\\nvar GLTFMaterialsVolumeExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFMaterialsVolumeExtension(parser) {\\n    _classCallCheck(this, GLTFMaterialsVolumeExtension);\\n\\n    this.parser = parser;\\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\\n  }\\n\\n  _createClass(GLTFMaterialsVolumeExtension, [{\\n    key: \\\"getMaterialType\\\",\\n    value: function getMaterialType(materialIndex) {\\n      var parser = this.parser;\\n      var materialDef = parser.json.materials[materialIndex];\\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\\n      return _three.MeshPhysicalMaterial;\\n    }\\n  }, {\\n    key: \\\"extendMaterialParams\\\",\\n    value: function extendMaterialParams(materialIndex, materialParams) {\\n      var parser = this.parser;\\n      var materialDef = parser.json.materials[materialIndex];\\n\\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\\n        return Promise.resolve();\\n      }\\n\\n      var pending = [];\\n      var extension = materialDef.extensions[this.name];\\n      materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\\n\\n      if (extension.thicknessTexture !== undefined) {\\n        pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));\\n      }\\n\\n      materialParams.attenuationDistance = extension.attenuationDistance || 0;\\n      var colorArray = extension.attenuationColor || [1, 1, 1];\\n      materialParams.attenuationTint = new _three.Color(colorArray[0], colorArray[1], colorArray[2]);\\n      return Promise.all(pending);\\n    }\\n  }]);\\n\\n  return GLTFMaterialsVolumeExtension;\\n}();\\n/**\\n * Materials ior Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\\n */\\n\\n\\nvar GLTFMaterialsIorExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFMaterialsIorExtension(parser) {\\n    _classCallCheck(this, GLTFMaterialsIorExtension);\\n\\n    this.parser = parser;\\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\\n  }\\n\\n  _createClass(GLTFMaterialsIorExtension, [{\\n    key: \\\"getMaterialType\\\",\\n    value: function getMaterialType(materialIndex) {\\n      var parser = this.parser;\\n      var materialDef = parser.json.materials[materialIndex];\\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\\n      return _three.MeshPhysicalMaterial;\\n    }\\n  }, {\\n    key: \\\"extendMaterialParams\\\",\\n    value: function extendMaterialParams(materialIndex, materialParams) {\\n      var parser = this.parser;\\n      var materialDef = parser.json.materials[materialIndex];\\n\\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\\n        return Promise.resolve();\\n      }\\n\\n      var extension = materialDef.extensions[this.name];\\n      materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\\n      return Promise.resolve();\\n    }\\n  }]);\\n\\n  return GLTFMaterialsIorExtension;\\n}();\\n/**\\n * Materials specular Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\\n */\\n\\n\\nvar GLTFMaterialsSpecularExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFMaterialsSpecularExtension(parser) {\\n    _classCallCheck(this, GLTFMaterialsSpecularExtension);\\n\\n    this.parser = parser;\\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\\n  }\\n\\n  _createClass(GLTFMaterialsSpecularExtension, [{\\n    key: \\\"getMaterialType\\\",\\n    value: function getMaterialType(materialIndex) {\\n      var parser = this.parser;\\n      var materialDef = parser.json.materials[materialIndex];\\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\\n      return _three.MeshPhysicalMaterial;\\n    }\\n  }, {\\n    key: \\\"extendMaterialParams\\\",\\n    value: function extendMaterialParams(materialIndex, materialParams) {\\n      var parser = this.parser;\\n      var materialDef = parser.json.materials[materialIndex];\\n\\n      if (!materialDef.extensions || !materialDef.extensions[this.name]) {\\n        return Promise.resolve();\\n      }\\n\\n      var pending = [];\\n      var extension = materialDef.extensions[this.name];\\n      materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\\n\\n      if (extension.specularTexture !== undefined) {\\n        pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));\\n      }\\n\\n      var colorArray = extension.specularColorFactor || [1, 1, 1];\\n      materialParams.specularTint = new _three.Color(colorArray[0], colorArray[1], colorArray[2]);\\n\\n      if (extension.specularColorTexture !== undefined) {\\n        pending.push(parser.assignTexture(materialParams, 'specularTintMap', extension.specularColorTexture).then(function (texture) {\\n          texture.encoding = _three.sRGBEncoding;\\n        }));\\n      }\\n\\n      return Promise.all(pending);\\n    }\\n  }]);\\n\\n  return GLTFMaterialsSpecularExtension;\\n}();\\n/**\\n * BasisU Texture Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\\n */\\n\\n\\nvar GLTFTextureBasisUExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFTextureBasisUExtension(parser) {\\n    _classCallCheck(this, GLTFTextureBasisUExtension);\\n\\n    this.parser = parser;\\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\\n  }\\n\\n  _createClass(GLTFTextureBasisUExtension, [{\\n    key: \\\"loadTexture\\\",\\n    value: function loadTexture(textureIndex) {\\n      var parser = this.parser;\\n      var json = parser.json;\\n      var textureDef = json.textures[textureIndex];\\n\\n      if (!textureDef.extensions || !textureDef.extensions[this.name]) {\\n        return null;\\n      }\\n\\n      var extension = textureDef.extensions[this.name];\\n      var source = json.images[extension.source];\\n      var loader = parser.options.ktx2Loader;\\n\\n      if (!loader) {\\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\\n          throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');\\n        } else {\\n          // Assumes that the extension is optional and that a fallback texture is present\\n          return null;\\n        }\\n      }\\n\\n      return parser.loadTextureImage(textureIndex, source, loader);\\n    }\\n  }]);\\n\\n  return GLTFTextureBasisUExtension;\\n}();\\n/**\\n * WebP Texture Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\\n */\\n\\n\\nvar GLTFTextureWebPExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFTextureWebPExtension(parser) {\\n    _classCallCheck(this, GLTFTextureWebPExtension);\\n\\n    this.parser = parser;\\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\\n    this.isSupported = null;\\n  }\\n\\n  _createClass(GLTFTextureWebPExtension, [{\\n    key: \\\"loadTexture\\\",\\n    value: function loadTexture(textureIndex) {\\n      var name = this.name;\\n      var parser = this.parser;\\n      var json = parser.json;\\n      var textureDef = json.textures[textureIndex];\\n\\n      if (!textureDef.extensions || !textureDef.extensions[name]) {\\n        return null;\\n      }\\n\\n      var extension = textureDef.extensions[name];\\n      var source = json.images[extension.source];\\n      var loader = parser.textureLoader;\\n\\n      if (source.uri) {\\n        var handler = parser.options.manager.getHandler(source.uri);\\n        if (handler !== null) loader = handler;\\n      }\\n\\n      return this.detectSupport().then(function (isSupported) {\\n        if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);\\n\\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\\n          throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');\\n        } // Fall back to PNG or JPEG.\\n\\n\\n        return parser.loadTexture(textureIndex);\\n      });\\n    }\\n  }, {\\n    key: \\\"detectSupport\\\",\\n    value: function detectSupport() {\\n      if (!this.isSupported) {\\n        this.isSupported = new Promise(function (resolve) {\\n          var image = new Image(); // Lossy test image. Support for lossy images doesn't guarantee support for all\\n          // WebP images, unfortunately.\\n\\n          image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\\n\\n          image.onload = image.onerror = function () {\\n            resolve(image.height === 1);\\n          };\\n        });\\n      }\\n\\n      return this.isSupported;\\n    }\\n  }]);\\n\\n  return GLTFTextureWebPExtension;\\n}();\\n/**\\n * meshopt BufferView Compression Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\\n */\\n\\n\\nvar GLTFMeshoptCompression =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFMeshoptCompression(parser) {\\n    _classCallCheck(this, GLTFMeshoptCompression);\\n\\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\\n    this.parser = parser;\\n  }\\n\\n  _createClass(GLTFMeshoptCompression, [{\\n    key: \\\"loadBufferView\\\",\\n    value: function loadBufferView(index) {\\n      var json = this.parser.json;\\n      var bufferView = json.bufferViews[index];\\n\\n      if (bufferView.extensions && bufferView.extensions[this.name]) {\\n        var extensionDef = bufferView.extensions[this.name];\\n        var buffer = this.parser.getDependency('buffer', extensionDef.buffer);\\n        var decoder = this.parser.options.meshoptDecoder;\\n\\n        if (!decoder || !decoder.supported) {\\n          if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\\n            throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');\\n          } else {\\n            // Assumes that the extension is optional and that fallback buffer data is present\\n            return null;\\n          }\\n        }\\n\\n        return Promise.all([buffer, decoder.ready]).then(function (res) {\\n          var byteOffset = extensionDef.byteOffset || 0;\\n          var byteLength = extensionDef.byteLength || 0;\\n          var count = extensionDef.count;\\n          var stride = extensionDef.byteStride;\\n          var result = new ArrayBuffer(count * stride);\\n          var source = new Uint8Array(res[0], byteOffset, byteLength);\\n          decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\\n          return result;\\n        });\\n      } else {\\n        return null;\\n      }\\n    }\\n  }]);\\n\\n  return GLTFMeshoptCompression;\\n}();\\n/* BINARY EXTENSION */\\n\\n\\nvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\\nvar BINARY_EXTENSION_HEADER_LENGTH = 12;\\nvar BINARY_EXTENSION_CHUNK_TYPES = {\\n  JSON: 0x4e4f534a,\\n  BIN: 0x004e4942\\n};\\n\\nvar GLTFBinaryExtension = function GLTFBinaryExtension(data) {\\n  _classCallCheck(this, GLTFBinaryExtension);\\n\\n  this.name = EXTENSIONS.KHR_BINARY_GLTF;\\n  this.content = null;\\n  this.body = null;\\n  var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\\n  this.header = {\\n    magic: _three.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\\n    version: headerView.getUint32(4, true),\\n    length: headerView.getUint32(8, true)\\n  };\\n\\n  if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\\n    throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\\n  } else if (this.header.version < 2.0) {\\n    throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\\n  }\\n\\n  var chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\\n  var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\\n  var chunkIndex = 0;\\n\\n  while (chunkIndex < chunkContentsLength) {\\n    var chunkLength = chunkView.getUint32(chunkIndex, true);\\n    chunkIndex += 4;\\n    var chunkType = chunkView.getUint32(chunkIndex, true);\\n    chunkIndex += 4;\\n\\n    if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\\n      var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\\n      this.content = _three.LoaderUtils.decodeText(contentArray);\\n    } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\\n      var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\\n      this.body = data.slice(byteOffset, byteOffset + chunkLength);\\n    } // Clients must ignore chunks with unknown types.\\n\\n\\n    chunkIndex += chunkLength;\\n  }\\n\\n  if (this.content === null) {\\n    throw new Error('THREE.GLTFLoader: JSON content not found.');\\n  }\\n};\\n/**\\n * DRACO Mesh Compression Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\\n */\\n\\n\\nvar GLTFDracoMeshCompressionExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {\\n    _classCallCheck(this, GLTFDracoMeshCompressionExtension);\\n\\n    if (!dracoLoader) {\\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\\n    }\\n\\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\\n    this.json = json;\\n    this.dracoLoader = dracoLoader;\\n    this.dracoLoader.preload();\\n  }\\n\\n  _createClass(GLTFDracoMeshCompressionExtension, [{\\n    key: \\\"decodePrimitive\\\",\\n    value: function decodePrimitive(primitive, parser) {\\n      var json = this.json;\\n      var dracoLoader = this.dracoLoader;\\n      var bufferViewIndex = primitive.extensions[this.name].bufferView;\\n      var gltfAttributeMap = primitive.extensions[this.name].attributes;\\n      var threeAttributeMap = {};\\n      var attributeNormalizedMap = {};\\n      var attributeTypeMap = {};\\n\\n      for (var attributeName in gltfAttributeMap) {\\n        var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\\n        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\\n      }\\n\\n      for (var _attributeName in primitive.attributes) {\\n        var _threeAttributeName = ATTRIBUTES[_attributeName] || _attributeName.toLowerCase();\\n\\n        if (gltfAttributeMap[_attributeName] !== undefined) {\\n          var accessorDef = json.accessors[primitive.attributes[_attributeName]];\\n          var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\\n          attributeTypeMap[_threeAttributeName] = componentType;\\n          attributeNormalizedMap[_threeAttributeName] = accessorDef.normalized === true;\\n        }\\n      }\\n\\n      return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\\n        return new Promise(function (resolve) {\\n          dracoLoader.decodeDracoFile(bufferView, function (geometry) {\\n            for (var _attributeName2 in geometry.attributes) {\\n              var attribute = geometry.attributes[_attributeName2];\\n              var normalized = attributeNormalizedMap[_attributeName2];\\n              if (normalized !== undefined) attribute.normalized = normalized;\\n            }\\n\\n            resolve(geometry);\\n          }, threeAttributeMap, attributeTypeMap);\\n        });\\n      });\\n    }\\n  }]);\\n\\n  return GLTFDracoMeshCompressionExtension;\\n}();\\n/**\\n * Texture Transform Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\\n */\\n\\n\\nvar GLTFTextureTransformExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFTextureTransformExtension() {\\n    _classCallCheck(this, GLTFTextureTransformExtension);\\n\\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\\n  }\\n\\n  _createClass(GLTFTextureTransformExtension, [{\\n    key: \\\"extendTexture\\\",\\n    value: function extendTexture(texture, transform) {\\n      if (transform.texCoord !== undefined) {\\n        console.warn('THREE.GLTFLoader: Custom UV sets in \\\"' + this.name + '\\\" extension not yet supported.');\\n      }\\n\\n      if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {\\n        // See https://github.com/mrdoob/three.js/issues/21819.\\n        return texture;\\n      }\\n\\n      texture = texture.clone();\\n\\n      if (transform.offset !== undefined) {\\n        texture.offset.fromArray(transform.offset);\\n      }\\n\\n      if (transform.rotation !== undefined) {\\n        texture.rotation = transform.rotation;\\n      }\\n\\n      if (transform.scale !== undefined) {\\n        texture.repeat.fromArray(transform.scale);\\n      }\\n\\n      texture.needsUpdate = true;\\n      return texture;\\n    }\\n  }]);\\n\\n  return GLTFTextureTransformExtension;\\n}();\\n/**\\n * Specular-Glossiness Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\\n */\\n\\n/**\\n * A sub class of StandardMaterial with some of the functionality\\n * changed via the `onBeforeCompile` callback\\n * @pailhead\\n */\\n\\n\\nvar GLTFMeshStandardSGMaterial =\\n/*#__PURE__*/\\nfunction (_MeshStandardMaterial) {\\n  _inherits(GLTFMeshStandardSGMaterial, _MeshStandardMaterial);\\n\\n  function GLTFMeshStandardSGMaterial(params) {\\n    var _this2;\\n\\n    _classCallCheck(this, GLTFMeshStandardSGMaterial);\\n\\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(GLTFMeshStandardSGMaterial).call(this));\\n    _this2.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing\\n\\n    var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\\tuniform sampler2D specularMap;', '#endif'].join('\\\\n');\\n    var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\\tuniform sampler2D glossinessMap;', '#endif'].join('\\\\n');\\n    var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\\ttexelSpecular = sRGBToLinear( texelSpecular );', '\\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\\\n');\\n    var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\\\n');\\n    var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );', 'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );', 'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );', 'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.', 'material.specularRoughness += geometryRoughness;', 'material.specularRoughness = min( material.specularRoughness, 1.0 );', 'material.specularColor = specularFactor;'].join('\\\\n');\\n    var uniforms = {\\n      specular: {\\n        value: new _three.Color().setHex(0xffffff)\\n      },\\n      glossiness: {\\n        value: 1\\n      },\\n      specularMap: {\\n        value: null\\n      },\\n      glossinessMap: {\\n        value: null\\n      }\\n    };\\n    _this2._extraUniforms = uniforms;\\n\\n    _this2.onBeforeCompile = function (shader) {\\n      for (var uniformName in uniforms) {\\n        shader.uniforms[uniformName] = uniforms[uniformName];\\n      }\\n\\n      shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\\n    };\\n\\n    Object.defineProperties(_assertThisInitialized(_this2), {\\n      specular: {\\n        get: function get() {\\n          return uniforms.specular.value;\\n        },\\n        set: function set(v) {\\n          uniforms.specular.value = v;\\n        }\\n      },\\n      specularMap: {\\n        get: function get() {\\n          return uniforms.specularMap.value;\\n        },\\n        set: function set(v) {\\n          uniforms.specularMap.value = v;\\n\\n          if (v) {\\n            this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps\\n          } else {\\n            delete this.defines.USE_SPECULARMAP;\\n          }\\n        }\\n      },\\n      glossiness: {\\n        get: function get() {\\n          return uniforms.glossiness.value;\\n        },\\n        set: function set(v) {\\n          uniforms.glossiness.value = v;\\n        }\\n      },\\n      glossinessMap: {\\n        get: function get() {\\n          return uniforms.glossinessMap.value;\\n        },\\n        set: function set(v) {\\n          uniforms.glossinessMap.value = v;\\n\\n          if (v) {\\n            this.defines.USE_GLOSSINESSMAP = '';\\n            this.defines.USE_UV = '';\\n          } else {\\n            delete this.defines.USE_GLOSSINESSMAP;\\n            delete this.defines.USE_UV;\\n          }\\n        }\\n      }\\n    });\\n    delete _this2.metalness;\\n    delete _this2.roughness;\\n    delete _this2.metalnessMap;\\n    delete _this2.roughnessMap;\\n\\n    _this2.setValues(params);\\n\\n    return _this2;\\n  }\\n\\n  _createClass(GLTFMeshStandardSGMaterial, [{\\n    key: \\\"copy\\\",\\n    value: function copy(source) {\\n      _get(_getPrototypeOf(GLTFMeshStandardSGMaterial.prototype), \\\"copy\\\", this).call(this, source);\\n\\n      this.specularMap = source.specularMap;\\n      this.specular.copy(source.specular);\\n      this.glossinessMap = source.glossinessMap;\\n      this.glossiness = source.glossiness;\\n      delete this.metalness;\\n      delete this.roughness;\\n      delete this.metalnessMap;\\n      delete this.roughnessMap;\\n      return this;\\n    }\\n  }]);\\n\\n  return GLTFMeshStandardSGMaterial;\\n}(_three.MeshStandardMaterial);\\n\\nvar GLTFMaterialsPbrSpecularGlossinessExtension =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFMaterialsPbrSpecularGlossinessExtension() {\\n    _classCallCheck(this, GLTFMaterialsPbrSpecularGlossinessExtension);\\n\\n    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\\n    this.specularGlossinessParams = ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'normalMapType', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'];\\n  }\\n\\n  _createClass(GLTFMaterialsPbrSpecularGlossinessExtension, [{\\n    key: \\\"getMaterialType\\\",\\n    value: function getMaterialType() {\\n      return GLTFMeshStandardSGMaterial;\\n    }\\n  }, {\\n    key: \\\"extendParams\\\",\\n    value: function extendParams(materialParams, materialDef, parser) {\\n      var pbrSpecularGlossiness = materialDef.extensions[this.name];\\n      materialParams.color = new _three.Color(1.0, 1.0, 1.0);\\n      materialParams.opacity = 1.0;\\n      var pending = [];\\n\\n      if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\\n        var array = pbrSpecularGlossiness.diffuseFactor;\\n        materialParams.color.fromArray(array);\\n        materialParams.opacity = array[3];\\n      }\\n\\n      if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\\n        pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\\n      }\\n\\n      materialParams.emissive = new _three.Color(0.0, 0.0, 0.0);\\n      materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\\n      materialParams.specular = new _three.Color(1.0, 1.0, 1.0);\\n\\n      if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\\n        materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\\n      }\\n\\n      if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\\n        var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\\n        pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\\n        pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\\n      }\\n\\n      return Promise.all(pending);\\n    }\\n  }, {\\n    key: \\\"createMaterial\\\",\\n    value: function createMaterial(materialParams) {\\n      var material = new GLTFMeshStandardSGMaterial(materialParams);\\n      material.fog = true;\\n      material.color = materialParams.color;\\n      material.map = materialParams.map === undefined ? null : materialParams.map;\\n      material.lightMap = null;\\n      material.lightMapIntensity = 1.0;\\n      material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\\n      material.aoMapIntensity = 1.0;\\n      material.emissive = materialParams.emissive;\\n      material.emissiveIntensity = 1.0;\\n      material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\\n      material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\\n      material.bumpScale = 1;\\n      material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\\n      material.normalMapType = _three.TangentSpaceNormalMap;\\n      if (materialParams.normalScale) material.normalScale = materialParams.normalScale;\\n      material.displacementMap = null;\\n      material.displacementScale = 1;\\n      material.displacementBias = 0;\\n      material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\\n      material.specular = materialParams.specular;\\n      material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\\n      material.glossiness = materialParams.glossiness;\\n      material.alphaMap = null;\\n      material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\\n      material.envMapIntensity = 1.0;\\n      material.refractionRatio = 0.98;\\n      return material;\\n    }\\n  }]);\\n\\n  return GLTFMaterialsPbrSpecularGlossinessExtension;\\n}();\\n/**\\n * Mesh Quantization Extension\\n *\\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\\n */\\n\\n\\nvar GLTFMeshQuantizationExtension = function GLTFMeshQuantizationExtension() {\\n  _classCallCheck(this, GLTFMeshQuantizationExtension);\\n\\n  this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\\n};\\n/*********************************/\\n\\n/********** INTERPOLATION ********/\\n\\n/*********************************/\\n// Spline Interpolation\\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\\n\\n\\nvar GLTFCubicSplineInterpolant =\\n/*#__PURE__*/\\nfunction (_Interpolant) {\\n  _inherits(GLTFCubicSplineInterpolant, _Interpolant);\\n\\n  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\\n    _classCallCheck(this, GLTFCubicSplineInterpolant);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(GLTFCubicSplineInterpolant).call(this, parameterPositions, sampleValues, sampleSize, resultBuffer));\\n  }\\n\\n  _createClass(GLTFCubicSplineInterpolant, [{\\n    key: \\\"copySampleValue_\\\",\\n    value: function copySampleValue_(index) {\\n      // Copies a sample value to the result buffer. See description of glTF\\n      // CUBICSPLINE values layout in interpolate_() function below.\\n      var result = this.resultBuffer,\\n          values = this.sampleValues,\\n          valueSize = this.valueSize,\\n          offset = index * valueSize * 3 + valueSize;\\n\\n      for (var i = 0; i !== valueSize; i++) {\\n        result[i] = values[offset + i];\\n      }\\n\\n      return result;\\n    }\\n  }]);\\n\\n  return GLTFCubicSplineInterpolant;\\n}(_three.Interpolant);\\n\\nGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\\nGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\\n\\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\\n  var result = this.resultBuffer;\\n  var values = this.sampleValues;\\n  var stride = this.valueSize;\\n  var stride2 = stride * 2;\\n  var stride3 = stride * 3;\\n  var td = t1 - t0;\\n  var p = (t - t0) / td;\\n  var pp = p * p;\\n  var ppp = pp * p;\\n  var offset1 = i1 * stride3;\\n  var offset0 = offset1 - stride3;\\n  var s2 = -2 * ppp + 3 * pp;\\n  var s3 = ppp - pp;\\n  var s0 = 1 - s2;\\n  var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\\n  //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\\n\\n  for (var i = 0; i !== stride; i++) {\\n    var p0 = values[offset0 + i + stride]; // splineVertex_k\\n\\n    var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\\n\\n    var p1 = values[offset1 + i + stride]; // splineVertex_k+1\\n\\n    var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\\n\\n    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\\n  }\\n\\n  return result;\\n};\\n/*********************************/\\n\\n/********** INTERNALS ************/\\n\\n/*********************************/\\n\\n/* CONSTANTS */\\n\\n\\nvar WEBGL_CONSTANTS = {\\n  FLOAT: 5126,\\n  //FLOAT_MAT2: 35674,\\n  FLOAT_MAT3: 35675,\\n  FLOAT_MAT4: 35676,\\n  FLOAT_VEC2: 35664,\\n  FLOAT_VEC3: 35665,\\n  FLOAT_VEC4: 35666,\\n  LINEAR: 9729,\\n  REPEAT: 10497,\\n  SAMPLER_2D: 35678,\\n  POINTS: 0,\\n  LINES: 1,\\n  LINE_LOOP: 2,\\n  LINE_STRIP: 3,\\n  TRIANGLES: 4,\\n  TRIANGLE_STRIP: 5,\\n  TRIANGLE_FAN: 6,\\n  UNSIGNED_BYTE: 5121,\\n  UNSIGNED_SHORT: 5123\\n};\\nvar WEBGL_COMPONENT_TYPES = {\\n  5120: Int8Array,\\n  5121: Uint8Array,\\n  5122: Int16Array,\\n  5123: Uint16Array,\\n  5125: Uint32Array,\\n  5126: Float32Array\\n};\\nvar WEBGL_FILTERS = {\\n  9728: _three.NearestFilter,\\n  9729: _three.LinearFilter,\\n  9984: _three.NearestMipmapNearestFilter,\\n  9985: _three.LinearMipmapNearestFilter,\\n  9986: _three.NearestMipmapLinearFilter,\\n  9987: _three.LinearMipmapLinearFilter\\n};\\nvar WEBGL_WRAPPINGS = {\\n  33071: _three.ClampToEdgeWrapping,\\n  33648: _three.MirroredRepeatWrapping,\\n  10497: _three.RepeatWrapping\\n};\\nvar WEBGL_TYPE_SIZES = {\\n  SCALAR: 1,\\n  VEC2: 2,\\n  VEC3: 3,\\n  VEC4: 4,\\n  MAT2: 4,\\n  MAT3: 9,\\n  MAT4: 16\\n};\\nvar ATTRIBUTES = {\\n  POSITION: 'position',\\n  NORMAL: 'normal',\\n  TANGENT: 'tangent',\\n  TEXCOORD_0: 'uv',\\n  TEXCOORD_1: 'uv2',\\n  COLOR_0: 'color',\\n  WEIGHTS_0: 'skinWeight',\\n  JOINTS_0: 'skinIndex'\\n};\\nvar PATH_PROPERTIES = {\\n  scale: 'scale',\\n  translation: 'position',\\n  rotation: 'quaternion',\\n  weights: 'morphTargetInfluences'\\n};\\nvar INTERPOLATION = {\\n  CUBICSPLINE: undefined,\\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\\n  // keyframe track will be initialized with a default interpolation type, then modified.\\n  LINEAR: _three.InterpolateLinear,\\n  STEP: _three.InterpolateDiscrete\\n};\\nvar ALPHA_MODES = {\\n  OPAQUE: 'OPAQUE',\\n  MASK: 'MASK',\\n  BLEND: 'BLEND'\\n};\\n/* UTILITY FUNCTIONS */\\n\\nfunction resolveURL(url, path) {\\n  // Invalid URL\\n  if (typeof url !== 'string' || url === '') return ''; // Host Relative URL\\n\\n  if (/^https?:\\\\/\\\\//i.test(path) && /^\\\\//.test(url)) {\\n    path = path.replace(/(^https?:\\\\/\\\\/[^\\\\/]+).*/i, '$1');\\n  } // Absolute URL http://,https://,//\\n\\n\\n  if (/^(https?:)?\\\\/\\\\//i.test(url)) return url; // Data URI\\n\\n  if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\\n\\n  if (/^blob:.*$/i.test(url)) return url; // Relative URL\\n\\n  return path + url;\\n}\\n/**\\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\\n */\\n\\n\\nfunction createDefaultMaterial(cache) {\\n  if (cache['DefaultMaterial'] === undefined) {\\n    cache['DefaultMaterial'] = new _three.MeshStandardMaterial({\\n      color: 0xffffff,\\n      emissive: 0x000000,\\n      metalness: 1,\\n      roughness: 1,\\n      transparent: false,\\n      depthTest: true,\\n      side: _three.FrontSide\\n    });\\n  }\\n\\n  return cache['DefaultMaterial'];\\n}\\n\\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\\n  // Add unknown glTF extensions to an object's userData.\\n  for (var name in objectDef.extensions) {\\n    if (knownExtensions[name] === undefined) {\\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\\n    }\\n  }\\n}\\n/**\\n * @param {Object3D|Material|BufferGeometry} object\\n * @param {GLTF.definition} gltfDef\\n */\\n\\n\\nfunction assignExtrasToUserData(object, gltfDef) {\\n  if (gltfDef.extras !== undefined) {\\n    if (_typeof(gltfDef.extras) === 'object') {\\n      Object.assign(object.userData, gltfDef.extras);\\n    } else {\\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\\n    }\\n  }\\n}\\n/**\\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\\n *\\n * @param {BufferGeometry} geometry\\n * @param {Array<GLTF.Target>} targets\\n * @param {GLTFParser} parser\\n * @return {Promise<BufferGeometry>}\\n */\\n\\n\\nfunction addMorphTargets(geometry, targets, parser) {\\n  var hasMorphPosition = false;\\n  var hasMorphNormal = false;\\n\\n  for (var i = 0, il = targets.length; i < il; i++) {\\n    var target = targets[i];\\n    if (target.POSITION !== undefined) hasMorphPosition = true;\\n    if (target.NORMAL !== undefined) hasMorphNormal = true;\\n    if (hasMorphPosition && hasMorphNormal) break;\\n  }\\n\\n  if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\\n  var pendingPositionAccessors = [];\\n  var pendingNormalAccessors = [];\\n\\n  for (var _i2 = 0, _il = targets.length; _i2 < _il; _i2++) {\\n    var _target = targets[_i2];\\n\\n    if (hasMorphPosition) {\\n      var pendingAccessor = _target.POSITION !== undefined ? parser.getDependency('accessor', _target.POSITION) : geometry.attributes.position;\\n      pendingPositionAccessors.push(pendingAccessor);\\n    }\\n\\n    if (hasMorphNormal) {\\n      var _pendingAccessor = _target.NORMAL !== undefined ? parser.getDependency('accessor', _target.NORMAL) : geometry.attributes.normal;\\n\\n      pendingNormalAccessors.push(_pendingAccessor);\\n    }\\n  }\\n\\n  return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\\n    var morphPositions = accessors[0];\\n    var morphNormals = accessors[1];\\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\\n    geometry.morphTargetsRelative = true;\\n    return geometry;\\n  });\\n}\\n/**\\n * @param {Mesh} mesh\\n * @param {GLTF.Mesh} meshDef\\n */\\n\\n\\nfunction updateMorphTargets(mesh, meshDef) {\\n  mesh.updateMorphTargets();\\n\\n  if (meshDef.weights !== undefined) {\\n    for (var i = 0, il = meshDef.weights.length; i < il; i++) {\\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\\n    }\\n  } // .extras has user-defined data, so check that .extras.targetNames is an array.\\n\\n\\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\\n    var targetNames = meshDef.extras.targetNames;\\n\\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\\n      mesh.morphTargetDictionary = {};\\n\\n      for (var _i3 = 0, _il2 = targetNames.length; _i3 < _il2; _i3++) {\\n        mesh.morphTargetDictionary[targetNames[_i3]] = _i3;\\n      }\\n    } else {\\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\\n    }\\n  }\\n}\\n\\nfunction createPrimitiveKey(primitiveDef) {\\n  var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\\n  var geometryKey;\\n\\n  if (dracoExtension) {\\n    geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\\n  } else {\\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\\n  }\\n\\n  return geometryKey;\\n}\\n\\nfunction createAttributesKey(attributes) {\\n  var attributesKey = '';\\n  var keys = Object.keys(attributes).sort();\\n\\n  for (var i = 0, il = keys.length; i < il; i++) {\\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\\n  }\\n\\n  return attributesKey;\\n}\\n\\nfunction getNormalizedComponentScale(constructor) {\\n  // Reference:\\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\\n  switch (constructor) {\\n    case Int8Array:\\n      return 1 / 127;\\n\\n    case Uint8Array:\\n      return 1 / 255;\\n\\n    case Int16Array:\\n      return 1 / 32767;\\n\\n    case Uint16Array:\\n      return 1 / 65535;\\n\\n    default:\\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');\\n  }\\n}\\n/* GLTF PARSER */\\n\\n\\nvar GLTFParser =\\n/*#__PURE__*/\\nfunction () {\\n  function GLTFParser() {\\n    var json = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n    _classCallCheck(this, GLTFParser);\\n\\n    this.json = json;\\n    this.extensions = {};\\n    this.plugins = {};\\n    this.options = options; // loader object cache\\n\\n    this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements\\n\\n    this.associations = new Map(); // BufferGeometry caching\\n\\n    this.primitiveCache = {}; // Object3D instance caches\\n\\n    this.meshCache = {\\n      refs: {},\\n      uses: {}\\n    };\\n    this.cameraCache = {\\n      refs: {},\\n      uses: {}\\n    };\\n    this.lightCache = {\\n      refs: {},\\n      uses: {}\\n    };\\n    this.textureCache = {}; // Track node names, to ensure no duplicates\\n\\n    this.nodeNamesUsed = {}; // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\\n    // expensive work of uploading a texture to the GPU off the main thread.\\n\\n    if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {\\n      this.textureLoader = new _three.ImageBitmapLoader(this.options.manager);\\n    } else {\\n      this.textureLoader = new _three.TextureLoader(this.options.manager);\\n    }\\n\\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\\n    this.fileLoader = new _three.FileLoader(this.options.manager);\\n    this.fileLoader.setResponseType('arraybuffer');\\n\\n    if (this.options.crossOrigin === 'use-credentials') {\\n      this.fileLoader.setWithCredentials(true);\\n    }\\n  }\\n\\n  _createClass(GLTFParser, [{\\n    key: \\\"setExtensions\\\",\\n    value: function setExtensions(extensions) {\\n      this.extensions = extensions;\\n    }\\n  }, {\\n    key: \\\"setPlugins\\\",\\n    value: function setPlugins(plugins) {\\n      this.plugins = plugins;\\n    }\\n  }, {\\n    key: \\\"parse\\\",\\n    value: function parse(onLoad, onError) {\\n      var parser = this;\\n      var json = this.json;\\n      var extensions = this.extensions; // Clear the loader cache\\n\\n      this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\\n\\n      this._invokeAll(function (ext) {\\n        return ext._markDefs && ext._markDefs();\\n      });\\n\\n      Promise.all(this._invokeAll(function (ext) {\\n        return ext.beforeRoot && ext.beforeRoot();\\n      })).then(function () {\\n        return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera')]);\\n      }).then(function (dependencies) {\\n        var result = {\\n          scene: dependencies[0][json.scene || 0],\\n          scenes: dependencies[0],\\n          animations: dependencies[1],\\n          cameras: dependencies[2],\\n          asset: json.asset,\\n          parser: parser,\\n          userData: {}\\n        };\\n        addUnknownExtensionsToUserData(extensions, result, json);\\n        assignExtrasToUserData(result, json);\\n        Promise.all(parser._invokeAll(function (ext) {\\n          return ext.afterRoot && ext.afterRoot(result);\\n        })).then(function () {\\n          onLoad(result);\\n        });\\n      })[\\\"catch\\\"](onError);\\n    }\\n    /**\\n     * Marks the special nodes/meshes in json for efficient parse.\\n     */\\n\\n  }, {\\n    key: \\\"_markDefs\\\",\\n    value: function _markDefs() {\\n      var nodeDefs = this.json.nodes || [];\\n      var skinDefs = this.json.skins || [];\\n      var meshDefs = this.json.meshes || []; // Nothing in the node definition indicates whether it is a Bone or an\\n      // Object3D. Use the skins' joint references to mark bones.\\n\\n      for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\\n        var joints = skinDefs[skinIndex].joints;\\n\\n        for (var i = 0, il = joints.length; i < il; i++) {\\n          nodeDefs[joints[i]].isBone = true;\\n        }\\n      } // Iterate over all nodes, marking references to shared resources,\\n      // as well as skeleton joints.\\n\\n\\n      for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\\n        var nodeDef = nodeDefs[nodeIndex];\\n\\n        if (nodeDef.mesh !== undefined) {\\n          this._addNodeRef(this.meshCache, nodeDef.mesh); // Nothing in the mesh definition indicates whether it is\\n          // a SkinnedMesh or Mesh. Use the node's mesh reference\\n          // to mark SkinnedMesh if node has skin.\\n\\n\\n          if (nodeDef.skin !== undefined) {\\n            meshDefs[nodeDef.mesh].isSkinnedMesh = true;\\n          }\\n        }\\n\\n        if (nodeDef.camera !== undefined) {\\n          this._addNodeRef(this.cameraCache, nodeDef.camera);\\n        }\\n      }\\n    }\\n    /**\\n     * Counts references to shared node / Object3D resources. These resources\\n     * can be reused, or \\\"instantiated\\\", at multiple nodes in the scene\\n     * hierarchy. Mesh, Camera, and Light instances are instantiated and must\\n     * be marked. Non-scenegraph resources (like Materials, Geometries, and\\n     * Textures) can be reused directly and are not marked here.\\n     *\\n     * Example: CesiumMilkTruck sample model reuses \\\"Wheel\\\" meshes.\\n     */\\n\\n  }, {\\n    key: \\\"_addNodeRef\\\",\\n    value: function _addNodeRef(cache, index) {\\n      if (index === undefined) return;\\n\\n      if (cache.refs[index] === undefined) {\\n        cache.refs[index] = cache.uses[index] = 0;\\n      }\\n\\n      cache.refs[index]++;\\n    }\\n    /** Returns a reference to a shared resource, cloning it if necessary. */\\n\\n  }, {\\n    key: \\\"_getNodeRef\\\",\\n    value: function _getNodeRef(cache, index, object) {\\n      if (cache.refs[index] <= 1) return object;\\n      var ref = object.clone();\\n      ref.name += '_instance_' + cache.uses[index]++;\\n      return ref;\\n    }\\n  }, {\\n    key: \\\"_invokeOne\\\",\\n    value: function _invokeOne(func) {\\n      var extensions = Object.values(this.plugins);\\n      extensions.push(this);\\n\\n      for (var i = 0; i < extensions.length; i++) {\\n        var result = func(extensions[i]);\\n        if (result) return result;\\n      }\\n\\n      return null;\\n    }\\n  }, {\\n    key: \\\"_invokeAll\\\",\\n    value: function _invokeAll(func) {\\n      var extensions = Object.values(this.plugins);\\n      extensions.unshift(this);\\n      var pending = [];\\n\\n      for (var i = 0; i < extensions.length; i++) {\\n        var result = func(extensions[i]);\\n        if (result) pending.push(result);\\n      }\\n\\n      return pending;\\n    }\\n    /**\\n     * Requests the specified dependency asynchronously, with caching.\\n     * @param {string} type\\n     * @param {number} index\\n     * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\\n     */\\n\\n  }, {\\n    key: \\\"getDependency\\\",\\n    value: function getDependency(type, index) {\\n      var cacheKey = type + ':' + index;\\n      var dependency = this.cache.get(cacheKey);\\n\\n      if (!dependency) {\\n        switch (type) {\\n          case 'scene':\\n            dependency = this.loadScene(index);\\n            break;\\n\\n          case 'node':\\n            dependency = this.loadNode(index);\\n            break;\\n\\n          case 'mesh':\\n            dependency = this._invokeOne(function (ext) {\\n              return ext.loadMesh && ext.loadMesh(index);\\n            });\\n            break;\\n\\n          case 'accessor':\\n            dependency = this.loadAccessor(index);\\n            break;\\n\\n          case 'bufferView':\\n            dependency = this._invokeOne(function (ext) {\\n              return ext.loadBufferView && ext.loadBufferView(index);\\n            });\\n            break;\\n\\n          case 'buffer':\\n            dependency = this.loadBuffer(index);\\n            break;\\n\\n          case 'material':\\n            dependency = this._invokeOne(function (ext) {\\n              return ext.loadMaterial && ext.loadMaterial(index);\\n            });\\n            break;\\n\\n          case 'texture':\\n            dependency = this._invokeOne(function (ext) {\\n              return ext.loadTexture && ext.loadTexture(index);\\n            });\\n            break;\\n\\n          case 'skin':\\n            dependency = this.loadSkin(index);\\n            break;\\n\\n          case 'animation':\\n            dependency = this.loadAnimation(index);\\n            break;\\n\\n          case 'camera':\\n            dependency = this.loadCamera(index);\\n            break;\\n\\n          default:\\n            throw new Error('Unknown type: ' + type);\\n        }\\n\\n        this.cache.add(cacheKey, dependency);\\n      }\\n\\n      return dependency;\\n    }\\n    /**\\n     * Requests all dependencies of the specified type asynchronously, with caching.\\n     * @param {string} type\\n     * @return {Promise<Array<Object>>}\\n     */\\n\\n  }, {\\n    key: \\\"getDependencies\\\",\\n    value: function getDependencies(type) {\\n      var dependencies = this.cache.get(type);\\n\\n      if (!dependencies) {\\n        var parser = this;\\n        var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\\n        dependencies = Promise.all(defs.map(function (def, index) {\\n          return parser.getDependency(type, index);\\n        }));\\n        this.cache.add(type, dependencies);\\n      }\\n\\n      return dependencies;\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\\n     * @param {number} bufferIndex\\n     * @return {Promise<ArrayBuffer>}\\n     */\\n\\n  }, {\\n    key: \\\"loadBuffer\\\",\\n    value: function loadBuffer(bufferIndex) {\\n      var bufferDef = this.json.buffers[bufferIndex];\\n      var loader = this.fileLoader;\\n\\n      if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\\n        throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\\n      } // If present, GLB container is required to be the first buffer.\\n\\n\\n      if (bufferDef.uri === undefined && bufferIndex === 0) {\\n        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\\n      }\\n\\n      var options = this.options;\\n      return new Promise(function (resolve, reject) {\\n        loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\\n          reject(new Error('THREE.GLTFLoader: Failed to load buffer \\\"' + bufferDef.uri + '\\\".'));\\n        });\\n      });\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\\n     * @param {number} bufferViewIndex\\n     * @return {Promise<ArrayBuffer>}\\n     */\\n\\n  }, {\\n    key: \\\"loadBufferView\\\",\\n    value: function loadBufferView(bufferViewIndex) {\\n      var bufferViewDef = this.json.bufferViews[bufferViewIndex];\\n      return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\\n        var byteLength = bufferViewDef.byteLength || 0;\\n        var byteOffset = bufferViewDef.byteOffset || 0;\\n        return buffer.slice(byteOffset, byteOffset + byteLength);\\n      });\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\\n     * @param {number} accessorIndex\\n     * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\\n     */\\n\\n  }, {\\n    key: \\\"loadAccessor\\\",\\n    value: function loadAccessor(accessorIndex) {\\n      var parser = this;\\n      var json = this.json;\\n      var accessorDef = this.json.accessors[accessorIndex];\\n\\n      if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\\n        // Ignore empty accessors, which may be used to declare runtime\\n        // information about attributes coming from another source (e.g. Draco\\n        // compression extension).\\n        return Promise.resolve(null);\\n      }\\n\\n      var pendingBufferViews = [];\\n\\n      if (accessorDef.bufferView !== undefined) {\\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\\n      } else {\\n        pendingBufferViews.push(null);\\n      }\\n\\n      if (accessorDef.sparse !== undefined) {\\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\\n        pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\\n      }\\n\\n      return Promise.all(pendingBufferViews).then(function (bufferViews) {\\n        var bufferView = bufferViews[0];\\n        var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\\n        var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\\n\\n        var elementBytes = TypedArray.BYTES_PER_ELEMENT;\\n        var itemBytes = elementBytes * itemSize;\\n        var byteOffset = accessorDef.byteOffset || 0;\\n        var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\\n        var normalized = accessorDef.normalized === true;\\n        var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\\n\\n        if (byteStride && byteStride !== itemBytes) {\\n          // Each \\\"slice\\\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\\n          // This makes sure that IBA.count reflects accessor.count properly\\n          var ibSlice = Math.floor(byteOffset / byteStride);\\n          var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\\n          var ib = parser.cache.get(ibCacheKey);\\n\\n          if (!ib) {\\n            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\\n\\n            ib = new _three.InterleavedBuffer(array, byteStride / elementBytes);\\n            parser.cache.add(ibCacheKey, ib);\\n          }\\n\\n          bufferAttribute = new _three.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\\n        } else {\\n          if (bufferView === null) {\\n            array = new TypedArray(accessorDef.count * itemSize);\\n          } else {\\n            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\\n          }\\n\\n          bufferAttribute = new _three.BufferAttribute(array, itemSize, normalized);\\n        } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\\n\\n\\n        if (accessorDef.sparse !== undefined) {\\n          var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\\n          var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\\n          var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\\n          var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\\n          var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\\n          var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\\n\\n          if (bufferView !== null) {\\n            // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\\n            bufferAttribute = new _three.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\\n          }\\n\\n          for (var i = 0, il = sparseIndices.length; i < il; i++) {\\n            var index = sparseIndices[i];\\n            bufferAttribute.setX(index, sparseValues[i * itemSize]);\\n            if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\\n            if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\\n            if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\\n            if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\\n          }\\n        }\\n\\n        return bufferAttribute;\\n      });\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\\n     * @param {number} textureIndex\\n     * @return {Promise<THREE.Texture>}\\n     */\\n\\n  }, {\\n    key: \\\"loadTexture\\\",\\n    value: function loadTexture(textureIndex) {\\n      var json = this.json;\\n      var options = this.options;\\n      var textureDef = json.textures[textureIndex];\\n      var source = json.images[textureDef.source];\\n      var loader = this.textureLoader;\\n\\n      if (source.uri) {\\n        var handler = options.manager.getHandler(source.uri);\\n        if (handler !== null) loader = handler;\\n      }\\n\\n      return this.loadTextureImage(textureIndex, source, loader);\\n    }\\n  }, {\\n    key: \\\"loadTextureImage\\\",\\n    value: function loadTextureImage(textureIndex, source, loader) {\\n      var parser = this;\\n      var json = this.json;\\n      var options = this.options;\\n      var textureDef = json.textures[textureIndex];\\n      var cacheKey = (source.uri || source.bufferView) + ':' + textureDef.sampler;\\n\\n      if (this.textureCache[cacheKey]) {\\n        // See https://github.com/mrdoob/three.js/issues/21559.\\n        return this.textureCache[cacheKey];\\n      }\\n\\n      var URL = self.URL || self.webkitURL;\\n      var sourceURI = source.uri || '';\\n      var isObjectURL = false;\\n      var hasAlpha = true;\\n      var isJPEG = sourceURI.search(/\\\\.jpe?g($|\\\\?)/i) > 0 || sourceURI.search(/^data\\\\:image\\\\/jpeg/) === 0;\\n      if (source.mimeType === 'image/jpeg' || isJPEG) hasAlpha = false;\\n\\n      if (source.bufferView !== undefined) {\\n        // Load binary image data from bufferView, if provided.\\n        sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\\n          if (source.mimeType === 'image/png') {\\n            // Inspect the PNG 'IHDR' chunk to determine whether the image could have an\\n            // alpha channel. This check is conservative \\u2014 the image could have an alpha\\n            // channel with all values == 1, and the indexed type (colorType == 3) only\\n            // sometimes contains alpha.\\n            //\\n            // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\\n            var colorType = new DataView(bufferView, 25, 1).getUint8(0, false);\\n            hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\\n          }\\n\\n          isObjectURL = true;\\n          var blob = new Blob([bufferView], {\\n            type: source.mimeType\\n          });\\n          sourceURI = URL.createObjectURL(blob);\\n          return sourceURI;\\n        });\\n      } else if (source.uri === undefined) {\\n        throw new Error('THREE.GLTFLoader: Image ' + textureIndex + ' is missing URI and bufferView');\\n      }\\n\\n      var promise = Promise.resolve(sourceURI).then(function (sourceURI) {\\n        return new Promise(function (resolve, reject) {\\n          var onLoad = resolve;\\n\\n          if (loader.isImageBitmapLoader === true) {\\n            onLoad = function onLoad(imageBitmap) {\\n              var texture = new _three.Texture(imageBitmap);\\n              texture.needsUpdate = true;\\n              resolve(texture);\\n            };\\n          }\\n\\n          loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);\\n        });\\n      }).then(function (texture) {\\n        // Clean up resources and configure Texture.\\n        if (isObjectURL === true) {\\n          URL.revokeObjectURL(sourceURI);\\n        }\\n\\n        texture.flipY = false;\\n        if (textureDef.name) texture.name = textureDef.name; // When there is definitely no alpha channel in the texture, set RGBFormat to save space.\\n\\n        if (!hasAlpha) texture.format = _three.RGBFormat;\\n        var samplers = json.samplers || {};\\n        var sampler = samplers[textureDef.sampler] || {};\\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || _three.LinearFilter;\\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || _three.LinearMipmapLinearFilter;\\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || _three.RepeatWrapping;\\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || _three.RepeatWrapping;\\n        parser.associations.set(texture, {\\n          type: 'textures',\\n          index: textureIndex\\n        });\\n        return texture;\\n      })[\\\"catch\\\"](function () {\\n        console.error(\\\"THREE.GLTFLoader: Couldn't load texture\\\", sourceURI);\\n        return null;\\n      });\\n      this.textureCache[cacheKey] = promise;\\n      return promise;\\n    }\\n    /**\\n     * Asynchronously assigns a texture to the given material parameters.\\n     * @param {Object} materialParams\\n     * @param {string} mapName\\n     * @param {Object} mapDef\\n     * @return {Promise<Texture>}\\n     */\\n\\n  }, {\\n    key: \\\"assignTexture\\\",\\n    value: function assignTexture(materialParams, mapName, mapDef) {\\n      var parser = this;\\n      return this.getDependency('texture', mapDef.index).then(function (texture) {\\n        // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\\n        // However, we will copy UV set 0 to UV set 1 on demand for aoMap\\n        if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\\n          console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\\n        }\\n\\n        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\\n          var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\\n\\n          if (transform) {\\n            var gltfReference = parser.associations.get(texture);\\n            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\\n            parser.associations.set(texture, gltfReference);\\n          }\\n        }\\n\\n        materialParams[mapName] = texture;\\n        return texture;\\n      });\\n    }\\n    /**\\n     * Assigns final material to a Mesh, Line, or Points instance. The instance\\n     * already has a material (generated from the glTF material options alone)\\n     * but reuse of the same glTF material may require multiple threejs materials\\n     * to accommodate different primitive types, defines, etc. New materials will\\n     * be created if necessary, and reused from a cache.\\n     * @param  {Object3D} mesh Mesh, Line, or Points instance.\\n     */\\n\\n  }, {\\n    key: \\\"assignFinalMaterial\\\",\\n    value: function assignFinalMaterial(mesh) {\\n      var geometry = mesh.geometry;\\n      var material = mesh.material;\\n      var useVertexTangents = geometry.attributes.tangent !== undefined;\\n      var useVertexColors = geometry.attributes.color !== undefined;\\n      var useFlatShading = geometry.attributes.normal === undefined;\\n\\n      if (mesh.isPoints) {\\n        var cacheKey = 'PointsMaterial:' + material.uuid;\\n        var pointsMaterial = this.cache.get(cacheKey);\\n\\n        if (!pointsMaterial) {\\n          pointsMaterial = new _three.PointsMaterial();\\n\\n          _three.Material.prototype.copy.call(pointsMaterial, material);\\n\\n          pointsMaterial.color.copy(material.color);\\n          pointsMaterial.map = material.map;\\n          pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\\n\\n          this.cache.add(cacheKey, pointsMaterial);\\n        }\\n\\n        material = pointsMaterial;\\n      } else if (mesh.isLine) {\\n        var _cacheKey = 'LineBasicMaterial:' + material.uuid;\\n\\n        var lineMaterial = this.cache.get(_cacheKey);\\n\\n        if (!lineMaterial) {\\n          lineMaterial = new _three.LineBasicMaterial();\\n\\n          _three.Material.prototype.copy.call(lineMaterial, material);\\n\\n          lineMaterial.color.copy(material.color);\\n          this.cache.add(_cacheKey, lineMaterial);\\n        }\\n\\n        material = lineMaterial;\\n      } // Clone the material if it will be modified\\n\\n\\n      if (useVertexTangents || useVertexColors || useFlatShading) {\\n        var _cacheKey2 = 'ClonedMaterial:' + material.uuid + ':';\\n\\n        if (material.isGLTFSpecularGlossinessMaterial) _cacheKey2 += 'specular-glossiness:';\\n        if (useVertexTangents) _cacheKey2 += 'vertex-tangents:';\\n        if (useVertexColors) _cacheKey2 += 'vertex-colors:';\\n        if (useFlatShading) _cacheKey2 += 'flat-shading:';\\n        var cachedMaterial = this.cache.get(_cacheKey2);\\n\\n        if (!cachedMaterial) {\\n          cachedMaterial = material.clone();\\n          if (useVertexColors) cachedMaterial.vertexColors = true;\\n          if (useFlatShading) cachedMaterial.flatShading = true;\\n\\n          if (useVertexTangents) {\\n            // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\\n            if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\\n            if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\\n          }\\n\\n          this.cache.add(_cacheKey2, cachedMaterial);\\n          this.associations.set(cachedMaterial, this.associations.get(material));\\n        }\\n\\n        material = cachedMaterial;\\n      } // workarounds for mesh and geometry\\n\\n\\n      if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\\n        geometry.setAttribute('uv2', geometry.attributes.uv);\\n      }\\n\\n      mesh.material = material;\\n    }\\n  }, {\\n    key: \\\"getMaterialType\\\",\\n    value: function getMaterialType()\\n    /* materialIndex */\\n    {\\n      return _three.MeshStandardMaterial;\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\\n     * @param {number} materialIndex\\n     * @return {Promise<Material>}\\n     */\\n\\n  }, {\\n    key: \\\"loadMaterial\\\",\\n    value: function loadMaterial(materialIndex) {\\n      var parser = this;\\n      var json = this.json;\\n      var extensions = this.extensions;\\n      var materialDef = json.materials[materialIndex];\\n      var materialType;\\n      var materialParams = {};\\n      var materialExtensions = materialDef.extensions || {};\\n      var pending = [];\\n\\n      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\\n        var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\\n        materialType = sgExtension.getMaterialType();\\n        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\\n      } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\\n        var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\\n        materialType = kmuExtension.getMaterialType();\\n        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\\n      } else {\\n        // Specification:\\n        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\\n        var metallicRoughness = materialDef.pbrMetallicRoughness || {};\\n        materialParams.color = new _three.Color(1.0, 1.0, 1.0);\\n        materialParams.opacity = 1.0;\\n\\n        if (Array.isArray(metallicRoughness.baseColorFactor)) {\\n          var array = metallicRoughness.baseColorFactor;\\n          materialParams.color.fromArray(array);\\n          materialParams.opacity = array[3];\\n        }\\n\\n        if (metallicRoughness.baseColorTexture !== undefined) {\\n          pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\\n        }\\n\\n        materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\\n        materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\\n\\n        if (metallicRoughness.metallicRoughnessTexture !== undefined) {\\n          pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\\n          pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\\n        }\\n\\n        materialType = this._invokeOne(function (ext) {\\n          return ext.getMaterialType && ext.getMaterialType(materialIndex);\\n        });\\n        pending.push(Promise.all(this._invokeAll(function (ext) {\\n          return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\\n        })));\\n      }\\n\\n      if (materialDef.doubleSided === true) {\\n        materialParams.side = _three.DoubleSide;\\n      }\\n\\n      var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\\n\\n      if (alphaMode === ALPHA_MODES.BLEND) {\\n        materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706\\n\\n        materialParams.depthWrite = false;\\n      } else {\\n        materialParams.transparent = false;\\n\\n        if (alphaMode === ALPHA_MODES.MASK) {\\n          materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\\n        }\\n      }\\n\\n      if (materialDef.normalTexture !== undefined && materialType !== _three.MeshBasicMaterial) {\\n        pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture)); // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\\n\\n        materialParams.normalScale = new _three.Vector2(1, -1);\\n\\n        if (materialDef.normalTexture.scale !== undefined) {\\n          materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);\\n        }\\n      }\\n\\n      if (materialDef.occlusionTexture !== undefined && materialType !== _three.MeshBasicMaterial) {\\n        pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\\n\\n        if (materialDef.occlusionTexture.strength !== undefined) {\\n          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\\n        }\\n      }\\n\\n      if (materialDef.emissiveFactor !== undefined && materialType !== _three.MeshBasicMaterial) {\\n        materialParams.emissive = new _three.Color().fromArray(materialDef.emissiveFactor);\\n      }\\n\\n      if (materialDef.emissiveTexture !== undefined && materialType !== _three.MeshBasicMaterial) {\\n        pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\\n      }\\n\\n      return Promise.all(pending).then(function () {\\n        var material;\\n\\n        if (materialType === GLTFMeshStandardSGMaterial) {\\n          material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\\n        } else {\\n          material = new materialType(materialParams);\\n        }\\n\\n        if (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\\n\\n        if (material.map) material.map.encoding = _three.sRGBEncoding;\\n        if (material.emissiveMap) material.emissiveMap.encoding = _three.sRGBEncoding;\\n        assignExtrasToUserData(material, materialDef);\\n        parser.associations.set(material, {\\n          type: 'materials',\\n          index: materialIndex\\n        });\\n        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\\n        return material;\\n      });\\n    }\\n    /** When Object3D instances are targeted by animation, they need unique names. */\\n\\n  }, {\\n    key: \\\"createUniqueName\\\",\\n    value: function createUniqueName(originalName) {\\n      var sanitizedName = _three.PropertyBinding.sanitizeNodeName(originalName || '');\\n\\n      var name = sanitizedName;\\n\\n      for (var i = 1; this.nodeNamesUsed[name]; ++i) {\\n        name = sanitizedName + '_' + i;\\n      }\\n\\n      this.nodeNamesUsed[name] = true;\\n      return name;\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\\n     *\\n     * Creates BufferGeometries from primitives.\\n     *\\n     * @param {Array<GLTF.Primitive>} primitives\\n     * @return {Promise<Array<BufferGeometry>>}\\n     */\\n\\n  }, {\\n    key: \\\"loadGeometries\\\",\\n    value: function loadGeometries(primitives) {\\n      var parser = this;\\n      var extensions = this.extensions;\\n      var cache = this.primitiveCache;\\n\\n      function createDracoPrimitive(primitive) {\\n        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\\n          return addPrimitiveAttributes(geometry, primitive, parser);\\n        });\\n      }\\n\\n      var pending = [];\\n\\n      for (var i = 0, il = primitives.length; i < il; i++) {\\n        var primitive = primitives[i];\\n        var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\\n\\n        var cached = cache[cacheKey];\\n\\n        if (cached) {\\n          // Use the cached geometry if it exists\\n          pending.push(cached.promise);\\n        } else {\\n          var geometryPromise = void 0;\\n\\n          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\\n            // Use DRACO geometry if available\\n            geometryPromise = createDracoPrimitive(primitive);\\n          } else {\\n            // Otherwise create a new geometry\\n            geometryPromise = addPrimitiveAttributes(new _three.BufferGeometry(), primitive, parser);\\n          } // Cache this geometry\\n\\n\\n          cache[cacheKey] = {\\n            primitive: primitive,\\n            promise: geometryPromise\\n          };\\n          pending.push(geometryPromise);\\n        }\\n      }\\n\\n      return Promise.all(pending);\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\\n     * @param {number} meshIndex\\n     * @return {Promise<Group|Mesh|SkinnedMesh>}\\n     */\\n\\n  }, {\\n    key: \\\"loadMesh\\\",\\n    value: function loadMesh(meshIndex) {\\n      var parser = this;\\n      var json = this.json;\\n      var extensions = this.extensions;\\n      var meshDef = json.meshes[meshIndex];\\n      var primitives = meshDef.primitives;\\n      var pending = [];\\n\\n      for (var i = 0, il = primitives.length; i < il; i++) {\\n        var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\\n        pending.push(material);\\n      }\\n\\n      pending.push(parser.loadGeometries(primitives));\\n      return Promise.all(pending).then(function (results) {\\n        var materials = results.slice(0, results.length - 1);\\n        var geometries = results[results.length - 1];\\n        var meshes = [];\\n\\n        for (var _i4 = 0, _il3 = geometries.length; _i4 < _il3; _i4++) {\\n          var geometry = geometries[_i4];\\n          var primitive = primitives[_i4]; // 1. create Mesh\\n\\n          var mesh = void 0;\\n          var _material = materials[_i4];\\n\\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\\n            // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\\n            mesh = meshDef.isSkinnedMesh === true ? new _three.SkinnedMesh(geometry, _material) : new _three.Mesh(geometry, _material);\\n\\n            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\\n              // we normalize floating point skin weight array to fix malformed assets (see #15319)\\n              // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\\n              mesh.normalizeSkinWeights();\\n            }\\n\\n            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\\n              mesh.geometry = toTrianglesDrawMode(mesh.geometry, _three.TriangleStripDrawMode);\\n            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\\n              mesh.geometry = toTrianglesDrawMode(mesh.geometry, _three.TriangleFanDrawMode);\\n            }\\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\\n            mesh = new _three.LineSegments(geometry, _material);\\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\\n            mesh = new _three.Line(geometry, _material);\\n          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\\n            mesh = new _three.LineLoop(geometry, _material);\\n          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\\n            mesh = new _three.Points(geometry, _material);\\n          } else {\\n            throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\\n          }\\n\\n          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\\n            updateMorphTargets(mesh, meshDef);\\n          }\\n\\n          mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex);\\n          assignExtrasToUserData(mesh, meshDef);\\n          if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\\n          parser.assignFinalMaterial(mesh);\\n          meshes.push(mesh);\\n        }\\n\\n        if (meshes.length === 1) {\\n          return meshes[0];\\n        }\\n\\n        var group = new _three.Group();\\n\\n        for (var _i5 = 0, _il4 = meshes.length; _i5 < _il4; _i5++) {\\n          group.add(meshes[_i5]);\\n        }\\n\\n        return group;\\n      });\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\\n     * @param {number} cameraIndex\\n     * @return {Promise<THREE.Camera>}\\n     */\\n\\n  }, {\\n    key: \\\"loadCamera\\\",\\n    value: function loadCamera(cameraIndex) {\\n      var camera;\\n      var cameraDef = this.json.cameras[cameraIndex];\\n      var params = cameraDef[cameraDef.type];\\n\\n      if (!params) {\\n        console.warn('THREE.GLTFLoader: Missing camera parameters.');\\n        return;\\n      }\\n\\n      if (cameraDef.type === 'perspective') {\\n        camera = new _three.PerspectiveCamera(_three.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\\n      } else if (cameraDef.type === 'orthographic') {\\n        camera = new _three.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\\n      }\\n\\n      if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\\n      assignExtrasToUserData(camera, cameraDef);\\n      return Promise.resolve(camera);\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\\n     * @param {number} skinIndex\\n     * @return {Promise<Object>}\\n     */\\n\\n  }, {\\n    key: \\\"loadSkin\\\",\\n    value: function loadSkin(skinIndex) {\\n      var skinDef = this.json.skins[skinIndex];\\n      var skinEntry = {\\n        joints: skinDef.joints\\n      };\\n\\n      if (skinDef.inverseBindMatrices === undefined) {\\n        return Promise.resolve(skinEntry);\\n      }\\n\\n      return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\\n        skinEntry.inverseBindMatrices = accessor;\\n        return skinEntry;\\n      });\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\\n     * @param {number} animationIndex\\n     * @return {Promise<AnimationClip>}\\n     */\\n\\n  }, {\\n    key: \\\"loadAnimation\\\",\\n    value: function loadAnimation(animationIndex) {\\n      var json = this.json;\\n      var animationDef = json.animations[animationIndex];\\n      var pendingNodes = [];\\n      var pendingInputAccessors = [];\\n      var pendingOutputAccessors = [];\\n      var pendingSamplers = [];\\n      var pendingTargets = [];\\n\\n      for (var i = 0, il = animationDef.channels.length; i < il; i++) {\\n        var channel = animationDef.channels[i];\\n        var sampler = animationDef.samplers[channel.sampler];\\n        var target = channel.target;\\n        var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\\n\\n        var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\\n        var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\\n        pendingNodes.push(this.getDependency('node', name));\\n        pendingInputAccessors.push(this.getDependency('accessor', input));\\n        pendingOutputAccessors.push(this.getDependency('accessor', output));\\n        pendingSamplers.push(sampler);\\n        pendingTargets.push(target);\\n      }\\n\\n      return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\\n        var nodes = dependencies[0];\\n        var inputAccessors = dependencies[1];\\n        var outputAccessors = dependencies[2];\\n        var samplers = dependencies[3];\\n        var targets = dependencies[4];\\n        var tracks = [];\\n\\n        var _loop = function _loop(_i6, _il5) {\\n          var node = nodes[_i6];\\n          var inputAccessor = inputAccessors[_i6];\\n          var outputAccessor = outputAccessors[_i6];\\n          var sampler = samplers[_i6];\\n          var target = targets[_i6];\\n          if (node === undefined) return \\\"continue\\\";\\n          node.updateMatrix();\\n          node.matrixAutoUpdate = true;\\n          var TypedKeyframeTrack = void 0;\\n\\n          switch (PATH_PROPERTIES[target.path]) {\\n            case PATH_PROPERTIES.weights:\\n              TypedKeyframeTrack = _three.NumberKeyframeTrack;\\n              break;\\n\\n            case PATH_PROPERTIES.rotation:\\n              TypedKeyframeTrack = _three.QuaternionKeyframeTrack;\\n              break;\\n\\n            case PATH_PROPERTIES.position:\\n            case PATH_PROPERTIES.scale:\\n            default:\\n              TypedKeyframeTrack = _three.VectorKeyframeTrack;\\n              break;\\n          }\\n\\n          var targetName = node.name ? node.name : node.uuid;\\n          var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : _three.InterpolateLinear;\\n          var targetNames = [];\\n\\n          if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\\n            // Node may be a Group (glTF mesh with several primitives) or a Mesh.\\n            node.traverse(function (object) {\\n              if (object.isMesh === true && object.morphTargetInfluences) {\\n                targetNames.push(object.name ? object.name : object.uuid);\\n              }\\n            });\\n          } else {\\n            targetNames.push(targetName);\\n          }\\n\\n          var outputArray = outputAccessor.array;\\n\\n          if (outputAccessor.normalized) {\\n            var scale = getNormalizedComponentScale(outputArray.constructor);\\n            var scaled = new Float32Array(outputArray.length);\\n\\n            for (var j = 0, jl = outputArray.length; j < jl; j++) {\\n              scaled[j] = outputArray[j] * scale;\\n            }\\n\\n            outputArray = scaled;\\n          }\\n\\n          for (var _j = 0, _jl = targetNames.length; _j < _jl; _j++) {\\n            var track = new TypedKeyframeTrack(targetNames[_j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\\n\\n            if (sampler.interpolation === 'CUBICSPLINE') {\\n              track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\\n                // A CUBICSPLINE keyframe in glTF has three output values for each input value,\\n                // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\\n                // must be divided by three to get the interpolant's sampleSize argument.\\n                return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\\n              }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\\n\\n\\n              track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\\n            }\\n\\n            tracks.push(track);\\n          }\\n        };\\n\\n        for (var _i6 = 0, _il5 = nodes.length; _i6 < _il5; _i6++) {\\n          var _ret = _loop(_i6, _il5);\\n\\n          if (_ret === \\\"continue\\\") continue;\\n        }\\n\\n        var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\\n        return new _three.AnimationClip(name, undefined, tracks);\\n      });\\n    }\\n  }, {\\n    key: \\\"createNodeMesh\\\",\\n    value: function createNodeMesh(nodeIndex) {\\n      var json = this.json;\\n      var parser = this;\\n      var nodeDef = json.nodes[nodeIndex];\\n      if (nodeDef.mesh === undefined) return null;\\n      return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\\n        var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh); // if weights are provided on the node, override weights on the mesh.\\n\\n\\n        if (nodeDef.weights !== undefined) {\\n          node.traverse(function (o) {\\n            if (!o.isMesh) return;\\n\\n            for (var i = 0, il = nodeDef.weights.length; i < il; i++) {\\n              o.morphTargetInfluences[i] = nodeDef.weights[i];\\n            }\\n          });\\n        }\\n\\n        return node;\\n      });\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\\n     * @param {number} nodeIndex\\n     * @return {Promise<Object3D>}\\n     */\\n\\n  }, {\\n    key: \\\"loadNode\\\",\\n    value: function loadNode(nodeIndex) {\\n      var json = this.json;\\n      var extensions = this.extensions;\\n      var parser = this;\\n      var nodeDef = json.nodes[nodeIndex]; // reserve node's name before its dependencies, so the root has the intended name.\\n\\n      var nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';\\n      return function () {\\n        var pending = [];\\n\\n        var meshPromise = parser._invokeOne(function (ext) {\\n          return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\\n        });\\n\\n        if (meshPromise) {\\n          pending.push(meshPromise);\\n        }\\n\\n        if (nodeDef.camera !== undefined) {\\n          pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {\\n            return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\\n          }));\\n        }\\n\\n        parser._invokeAll(function (ext) {\\n          return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\\n        }).forEach(function (promise) {\\n          pending.push(promise);\\n        });\\n\\n        return Promise.all(pending);\\n      }().then(function (objects) {\\n        var node; // .isBone isn't in glTF spec. See ._markDefs\\n\\n        if (nodeDef.isBone === true) {\\n          node = new _three.Bone();\\n        } else if (objects.length > 1) {\\n          node = new _three.Group();\\n        } else if (objects.length === 1) {\\n          node = objects[0];\\n        } else {\\n          node = new _three.Object3D();\\n        }\\n\\n        if (node !== objects[0]) {\\n          for (var i = 0, il = objects.length; i < il; i++) {\\n            node.add(objects[i]);\\n          }\\n        }\\n\\n        if (nodeDef.name) {\\n          node.userData.name = nodeDef.name;\\n          node.name = nodeName;\\n        }\\n\\n        assignExtrasToUserData(node, nodeDef);\\n        if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\\n\\n        if (nodeDef.matrix !== undefined) {\\n          var matrix = new _three.Matrix4();\\n          matrix.fromArray(nodeDef.matrix);\\n          node.applyMatrix4(matrix);\\n        } else {\\n          if (nodeDef.translation !== undefined) {\\n            node.position.fromArray(nodeDef.translation);\\n          }\\n\\n          if (nodeDef.rotation !== undefined) {\\n            node.quaternion.fromArray(nodeDef.rotation);\\n          }\\n\\n          if (nodeDef.scale !== undefined) {\\n            node.scale.fromArray(nodeDef.scale);\\n          }\\n        }\\n\\n        parser.associations.set(node, {\\n          type: 'nodes',\\n          index: nodeIndex\\n        });\\n        return node;\\n      });\\n    }\\n    /**\\n     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\\n     * @param {number} sceneIndex\\n     * @return {Promise<Group>}\\n     */\\n\\n  }, {\\n    key: \\\"loadScene\\\",\\n    value: function loadScene(sceneIndex) {\\n      var json = this.json;\\n      var extensions = this.extensions;\\n      var sceneDef = this.json.scenes[sceneIndex];\\n      var parser = this; // Loader returns Group, not Scene.\\n      // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\\n\\n      var scene = new _three.Group();\\n      if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\\n      assignExtrasToUserData(scene, sceneDef);\\n      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\\n      var nodeIds = sceneDef.nodes || [];\\n      var pending = [];\\n\\n      for (var i = 0, il = nodeIds.length; i < il; i++) {\\n        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\\n      }\\n\\n      return Promise.all(pending).then(function () {\\n        return scene;\\n      });\\n    }\\n  }]);\\n\\n  return GLTFParser;\\n}();\\n\\nfunction buildNodeHierachy(nodeId, parentObject, json, parser) {\\n  var nodeDef = json.nodes[nodeId];\\n  return parser.getDependency('node', nodeId).then(function (node) {\\n    if (nodeDef.skin === undefined) return node; // build skeleton here as well\\n\\n    var skinEntry;\\n    return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\\n      skinEntry = skin;\\n      var pendingJoints = [];\\n\\n      for (var i = 0, il = skinEntry.joints.length; i < il; i++) {\\n        pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\\n      }\\n\\n      return Promise.all(pendingJoints);\\n    }).then(function (jointNodes) {\\n      node.traverse(function (mesh) {\\n        if (!mesh.isMesh) return;\\n        var bones = [];\\n        var boneInverses = [];\\n\\n        for (var j = 0, jl = jointNodes.length; j < jl; j++) {\\n          var jointNode = jointNodes[j];\\n\\n          if (jointNode) {\\n            bones.push(jointNode);\\n            var mat = new _three.Matrix4();\\n\\n            if (skinEntry.inverseBindMatrices !== undefined) {\\n              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\\n            }\\n\\n            boneInverses.push(mat);\\n          } else {\\n            console.warn('THREE.GLTFLoader: Joint \\\"%s\\\" could not be found.', skinEntry.joints[j]);\\n          }\\n        }\\n\\n        mesh.bind(new _three.Skeleton(bones, boneInverses), mesh.matrixWorld);\\n      });\\n      return node;\\n    });\\n  }).then(function (node) {\\n    // build node hierachy\\n    parentObject.add(node);\\n    var pending = [];\\n\\n    if (nodeDef.children) {\\n      var children = nodeDef.children;\\n\\n      for (var i = 0, il = children.length; i < il; i++) {\\n        var child = children[i];\\n        pending.push(buildNodeHierachy(child, node, json, parser));\\n      }\\n    }\\n\\n    return Promise.all(pending);\\n  });\\n}\\n/**\\n * @param {BufferGeometry} geometry\\n * @param {GLTF.Primitive} primitiveDef\\n * @param {GLTFParser} parser\\n */\\n\\n\\nfunction computeBounds(geometry, primitiveDef, parser) {\\n  var attributes = primitiveDef.attributes;\\n  var box = new _three.Box3();\\n\\n  if (attributes.POSITION !== undefined) {\\n    var accessor = parser.json.accessors[attributes.POSITION];\\n    var min = accessor.min;\\n    var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\\n\\n    if (min !== undefined && max !== undefined) {\\n      box.set(new _three.Vector3(min[0], min[1], min[2]), new _three.Vector3(max[0], max[1], max[2]));\\n\\n      if (accessor.normalized) {\\n        var boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\\n        box.min.multiplyScalar(boxScale);\\n        box.max.multiplyScalar(boxScale);\\n      }\\n    } else {\\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\\n      return;\\n    }\\n  } else {\\n    return;\\n  }\\n\\n  var targets = primitiveDef.targets;\\n\\n  if (targets !== undefined) {\\n    var maxDisplacement = new _three.Vector3();\\n    var vector = new _three.Vector3();\\n\\n    for (var i = 0, il = targets.length; i < il; i++) {\\n      var target = targets[i];\\n\\n      if (target.POSITION !== undefined) {\\n        var _accessor = parser.json.accessors[target.POSITION];\\n        var _min = _accessor.min;\\n        var _max = _accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\\n\\n        if (_min !== undefined && _max !== undefined) {\\n          // we need to get max of absolute components because target weight is [-1,1]\\n          vector.setX(Math.max(Math.abs(_min[0]), Math.abs(_max[0])));\\n          vector.setY(Math.max(Math.abs(_min[1]), Math.abs(_max[1])));\\n          vector.setZ(Math.max(Math.abs(_min[2]), Math.abs(_max[2])));\\n\\n          if (_accessor.normalized) {\\n            var _boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[_accessor.componentType]);\\n\\n            vector.multiplyScalar(_boxScale);\\n          } // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\\n\\n\\n          maxDisplacement.max(vector);\\n        } else {\\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\\n        }\\n      }\\n    } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\\n\\n\\n    box.expandByVector(maxDisplacement);\\n  }\\n\\n  geometry.boundingBox = box;\\n  var sphere = new _three.Sphere();\\n  box.getCenter(sphere.center);\\n  sphere.radius = box.min.distanceTo(box.max) / 2;\\n  geometry.boundingSphere = sphere;\\n}\\n/**\\n * @param {BufferGeometry} geometry\\n * @param {GLTF.Primitive} primitiveDef\\n * @param {GLTFParser} parser\\n * @return {Promise<BufferGeometry>}\\n */\\n\\n\\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\\n  var attributes = primitiveDef.attributes;\\n  var pending = [];\\n\\n  function assignAttributeAccessor(accessorIndex, attributeName) {\\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\\n      geometry.setAttribute(attributeName, accessor);\\n    });\\n  }\\n\\n  for (var gltfAttributeName in attributes) {\\n    var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\\n\\n    if (threeAttributeName in geometry.attributes) continue;\\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\\n  }\\n\\n  if (primitiveDef.indices !== undefined && !geometry.index) {\\n    var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\\n      geometry.setIndex(accessor);\\n    });\\n    pending.push(accessor);\\n  }\\n\\n  assignExtrasToUserData(geometry, primitiveDef);\\n  computeBounds(geometry, primitiveDef, parser);\\n  return Promise.all(pending).then(function () {\\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\\n  });\\n}\\n/**\\n * @param {BufferGeometry} geometry\\n * @param {Number} drawMode\\n * @return {BufferGeometry}\\n */\\n\\n\\nfunction toTrianglesDrawMode(geometry, drawMode) {\\n  var index = geometry.getIndex(); // generate index if not present\\n\\n  if (index === null) {\\n    var indices = [];\\n    var position = geometry.getAttribute('position');\\n\\n    if (position !== undefined) {\\n      for (var i = 0; i < position.count; i++) {\\n        indices.push(i);\\n      }\\n\\n      geometry.setIndex(indices);\\n      index = geometry.getIndex();\\n    } else {\\n      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\\n      return geometry;\\n    }\\n  } //\\n\\n\\n  var numberOfTriangles = index.count - 2;\\n  var newIndices = [];\\n\\n  if (drawMode === _three.TriangleFanDrawMode) {\\n    // gl.TRIANGLE_FAN\\n    for (var _i7 = 1; _i7 <= numberOfTriangles; _i7++) {\\n      newIndices.push(index.getX(0));\\n      newIndices.push(index.getX(_i7));\\n      newIndices.push(index.getX(_i7 + 1));\\n    }\\n  } else {\\n    // gl.TRIANGLE_STRIP\\n    for (var _i8 = 0; _i8 < numberOfTriangles; _i8++) {\\n      if (_i8 % 2 === 0) {\\n        newIndices.push(index.getX(_i8));\\n        newIndices.push(index.getX(_i8 + 1));\\n        newIndices.push(index.getX(_i8 + 2));\\n      } else {\\n        newIndices.push(index.getX(_i8 + 2));\\n        newIndices.push(index.getX(_i8 + 1));\\n        newIndices.push(index.getX(_i8));\\n      }\\n    }\\n  }\\n\\n  if (newIndices.length / 3 !== numberOfTriangles) {\\n    console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\\n  } // build final geometry\\n\\n\\n  var newGeometry = geometry.clone();\\n  newGeometry.setIndex(newIndices);\\n  return newGeometry;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_get\",\"target\",\"property\",\"receiver\",\"Reflect\",\"get\",\"Object\",\"prototype\",\"hasOwnProperty\",\"call\",\"object\",\"_getPrototypeOf\",\"base\",\"desc\",\"getOwnPropertyDescriptor\",\"value\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"_classCallCheck\",\"instance\",\"Constructor\",\"TypeError\",\"_defineProperties\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"defineProperty\",\"key\",\"_createClass\",\"protoProps\",\"staticProps\",\"_possibleConstructorReturn\",\"self\",\"_assertThisInitialized\",\"ReferenceError\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"create\",\"_setPrototypeOf\",\"p\",\"GLTFRegistry\",\"objects\",\"add\",\"remove\",\"removeAll\",\"resolveURL\",\"url\",\"path\",\"test\",\"replace\",\"createDefaultMaterial\",\"cache\",\"undefined\",\"_three\",\"MeshStandardMaterial\",\"color\",\"emissive\",\"metalness\",\"roughness\",\"transparent\",\"depthTest\",\"side\",\"FrontSide\",\"addUnknownExtensionsToUserData\",\"knownExtensions\",\"objectDef\",\"name\",\"extensions\",\"userData\",\"gltfExtensions\",\"assignExtrasToUserData\",\"gltfDef\",\"extras\",\"assign\",\"console\",\"warn\",\"addMorphTargets\",\"geometry\",\"targets\",\"parser\",\"hasMorphPosition\",\"hasMorphNormal\",\"il\",\"POSITION\",\"NORMAL\",\"Promise\",\"resolve\",\"pendingPositionAccessors\",\"pendingNormalAccessors\",\"_i2\",\"_il\",\"_target\",\"pendingAccessor\",\"getDependency\",\"attributes\",\"position\",\"push\",\"_pendingAccessor\",\"normal\",\"all\",\"then\",\"accessors\",\"morphPositions\",\"morphNormals\",\"morphAttributes\",\"morphTargetsRelative\",\"createPrimitiveKey\",\"primitiveDef\",\"dracoExtension\",\"EXTENSIONS\",\"KHR_DRACO_MESH_COMPRESSION\",\"geometryKey\",\"bufferView\",\"indices\",\"createAttributesKey\",\"mode\",\"attributesKey\",\"keys\",\"sort\",\"getNormalizedComponentScale\",\"Int8Array\",\"Uint8Array\",\"Int16Array\",\"Uint16Array\",\"Error\",\"buildNodeHierachy\",\"nodeId\",\"parentObject\",\"json\",\"nodeDef\",\"nodes\",\"node\",\"skin\",\"skinEntry\",\"pendingJoints\",\"joints\",\"jointNodes\",\"traverse\",\"mesh\",\"isMesh\",\"bones\",\"boneInverses\",\"j\",\"jl\",\"jointNode\",\"mat\",\"Matrix4\",\"inverseBindMatrices\",\"fromArray\",\"array\",\"bind\",\"Skeleton\",\"matrixWorld\",\"pending\",\"children\",\"child\",\"computeBounds\",\"box\",\"Box3\",\"accessor\",\"min\",\"max\",\"set\",\"Vector3\",\"normalized\",\"boxScale\",\"WEBGL_COMPONENT_TYPES\",\"componentType\",\"multiplyScalar\",\"maxDisplacement\",\"vector\",\"_accessor\",\"_min\",\"_max\",\"setX\",\"Math\",\"abs\",\"setY\",\"setZ\",\"_boxScale\",\"expandByVector\",\"boundingBox\",\"sphere\",\"Sphere\",\"getCenter\",\"center\",\"radius\",\"distanceTo\",\"boundingSphere\",\"addPrimitiveAttributes\",\"assignAttributeAccessor\",\"accessorIndex\",\"attributeName\",\"setAttribute\",\"gltfAttributeName\",\"threeAttributeName\",\"ATTRIBUTES\",\"toLowerCase\",\"index\",\"setIndex\",\"toTrianglesDrawMode\",\"drawMode\",\"getIndex\",\"getAttribute\",\"count\",\"error\",\"numberOfTriangles\",\"newIndices\",\"TriangleFanDrawMode\",\"_i7\",\"getX\",\"_i8\",\"newGeometry\",\"clone\",\"GLTFLoader\",\"_Loader\",\"manager\",\"_this\",\"dracoLoader\",\"ktx2Loader\",\"meshoptDecoder\",\"pluginCallbacks\",\"register\",\"GLTFMaterialsClearcoatExtension\",\"GLTFTextureBasisUExtension\",\"GLTFTextureWebPExtension\",\"GLTFMaterialsTransmissionExtension\",\"GLTFMaterialsVolumeExtension\",\"GLTFMaterialsIorExtension\",\"GLTFMaterialsSpecularExtension\",\"GLTFLightsExtension\",\"GLTFMeshoptCompression\",\"load\",\"onLoad\",\"onProgress\",\"onError\",\"scope\",\"resourcePath\",\"LoaderUtils\",\"extractUrlBase\",\"itemStart\",\"_onError\",\"e\",\"itemError\",\"itemEnd\",\"loader\",\"FileLoader\",\"setPath\",\"setResponseType\",\"setRequestHeader\",\"requestHeader\",\"setWithCredentials\",\"withCredentials\",\"data\",\"parse\",\"gltf\",\"setDRACOLoader\",\"setDDSLoader\",\"setKTX2Loader\",\"setMeshoptDecoder\",\"callback\",\"indexOf\",\"unregister\",\"splice\",\"plugins\",\"decodeText\",\"magic\",\"BINARY_EXTENSION_HEADER_MAGIC\",\"KHR_BINARY_GLTF\",\"GLTFBinaryExtension\",\"content\",\"JSON\",\"asset\",\"version\",\"GLTFParser\",\"crossOrigin\",\"fileLoader\",\"plugin\",\"extensionsUsed\",\"_i\",\"extensionName\",\"extensionsRequired\",\"KHR_MATERIALS_UNLIT\",\"GLTFMaterialsUnlitExtension\",\"KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS\",\"GLTFMaterialsPbrSpecularGlossinessExtension\",\"GLTFDracoMeshCompressionExtension\",\"KHR_TEXTURE_TRANSFORM\",\"GLTFTextureTransformExtension\",\"KHR_MESH_QUANTIZATION\",\"GLTFMeshQuantizationExtension\",\"setExtensions\",\"setPlugins\",\"Loader\",\"KHR_LIGHTS_PUNCTUAL\",\"KHR_MATERIALS_CLEARCOAT\",\"KHR_MATERIALS_IOR\",\"KHR_MATERIALS_SPECULAR\",\"KHR_MATERIALS_TRANSMISSION\",\"KHR_MATERIALS_VOLUME\",\"KHR_TEXTURE_BASISU\",\"EXT_TEXTURE_WEBP\",\"EXT_MESHOPT_COMPRESSION\",\"refs\",\"uses\",\"_markDefs\",\"nodeDefs\",\"nodeIndex\",\"nodeLength\",\"light\",\"_addNodeRef\",\"_loadLight\",\"lightIndex\",\"cacheKey\",\"dependency\",\"lightDef\",\"lights\",\"Color\",\"range\",\"type\",\"lightNode\",\"DirectionalLight\",\"PointLight\",\"distance\",\"SpotLight\",\"spot\",\"innerConeAngle\",\"outerConeAngle\",\"PI\",\"angle\",\"penumbra\",\"decay\",\"intensity\",\"createUniqueName\",\"createNodeAttachment\",\"_getNodeRef\",\"getMaterialType\",\"MeshBasicMaterial\",\"extendParams\",\"materialParams\",\"materialDef\",\"opacity\",\"metallicRoughness\",\"pbrMetallicRoughness\",\"Array\",\"isArray\",\"baseColorFactor\",\"baseColorTexture\",\"assignTexture\",\"materialIndex\",\"materials\",\"MeshPhysicalMaterial\",\"extendMaterialParams\",\"extension\",\"clearcoatFactor\",\"clearcoat\",\"clearcoatTexture\",\"clearcoatRoughnessFactor\",\"clearcoatRoughness\",\"clearcoatRoughnessTexture\",\"clearcoatNormalTexture\",\"scale\",\"clearcoatNormalScale\",\"Vector2\",\"transmissionFactor\",\"transmission\",\"transmissionTexture\",\"thickness\",\"thicknessFactor\",\"thicknessTexture\",\"attenuationDistance\",\"colorArray\",\"attenuationColor\",\"attenuationTint\",\"ior\",\"specularIntensity\",\"specularFactor\",\"specularTexture\",\"specularColorFactor\",\"specularTint\",\"specularColorTexture\",\"texture\",\"encoding\",\"sRGBEncoding\",\"loadTexture\",\"textureIndex\",\"textureDef\",\"textures\",\"source\",\"images\",\"options\",\"loadTextureImage\",\"isSupported\",\"textureLoader\",\"uri\",\"handler\",\"getHandler\",\"detectSupport\",\"image\",\"Image\",\"src\",\"onload\",\"onerror\",\"image.onerror\",\"height\",\"loadBufferView\",\"bufferViews\",\"extensionDef\",\"buffer\",\"decoder\",\"supported\",\"ready\",\"res\",\"byteOffset\",\"byteLength\",\"stride\",\"byteStride\",\"result\",\"ArrayBuffer\",\"decodeGltfBuffer\",\"filter\",\"body\",\"headerView\",\"DataView\",\"BINARY_EXTENSION_HEADER_LENGTH\",\"header\",\"slice\",\"getUint32\",\"chunkContentsLength\",\"chunkView\",\"chunkIndex\",\"chunkLength\",\"chunkType\",\"contentArray\",\"BIN\",\"preload\",\"decodePrimitive\",\"primitive\",\"bufferViewIndex\",\"gltfAttributeMap\",\"threeAttributeMap\",\"attributeNormalizedMap\",\"attributeTypeMap\",\"_attributeName\",\"_threeAttributeName\",\"accessorDef\",\"decodeDracoFile\",\"_attributeName2\",\"attribute\",\"extendTexture\",\"transform\",\"texCoord\",\"offset\",\"rotation\",\"repeat\",\"needsUpdate\",\"GLTFMeshStandardSGMaterial\",\"_MeshStandardMaterial\",\"params\",\"_this2\",\"isGLTFSpecularGlossinessMaterial\",\"uniforms\",\"specular\",\"setHex\",\"glossiness\",\"specularMap\",\"glossinessMap\",\"_extraUniforms\",\"onBeforeCompile\",\"_this2.onBeforeCompile\",\"shader\",\"uniformName\",\"fragmentShader\",\"specularMapParsFragmentChunk\",\"glossinessMapParsFragmentChunk\",\"specularMapFragmentChunk\",\"glossinessMapFragmentChunk\",\"lightPhysicalFragmentChunk\",\"defineProperties\",\"v\",\"defines\",\"USE_SPECULARMAP\",\"USE_GLOSSINESSMAP\",\"USE_UV\",\"metalnessMap\",\"roughnessMap\",\"setValues\",\"copy\",\"specularGlossinessParams\",\"pbrSpecularGlossiness\",\"diffuseFactor\",\"diffuseTexture\",\"glossinessFactor\",\"specularGlossinessTexture\",\"specGlossMapDef\",\"createMaterial\",\"material\",\"fog\",\"map\",\"lightMap\",\"lightMapIntensity\",\"aoMap\",\"aoMapIntensity\",\"emissiveIntensity\",\"emissiveMap\",\"bumpMap\",\"bumpScale\",\"normalMap\",\"normalMapType\",\"TangentSpaceNormalMap\",\"normalScale\",\"displacementMap\",\"displacementScale\",\"displacementBias\",\"alphaMap\",\"envMap\",\"envMapIntensity\",\"refractionRatio\",\"GLTFCubicSplineInterpolant\",\"_Interpolant\",\"parameterPositions\",\"sampleValues\",\"sampleSize\",\"resultBuffer\",\"copySampleValue_\",\"values\",\"valueSize\",\"Interpolant\",\"beforeStart_\",\"afterEnd_\",\"interpolate_\",\"GLTFCubicSplineInterpolant.prototype.interpolate_\",\"i1\",\"t0\",\"t\",\"t1\",\"stride2\",\"stride3\",\"td\",\"pp\",\"ppp\",\"offset1\",\"offset0\",\"s2\",\"s3\",\"s0\",\"s1\",\"p0\",\"p1\",\"Uint32Array\",\"Float32Array\",\"WEBGL_FILTERS\",\"NearestFilter\",\"LinearFilter\",\"NearestMipmapNearestFilter\",\"LinearMipmapNearestFilter\",\"NearestMipmapLinearFilter\",\"LinearMipmapLinearFilter\",\"WEBGL_WRAPPINGS\",\"ClampToEdgeWrapping\",\"MirroredRepeatWrapping\",\"RepeatWrapping\",\"WEBGL_TYPE_SIZES\",\"SCALAR\",\"VEC2\",\"VEC3\",\"VEC4\",\"MAT2\",\"MAT3\",\"MAT4\",\"TANGENT\",\"TEXCOORD_0\",\"TEXCOORD_1\",\"COLOR_0\",\"WEIGHTS_0\",\"JOINTS_0\",\"PATH_PROPERTIES\",\"translation\",\"weights\",\"INTERPOLATION\",\"CUBICSPLINE\",\"LINEAR\",\"InterpolateLinear\",\"STEP\",\"InterpolateDiscrete\",\"arguments\",\"associations\",\"Map\",\"primitiveCache\",\"meshCache\",\"cameraCache\",\"lightCache\",\"textureCache\",\"nodeNamesUsed\",\"createImageBitmap\",\"navigator\",\"userAgent\",\"ImageBitmapLoader\",\"TextureLoader\",\"setCrossOrigin\",\"_invokeAll\",\"ext\",\"beforeRoot\",\"getDependencies\",\"dependencies\",\"scene\",\"scenes\",\"animations\",\"cameras\",\"afterRoot\",\"skinDefs\",\"skins\",\"meshDefs\",\"meshes\",\"skinIndex\",\"skinLength\",\"isBone\",\"isSkinnedMesh\",\"camera\",\"ref\",\"_invokeOne\",\"func\",\"unshift\",\"loadScene\",\"loadNode\",\"loadMesh\",\"loadAccessor\",\"loadBuffer\",\"loadMaterial\",\"loadSkin\",\"loadAnimation\",\"loadCamera\",\"def\",\"bufferIndex\",\"bufferDef\",\"buffers\",\"reject\",\"bufferViewDef\",\"sparse\",\"pendingBufferViews\",\"itemSize\",\"TypedArray\",\"elementBytes\",\"BYTES_PER_ELEMENT\",\"ibSlice\",\"floor\",\"ibCacheKey\",\"ib\",\"InterleavedBuffer\",\"bufferAttribute\",\"InterleavedBufferAttribute\",\"BufferAttribute\",\"byteOffsetValues\",\"sparseIndices\",\"TypedArrayIndices\",\"sparseValues\",\"setW\",\"sampler\",\"URL\",\"webkitURL\",\"sourceURI\",\"isObjectURL\",\"hasAlpha\",\"isJPEG\",\"search\",\"mimeType\",\"colorType\",\"getUint8\",\"blob\",\"Blob\",\"createObjectURL\",\"promise\",\"isImageBitmapLoader\",\"imageBitmap\",\"Texture\",\"revokeObjectURL\",\"flipY\",\"format\",\"RGBFormat\",\"samplers\",\"magFilter\",\"minFilter\",\"wrapS\",\"wrapT\",\"mapName\",\"mapDef\",\"gltfReference\",\"assignFinalMaterial\",\"useVertexTangents\",\"tangent\",\"useVertexColors\",\"useFlatShading\",\"isPoints\",\"uuid\",\"pointsMaterial\",\"PointsMaterial\",\"Material\",\"sizeAttenuation\",\"isLine\",\"_cacheKey\",\"lineMaterial\",\"LineBasicMaterial\",\"_cacheKey2\",\"cachedMaterial\",\"vertexColors\",\"flatShading\",\"y\",\"uv2\",\"uv\",\"materialExtensions\",\"sgExtension\",\"materialType\",\"kmuExtension\",\"metallicFactor\",\"roughnessFactor\",\"metallicRoughnessTexture\",\"doubleSided\",\"DoubleSide\",\"alphaMode\",\"OPAQUE\",\"BLEND\",\"depthWrite\",\"MASK\",\"alphaTest\",\"alphaCutoff\",\"normalTexture\",\"occlusionTexture\",\"strength\",\"emissiveFactor\",\"emissiveTexture\",\"originalName\",\"sanitizedName\",\"PropertyBinding\",\"sanitizeNodeName\",\"loadGeometries\",\"primitives\",\"createDracoPrimitive\",\"cached\",\"geometryPromise\",\"BufferGeometry\",\"meshIndex\",\"meshDef\",\"results\",\"geometries\",\"_i4\",\"_il3\",\"_material\",\"TRIANGLES\",\"TRIANGLE_STRIP\",\"TRIANGLE_FAN\",\"SkinnedMesh\",\"Mesh\",\"skinWeight\",\"normalizeSkinWeights\",\"TriangleStripDrawMode\",\"LINES\",\"LineSegments\",\"LINE_STRIP\",\"Line\",\"LINE_LOOP\",\"LineLoop\",\"POINTS\",\"Points\",\"updateMorphTargets\",\"morphTargetInfluences\",\"targetNames\",\"morphTargetDictionary\",\"_il2\",\"_i3\",\"group\",\"Group\",\"_i5\",\"_il4\",\"cameraIndex\",\"cameraDef\",\"PerspectiveCamera\",\"MathUtils\",\"radToDeg\",\"yfov\",\"aspectRatio\",\"znear\",\"zfar\",\"OrthographicCamera\",\"xmag\",\"ymag\",\"skinDef\",\"animationIndex\",\"animationDef\",\"pendingNodes\",\"pendingInputAccessors\",\"pendingOutputAccessors\",\"pendingSamplers\",\"pendingTargets\",\"channels\",\"channel\",\"input\",\"parameters\",\"output\",\"id\",\"inputAccessors\",\"outputAccessors\",\"tracks\",\"_loop\",\"_i6\",\"_il5\",\"inputAccessor\",\"outputAccessor\",\"updateMatrix\",\"matrixAutoUpdate\",\"TypedKeyframeTrack\",\"NumberKeyframeTrack\",\"QuaternionKeyframeTrack\",\"VectorKeyframeTrack\",\"targetName\",\"interpolation\",\"outputArray\",\"scaled\",\"_j\",\"_jl\",\"track\",\"createInterpolant\",\"track.createInterpolant\",\"times\",\"getValueSize\",\"isInterpolantFactoryMethodGLTFCubicSpline\",\"_ret\",\"AnimationClip\",\"createNodeMesh\",\"nodeName\",\"meshPromise\",\"forEach\",\"Bone\",\"Object3D\",\"matrix\",\"applyMatrix4\",\"quaternion\",\"sceneIndex\",\"sceneDef\",\"nodeIds\"]\n}\n"]