["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/LWOLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$LWOLoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");\n}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=\nObject.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,\np$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}function extractParentUrl(url,dir){dir=url.indexOf(dir);return-1===dir?\"./\":url.substr(0,dir)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.LWOLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_IFFParser=require(\"module$node_modules$three_stdlib$loaders$lwo$IFFParser\"),_lwoTree;global=function(_Loader){function LWOLoader(manager){var parameters=\n1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,LWOLoader);var _this=_getPrototypeOf(LWOLoader).call(this,manager);if(!_this||\"object\"!==_typeof(_this)&&\"function\"!==typeof _this){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");_this=this}_this.resourcePath=void 0!==parameters.resourcePath?parameters.resourcePath:\"\";return _this}_inherits(LWOLoader,_Loader);_createClass(LWOLoader,[{key:\"load\",value:function(url,\nonLoad,onProgress,onError){var scope=this,path=\"\"===scope.path?extractParentUrl(url,\"Objects\"):scope.path,modelName=url.split(path).pop().split(\".\")[0],loader=new _three.FileLoader(this.manager);loader.setPath(scope.path);loader.setResponseType(\"arraybuffer\");loader.load(url,function(buffer){try{onLoad(scope.parse(buffer,path,modelName))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}},onProgress,onError)}},{key:\"parse\",value:function(iffBuffer,path,modelName){_lwoTree=\n(new _IFFParser.IFFParser).parse(iffBuffer);iffBuffer=(new _three.TextureLoader(this.manager)).setPath(this.resourcePath||path).setCrossOrigin(this.crossOrigin);return(new LWOTreeParser(iffBuffer)).parse(modelName)}}]);return LWOLoader}(_three.Loader);exports.LWOLoader=global;var LWOTreeParser=function(){function LWOTreeParser(textureLoader){_classCallCheck(this,LWOTreeParser);this.textureLoader=textureLoader}_createClass(LWOTreeParser,[{key:\"parse\",value:function(modelName){this.materials=(new MaterialParser(this.textureLoader)).parse();\nthis.defaultLayerName=modelName;this.meshes=this.parseLayers();return{materials:this.materials,meshes:this.meshes}}},{key:\"parseLayers\",value:function(){var meshes=[],finalMeshes=[],geometryParser=new GeometryParser$jscomp$0,scope=this;_lwoTree.layers.forEach(function(layer){var geometry=geometryParser.parse(layer.geometry,layer);geometry=scope.parseMesh(geometry,layer);meshes[layer.number]=geometry;-1===layer.parent?finalMeshes.push(geometry):meshes[layer.parent].add(geometry)});this.applyPivots(finalMeshes);\nreturn finalMeshes}},{key:\"parseMesh\",value:function(geometry,layer){var materials=this.getMaterials(geometry.userData.matNames,layer.geometry.type);this.duplicateUVs(geometry,materials);geometry=\"points\"===layer.geometry.type?new _three.Points(geometry,materials):\"lines\"===layer.geometry.type?new _three.LineSegments(geometry,materials):new _three.Mesh(geometry,materials);geometry.name=layer.name?layer.name:this.defaultLayerName+\"_layer_\"+layer.number;geometry.userData.pivot=layer.pivot;return geometry}},\n{key:\"applyPivots\",value:function(meshes){meshes.forEach(function(mesh){mesh.traverse(function(child){var pivot=child.userData.pivot;child.position.x+=pivot[0];child.position.y+=pivot[1];child.position.z+=pivot[2];child.parent&&(pivot=child.parent.userData.pivot,child.position.x-=pivot[0],child.position.y-=pivot[1],child.position.z-=pivot[2])})})}},{key:\"getMaterials\",value:function(namesArray,type){var materials=[],scope=this;namesArray.forEach(function(name,i){materials[i]=scope.getMaterialByName(name)});\n\"points\"!==type&&\"lines\"!==type||materials.forEach(function(mat,i){var spec={color:mat.color};\"points\"===type?(spec.size=.1,spec.map=mat.map,spec.morphTargets=mat.morphTargets,materials[i]=new _three.PointsMaterial(spec)):\"lines\"===type&&(materials[i]=new _three.LineBasicMaterial(spec))});namesArray=materials.filter(Boolean);return 1===namesArray.length?namesArray[0]:materials}},{key:\"getMaterialByName\",value:function(name){return this.materials.filter(function(m){return m.name===name})[0]}},{key:\"duplicateUVs\",\nvalue:function(geometry,materials){var duplicateUVs=!1;Array.isArray(materials)?materials.forEach(function(material){material.aoMap&&(duplicateUVs=!0)}):materials.aoMap&&(duplicateUVs=!0);duplicateUVs&&geometry.setAttribute(\"uv2\",new _three.BufferAttribute(geometry.attributes.uv.array,2))}}]);return LWOTreeParser}(),MaterialParser=function(){function MaterialParser(textureLoader){_classCallCheck(this,MaterialParser);this.textureLoader=textureLoader}_createClass(MaterialParser,[{key:\"parse\",value:function(){var materials=\n[];this.textures={};for(var name in _lwoTree.materials)\"LWO3\"===_lwoTree.format?materials.push(this.parseMaterial(_lwoTree.materials[name],name,_lwoTree.textures)):\"LWO2\"===_lwoTree.format&&materials.push(this.parseMaterialLwo2(_lwoTree.materials[name],name,_lwoTree.textures));return materials}},{key:\"parseMaterial\",value:function(materialData,name,textures){name={name,side:this.getSide(materialData.attributes),flatShading:this.getSmooth(materialData.attributes)};var connections=this.parseConnections(materialData.connections,\nmaterialData.nodes),maps=this.parseTextureNodes(connections.maps);this.parseAttributeImageMaps(connections.attributes,textures,maps,materialData.maps);materialData=this.parseAttributes(connections.attributes,maps);this.parseEnvMap(connections,maps,materialData);name=Object.assign(maps,name);name=Object.assign(name,materialData);return new (this.getMaterialType(connections.attributes))(name)}},{key:\"parseMaterialLwo2\",value:function(materialData,name){name={name,side:this.getSide(materialData.attributes),\nflatShading:this.getSmooth(materialData.attributes)};materialData=this.parseAttributes(materialData.attributes,{});name=Object.assign(name,materialData);return new _three.MeshPhongMaterial(name)}},{key:\"getSide\",value:function(attributes){if(!attributes.side)return _three.BackSide;switch(attributes.side){case 0:case 1:return _three.BackSide;case 2:return _three.FrontSide;case 3:return _three.DoubleSide}}},{key:\"getSmooth\",value:function(attributes){return attributes.smooth?!attributes.smooth:!0}},\n{key:\"parseConnections\",value:function(connections,nodes){var materialConnections={maps:{}},inputName=connections.inputName,inputNodeName=connections.inputNodeName;connections=connections.nodeName;var scope=this;inputName.forEach(function(name,index){\"Material\"===name&&(name=scope.getNodeByRefName(inputNodeName[index],nodes),materialConnections.attributes=name.attributes,materialConnections.envMap=name.fileName,materialConnections.name=inputNodeName[index])});connections.forEach(function(name,index){name===\nmaterialConnections.name&&(materialConnections.maps[inputName[index]]=scope.getNodeByRefName(inputNodeName[index],nodes))});return materialConnections}},{key:\"getNodeByRefName\",value:function(refName,nodes){for(var name in nodes)if(nodes[name].refName===refName)return nodes[name]}},{key:\"parseTextureNodes\",value:function(textureNodes){var maps={},name;for(name in textureNodes){var node=textureNodes[name],path=node.fileName;if(!path)return;path=this.loadTexture(path);void 0!==node.widthWrappingMode&&\n(path.wrapS=this.getWrappingType(node.widthWrappingMode));void 0!==node.heightWrappingMode&&(path.wrapT=this.getWrappingType(node.heightWrappingMode));switch(name){case \"Color\":maps.map=path;break;case \"Roughness\":maps.roughnessMap=path;maps.roughness=.5;break;case \"Specular\":maps.specularMap=path;maps.specular=16777215;break;case \"Luminous\":maps.emissiveMap=path;maps.emissive=8421504;break;case \"Luminous Color\":maps.emissive=8421504;break;case \"Metallic\":maps.metalnessMap=path;maps.metalness=.5;\nbreak;case \"Transparency\":case \"Alpha\":maps.alphaMap=path;maps.transparent=!0;break;case \"Normal\":maps.normalMap=path;void 0!==node.amplitude&&(maps.normalScale=new _three.Vector2(node.amplitude,node.amplitude));break;case \"Bump\":maps.bumpMap=path}}maps.roughnessMap&&maps.specularMap&&delete maps.specularMap;return maps}},{key:\"parseAttributeImageMaps\",value:function(attributes,textures,maps){for(var name in attributes){var attribute=attributes[name];if(attribute.maps){attribute=attribute.maps[0];\nvar path=this.getTexturePathByIndex(attribute.imageIndex,textures);if(!path)break;path=this.loadTexture(path);void 0!==attribute.wrap&&(path.wrapS=this.getWrappingType(attribute.wrap.w));void 0!==attribute.wrap&&(path.wrapT=this.getWrappingType(attribute.wrap.h));switch(name){case \"Color\":maps.map=path;break;case \"Diffuse\":maps.aoMap=path;break;case \"Roughness\":maps.roughnessMap=path;maps.roughness=1;break;case \"Specular\":maps.specularMap=path;maps.specular=16777215;break;case \"Luminosity\":maps.emissiveMap=\npath;maps.emissive=8421504;break;case \"Metallic\":maps.metalnessMap=path;maps.metalness=1;break;case \"Transparency\":case \"Alpha\":maps.alphaMap=path;maps.transparent=!0;break;case \"Normal\":maps.normalMap=path;break;case \"Bump\":maps.bumpMap=path}}}}},{key:\"parseAttributes\",value:function(attributes,maps){var params={};params.color=attributes.Color&&!maps.map?(new _three.Color).fromArray(attributes.Color.value):new _three.Color;attributes.Transparency&&0!==attributes.Transparency.value&&(params.opacity=\n1-attributes.Transparency.value,params.transparent=!0);attributes[\"Bump Height\"]&&(params.bumpScale=.1*attributes[\"Bump Height\"].value);attributes[\"Refraction Index\"]&&(params.refractionRatio=1/attributes[\"Refraction Index\"].value);this.parsePhysicalAttributes(params,attributes,maps);this.parseStandardAttributes(params,attributes,maps);this.parsePhongAttributes(params,attributes,maps);return params}},{key:\"parsePhysicalAttributes\",value:function(params,attributes){attributes.Clearcoat&&0<attributes.Clearcoat.value&&\n(params.clearcoat=attributes.Clearcoat.value,attributes[\"Clearcoat Gloss\"]&&(params.clearcoatRoughness=.5*(1-attributes[\"Clearcoat Gloss\"].value)))}},{key:\"parseStandardAttributes\",value:function(params,attributes,maps){attributes.Luminous&&(params.emissiveIntensity=attributes.Luminous.value,params.emissive=attributes[\"Luminous Color\"]&&!maps.emissive?(new _three.Color).fromArray(attributes[\"Luminous Color\"].value):new _three.Color(8421504));attributes.Roughness&&!maps.roughnessMap&&(params.roughness=\nattributes.Roughness.value);attributes.Metallic&&!maps.metalnessMap&&(params.metalness=attributes.Metallic.value)}},{key:\"parsePhongAttributes\",value:function(params,attributes,maps){attributes.Diffuse&&params.color.multiplyScalar(attributes.Diffuse.value);attributes.Reflection&&(params.reflectivity=attributes.Reflection.value,params.combine=_three.AddOperation);attributes.Luminosity&&(params.emissiveIntensity=attributes.Luminosity.value,params.emissive=maps.emissiveMap||maps.map?new _three.Color(8421504):\nparams.color);attributes.Roughness||!attributes.Specular||maps.specularMap||(params.specular=attributes[\"Color Highlight\"]?(new _three.Color).setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value),attributes[\"Color Highlight\"].value):(new _three.Color).setScalar(attributes.Specular.value));params.specular&&attributes.Glossiness&&(params.shininess=7+Math.pow(2,12*attributes.Glossiness.value+2))}},{key:\"parseEnvMap\",value:function(connections,maps,attributes){connections.envMap&&\n(connections=this.loadTexture(connections.envMap),attributes.transparent&&.999>attributes.opacity?(connections.mapping=_three.EquirectangularRefractionMapping,void 0!==attributes.reflectivity&&(delete attributes.reflectivity,delete attributes.combine),void 0!==attributes.metalness&&delete attributes.metalness):connections.mapping=_three.EquirectangularReflectionMapping,maps.envMap=connections)}},{key:\"getTexturePathByIndex\",value:function(index){var fileName=\"\";if(!_lwoTree.textures)return fileName;\n_lwoTree.textures.forEach(function(texture){texture.index===index&&(fileName=texture.fileName)});return fileName}},{key:\"loadTexture\",value:function(path){return path?this.textureLoader.load(path,void 0,void 0,function(){console.warn(\"LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.\")}):null}},{key:\"getWrappingType\",value:function(num){switch(num){case 0:return console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js'),\n_three.ClampToEdgeWrapping;case 1:return _three.RepeatWrapping;case 2:return _three.MirroredRepeatWrapping;case 3:return _three.ClampToEdgeWrapping}}},{key:\"getMaterialType\",value:function(nodeData){return nodeData.Clearcoat&&0<nodeData.Clearcoat.value?_three.MeshPhysicalMaterial:nodeData.Roughness?_three.MeshStandardMaterial:_three.MeshPhongMaterial}}]);return MaterialParser}(),GeometryParser$jscomp$0=function(){function GeometryParser(){_classCallCheck(this,GeometryParser)}_createClass(GeometryParser,\n[{key:\"parse\",value:function(geoData,layer){var geometry=new _three.BufferGeometry;geometry.setAttribute(\"position\",new _three.Float32BufferAttribute(geoData.points,3));var indices=this.splitIndices(geoData.vertexIndices,geoData.polygonDimensions);geometry.setIndex(indices);this.parseGroups(geometry,geoData);geometry.computeVertexNormals();this.parseUVs(geometry,layer,indices);this.parseMorphTargets(geometry,layer,indices);geometry.translate(-layer.pivot[0],-layer.pivot[1],-layer.pivot[2]);return geometry}},\n{key:\"splitIndices\",value:function(indices,polygonDimensions){var remappedIndices=[],i=0;polygonDimensions.forEach(function(dim){if(4>dim)for(var k=0;k<dim;k++)remappedIndices.push(indices[i+k]);else if(4===dim)remappedIndices.push(indices[i],indices[i+1],indices[i+2],indices[i],indices[i+2],indices[i+3]);else if(4<dim){for(k=1;k<dim-1;k++)remappedIndices.push(indices[i],indices[i+k],indices[i+k+1]);console.warn(\"LWOLoader: polygons with greater than 4 sides are not supported\")}i+=dim});return remappedIndices}},\n{key:\"parseGroups\",value:function(geometry,geoData){var tags=_lwoTree.tags,matNames=[],elemSize=3;\"lines\"===geoData.type&&(elemSize=2);\"points\"===geoData.type&&(elemSize=1);var remappedIndices=this.splitMaterialIndices(geoData.polygonDimensions,geoData.materialIndices);geoData=0;for(var indexPairs={},prevMaterialIndex,materialIndex,prevStart=0,currentCount=0,i=0;i<remappedIndices.length;i+=2){materialIndex=remappedIndices[i+1];0===i&&(matNames[geoData]=tags[materialIndex]);void 0===prevMaterialIndex&&\n(prevMaterialIndex=materialIndex);if(materialIndex!==prevMaterialIndex){if(indexPairs[tags[prevMaterialIndex]])var currentIndex=indexPairs[tags[prevMaterialIndex]];else currentIndex=geoData,indexPairs[tags[prevMaterialIndex]]=geoData,matNames[geoData]=tags[prevMaterialIndex],geoData++;geometry.addGroup(prevStart,currentCount,currentIndex);prevStart+=currentCount;prevMaterialIndex=materialIndex;currentCount=0}currentCount+=elemSize}0<geometry.groups.length&&(indexPairs[tags[materialIndex]]?elemSize=\nindexPairs[tags[materialIndex]]:(elemSize=geoData,indexPairs[tags[materialIndex]]=geoData,matNames[geoData]=tags[materialIndex]),geometry.addGroup(prevStart,currentCount,elemSize));geometry.userData.matNames=matNames}},{key:\"splitMaterialIndices\",value:function(polygonDimensions,indices){var remappedIndices=[];polygonDimensions.forEach(function(dim,i){if(3>=dim)remappedIndices.push(indices[2*i],indices[2*i+1]);else if(4===dim)remappedIndices.push(indices[2*i],indices[2*i+1],indices[2*i],indices[2*\ni+1]);else for(var k=0;k<dim-2;k++)remappedIndices.push(indices[2*i],indices[2*i+1])});return remappedIndices}},{key:\"parseUVs\",value:function(geometry,layer){var remappedUVs=Array.from(Array(2*geometry.attributes.position.count),function(){return 0}),_loop=function(name){var uvs=layer.uvs[name].uvs;layer.uvs[name].uvIndices.forEach(function(i,j){remappedUVs[2*i]=uvs[2*j];remappedUVs[2*i+1]=uvs[2*j+1]})},name$jscomp$0;for(name$jscomp$0 in layer.uvs)_loop(name$jscomp$0);geometry.setAttribute(\"uv\",\nnew _three.Float32BufferAttribute(remappedUVs,2))}},{key:\"parseMorphTargets\",value:function(geometry,layer){var num=0,_loop2=function(name){var remappedPoints=geometry.attributes.position.array.slice();geometry.morphAttributes.position||(geometry.morphAttributes.position=[]);var morphPoints=layer.morphTargets[name].points,type=layer.morphTargets[name].type;layer.morphTargets[name].indices.forEach(function(i,j){\"relative\"===type?(remappedPoints[3*i]+=morphPoints[3*j],remappedPoints[3*i+1]+=morphPoints[3*\nj+1],remappedPoints[3*i+2]+=morphPoints[3*j+2]):(remappedPoints[3*i]=morphPoints[3*j],remappedPoints[3*i+1]=morphPoints[3*j+1],remappedPoints[3*i+2]=morphPoints[3*j+2])});geometry.morphAttributes.position[num]=new _three.Float32BufferAttribute(remappedPoints,3);geometry.morphAttributes.position[num].name=name;num++},name$jscomp$0;for(name$jscomp$0 in layer.morphTargets)_loop2(name$jscomp$0);geometry.morphTargetsRelative=!1}}]);return GeometryParser}()}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$LWOLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LWOLoader = void 0;\n\nvar _three = require(\"three\");\n\nvar _IFFParser = require(\"./lwo/IFFParser.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\nvar _lwoTree;\n\nvar LWOLoader =\n/*#__PURE__*/\nfunction (_Loader) {\n  _inherits(LWOLoader, _Loader);\n\n  function LWOLoader(manager) {\n    var _this;\n\n    var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, LWOLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LWOLoader).call(this, manager));\n    _this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n    return _this;\n  }\n\n  _createClass(LWOLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\n\n      var modelName = url.split(path).pop().split('.')[0];\n      var loader = new _three.FileLoader(this.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (buffer) {\n        // console.time( 'Total parsing: ' );\n        try {\n          onLoad(scope.parse(buffer, path, modelName));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        } // console.timeEnd( 'Total parsing: ' );\n\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(iffBuffer, path, modelName) {\n      _lwoTree = new _IFFParser.IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\n\n      var textureLoader = new _three.TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      return new LWOTreeParser(textureLoader).parse(modelName);\n    }\n  }]);\n\n  return LWOLoader;\n}(_three.Loader); // Parse the lwoTree object\n\n\nexports.LWOLoader = LWOLoader;\n\nvar LWOTreeParser =\n/*#__PURE__*/\nfunction () {\n  function LWOTreeParser(textureLoader) {\n    _classCallCheck(this, LWOTreeParser);\n\n    this.textureLoader = textureLoader;\n  }\n\n  _createClass(LWOTreeParser, [{\n    key: \"parse\",\n    value: function parse(modelName) {\n      this.materials = new MaterialParser(this.textureLoader).parse();\n      this.defaultLayerName = modelName;\n      this.meshes = this.parseLayers();\n      return {\n        materials: this.materials,\n        meshes: this.meshes\n      };\n    }\n  }, {\n    key: \"parseLayers\",\n    value: function parseLayers() {\n      // array of all meshes for building hierarchy\n      var meshes = []; // final array containing meshes with scene graph hierarchy set up\n\n      var finalMeshes = [];\n      var geometryParser = new GeometryParser();\n      var scope = this;\n\n      _lwoTree.layers.forEach(function (layer) {\n        var geometry = geometryParser.parse(layer.geometry, layer);\n        var mesh = scope.parseMesh(geometry, layer);\n        meshes[layer.number] = mesh;\n        if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n      });\n\n      this.applyPivots(finalMeshes);\n      return finalMeshes;\n    }\n  }, {\n    key: \"parseMesh\",\n    value: function parseMesh(geometry, layer) {\n      var mesh;\n      var materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n      this.duplicateUVs(geometry, materials);\n      if (layer.geometry.type === 'points') mesh = new _three.Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new _three.LineSegments(geometry, materials);else mesh = new _three.Mesh(geometry, materials);\n      if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n      mesh.userData.pivot = layer.pivot;\n      return mesh;\n    } // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n\n  }, {\n    key: \"applyPivots\",\n    value: function applyPivots(meshes) {\n      meshes.forEach(function (mesh) {\n        mesh.traverse(function (child) {\n          var pivot = child.userData.pivot;\n          child.position.x += pivot[0];\n          child.position.y += pivot[1];\n          child.position.z += pivot[2];\n\n          if (child.parent) {\n            var parentPivot = child.parent.userData.pivot;\n            child.position.x -= parentPivot[0];\n            child.position.y -= parentPivot[1];\n            child.position.z -= parentPivot[2];\n          }\n        });\n      });\n    }\n  }, {\n    key: \"getMaterials\",\n    value: function getMaterials(namesArray, type) {\n      var materials = [];\n      var scope = this;\n      namesArray.forEach(function (name, i) {\n        materials[i] = scope.getMaterialByName(name);\n      }); // convert materials to line or point mats if required\n\n      if (type === 'points' || type === 'lines') {\n        materials.forEach(function (mat, i) {\n          var spec = {\n            color: mat.color\n          };\n\n          if (type === 'points') {\n            spec.size = 0.1;\n            spec.map = mat.map;\n            spec.morphTargets = mat.morphTargets;\n            materials[i] = new _three.PointsMaterial(spec);\n          } else if (type === 'lines') {\n            materials[i] = new _three.LineBasicMaterial(spec);\n          }\n        });\n      } // if there is only one material, return that directly instead of array\n\n\n      var filtered = materials.filter(Boolean);\n      if (filtered.length === 1) return filtered[0];\n      return materials;\n    }\n  }, {\n    key: \"getMaterialByName\",\n    value: function getMaterialByName(name) {\n      return this.materials.filter(function (m) {\n        return m.name === name;\n      })[0];\n    } // If the material has an aoMap, duplicate UVs\n\n  }, {\n    key: \"duplicateUVs\",\n    value: function duplicateUVs(geometry, materials) {\n      var duplicateUVs = false;\n\n      if (!Array.isArray(materials)) {\n        if (materials.aoMap) duplicateUVs = true;\n      } else {\n        materials.forEach(function (material) {\n          if (material.aoMap) duplicateUVs = true;\n        });\n      }\n\n      if (!duplicateUVs) return;\n      geometry.setAttribute('uv2', new _three.BufferAttribute(geometry.attributes.uv.array, 2));\n    }\n  }]);\n\n  return LWOTreeParser;\n}();\n\nvar MaterialParser =\n/*#__PURE__*/\nfunction () {\n  function MaterialParser(textureLoader) {\n    _classCallCheck(this, MaterialParser);\n\n    this.textureLoader = textureLoader;\n  }\n\n  _createClass(MaterialParser, [{\n    key: \"parse\",\n    value: function parse() {\n      var materials = [];\n      this.textures = {};\n\n      for (var name in _lwoTree.materials) {\n        if (_lwoTree.format === 'LWO3') {\n          materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n        } else if (_lwoTree.format === 'LWO2') {\n          materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n        }\n      }\n\n      return materials;\n    }\n  }, {\n    key: \"parseMaterial\",\n    value: function parseMaterial(materialData, name, textures) {\n      var params = {\n        name: name,\n        side: this.getSide(materialData.attributes),\n        flatShading: this.getSmooth(materialData.attributes)\n      };\n      var connections = this.parseConnections(materialData.connections, materialData.nodes);\n      var maps = this.parseTextureNodes(connections.maps);\n      this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n      var attributes = this.parseAttributes(connections.attributes, maps);\n      this.parseEnvMap(connections, maps, attributes);\n      params = Object.assign(maps, params);\n      params = Object.assign(params, attributes);\n      var materialType = this.getMaterialType(connections.attributes);\n      return new materialType(params);\n    }\n  }, {\n    key: \"parseMaterialLwo2\",\n    value: function parseMaterialLwo2(materialData, name\n    /*, textures*/\n    ) {\n      var params = {\n        name: name,\n        side: this.getSide(materialData.attributes),\n        flatShading: this.getSmooth(materialData.attributes)\n      };\n      var attributes = this.parseAttributes(materialData.attributes, {});\n      params = Object.assign(params, attributes);\n      return new _three.MeshPhongMaterial(params);\n    } // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n    // then switching mat FrontSide -> BackSide\n    // NB: this means that FrontSide and BackSide have been switched!\n\n  }, {\n    key: \"getSide\",\n    value: function getSide(attributes) {\n      if (!attributes.side) return _three.BackSide;\n\n      switch (attributes.side) {\n        case 0:\n        case 1:\n          return _three.BackSide;\n\n        case 2:\n          return _three.FrontSide;\n\n        case 3:\n          return _three.DoubleSide;\n      }\n    }\n  }, {\n    key: \"getSmooth\",\n    value: function getSmooth(attributes) {\n      if (!attributes.smooth) return true;\n      return !attributes.smooth;\n    }\n  }, {\n    key: \"parseConnections\",\n    value: function parseConnections(connections, nodes) {\n      var materialConnections = {\n        maps: {}\n      };\n      var inputName = connections.inputName;\n      var inputNodeName = connections.inputNodeName;\n      var nodeName = connections.nodeName;\n      var scope = this;\n      inputName.forEach(function (name, index) {\n        if (name === 'Material') {\n          var matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n          materialConnections.attributes = matNode.attributes;\n          materialConnections.envMap = matNode.fileName;\n          materialConnections.name = inputNodeName[index];\n        }\n      });\n      nodeName.forEach(function (name, index) {\n        if (name === materialConnections.name) {\n          materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n        }\n      });\n      return materialConnections;\n    }\n  }, {\n    key: \"getNodeByRefName\",\n    value: function getNodeByRefName(refName, nodes) {\n      for (var name in nodes) {\n        if (nodes[name].refName === refName) return nodes[name];\n      }\n    }\n  }, {\n    key: \"parseTextureNodes\",\n    value: function parseTextureNodes(textureNodes) {\n      var maps = {};\n\n      for (var name in textureNodes) {\n        var node = textureNodes[name];\n        var path = node.fileName;\n        if (!path) return;\n        var texture = this.loadTexture(path);\n        if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n        if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            break;\n\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 0.5;\n            break;\n\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specular = 0xffffff;\n            break;\n\n          case 'Luminous':\n            maps.emissiveMap = texture;\n            maps.emissive = 0x808080;\n            break;\n\n          case 'Luminous Color':\n            maps.emissive = 0x808080;\n            break;\n\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 0.5;\n            break;\n\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n\n          case 'Normal':\n            maps.normalMap = texture;\n            if (node.amplitude !== undefined) maps.normalScale = new _three.Vector2(node.amplitude, node.amplitude);\n            break;\n\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      } // LWO BSDF materials can have both spec and rough, but this is not valid in three\n\n\n      if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n      return maps;\n    } // maps can also be defined on individual material attributes, parse those here\n    // This occurs on Standard (Phong) surfaces\n\n  }, {\n    key: \"parseAttributeImageMaps\",\n    value: function parseAttributeImageMaps(attributes, textures, maps) {\n      for (var name in attributes) {\n        var attribute = attributes[name];\n\n        if (attribute.maps) {\n          var mapData = attribute.maps[0];\n          var path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n          if (!path) return;\n          var texture = this.loadTexture(path);\n          if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n          if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n\n          switch (name) {\n            case 'Color':\n              maps.map = texture;\n              break;\n\n            case 'Diffuse':\n              maps.aoMap = texture;\n              break;\n\n            case 'Roughness':\n              maps.roughnessMap = texture;\n              maps.roughness = 1;\n              break;\n\n            case 'Specular':\n              maps.specularMap = texture;\n              maps.specular = 0xffffff;\n              break;\n\n            case 'Luminosity':\n              maps.emissiveMap = texture;\n              maps.emissive = 0x808080;\n              break;\n\n            case 'Metallic':\n              maps.metalnessMap = texture;\n              maps.metalness = 1;\n              break;\n\n            case 'Transparency':\n            case 'Alpha':\n              maps.alphaMap = texture;\n              maps.transparent = true;\n              break;\n\n            case 'Normal':\n              maps.normalMap = texture;\n              break;\n\n            case 'Bump':\n              maps.bumpMap = texture;\n              break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"parseAttributes\",\n    value: function parseAttributes(attributes, maps) {\n      var params = {}; // don't use color data if color map is present\n\n      if (attributes.Color && !maps.map) {\n        params.color = new _three.Color().fromArray(attributes.Color.value);\n      } else {\n        params.color = new _three.Color();\n      }\n\n      if (attributes.Transparency && attributes.Transparency.value !== 0) {\n        params.opacity = 1 - attributes.Transparency.value;\n        params.transparent = true;\n      }\n\n      if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n      if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\n      this.parsePhysicalAttributes(params, attributes, maps);\n      this.parseStandardAttributes(params, attributes, maps);\n      this.parsePhongAttributes(params, attributes, maps);\n      return params;\n    }\n  }, {\n    key: \"parsePhysicalAttributes\",\n    value: function parsePhysicalAttributes(params, attributes\n    /*, maps*/\n    ) {\n      if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n        params.clearcoat = attributes.Clearcoat.value;\n\n        if (attributes['Clearcoat Gloss']) {\n          params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n        }\n      }\n    }\n  }, {\n    key: \"parseStandardAttributes\",\n    value: function parseStandardAttributes(params, attributes, maps) {\n      if (attributes.Luminous) {\n        params.emissiveIntensity = attributes.Luminous.value;\n\n        if (attributes['Luminous Color'] && !maps.emissive) {\n          params.emissive = new _three.Color().fromArray(attributes['Luminous Color'].value);\n        } else {\n          params.emissive = new _three.Color(0x808080);\n        }\n      }\n\n      if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n      if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n    }\n  }, {\n    key: \"parsePhongAttributes\",\n    value: function parsePhongAttributes(params, attributes, maps) {\n      if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n\n      if (attributes.Reflection) {\n        params.reflectivity = attributes.Reflection.value;\n        params.combine = _three.AddOperation;\n      }\n\n      if (attributes.Luminosity) {\n        params.emissiveIntensity = attributes.Luminosity.value;\n\n        if (!maps.emissiveMap && !maps.map) {\n          params.emissive = params.color;\n        } else {\n          params.emissive = new _three.Color(0x808080);\n        }\n      } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\n\n      if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n        if (attributes['Color Highlight']) {\n          params.specular = new _three.Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n        } else {\n          params.specular = new _three.Color().setScalar(attributes.Specular.value);\n        }\n      }\n\n      if (params.specular && attributes.Glossiness) {\n        params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n      }\n    }\n  }, {\n    key: \"parseEnvMap\",\n    value: function parseEnvMap(connections, maps, attributes) {\n      if (connections.envMap) {\n        var envMap = this.loadTexture(connections.envMap);\n\n        if (attributes.transparent && attributes.opacity < 0.999) {\n          envMap.mapping = _three.EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\n\n          if (attributes.reflectivity !== undefined) {\n            delete attributes.reflectivity;\n            delete attributes.combine;\n          }\n\n          if (attributes.metalness !== undefined) {\n            delete attributes.metalness;\n          }\n        } else {\n          envMap.mapping = _three.EquirectangularReflectionMapping;\n        }\n\n        maps.envMap = envMap;\n      }\n    } // get texture defined at top level by its index\n\n  }, {\n    key: \"getTexturePathByIndex\",\n    value: function getTexturePathByIndex(index) {\n      var fileName = '';\n      if (!_lwoTree.textures) return fileName;\n\n      _lwoTree.textures.forEach(function (texture) {\n        if (texture.index === index) fileName = texture.fileName;\n      });\n\n      return fileName;\n    }\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture(path) {\n      if (!path) return null;\n      var texture = this.textureLoader.load(path, undefined, undefined, function () {\n        console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\n      });\n      return texture;\n    } // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\n  }, {\n    key: \"getWrappingType\",\n    value: function getWrappingType(num) {\n      switch (num) {\n        case 0:\n          console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n          return _three.ClampToEdgeWrapping;\n\n        case 1:\n          return _three.RepeatWrapping;\n\n        case 2:\n          return _three.MirroredRepeatWrapping;\n\n        case 3:\n          return _three.ClampToEdgeWrapping;\n      }\n    }\n  }, {\n    key: \"getMaterialType\",\n    value: function getMaterialType(nodeData) {\n      if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return _three.MeshPhysicalMaterial;\n      if (nodeData.Roughness) return _three.MeshStandardMaterial;\n      return _three.MeshPhongMaterial;\n    }\n  }]);\n\n  return MaterialParser;\n}();\n\nvar GeometryParser =\n/*#__PURE__*/\nfunction () {\n  function GeometryParser() {\n    _classCallCheck(this, GeometryParser);\n  }\n\n  _createClass(GeometryParser, [{\n    key: \"parse\",\n    value: function parse(geoData, layer) {\n      var geometry = new _three.BufferGeometry();\n      geometry.setAttribute('position', new _three.Float32BufferAttribute(geoData.points, 3));\n      var indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n      geometry.setIndex(indices);\n      this.parseGroups(geometry, geoData);\n      geometry.computeVertexNormals();\n      this.parseUVs(geometry, layer, indices);\n      this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\n\n      geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // let userData = geometry.userData;\n      // geometry = geometry.toNonIndexed()\n      // geometry.userData = userData;\n\n      return geometry;\n    } // split quads into tris\n\n  }, {\n    key: \"splitIndices\",\n    value: function splitIndices(indices, polygonDimensions) {\n      var remappedIndices = [];\n      var i = 0;\n      polygonDimensions.forEach(function (dim) {\n        if (dim < 4) {\n          for (var k = 0; k < dim; k++) {\n            remappedIndices.push(indices[i + k]);\n          }\n        } else if (dim === 4) {\n          remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n        } else if (dim > 4) {\n          for (var _k = 1; _k < dim - 1; _k++) {\n            remappedIndices.push(indices[i], indices[i + _k], indices[i + _k + 1]);\n          }\n\n          console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n        }\n\n        i += dim;\n      });\n      return remappedIndices;\n    } // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n\n  }, {\n    key: \"parseGroups\",\n    value: function parseGroups(geometry, geoData) {\n      var tags = _lwoTree.tags;\n      var matNames = [];\n      var elemSize = 3;\n      if (geoData.type === 'lines') elemSize = 2;\n      if (geoData.type === 'points') elemSize = 1;\n      var remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n      var indexNum = 0; // create new indices in numerical order\n\n      var indexPairs = {}; // original indices mapped to numerical indices\n\n      var prevMaterialIndex;\n      var materialIndex;\n      var prevStart = 0;\n      var currentCount = 0;\n\n      for (var i = 0; i < remappedIndices.length; i += 2) {\n        materialIndex = remappedIndices[i + 1];\n        if (i === 0) matNames[indexNum] = tags[materialIndex];\n        if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n\n        if (materialIndex !== prevMaterialIndex) {\n          var currentIndex = void 0;\n\n          if (indexPairs[tags[prevMaterialIndex]]) {\n            currentIndex = indexPairs[tags[prevMaterialIndex]];\n          } else {\n            currentIndex = indexNum;\n            indexPairs[tags[prevMaterialIndex]] = indexNum;\n            matNames[indexNum] = tags[prevMaterialIndex];\n            indexNum++;\n          }\n\n          geometry.addGroup(prevStart, currentCount, currentIndex);\n          prevStart += currentCount;\n          prevMaterialIndex = materialIndex;\n          currentCount = 0;\n        }\n\n        currentCount += elemSize;\n      } // the loop above doesn't add the last group, do that here.\n\n\n      if (geometry.groups.length > 0) {\n        var _currentIndex;\n\n        if (indexPairs[tags[materialIndex]]) {\n          _currentIndex = indexPairs[tags[materialIndex]];\n        } else {\n          _currentIndex = indexNum;\n          indexPairs[tags[materialIndex]] = indexNum;\n          matNames[indexNum] = tags[materialIndex];\n        }\n\n        geometry.addGroup(prevStart, currentCount, _currentIndex);\n      } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\n\n      geometry.userData.matNames = matNames;\n    }\n  }, {\n    key: \"splitMaterialIndices\",\n    value: function splitMaterialIndices(polygonDimensions, indices) {\n      var remappedIndices = [];\n      polygonDimensions.forEach(function (dim, i) {\n        if (dim <= 3) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        } else if (dim === 4) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n        } else {\n          // ignore > 4 for now\n          for (var k = 0; k < dim - 2; k++) {\n            remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n          }\n        }\n      });\n      return remappedIndices;\n    } // UV maps:\n    // 1: are defined via index into an array of points, not into a geometry\n    // - the geometry is also defined by an index into this array, but the indexes may not match\n    // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n    // \twith preference given to the first map encountered\n    // 3: UV maps can be partial - that is, defined for only a part of the geometry\n    // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n    // UV maps are defined as partially VMAP and partially VMAD\n    // VMADs are currently not supported\n\n  }, {\n    key: \"parseUVs\",\n    value: function parseUVs(geometry, layer) {\n      // start by creating a UV map set to zero for the whole geometry\n      var remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n        return 0;\n      });\n\n      var _loop = function _loop(name) {\n        var uvs = layer.uvs[name].uvs;\n        var uvIndices = layer.uvs[name].uvIndices;\n        uvIndices.forEach(function (i, j) {\n          remappedUVs[i * 2] = uvs[j * 2];\n          remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n        });\n      };\n\n      for (var name in layer.uvs) {\n        _loop(name);\n      }\n\n      geometry.setAttribute('uv', new _three.Float32BufferAttribute(remappedUVs, 2));\n    }\n  }, {\n    key: \"parseMorphTargets\",\n    value: function parseMorphTargets(geometry, layer) {\n      var num = 0;\n\n      var _loop2 = function _loop2(name) {\n        var remappedPoints = geometry.attributes.position.array.slice();\n        if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n        var morphPoints = layer.morphTargets[name].points;\n        var morphIndices = layer.morphTargets[name].indices;\n        var type = layer.morphTargets[name].type;\n        morphIndices.forEach(function (i, j) {\n          if (type === 'relative') {\n            remappedPoints[i * 3] += morphPoints[j * 3];\n            remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n            remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n          } else {\n            remappedPoints[i * 3] = morphPoints[j * 3];\n            remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n            remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n          }\n        });\n        geometry.morphAttributes.position[num] = new _three.Float32BufferAttribute(remappedPoints, 3);\n        geometry.morphAttributes.position[num].name = name;\n        num++;\n      };\n\n      for (var name in layer.morphTargets) {\n        _loop2(name);\n      }\n\n      geometry.morphTargetsRelative = false;\n    }\n  }]);\n\n  return GeometryParser;\n}(); // ************** UTILITY FUNCTIONS **************\n\n\nfunction extractParentUrl(url, dir) {\n  var index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.substr(0, index);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$three_stdlib$loaders$lwo$IFFParser"]],"~:properties",["^5",["clearcoat","resourcePath","map","z","wrapS","reflectivity","prototype","transparent","textureLoader","side","pivot","emissive","maps","roughnessMap","key","x","__esModule","clearcoatRoughness","alphaMap","flatShading","LWOLoader","defaultLayerName","normalMap","aoMap","bumpMap","materials","specular","position","name","configurable","emissiveMap","value","matNames","enumerable","writable","shininess","metalnessMap","attributes","textures","y","wrapT","mapping","__proto__","envMap","specularMap","meshes","bumpScale","morphTargetsRelative","size","morphTargets","metalness","combine","roughness","refractionRatio","emissiveIntensity","color","opacity","normalScale","constructor"]],"~:compiled-at",1630917515958,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$LWOLoader.js\",\n\"lineCount\":36,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/LWOLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$LWOLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.LWOLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _IFFParser = require(\\\"./lwo/IFFParser.js\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * @version 1.1.1\\n *\\n * @desc Load files in LWO3 and LWO2 format on Three.js\\n *\\n * LWO3 format specification:\\n * \\thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\\n *\\n * LWO2 format specification:\\n * \\thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\\n *\\n **/\\nvar _lwoTree;\\n\\nvar LWOLoader =\\n/*#__PURE__*/\\nfunction (_Loader) {\\n  _inherits(LWOLoader, _Loader);\\n\\n  function LWOLoader(manager) {\\n    var _this;\\n\\n    var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n    _classCallCheck(this, LWOLoader);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LWOLoader).call(this, manager));\\n    _this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\\n    return _this;\\n  }\\n\\n  _createClass(LWOLoader, [{\\n    key: \\\"load\\\",\\n    value: function load(url, onLoad, onProgress, onError) {\\n      var scope = this;\\n      var path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\\n\\n      var modelName = url.split(path).pop().split('.')[0];\\n      var loader = new _three.FileLoader(this.manager);\\n      loader.setPath(scope.path);\\n      loader.setResponseType('arraybuffer');\\n      loader.load(url, function (buffer) {\\n        // console.time( 'Total parsing: ' );\\n        try {\\n          onLoad(scope.parse(buffer, path, modelName));\\n        } catch (e) {\\n          if (onError) {\\n            onError(e);\\n          } else {\\n            console.error(e);\\n          }\\n\\n          scope.manager.itemError(url);\\n        } // console.timeEnd( 'Total parsing: ' );\\n\\n      }, onProgress, onError);\\n    }\\n  }, {\\n    key: \\\"parse\\\",\\n    value: function parse(iffBuffer, path, modelName) {\\n      _lwoTree = new _IFFParser.IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\\n\\n      var textureLoader = new _three.TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\\n      return new LWOTreeParser(textureLoader).parse(modelName);\\n    }\\n  }]);\\n\\n  return LWOLoader;\\n}(_three.Loader); // Parse the lwoTree object\\n\\n\\nexports.LWOLoader = LWOLoader;\\n\\nvar LWOTreeParser =\\n/*#__PURE__*/\\nfunction () {\\n  function LWOTreeParser(textureLoader) {\\n    _classCallCheck(this, LWOTreeParser);\\n\\n    this.textureLoader = textureLoader;\\n  }\\n\\n  _createClass(LWOTreeParser, [{\\n    key: \\\"parse\\\",\\n    value: function parse(modelName) {\\n      this.materials = new MaterialParser(this.textureLoader).parse();\\n      this.defaultLayerName = modelName;\\n      this.meshes = this.parseLayers();\\n      return {\\n        materials: this.materials,\\n        meshes: this.meshes\\n      };\\n    }\\n  }, {\\n    key: \\\"parseLayers\\\",\\n    value: function parseLayers() {\\n      // array of all meshes for building hierarchy\\n      var meshes = []; // final array containing meshes with scene graph hierarchy set up\\n\\n      var finalMeshes = [];\\n      var geometryParser = new GeometryParser();\\n      var scope = this;\\n\\n      _lwoTree.layers.forEach(function (layer) {\\n        var geometry = geometryParser.parse(layer.geometry, layer);\\n        var mesh = scope.parseMesh(geometry, layer);\\n        meshes[layer.number] = mesh;\\n        if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\\n      });\\n\\n      this.applyPivots(finalMeshes);\\n      return finalMeshes;\\n    }\\n  }, {\\n    key: \\\"parseMesh\\\",\\n    value: function parseMesh(geometry, layer) {\\n      var mesh;\\n      var materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\\n      this.duplicateUVs(geometry, materials);\\n      if (layer.geometry.type === 'points') mesh = new _three.Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new _three.LineSegments(geometry, materials);else mesh = new _three.Mesh(geometry, materials);\\n      if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\\n      mesh.userData.pivot = layer.pivot;\\n      return mesh;\\n    } // TODO: may need to be reversed in z to convert LWO to three.js coordinates\\n\\n  }, {\\n    key: \\\"applyPivots\\\",\\n    value: function applyPivots(meshes) {\\n      meshes.forEach(function (mesh) {\\n        mesh.traverse(function (child) {\\n          var pivot = child.userData.pivot;\\n          child.position.x += pivot[0];\\n          child.position.y += pivot[1];\\n          child.position.z += pivot[2];\\n\\n          if (child.parent) {\\n            var parentPivot = child.parent.userData.pivot;\\n            child.position.x -= parentPivot[0];\\n            child.position.y -= parentPivot[1];\\n            child.position.z -= parentPivot[2];\\n          }\\n        });\\n      });\\n    }\\n  }, {\\n    key: \\\"getMaterials\\\",\\n    value: function getMaterials(namesArray, type) {\\n      var materials = [];\\n      var scope = this;\\n      namesArray.forEach(function (name, i) {\\n        materials[i] = scope.getMaterialByName(name);\\n      }); // convert materials to line or point mats if required\\n\\n      if (type === 'points' || type === 'lines') {\\n        materials.forEach(function (mat, i) {\\n          var spec = {\\n            color: mat.color\\n          };\\n\\n          if (type === 'points') {\\n            spec.size = 0.1;\\n            spec.map = mat.map;\\n            spec.morphTargets = mat.morphTargets;\\n            materials[i] = new _three.PointsMaterial(spec);\\n          } else if (type === 'lines') {\\n            materials[i] = new _three.LineBasicMaterial(spec);\\n          }\\n        });\\n      } // if there is only one material, return that directly instead of array\\n\\n\\n      var filtered = materials.filter(Boolean);\\n      if (filtered.length === 1) return filtered[0];\\n      return materials;\\n    }\\n  }, {\\n    key: \\\"getMaterialByName\\\",\\n    value: function getMaterialByName(name) {\\n      return this.materials.filter(function (m) {\\n        return m.name === name;\\n      })[0];\\n    } // If the material has an aoMap, duplicate UVs\\n\\n  }, {\\n    key: \\\"duplicateUVs\\\",\\n    value: function duplicateUVs(geometry, materials) {\\n      var duplicateUVs = false;\\n\\n      if (!Array.isArray(materials)) {\\n        if (materials.aoMap) duplicateUVs = true;\\n      } else {\\n        materials.forEach(function (material) {\\n          if (material.aoMap) duplicateUVs = true;\\n        });\\n      }\\n\\n      if (!duplicateUVs) return;\\n      geometry.setAttribute('uv2', new _three.BufferAttribute(geometry.attributes.uv.array, 2));\\n    }\\n  }]);\\n\\n  return LWOTreeParser;\\n}();\\n\\nvar MaterialParser =\\n/*#__PURE__*/\\nfunction () {\\n  function MaterialParser(textureLoader) {\\n    _classCallCheck(this, MaterialParser);\\n\\n    this.textureLoader = textureLoader;\\n  }\\n\\n  _createClass(MaterialParser, [{\\n    key: \\\"parse\\\",\\n    value: function parse() {\\n      var materials = [];\\n      this.textures = {};\\n\\n      for (var name in _lwoTree.materials) {\\n        if (_lwoTree.format === 'LWO3') {\\n          materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\\n        } else if (_lwoTree.format === 'LWO2') {\\n          materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\\n        }\\n      }\\n\\n      return materials;\\n    }\\n  }, {\\n    key: \\\"parseMaterial\\\",\\n    value: function parseMaterial(materialData, name, textures) {\\n      var params = {\\n        name: name,\\n        side: this.getSide(materialData.attributes),\\n        flatShading: this.getSmooth(materialData.attributes)\\n      };\\n      var connections = this.parseConnections(materialData.connections, materialData.nodes);\\n      var maps = this.parseTextureNodes(connections.maps);\\n      this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\\n      var attributes = this.parseAttributes(connections.attributes, maps);\\n      this.parseEnvMap(connections, maps, attributes);\\n      params = Object.assign(maps, params);\\n      params = Object.assign(params, attributes);\\n      var materialType = this.getMaterialType(connections.attributes);\\n      return new materialType(params);\\n    }\\n  }, {\\n    key: \\\"parseMaterialLwo2\\\",\\n    value: function parseMaterialLwo2(materialData, name\\n    /*, textures*/\\n    ) {\\n      var params = {\\n        name: name,\\n        side: this.getSide(materialData.attributes),\\n        flatShading: this.getSmooth(materialData.attributes)\\n      };\\n      var attributes = this.parseAttributes(materialData.attributes, {});\\n      params = Object.assign(params, attributes);\\n      return new _three.MeshPhongMaterial(params);\\n    } // Note: converting from left to right handed coords by switching x -> -x in vertices, and\\n    // then switching mat FrontSide -> BackSide\\n    // NB: this means that FrontSide and BackSide have been switched!\\n\\n  }, {\\n    key: \\\"getSide\\\",\\n    value: function getSide(attributes) {\\n      if (!attributes.side) return _three.BackSide;\\n\\n      switch (attributes.side) {\\n        case 0:\\n        case 1:\\n          return _three.BackSide;\\n\\n        case 2:\\n          return _three.FrontSide;\\n\\n        case 3:\\n          return _three.DoubleSide;\\n      }\\n    }\\n  }, {\\n    key: \\\"getSmooth\\\",\\n    value: function getSmooth(attributes) {\\n      if (!attributes.smooth) return true;\\n      return !attributes.smooth;\\n    }\\n  }, {\\n    key: \\\"parseConnections\\\",\\n    value: function parseConnections(connections, nodes) {\\n      var materialConnections = {\\n        maps: {}\\n      };\\n      var inputName = connections.inputName;\\n      var inputNodeName = connections.inputNodeName;\\n      var nodeName = connections.nodeName;\\n      var scope = this;\\n      inputName.forEach(function (name, index) {\\n        if (name === 'Material') {\\n          var matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\\n          materialConnections.attributes = matNode.attributes;\\n          materialConnections.envMap = matNode.fileName;\\n          materialConnections.name = inputNodeName[index];\\n        }\\n      });\\n      nodeName.forEach(function (name, index) {\\n        if (name === materialConnections.name) {\\n          materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\\n        }\\n      });\\n      return materialConnections;\\n    }\\n  }, {\\n    key: \\\"getNodeByRefName\\\",\\n    value: function getNodeByRefName(refName, nodes) {\\n      for (var name in nodes) {\\n        if (nodes[name].refName === refName) return nodes[name];\\n      }\\n    }\\n  }, {\\n    key: \\\"parseTextureNodes\\\",\\n    value: function parseTextureNodes(textureNodes) {\\n      var maps = {};\\n\\n      for (var name in textureNodes) {\\n        var node = textureNodes[name];\\n        var path = node.fileName;\\n        if (!path) return;\\n        var texture = this.loadTexture(path);\\n        if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\\n        if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\\n\\n        switch (name) {\\n          case 'Color':\\n            maps.map = texture;\\n            break;\\n\\n          case 'Roughness':\\n            maps.roughnessMap = texture;\\n            maps.roughness = 0.5;\\n            break;\\n\\n          case 'Specular':\\n            maps.specularMap = texture;\\n            maps.specular = 0xffffff;\\n            break;\\n\\n          case 'Luminous':\\n            maps.emissiveMap = texture;\\n            maps.emissive = 0x808080;\\n            break;\\n\\n          case 'Luminous Color':\\n            maps.emissive = 0x808080;\\n            break;\\n\\n          case 'Metallic':\\n            maps.metalnessMap = texture;\\n            maps.metalness = 0.5;\\n            break;\\n\\n          case 'Transparency':\\n          case 'Alpha':\\n            maps.alphaMap = texture;\\n            maps.transparent = true;\\n            break;\\n\\n          case 'Normal':\\n            maps.normalMap = texture;\\n            if (node.amplitude !== undefined) maps.normalScale = new _three.Vector2(node.amplitude, node.amplitude);\\n            break;\\n\\n          case 'Bump':\\n            maps.bumpMap = texture;\\n            break;\\n        }\\n      } // LWO BSDF materials can have both spec and rough, but this is not valid in three\\n\\n\\n      if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\\n      return maps;\\n    } // maps can also be defined on individual material attributes, parse those here\\n    // This occurs on Standard (Phong) surfaces\\n\\n  }, {\\n    key: \\\"parseAttributeImageMaps\\\",\\n    value: function parseAttributeImageMaps(attributes, textures, maps) {\\n      for (var name in attributes) {\\n        var attribute = attributes[name];\\n\\n        if (attribute.maps) {\\n          var mapData = attribute.maps[0];\\n          var path = this.getTexturePathByIndex(mapData.imageIndex, textures);\\n          if (!path) return;\\n          var texture = this.loadTexture(path);\\n          if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\\n          if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\\n\\n          switch (name) {\\n            case 'Color':\\n              maps.map = texture;\\n              break;\\n\\n            case 'Diffuse':\\n              maps.aoMap = texture;\\n              break;\\n\\n            case 'Roughness':\\n              maps.roughnessMap = texture;\\n              maps.roughness = 1;\\n              break;\\n\\n            case 'Specular':\\n              maps.specularMap = texture;\\n              maps.specular = 0xffffff;\\n              break;\\n\\n            case 'Luminosity':\\n              maps.emissiveMap = texture;\\n              maps.emissive = 0x808080;\\n              break;\\n\\n            case 'Metallic':\\n              maps.metalnessMap = texture;\\n              maps.metalness = 1;\\n              break;\\n\\n            case 'Transparency':\\n            case 'Alpha':\\n              maps.alphaMap = texture;\\n              maps.transparent = true;\\n              break;\\n\\n            case 'Normal':\\n              maps.normalMap = texture;\\n              break;\\n\\n            case 'Bump':\\n              maps.bumpMap = texture;\\n              break;\\n          }\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"parseAttributes\\\",\\n    value: function parseAttributes(attributes, maps) {\\n      var params = {}; // don't use color data if color map is present\\n\\n      if (attributes.Color && !maps.map) {\\n        params.color = new _three.Color().fromArray(attributes.Color.value);\\n      } else {\\n        params.color = new _three.Color();\\n      }\\n\\n      if (attributes.Transparency && attributes.Transparency.value !== 0) {\\n        params.opacity = 1 - attributes.Transparency.value;\\n        params.transparent = true;\\n      }\\n\\n      if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\\n      if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\\n      this.parsePhysicalAttributes(params, attributes, maps);\\n      this.parseStandardAttributes(params, attributes, maps);\\n      this.parsePhongAttributes(params, attributes, maps);\\n      return params;\\n    }\\n  }, {\\n    key: \\\"parsePhysicalAttributes\\\",\\n    value: function parsePhysicalAttributes(params, attributes\\n    /*, maps*/\\n    ) {\\n      if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\\n        params.clearcoat = attributes.Clearcoat.value;\\n\\n        if (attributes['Clearcoat Gloss']) {\\n          params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"parseStandardAttributes\\\",\\n    value: function parseStandardAttributes(params, attributes, maps) {\\n      if (attributes.Luminous) {\\n        params.emissiveIntensity = attributes.Luminous.value;\\n\\n        if (attributes['Luminous Color'] && !maps.emissive) {\\n          params.emissive = new _three.Color().fromArray(attributes['Luminous Color'].value);\\n        } else {\\n          params.emissive = new _three.Color(0x808080);\\n        }\\n      }\\n\\n      if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\\n      if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\\n    }\\n  }, {\\n    key: \\\"parsePhongAttributes\\\",\\n    value: function parsePhongAttributes(params, attributes, maps) {\\n      if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\\n\\n      if (attributes.Reflection) {\\n        params.reflectivity = attributes.Reflection.value;\\n        params.combine = _three.AddOperation;\\n      }\\n\\n      if (attributes.Luminosity) {\\n        params.emissiveIntensity = attributes.Luminosity.value;\\n\\n        if (!maps.emissiveMap && !maps.map) {\\n          params.emissive = params.color;\\n        } else {\\n          params.emissive = new _three.Color(0x808080);\\n        }\\n      } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\\n\\n\\n      if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\\n        if (attributes['Color Highlight']) {\\n          params.specular = new _three.Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\\n        } else {\\n          params.specular = new _three.Color().setScalar(attributes.Specular.value);\\n        }\\n      }\\n\\n      if (params.specular && attributes.Glossiness) {\\n        params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\\n      }\\n    }\\n  }, {\\n    key: \\\"parseEnvMap\\\",\\n    value: function parseEnvMap(connections, maps, attributes) {\\n      if (connections.envMap) {\\n        var envMap = this.loadTexture(connections.envMap);\\n\\n        if (attributes.transparent && attributes.opacity < 0.999) {\\n          envMap.mapping = _three.EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\\n\\n          if (attributes.reflectivity !== undefined) {\\n            delete attributes.reflectivity;\\n            delete attributes.combine;\\n          }\\n\\n          if (attributes.metalness !== undefined) {\\n            delete attributes.metalness;\\n          }\\n        } else {\\n          envMap.mapping = _three.EquirectangularReflectionMapping;\\n        }\\n\\n        maps.envMap = envMap;\\n      }\\n    } // get texture defined at top level by its index\\n\\n  }, {\\n    key: \\\"getTexturePathByIndex\\\",\\n    value: function getTexturePathByIndex(index) {\\n      var fileName = '';\\n      if (!_lwoTree.textures) return fileName;\\n\\n      _lwoTree.textures.forEach(function (texture) {\\n        if (texture.index === index) fileName = texture.fileName;\\n      });\\n\\n      return fileName;\\n    }\\n  }, {\\n    key: \\\"loadTexture\\\",\\n    value: function loadTexture(path) {\\n      if (!path) return null;\\n      var texture = this.textureLoader.load(path, undefined, undefined, function () {\\n        console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\\n      });\\n      return texture;\\n    } // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\\n\\n  }, {\\n    key: \\\"getWrappingType\\\",\\n    value: function getWrappingType(num) {\\n      switch (num) {\\n        case 0:\\n          console.warn('LWOLoader: \\\"Reset\\\" texture wrapping type is not supported in three.js');\\n          return _three.ClampToEdgeWrapping;\\n\\n        case 1:\\n          return _three.RepeatWrapping;\\n\\n        case 2:\\n          return _three.MirroredRepeatWrapping;\\n\\n        case 3:\\n          return _three.ClampToEdgeWrapping;\\n      }\\n    }\\n  }, {\\n    key: \\\"getMaterialType\\\",\\n    value: function getMaterialType(nodeData) {\\n      if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return _three.MeshPhysicalMaterial;\\n      if (nodeData.Roughness) return _three.MeshStandardMaterial;\\n      return _three.MeshPhongMaterial;\\n    }\\n  }]);\\n\\n  return MaterialParser;\\n}();\\n\\nvar GeometryParser =\\n/*#__PURE__*/\\nfunction () {\\n  function GeometryParser() {\\n    _classCallCheck(this, GeometryParser);\\n  }\\n\\n  _createClass(GeometryParser, [{\\n    key: \\\"parse\\\",\\n    value: function parse(geoData, layer) {\\n      var geometry = new _three.BufferGeometry();\\n      geometry.setAttribute('position', new _three.Float32BufferAttribute(geoData.points, 3));\\n      var indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\\n      geometry.setIndex(indices);\\n      this.parseGroups(geometry, geoData);\\n      geometry.computeVertexNormals();\\n      this.parseUVs(geometry, layer, indices);\\n      this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\\n\\n      geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // let userData = geometry.userData;\\n      // geometry = geometry.toNonIndexed()\\n      // geometry.userData = userData;\\n\\n      return geometry;\\n    } // split quads into tris\\n\\n  }, {\\n    key: \\\"splitIndices\\\",\\n    value: function splitIndices(indices, polygonDimensions) {\\n      var remappedIndices = [];\\n      var i = 0;\\n      polygonDimensions.forEach(function (dim) {\\n        if (dim < 4) {\\n          for (var k = 0; k < dim; k++) {\\n            remappedIndices.push(indices[i + k]);\\n          }\\n        } else if (dim === 4) {\\n          remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\\n        } else if (dim > 4) {\\n          for (var _k = 1; _k < dim - 1; _k++) {\\n            remappedIndices.push(indices[i], indices[i + _k], indices[i + _k + 1]);\\n          }\\n\\n          console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\\n        }\\n\\n        i += dim;\\n      });\\n      return remappedIndices;\\n    } // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\\n\\n  }, {\\n    key: \\\"parseGroups\\\",\\n    value: function parseGroups(geometry, geoData) {\\n      var tags = _lwoTree.tags;\\n      var matNames = [];\\n      var elemSize = 3;\\n      if (geoData.type === 'lines') elemSize = 2;\\n      if (geoData.type === 'points') elemSize = 1;\\n      var remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\\n      var indexNum = 0; // create new indices in numerical order\\n\\n      var indexPairs = {}; // original indices mapped to numerical indices\\n\\n      var prevMaterialIndex;\\n      var materialIndex;\\n      var prevStart = 0;\\n      var currentCount = 0;\\n\\n      for (var i = 0; i < remappedIndices.length; i += 2) {\\n        materialIndex = remappedIndices[i + 1];\\n        if (i === 0) matNames[indexNum] = tags[materialIndex];\\n        if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\\n\\n        if (materialIndex !== prevMaterialIndex) {\\n          var currentIndex = void 0;\\n\\n          if (indexPairs[tags[prevMaterialIndex]]) {\\n            currentIndex = indexPairs[tags[prevMaterialIndex]];\\n          } else {\\n            currentIndex = indexNum;\\n            indexPairs[tags[prevMaterialIndex]] = indexNum;\\n            matNames[indexNum] = tags[prevMaterialIndex];\\n            indexNum++;\\n          }\\n\\n          geometry.addGroup(prevStart, currentCount, currentIndex);\\n          prevStart += currentCount;\\n          prevMaterialIndex = materialIndex;\\n          currentCount = 0;\\n        }\\n\\n        currentCount += elemSize;\\n      } // the loop above doesn't add the last group, do that here.\\n\\n\\n      if (geometry.groups.length > 0) {\\n        var _currentIndex;\\n\\n        if (indexPairs[tags[materialIndex]]) {\\n          _currentIndex = indexPairs[tags[materialIndex]];\\n        } else {\\n          _currentIndex = indexNum;\\n          indexPairs[tags[materialIndex]] = indexNum;\\n          matNames[indexNum] = tags[materialIndex];\\n        }\\n\\n        geometry.addGroup(prevStart, currentCount, _currentIndex);\\n      } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\\n\\n\\n      geometry.userData.matNames = matNames;\\n    }\\n  }, {\\n    key: \\\"splitMaterialIndices\\\",\\n    value: function splitMaterialIndices(polygonDimensions, indices) {\\n      var remappedIndices = [];\\n      polygonDimensions.forEach(function (dim, i) {\\n        if (dim <= 3) {\\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\\n        } else if (dim === 4) {\\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\\n        } else {\\n          // ignore > 4 for now\\n          for (var k = 0; k < dim - 2; k++) {\\n            remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\\n          }\\n        }\\n      });\\n      return remappedIndices;\\n    } // UV maps:\\n    // 1: are defined via index into an array of points, not into a geometry\\n    // - the geometry is also defined by an index into this array, but the indexes may not match\\n    // 2: there can be any number of UV maps for a single geometry. Here these are combined,\\n    // \\twith preference given to the first map encountered\\n    // 3: UV maps can be partial - that is, defined for only a part of the geometry\\n    // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\\n    // UV maps are defined as partially VMAP and partially VMAD\\n    // VMADs are currently not supported\\n\\n  }, {\\n    key: \\\"parseUVs\\\",\\n    value: function parseUVs(geometry, layer) {\\n      // start by creating a UV map set to zero for the whole geometry\\n      var remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\\n        return 0;\\n      });\\n\\n      var _loop = function _loop(name) {\\n        var uvs = layer.uvs[name].uvs;\\n        var uvIndices = layer.uvs[name].uvIndices;\\n        uvIndices.forEach(function (i, j) {\\n          remappedUVs[i * 2] = uvs[j * 2];\\n          remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\\n        });\\n      };\\n\\n      for (var name in layer.uvs) {\\n        _loop(name);\\n      }\\n\\n      geometry.setAttribute('uv', new _three.Float32BufferAttribute(remappedUVs, 2));\\n    }\\n  }, {\\n    key: \\\"parseMorphTargets\\\",\\n    value: function parseMorphTargets(geometry, layer) {\\n      var num = 0;\\n\\n      var _loop2 = function _loop2(name) {\\n        var remappedPoints = geometry.attributes.position.array.slice();\\n        if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\\n        var morphPoints = layer.morphTargets[name].points;\\n        var morphIndices = layer.morphTargets[name].indices;\\n        var type = layer.morphTargets[name].type;\\n        morphIndices.forEach(function (i, j) {\\n          if (type === 'relative') {\\n            remappedPoints[i * 3] += morphPoints[j * 3];\\n            remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\\n            remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\\n          } else {\\n            remappedPoints[i * 3] = morphPoints[j * 3];\\n            remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\\n            remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\\n          }\\n        });\\n        geometry.morphAttributes.position[num] = new _three.Float32BufferAttribute(remappedPoints, 3);\\n        geometry.morphAttributes.position[num].name = name;\\n        num++;\\n      };\\n\\n      for (var name in layer.morphTargets) {\\n        _loop2(name);\\n      }\\n\\n      geometry.morphTargetsRelative = false;\\n    }\\n  }]);\\n\\n  return GeometryParser;\\n}(); // ************** UTILITY FUNCTIONS **************\\n\\n\\nfunction extractParentUrl(url, dir) {\\n  var index = url.indexOf(dir);\\n  if (index === -1) return './';\\n  return url.substr(0, index);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_classCallCheck\",\"instance\",\"Constructor\",\"TypeError\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"extractParentUrl\",\"url\",\"dir\",\"index\",\"indexOf\",\"substr\",\"LWOLoader\",\"_three\",\"_IFFParser\",\"_lwoTree\",\"_Loader\",\"manager\",\"parameters\",\"arguments\",\"undefined\",\"call\",\"self\",\"ReferenceError\",\"_this\",\"resourcePath\",\"load\",\"onLoad\",\"onProgress\",\"onError\",\"scope\",\"path\",\"modelName\",\"split\",\"pop\",\"loader\",\"FileLoader\",\"setPath\",\"setResponseType\",\"buffer\",\"parse\",\"e\",\"console\",\"error\",\"itemError\",\"iffBuffer\",\"IFFParser\",\"textureLoader\",\"TextureLoader\",\"setCrossOrigin\",\"crossOrigin\",\"LWOTreeParser\",\"Loader\",\"materials\",\"MaterialParser\",\"defaultLayerName\",\"meshes\",\"parseLayers\",\"finalMeshes\",\"geometryParser\",\"GeometryParser\",\"layers\",\"forEach\",\"layer\",\"geometry\",\"mesh\",\"parseMesh\",\"number\",\"parent\",\"push\",\"add\",\"applyPivots\",\"getMaterials\",\"userData\",\"matNames\",\"type\",\"duplicateUVs\",\"Points\",\"LineSegments\",\"Mesh\",\"name\",\"pivot\",\"traverse\",\"child\",\"position\",\"x\",\"y\",\"z\",\"parentPivot\",\"namesArray\",\"getMaterialByName\",\"mat\",\"spec\",\"color\",\"size\",\"map\",\"morphTargets\",\"PointsMaterial\",\"LineBasicMaterial\",\"filtered\",\"filter\",\"Boolean\",\"m\",\"Array\",\"isArray\",\"material\",\"aoMap\",\"setAttribute\",\"BufferAttribute\",\"attributes\",\"uv\",\"array\",\"textures\",\"format\",\"parseMaterial\",\"parseMaterialLwo2\",\"materialData\",\"params\",\"side\",\"getSide\",\"flatShading\",\"getSmooth\",\"connections\",\"parseConnections\",\"nodes\",\"maps\",\"parseTextureNodes\",\"parseAttributeImageMaps\",\"parseAttributes\",\"parseEnvMap\",\"assign\",\"getMaterialType\",\"materialType\",\"MeshPhongMaterial\",\"BackSide\",\"FrontSide\",\"DoubleSide\",\"smooth\",\"materialConnections\",\"inputName\",\"inputNodeName\",\"nodeName\",\"matNode\",\"getNodeByRefName\",\"envMap\",\"fileName\",\"refName\",\"textureNodes\",\"node\",\"texture\",\"loadTexture\",\"widthWrappingMode\",\"wrapS\",\"getWrappingType\",\"heightWrappingMode\",\"wrapT\",\"roughnessMap\",\"roughness\",\"specularMap\",\"specular\",\"emissiveMap\",\"emissive\",\"metalnessMap\",\"metalness\",\"alphaMap\",\"transparent\",\"normalMap\",\"amplitude\",\"normalScale\",\"Vector2\",\"bumpMap\",\"attribute\",\"mapData\",\"getTexturePathByIndex\",\"imageIndex\",\"wrap\",\"w\",\"h\",\"Color\",\"fromArray\",\"Transparency\",\"opacity\",\"bumpScale\",\"refractionRatio\",\"parsePhysicalAttributes\",\"parseStandardAttributes\",\"parsePhongAttributes\",\"Clearcoat\",\"clearcoat\",\"clearcoatRoughness\",\"Luminous\",\"emissiveIntensity\",\"Roughness\",\"Metallic\",\"Diffuse\",\"multiplyScalar\",\"Reflection\",\"reflectivity\",\"combine\",\"AddOperation\",\"Luminosity\",\"Specular\",\"setScalar\",\"lerp\",\"clone\",\"Glossiness\",\"shininess\",\"Math\",\"pow\",\"mapping\",\"EquirectangularRefractionMapping\",\"EquirectangularReflectionMapping\",\"warn\",\"num\",\"ClampToEdgeWrapping\",\"RepeatWrapping\",\"MirroredRepeatWrapping\",\"nodeData\",\"MeshPhysicalMaterial\",\"MeshStandardMaterial\",\"geoData\",\"BufferGeometry\",\"Float32BufferAttribute\",\"points\",\"indices\",\"splitIndices\",\"vertexIndices\",\"polygonDimensions\",\"setIndex\",\"parseGroups\",\"computeVertexNormals\",\"parseUVs\",\"parseMorphTargets\",\"translate\",\"remappedIndices\",\"dim\",\"k\",\"_k\",\"tags\",\"elemSize\",\"splitMaterialIndices\",\"materialIndices\",\"indexNum\",\"indexPairs\",\"prevMaterialIndex\",\"materialIndex\",\"prevStart\",\"currentCount\",\"currentIndex\",\"addGroup\",\"groups\",\"_currentIndex\",\"remappedUVs\",\"from\",\"count\",\"_loop\",\"uvs\",\"uvIndices\",\"j\",\"_loop2\",\"remappedPoints\",\"slice\",\"morphAttributes\",\"morphPoints\",\"morphTargetsRelative\"]\n}\n"]