["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/effects/ParallaxBarrierEffect.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$effects$ParallaxBarrierEffect=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ParallaxBarrierEffect=void 0;var _three=require(\"module$node_modules$three$build$three_module\");exports.ParallaxBarrierEffect=function(renderer){var _camera=new _three.OrthographicCamera(-1,1,1,-1,0,1),_scene=new _three.Scene,_stereo=new _three.StereoCamera,_params={minFilter:_three.LinearFilter,magFilter:_three.NearestFilter,\nformat:_three.RGBAFormat},_renderTargetL=new _three.WebGLRenderTarget(512,512,_params),_renderTargetR=new _three.WebGLRenderTarget(512,512,_params);_params=new _three.ShaderMaterial({uniforms:{mapLeft:{value:_renderTargetL.texture},mapRight:{value:_renderTargetR.texture}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d vec2( uv.x, uv.y );\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform sampler2D mapLeft;\\nuniform sampler2D mapRight;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec2 uv \\x3d vUv;\\n\\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) \\x3e 1.00 ) {\\n\\t\\tgl_FragColor \\x3d texture2D( mapLeft, uv );\\n\\t} else {\\n\\t\\tgl_FragColor \\x3d texture2D( mapRight, uv );\\n\\t}\\n}\"});\n_params=new _three.Mesh(new _three.PlaneGeometry(2,2),_params);_scene.add(_params);this.setSize=function(width,height){renderer.setSize(width,height);var pixelRatio=renderer.getPixelRatio();_renderTargetL.setSize(width*pixelRatio,height*pixelRatio);_renderTargetR.setSize(width*pixelRatio,height*pixelRatio)};this.render=function(scene,camera){scene.updateMatrixWorld();null===camera.parent&&camera.updateMatrixWorld();_stereo.update(camera);renderer.setRenderTarget(_renderTargetL);renderer.clear();renderer.render(scene,\n_stereo.cameraL);renderer.setRenderTarget(_renderTargetR);renderer.clear();renderer.render(scene,_stereo.cameraR);renderer.setRenderTarget(null);renderer.render(_scene,_camera)}}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$effects$ParallaxBarrierEffect\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParallaxBarrierEffect = void 0;\n\nvar _three = require(\"three\");\n\nvar ParallaxBarrierEffect = function ParallaxBarrierEffect(renderer) {\n  var _camera = new _three.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n  var _scene = new _three.Scene();\n\n  var _stereo = new _three.StereoCamera();\n\n  var _params = {\n    minFilter: _three.LinearFilter,\n    magFilter: _three.NearestFilter,\n    format: _three.RGBAFormat\n  };\n\n  var _renderTargetL = new _three.WebGLRenderTarget(512, 512, _params);\n\n  var _renderTargetR = new _three.WebGLRenderTarget(512, 512, _params);\n\n  var _material = new _three.ShaderMaterial({\n    uniforms: {\n      mapLeft: {\n        value: _renderTargetL.texture\n      },\n      mapRight: {\n        value: _renderTargetR.texture\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = vec2( uv.x, uv.y );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'varying vec2 vUv;', 'void main() {', '\tvec2 uv = vUv;', '\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {', '\t\tgl_FragColor = texture2D( mapLeft, uv );', '\t} else {', '\t\tgl_FragColor = texture2D( mapRight, uv );', '\t}', '}'].join('\\n')\n  });\n\n  var mesh = new _three.Mesh(new _three.PlaneGeometry(2, 2), _material);\n\n  _scene.add(mesh);\n\n  this.setSize = function (width, height) {\n    renderer.setSize(width, height);\n    var pixelRatio = renderer.getPixelRatio();\n\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n  };\n\n  this.render = function (scene, camera) {\n    scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    _stereo.update(camera);\n\n    renderer.setRenderTarget(_renderTargetL);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraL);\n    renderer.setRenderTarget(_renderTargetR);\n    renderer.clear();\n    renderer.render(scene, _stereo.cameraR);\n    renderer.setRenderTarget(null);\n    renderer.render(_scene, _camera);\n  };\n};\n\nexports.ParallaxBarrierEffect = ParallaxBarrierEffect;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","__esModule","vertexShader","value","magFilter","ParallaxBarrierEffect","render","setSize","mapRight","mapLeft","uniforms","minFilter","format"]],"~:compiled-at",1630917515597,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$effects$ParallaxBarrierEffect.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,8DAAA,CAAmF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG3HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,qBAAR,CAAgC,IAAK,EAErC,KAAIC,OAASP,OAAA,CAAQ,8CAAR,CA8DbE,QAAQI,CAAAA,qBAAR,CA5D4BA,QAA8B,CAACE,QAAD,CAAW,CACnE,IAAIC,QAAU,IAAIF,MAAOG,CAAAA,kBAAX,CAA8B,EAA9B,CAAkC,CAAlC,CAAqC,CAArC,CAAwC,EAAxC,CAA4C,CAA5C,CAA+C,CAA/C,CAAd,CAEIC,OAAS,IAAIJ,MAAOK,CAAAA,KAFxB,CAIIC,QAAU,IAAIN,MAAOO,CAAAA,YAJzB,CAMIC,QAAU,CACZC,UAAWT,MAAOU,CAAAA,YADN,CAEZC,UAAWX,MAAOY,CAAAA,aAFN;AAGZC,OAAQb,MAAOc,CAAAA,UAHH,CANd,CAYIC,eAAiB,IAAIf,MAAOgB,CAAAA,iBAAX,CAA6B,GAA7B,CAAkC,GAAlC,CAAuCR,OAAvC,CAZrB,CAcIS,eAAiB,IAAIjB,MAAOgB,CAAAA,iBAAX,CAA6B,GAA7B,CAAkC,GAAlC,CAAuCR,OAAvC,CAEjBU,QAAAA,CAAY,IAAIlB,MAAOmB,CAAAA,cAAX,CAA0B,CACxCC,SAAU,CACRC,QAAS,CACPvB,MAAOiB,cAAeO,CAAAA,OADf,CADD,CAIRC,SAAU,CACRzB,MAAOmB,cAAeK,CAAAA,OADd,CAJF,CAD8B,CASxCE,aAAiK,qJATzH,CAUxCC,eAA0S,4RAVlQ,CAA1B,CAaZC;OAAAA,CAAO,IAAI1B,MAAO2B,CAAAA,IAAX,CAAgB,IAAI3B,MAAO4B,CAAAA,aAAX,CAAyB,CAAzB,CAA4B,CAA5B,CAAhB,CAAgDV,OAAhD,CAEXd,OAAOyB,CAAAA,GAAP,CAAWH,OAAX,CAEA,KAAKI,CAAAA,OAAL,CAAeC,QAAS,CAACC,KAAD,CAAQC,MAAR,CAAgB,CACtChC,QAAS6B,CAAAA,OAAT,CAAiBE,KAAjB,CAAwBC,MAAxB,CACA,KAAIC,WAAajC,QAASkC,CAAAA,aAAT,EAEjBpB,eAAee,CAAAA,OAAf,CAAuBE,KAAvB,CAA+BE,UAA/B,CAA2CD,MAA3C,CAAoDC,UAApD,CAEAjB,eAAea,CAAAA,OAAf,CAAuBE,KAAvB,CAA+BE,UAA/B,CAA2CD,MAA3C,CAAoDC,UAApD,CANsC,CASxC,KAAKE,CAAAA,MAAL,CAAcC,QAAS,CAACC,KAAD,CAAQC,MAAR,CAAgB,CACrCD,KAAME,CAAAA,iBAAN,EACsB,KAAtB,GAAID,MAAOE,CAAAA,MAAX,EAA4BF,MAAOC,CAAAA,iBAAP,EAE5BlC,QAAQoC,CAAAA,MAAR,CAAeH,MAAf,CAEAtC,SAAS0C,CAAAA,eAAT,CAAyB5B,cAAzB,CACAd,SAAS2C,CAAAA,KAAT,EACA3C,SAASmC,CAAAA,MAAT,CAAgBE,KAAhB;AAAuBhC,OAAQuC,CAAAA,OAA/B,CACA5C,SAAS0C,CAAAA,eAAT,CAAyB1B,cAAzB,CACAhB,SAAS2C,CAAAA,KAAT,EACA3C,SAASmC,CAAAA,MAAT,CAAgBE,KAAhB,CAAuBhC,OAAQwC,CAAAA,OAA/B,CACA7C,SAAS0C,CAAAA,eAAT,CAAyB,IAAzB,CACA1C,SAASmC,CAAAA,MAAT,CAAgBhC,MAAhB,CAAwBF,OAAxB,CAbqC,CA3C4B,CAVsD;\",\n\"sources\":[\"node_modules/three-stdlib/effects/ParallaxBarrierEffect.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$effects$ParallaxBarrierEffect\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ParallaxBarrierEffect = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar ParallaxBarrierEffect = function ParallaxBarrierEffect(renderer) {\\n  var _camera = new _three.OrthographicCamera(-1, 1, 1, -1, 0, 1);\\n\\n  var _scene = new _three.Scene();\\n\\n  var _stereo = new _three.StereoCamera();\\n\\n  var _params = {\\n    minFilter: _three.LinearFilter,\\n    magFilter: _three.NearestFilter,\\n    format: _three.RGBAFormat\\n  };\\n\\n  var _renderTargetL = new _three.WebGLRenderTarget(512, 512, _params);\\n\\n  var _renderTargetR = new _three.WebGLRenderTarget(512, 512, _params);\\n\\n  var _material = new _three.ShaderMaterial({\\n    uniforms: {\\n      mapLeft: {\\n        value: _renderTargetL.texture\\n      },\\n      mapRight: {\\n        value: _renderTargetR.texture\\n      }\\n    },\\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = vec2( uv.x, uv.y );', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n    fragmentShader: ['uniform sampler2D mapLeft;', 'uniform sampler2D mapRight;', 'varying vec2 vUv;', 'void main() {', '\\tvec2 uv = vUv;', '\\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {', '\\t\\tgl_FragColor = texture2D( mapLeft, uv );', '\\t} else {', '\\t\\tgl_FragColor = texture2D( mapRight, uv );', '\\t}', '}'].join('\\\\n')\\n  });\\n\\n  var mesh = new _three.Mesh(new _three.PlaneGeometry(2, 2), _material);\\n\\n  _scene.add(mesh);\\n\\n  this.setSize = function (width, height) {\\n    renderer.setSize(width, height);\\n    var pixelRatio = renderer.getPixelRatio();\\n\\n    _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\\n\\n    _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\\n  };\\n\\n  this.render = function (scene, camera) {\\n    scene.updateMatrixWorld();\\n    if (camera.parent === null) camera.updateMatrixWorld();\\n\\n    _stereo.update(camera);\\n\\n    renderer.setRenderTarget(_renderTargetL);\\n    renderer.clear();\\n    renderer.render(scene, _stereo.cameraL);\\n    renderer.setRenderTarget(_renderTargetR);\\n    renderer.clear();\\n    renderer.render(scene, _stereo.cameraR);\\n    renderer.setRenderTarget(null);\\n    renderer.render(_scene, _camera);\\n  };\\n};\\n\\nexports.ParallaxBarrierEffect = ParallaxBarrierEffect;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"ParallaxBarrierEffect\",\"_three\",\"renderer\",\"_camera\",\"OrthographicCamera\",\"_scene\",\"Scene\",\"_stereo\",\"StereoCamera\",\"_params\",\"minFilter\",\"LinearFilter\",\"magFilter\",\"NearestFilter\",\"format\",\"RGBAFormat\",\"_renderTargetL\",\"WebGLRenderTarget\",\"_renderTargetR\",\"_material\",\"ShaderMaterial\",\"uniforms\",\"mapLeft\",\"texture\",\"mapRight\",\"vertexShader\",\"fragmentShader\",\"mesh\",\"Mesh\",\"PlaneGeometry\",\"add\",\"setSize\",\"this.setSize\",\"width\",\"height\",\"pixelRatio\",\"getPixelRatio\",\"render\",\"this.render\",\"scene\",\"camera\",\"updateMatrixWorld\",\"parent\",\"update\",\"setRenderTarget\",\"clear\",\"cameraL\",\"cameraR\"]\n}\n"]