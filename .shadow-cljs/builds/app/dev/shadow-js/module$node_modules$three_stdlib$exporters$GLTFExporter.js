["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/exporters/GLTFExporter.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$exporters$GLTFExporter=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.GLTFExporter=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(){function GLTFExporter(){this.pluginCallbacks=[];this.register(function(writer){return new GLTFLightExtension(writer)});this.register(function(writer){return new GLTFMaterialsUnlitExtension(writer)});this.register(function(writer){return new GLTFMaterialsPBRSpecularGlossiness(writer)})}\nfunction equalArray(array1,array2){return array1.length===array2.length&&array1.every(function(element,index){return element===array2[index]})}function stringToArrayBuffer(text){if(void 0!==window.TextEncoder)return(new TextEncoder).encode(text).buffer;for(var array=new Uint8Array(new ArrayBuffer(text.length)),i=0,il=text.length;i<il;i++){var value=text.charCodeAt(i);array[i]=255<value?32:value}return array.buffer}function getPaddedArrayBuffer(arrayBuffer,paddingByte){paddingByte=paddingByte||0;var paddedLength=\n4*Math.ceil(arrayBuffer.byteLength/4);if(paddedLength!==arrayBuffer.byteLength){var array=new Uint8Array(paddedLength);array.set(new Uint8Array(arrayBuffer));if(0!==paddingByte)for(arrayBuffer=arrayBuffer.byteLength;arrayBuffer<paddedLength;arrayBuffer++)array[arrayBuffer]=paddingByte;return array.buffer}return arrayBuffer}function GLTFWriter(){this.plugins=[];this.options={};this.pending=[];this.buffers=[];this.byteOffset=0;this.buffers=[];this.nodeMap=new Map;this.skins=[];this.extensionsUsed={};\nthis.uids=new Map;this.uid=0;this.json={asset:{version:\"2.0\",generator:\"THREE.GLTFExporter\"}};this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}function GLTFLightExtension(writer){this.writer=writer;this.name=\"KHR_lights_punctual\"}function GLTFMaterialsUnlitExtension(writer){this.writer=writer;this.name=\"KHR_materials_unlit\"}function GLTFMaterialsPBRSpecularGlossiness(writer){this.writer=writer;this.name=\"KHR_materials_pbrSpecularGlossiness\"}\nGLTFExporter.prototype={constructor:GLTFExporter,register:function(callback){-1===this.pluginCallbacks.indexOf(callback)&&this.pluginCallbacks.push(callback);return this},unregister:function(callback){-1!==this.pluginCallbacks.indexOf(callback)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback),1);return this},parse:function(input,onDone,options){for(var writer=new GLTFWriter,plugins=[],i=0,il=this.pluginCallbacks.length;i<il;i++)plugins.push(this.pluginCallbacks[i](writer));writer.setPlugins(plugins);\nwriter.write(input,onDone,options)}};var THREE_TO_WEBGL={};THREE_TO_WEBGL[_three.NearestFilter]=9728;THREE_TO_WEBGL[_three.NearestMipmapNearestFilter]=9984;THREE_TO_WEBGL[_three.NearestMipmapLinearFilter]=9986;THREE_TO_WEBGL[_three.LinearFilter]=9729;THREE_TO_WEBGL[_three.LinearMipmapNearestFilter]=9985;THREE_TO_WEBGL[_three.LinearMipmapLinearFilter]=9987;THREE_TO_WEBGL[_three.ClampToEdgeWrapping]=33071;THREE_TO_WEBGL[_three.RepeatWrapping]=10497;THREE_TO_WEBGL[_three.MirroredRepeatWrapping]=33648;\nvar PATH_PROPERTIES={scale:\"scale\",position:\"translation\",quaternion:\"rotation\",morphTargetInfluences:\"weights\"},cachedCanvas=null;GLTFWriter.prototype={constructor:GLTFWriter,setPlugins:function(plugins){this.plugins=plugins},write:function(input,onDone,options$jscomp$0){this.options=Object.assign({},{binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,embedImages:!0,maxTextureSize:Infinity,animations:[],includeCustomExtensions:!1},options$jscomp$0);0<this.options.animations.length&&(this.options.trs=\n!0);this.processInput(input);var writer=this;Promise.all(this.pending).then(function(){var json=writer.json,options=writer.options,extensionsUsed=writer.extensionsUsed,blob=new Blob(writer.buffers,{type:\"application/octet-stream\"});extensionsUsed=Object.keys(extensionsUsed);0<extensionsUsed.length&&(json.extensionsUsed=extensionsUsed);json.buffers&&0<json.buffers.length&&(json.buffers[0].byteLength=blob.size);if(!0===options.binary){var reader=new window.FileReader;reader.readAsArrayBuffer(blob);\nreader.onloadend=function(){var binaryChunk=getPaddedArrayBuffer(reader.result),binaryChunkPrefix=new DataView(new ArrayBuffer(8));binaryChunkPrefix.setUint32(0,binaryChunk.byteLength,!0);binaryChunkPrefix.setUint32(4,5130562,!0);var jsonChunk=getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)),32),jsonChunkPrefix=new DataView(new ArrayBuffer(8));jsonChunkPrefix.setUint32(0,jsonChunk.byteLength,!0);jsonChunkPrefix.setUint32(4,1313821514,!0);var header=new ArrayBuffer(12),headerView=new DataView(header);\nheaderView.setUint32(0,1179937895,!0);headerView.setUint32(4,2,!0);headerView.setUint32(8,12+jsonChunkPrefix.byteLength+jsonChunk.byteLength+binaryChunkPrefix.byteLength+binaryChunk.byteLength,!0);binaryChunk=new Blob([header,jsonChunkPrefix,jsonChunk,binaryChunkPrefix,binaryChunk],{type:\"application/octet-stream\"});var glbReader=new window.FileReader;glbReader.readAsArrayBuffer(binaryChunk);glbReader.onloadend=function(){onDone(glbReader.result)}}}else json.buffers&&0<json.buffers.length?(reader=\nnew window.FileReader,reader.readAsDataURL(blob),reader.onloadend=function(){json.buffers[0].uri=reader.result;onDone(json)}):onDone(json)})},serializeUserData:function(object,objectDef){if(0!==Object.keys(object.userData).length){var options=this.options,extensionsUsed=this.extensionsUsed;try{var json=JSON.parse(JSON.stringify(object.userData));if(options.includeCustomExtensions&&json.gltfExtensions){void 0===objectDef.extensions&&(objectDef.extensions={});for(var extensionName in json.gltfExtensions)objectDef.extensions[extensionName]=\njson.gltfExtensions[extensionName],extensionsUsed[extensionName]=!0;delete json.gltfExtensions}0<Object.keys(json).length&&(objectDef.extras=json)}catch(error){console.warn(\"THREE.GLTFExporter: userData of '\".concat(object.name,\"' won't be serialized because of JSON.stringify error - \").concat(error.message))}}},getUID:function(object){this.uids.has(object)||this.uids.set(object,this.uid++);return this.uids.get(object)},isNormalizedNormalAttribute:function(normal){if(this.cache.attributesNormalized.has(normal))return!1;\nfor(var v=new _three.Vector3,i=0,il=normal.count;i<il;i++)if(5E-4<Math.abs(v.fromBufferAttribute(normal,i).length()-1))return!1;return!0},createNormalizedNormalAttribute:function(normal){var cache=this.cache;if(cache.attributesNormalized.has(normal))return cache.attributesNormalized.get(normal);for(var attribute=normal.clone(),v=new _three.Vector3,i=0,il=attribute.count;i<il;i++)v.fromBufferAttribute(attribute,i),0===v.x&&0===v.y&&0===v.z?v.setX(1):v.normalize(),attribute.setXYZ(i,v.x,v.y,v.z);cache.attributesNormalized.set(normal,\nattribute);return attribute},applyTextureTransform:function(mapDef,texture){var didTransform=!1,transformDef={};if(0!==texture.offset.x||0!==texture.offset.y)transformDef.offset=texture.offset.toArray(),didTransform=!0;0!==texture.rotation&&(transformDef.rotation=texture.rotation,didTransform=!0);if(1!==texture.repeat.x||1!==texture.repeat.y)transformDef.scale=texture.repeat.toArray(),didTransform=!0;didTransform&&(mapDef.extensions=mapDef.extensions||{},mapDef.extensions.KHR_texture_transform=transformDef,\nthis.extensionsUsed.KHR_texture_transform=!0)},processBuffer:function(buffer){var json=this.json,buffers=this.buffers;json.buffers||(json.buffers=[{byteLength:0}]);buffers.push(buffer);return 0},processBufferView:function(attribute,componentType,start,count,target){var json=this.json;json.bufferViews||(json.bufferViews=[]);var componentSize=5121===componentType?1:5123===componentType?2:4;for(var byteLength=4*Math.ceil(count*attribute.itemSize*componentSize/4),dataView=new DataView(new ArrayBuffer(byteLength)),\noffset=0,i=start;i<start+count;i++)for(var a=0;a<attribute.itemSize;a++){var value=void 0;4<attribute.itemSize?value=attribute.array[i*attribute.itemSize+a]:0===a?value=attribute.getX(i):1===a?value=attribute.getY(i):2===a?value=attribute.getZ(i):3===a&&(value=attribute.getW(i));5126===componentType?dataView.setFloat32(offset,value,!0):5125===componentType?dataView.setUint32(offset,value,!0):5123===componentType?dataView.setUint16(offset,value,!0):5121===componentType&&dataView.setUint8(offset,value);\noffset+=componentSize}componentType={buffer:this.processBuffer(dataView.buffer),byteOffset:this.byteOffset,byteLength};void 0!==target&&(componentType.target=target);34962===target&&(componentType.byteStride=attribute.itemSize*componentSize);this.byteOffset+=byteLength;json.bufferViews.push(componentType);return{id:json.bufferViews.length-1,byteLength:0}},processBufferViewImage:function(blob){var writer=this,json=writer.json;json.bufferViews||(json.bufferViews=[]);return new Promise(function(resolve){var reader=\nnew window.FileReader;reader.readAsArrayBuffer(blob);reader.onloadend=function(){var buffer=getPaddedArrayBuffer(reader.result),bufferViewDef={buffer:writer.processBuffer(buffer),byteOffset:writer.byteOffset,byteLength:buffer.byteLength};writer.byteOffset+=buffer.byteLength;resolve(json.bufferViews.push(bufferViewDef)-1)}})},processAccessor:function(attribute,geometry,start$jscomp$0,count$jscomp$0){var options=this.options,json=this.json;if(attribute.array.constructor===Float32Array)var componentType=\n5126;else if(attribute.array.constructor===Uint32Array)componentType=5125;else if(attribute.array.constructor===Uint16Array)componentType=5123;else if(attribute.array.constructor===Uint8Array)componentType=5121;else throw Error(\"THREE.GLTFExporter: Unsupported bufferAttribute component type.\");void 0===start$jscomp$0&&(start$jscomp$0=0);void 0===count$jscomp$0&&(count$jscomp$0=attribute.count);options.truncateDrawRange&&void 0!==geometry&&null===geometry.index&&(count$jscomp$0=start$jscomp$0+count$jscomp$0,\noptions=Infinity===geometry.drawRange.count?attribute.count:geometry.drawRange.start+geometry.drawRange.count,start$jscomp$0=Math.max(start$jscomp$0,geometry.drawRange.start),count$jscomp$0=Math.min(count$jscomp$0,options)-start$jscomp$0,0>count$jscomp$0&&(count$jscomp$0=0));if(0===count$jscomp$0)return null;var start=start$jscomp$0,count=count$jscomp$0;options=Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY);for(var JSCompiler_object_inline_max_8514=Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY),\ni=start;i<start+count;i++)for(var a=0;a<attribute.itemSize;a++){var value=void 0;4<attribute.itemSize?value=attribute.array[i*attribute.itemSize+a]:0===a?value=attribute.getX(i):1===a?value=attribute.getY(i):2===a?value=attribute.getZ(i):3===a&&(value=attribute.getW(i));options[a]=Math.min(options[a],value);JSCompiler_object_inline_max_8514[a]=Math.max(JSCompiler_object_inline_max_8514[a],value)}var bufferViewTarget;void 0!==geometry&&(bufferViewTarget=attribute===geometry.index?34963:34962);geometry=\nthis.processBufferView(attribute,componentType,start$jscomp$0,count$jscomp$0,bufferViewTarget);componentType={bufferView:geometry.id,byteOffset:geometry.byteOffset,componentType,count:count$jscomp$0,max:JSCompiler_object_inline_max_8514,min:options,type:{1:\"SCALAR\",2:\"VEC2\",3:\"VEC3\",4:\"VEC4\",16:\"MAT4\"}[attribute.itemSize]};!0===attribute.normalized&&(componentType.normalized=!0);json.accessors||(json.accessors=[]);return json.accessors.push(componentType)-1},processImage:function(image,format,flipY){var writer=\nthis,cache=writer.cache,json=writer.json,options=writer.options,pending=writer.pending;cache.images.has(image)||cache.images.set(image,{});cache=cache.images.get(image);var mimeType=format===_three.RGBAFormat?\"image/png\":\"image/jpeg\",key=\"\".concat(mimeType,\":flipY/\").concat(flipY.toString());if(void 0!==cache[key])return cache[key];json.images||(json.images=[]);var imageDef={mimeType};if(options.embedImages){var canvas=cachedCanvas=cachedCanvas||document.createElement(\"canvas\");canvas.width=Math.min(image.width,\noptions.maxTextureSize);canvas.height=Math.min(image.height,options.maxTextureSize);var ctx=canvas.getContext(\"2d\");!0===flipY&&(ctx.translate(0,canvas.height),ctx.scale(1,-1));if(\"undefined\"!==typeof HTMLImageElement&&image instanceof HTMLImageElement||\"undefined\"!==typeof HTMLCanvasElement&&image instanceof HTMLCanvasElement||\"undefined\"!==typeof OffscreenCanvas&&image instanceof OffscreenCanvas||\"undefined\"!==typeof ImageBitmap&&image instanceof ImageBitmap)ctx.drawImage(image,0,0,canvas.width,\ncanvas.height);else{format!==_three.RGBAFormat&&format!==_three.RGBFormat&&console.error(\"GLTFExporter: Only RGB and RGBA formats are supported.\");(image.width>options.maxTextureSize||image.height>options.maxTextureSize)&&console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\",image);flipY=image.data;if(format===_three.RGBFormat){flipY=new Uint8ClampedArray(image.height*image.width*4);for(var j=format=0;format<flipY.length;format+=4,j+=3)flipY[format+0]=image.data[j+0],flipY[format+\n1]=image.data[j+1],flipY[format+2]=image.data[j+2],flipY[format+3]=255}ctx.putImageData(new ImageData(flipY,image.width,image.height),0,0)}!0===options.binary?pending.push(new Promise(function(resolve){canvas.toBlob(function(blob){writer.processBufferViewImage(blob).then(function(bufferViewIndex){imageDef.bufferView=bufferViewIndex;resolve()})},mimeType)})):imageDef.uri=canvas.toDataURL(mimeType)}else imageDef.uri=image.src;image=json.images.push(imageDef)-1;return cache[key]=image},processSampler:function(map){var json=\nthis.json;json.samplers||(json.samplers=[]);return json.samplers.push({magFilter:THREE_TO_WEBGL[map.magFilter],minFilter:THREE_TO_WEBGL[map.minFilter],wrapS:THREE_TO_WEBGL[map.wrapS],wrapT:THREE_TO_WEBGL[map.wrapT]})-1},processTexture:function(map){var cache=this.cache,json=this.json;if(cache.textures.has(map))return cache.textures.get(map);json.textures||(json.textures=[]);var textureDef={sampler:this.processSampler(map),source:this.processImage(map.image,map.format,map.flipY)};map.name&&(textureDef.name=\nmap.name);this._invokeAll(function(ext){ext.writeTexture&&ext.writeTexture(map,textureDef)});json=json.textures.push(textureDef)-1;cache.textures.set(map,json);return json},processMaterial:function(material){var cache=this.cache,json=this.json;if(cache.materials.has(material))return cache.materials.get(material);if(material.isShaderMaterial)return console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\"),null;json.materials||(json.materials=[]);var materialDef={pbrMetallicRoughness:{}};!0!==\nmaterial.isMeshStandardMaterial&&!0!==material.isMeshBasicMaterial&&console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");var color=material.color.toArray().concat([material.opacity]);equalArray(color,[1,1,1,1])||(materialDef.pbrMetallicRoughness.baseColorFactor=color);material.isMeshStandardMaterial?(materialDef.pbrMetallicRoughness.metallicFactor=material.metalness,materialDef.pbrMetallicRoughness.roughnessFactor=material.roughness):(materialDef.pbrMetallicRoughness.metallicFactor=\n.5,materialDef.pbrMetallicRoughness.roughnessFactor=.5);if(material.metalnessMap||material.roughnessMap)material.metalnessMap===material.roughnessMap?(color={index:this.processTexture(material.metalnessMap)},this.applyTextureTransform(color,material.metalnessMap),materialDef.pbrMetallicRoughness.metallicRoughnessTexture=color):console.warn(\"THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.\");material.map&&(color={index:this.processTexture(material.map)},\nthis.applyTextureTransform(color,material.map),materialDef.pbrMetallicRoughness.baseColorTexture=color);material.emissive&&(color=material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray(),equalArray(color,[0,0,0])||(materialDef.emissiveFactor=color),material.emissiveMap&&(color={index:this.processTexture(material.emissiveMap)},this.applyTextureTransform(color,material.emissiveMap),materialDef.emissiveTexture=color));material.normalMap&&(color={index:this.processTexture(material.normalMap)},\nmaterial.normalScale&&-1!==material.normalScale.x&&(material.normalScale.x!==material.normalScale.y&&console.warn(\"THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.\"),color.scale=material.normalScale.x),this.applyTextureTransform(color,material.normalMap),materialDef.normalTexture=color);material.aoMap&&(color={index:this.processTexture(material.aoMap),texCoord:1},1!==material.aoMapIntensity&&(color.strength=material.aoMapIntensity),this.applyTextureTransform(color,\nmaterial.aoMap),materialDef.occlusionTexture=color);material.transparent?materialDef.alphaMode=\"BLEND\":0<material.alphaTest&&(materialDef.alphaMode=\"MASK\",materialDef.alphaCutoff=material.alphaTest);material.side===_three.DoubleSide&&(materialDef.doubleSided=!0);\"\"!==material.name&&(materialDef.name=material.name);this.serializeUserData(material,materialDef);this._invokeAll(function(ext){ext.writeMaterial&&ext.writeMaterial(material,materialDef)});json=json.materials.push(materialDef)-1;cache.materials.set(material,\njson);return json},processMesh:function(mesh){var cache=this.cache,json=this.json,meshCacheKeyParts=[mesh.geometry.uuid];if(Array.isArray(mesh.material))for(var i=0,l=mesh.material.length;i<l;i++)meshCacheKeyParts.push(mesh.material[i].uuid);else meshCacheKeyParts.push(mesh.material.uuid);meshCacheKeyParts=meshCacheKeyParts.join(\":\");if(cache.meshes.has(meshCacheKeyParts))return cache.meshes.get(meshCacheKeyParts);i=mesh.geometry;l=mesh.isLineSegments?1:mesh.isLineLoop?2:mesh.isLine?3:mesh.isPoints?\n0:mesh.material.wireframe?1:4;if(!0!==i.isBufferGeometry)throw Error(\"THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.\");var meshDef={},attributes={},primitives=[],targets=[],nameConversion={uv:\"TEXCOORD_0\",uv2:\"TEXCOORD_1\",color:\"COLOR_0\",skinWeight:\"WEIGHTS_0\",skinIndex:\"JOINTS_0\"},originalNormal=i.getAttribute(\"normal\");void 0===originalNormal||this.isNormalizedNormalAttribute(originalNormal)||(console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\"),\ni.setAttribute(\"normal\",this.createNormalizedNormalAttribute(originalNormal)));var modifiedAttribute=null;for(attributeName in i.attributes)if(\"morph\"!==attributeName.substr(0,5)){var attribute=i.attributes[attributeName];var attributeName=nameConversion[attributeName]||attributeName.toUpperCase();/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/.test(attributeName)||(attributeName=\"_\".concat(attributeName));if(cache.attributes.has(this.getUID(attribute)))attributes[attributeName]=\ncache.attributes.get(this.getUID(attribute));else{modifiedAttribute=null;var array=attribute.array;\"JOINTS_0\"!==attributeName||array instanceof Uint16Array||array instanceof Uint8Array||(console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.'),modifiedAttribute=new _three.BufferAttribute(new Uint16Array(array),attribute.itemSize,attribute.normalized));modifiedAttribute=this.processAccessor(modifiedAttribute||attribute,i);null!==modifiedAttribute&&(attributes[attributeName]=\nmodifiedAttribute,cache.attributes.set(this.getUID(attribute),modifiedAttribute))}}void 0!==originalNormal&&i.setAttribute(\"normal\",originalNormal);if(0===Object.keys(attributes).length)return null;if(void 0!==mesh.morphTargetInfluences&&0<mesh.morphTargetInfluences.length){attributeName=[];nameConversion=[];originalNormal={};if(void 0!==mesh.morphTargetDictionary)for(var key in mesh.morphTargetDictionary)originalNormal[mesh.morphTargetDictionary[key]]=key;for(key=0;key<mesh.morphTargetInfluences.length;++key){modifiedAttribute=\n{};array=!1;for(var _attributeName in i.morphAttributes)if(\"position\"!==_attributeName&&\"normal\"!==_attributeName)array||(console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\"),array=!0);else{attribute=i.morphAttributes[_attributeName][key];var gltfAttributeName=_attributeName.toUpperCase(),baseAttribute=i.attributes[_attributeName];if(cache.attributes.has(this.getUID(attribute)))modifiedAttribute[gltfAttributeName]=cache.attributes.get(this.getUID(attribute));else{var relativeAttribute=\nattribute.clone();if(!i.morphTargetsRelative)for(var j=0,jl=attribute.count;j<jl;j++)relativeAttribute.setXYZ(j,attribute.getX(j)-baseAttribute.getX(j),attribute.getY(j)-baseAttribute.getY(j),attribute.getZ(j)-baseAttribute.getZ(j));modifiedAttribute[gltfAttributeName]=this.processAccessor(relativeAttribute,i);cache.attributes.set(this.getUID(baseAttribute),modifiedAttribute[gltfAttributeName])}}targets.push(modifiedAttribute);attributeName.push(mesh.morphTargetInfluences[key]);void 0!==mesh.morphTargetDictionary&&\nnameConversion.push(originalNormal[key])}meshDef.weights=attributeName;0<nameConversion.length&&(meshDef.extras={},meshDef.extras.targetNames=nameConversion)}if((attribute=Array.isArray(mesh.material))&&0===i.groups.length)return null;_attributeName=attribute?mesh.material:[mesh.material];attribute=attribute?i.groups:[{materialIndex:0,start:void 0,count:void 0}];key=0;for(attributeName=attribute.length;key<attributeName;key++){nameConversion={mode:l,attributes};this.serializeUserData(i,nameConversion);\n0<targets.length&&(nameConversion.targets=targets);if(null!==i.index){originalNormal=this.getUID(i.index);if(void 0!==attribute[key].start||void 0!==attribute[key].count)originalNormal+=\":\".concat(attribute[key].start,\":\").concat(attribute[key].count);cache.attributes.has(originalNormal)?nameConversion.indices=cache.attributes.get(originalNormal):(nameConversion.indices=this.processAccessor(i.index,i,attribute[key].start,attribute[key].count),cache.attributes.set(originalNormal,nameConversion.indices));\nnull===nameConversion.indices&&delete nameConversion.indices}originalNormal=this.processMaterial(_attributeName[attribute[key].materialIndex]);null!==originalNormal&&(nameConversion.material=originalNormal);primitives.push(nameConversion)}meshDef.primitives=primitives;json.meshes||(json.meshes=[]);this._invokeAll(function(ext){ext.writeMesh&&ext.writeMesh(mesh,meshDef)});json=json.meshes.push(meshDef)-1;cache.meshes.set(meshCacheKeyParts,json);return json},processCamera:function(camera){var json=\nthis.json;json.cameras||(json.cameras=[]);var isOrtho=camera.isOrthographicCamera,cameraDef={type:isOrtho?\"orthographic\":\"perspective\"};isOrtho?cameraDef.orthographic={xmag:2*camera.right,ymag:2*camera.top,zfar:0>=camera.far?.001:camera.far,znear:0>camera.near?0:camera.near}:cameraDef.perspective={aspectRatio:camera.aspect,yfov:_three.MathUtils.degToRad(camera.fov),zfar:0>=camera.far?.001:camera.far,znear:0>camera.near?0:camera.near};\"\"!==camera.name&&(cameraDef.name=camera.type);return json.cameras.push(cameraDef)-\n1},processAnimation:function(clip,root){var json=this.json,nodeMap=this.nodeMap;json.animations||(json.animations=[]);clip=GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(),root);for(var tracks=clip.tracks,channels=[],samplers=[],i=0;i<tracks.length;++i){var track=tracks[i],trackBinding=_three.PropertyBinding.parseTrackName(track.name),trackNode=_three.PropertyBinding.findNode(root,trackBinding.nodeName),trackProperty=PATH_PROPERTIES[trackBinding.propertyName];\"bones\"===trackBinding.objectName&&\n(trackNode=!0===trackNode.isSkinnedMesh?trackNode.skeleton.getBoneByName(trackBinding.objectIndex):void 0);if(!trackNode||!trackProperty)return console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".',track.name),null;trackBinding=track.values.length/track.times.length;trackProperty===PATH_PROPERTIES.morphTargetInfluences&&(trackBinding/=trackNode.morphTargetInfluences.length);if(!0===track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline){var interpolation=\"CUBICSPLINE\";\ntrackBinding/=3}else interpolation=track.getInterpolation()===_three.InterpolateDiscrete?\"STEP\":\"LINEAR\";samplers.push({input:this.processAccessor(new _three.BufferAttribute(track.times,1)),output:this.processAccessor(new _three.BufferAttribute(track.values,trackBinding)),interpolation});channels.push({sampler:samplers.length-1,target:{node:nodeMap.get(trackNode),path:trackProperty}})}json.animations.push({name:clip.name||\"clip_\".concat(json.animations.length),samplers,channels});return json.animations.length-\n1},processSkin:function(object){var json=this.json,nodeMap=this.nodeMap,node=json.nodes[nodeMap.get(object)],skeleton=object.skeleton;if(void 0===skeleton)return null;var rootJoint=object.skeleton.bones[0];if(void 0===rootJoint)return null;for(var joints=[],inverseBindMatrices=new Float32Array(16*skeleton.bones.length),temporaryBoneInverse=new _three.Matrix4,i=0;i<skeleton.bones.length;++i)joints.push(nodeMap.get(skeleton.bones[i])),temporaryBoneInverse.copy(skeleton.boneInverses[i]),temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices,\n16*i);void 0===json.skins&&(json.skins=[]);json.skins.push({inverseBindMatrices:this.processAccessor(new _three.BufferAttribute(inverseBindMatrices,16)),joints,skeleton:nodeMap.get(rootJoint)});return node.skin=json.skins.length-1},processNode:function(object){var json=this.json,options=this.options,nodeMap=this.nodeMap;json.nodes||(json.nodes=[]);var nodeDef={};if(options.trs){var rotation=object.quaternion.toArray(),position=object.position.toArray(),scale=object.scale.toArray();equalArray(rotation,\n[0,0,0,1])||(nodeDef.rotation=rotation);equalArray(position,[0,0,0])||(nodeDef.translation=position);equalArray(scale,[1,1,1])||(nodeDef.scale=scale)}else object.matrixAutoUpdate&&object.updateMatrix(),!1===equalArray(object.matrix.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])&&(nodeDef.matrix=object.matrix.elements);\"\"!==object.name&&(nodeDef.name=String(object.name));this.serializeUserData(object,nodeDef);object.isMesh||object.isLine||object.isPoints?(rotation=this.processMesh(object),null!==rotation&&\n(nodeDef.mesh=rotation)):object.isCamera&&(nodeDef.camera=this.processCamera(object));object.isSkinnedMesh&&this.skins.push(object);if(0<object.children.length){rotation=[];position=0;for(scale=object.children.length;position<scale;position++){var child=object.children[position];if(child.visible||!1===options.onlyVisible)child=this.processNode(child),null!==child&&rotation.push(child)}0<rotation.length&&(nodeDef.children=rotation)}this._invokeAll(function(ext){ext.writeNode&&ext.writeNode(object,\nnodeDef)});child=json.nodes.push(nodeDef)-1;nodeMap.set(object,child);return child},processScene:function(scene){var json=this.json,options=this.options;json.scenes||(json.scenes=[],json.scene=0);var sceneDef={};\"\"!==scene.name&&(sceneDef.name=scene.name);json.scenes.push(sceneDef);json=[];for(var i=0,l=scene.children.length;i<l;i++){var child=scene.children[i];if(child.visible||!1===options.onlyVisible)child=this.processNode(child),null!==child&&json.push(child)}0<json.length&&(sceneDef.nodes=json);\nthis.serializeUserData(scene,sceneDef)},processObjects:function(objects){var scene=new _three.Scene;scene.name=\"AuxScene\";for(var i=0;i<objects.length;i++)scene.children.push(objects[i]);this.processScene(scene)},processInput:function(input){var options=this.options;input=input instanceof Array?input:[input];this._invokeAll(function(ext){ext.beforeParse&&ext.beforeParse(input)});for(var objectsWithoutScene=[],i=0;i<input.length;i++)input[i]instanceof _three.Scene?this.processScene(input[i]):objectsWithoutScene.push(input[i]);\n0<objectsWithoutScene.length&&this.processObjects(objectsWithoutScene);for(objectsWithoutScene=0;objectsWithoutScene<this.skins.length;++objectsWithoutScene)this.processSkin(this.skins[objectsWithoutScene]);for(objectsWithoutScene=0;objectsWithoutScene<options.animations.length;++objectsWithoutScene)this.processAnimation(options.animations[objectsWithoutScene],input[0]);this._invokeAll(function(ext){ext.afterParse&&ext.afterParse(input)})},_invokeAll:function(func){for(var i=0,il=this.plugins.length;i<\nil;i++)func(this.plugins[i])}};GLTFLightExtension.prototype={constructor:GLTFLightExtension,writeNode:function(light,nodeDef){if(light.isLight)if(light.isDirectionalLight||light.isPointLight||light.isSpotLight){var writer=this.writer,json=writer.json,extensionsUsed=writer.extensionsUsed;writer={};light.name&&(writer.name=light.name);writer.color=light.color.toArray();writer.intensity=light.intensity;light.isDirectionalLight?writer.type=\"directional\":light.isPointLight?(writer.type=\"point\",0<light.distance&&\n(writer.range=light.distance)):light.isSpotLight&&(writer.type=\"spot\",0<light.distance&&(writer.range=light.distance),writer.spot={},writer.spot.innerConeAngle=(light.penumbra-1)*light.angle*-1,writer.spot.outerConeAngle=light.angle);void 0!==light.decay&&2!==light.decay&&console.warn(\"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay\\x3d2.\");!light.target||light.target.parent===light&&0===light.target.position.x&&0===light.target.position.y&&-1===light.target.position.z||\nconsole.warn(\"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\");extensionsUsed[this.name]||(json.extensions=json.extensions||{},json.extensions[this.name]={lights:[]},extensionsUsed[this.name]=!0);light=json.extensions[this.name].lights;light.push(writer);nodeDef.extensions=nodeDef.extensions||{};nodeDef.extensions[this.name]={light:light.length-1}}else console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\",\nlight)}};GLTFMaterialsUnlitExtension.prototype={constructor:GLTFMaterialsUnlitExtension,writeMaterial:function(material,materialDef){material.isMeshBasicMaterial&&(material=this.writer.extensionsUsed,materialDef.extensions=materialDef.extensions||{},materialDef.extensions[this.name]={},material[this.name]=!0,materialDef.pbrMetallicRoughness.metallicFactor=0,materialDef.pbrMetallicRoughness.roughnessFactor=.9)}};GLTFMaterialsPBRSpecularGlossiness.prototype={constructor:GLTFMaterialsPBRSpecularGlossiness,\nwriteMaterial:function(material,materialDef){if(material.isGLTFSpecularGlossinessMaterial){var writer=this.writer,extensionsUsed=writer.extensionsUsed,extensionDef={};materialDef.pbrMetallicRoughness.baseColorFactor&&(extensionDef.diffuseFactor=materialDef.pbrMetallicRoughness.baseColorFactor);var specularFactor=[1,1,1];material.specular.toArray(specularFactor,0);extensionDef.specularFactor=specularFactor;extensionDef.glossinessFactor=material.glossiness;materialDef.pbrMetallicRoughness.baseColorTexture&&\n(extensionDef.diffuseTexture=materialDef.pbrMetallicRoughness.baseColorTexture);material.specularMap&&(specularFactor={index:writer.processTexture(material.specularMap)},writer.applyTextureTransform(specularFactor,material.specularMap),extensionDef.specularGlossinessTexture=specularFactor);materialDef.extensions=materialDef.extensions||{};materialDef.extensions[this.name]=extensionDef;extensionsUsed[this.name]=!0}}};GLTFExporter.Utils={insertKeyframe:function(track,time){var valueSize=track.getValueSize(),\ntimes=new track.TimeBufferType(track.times.length+1),values=new track.ValueBufferType(track.values.length+valueSize),interpolant=track.createInterpolant(new track.ValueBufferType(valueSize));if(0===track.times.length){times[0]=time;for(time=0;time<valueSize;time++)values[time]=0;var index=0}else if(time<track.times[0]){if(.001>Math.abs(track.times[0]-time))return 0;times[0]=time;times.set(track.times,1);values.set(interpolant.evaluate(time),0);values.set(track.values,valueSize);index=0}else if(time>\ntrack.times[track.times.length-1]){if(.001>Math.abs(track.times[track.times.length-1]-time))return track.times.length-1;times[times.length-1]=time;times.set(track.times,0);values.set(track.values,0);values.set(interpolant.evaluate(time),track.values.length);index=times.length-1}else for(var _i5=0;_i5<track.times.length;_i5++){if(.001>Math.abs(track.times[_i5]-time))return _i5;if(track.times[_i5]<time&&track.times[_i5+1]>time){times.set(track.times.slice(0,_i5+1),0);times[_i5+1]=time;times.set(track.times.slice(_i5+\n1),_i5+2);values.set(track.values.slice(0,(_i5+1)*valueSize),0);values.set(interpolant.evaluate(time),(_i5+1)*valueSize);values.set(track.values.slice((_i5+1)*valueSize),(_i5+2)*valueSize);index=_i5+1;break}}track.times=times;track.values=values;return index},mergeMorphTargetTracks:function(clip,root){for(var tracks=[],mergedTracks={},sourceTracks=clip.tracks,i=0;i<sourceTracks.length;++i){var sourceTrack=sourceTracks[i],sourceTrackBinding=_three.PropertyBinding.parseTrackName(sourceTrack.name),sourceTrackNode=\n_three.PropertyBinding.findNode(root,sourceTrackBinding.nodeName);if(\"morphTargetInfluences\"!==sourceTrackBinding.propertyName||void 0===sourceTrackBinding.propertyIndex)tracks.push(sourceTrack);else{if(sourceTrack.createInterpolant!==sourceTrack.InterpolantFactoryMethodDiscrete&&sourceTrack.createInterpolant!==sourceTrack.InterpolantFactoryMethodLinear){if(sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\nconsole.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");sourceTrack=sourceTrack.clone();sourceTrack.setInterpolation(_three.InterpolateLinear)}var targetCount=sourceTrackNode.morphTargetInfluences.length,targetIndex=sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];if(void 0===targetIndex)throw Error(\"THREE.GLTFExporter: Morph target name not found: \".concat(sourceTrackBinding.propertyIndex));if(void 0===mergedTracks[sourceTrackNode.uuid]){var mergedTrack=\nsourceTrack.clone();sourceTrack=new mergedTrack.ValueBufferType(targetCount*mergedTrack.times.length);for(var j=0;j<mergedTrack.times.length;j++)sourceTrack[j*targetCount+targetIndex]=mergedTrack.values[j];mergedTrack.name=\"\".concat(sourceTrackBinding.nodeName||\"\",\".morphTargetInfluences\");mergedTrack.values=sourceTrack;mergedTracks[sourceTrackNode.uuid]=mergedTrack;tracks.push(mergedTrack)}else{sourceTrackBinding=sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));mergedTrack=mergedTracks[sourceTrackNode.uuid];\nfor(sourceTrackNode=0;sourceTrackNode<mergedTrack.times.length;sourceTrackNode++)mergedTrack.values[sourceTrackNode*targetCount+targetIndex]=sourceTrackBinding.evaluate(mergedTrack.times[sourceTrackNode]);for(sourceTrackNode=0;sourceTrackNode<sourceTrack.times.length;sourceTrackNode++)sourceTrackBinding=this.insertKeyframe(mergedTrack,sourceTrack.times[sourceTrackNode]),mergedTrack.values[sourceTrackBinding*targetCount+targetIndex]=sourceTrack.values[sourceTrackNode]}}}clip.tracks=tracks;return clip}};\nreturn GLTFExporter}();exports.GLTFExporter=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$exporters$GLTFExporter\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GLTFExporter = void 0;\n\nvar _three = require(\"three\");\n\nvar GLTFExporter = function () {\n  function GLTFExporter() {\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n  }\n\n  GLTFExporter.prototype = {\n    constructor: GLTFExporter,\n    register: function register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n\n      return this;\n    },\n    unregister: function unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n\n      return this;\n    },\n\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n    parse: function parse(input, onDone, options) {\n      var writer = new GLTFWriter();\n      var plugins = [];\n\n      for (var i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options);\n    }\n  }; //------------------------------------------------------------------------------\n  // Constants\n  //------------------------------------------------------------------------------\n\n  var WEBGL_CONSTANTS = {\n    POINTS: 0x0000,\n    LINES: 0x0001,\n    LINE_LOOP: 0x0002,\n    LINE_STRIP: 0x0003,\n    TRIANGLES: 0x0004,\n    TRIANGLE_STRIP: 0x0005,\n    TRIANGLE_FAN: 0x0006,\n    UNSIGNED_BYTE: 0x1401,\n    UNSIGNED_SHORT: 0x1403,\n    FLOAT: 0x1406,\n    UNSIGNED_INT: 0x1405,\n    ARRAY_BUFFER: 0x8892,\n    ELEMENT_ARRAY_BUFFER: 0x8893,\n    NEAREST: 0x2600,\n    LINEAR: 0x2601,\n    NEAREST_MIPMAP_NEAREST: 0x2700,\n    LINEAR_MIPMAP_NEAREST: 0x2701,\n    NEAREST_MIPMAP_LINEAR: 0x2702,\n    LINEAR_MIPMAP_LINEAR: 0x2703,\n    CLAMP_TO_EDGE: 33071,\n    MIRRORED_REPEAT: 33648,\n    REPEAT: 10497\n  };\n  var THREE_TO_WEBGL = {};\n  THREE_TO_WEBGL[_three.NearestFilter] = WEBGL_CONSTANTS.NEAREST;\n  THREE_TO_WEBGL[_three.NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\n  THREE_TO_WEBGL[_three.NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\n  THREE_TO_WEBGL[_three.LinearFilter] = WEBGL_CONSTANTS.LINEAR;\n  THREE_TO_WEBGL[_three.LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\n  THREE_TO_WEBGL[_three.LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n  THREE_TO_WEBGL[_three.ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\n  THREE_TO_WEBGL[_three.RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\n  THREE_TO_WEBGL[_three.MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n  var PATH_PROPERTIES = {\n    scale: 'scale',\n    position: 'translation',\n    quaternion: 'rotation',\n    morphTargetInfluences: 'weights'\n  }; // GLB constants\n  // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n  var GLB_HEADER_BYTES = 12;\n  var GLB_HEADER_MAGIC = 0x46546c67;\n  var GLB_VERSION = 2;\n  var GLB_CHUNK_PREFIX_BYTES = 8;\n  var GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\n  var GLB_CHUNK_TYPE_BIN = 0x004e4942; //------------------------------------------------------------------------------\n  // Utility functions\n  //------------------------------------------------------------------------------\n\n  /**\n   * Compare two arrays\n   * @param  {Array} array1 Array 1 to compare\n   * @param  {Array} array2 Array 2 to compare\n   * @return {Boolean}        Returns true if both arrays are equal\n   */\n\n  function equalArray(array1, array2) {\n    return array1.length === array2.length && array1.every(function (element, index) {\n      return element === array2[index];\n    });\n  }\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param  {string} text\n   * @return {ArrayBuffer}\n   */\n\n\n  function stringToArrayBuffer(text) {\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(text).buffer;\n    }\n\n    var array = new Uint8Array(new ArrayBuffer(text.length));\n\n    for (var i = 0, il = text.length; i < il; i++) {\n      var value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n      array[i] = value > 0xff ? 0x20 : value;\n    }\n\n    return array.buffer;\n  }\n  /**\n   * Is identity matrix\n   *\n   * @param {Matrix4} matrix\n   * @returns {Boolean} Returns true, if parameter is identity matrix\n   */\n\n\n  function isIdentityMatrix(matrix) {\n    return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n  /**\n   * Get the min and max vectors from the given attribute\n   * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n   * @param  {Integer} start\n   * @param  {Integer} count\n   * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n   */\n\n\n  function getMinMax(attribute, start, count) {\n    var output = {\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n    };\n\n    for (var i = start; i < start + count; i++) {\n      for (var a = 0; a < attribute.itemSize; a++) {\n        var value = void 0;\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        }\n\n        output.min[a] = Math.min(output.min[a], value);\n        output.max[a] = Math.max(output.max[a], value);\n      }\n    }\n\n    return output;\n  }\n  /**\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n   *\n   * @param {Integer} bufferSize The size the original buffer.\n   * @returns {Integer} new buffer size with required padding.\n   *\n   */\n\n\n  function getPaddedBufferSize(bufferSize) {\n    return Math.ceil(bufferSize / 4) * 4;\n  }\n  /**\n   * Returns a buffer aligned to 4-byte boundary.\n   *\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\n   * @param {Integer} paddingByte (Optional)\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n   */\n\n\n  function getPaddedArrayBuffer(arrayBuffer, paddingByte) {\n    paddingByte = paddingByte || 0;\n    var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n\n    if (paddedLength !== arrayBuffer.byteLength) {\n      var array = new Uint8Array(paddedLength);\n      array.set(new Uint8Array(arrayBuffer));\n\n      if (paddingByte !== 0) {\n        for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n          array[i] = paddingByte;\n        }\n      }\n\n      return array.buffer;\n    }\n\n    return arrayBuffer;\n  }\n\n  var cachedCanvas = null;\n  /**\n   * Writer\n   */\n\n  function GLTFWriter() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n  }\n\n  GLTFWriter.prototype = {\n    constructor: GLTFWriter,\n    setPlugins: function setPlugins(plugins) {\n      this.plugins = plugins;\n    },\n\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n    write: function write(input, onDone, options) {\n      this.options = Object.assign({}, {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        truncateDrawRange: true,\n        embedImages: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      }, options);\n\n      if (this.options.animations.length > 0) {\n        // Only TRS properties, and not matrices, may be targeted by animation.\n        this.options.trs = true;\n      }\n\n      this.processInput(input);\n      var writer = this;\n      Promise.all(this.pending).then(function () {\n        var buffers = writer.buffers;\n        var json = writer.json;\n        var options = writer.options;\n        var extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n        var blob = new Blob(buffers, {\n          type: 'application/octet-stream'\n        }); // Declare extensions.\n\n        var extensionsUsedList = Object.keys(extensionsUsed);\n        if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n        if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n        if (options.binary === true) {\n          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n          var reader = new window.FileReader();\n          reader.readAsArrayBuffer(blob);\n\n          reader.onloadend = function () {\n            // Binary chunk.\n            var binaryChunk = getPaddedArrayBuffer(reader.result);\n            var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n            var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\n            var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n            var header = new ArrayBuffer(GLB_HEADER_BYTES);\n            var headerView = new DataView(header);\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n            headerView.setUint32(4, GLB_VERSION, true);\n            var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n            headerView.setUint32(8, totalByteLength, true);\n            var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n              type: 'application/octet-stream'\n            });\n            var glbReader = new window.FileReader();\n            glbReader.readAsArrayBuffer(glbBlob);\n\n            glbReader.onloadend = function () {\n              onDone(glbReader.result);\n            };\n          };\n        } else {\n          if (json.buffers && json.buffers.length > 0) {\n            var reader = new window.FileReader();\n            reader.readAsDataURL(blob);\n\n            reader.onloadend = function () {\n              var base64data = reader.result;\n              json.buffers[0].uri = base64data;\n              onDone(json);\n            };\n          } else {\n            onDone(json);\n          }\n        }\n      });\n    },\n\n    /**\n     * Serializes a userData.\n     *\n     * @param {THREE.Object3D|THREE.Material} object\n     * @param {Object} objectDef\n     */\n    serializeUserData: function serializeUserData(object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      var options = this.options;\n      var extensionsUsed = this.extensionsUsed;\n\n      try {\n        var json = JSON.parse(JSON.stringify(object.userData));\n\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n          for (var extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n\n          delete json.gltfExtensions;\n        }\n\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        console.warn(\"THREE.GLTFExporter: userData of '\".concat(object.name, \"' won't be serialized because of JSON.stringify error - \").concat(error.message));\n      }\n    },\n\n    /**\n     * Assign and return a temporal unique id for an object\n     * especially which doesn't have .uuid\n     * @param  {Object} object\n     * @return {Integer}\n     */\n    getUID: function getUID(object) {\n      if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n      return this.uids.get(object);\n    },\n\n    /**\n     * Checks if normal attribute values are normalized.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {Boolean}\n     */\n    isNormalizedNormalAttribute: function isNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      var v = new _three.Vector3();\n\n      for (var i = 0, il = normal.count; i < il; i++) {\n        // 0.0005 is from glTF-validator\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n      }\n\n      return true;\n    },\n\n    /**\n     * Creates normalized normal buffer attribute.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {BufferAttribute}\n     *\n     */\n    createNormalizedNormalAttribute: function createNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      var attribute = normal.clone();\n      var v = new _three.Vector3();\n\n      for (var i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          // if values can't be normalized set (1, 0, 0)\n          v.setX(1.0);\n        } else {\n          v.normalize();\n        }\n\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    },\n\n    /**\n     * Applies a texture transform, if present, to the map definition. Requires\n     * the KHR_texture_transform extension.\n     *\n     * @param {Object} mapDef\n     * @param {THREE.Texture} texture\n     */\n    applyTextureTransform: function applyTextureTransform(mapDef, texture) {\n      var didTransform = false;\n      var transformDef = {};\n\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions['KHR_texture_transform'] = transformDef;\n        this.extensionsUsed['KHR_texture_transform'] = true;\n      }\n    },\n\n    /**\n     * Process a buffer to append to the default one.\n     * @param  {ArrayBuffer} buffer\n     * @return {Integer}\n     */\n    processBuffer: function processBuffer(buffer) {\n      var json = this.json;\n      var buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }]; // All buffers are merged before export.\n\n      buffers.push(buffer);\n      return 0;\n    },\n\n    /**\n     * Process and generate a BufferView\n     * @param  {BufferAttribute} attribute\n     * @param  {number} componentType\n     * @param  {number} start\n     * @param  {number} count\n     * @param  {number} target (Optional) Target usage of the BufferView\n     * @return {Object}\n     */\n    processBufferView: function processBufferView(attribute, componentType, start, count, target) {\n      var json = this.json;\n      if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n      var componentSize;\n\n      if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n        componentSize = 1;\n      } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n        componentSize = 2;\n      } else {\n        componentSize = 4;\n      }\n\n      var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      var dataView = new DataView(new ArrayBuffer(byteLength));\n      var offset = 0;\n\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n\n          offset += componentSize;\n        }\n      }\n\n      var bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength: byteLength\n      };\n      if (target !== undefined) bufferViewDef.target = target;\n\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        // Only define byteStride for vertex attributes.\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n      var output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    },\n\n    /**\n     * Process and generate a BufferView from an image Blob.\n     * @param {Blob} blob\n     * @return {Promise<Integer>}\n     */\n    processBufferViewImage: function processBufferViewImage(blob) {\n      var writer = this;\n      var json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return new Promise(function (resolve) {\n        var reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n\n        reader.onloadend = function () {\n          var buffer = getPaddedArrayBuffer(reader.result);\n          var bufferViewDef = {\n            buffer: writer.processBuffer(buffer),\n            byteOffset: writer.byteOffset,\n            byteLength: buffer.byteLength\n          };\n          writer.byteOffset += buffer.byteLength;\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\n        };\n      });\n    },\n\n    /**\n     * Process attribute to generate an accessor\n     * @param  {BufferAttribute} attribute Attribute to process\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n     * @param  {Integer} start (Optional)\n     * @param  {Integer} count (Optional)\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n     */\n    processAccessor: function processAccessor(attribute, geometry, start, count) {\n      var options = this.options;\n      var json = this.json;\n      var types = {\n        1: 'SCALAR',\n        2: 'VEC2',\n        3: 'VEC3',\n        4: 'VEC4',\n        16: 'MAT4'\n      };\n      var componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n      }\n\n      if (start === undefined) start = 0;\n      if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n        var end = start + count;\n        var end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n        start = Math.max(start, geometry.drawRange.start);\n        count = Math.min(end, end2) - start;\n        if (count < 0) count = 0;\n      } // Skip creating an accessor if the attribute doesn't have data to export\n\n\n      if (count === 0) return null;\n      var minMax = getMinMax(attribute, start, count);\n      var bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n      // animation samplers, target must not be set.\n\n      if (geometry !== undefined) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n\n      var bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      var accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType: componentType,\n        count: count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized === true) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    },\n\n    /**\n     * Process image\n     * @param  {Image} image to process\n     * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\n     * @param  {Boolean} flipY before writing out the image\n     * @return {Integer}     Index of the processed texture in the \"images\" array\n     */\n    processImage: function processImage(image, format, flipY) {\n      var writer = this;\n      var cache = writer.cache;\n      var json = writer.json;\n      var options = writer.options;\n      var pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      var cachedImages = cache.images.get(image);\n      var mimeType = format === _three.RGBAFormat ? 'image/png' : 'image/jpeg';\n      var key = \"\".concat(mimeType, \":flipY/\").concat(flipY.toString());\n      if (cachedImages[key] !== undefined) return cachedImages[key];\n      if (!json.images) json.images = [];\n      var imageDef = {\n        mimeType: mimeType\n      };\n\n      if (options.embedImages) {\n        var canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        var ctx = canvas.getContext('2d');\n\n        if (flipY === true) {\n          ctx.translate(0, canvas.height);\n          ctx.scale(1, -1);\n        }\n\n        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        } else {\n          if (format !== _three.RGBAFormat && format !== _three.RGBFormat) {\n            console.error('GLTFExporter: Only RGB and RGBA formats are supported.');\n          }\n\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n          }\n\n          var data = image.data;\n\n          if (format === _three.RGBFormat) {\n            data = new Uint8ClampedArray(image.height * image.width * 4);\n\n            for (var i = 0, j = 0; i < data.length; i += 4, j += 3) {\n              data[i + 0] = image.data[j + 0];\n              data[i + 1] = image.data[j + 1];\n              data[i + 2] = image.data[j + 2];\n              data[i + 3] = 255;\n            }\n          }\n\n          ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        }\n\n        if (options.binary === true) {\n          pending.push(new Promise(function (resolve) {\n            canvas.toBlob(function (blob) {\n              writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\n                imageDef.bufferView = bufferViewIndex;\n                resolve();\n              });\n            }, mimeType);\n          }));\n        } else {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        }\n      } else {\n        imageDef.uri = image.src;\n      }\n\n      var index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    },\n\n    /**\n     * Process sampler\n     * @param  {Texture} map Texture to process\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\n     */\n    processSampler: function processSampler(map) {\n      var json = this.json;\n      if (!json.samplers) json.samplers = [];\n      var samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    },\n\n    /**\n     * Process texture\n     * @param  {Texture} map Map to process\n     * @return {Integer} Index of the processed texture in the \"textures\" array\n     */\n    processTexture: function processTexture(map) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      var textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY)\n      };\n      if (map.name) textureDef.name = map.name;\n\n      this._invokeAll(function (ext) {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n\n      var index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    },\n\n    /**\n     * Process material\n     * @param  {THREE.Material} material Material to process\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\n     */\n    processMaterial: function processMaterial(material) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n\n      if (material.isShaderMaterial) {\n        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n        return null;\n      }\n\n      if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n      var materialDef = {\n        pbrMetallicRoughness: {}\n      };\n\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n      } // pbrMetallicRoughness.baseColorFactor\n\n\n      var color = material.color.toArray().concat([material.opacity]);\n\n      if (!equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n\n      if (material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      } // pbrMetallicRoughness.metallicRoughnessTexture\n\n\n      if (material.metalnessMap || material.roughnessMap) {\n        if (material.metalnessMap === material.roughnessMap) {\n          var metalRoughMapDef = {\n            index: this.processTexture(material.metalnessMap)\n          };\n          this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n          materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n        } else {\n          console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n        }\n      } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n\n      if (material.map) {\n        var baseColorMapDef = {\n          index: this.processTexture(material.map)\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n\n      if (material.emissive) {\n        // emissiveFactor\n        var emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();\n\n        if (!equalArray(emissive, [0, 0, 0])) {\n          materialDef.emissiveFactor = emissive;\n        } // emissiveTexture\n\n\n        if (material.emissiveMap) {\n          var emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap)\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      } // normalTexture\n\n\n      if (material.normalMap) {\n        var normalMapDef = {\n          index: this.processTexture(material.normalMap)\n        };\n\n        if (material.normalScale && material.normalScale.x !== -1) {\n          if (material.normalScale.x !== material.normalScale.y) {\n            console.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');\n          }\n\n          normalMapDef.scale = material.normalScale.x;\n        }\n\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      } // occlusionTexture\n\n\n      if (material.aoMap) {\n        var occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: 1\n        };\n\n        if (material.aoMapIntensity !== 1.0) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      } // alphaMode\n\n\n      if (material.transparent) {\n        materialDef.alphaMode = 'BLEND';\n      } else {\n        if (material.alphaTest > 0.0) {\n          materialDef.alphaMode = 'MASK';\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      } // doubleSided\n\n\n      if (material.side === _three.DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== '') materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n\n      this._invokeAll(function (ext) {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n\n      var index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    },\n\n    /**\n     * Process mesh\n     * @param  {THREE.Mesh} mesh Mesh to process\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n     */\n    processMesh: function processMesh(mesh) {\n      var cache = this.cache;\n      var json = this.json;\n      var meshCacheKeyParts = [mesh.geometry.uuid];\n\n      if (Array.isArray(mesh.material)) {\n        for (var i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n\n      var meshCacheKey = meshCacheKeyParts.join(':');\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      var geometry = mesh.geometry;\n      var mode; // Use the correct mode\n\n      if (mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n\n      if (geometry.isBufferGeometry !== true) {\n        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      var meshDef = {};\n      var attributes = {};\n      var primitives = [];\n      var targets = []; // Conversion between attributes names in threejs and gltf spec\n\n      var nameConversion = {\n        uv: 'TEXCOORD_0',\n        uv2: 'TEXCOORD_1',\n        color: 'COLOR_0',\n        skinWeight: 'WEIGHTS_0',\n        skinIndex: 'JOINTS_0'\n      };\n      var originalNormal = geometry.getAttribute('normal');\n\n      if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n        geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n      } // @QUESTION Detect if .vertexColors = true?\n      // For every attribute create an accessor\n\n\n      var modifiedAttribute = null;\n\n      for (var attributeName in geometry.attributes) {\n        // Ignore morph target attributes, which are exported later.\n        if (attributeName.substr(0, 5) === 'morph') continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n        // listed in the spec; non-spec attributes are considered custom.\n\n        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = \"_\".concat(attributeName);\n\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n\n        modifiedAttribute = null;\n        var array = attribute.array;\n\n        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new _three.BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n\n        var accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n\n        if (accessor !== null) {\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n\n      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n      if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n        var weights = [];\n        var targetNames = [];\n        var reverseDictionary = {};\n\n        if (mesh.morphTargetDictionary !== undefined) {\n          for (var key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n\n        for (var _i = 0; _i < mesh.morphTargetInfluences.length; ++_i) {\n          var target = {};\n          var warned = false;\n\n          for (var _attributeName in geometry.morphAttributes) {\n            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n            // Three.js doesn't support TANGENT yet.\n            if (_attributeName !== 'position' && _attributeName !== 'normal') {\n              if (!warned) {\n                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n                warned = true;\n              }\n\n              continue;\n            }\n\n            var attribute = geometry.morphAttributes[_attributeName][_i];\n\n            var gltfAttributeName = _attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n            //\n            // glTF 2.0 Specification:\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\n            var baseAttribute = geometry.attributes[_attributeName];\n\n            if (cache.attributes.has(this.getUID(attribute))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\n              continue;\n            } // Clones attribute not to override\n\n\n            var relativeAttribute = attribute.clone();\n\n            if (!geometry.morphTargetsRelative) {\n              for (var j = 0, jl = attribute.count; j < jl; j++) {\n                relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n              }\n            }\n\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n            cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n          }\n\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[_i]);\n          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[_i]);\n        }\n\n        meshDef.weights = weights;\n\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n\n      var isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      var materials = isMultiMaterial ? mesh.material : [mesh.material];\n      var groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: undefined,\n        count: undefined\n      }];\n\n      for (var _i2 = 0, il = groups.length; _i2 < il; _i2++) {\n        var primitive = {\n          mode: mode,\n          attributes: attributes\n        };\n        this.serializeUserData(geometry, primitive);\n        if (targets.length > 0) primitive.targets = targets;\n\n        if (geometry.index !== null) {\n          var cacheKey = this.getUID(geometry.index);\n\n          if (groups[_i2].start !== undefined || groups[_i2].count !== undefined) {\n            cacheKey += \":\".concat(groups[_i2].start, \":\").concat(groups[_i2].count);\n          }\n\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[_i2].start, groups[_i2].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n\n          if (primitive.indices === null) delete primitive.indices;\n        }\n\n        var material = this.processMaterial(materials[groups[_i2].materialIndex]);\n        if (material !== null) primitive.material = material;\n        primitives.push(primitive);\n      }\n\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n\n      this._invokeAll(function (ext) {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n\n      var index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    },\n\n    /**\n     * Process camera\n     * @param  {THREE.Camera} camera Camera to process\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\n     */\n    processCamera: function processCamera(camera) {\n      var json = this.json;\n      if (!json.cameras) json.cameras = [];\n      var isOrtho = camera.isOrthographicCamera;\n      var cameraDef = {\n        type: isOrtho ? 'orthographic' : 'perspective'\n      };\n\n      if (isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: _three.MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } // Question: Is saving \"type\" as name intentional?\n\n\n      if (camera.name !== '') cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    },\n\n    /**\n     * Creates glTF animation entry from AnimationClip object.\n     *\n     * Status:\n     * - Only properties listed in PATH_PROPERTIES may be animated.\n     *\n     * @param {THREE.AnimationClip} clip\n     * @param {THREE.Object3D} root\n     * @return {number|null}\n     */\n    processAnimation: function processAnimation(clip, root) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      var tracks = clip.tracks;\n      var channels = [];\n      var samplers = [];\n\n      for (var i = 0; i < tracks.length; ++i) {\n        var track = tracks[i];\n\n        var trackBinding = _three.PropertyBinding.parseTrackName(track.name);\n\n        var trackNode = _three.PropertyBinding.findNode(root, trackBinding.nodeName);\n\n        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n        if (trackBinding.objectName === 'bones') {\n          if (trackNode.isSkinnedMesh === true) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = undefined;\n          }\n        }\n\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n\n        var inputItemSize = 1;\n        var outputItemSize = track.values.length / track.times.length;\n\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n\n        var interpolation = void 0; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n        // Detecting glTF cubic spline interpolant by checking factory method's special property\n        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n        // valid value from .getInterpolation().\n\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n          interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n          // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n          // but needs to be stored as VEC3 so dividing by 3 here.\n\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === _three.InterpolateDiscrete) {\n          interpolation = 'STEP';\n        } else {\n          interpolation = 'LINEAR';\n        }\n\n        samplers.push({\n          input: this.processAccessor(new _three.BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new _three.BufferAttribute(track.values, outputItemSize)),\n          interpolation: interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n\n      json.animations.push({\n        name: clip.name || \"clip_\".concat(json.animations.length),\n        samplers: samplers,\n        channels: channels\n      });\n      return json.animations.length - 1;\n    },\n\n    /**\n     * @param {THREE.Object3D} object\n     * @return {number|null}\n     */\n    processSkin: function processSkin(object) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      var node = json.nodes[nodeMap.get(object)];\n      var skeleton = object.skeleton;\n      if (skeleton === undefined) return null;\n      var rootJoint = object.skeleton.bones[0];\n      if (rootJoint === undefined) return null;\n      var joints = [];\n      var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      var temporaryBoneInverse = new _three.Matrix4();\n\n      for (var i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n\n      if (json.skins === undefined) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new _three.BufferAttribute(inverseBindMatrices, 16)),\n        joints: joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      var skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    },\n\n    /**\n     * Process Object3D node\n     * @param  {THREE.Object3D} node Object3D to processNode\n     * @return {Integer} Index of the node in the nodes list\n     */\n    processNode: function processNode(object) {\n      var json = this.json;\n      var options = this.options;\n      var nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      var nodeDef = {};\n\n      if (options.trs) {\n        var rotation = object.quaternion.toArray();\n        var position = object.position.toArray();\n        var scale = object.scale.toArray();\n\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n\n        if (!equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n\n        if (!equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n\n        if (isIdentityMatrix(object.matrix) === false) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      } // We don't export empty strings name because it represents no-name in Three.js.\n\n\n      if (object.name !== '') nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n\n      if (object.isMesh || object.isLine || object.isPoints) {\n        var meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n\n      if (object.isSkinnedMesh) this.skins.push(object);\n\n      if (object.children.length > 0) {\n        var children = [];\n\n        for (var i = 0, l = object.children.length; i < l; i++) {\n          var child = object.children[i];\n\n          if (child.visible || options.onlyVisible === false) {\n            var nodeIndex = this.processNode(child);\n            if (nodeIndex !== null) children.push(nodeIndex);\n          }\n        }\n\n        if (children.length > 0) nodeDef.children = children;\n      }\n\n      this._invokeAll(function (ext) {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    },\n\n    /**\n     * Process Scene\n     * @param  {Scene} node Scene to process\n     */\n    processScene: function processScene(scene) {\n      var json = this.json;\n      var options = this.options;\n\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n\n      var sceneDef = {};\n      if (scene.name !== '') sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      var nodes = [];\n\n      for (var i = 0, l = scene.children.length; i < l; i++) {\n        var child = scene.children[i];\n\n        if (child.visible || options.onlyVisible === false) {\n          var nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    },\n\n    /**\n     * Creates a Scene to hold a list of objects and parse it\n     * @param  {Array} objects List of objects to process\n     */\n    processObjects: function processObjects(objects) {\n      var scene = new _three.Scene();\n      scene.name = 'AuxScene';\n\n      for (var i = 0; i < objects.length; i++) {\n        // We push directly to children instead of calling `add` to prevent\n        // modify the .parent and break its original scene and hierarchy\n        scene.children.push(objects[i]);\n      }\n\n      this.processScene(scene);\n    },\n\n    /**\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\n     */\n    processInput: function processInput(input) {\n      var options = this.options;\n      input = input instanceof Array ? input : [input];\n\n      this._invokeAll(function (ext) {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n\n      var objectsWithoutScene = [];\n\n      for (var i = 0; i < input.length; i++) {\n        if (input[i] instanceof _three.Scene) {\n          this.processScene(input[i]);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n      for (var _i3 = 0; _i3 < this.skins.length; ++_i3) {\n        this.processSkin(this.skins[_i3]);\n      }\n\n      for (var _i4 = 0; _i4 < options.animations.length; ++_i4) {\n        this.processAnimation(options.animations[_i4], input[0]);\n      }\n\n      this._invokeAll(function (ext) {\n        ext.afterParse && ext.afterParse(input);\n      });\n    },\n    _invokeAll: function _invokeAll(func) {\n      for (var i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    }\n  };\n  /**\n   * Punctual Lights Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n   */\n\n  function GLTFLightExtension(writer) {\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  GLTFLightExtension.prototype = {\n    constructor: GLTFLightExtension,\n    writeNode: function writeNode(light, nodeDef) {\n      if (!light.isLight) return;\n\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n        return;\n      }\n\n      var writer = this.writer;\n      var json = writer.json;\n      var extensionsUsed = writer.extensionsUsed;\n      var lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n\n      if (light.isDirectionalLight) {\n        lightDef.type = 'directional';\n      } else if (light.isPointLight) {\n        lightDef.type = 'point';\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light.isSpotLight) {\n        lightDef.type = 'spot';\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n\n      if (light.decay !== undefined && light.decay !== 2) {\n        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n      }\n\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n      }\n\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n\n      var lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  };\n  /**\n   * Unlit Materials Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n   */\n\n  function GLTFMaterialsUnlitExtension(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  GLTFMaterialsUnlitExtension.prototype = {\n    constructor: GLTFMaterialsUnlitExtension,\n    writeMaterial: function writeMaterial(material, materialDef) {\n      if (!material.isMeshBasicMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  };\n  /**\n   * Specular-Glossiness Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n   */\n\n  function GLTFMaterialsPBRSpecularGlossiness(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  GLTFMaterialsPBRSpecularGlossiness.prototype = {\n    constructor: GLTFMaterialsPBRSpecularGlossiness,\n    writeMaterial: function writeMaterial(material, materialDef) {\n      if (!material.isGLTFSpecularGlossinessMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n\n      if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n        extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n      }\n\n      var specularFactor = [1, 1, 1];\n      material.specular.toArray(specularFactor, 0);\n      extensionDef.specularFactor = specularFactor;\n      extensionDef.glossinessFactor = material.glossiness;\n\n      if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n        extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n      }\n\n      if (material.specularMap) {\n        var specularMapDef = {\n          index: writer.processTexture(material.specularMap)\n        };\n        writer.applyTextureTransform(specularMapDef, material.specularMap);\n        extensionDef.specularGlossinessTexture = specularMapDef;\n      }\n\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  };\n  /**\n   * Static utility functions\n   */\n\n  GLTFExporter.Utils = {\n    insertKeyframe: function insertKeyframe(track, time) {\n      var tolerance = 0.001; // 1ms\n\n      var valueSize = track.getValueSize();\n      var times = new track.TimeBufferType(track.times.length + 1);\n      var values = new track.ValueBufferType(track.values.length + valueSize);\n      var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n      var index;\n\n      if (track.times.length === 0) {\n        times[0] = time;\n\n        for (var i = 0; i < valueSize; i++) {\n          values[i] = 0;\n        }\n\n        index = 0;\n      } else if (time < track.times[0]) {\n        if (Math.abs(track.times[0] - time) < tolerance) return 0;\n        times[0] = time;\n        times.set(track.times, 1);\n        values.set(interpolant.evaluate(time), 0);\n        values.set(track.values, valueSize);\n        index = 0;\n      } else if (time > track.times[track.times.length - 1]) {\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n          return track.times.length - 1;\n        }\n\n        times[times.length - 1] = time;\n        times.set(track.times, 0);\n        values.set(track.values, 0);\n        values.set(interpolant.evaluate(time), track.values.length);\n        index = times.length - 1;\n      } else {\n        for (var _i5 = 0; _i5 < track.times.length; _i5++) {\n          if (Math.abs(track.times[_i5] - time) < tolerance) return _i5;\n\n          if (track.times[_i5] < time && track.times[_i5 + 1] > time) {\n            times.set(track.times.slice(0, _i5 + 1), 0);\n            times[_i5 + 1] = time;\n            times.set(track.times.slice(_i5 + 1), _i5 + 2);\n            values.set(track.values.slice(0, (_i5 + 1) * valueSize), 0);\n            values.set(interpolant.evaluate(time), (_i5 + 1) * valueSize);\n            values.set(track.values.slice((_i5 + 1) * valueSize), (_i5 + 2) * valueSize);\n            index = _i5 + 1;\n            break;\n          }\n        }\n      }\n\n      track.times = times;\n      track.values = values;\n      return index;\n    },\n    mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {\n      var tracks = [];\n      var mergedTracks = {};\n      var sourceTracks = clip.tracks;\n\n      for (var i = 0; i < sourceTracks.length; ++i) {\n        var sourceTrack = sourceTracks[i];\n\n        var sourceTrackBinding = _three.PropertyBinding.parseTrackName(sourceTrack.name);\n\n        var sourceTrackNode = _three.PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n        if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n          // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n          tracks.push(sourceTrack);\n          continue;\n        }\n\n        if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n            // This should never happen, because glTF morph target animations\n            // affect all targets already.\n            throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n          }\n\n          console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n          sourceTrack = sourceTrack.clone();\n          sourceTrack.setInterpolation(_three.InterpolateLinear);\n        }\n\n        var targetCount = sourceTrackNode.morphTargetInfluences.length;\n        var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n        if (targetIndex === undefined) {\n          throw new Error(\"THREE.GLTFExporter: Morph target name not found: \".concat(sourceTrackBinding.propertyIndex));\n        }\n\n        var mergedTrack = void 0; // If this is the first time we've seen this object, create a new\n        // track to store merged keyframe data for each morph target.\n\n        if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n          mergedTrack = sourceTrack.clone();\n          var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n          for (var j = 0; j < mergedTrack.times.length; j++) {\n            values[j * targetCount + targetIndex] = mergedTrack.values[j];\n          } // We need to take into consideration the intended target node\n          // of our original un-merged morphTarget animation.\n\n\n          mergedTrack.name = \"\".concat(sourceTrackBinding.nodeName || '', \".morphTargetInfluences\");\n          mergedTrack.values = values;\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n          tracks.push(mergedTrack);\n          continue;\n        }\n\n        var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n        mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n        // interpolated) value from the source track.\n\n        for (var _j = 0; _j < mergedTrack.times.length; _j++) {\n          mergedTrack.values[_j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[_j]);\n        } // For every existing keyframe of the source track, write a (possibly\n        // new) keyframe to the merged track. Values from the previous loop may\n        // be written again, but keyframes are de-duplicated.\n\n\n        for (var _j2 = 0; _j2 < sourceTrack.times.length; _j2++) {\n          var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[_j2]);\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[_j2];\n        }\n      }\n\n      clip.tracks = tracks;\n      return clip;\n    }\n  };\n  return GLTFExporter;\n}();\n\nexports.GLTFExporter = GLTFExporter;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["baseColorTexture","json","skin","extensions","includeCustomExtensions","intensity","weights","bufferView","range","wrapS","light","processSampler","pluginCallbacks","trs","values","processCamera","byteOffset","min","morphTargetInfluences","processBuffer","width","samplers","texCoord","specularFactor","processAnimation","output","processScene","unregister","orthographic","serializeUserData","index","diffuseTexture","processAccessor","onlyVisible","quaternion","offset","uv2","primitives","byteLength","prototype","height","spot","scale","byteStride","skins","aspectRatio","lights","emissiveFactor","processBufferView","maxTextureSize","isNormalizedNormalAttribute","pbrMetallicRoughness","matrix","children","skeleton","uri","__esModule","binary","writeNode","max","path","alphaCutoff","scenes","doubleSided","asset","id","processImage","applyTextureTransform","camera","embedImages","extras","uid","outerConeAngle","count","materials","processNode","baseColorFactor","createNormalizedNormalAttribute","GLTFExporter","insertKeyframe","specularGlossinessTexture","writeMaterial","extensionsUsed","cache","mode","_invokeAll","processTexture","buffer","xmag","times","position","processInput","processMaterial","name","value","roughnessFactor","materialIndex","metallicFactor","tracks","truncateDrawRange","emissiveTexture","start","magFilter","processMesh","uids","skinWeight","targets","yfov","innerConeAngle","rotation","register","componentType","glossinessFactor","input","writer","nodes","animations","uv","targetNames","attributes","processSkin","images","mesh","normalized","occlusionTexture","source","type","Utils","textures","wrapT","zfar","processBufferViewImage","nodeMap","onloadend","znear","version","target","cameras","normalTexture","attributesNormalized","perspective","joints","accessors","parse","generator","meshes","setPlugins","ymag","mimeType","minFilter","pending","options","write","processObjects","sampler","alphaMode","interpolation","color","buffers","plugins","mergeMorphTargetTracks","metallicRoughnessTexture","getUID","strength","bufferViews","translation","inverseBindMatrices","node","diffuseFactor","constructor","scene","indices","channels","skinIndex","material"]],"~:compiled-at",1630917515284,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$exporters$GLTFExporter.js\",\n\"lineCount\":68,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/exporters/GLTFExporter.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$exporters$GLTFExporter\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.GLTFExporter = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar GLTFExporter = function () {\\n  function GLTFExporter() {\\n    this.pluginCallbacks = [];\\n    this.register(function (writer) {\\n      return new GLTFLightExtension(writer);\\n    });\\n    this.register(function (writer) {\\n      return new GLTFMaterialsUnlitExtension(writer);\\n    });\\n    this.register(function (writer) {\\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\\n    });\\n  }\\n\\n  GLTFExporter.prototype = {\\n    constructor: GLTFExporter,\\n    register: function register(callback) {\\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\\n        this.pluginCallbacks.push(callback);\\n      }\\n\\n      return this;\\n    },\\n    unregister: function unregister(callback) {\\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Parse scenes and generate GLTF output\\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\\n     * @param  {Function} onDone  Callback on completed\\n     * @param  {Object} options options\\n     */\\n    parse: function parse(input, onDone, options) {\\n      var writer = new GLTFWriter();\\n      var plugins = [];\\n\\n      for (var i = 0, il = this.pluginCallbacks.length; i < il; i++) {\\n        plugins.push(this.pluginCallbacks[i](writer));\\n      }\\n\\n      writer.setPlugins(plugins);\\n      writer.write(input, onDone, options);\\n    }\\n  }; //------------------------------------------------------------------------------\\n  // Constants\\n  //------------------------------------------------------------------------------\\n\\n  var WEBGL_CONSTANTS = {\\n    POINTS: 0x0000,\\n    LINES: 0x0001,\\n    LINE_LOOP: 0x0002,\\n    LINE_STRIP: 0x0003,\\n    TRIANGLES: 0x0004,\\n    TRIANGLE_STRIP: 0x0005,\\n    TRIANGLE_FAN: 0x0006,\\n    UNSIGNED_BYTE: 0x1401,\\n    UNSIGNED_SHORT: 0x1403,\\n    FLOAT: 0x1406,\\n    UNSIGNED_INT: 0x1405,\\n    ARRAY_BUFFER: 0x8892,\\n    ELEMENT_ARRAY_BUFFER: 0x8893,\\n    NEAREST: 0x2600,\\n    LINEAR: 0x2601,\\n    NEAREST_MIPMAP_NEAREST: 0x2700,\\n    LINEAR_MIPMAP_NEAREST: 0x2701,\\n    NEAREST_MIPMAP_LINEAR: 0x2702,\\n    LINEAR_MIPMAP_LINEAR: 0x2703,\\n    CLAMP_TO_EDGE: 33071,\\n    MIRRORED_REPEAT: 33648,\\n    REPEAT: 10497\\n  };\\n  var THREE_TO_WEBGL = {};\\n  THREE_TO_WEBGL[_three.NearestFilter] = WEBGL_CONSTANTS.NEAREST;\\n  THREE_TO_WEBGL[_three.NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\\n  THREE_TO_WEBGL[_three.NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\\n  THREE_TO_WEBGL[_three.LinearFilter] = WEBGL_CONSTANTS.LINEAR;\\n  THREE_TO_WEBGL[_three.LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\\n  THREE_TO_WEBGL[_three.LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\\n  THREE_TO_WEBGL[_three.ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\\n  THREE_TO_WEBGL[_three.RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\\n  THREE_TO_WEBGL[_three.MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\\n  var PATH_PROPERTIES = {\\n    scale: 'scale',\\n    position: 'translation',\\n    quaternion: 'rotation',\\n    morphTargetInfluences: 'weights'\\n  }; // GLB constants\\n  // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\\n\\n  var GLB_HEADER_BYTES = 12;\\n  var GLB_HEADER_MAGIC = 0x46546c67;\\n  var GLB_VERSION = 2;\\n  var GLB_CHUNK_PREFIX_BYTES = 8;\\n  var GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\\n  var GLB_CHUNK_TYPE_BIN = 0x004e4942; //------------------------------------------------------------------------------\\n  // Utility functions\\n  //------------------------------------------------------------------------------\\n\\n  /**\\n   * Compare two arrays\\n   * @param  {Array} array1 Array 1 to compare\\n   * @param  {Array} array2 Array 2 to compare\\n   * @return {Boolean}        Returns true if both arrays are equal\\n   */\\n\\n  function equalArray(array1, array2) {\\n    return array1.length === array2.length && array1.every(function (element, index) {\\n      return element === array2[index];\\n    });\\n  }\\n  /**\\n   * Converts a string to an ArrayBuffer.\\n   * @param  {string} text\\n   * @return {ArrayBuffer}\\n   */\\n\\n\\n  function stringToArrayBuffer(text) {\\n    if (window.TextEncoder !== undefined) {\\n      return new TextEncoder().encode(text).buffer;\\n    }\\n\\n    var array = new Uint8Array(new ArrayBuffer(text.length));\\n\\n    for (var i = 0, il = text.length; i < il; i++) {\\n      var value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\\n\\n      array[i] = value > 0xff ? 0x20 : value;\\n    }\\n\\n    return array.buffer;\\n  }\\n  /**\\n   * Is identity matrix\\n   *\\n   * @param {Matrix4} matrix\\n   * @returns {Boolean} Returns true, if parameter is identity matrix\\n   */\\n\\n\\n  function isIdentityMatrix(matrix) {\\n    return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\\n  }\\n  /**\\n   * Get the min and max vectors from the given attribute\\n   * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\\n   * @param  {Integer} start\\n   * @param  {Integer} count\\n   * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\\n   */\\n\\n\\n  function getMinMax(attribute, start, count) {\\n    var output = {\\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\\n    };\\n\\n    for (var i = start; i < start + count; i++) {\\n      for (var a = 0; a < attribute.itemSize; a++) {\\n        var value = void 0;\\n\\n        if (attribute.itemSize > 4) {\\n          // no support for interleaved data for itemSize > 4\\n          value = attribute.array[i * attribute.itemSize + a];\\n        } else {\\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\\n        }\\n\\n        output.min[a] = Math.min(output.min[a], value);\\n        output.max[a] = Math.max(output.max[a], value);\\n      }\\n    }\\n\\n    return output;\\n  }\\n  /**\\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\\n   *\\n   * @param {Integer} bufferSize The size the original buffer.\\n   * @returns {Integer} new buffer size with required padding.\\n   *\\n   */\\n\\n\\n  function getPaddedBufferSize(bufferSize) {\\n    return Math.ceil(bufferSize / 4) * 4;\\n  }\\n  /**\\n   * Returns a buffer aligned to 4-byte boundary.\\n   *\\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\\n   * @param {Integer} paddingByte (Optional)\\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\\n   */\\n\\n\\n  function getPaddedArrayBuffer(arrayBuffer, paddingByte) {\\n    paddingByte = paddingByte || 0;\\n    var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\\n\\n    if (paddedLength !== arrayBuffer.byteLength) {\\n      var array = new Uint8Array(paddedLength);\\n      array.set(new Uint8Array(arrayBuffer));\\n\\n      if (paddingByte !== 0) {\\n        for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\\n          array[i] = paddingByte;\\n        }\\n      }\\n\\n      return array.buffer;\\n    }\\n\\n    return arrayBuffer;\\n  }\\n\\n  var cachedCanvas = null;\\n  /**\\n   * Writer\\n   */\\n\\n  function GLTFWriter() {\\n    this.plugins = [];\\n    this.options = {};\\n    this.pending = [];\\n    this.buffers = [];\\n    this.byteOffset = 0;\\n    this.buffers = [];\\n    this.nodeMap = new Map();\\n    this.skins = [];\\n    this.extensionsUsed = {};\\n    this.uids = new Map();\\n    this.uid = 0;\\n    this.json = {\\n      asset: {\\n        version: '2.0',\\n        generator: 'THREE.GLTFExporter'\\n      }\\n    };\\n    this.cache = {\\n      meshes: new Map(),\\n      attributes: new Map(),\\n      attributesNormalized: new Map(),\\n      materials: new Map(),\\n      textures: new Map(),\\n      images: new Map()\\n    };\\n  }\\n\\n  GLTFWriter.prototype = {\\n    constructor: GLTFWriter,\\n    setPlugins: function setPlugins(plugins) {\\n      this.plugins = plugins;\\n    },\\n\\n    /**\\n     * Parse scenes and generate GLTF output\\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\\n     * @param  {Function} onDone  Callback on completed\\n     * @param  {Object} options options\\n     */\\n    write: function write(input, onDone, options) {\\n      this.options = Object.assign({}, {\\n        // default options\\n        binary: false,\\n        trs: false,\\n        onlyVisible: true,\\n        truncateDrawRange: true,\\n        embedImages: true,\\n        maxTextureSize: Infinity,\\n        animations: [],\\n        includeCustomExtensions: false\\n      }, options);\\n\\n      if (this.options.animations.length > 0) {\\n        // Only TRS properties, and not matrices, may be targeted by animation.\\n        this.options.trs = true;\\n      }\\n\\n      this.processInput(input);\\n      var writer = this;\\n      Promise.all(this.pending).then(function () {\\n        var buffers = writer.buffers;\\n        var json = writer.json;\\n        var options = writer.options;\\n        var extensionsUsed = writer.extensionsUsed; // Merge buffers.\\n\\n        var blob = new Blob(buffers, {\\n          type: 'application/octet-stream'\\n        }); // Declare extensions.\\n\\n        var extensionsUsedList = Object.keys(extensionsUsed);\\n        if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\\n\\n        if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\\n\\n        if (options.binary === true) {\\n          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\\n          var reader = new window.FileReader();\\n          reader.readAsArrayBuffer(blob);\\n\\n          reader.onloadend = function () {\\n            // Binary chunk.\\n            var binaryChunk = getPaddedArrayBuffer(reader.result);\\n            var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\\n\\n            var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\\n            var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\\n\\n            var header = new ArrayBuffer(GLB_HEADER_BYTES);\\n            var headerView = new DataView(header);\\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\\n            headerView.setUint32(4, GLB_VERSION, true);\\n            var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\\n            headerView.setUint32(8, totalByteLength, true);\\n            var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\\n              type: 'application/octet-stream'\\n            });\\n            var glbReader = new window.FileReader();\\n            glbReader.readAsArrayBuffer(glbBlob);\\n\\n            glbReader.onloadend = function () {\\n              onDone(glbReader.result);\\n            };\\n          };\\n        } else {\\n          if (json.buffers && json.buffers.length > 0) {\\n            var reader = new window.FileReader();\\n            reader.readAsDataURL(blob);\\n\\n            reader.onloadend = function () {\\n              var base64data = reader.result;\\n              json.buffers[0].uri = base64data;\\n              onDone(json);\\n            };\\n          } else {\\n            onDone(json);\\n          }\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Serializes a userData.\\n     *\\n     * @param {THREE.Object3D|THREE.Material} object\\n     * @param {Object} objectDef\\n     */\\n    serializeUserData: function serializeUserData(object, objectDef) {\\n      if (Object.keys(object.userData).length === 0) return;\\n      var options = this.options;\\n      var extensionsUsed = this.extensionsUsed;\\n\\n      try {\\n        var json = JSON.parse(JSON.stringify(object.userData));\\n\\n        if (options.includeCustomExtensions && json.gltfExtensions) {\\n          if (objectDef.extensions === undefined) objectDef.extensions = {};\\n\\n          for (var extensionName in json.gltfExtensions) {\\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\\n            extensionsUsed[extensionName] = true;\\n          }\\n\\n          delete json.gltfExtensions;\\n        }\\n\\n        if (Object.keys(json).length > 0) objectDef.extras = json;\\n      } catch (error) {\\n        console.warn(\\\"THREE.GLTFExporter: userData of '\\\".concat(object.name, \\\"' won't be serialized because of JSON.stringify error - \\\").concat(error.message));\\n      }\\n    },\\n\\n    /**\\n     * Assign and return a temporal unique id for an object\\n     * especially which doesn't have .uuid\\n     * @param  {Object} object\\n     * @return {Integer}\\n     */\\n    getUID: function getUID(object) {\\n      if (!this.uids.has(object)) this.uids.set(object, this.uid++);\\n      return this.uids.get(object);\\n    },\\n\\n    /**\\n     * Checks if normal attribute values are normalized.\\n     *\\n     * @param {BufferAttribute} normal\\n     * @returns {Boolean}\\n     */\\n    isNormalizedNormalAttribute: function isNormalizedNormalAttribute(normal) {\\n      var cache = this.cache;\\n      if (cache.attributesNormalized.has(normal)) return false;\\n      var v = new _three.Vector3();\\n\\n      for (var i = 0, il = normal.count; i < il; i++) {\\n        // 0.0005 is from glTF-validator\\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\\n      }\\n\\n      return true;\\n    },\\n\\n    /**\\n     * Creates normalized normal buffer attribute.\\n     *\\n     * @param {BufferAttribute} normal\\n     * @returns {BufferAttribute}\\n     *\\n     */\\n    createNormalizedNormalAttribute: function createNormalizedNormalAttribute(normal) {\\n      var cache = this.cache;\\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\\n      var attribute = normal.clone();\\n      var v = new _three.Vector3();\\n\\n      for (var i = 0, il = attribute.count; i < il; i++) {\\n        v.fromBufferAttribute(attribute, i);\\n\\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\\n          // if values can't be normalized set (1, 0, 0)\\n          v.setX(1.0);\\n        } else {\\n          v.normalize();\\n        }\\n\\n        attribute.setXYZ(i, v.x, v.y, v.z);\\n      }\\n\\n      cache.attributesNormalized.set(normal, attribute);\\n      return attribute;\\n    },\\n\\n    /**\\n     * Applies a texture transform, if present, to the map definition. Requires\\n     * the KHR_texture_transform extension.\\n     *\\n     * @param {Object} mapDef\\n     * @param {THREE.Texture} texture\\n     */\\n    applyTextureTransform: function applyTextureTransform(mapDef, texture) {\\n      var didTransform = false;\\n      var transformDef = {};\\n\\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\\n        transformDef.offset = texture.offset.toArray();\\n        didTransform = true;\\n      }\\n\\n      if (texture.rotation !== 0) {\\n        transformDef.rotation = texture.rotation;\\n        didTransform = true;\\n      }\\n\\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\\n        transformDef.scale = texture.repeat.toArray();\\n        didTransform = true;\\n      }\\n\\n      if (didTransform) {\\n        mapDef.extensions = mapDef.extensions || {};\\n        mapDef.extensions['KHR_texture_transform'] = transformDef;\\n        this.extensionsUsed['KHR_texture_transform'] = true;\\n      }\\n    },\\n\\n    /**\\n     * Process a buffer to append to the default one.\\n     * @param  {ArrayBuffer} buffer\\n     * @return {Integer}\\n     */\\n    processBuffer: function processBuffer(buffer) {\\n      var json = this.json;\\n      var buffers = this.buffers;\\n      if (!json.buffers) json.buffers = [{\\n        byteLength: 0\\n      }]; // All buffers are merged before export.\\n\\n      buffers.push(buffer);\\n      return 0;\\n    },\\n\\n    /**\\n     * Process and generate a BufferView\\n     * @param  {BufferAttribute} attribute\\n     * @param  {number} componentType\\n     * @param  {number} start\\n     * @param  {number} count\\n     * @param  {number} target (Optional) Target usage of the BufferView\\n     * @return {Object}\\n     */\\n    processBufferView: function processBufferView(attribute, componentType, start, count, target) {\\n      var json = this.json;\\n      if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\\n\\n      var componentSize;\\n\\n      if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\\n        componentSize = 1;\\n      } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\\n        componentSize = 2;\\n      } else {\\n        componentSize = 4;\\n      }\\n\\n      var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\\n      var dataView = new DataView(new ArrayBuffer(byteLength));\\n      var offset = 0;\\n\\n      for (var i = start; i < start + count; i++) {\\n        for (var a = 0; a < attribute.itemSize; a++) {\\n          var value = void 0;\\n\\n          if (attribute.itemSize > 4) {\\n            // no support for interleaved data for itemSize > 4\\n            value = attribute.array[i * attribute.itemSize + a];\\n          } else {\\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\\n          }\\n\\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\\n            dataView.setFloat32(offset, value, true);\\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\\n            dataView.setUint32(offset, value, true);\\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\\n            dataView.setUint16(offset, value, true);\\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\\n            dataView.setUint8(offset, value);\\n          }\\n\\n          offset += componentSize;\\n        }\\n      }\\n\\n      var bufferViewDef = {\\n        buffer: this.processBuffer(dataView.buffer),\\n        byteOffset: this.byteOffset,\\n        byteLength: byteLength\\n      };\\n      if (target !== undefined) bufferViewDef.target = target;\\n\\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\\n        // Only define byteStride for vertex attributes.\\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\\n      }\\n\\n      this.byteOffset += byteLength;\\n      json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\\n\\n      var output = {\\n        id: json.bufferViews.length - 1,\\n        byteLength: 0\\n      };\\n      return output;\\n    },\\n\\n    /**\\n     * Process and generate a BufferView from an image Blob.\\n     * @param {Blob} blob\\n     * @return {Promise<Integer>}\\n     */\\n    processBufferViewImage: function processBufferViewImage(blob) {\\n      var writer = this;\\n      var json = writer.json;\\n      if (!json.bufferViews) json.bufferViews = [];\\n      return new Promise(function (resolve) {\\n        var reader = new window.FileReader();\\n        reader.readAsArrayBuffer(blob);\\n\\n        reader.onloadend = function () {\\n          var buffer = getPaddedArrayBuffer(reader.result);\\n          var bufferViewDef = {\\n            buffer: writer.processBuffer(buffer),\\n            byteOffset: writer.byteOffset,\\n            byteLength: buffer.byteLength\\n          };\\n          writer.byteOffset += buffer.byteLength;\\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\\n        };\\n      });\\n    },\\n\\n    /**\\n     * Process attribute to generate an accessor\\n     * @param  {BufferAttribute} attribute Attribute to process\\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\\n     * @param  {Integer} start (Optional)\\n     * @param  {Integer} count (Optional)\\n     * @return {Integer|null} Index of the processed accessor on the \\\"accessors\\\" array\\n     */\\n    processAccessor: function processAccessor(attribute, geometry, start, count) {\\n      var options = this.options;\\n      var json = this.json;\\n      var types = {\\n        1: 'SCALAR',\\n        2: 'VEC2',\\n        3: 'VEC3',\\n        4: 'VEC4',\\n        16: 'MAT4'\\n      };\\n      var componentType; // Detect the component type of the attribute array (float, uint or ushort)\\n\\n      if (attribute.array.constructor === Float32Array) {\\n        componentType = WEBGL_CONSTANTS.FLOAT;\\n      } else if (attribute.array.constructor === Uint32Array) {\\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\\n      } else if (attribute.array.constructor === Uint16Array) {\\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\\n      } else if (attribute.array.constructor === Uint8Array) {\\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\\n      } else {\\n        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\\n      }\\n\\n      if (start === undefined) start = 0;\\n      if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\\n\\n      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\\n        var end = start + count;\\n        var end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\\n        start = Math.max(start, geometry.drawRange.start);\\n        count = Math.min(end, end2) - start;\\n        if (count < 0) count = 0;\\n      } // Skip creating an accessor if the attribute doesn't have data to export\\n\\n\\n      if (count === 0) return null;\\n      var minMax = getMinMax(attribute, start, count);\\n      var bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\\n      // animation samplers, target must not be set.\\n\\n      if (geometry !== undefined) {\\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\\n      }\\n\\n      var bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\\n      var accessorDef = {\\n        bufferView: bufferView.id,\\n        byteOffset: bufferView.byteOffset,\\n        componentType: componentType,\\n        count: count,\\n        max: minMax.max,\\n        min: minMax.min,\\n        type: types[attribute.itemSize]\\n      };\\n      if (attribute.normalized === true) accessorDef.normalized = true;\\n      if (!json.accessors) json.accessors = [];\\n      return json.accessors.push(accessorDef) - 1;\\n    },\\n\\n    /**\\n     * Process image\\n     * @param  {Image} image to process\\n     * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\\n     * @param  {Boolean} flipY before writing out the image\\n     * @return {Integer}     Index of the processed texture in the \\\"images\\\" array\\n     */\\n    processImage: function processImage(image, format, flipY) {\\n      var writer = this;\\n      var cache = writer.cache;\\n      var json = writer.json;\\n      var options = writer.options;\\n      var pending = writer.pending;\\n      if (!cache.images.has(image)) cache.images.set(image, {});\\n      var cachedImages = cache.images.get(image);\\n      var mimeType = format === _three.RGBAFormat ? 'image/png' : 'image/jpeg';\\n      var key = \\\"\\\".concat(mimeType, \\\":flipY/\\\").concat(flipY.toString());\\n      if (cachedImages[key] !== undefined) return cachedImages[key];\\n      if (!json.images) json.images = [];\\n      var imageDef = {\\n        mimeType: mimeType\\n      };\\n\\n      if (options.embedImages) {\\n        var canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\\n        canvas.width = Math.min(image.width, options.maxTextureSize);\\n        canvas.height = Math.min(image.height, options.maxTextureSize);\\n        var ctx = canvas.getContext('2d');\\n\\n        if (flipY === true) {\\n          ctx.translate(0, canvas.height);\\n          ctx.scale(1, -1);\\n        }\\n\\n        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\\n        } else {\\n          if (format !== _three.RGBAFormat && format !== _three.RGBFormat) {\\n            console.error('GLTFExporter: Only RGB and RGBA formats are supported.');\\n          }\\n\\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\\n            console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\\n          }\\n\\n          var data = image.data;\\n\\n          if (format === _three.RGBFormat) {\\n            data = new Uint8ClampedArray(image.height * image.width * 4);\\n\\n            for (var i = 0, j = 0; i < data.length; i += 4, j += 3) {\\n              data[i + 0] = image.data[j + 0];\\n              data[i + 1] = image.data[j + 1];\\n              data[i + 2] = image.data[j + 2];\\n              data[i + 3] = 255;\\n            }\\n          }\\n\\n          ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\\n        }\\n\\n        if (options.binary === true) {\\n          pending.push(new Promise(function (resolve) {\\n            canvas.toBlob(function (blob) {\\n              writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\\n                imageDef.bufferView = bufferViewIndex;\\n                resolve();\\n              });\\n            }, mimeType);\\n          }));\\n        } else {\\n          imageDef.uri = canvas.toDataURL(mimeType);\\n        }\\n      } else {\\n        imageDef.uri = image.src;\\n      }\\n\\n      var index = json.images.push(imageDef) - 1;\\n      cachedImages[key] = index;\\n      return index;\\n    },\\n\\n    /**\\n     * Process sampler\\n     * @param  {Texture} map Texture to process\\n     * @return {Integer}     Index of the processed texture in the \\\"samplers\\\" array\\n     */\\n    processSampler: function processSampler(map) {\\n      var json = this.json;\\n      if (!json.samplers) json.samplers = [];\\n      var samplerDef = {\\n        magFilter: THREE_TO_WEBGL[map.magFilter],\\n        minFilter: THREE_TO_WEBGL[map.minFilter],\\n        wrapS: THREE_TO_WEBGL[map.wrapS],\\n        wrapT: THREE_TO_WEBGL[map.wrapT]\\n      };\\n      return json.samplers.push(samplerDef) - 1;\\n    },\\n\\n    /**\\n     * Process texture\\n     * @param  {Texture} map Map to process\\n     * @return {Integer} Index of the processed texture in the \\\"textures\\\" array\\n     */\\n    processTexture: function processTexture(map) {\\n      var cache = this.cache;\\n      var json = this.json;\\n      if (cache.textures.has(map)) return cache.textures.get(map);\\n      if (!json.textures) json.textures = [];\\n      var textureDef = {\\n        sampler: this.processSampler(map),\\n        source: this.processImage(map.image, map.format, map.flipY)\\n      };\\n      if (map.name) textureDef.name = map.name;\\n\\n      this._invokeAll(function (ext) {\\n        ext.writeTexture && ext.writeTexture(map, textureDef);\\n      });\\n\\n      var index = json.textures.push(textureDef) - 1;\\n      cache.textures.set(map, index);\\n      return index;\\n    },\\n\\n    /**\\n     * Process material\\n     * @param  {THREE.Material} material Material to process\\n     * @return {Integer|null} Index of the processed material in the \\\"materials\\\" array\\n     */\\n    processMaterial: function processMaterial(material) {\\n      var cache = this.cache;\\n      var json = this.json;\\n      if (cache.materials.has(material)) return cache.materials.get(material);\\n\\n      if (material.isShaderMaterial) {\\n        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\\n        return null;\\n      }\\n\\n      if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\\n\\n      var materialDef = {\\n        pbrMetallicRoughness: {}\\n      };\\n\\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\\n        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\\n      } // pbrMetallicRoughness.baseColorFactor\\n\\n\\n      var color = material.color.toArray().concat([material.opacity]);\\n\\n      if (!equalArray(color, [1, 1, 1, 1])) {\\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\\n      }\\n\\n      if (material.isMeshStandardMaterial) {\\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\\n      } else {\\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\\n      } // pbrMetallicRoughness.metallicRoughnessTexture\\n\\n\\n      if (material.metalnessMap || material.roughnessMap) {\\n        if (material.metalnessMap === material.roughnessMap) {\\n          var metalRoughMapDef = {\\n            index: this.processTexture(material.metalnessMap)\\n          };\\n          this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\\n          materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\\n        } else {\\n          console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\\n        }\\n      } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\\n\\n\\n      if (material.map) {\\n        var baseColorMapDef = {\\n          index: this.processTexture(material.map)\\n        };\\n        this.applyTextureTransform(baseColorMapDef, material.map);\\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\\n      }\\n\\n      if (material.emissive) {\\n        // emissiveFactor\\n        var emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();\\n\\n        if (!equalArray(emissive, [0, 0, 0])) {\\n          materialDef.emissiveFactor = emissive;\\n        } // emissiveTexture\\n\\n\\n        if (material.emissiveMap) {\\n          var emissiveMapDef = {\\n            index: this.processTexture(material.emissiveMap)\\n          };\\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\\n          materialDef.emissiveTexture = emissiveMapDef;\\n        }\\n      } // normalTexture\\n\\n\\n      if (material.normalMap) {\\n        var normalMapDef = {\\n          index: this.processTexture(material.normalMap)\\n        };\\n\\n        if (material.normalScale && material.normalScale.x !== -1) {\\n          if (material.normalScale.x !== material.normalScale.y) {\\n            console.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');\\n          }\\n\\n          normalMapDef.scale = material.normalScale.x;\\n        }\\n\\n        this.applyTextureTransform(normalMapDef, material.normalMap);\\n        materialDef.normalTexture = normalMapDef;\\n      } // occlusionTexture\\n\\n\\n      if (material.aoMap) {\\n        var occlusionMapDef = {\\n          index: this.processTexture(material.aoMap),\\n          texCoord: 1\\n        };\\n\\n        if (material.aoMapIntensity !== 1.0) {\\n          occlusionMapDef.strength = material.aoMapIntensity;\\n        }\\n\\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\\n        materialDef.occlusionTexture = occlusionMapDef;\\n      } // alphaMode\\n\\n\\n      if (material.transparent) {\\n        materialDef.alphaMode = 'BLEND';\\n      } else {\\n        if (material.alphaTest > 0.0) {\\n          materialDef.alphaMode = 'MASK';\\n          materialDef.alphaCutoff = material.alphaTest;\\n        }\\n      } // doubleSided\\n\\n\\n      if (material.side === _three.DoubleSide) materialDef.doubleSided = true;\\n      if (material.name !== '') materialDef.name = material.name;\\n      this.serializeUserData(material, materialDef);\\n\\n      this._invokeAll(function (ext) {\\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\\n      });\\n\\n      var index = json.materials.push(materialDef) - 1;\\n      cache.materials.set(material, index);\\n      return index;\\n    },\\n\\n    /**\\n     * Process mesh\\n     * @param  {THREE.Mesh} mesh Mesh to process\\n     * @return {Integer|null} Index of the processed mesh in the \\\"meshes\\\" array\\n     */\\n    processMesh: function processMesh(mesh) {\\n      var cache = this.cache;\\n      var json = this.json;\\n      var meshCacheKeyParts = [mesh.geometry.uuid];\\n\\n      if (Array.isArray(mesh.material)) {\\n        for (var i = 0, l = mesh.material.length; i < l; i++) {\\n          meshCacheKeyParts.push(mesh.material[i].uuid);\\n        }\\n      } else {\\n        meshCacheKeyParts.push(mesh.material.uuid);\\n      }\\n\\n      var meshCacheKey = meshCacheKeyParts.join(':');\\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\\n      var geometry = mesh.geometry;\\n      var mode; // Use the correct mode\\n\\n      if (mesh.isLineSegments) {\\n        mode = WEBGL_CONSTANTS.LINES;\\n      } else if (mesh.isLineLoop) {\\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\\n      } else if (mesh.isLine) {\\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\\n      } else if (mesh.isPoints) {\\n        mode = WEBGL_CONSTANTS.POINTS;\\n      } else {\\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\\n      }\\n\\n      if (geometry.isBufferGeometry !== true) {\\n        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\\n      }\\n\\n      var meshDef = {};\\n      var attributes = {};\\n      var primitives = [];\\n      var targets = []; // Conversion between attributes names in threejs and gltf spec\\n\\n      var nameConversion = {\\n        uv: 'TEXCOORD_0',\\n        uv2: 'TEXCOORD_1',\\n        color: 'COLOR_0',\\n        skinWeight: 'WEIGHTS_0',\\n        skinIndex: 'JOINTS_0'\\n      };\\n      var originalNormal = geometry.getAttribute('normal');\\n\\n      if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\\n        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\\n        geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\\n      } // @QUESTION Detect if .vertexColors = true?\\n      // For every attribute create an accessor\\n\\n\\n      var modifiedAttribute = null;\\n\\n      for (var attributeName in geometry.attributes) {\\n        // Ignore morph target attributes, which are exported later.\\n        if (attributeName.substr(0, 5) === 'morph') continue;\\n        var attribute = geometry.attributes[attributeName];\\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\\n        // listed in the spec; non-spec attributes are considered custom.\\n\\n        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\\\d+|COLOR_\\\\d+|JOINTS_\\\\d+|WEIGHTS_\\\\d+)$/;\\n        if (!validVertexAttributes.test(attributeName)) attributeName = \\\"_\\\".concat(attributeName);\\n\\n        if (cache.attributes.has(this.getUID(attribute))) {\\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\\n          continue;\\n        } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\\n\\n\\n        modifiedAttribute = null;\\n        var array = attribute.array;\\n\\n        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\\n          console.warn('GLTFExporter: Attribute \\\"skinIndex\\\" converted to type UNSIGNED_SHORT.');\\n          modifiedAttribute = new _three.BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\\n        }\\n\\n        var accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\\n\\n        if (accessor !== null) {\\n          attributes[attributeName] = accessor;\\n          cache.attributes.set(this.getUID(attribute), accessor);\\n        }\\n      }\\n\\n      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\\n\\n      if (Object.keys(attributes).length === 0) return null; // Morph targets\\n\\n      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\\n        var weights = [];\\n        var targetNames = [];\\n        var reverseDictionary = {};\\n\\n        if (mesh.morphTargetDictionary !== undefined) {\\n          for (var key in mesh.morphTargetDictionary) {\\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\\n          }\\n        }\\n\\n        for (var _i = 0; _i < mesh.morphTargetInfluences.length; ++_i) {\\n          var target = {};\\n          var warned = false;\\n\\n          for (var _attributeName in geometry.morphAttributes) {\\n            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\\n            // Three.js doesn't support TANGENT yet.\\n            if (_attributeName !== 'position' && _attributeName !== 'normal') {\\n              if (!warned) {\\n                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\\n                warned = true;\\n              }\\n\\n              continue;\\n            }\\n\\n            var attribute = geometry.morphAttributes[_attributeName][_i];\\n\\n            var gltfAttributeName = _attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\\n            //\\n            // glTF 2.0 Specification:\\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\\n\\n\\n            var baseAttribute = geometry.attributes[_attributeName];\\n\\n            if (cache.attributes.has(this.getUID(attribute))) {\\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\\n              continue;\\n            } // Clones attribute not to override\\n\\n\\n            var relativeAttribute = attribute.clone();\\n\\n            if (!geometry.morphTargetsRelative) {\\n              for (var j = 0, jl = attribute.count; j < jl; j++) {\\n                relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\\n              }\\n            }\\n\\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\\n            cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\\n          }\\n\\n          targets.push(target);\\n          weights.push(mesh.morphTargetInfluences[_i]);\\n          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[_i]);\\n        }\\n\\n        meshDef.weights = weights;\\n\\n        if (targetNames.length > 0) {\\n          meshDef.extras = {};\\n          meshDef.extras.targetNames = targetNames;\\n        }\\n      }\\n\\n      var isMultiMaterial = Array.isArray(mesh.material);\\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\\n      var materials = isMultiMaterial ? mesh.material : [mesh.material];\\n      var groups = isMultiMaterial ? geometry.groups : [{\\n        materialIndex: 0,\\n        start: undefined,\\n        count: undefined\\n      }];\\n\\n      for (var _i2 = 0, il = groups.length; _i2 < il; _i2++) {\\n        var primitive = {\\n          mode: mode,\\n          attributes: attributes\\n        };\\n        this.serializeUserData(geometry, primitive);\\n        if (targets.length > 0) primitive.targets = targets;\\n\\n        if (geometry.index !== null) {\\n          var cacheKey = this.getUID(geometry.index);\\n\\n          if (groups[_i2].start !== undefined || groups[_i2].count !== undefined) {\\n            cacheKey += \\\":\\\".concat(groups[_i2].start, \\\":\\\").concat(groups[_i2].count);\\n          }\\n\\n          if (cache.attributes.has(cacheKey)) {\\n            primitive.indices = cache.attributes.get(cacheKey);\\n          } else {\\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[_i2].start, groups[_i2].count);\\n            cache.attributes.set(cacheKey, primitive.indices);\\n          }\\n\\n          if (primitive.indices === null) delete primitive.indices;\\n        }\\n\\n        var material = this.processMaterial(materials[groups[_i2].materialIndex]);\\n        if (material !== null) primitive.material = material;\\n        primitives.push(primitive);\\n      }\\n\\n      meshDef.primitives = primitives;\\n      if (!json.meshes) json.meshes = [];\\n\\n      this._invokeAll(function (ext) {\\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\\n      });\\n\\n      var index = json.meshes.push(meshDef) - 1;\\n      cache.meshes.set(meshCacheKey, index);\\n      return index;\\n    },\\n\\n    /**\\n     * Process camera\\n     * @param  {THREE.Camera} camera Camera to process\\n     * @return {Integer}      Index of the processed mesh in the \\\"camera\\\" array\\n     */\\n    processCamera: function processCamera(camera) {\\n      var json = this.json;\\n      if (!json.cameras) json.cameras = [];\\n      var isOrtho = camera.isOrthographicCamera;\\n      var cameraDef = {\\n        type: isOrtho ? 'orthographic' : 'perspective'\\n      };\\n\\n      if (isOrtho) {\\n        cameraDef.orthographic = {\\n          xmag: camera.right * 2,\\n          ymag: camera.top * 2,\\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\\n          znear: camera.near < 0 ? 0 : camera.near\\n        };\\n      } else {\\n        cameraDef.perspective = {\\n          aspectRatio: camera.aspect,\\n          yfov: _three.MathUtils.degToRad(camera.fov),\\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\\n          znear: camera.near < 0 ? 0 : camera.near\\n        };\\n      } // Question: Is saving \\\"type\\\" as name intentional?\\n\\n\\n      if (camera.name !== '') cameraDef.name = camera.type;\\n      return json.cameras.push(cameraDef) - 1;\\n    },\\n\\n    /**\\n     * Creates glTF animation entry from AnimationClip object.\\n     *\\n     * Status:\\n     * - Only properties listed in PATH_PROPERTIES may be animated.\\n     *\\n     * @param {THREE.AnimationClip} clip\\n     * @param {THREE.Object3D} root\\n     * @return {number|null}\\n     */\\n    processAnimation: function processAnimation(clip, root) {\\n      var json = this.json;\\n      var nodeMap = this.nodeMap;\\n      if (!json.animations) json.animations = [];\\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\\n      var tracks = clip.tracks;\\n      var channels = [];\\n      var samplers = [];\\n\\n      for (var i = 0; i < tracks.length; ++i) {\\n        var track = tracks[i];\\n\\n        var trackBinding = _three.PropertyBinding.parseTrackName(track.name);\\n\\n        var trackNode = _three.PropertyBinding.findNode(root, trackBinding.nodeName);\\n\\n        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\\n\\n        if (trackBinding.objectName === 'bones') {\\n          if (trackNode.isSkinnedMesh === true) {\\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\\n          } else {\\n            trackNode = undefined;\\n          }\\n        }\\n\\n        if (!trackNode || !trackProperty) {\\n          console.warn('THREE.GLTFExporter: Could not export animation track \\\"%s\\\".', track.name);\\n          return null;\\n        }\\n\\n        var inputItemSize = 1;\\n        var outputItemSize = track.values.length / track.times.length;\\n\\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\\n          outputItemSize /= trackNode.morphTargetInfluences.length;\\n        }\\n\\n        var interpolation = void 0; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\\n        // Detecting glTF cubic spline interpolant by checking factory method's special property\\n        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\\n        // valid value from .getInterpolation().\\n\\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\\n          interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\\n          // (VEC3 * 3: inTangent, splineVertex, and outTangent)\\n          // but needs to be stored as VEC3 so dividing by 3 here.\\n\\n          outputItemSize /= 3;\\n        } else if (track.getInterpolation() === _three.InterpolateDiscrete) {\\n          interpolation = 'STEP';\\n        } else {\\n          interpolation = 'LINEAR';\\n        }\\n\\n        samplers.push({\\n          input: this.processAccessor(new _three.BufferAttribute(track.times, inputItemSize)),\\n          output: this.processAccessor(new _three.BufferAttribute(track.values, outputItemSize)),\\n          interpolation: interpolation\\n        });\\n        channels.push({\\n          sampler: samplers.length - 1,\\n          target: {\\n            node: nodeMap.get(trackNode),\\n            path: trackProperty\\n          }\\n        });\\n      }\\n\\n      json.animations.push({\\n        name: clip.name || \\\"clip_\\\".concat(json.animations.length),\\n        samplers: samplers,\\n        channels: channels\\n      });\\n      return json.animations.length - 1;\\n    },\\n\\n    /**\\n     * @param {THREE.Object3D} object\\n     * @return {number|null}\\n     */\\n    processSkin: function processSkin(object) {\\n      var json = this.json;\\n      var nodeMap = this.nodeMap;\\n      var node = json.nodes[nodeMap.get(object)];\\n      var skeleton = object.skeleton;\\n      if (skeleton === undefined) return null;\\n      var rootJoint = object.skeleton.bones[0];\\n      if (rootJoint === undefined) return null;\\n      var joints = [];\\n      var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\\n      var temporaryBoneInverse = new _three.Matrix4();\\n\\n      for (var i = 0; i < skeleton.bones.length; ++i) {\\n        joints.push(nodeMap.get(skeleton.bones[i]));\\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\\n      }\\n\\n      if (json.skins === undefined) json.skins = [];\\n      json.skins.push({\\n        inverseBindMatrices: this.processAccessor(new _three.BufferAttribute(inverseBindMatrices, 16)),\\n        joints: joints,\\n        skeleton: nodeMap.get(rootJoint)\\n      });\\n      var skinIndex = node.skin = json.skins.length - 1;\\n      return skinIndex;\\n    },\\n\\n    /**\\n     * Process Object3D node\\n     * @param  {THREE.Object3D} node Object3D to processNode\\n     * @return {Integer} Index of the node in the nodes list\\n     */\\n    processNode: function processNode(object) {\\n      var json = this.json;\\n      var options = this.options;\\n      var nodeMap = this.nodeMap;\\n      if (!json.nodes) json.nodes = [];\\n      var nodeDef = {};\\n\\n      if (options.trs) {\\n        var rotation = object.quaternion.toArray();\\n        var position = object.position.toArray();\\n        var scale = object.scale.toArray();\\n\\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\\n          nodeDef.rotation = rotation;\\n        }\\n\\n        if (!equalArray(position, [0, 0, 0])) {\\n          nodeDef.translation = position;\\n        }\\n\\n        if (!equalArray(scale, [1, 1, 1])) {\\n          nodeDef.scale = scale;\\n        }\\n      } else {\\n        if (object.matrixAutoUpdate) {\\n          object.updateMatrix();\\n        }\\n\\n        if (isIdentityMatrix(object.matrix) === false) {\\n          nodeDef.matrix = object.matrix.elements;\\n        }\\n      } // We don't export empty strings name because it represents no-name in Three.js.\\n\\n\\n      if (object.name !== '') nodeDef.name = String(object.name);\\n      this.serializeUserData(object, nodeDef);\\n\\n      if (object.isMesh || object.isLine || object.isPoints) {\\n        var meshIndex = this.processMesh(object);\\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\\n      } else if (object.isCamera) {\\n        nodeDef.camera = this.processCamera(object);\\n      }\\n\\n      if (object.isSkinnedMesh) this.skins.push(object);\\n\\n      if (object.children.length > 0) {\\n        var children = [];\\n\\n        for (var i = 0, l = object.children.length; i < l; i++) {\\n          var child = object.children[i];\\n\\n          if (child.visible || options.onlyVisible === false) {\\n            var nodeIndex = this.processNode(child);\\n            if (nodeIndex !== null) children.push(nodeIndex);\\n          }\\n        }\\n\\n        if (children.length > 0) nodeDef.children = children;\\n      }\\n\\n      this._invokeAll(function (ext) {\\n        ext.writeNode && ext.writeNode(object, nodeDef);\\n      });\\n\\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\\n      nodeMap.set(object, nodeIndex);\\n      return nodeIndex;\\n    },\\n\\n    /**\\n     * Process Scene\\n     * @param  {Scene} node Scene to process\\n     */\\n    processScene: function processScene(scene) {\\n      var json = this.json;\\n      var options = this.options;\\n\\n      if (!json.scenes) {\\n        json.scenes = [];\\n        json.scene = 0;\\n      }\\n\\n      var sceneDef = {};\\n      if (scene.name !== '') sceneDef.name = scene.name;\\n      json.scenes.push(sceneDef);\\n      var nodes = [];\\n\\n      for (var i = 0, l = scene.children.length; i < l; i++) {\\n        var child = scene.children[i];\\n\\n        if (child.visible || options.onlyVisible === false) {\\n          var nodeIndex = this.processNode(child);\\n          if (nodeIndex !== null) nodes.push(nodeIndex);\\n        }\\n      }\\n\\n      if (nodes.length > 0) sceneDef.nodes = nodes;\\n      this.serializeUserData(scene, sceneDef);\\n    },\\n\\n    /**\\n     * Creates a Scene to hold a list of objects and parse it\\n     * @param  {Array} objects List of objects to process\\n     */\\n    processObjects: function processObjects(objects) {\\n      var scene = new _three.Scene();\\n      scene.name = 'AuxScene';\\n\\n      for (var i = 0; i < objects.length; i++) {\\n        // We push directly to children instead of calling `add` to prevent\\n        // modify the .parent and break its original scene and hierarchy\\n        scene.children.push(objects[i]);\\n      }\\n\\n      this.processScene(scene);\\n    },\\n\\n    /**\\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\\n     */\\n    processInput: function processInput(input) {\\n      var options = this.options;\\n      input = input instanceof Array ? input : [input];\\n\\n      this._invokeAll(function (ext) {\\n        ext.beforeParse && ext.beforeParse(input);\\n      });\\n\\n      var objectsWithoutScene = [];\\n\\n      for (var i = 0; i < input.length; i++) {\\n        if (input[i] instanceof _three.Scene) {\\n          this.processScene(input[i]);\\n        } else {\\n          objectsWithoutScene.push(input[i]);\\n        }\\n      }\\n\\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\\n\\n      for (var _i3 = 0; _i3 < this.skins.length; ++_i3) {\\n        this.processSkin(this.skins[_i3]);\\n      }\\n\\n      for (var _i4 = 0; _i4 < options.animations.length; ++_i4) {\\n        this.processAnimation(options.animations[_i4], input[0]);\\n      }\\n\\n      this._invokeAll(function (ext) {\\n        ext.afterParse && ext.afterParse(input);\\n      });\\n    },\\n    _invokeAll: function _invokeAll(func) {\\n      for (var i = 0, il = this.plugins.length; i < il; i++) {\\n        func(this.plugins[i]);\\n      }\\n    }\\n  };\\n  /**\\n   * Punctual Lights Extension\\n   *\\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\\n   */\\n\\n  function GLTFLightExtension(writer) {\\n    this.writer = writer;\\n    this.name = 'KHR_lights_punctual';\\n  }\\n\\n  GLTFLightExtension.prototype = {\\n    constructor: GLTFLightExtension,\\n    writeNode: function writeNode(light, nodeDef) {\\n      if (!light.isLight) return;\\n\\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\\n        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\\n        return;\\n      }\\n\\n      var writer = this.writer;\\n      var json = writer.json;\\n      var extensionsUsed = writer.extensionsUsed;\\n      var lightDef = {};\\n      if (light.name) lightDef.name = light.name;\\n      lightDef.color = light.color.toArray();\\n      lightDef.intensity = light.intensity;\\n\\n      if (light.isDirectionalLight) {\\n        lightDef.type = 'directional';\\n      } else if (light.isPointLight) {\\n        lightDef.type = 'point';\\n        if (light.distance > 0) lightDef.range = light.distance;\\n      } else if (light.isSpotLight) {\\n        lightDef.type = 'spot';\\n        if (light.distance > 0) lightDef.range = light.distance;\\n        lightDef.spot = {};\\n        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\\n        lightDef.spot.outerConeAngle = light.angle;\\n      }\\n\\n      if (light.decay !== undefined && light.decay !== 2) {\\n        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\\n      }\\n\\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\\n        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\\n      }\\n\\n      if (!extensionsUsed[this.name]) {\\n        json.extensions = json.extensions || {};\\n        json.extensions[this.name] = {\\n          lights: []\\n        };\\n        extensionsUsed[this.name] = true;\\n      }\\n\\n      var lights = json.extensions[this.name].lights;\\n      lights.push(lightDef);\\n      nodeDef.extensions = nodeDef.extensions || {};\\n      nodeDef.extensions[this.name] = {\\n        light: lights.length - 1\\n      };\\n    }\\n  };\\n  /**\\n   * Unlit Materials Extension\\n   *\\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\\n   */\\n\\n  function GLTFMaterialsUnlitExtension(writer) {\\n    this.writer = writer;\\n    this.name = 'KHR_materials_unlit';\\n  }\\n\\n  GLTFMaterialsUnlitExtension.prototype = {\\n    constructor: GLTFMaterialsUnlitExtension,\\n    writeMaterial: function writeMaterial(material, materialDef) {\\n      if (!material.isMeshBasicMaterial) return;\\n      var writer = this.writer;\\n      var extensionsUsed = writer.extensionsUsed;\\n      materialDef.extensions = materialDef.extensions || {};\\n      materialDef.extensions[this.name] = {};\\n      extensionsUsed[this.name] = true;\\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\\n    }\\n  };\\n  /**\\n   * Specular-Glossiness Extension\\n   *\\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\\n   */\\n\\n  function GLTFMaterialsPBRSpecularGlossiness(writer) {\\n    this.writer = writer;\\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\\n  }\\n\\n  GLTFMaterialsPBRSpecularGlossiness.prototype = {\\n    constructor: GLTFMaterialsPBRSpecularGlossiness,\\n    writeMaterial: function writeMaterial(material, materialDef) {\\n      if (!material.isGLTFSpecularGlossinessMaterial) return;\\n      var writer = this.writer;\\n      var extensionsUsed = writer.extensionsUsed;\\n      var extensionDef = {};\\n\\n      if (materialDef.pbrMetallicRoughness.baseColorFactor) {\\n        extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\\n      }\\n\\n      var specularFactor = [1, 1, 1];\\n      material.specular.toArray(specularFactor, 0);\\n      extensionDef.specularFactor = specularFactor;\\n      extensionDef.glossinessFactor = material.glossiness;\\n\\n      if (materialDef.pbrMetallicRoughness.baseColorTexture) {\\n        extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\\n      }\\n\\n      if (material.specularMap) {\\n        var specularMapDef = {\\n          index: writer.processTexture(material.specularMap)\\n        };\\n        writer.applyTextureTransform(specularMapDef, material.specularMap);\\n        extensionDef.specularGlossinessTexture = specularMapDef;\\n      }\\n\\n      materialDef.extensions = materialDef.extensions || {};\\n      materialDef.extensions[this.name] = extensionDef;\\n      extensionsUsed[this.name] = true;\\n    }\\n  };\\n  /**\\n   * Static utility functions\\n   */\\n\\n  GLTFExporter.Utils = {\\n    insertKeyframe: function insertKeyframe(track, time) {\\n      var tolerance = 0.001; // 1ms\\n\\n      var valueSize = track.getValueSize();\\n      var times = new track.TimeBufferType(track.times.length + 1);\\n      var values = new track.ValueBufferType(track.values.length + valueSize);\\n      var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\\n      var index;\\n\\n      if (track.times.length === 0) {\\n        times[0] = time;\\n\\n        for (var i = 0; i < valueSize; i++) {\\n          values[i] = 0;\\n        }\\n\\n        index = 0;\\n      } else if (time < track.times[0]) {\\n        if (Math.abs(track.times[0] - time) < tolerance) return 0;\\n        times[0] = time;\\n        times.set(track.times, 1);\\n        values.set(interpolant.evaluate(time), 0);\\n        values.set(track.values, valueSize);\\n        index = 0;\\n      } else if (time > track.times[track.times.length - 1]) {\\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\\n          return track.times.length - 1;\\n        }\\n\\n        times[times.length - 1] = time;\\n        times.set(track.times, 0);\\n        values.set(track.values, 0);\\n        values.set(interpolant.evaluate(time), track.values.length);\\n        index = times.length - 1;\\n      } else {\\n        for (var _i5 = 0; _i5 < track.times.length; _i5++) {\\n          if (Math.abs(track.times[_i5] - time) < tolerance) return _i5;\\n\\n          if (track.times[_i5] < time && track.times[_i5 + 1] > time) {\\n            times.set(track.times.slice(0, _i5 + 1), 0);\\n            times[_i5 + 1] = time;\\n            times.set(track.times.slice(_i5 + 1), _i5 + 2);\\n            values.set(track.values.slice(0, (_i5 + 1) * valueSize), 0);\\n            values.set(interpolant.evaluate(time), (_i5 + 1) * valueSize);\\n            values.set(track.values.slice((_i5 + 1) * valueSize), (_i5 + 2) * valueSize);\\n            index = _i5 + 1;\\n            break;\\n          }\\n        }\\n      }\\n\\n      track.times = times;\\n      track.values = values;\\n      return index;\\n    },\\n    mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {\\n      var tracks = [];\\n      var mergedTracks = {};\\n      var sourceTracks = clip.tracks;\\n\\n      for (var i = 0; i < sourceTracks.length; ++i) {\\n        var sourceTrack = sourceTracks[i];\\n\\n        var sourceTrackBinding = _three.PropertyBinding.parseTrackName(sourceTrack.name);\\n\\n        var sourceTrackNode = _three.PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\\n\\n        if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\\n          // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\\n          tracks.push(sourceTrack);\\n          continue;\\n        }\\n\\n        if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\\n            // This should never happen, because glTF morph target animations\\n            // affect all targets already.\\n            throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\\n          }\\n\\n          console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\\n          sourceTrack = sourceTrack.clone();\\n          sourceTrack.setInterpolation(_three.InterpolateLinear);\\n        }\\n\\n        var targetCount = sourceTrackNode.morphTargetInfluences.length;\\n        var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\\n\\n        if (targetIndex === undefined) {\\n          throw new Error(\\\"THREE.GLTFExporter: Morph target name not found: \\\".concat(sourceTrackBinding.propertyIndex));\\n        }\\n\\n        var mergedTrack = void 0; // If this is the first time we've seen this object, create a new\\n        // track to store merged keyframe data for each morph target.\\n\\n        if (mergedTracks[sourceTrackNode.uuid] === undefined) {\\n          mergedTrack = sourceTrack.clone();\\n          var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\\n\\n          for (var j = 0; j < mergedTrack.times.length; j++) {\\n            values[j * targetCount + targetIndex] = mergedTrack.values[j];\\n          } // We need to take into consideration the intended target node\\n          // of our original un-merged morphTarget animation.\\n\\n\\n          mergedTrack.name = \\\"\\\".concat(sourceTrackBinding.nodeName || '', \\\".morphTargetInfluences\\\");\\n          mergedTrack.values = values;\\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack;\\n          tracks.push(mergedTrack);\\n          continue;\\n        }\\n\\n        var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\\n        mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\\n        // interpolated) value from the source track.\\n\\n        for (var _j = 0; _j < mergedTrack.times.length; _j++) {\\n          mergedTrack.values[_j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[_j]);\\n        } // For every existing keyframe of the source track, write a (possibly\\n        // new) keyframe to the merged track. Values from the previous loop may\\n        // be written again, but keyframes are de-duplicated.\\n\\n\\n        for (var _j2 = 0; _j2 < sourceTrack.times.length; _j2++) {\\n          var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[_j2]);\\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[_j2];\\n        }\\n      }\\n\\n      clip.tracks = tracks;\\n      return clip;\\n    }\\n  };\\n  return GLTFExporter;\\n}();\\n\\nexports.GLTFExporter = GLTFExporter;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"GLTFExporter\",\"_three\",\"pluginCallbacks\",\"register\",\"writer\",\"GLTFLightExtension\",\"GLTFMaterialsUnlitExtension\",\"GLTFMaterialsPBRSpecularGlossiness\",\"equalArray\",\"array1\",\"array2\",\"length\",\"every\",\"element\",\"index\",\"stringToArrayBuffer\",\"text\",\"undefined\",\"window\",\"TextEncoder\",\"encode\",\"buffer\",\"array\",\"Uint8Array\",\"ArrayBuffer\",\"i\",\"il\",\"charCodeAt\",\"getPaddedArrayBuffer\",\"arrayBuffer\",\"paddingByte\",\"paddedLength\",\"Math\",\"ceil\",\"byteLength\",\"set\",\"GLTFWriter\",\"plugins\",\"options\",\"pending\",\"buffers\",\"byteOffset\",\"nodeMap\",\"Map\",\"skins\",\"extensionsUsed\",\"uids\",\"uid\",\"json\",\"asset\",\"version\",\"generator\",\"cache\",\"meshes\",\"attributes\",\"attributesNormalized\",\"materials\",\"textures\",\"images\",\"name\",\"prototype\",\"constructor\",\"callback\",\"indexOf\",\"push\",\"unregister\",\"splice\",\"parse\",\"input\",\"onDone\",\"setPlugins\",\"write\",\"THREE_TO_WEBGL\",\"NearestFilter\",\"NEAREST\",\"NearestMipmapNearestFilter\",\"NEAREST_MIPMAP_NEAREST\",\"NearestMipmapLinearFilter\",\"NEAREST_MIPMAP_LINEAR\",\"LinearFilter\",\"LINEAR\",\"LinearMipmapNearestFilter\",\"LINEAR_MIPMAP_NEAREST\",\"LinearMipmapLinearFilter\",\"LINEAR_MIPMAP_LINEAR\",\"ClampToEdgeWrapping\",\"CLAMP_TO_EDGE\",\"RepeatWrapping\",\"REPEAT\",\"MirroredRepeatWrapping\",\"MIRRORED_REPEAT\",\"PATH_PROPERTIES\",\"scale\",\"position\",\"quaternion\",\"morphTargetInfluences\",\"cachedCanvas\",\"assign\",\"binary\",\"trs\",\"onlyVisible\",\"truncateDrawRange\",\"embedImages\",\"maxTextureSize\",\"Infinity\",\"animations\",\"includeCustomExtensions\",\"processInput\",\"Promise\",\"all\",\"then\",\"blob\",\"Blob\",\"type\",\"extensionsUsedList\",\"keys\",\"size\",\"reader\",\"FileReader\",\"readAsArrayBuffer\",\"onloadend\",\"reader.onloadend\",\"binaryChunk\",\"result\",\"binaryChunkPrefix\",\"DataView\",\"GLB_CHUNK_PREFIX_BYTES\",\"setUint32\",\"GLB_CHUNK_TYPE_BIN\",\"jsonChunk\",\"JSON\",\"stringify\",\"jsonChunkPrefix\",\"GLB_CHUNK_TYPE_JSON\",\"header\",\"GLB_HEADER_BYTES\",\"headerView\",\"GLB_HEADER_MAGIC\",\"GLB_VERSION\",\"glbBlob\",\"glbReader\",\"glbReader.onloadend\",\"readAsDataURL\",\"uri\",\"serializeUserData\",\"object\",\"objectDef\",\"userData\",\"gltfExtensions\",\"extensions\",\"extensionName\",\"extras\",\"error\",\"console\",\"warn\",\"concat\",\"message\",\"getUID\",\"has\",\"get\",\"isNormalizedNormalAttribute\",\"normal\",\"v\",\"Vector3\",\"count\",\"abs\",\"fromBufferAttribute\",\"createNormalizedNormalAttribute\",\"attribute\",\"clone\",\"x\",\"y\",\"z\",\"setX\",\"normalize\",\"setXYZ\",\"applyTextureTransform\",\"mapDef\",\"texture\",\"didTransform\",\"transformDef\",\"offset\",\"toArray\",\"rotation\",\"repeat\",\"processBuffer\",\"processBufferView\",\"componentType\",\"start\",\"target\",\"bufferViews\",\"componentSize\",\"UNSIGNED_BYTE\",\"UNSIGNED_SHORT\",\"itemSize\",\"dataView\",\"a\",\"getX\",\"getY\",\"getZ\",\"getW\",\"FLOAT\",\"setFloat32\",\"UNSIGNED_INT\",\"setUint16\",\"setUint8\",\"bufferViewDef\",\"ARRAY_BUFFER\",\"byteStride\",\"output\",\"id\",\"processBufferViewImage\",\"resolve\",\"processAccessor\",\"geometry\",\"Float32Array\",\"Uint32Array\",\"Uint16Array\",\"Error\",\"end\",\"end2\",\"drawRange\",\"max\",\"min\",\"Array\",\"fill\",\"Number\",\"POSITIVE_INFINITY\",\"NEGATIVE_INFINITY\",\"bufferViewTarget\",\"ELEMENT_ARRAY_BUFFER\",\"bufferView\",\"accessorDef\",\"types\",\"normalized\",\"accessors\",\"processImage\",\"image\",\"format\",\"flipY\",\"cachedImages\",\"mimeType\",\"RGBAFormat\",\"key\",\"toString\",\"imageDef\",\"canvas\",\"document\",\"createElement\",\"width\",\"height\",\"ctx\",\"getContext\",\"translate\",\"HTMLImageElement\",\"HTMLCanvasElement\",\"OffscreenCanvas\",\"ImageBitmap\",\"drawImage\",\"RGBFormat\",\"data\",\"Uint8ClampedArray\",\"j\",\"putImageData\",\"ImageData\",\"toBlob\",\"bufferViewIndex\",\"toDataURL\",\"src\",\"processSampler\",\"map\",\"samplers\",\"samplerDef\",\"magFilter\",\"minFilter\",\"wrapS\",\"wrapT\",\"processTexture\",\"textureDef\",\"sampler\",\"source\",\"_invokeAll\",\"ext\",\"writeTexture\",\"processMaterial\",\"material\",\"isShaderMaterial\",\"materialDef\",\"pbrMetallicRoughness\",\"isMeshStandardMaterial\",\"isMeshBasicMaterial\",\"color\",\"opacity\",\"baseColorFactor\",\"metallicFactor\",\"metalness\",\"roughnessFactor\",\"roughness\",\"metalnessMap\",\"roughnessMap\",\"metalRoughMapDef\",\"metallicRoughnessTexture\",\"baseColorMapDef\",\"baseColorTexture\",\"emissive\",\"multiplyScalar\",\"emissiveIntensity\",\"emissiveFactor\",\"emissiveMap\",\"emissiveMapDef\",\"emissiveTexture\",\"normalMap\",\"normalMapDef\",\"normalScale\",\"normalTexture\",\"aoMap\",\"occlusionMapDef\",\"texCoord\",\"aoMapIntensity\",\"strength\",\"occlusionTexture\",\"transparent\",\"alphaMode\",\"alphaTest\",\"alphaCutoff\",\"side\",\"DoubleSide\",\"doubleSided\",\"writeMaterial\",\"processMesh\",\"mesh\",\"meshCacheKeyParts\",\"uuid\",\"isArray\",\"l\",\"meshCacheKey\",\"join\",\"mode\",\"isLineSegments\",\"LINES\",\"isLineLoop\",\"LINE_LOOP\",\"isLine\",\"LINE_STRIP\",\"isPoints\",\"POINTS\",\"wireframe\",\"TRIANGLES\",\"isBufferGeometry\",\"meshDef\",\"primitives\",\"targets\",\"nameConversion\",\"uv\",\"uv2\",\"skinWeight\",\"skinIndex\",\"originalNormal\",\"getAttribute\",\"setAttribute\",\"modifiedAttribute\",\"attributeName\",\"substr\",\"toUpperCase\",\"validVertexAttributes\",\"test\",\"BufferAttribute\",\"accessor\",\"weights\",\"targetNames\",\"reverseDictionary\",\"morphTargetDictionary\",\"_i\",\"warned\",\"_attributeName\",\"morphAttributes\",\"gltfAttributeName\",\"baseAttribute\",\"relativeAttribute\",\"morphTargetsRelative\",\"jl\",\"isMultiMaterial\",\"groups\",\"materialIndex\",\"_i2\",\"primitive\",\"cacheKey\",\"indices\",\"writeMesh\",\"processCamera\",\"camera\",\"cameras\",\"isOrtho\",\"isOrthographicCamera\",\"cameraDef\",\"orthographic\",\"xmag\",\"right\",\"ymag\",\"top\",\"zfar\",\"far\",\"znear\",\"near\",\"perspective\",\"aspectRatio\",\"aspect\",\"yfov\",\"MathUtils\",\"degToRad\",\"fov\",\"processAnimation\",\"clip\",\"root\",\"Utils\",\"mergeMorphTargetTracks\",\"tracks\",\"channels\",\"track\",\"trackBinding\",\"PropertyBinding\",\"parseTrackName\",\"trackNode\",\"findNode\",\"nodeName\",\"trackProperty\",\"propertyName\",\"objectName\",\"isSkinnedMesh\",\"skeleton\",\"getBoneByName\",\"objectIndex\",\"outputItemSize\",\"values\",\"times\",\"createInterpolant\",\"isInterpolantFactoryMethodGLTFCubicSpline\",\"interpolation\",\"getInterpolation\",\"InterpolateDiscrete\",\"inputItemSize\",\"node\",\"path\",\"processSkin\",\"nodes\",\"rootJoint\",\"bones\",\"joints\",\"inverseBindMatrices\",\"temporaryBoneInverse\",\"Matrix4\",\"copy\",\"boneInverses\",\"multiply\",\"bindMatrix\",\"skin\",\"processNode\",\"nodeDef\",\"translation\",\"matrixAutoUpdate\",\"updateMatrix\",\"matrix\",\"elements\",\"String\",\"isMesh\",\"meshIndex\",\"isCamera\",\"children\",\"child\",\"visible\",\"nodeIndex\",\"writeNode\",\"processScene\",\"scene\",\"scenes\",\"sceneDef\",\"processObjects\",\"objects\",\"Scene\",\"beforeParse\",\"objectsWithoutScene\",\"_i3\",\"_i4\",\"afterParse\",\"func\",\"light\",\"isLight\",\"isDirectionalLight\",\"isPointLight\",\"isSpotLight\",\"lightDef\",\"intensity\",\"distance\",\"range\",\"spot\",\"innerConeAngle\",\"penumbra\",\"angle\",\"outerConeAngle\",\"decay\",\"parent\",\"lights\",\"isGLTFSpecularGlossinessMaterial\",\"extensionDef\",\"diffuseFactor\",\"specularFactor\",\"specular\",\"glossinessFactor\",\"glossiness\",\"diffuseTexture\",\"specularMap\",\"specularMapDef\",\"specularGlossinessTexture\",\"insertKeyframe\",\"time\",\"valueSize\",\"getValueSize\",\"TimeBufferType\",\"ValueBufferType\",\"interpolant\",\"tolerance\",\"evaluate\",\"_i5\",\"slice\",\"mergedTracks\",\"sourceTracks\",\"sourceTrack\",\"sourceTrackBinding\",\"sourceTrackNode\",\"propertyIndex\",\"InterpolantFactoryMethodDiscrete\",\"InterpolantFactoryMethodLinear\",\"setInterpolation\",\"InterpolateLinear\",\"targetCount\",\"targetIndex\",\"mergedTrack\",\"sourceInterpolant\",\"_j\",\"_j2\",\"keyframeIndex\"]\n}\n"]