["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/nodes/misc/TextureCubeUVNode.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$nodes$misc$TextureCubeUVNode=function(global,require,module,exports){function TextureCubeUVNode(value,uv,bias){_TempNode.TempNode.call(this,\"v4\");this.value=value;this.uv=uv;this.bias=bias}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.TextureCubeUVNode=TextureCubeUVNode;var _TempNode=require(\"module$node_modules$three_stdlib$nodes$core$TempNode\"),_ConstNode=require(\"module$node_modules$three_stdlib$nodes$core$ConstNode\"),_StructNode=\nrequire(\"module$node_modules$three_stdlib$nodes$core$StructNode\"),_FunctionNode=require(\"module$node_modules$three_stdlib$nodes$core$FunctionNode\"),_FunctionCallNode=require(\"module$node_modules$three_stdlib$nodes$core$FunctionCallNode\"),_ExpressionNode=require(\"module$node_modules$three_stdlib$nodes$core$ExpressionNode\"),_FloatNode=require(\"module$node_modules$three_stdlib$nodes$inputs$FloatNode\"),_OperatorNode=require(\"module$node_modules$three_stdlib$nodes$math$OperatorNode\"),_MathNode=require(\"module$node_modules$three_stdlib$nodes$math$MathNode\"),\n_ColorSpaceNode=require(\"module$node_modules$three_stdlib$nodes$utils$ColorSpaceNode\");TextureCubeUVNode.Nodes=function(){var TextureCubeUVData=new _StructNode.StructNode(\"struct TextureCubeUVData {\\n\\t\\t\\tvec4 tl;\\n\\t\\t\\tvec4 tr;\\n\\t\\t\\tvec4 br;\\n\\t\\t\\tvec4 bl;\\n\\t\\t\\tvec2 f;\\n\\t\\t}\"),cubeUV_maxMipLevel=new _ConstNode.ConstNode(\"float cubeUV_maxMipLevel 8.0\",!0),cubeUV_minMipLevel=new _ConstNode.ConstNode(\"float cubeUV_minMipLevel 4.0\",!0),cubeUV_maxTileSize=new _ConstNode.ConstNode(\"float cubeUV_maxTileSize 256.0\",\n!0),cubeUV_minTileSize=new _ConstNode.ConstNode(\"float cubeUV_minTileSize 16.0\",!0),getFace=new _FunctionNode.FunctionNode(\"float getFace(vec3 direction) {\\n\\t\\t\\t\\tvec3 absDirection \\x3d abs(direction);\\n\\t\\t\\t\\tfloat face \\x3d -1.0;\\n\\t\\t\\t\\tif (absDirection.x \\x3e absDirection.z) {\\n\\t\\t\\t\\t\\tif (absDirection.x \\x3e absDirection.y)\\n\\t\\t\\t\\t\\t\\tface \\x3d direction.x \\x3e 0.0 ? 0.0 : 3.0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tface \\x3d direction.y \\x3e 0.0 ? 1.0 : 4.0;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (absDirection.z \\x3e absDirection.y)\\n\\t\\t\\t\\t\\t\\tface \\x3d direction.z \\x3e 0.0 ? 2.0 : 5.0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tface \\x3d direction.y \\x3e 0.0 ? 1.0 : 4.0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn face;\\n\\t\\t}\");\ngetFace.useKeywords=!1;var getUV=new _FunctionNode.FunctionNode(\"vec2 getUV(vec3 direction, float face) {\\n\\t\\t\\t\\tvec2 uv;\\n\\t\\t\\t\\tif (face \\x3d\\x3d 0.0) {\\n\\t\\t\\t\\t\\tuv \\x3d vec2(direction.z, direction.y) / abs(direction.x); // pos x\\n\\t\\t\\t\\t} else if (face \\x3d\\x3d 1.0) {\\n\\t\\t\\t\\t\\tuv \\x3d vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\\n\\t\\t\\t\\t} else if (face \\x3d\\x3d 2.0) {\\n\\t\\t\\t\\t\\tuv \\x3d vec2(-direction.x, direction.y) / abs(direction.z); // pos z\\n\\t\\t\\t\\t} else if (face \\x3d\\x3d 3.0) {\\n\\t\\t\\t\\t\\tuv \\x3d vec2(-direction.z, direction.y) / abs(direction.x); // neg x\\n\\t\\t\\t\\t} else if (face \\x3d\\x3d 4.0) {\\n\\t\\t\\t\\t\\tuv \\x3d vec2(-direction.x, direction.z) / abs(direction.y); // neg y\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tuv \\x3d vec2(direction.x, direction.y) / abs(direction.z); // neg z\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn 0.5 * (uv + 1.0);\\n\\t\\t}\");\ngetUV.useKeywords=!1;TextureCubeUVData=new _FunctionNode.FunctionNode(\"TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\\n\\n\\t\\t\\tfloat face \\x3d getFace(direction);\\n\\t\\t\\tfloat filterInt \\x3d max(cubeUV_minMipLevel - mipInt, 0.0);\\n\\t\\t\\tmipInt \\x3d max(mipInt, cubeUV_minMipLevel);\\n\\t\\t\\tfloat faceSize \\x3d exp2(mipInt);\\n\\n\\t\\t\\tfloat texelSize \\x3d 1.0 / (3.0 * cubeUV_maxTileSize);\\n\\n\\t\\t\\tvec2 uv \\x3d getUV(direction, face) * (faceSize - 1.0);\\n\\t\\t\\tvec2 f \\x3d fract(uv);\\n\\t\\t\\tuv +\\x3d 0.5 - f;\\n\\t\\t\\tif (face \\x3e 2.0) {\\n\\t\\t\\t\\tuv.y +\\x3d faceSize;\\n\\t\\t\\t\\tface -\\x3d 3.0;\\n\\t\\t\\t}\\n\\t\\t\\tuv.x +\\x3d face * faceSize;\\n\\t\\t\\tif(mipInt \\x3c cubeUV_maxMipLevel){\\n\\t\\t\\t\\tuv.y +\\x3d 2.0 * cubeUV_maxTileSize;\\n\\t\\t\\t}\\n\\t\\t\\tuv.y +\\x3d filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\t\\tuv.x +\\x3d 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\\n\\t\\t\\tuv *\\x3d texelSize;\\n\\n\\t\\t\\tvec4 tl \\x3d texture2D(envMap, uv);\\n\\t\\t\\tuv.x +\\x3d texelSize;\\n\\t\\t\\tvec4 tr \\x3d texture2D(envMap, uv);\\n\\t\\t\\tuv.y +\\x3d texelSize;\\n\\t\\t\\tvec4 br \\x3d texture2D(envMap, uv);\\n\\t\\t\\tuv.x -\\x3d texelSize;\\n\\t\\t\\tvec4 bl \\x3d texture2D(envMap, uv);\\n\\n\\t\\t\\treturn TextureCubeUVData( tl, tr, br, bl, f );\\n\\t\\t}\",\n[TextureCubeUVData,getFace,getUV,cubeUV_maxMipLevel,cubeUV_minMipLevel,cubeUV_maxTileSize,cubeUV_minTileSize]);TextureCubeUVData.useKeywords=!1;cubeUV_maxTileSize=new _ConstNode.ConstNode(\"float r0 1.0\",!0);cubeUV_minTileSize=new _ConstNode.ConstNode(\"float v0 0.339\",!0);cubeUV_minMipLevel=new _ConstNode.ConstNode(\"float m0 -2.0\",!0);getFace=new _ConstNode.ConstNode(\"float r1 0.8\",!0);getUV=new _ConstNode.ConstNode(\"float v1 0.276\",!0);var m1=new _ConstNode.ConstNode(\"float m1 -1.0\",!0),r4=new _ConstNode.ConstNode(\"float r4 0.4\",\n!0),v4=new _ConstNode.ConstNode(\"float v4 0.046\",!0),m4=new _ConstNode.ConstNode(\"float m4 2.0\",!0),r5=new _ConstNode.ConstNode(\"float r5 0.305\",!0),v5=new _ConstNode.ConstNode(\"float v5 0.016\",!0),m5=new _ConstNode.ConstNode(\"float m5 3.0\",!0),r6=new _ConstNode.ConstNode(\"float r6 0.21\",!0),v6=new _ConstNode.ConstNode(\"float v6 0.0038\",!0),m6=new _ConstNode.ConstNode(\"float m6 4.0\",!0);cubeUV_maxTileSize=new _FunctionNode.FunctionNode(\"float roughnessToMip(float roughness) {\\n\\t\\t\\tfloat mip \\x3d 0.0;\\n\\t\\t\\tif (roughness \\x3e\\x3d r1) {\\n\\t\\t\\t\\tmip \\x3d (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\\n\\t\\t\\t} else if (roughness \\x3e\\x3d r4) {\\n\\t\\t\\t\\tmip \\x3d (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\\n\\t\\t\\t} else if (roughness \\x3e\\x3d r5) {\\n\\t\\t\\t\\tmip \\x3d (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\\n\\t\\t\\t} else if (roughness \\x3e\\x3d r6) {\\n\\t\\t\\t\\tmip \\x3d (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmip \\x3d -2.0 * log2(1.16 * roughness);// 1.16 \\x3d 1.79^0.25\\n\\t\\t\\t}\\n\\t\\t\\treturn mip;\\n\\t\\t}\",\n[cubeUV_maxTileSize,cubeUV_minTileSize,cubeUV_minMipLevel,getFace,getUV,m1,r4,v4,m4,r5,v5,m5,r6,v6,m6]);return{bilinearCubeUV:TextureCubeUVData,roughnessToMip:cubeUV_maxTileSize,m0:cubeUV_minMipLevel,cubeUV_maxMipLevel}}();TextureCubeUVNode.prototype=Object.create(_TempNode.TempNode.prototype);TextureCubeUVNode.prototype.constructor=TextureCubeUVNode;TextureCubeUVNode.prototype.nodeType=\"TextureCubeUV\";TextureCubeUVNode.prototype.bilinearCubeUV=function(builder,texture,uv,mipInt){texture=new _FunctionCallNode.FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV,\n[texture,uv,mipInt]);this.colorSpaceTL=this.colorSpaceTL||new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode(\"\",\"v4\"));this.colorSpaceTL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));this.colorSpaceTL.input.parse(texture.build(builder)+\".tl\");this.colorSpaceTR=this.colorSpaceTR||new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode(\"\",\"v4\"));this.colorSpaceTR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));this.colorSpaceTR.input.parse(texture.build(builder)+\n\".tr\");this.colorSpaceBL=this.colorSpaceBL||new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode(\"\",\"v4\"));this.colorSpaceBL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));this.colorSpaceBL.input.parse(texture.build(builder)+\".bl\");this.colorSpaceBR=this.colorSpaceBR||new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode(\"\",\"v4\"));this.colorSpaceBR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));this.colorSpaceBR.input.parse(texture.build(builder)+\n\".br\");uv={include:builder.isShader(\"vertex\"),ignoreCache:!0};builder.addContext(uv);this.colorSpaceTLExp=new _ExpressionNode.ExpressionNode(this.colorSpaceTL.build(builder,\"v4\"),\"v4\");this.colorSpaceTRExp=new _ExpressionNode.ExpressionNode(this.colorSpaceTR.build(builder,\"v4\"),\"v4\");this.colorSpaceBLExp=new _ExpressionNode.ExpressionNode(this.colorSpaceBL.build(builder,\"v4\"),\"v4\");this.colorSpaceBRExp=new _ExpressionNode.ExpressionNode(this.colorSpaceBR.build(builder,\"v4\"),\"v4\");builder.removeContext();\nbuilder=new _ExpressionNode.ExpressionNode(\"mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )\",\"v4\");builder.keywords.cubeUV_TL=this.colorSpaceTLExp;builder.keywords.cubeUV_TR=this.colorSpaceTRExp;builder.keywords.cubeUV_BL=this.colorSpaceBLExp;builder.keywords.cubeUV_BR=this.colorSpaceBRExp;builder.keywords.cubeUV=texture;return builder};TextureCubeUVNode.prototype.generate=function(builder,output){if(builder.isShader(\"fragment\")){var uv=this.uv,\nmipV=new _FunctionCallNode.FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip,[this.bias||builder.context.roughness]),mip=new _MathNode.MathNode(mipV,TextureCubeUVNode.Nodes.m0,TextureCubeUVNode.Nodes.cubeUV_maxMipLevel,_MathNode.MathNode.CLAMP);mipV=new _MathNode.MathNode(mip,_MathNode.MathNode.FLOOR);mip=new _MathNode.MathNode(mip,_MathNode.MathNode.FRACT);var color0=this.bilinearCubeUV(builder,this.value,uv,mipV);uv=this.bilinearCubeUV(builder,this.value,uv,new _OperatorNode.OperatorNode(mipV,\n(new _FloatNode.FloatNode(1)).setReadonly(!0),_OperatorNode.OperatorNode.ADD));uv=new _MathNode.MathNode(color0,uv,mip,_MathNode.MathNode.MIX);return builder.format(uv.build(builder),\"v4\",output)}console.warn(\"THREE.TextureCubeUVNode is not compatible with \"+builder.shader+\" shader.\");return builder.format(\"vec4( 0.0 )\",this.getType(builder),output)};TextureCubeUVNode.prototype.toJSON=function(meta){var data=this.getJSONNode(meta);data||(data=this.createJSONNode(meta),data.value=this.value.toJSON(meta).uuid,\ndata.uv=this.uv.toJSON(meta).uuid,data.bias=this.bias.toJSON(meta).uuid);return data}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$nodes$misc$TextureCubeUVNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TextureCubeUVNode = TextureCubeUVNode;\n\nvar _TempNode = require(\"../core/TempNode.js\");\n\nvar _ConstNode = require(\"../core/ConstNode.js\");\n\nvar _StructNode = require(\"../core/StructNode.js\");\n\nvar _FunctionNode = require(\"../core/FunctionNode.js\");\n\nvar _FunctionCallNode = require(\"../core/FunctionCallNode.js\");\n\nvar _ExpressionNode = require(\"../core/ExpressionNode.js\");\n\nvar _FloatNode = require(\"../inputs/FloatNode.js\");\n\nvar _OperatorNode = require(\"../math/OperatorNode.js\");\n\nvar _MathNode = require(\"../math/MathNode.js\");\n\nvar _ColorSpaceNode = require(\"../utils/ColorSpaceNode.js\");\n\nfunction TextureCubeUVNode(value, uv, bias) {\n  _TempNode.TempNode.call(this, 'v4');\n\n  this.value = value, this.uv = uv;\n  this.bias = bias;\n}\n\nTextureCubeUVNode.Nodes = function () {\n  var TextureCubeUVData = new _StructNode.StructNode(\"struct TextureCubeUVData {\\n\\t\\t\\tvec4 tl;\\n\\t\\t\\tvec4 tr;\\n\\t\\t\\tvec4 br;\\n\\t\\t\\tvec4 bl;\\n\\t\\t\\tvec2 f;\\n\\t\\t}\");\n  var cubeUV_maxMipLevel = new _ConstNode.ConstNode('float cubeUV_maxMipLevel 8.0', true);\n  var cubeUV_minMipLevel = new _ConstNode.ConstNode('float cubeUV_minMipLevel 4.0', true);\n  var cubeUV_maxTileSize = new _ConstNode.ConstNode('float cubeUV_maxTileSize 256.0', true);\n  var cubeUV_minTileSize = new _ConstNode.ConstNode('float cubeUV_minTileSize 16.0', true); // These shader functions convert between the UV coordinates of a single face of\n  // a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n  // sampling a textureCube (not generally normalized).\n\n  var getFace = new _FunctionNode.FunctionNode(\"float getFace(vec3 direction) {\\n\\t\\t\\t\\tvec3 absDirection = abs(direction);\\n\\t\\t\\t\\tfloat face = -1.0;\\n\\t\\t\\t\\tif (absDirection.x > absDirection.z) {\\n\\t\\t\\t\\t\\tif (absDirection.x > absDirection.y)\\n\\t\\t\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (absDirection.z > absDirection.y)\\n\\t\\t\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn face;\\n\\t\\t}\");\n  getFace.useKeywords = false;\n  var getUV = new _FunctionNode.FunctionNode(\"vec2 getUV(vec3 direction, float face) {\\n\\t\\t\\t\\tvec2 uv;\\n\\t\\t\\t\\tif (face == 0.0) {\\n\\t\\t\\t\\t\\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\\n\\t\\t\\t\\t} else if (face == 1.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\\n\\t\\t\\t\\t} else if (face == 2.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\\n\\t\\t\\t\\t} else if (face == 3.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\\n\\t\\t\\t\\t} else if (face == 4.0) {\\n\\t\\t\\t\\t\\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn 0.5 * (uv + 1.0);\\n\\t\\t}\");\n  getUV.useKeywords = false;\n  var bilinearCubeUV = new _FunctionNode.FunctionNode(\"TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\\n\\n\\t\\t\\tfloat face = getFace(direction);\\n\\t\\t\\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\\n\\t\\t\\tmipInt = max(mipInt, cubeUV_minMipLevel);\\n\\t\\t\\tfloat faceSize = exp2(mipInt);\\n\\n\\t\\t\\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\\n\\n\\t\\t\\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\\n\\t\\t\\tvec2 f = fract(uv);\\n\\t\\t\\tuv += 0.5 - f;\\n\\t\\t\\tif (face > 2.0) {\\n\\t\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\t\\tface -= 3.0;\\n\\t\\t\\t}\\n\\t\\t\\tuv.x += face * faceSize;\\n\\t\\t\\tif(mipInt < cubeUV_maxMipLevel){\\n\\t\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t\\t}\\n\\t\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\t\\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\\n\\t\\t\\tuv *= texelSize;\\n\\n\\t\\t\\tvec4 tl = texture2D(envMap, uv);\\n\\t\\t\\tuv.x += texelSize;\\n\\t\\t\\tvec4 tr = texture2D(envMap, uv);\\n\\t\\t\\tuv.y += texelSize;\\n\\t\\t\\tvec4 br = texture2D(envMap, uv);\\n\\t\\t\\tuv.x -= texelSize;\\n\\t\\t\\tvec4 bl = texture2D(envMap, uv);\\n\\n\\t\\t\\treturn TextureCubeUVData( tl, tr, br, bl, f );\\n\\t\\t}\", [TextureCubeUVData, getFace, getUV, cubeUV_maxMipLevel, cubeUV_minMipLevel, cubeUV_maxTileSize, cubeUV_minTileSize]);\n  bilinearCubeUV.useKeywords = false; // These defines must match with PMREMGenerator\n\n  var r0 = new _ConstNode.ConstNode('float r0 1.0', true);\n  var v0 = new _ConstNode.ConstNode('float v0 0.339', true);\n  var m0 = new _ConstNode.ConstNode('float m0 -2.0', true);\n  var r1 = new _ConstNode.ConstNode('float r1 0.8', true);\n  var v1 = new _ConstNode.ConstNode('float v1 0.276', true);\n  var m1 = new _ConstNode.ConstNode('float m1 -1.0', true);\n  var r4 = new _ConstNode.ConstNode('float r4 0.4', true);\n  var v4 = new _ConstNode.ConstNode('float v4 0.046', true);\n  var m4 = new _ConstNode.ConstNode('float m4 2.0', true);\n  var r5 = new _ConstNode.ConstNode('float r5 0.305', true);\n  var v5 = new _ConstNode.ConstNode('float v5 0.016', true);\n  var m5 = new _ConstNode.ConstNode('float m5 3.0', true);\n  var r6 = new _ConstNode.ConstNode('float r6 0.21', true);\n  var v6 = new _ConstNode.ConstNode('float v6 0.0038', true);\n  var m6 = new _ConstNode.ConstNode('float m6 4.0', true);\n  var defines = [r0, v0, m0, r1, v1, m1, r4, v4, m4, r5, v5, m5, r6, v6, m6];\n  var roughnessToMip = new _FunctionNode.FunctionNode(\"float roughnessToMip(float roughness) {\\n\\t\\t\\tfloat mip = 0.0;\\n\\t\\t\\tif (roughness >= r1) {\\n\\t\\t\\t\\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\\n\\t\\t\\t} else if (roughness >= r4) {\\n\\t\\t\\t\\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\\n\\t\\t\\t} else if (roughness >= r5) {\\n\\t\\t\\t\\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\\n\\t\\t\\t} else if (roughness >= r6) {\\n\\t\\t\\t\\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\\n\\t\\t\\t}\\n\\t\\t\\treturn mip;\\n\\t\\t}\", defines);\n  return {\n    bilinearCubeUV: bilinearCubeUV,\n    roughnessToMip: roughnessToMip,\n    m0: m0,\n    cubeUV_maxMipLevel: cubeUV_maxMipLevel\n  };\n}();\n\nTextureCubeUVNode.prototype = Object.create(_TempNode.TempNode.prototype);\nTextureCubeUVNode.prototype.constructor = TextureCubeUVNode;\nTextureCubeUVNode.prototype.nodeType = 'TextureCubeUV';\n\nTextureCubeUVNode.prototype.bilinearCubeUV = function (builder, texture, uv, mipInt) {\n  var bilinearCubeUV = new _FunctionCallNode.FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV, [texture, uv, mipInt]);\n  this.colorSpaceTL = this.colorSpaceTL || new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode('', 'v4'));\n  this.colorSpaceTL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTL.input.parse(bilinearCubeUV.build(builder) + '.tl');\n  this.colorSpaceTR = this.colorSpaceTR || new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode('', 'v4'));\n  this.colorSpaceTR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceTR.input.parse(bilinearCubeUV.build(builder) + '.tr');\n  this.colorSpaceBL = this.colorSpaceBL || new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode('', 'v4'));\n  this.colorSpaceBL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBL.input.parse(bilinearCubeUV.build(builder) + '.bl');\n  this.colorSpaceBR = this.colorSpaceBR || new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode('', 'v4'));\n  this.colorSpaceBR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n  this.colorSpaceBR.input.parse(bilinearCubeUV.build(builder) + '.br'); // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create temp variables nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  builder.addContext(context);\n  this.colorSpaceTLExp = new _ExpressionNode.ExpressionNode(this.colorSpaceTL.build(builder, 'v4'), 'v4');\n  this.colorSpaceTRExp = new _ExpressionNode.ExpressionNode(this.colorSpaceTR.build(builder, 'v4'), 'v4');\n  this.colorSpaceBLExp = new _ExpressionNode.ExpressionNode(this.colorSpaceBL.build(builder, 'v4'), 'v4');\n  this.colorSpaceBRExp = new _ExpressionNode.ExpressionNode(this.colorSpaceBR.build(builder, 'v4'), 'v4'); // end custom context\n\n  builder.removeContext(); // --\n\n  var output = new _ExpressionNode.ExpressionNode('mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )', 'v4');\n  output.keywords['cubeUV_TL'] = this.colorSpaceTLExp;\n  output.keywords['cubeUV_TR'] = this.colorSpaceTRExp;\n  output.keywords['cubeUV_BL'] = this.colorSpaceBLExp;\n  output.keywords['cubeUV_BR'] = this.colorSpaceBRExp;\n  output.keywords['cubeUV'] = bilinearCubeUV;\n  return output;\n};\n\nTextureCubeUVNode.prototype.generate = function (builder, output) {\n  if (builder.isShader('fragment')) {\n    var uv = this.uv;\n    var bias = this.bias || builder.context.roughness;\n    var mipV = new _FunctionCallNode.FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip, [bias]);\n    var mip = new _MathNode.MathNode(mipV, TextureCubeUVNode.Nodes.m0, TextureCubeUVNode.Nodes.cubeUV_maxMipLevel, _MathNode.MathNode.CLAMP);\n    var mipInt = new _MathNode.MathNode(mip, _MathNode.MathNode.FLOOR);\n    var mipF = new _MathNode.MathNode(mip, _MathNode.MathNode.FRACT);\n    var color0 = this.bilinearCubeUV(builder, this.value, uv, mipInt);\n    var color1 = this.bilinearCubeUV(builder, this.value, uv, new _OperatorNode.OperatorNode(mipInt, new _FloatNode.FloatNode(1).setReadonly(true), _OperatorNode.OperatorNode.ADD));\n    var color1Mix = new _MathNode.MathNode(color0, color1, mipF, _MathNode.MathNode.MIX);\n    /*\n    // TODO: Optimize this in the future\n    var cond = new CondNode(\n    mipF,\n    new FloatNode( 0 ).setReadonly( true ),\n    CondNode.EQUAL,\n    color0, // if\n    color1Mix\t// else\n    );\n    */\n\n    return builder.format(color1Mix.build(builder), 'v4', output);\n  } else {\n    console.warn('THREE.TextureCubeUVNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec4( 0.0 )', this.getType(builder), output);\n  }\n};\n\nTextureCubeUVNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.toJSON(meta).uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    data.bias = this.bias.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three_stdlib$nodes$core$FunctionNode","~$module$node_modules$three_stdlib$nodes$core$FunctionCallNode","~$module$node_modules$three_stdlib$nodes$core$StructNode","~$shadow.js","~$module$node_modules$three_stdlib$nodes$math$MathNode","~$module$node_modules$three_stdlib$nodes$inputs$FloatNode","~$module$node_modules$three_stdlib$nodes$utils$ColorSpaceNode","~$module$node_modules$three_stdlib$nodes$math$OperatorNode","~$module$node_modules$three_stdlib$nodes$core$ExpressionNode","~$module$node_modules$three_stdlib$nodes$core$ConstNode","~$module$node_modules$three_stdlib$nodes$core$TempNode"]],"~:properties",["^5",["colorSpaceTR","Nodes","prototype","__esModule","useKeywords","generate","colorSpaceTLExp","colorSpaceBRExp","colorSpaceBLExp","roughnessToMip","m0","colorSpaceTRExp","nodeType","value","colorSpaceBR","include","uv","ignoreCache","cubeUV_maxMipLevel","bias","bilinearCubeUV","colorSpaceBL","TextureCubeUVNode","constructor","toJSON","colorSpaceTL"]],"~:compiled-at",1630917515212,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$nodes$misc$TextureCubeUVNode.js\",\n\"lineCount\":16,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/nodes/misc/TextureCubeUVNode.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$nodes$misc$TextureCubeUVNode\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.TextureCubeUVNode = TextureCubeUVNode;\\n\\nvar _TempNode = require(\\\"../core/TempNode.js\\\");\\n\\nvar _ConstNode = require(\\\"../core/ConstNode.js\\\");\\n\\nvar _StructNode = require(\\\"../core/StructNode.js\\\");\\n\\nvar _FunctionNode = require(\\\"../core/FunctionNode.js\\\");\\n\\nvar _FunctionCallNode = require(\\\"../core/FunctionCallNode.js\\\");\\n\\nvar _ExpressionNode = require(\\\"../core/ExpressionNode.js\\\");\\n\\nvar _FloatNode = require(\\\"../inputs/FloatNode.js\\\");\\n\\nvar _OperatorNode = require(\\\"../math/OperatorNode.js\\\");\\n\\nvar _MathNode = require(\\\"../math/MathNode.js\\\");\\n\\nvar _ColorSpaceNode = require(\\\"../utils/ColorSpaceNode.js\\\");\\n\\nfunction TextureCubeUVNode(value, uv, bias) {\\n  _TempNode.TempNode.call(this, 'v4');\\n\\n  this.value = value, this.uv = uv;\\n  this.bias = bias;\\n}\\n\\nTextureCubeUVNode.Nodes = function () {\\n  var TextureCubeUVData = new _StructNode.StructNode(\\\"struct TextureCubeUVData {\\\\n\\\\t\\\\t\\\\tvec4 tl;\\\\n\\\\t\\\\t\\\\tvec4 tr;\\\\n\\\\t\\\\t\\\\tvec4 br;\\\\n\\\\t\\\\t\\\\tvec4 bl;\\\\n\\\\t\\\\t\\\\tvec2 f;\\\\n\\\\t\\\\t}\\\");\\n  var cubeUV_maxMipLevel = new _ConstNode.ConstNode('float cubeUV_maxMipLevel 8.0', true);\\n  var cubeUV_minMipLevel = new _ConstNode.ConstNode('float cubeUV_minMipLevel 4.0', true);\\n  var cubeUV_maxTileSize = new _ConstNode.ConstNode('float cubeUV_maxTileSize 256.0', true);\\n  var cubeUV_minTileSize = new _ConstNode.ConstNode('float cubeUV_minTileSize 16.0', true); // These shader functions convert between the UV coordinates of a single face of\\n  // a cubemap, the 0-5 integer index of a cube face, and the direction vector for\\n  // sampling a textureCube (not generally normalized).\\n\\n  var getFace = new _FunctionNode.FunctionNode(\\\"float getFace(vec3 direction) {\\\\n\\\\t\\\\t\\\\t\\\\tvec3 absDirection = abs(direction);\\\\n\\\\t\\\\t\\\\t\\\\tfloat face = -1.0;\\\\n\\\\t\\\\t\\\\t\\\\tif (absDirection.x > absDirection.z) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tif (absDirection.x > absDirection.y)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\\\n\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tif (absDirection.z > absDirection.y)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\treturn face;\\\\n\\\\t\\\\t}\\\");\\n  getFace.useKeywords = false;\\n  var getUV = new _FunctionNode.FunctionNode(\\\"vec2 getUV(vec3 direction, float face) {\\\\n\\\\t\\\\t\\\\t\\\\tvec2 uv;\\\\n\\\\t\\\\t\\\\t\\\\tif (face == 0.0) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tuv = vec2(direction.z, direction.y) / abs(direction.x); // pos x\\\\n\\\\t\\\\t\\\\t\\\\t} else if (face == 1.0) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tuv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y\\\\n\\\\t\\\\t\\\\t\\\\t} else if (face == 2.0) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tuv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z\\\\n\\\\t\\\\t\\\\t\\\\t} else if (face == 3.0) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tuv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x\\\\n\\\\t\\\\t\\\\t\\\\t} else if (face == 4.0) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tuv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y\\\\n\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tuv = vec2(direction.x, direction.y) / abs(direction.z); // neg z\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\treturn 0.5 * (uv + 1.0);\\\\n\\\\t\\\\t}\\\");\\n  getUV.useKeywords = false;\\n  var bilinearCubeUV = new _FunctionNode.FunctionNode(\\\"TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\\\\n\\\\n\\\\t\\\\t\\\\tfloat face = getFace(direction);\\\\n\\\\t\\\\t\\\\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\\\\n\\\\t\\\\t\\\\tmipInt = max(mipInt, cubeUV_minMipLevel);\\\\n\\\\t\\\\t\\\\tfloat faceSize = exp2(mipInt);\\\\n\\\\n\\\\t\\\\t\\\\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\\\\n\\\\n\\\\t\\\\t\\\\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\\\\n\\\\t\\\\t\\\\tvec2 f = fract(uv);\\\\n\\\\t\\\\t\\\\tuv += 0.5 - f;\\\\n\\\\t\\\\t\\\\tif (face > 2.0) {\\\\n\\\\t\\\\t\\\\t\\\\tuv.y += faceSize;\\\\n\\\\t\\\\t\\\\t\\\\tface -= 3.0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\tuv.x += face * faceSize;\\\\n\\\\t\\\\t\\\\tif(mipInt < cubeUV_maxMipLevel){\\\\n\\\\t\\\\t\\\\t\\\\tuv.y += 2.0 * cubeUV_maxTileSize;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\\\n\\\\t\\\\t\\\\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\\\\n\\\\t\\\\t\\\\tuv *= texelSize;\\\\n\\\\n\\\\t\\\\t\\\\tvec4 tl = texture2D(envMap, uv);\\\\n\\\\t\\\\t\\\\tuv.x += texelSize;\\\\n\\\\t\\\\t\\\\tvec4 tr = texture2D(envMap, uv);\\\\n\\\\t\\\\t\\\\tuv.y += texelSize;\\\\n\\\\t\\\\t\\\\tvec4 br = texture2D(envMap, uv);\\\\n\\\\t\\\\t\\\\tuv.x -= texelSize;\\\\n\\\\t\\\\t\\\\tvec4 bl = texture2D(envMap, uv);\\\\n\\\\n\\\\t\\\\t\\\\treturn TextureCubeUVData( tl, tr, br, bl, f );\\\\n\\\\t\\\\t}\\\", [TextureCubeUVData, getFace, getUV, cubeUV_maxMipLevel, cubeUV_minMipLevel, cubeUV_maxTileSize, cubeUV_minTileSize]);\\n  bilinearCubeUV.useKeywords = false; // These defines must match with PMREMGenerator\\n\\n  var r0 = new _ConstNode.ConstNode('float r0 1.0', true);\\n  var v0 = new _ConstNode.ConstNode('float v0 0.339', true);\\n  var m0 = new _ConstNode.ConstNode('float m0 -2.0', true);\\n  var r1 = new _ConstNode.ConstNode('float r1 0.8', true);\\n  var v1 = new _ConstNode.ConstNode('float v1 0.276', true);\\n  var m1 = new _ConstNode.ConstNode('float m1 -1.0', true);\\n  var r4 = new _ConstNode.ConstNode('float r4 0.4', true);\\n  var v4 = new _ConstNode.ConstNode('float v4 0.046', true);\\n  var m4 = new _ConstNode.ConstNode('float m4 2.0', true);\\n  var r5 = new _ConstNode.ConstNode('float r5 0.305', true);\\n  var v5 = new _ConstNode.ConstNode('float v5 0.016', true);\\n  var m5 = new _ConstNode.ConstNode('float m5 3.0', true);\\n  var r6 = new _ConstNode.ConstNode('float r6 0.21', true);\\n  var v6 = new _ConstNode.ConstNode('float v6 0.0038', true);\\n  var m6 = new _ConstNode.ConstNode('float m6 4.0', true);\\n  var defines = [r0, v0, m0, r1, v1, m1, r4, v4, m4, r5, v5, m5, r6, v6, m6];\\n  var roughnessToMip = new _FunctionNode.FunctionNode(\\\"float roughnessToMip(float roughness) {\\\\n\\\\t\\\\t\\\\tfloat mip = 0.0;\\\\n\\\\t\\\\t\\\\tif (roughness >= r1) {\\\\n\\\\t\\\\t\\\\t\\\\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\\\\n\\\\t\\\\t\\\\t} else if (roughness >= r4) {\\\\n\\\\t\\\\t\\\\t\\\\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\\\\n\\\\t\\\\t\\\\t} else if (roughness >= r5) {\\\\n\\\\t\\\\t\\\\t\\\\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\\\\n\\\\t\\\\t\\\\t} else if (roughness >= r6) {\\\\n\\\\t\\\\t\\\\t\\\\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\\\\n\\\\t\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\t\\\\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\treturn mip;\\\\n\\\\t\\\\t}\\\", defines);\\n  return {\\n    bilinearCubeUV: bilinearCubeUV,\\n    roughnessToMip: roughnessToMip,\\n    m0: m0,\\n    cubeUV_maxMipLevel: cubeUV_maxMipLevel\\n  };\\n}();\\n\\nTextureCubeUVNode.prototype = Object.create(_TempNode.TempNode.prototype);\\nTextureCubeUVNode.prototype.constructor = TextureCubeUVNode;\\nTextureCubeUVNode.prototype.nodeType = 'TextureCubeUV';\\n\\nTextureCubeUVNode.prototype.bilinearCubeUV = function (builder, texture, uv, mipInt) {\\n  var bilinearCubeUV = new _FunctionCallNode.FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV, [texture, uv, mipInt]);\\n  this.colorSpaceTL = this.colorSpaceTL || new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode('', 'v4'));\\n  this.colorSpaceTL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\\n  this.colorSpaceTL.input.parse(bilinearCubeUV.build(builder) + '.tl');\\n  this.colorSpaceTR = this.colorSpaceTR || new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode('', 'v4'));\\n  this.colorSpaceTR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\\n  this.colorSpaceTR.input.parse(bilinearCubeUV.build(builder) + '.tr');\\n  this.colorSpaceBL = this.colorSpaceBL || new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode('', 'v4'));\\n  this.colorSpaceBL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\\n  this.colorSpaceBL.input.parse(bilinearCubeUV.build(builder) + '.bl');\\n  this.colorSpaceBR = this.colorSpaceBR || new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode('', 'v4'));\\n  this.colorSpaceBR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\\n  this.colorSpaceBR.input.parse(bilinearCubeUV.build(builder) + '.br'); // add a custom context for fix incompatibility with the core\\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\\n  // this should be removed in the future\\n  // context.include =: is used to include or not functions if used FunctionNode\\n  // context.ignoreCache =: not create temp variables nodeT0..9 to optimize the code\\n\\n  var context = {\\n    include: builder.isShader('vertex'),\\n    ignoreCache: true\\n  };\\n  builder.addContext(context);\\n  this.colorSpaceTLExp = new _ExpressionNode.ExpressionNode(this.colorSpaceTL.build(builder, 'v4'), 'v4');\\n  this.colorSpaceTRExp = new _ExpressionNode.ExpressionNode(this.colorSpaceTR.build(builder, 'v4'), 'v4');\\n  this.colorSpaceBLExp = new _ExpressionNode.ExpressionNode(this.colorSpaceBL.build(builder, 'v4'), 'v4');\\n  this.colorSpaceBRExp = new _ExpressionNode.ExpressionNode(this.colorSpaceBR.build(builder, 'v4'), 'v4'); // end custom context\\n\\n  builder.removeContext(); // --\\n\\n  var output = new _ExpressionNode.ExpressionNode('mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )', 'v4');\\n  output.keywords['cubeUV_TL'] = this.colorSpaceTLExp;\\n  output.keywords['cubeUV_TR'] = this.colorSpaceTRExp;\\n  output.keywords['cubeUV_BL'] = this.colorSpaceBLExp;\\n  output.keywords['cubeUV_BR'] = this.colorSpaceBRExp;\\n  output.keywords['cubeUV'] = bilinearCubeUV;\\n  return output;\\n};\\n\\nTextureCubeUVNode.prototype.generate = function (builder, output) {\\n  if (builder.isShader('fragment')) {\\n    var uv = this.uv;\\n    var bias = this.bias || builder.context.roughness;\\n    var mipV = new _FunctionCallNode.FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip, [bias]);\\n    var mip = new _MathNode.MathNode(mipV, TextureCubeUVNode.Nodes.m0, TextureCubeUVNode.Nodes.cubeUV_maxMipLevel, _MathNode.MathNode.CLAMP);\\n    var mipInt = new _MathNode.MathNode(mip, _MathNode.MathNode.FLOOR);\\n    var mipF = new _MathNode.MathNode(mip, _MathNode.MathNode.FRACT);\\n    var color0 = this.bilinearCubeUV(builder, this.value, uv, mipInt);\\n    var color1 = this.bilinearCubeUV(builder, this.value, uv, new _OperatorNode.OperatorNode(mipInt, new _FloatNode.FloatNode(1).setReadonly(true), _OperatorNode.OperatorNode.ADD));\\n    var color1Mix = new _MathNode.MathNode(color0, color1, mipF, _MathNode.MathNode.MIX);\\n    /*\\n    // TODO: Optimize this in the future\\n    var cond = new CondNode(\\n    mipF,\\n    new FloatNode( 0 ).setReadonly( true ),\\n    CondNode.EQUAL,\\n    color0, // if\\n    color1Mix\\t// else\\n    );\\n    */\\n\\n    return builder.format(color1Mix.build(builder), 'v4', output);\\n  } else {\\n    console.warn('THREE.TextureCubeUVNode is not compatible with ' + builder.shader + ' shader.');\\n    return builder.format('vec4( 0.0 )', this.getType(builder), output);\\n  }\\n};\\n\\nTextureCubeUVNode.prototype.toJSON = function (meta) {\\n  var data = this.getJSONNode(meta);\\n\\n  if (!data) {\\n    data = this.createJSONNode(meta);\\n    data.value = this.value.toJSON(meta).uuid;\\n    data.uv = this.uv.toJSON(meta).uuid;\\n    data.bias = this.bias.toJSON(meta).uuid;\\n  }\\n\\n  return data;\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"TextureCubeUVNode\",\"value\",\"uv\",\"bias\",\"_TempNode\",\"TempNode\",\"call\",\"Object\",\"defineProperty\",\"_ConstNode\",\"_StructNode\",\"_FunctionNode\",\"_FunctionCallNode\",\"_ExpressionNode\",\"_FloatNode\",\"_OperatorNode\",\"_MathNode\",\"_ColorSpaceNode\",\"Nodes\",\"TextureCubeUVData\",\"StructNode\",\"cubeUV_maxMipLevel\",\"ConstNode\",\"cubeUV_minMipLevel\",\"cubeUV_maxTileSize\",\"cubeUV_minTileSize\",\"getFace\",\"FunctionNode\",\"useKeywords\",\"getUV\",\"bilinearCubeUV\",\"r0\",\"v0\",\"m0\",\"r1\",\"v1\",\"m1\",\"r4\",\"v4\",\"m4\",\"r5\",\"v5\",\"m5\",\"r6\",\"v6\",\"m6\",\"roughnessToMip\",\"defines\",\"prototype\",\"create\",\"constructor\",\"nodeType\",\"TextureCubeUVNode.prototype.bilinearCubeUV\",\"builder\",\"texture\",\"mipInt\",\"FunctionCallNode\",\"colorSpaceTL\",\"ColorSpaceNode\",\"ExpressionNode\",\"fromDecoding\",\"getTextureEncodingFromMap\",\"input\",\"parse\",\"build\",\"colorSpaceTR\",\"colorSpaceBL\",\"colorSpaceBR\",\"context\",\"include\",\"isShader\",\"ignoreCache\",\"addContext\",\"colorSpaceTLExp\",\"colorSpaceTRExp\",\"colorSpaceBLExp\",\"colorSpaceBRExp\",\"removeContext\",\"output\",\"keywords\",\"generate\",\"TextureCubeUVNode.prototype.generate\",\"mipV\",\"roughness\",\"mip\",\"MathNode\",\"CLAMP\",\"FLOOR\",\"mipF\",\"FRACT\",\"color0\",\"color1\",\"OperatorNode\",\"setReadonly\",\"FloatNode\",\"ADD\",\"color1Mix\",\"MIX\",\"format\",\"console\",\"warn\",\"shader\",\"getType\",\"toJSON\",\"TextureCubeUVNode.prototype.toJSON\",\"meta\",\"data\",\"getJSONNode\",\"createJSONNode\",\"uuid\"]\n}\n"]