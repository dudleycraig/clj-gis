["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/BokehShader2.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$BokehShader2=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.BokehShader2=exports.BokehDepthShader=void 0;global={uniforms:{textureWidth:{value:1},textureHeight:{value:1},focalDepth:{value:1},focalLength:{value:24},fstop:{value:.9},tColor:{value:null},tDepth:{value:null},maxblur:{value:1},showFocus:{value:0},manualdof:{value:0},vignetting:{value:0},depthblur:{value:0},threshold:{value:.5},\ngain:{value:2},bias:{value:.5},fringe:{value:.7},znear:{value:.1},zfar:{value:100},noise:{value:1},dithering:{value:1E-4},pentagon:{value:0},shaderFocus:{value:1},focusCoords:{value:new (require(\"module$node_modules$three$build$three_module\").Vector2)}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"#include \\x3ccommon\\x3e\\nvarying vec2 vUv;\\nuniform sampler2D tColor;\\nuniform sampler2D tDepth;\\nuniform float textureWidth;\\nuniform float textureHeight;\\nuniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\\nuniform float focalLength; //focal length in mm\\nuniform float fstop; //f-stop value\\nuniform bool showFocus; //show debug focus point and focal range (red \\x3d focal point, green \\x3d focal range)\\n/*\\nmake sure that these two values are the same for your camera, otherwise distances will be wrong.\\n*/\\nuniform float znear; // camera clipping start\\nuniform float zfar; // camera clipping end\\n//------------------------------------------\\n//user variables\\nconst int samples \\x3d SAMPLES; //samples on the first ring\\nconst int rings \\x3d RINGS; //ring count\\nconst int maxringsamples \\x3d rings * samples;\\nuniform bool manualdof; // manual dof calculation\\nfloat ndofstart \\x3d 1.0; // near dof blur start\\nfloat ndofdist \\x3d 2.0; // near dof blur falloff distance\\nfloat fdofstart \\x3d 1.0; // far dof blur start\\nfloat fdofdist \\x3d 3.0; // far dof blur falloff distance\\nfloat CoC \\x3d 0.03; //circle of confusion size in mm (35mm film \\x3d 0.03mm)\\nuniform bool vignetting; // use optical lens vignetting\\nfloat vignout \\x3d 1.3; // vignetting outer border\\nfloat vignin \\x3d 0.0; // vignetting inner border\\nfloat vignfade \\x3d 22.0; // f-stops till vignete fades\\nuniform bool shaderFocus;\\n// disable if you use external focalDepth value\\nuniform vec2 focusCoords;\\n// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\\n// if center of screen use vec2(0.5, 0.5);\\nuniform float maxblur;\\n//clamp value of max blur (0.0 \\x3d no blur, 1.0 default)\\nuniform float threshold; // highlight threshold;\\nuniform float gain; // highlight gain;\\nuniform float bias; // bokeh edge bias\\nuniform float fringe; // bokeh chromatic aberration / fringing\\nuniform bool noise; //use noise instead of pattern for sample dithering\\nuniform float dithering;\\nuniform bool depthblur; // blur the depth buffer\\nfloat dbsize \\x3d 1.25; // depth blur size\\n/*\\nnext part is experimental\\nnot looking good with small sample and ring count\\nlooks okay starting from samples \\x3d 4, rings \\x3d 4\\n*/\\nuniform bool pentagon; //use pentagon as bokeh shape?\\nfloat feather \\x3d 0.4; //pentagon shape feather\\n//------------------------------------------\\nfloat penta(vec2 coords) {\\n\\t//pentagonal shape\\n\\tfloat scale \\x3d float(rings) - 1.3;\\n\\tvec4  HS0 \\x3d vec4( 1.0,         0.0,         0.0,  1.0);\\n\\tvec4  HS1 \\x3d vec4( 0.309016994, 0.951056516, 0.0,  1.0);\\n\\tvec4  HS2 \\x3d vec4(-0.809016994, 0.587785252, 0.0,  1.0);\\n\\tvec4  HS3 \\x3d vec4(-0.809016994,-0.587785252, 0.0,  1.0);\\n\\tvec4  HS4 \\x3d vec4( 0.309016994,-0.951056516, 0.0,  1.0);\\n\\tvec4  HS5 \\x3d vec4( 0.0        ,0.0         , 1.0,  1.0);\\n\\tvec4  one \\x3d vec4( 1.0 );\\n\\tvec4 P \\x3d vec4((coords),vec2(scale, scale));\\n\\tvec4 dist \\x3d vec4(0.0);\\n\\tfloat inorout \\x3d -4.0;\\n\\tdist.x \\x3d dot( P, HS0 );\\n\\tdist.y \\x3d dot( P, HS1 );\\n\\tdist.z \\x3d dot( P, HS2 );\\n\\tdist.w \\x3d dot( P, HS3 );\\n\\tdist \\x3d smoothstep( -feather, feather, dist );\\n\\tinorout +\\x3d dot( dist, one );\\n\\tdist.x \\x3d dot( P, HS4 );\\n\\tdist.y \\x3d HS5.w - abs( P.z );\\n\\tdist \\x3d smoothstep( -feather, feather, dist );\\n\\tinorout +\\x3d dist.x;\\n\\treturn clamp( inorout, 0.0, 1.0 );\\n}\\nfloat bdepth(vec2 coords) {\\n\\t// Depth buffer blur\\n\\tfloat d \\x3d 0.0;\\n\\tfloat kernel[9];\\n\\tvec2 offset[9];\\n\\tvec2 wh \\x3d vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\\n\\toffset[0] \\x3d vec2(-wh.x,-wh.y);\\n\\toffset[1] \\x3d vec2( 0.0, -wh.y);\\n\\toffset[2] \\x3d vec2( wh.x -wh.y);\\n\\toffset[3] \\x3d vec2(-wh.x,  0.0);\\n\\toffset[4] \\x3d vec2( 0.0,   0.0);\\n\\toffset[5] \\x3d vec2( wh.x,  0.0);\\n\\toffset[6] \\x3d vec2(-wh.x, wh.y);\\n\\toffset[7] \\x3d vec2( 0.0,  wh.y);\\n\\toffset[8] \\x3d vec2( wh.x, wh.y);\\n\\tkernel[0] \\x3d 1.0/16.0;   kernel[1] \\x3d 2.0/16.0;   kernel[2] \\x3d 1.0/16.0;\\n\\tkernel[3] \\x3d 2.0/16.0;   kernel[4] \\x3d 4.0/16.0;   kernel[5] \\x3d 2.0/16.0;\\n\\tkernel[6] \\x3d 1.0/16.0;   kernel[7] \\x3d 2.0/16.0;   kernel[8] \\x3d 1.0/16.0;\\n\\tfor( int i\\x3d0; i\\x3c9; i++ ) {\\n\\t\\tfloat tmp \\x3d texture2D(tDepth, coords + offset[i]).r;\\n\\t\\td +\\x3d tmp * kernel[i];\\n\\t}\\n\\treturn d;\\n}\\nvec3 color(vec2 coords,float blur) {\\n\\t//processing the sample\\n\\tvec3 col \\x3d vec3(0.0);\\n\\tvec2 texel \\x3d vec2(1.0/textureWidth,1.0/textureHeight);\\n\\tcol.r \\x3d texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\\n\\tcol.g \\x3d texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\\n\\tcol.b \\x3d texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\\n\\tvec3 lumcoeff \\x3d vec3(0.299,0.587,0.114);\\n\\tfloat lum \\x3d dot(col.rgb, lumcoeff);\\n\\tfloat thresh \\x3d max((lum-threshold)*gain, 0.0);\\n\\treturn col+mix(vec3(0.0),col,thresh*blur);\\n}\\nvec3 debugFocus(vec3 col, float blur, float depth) {\\n\\tfloat edge \\x3d 0.002*depth; //distance based edge smoothing\\n\\tfloat m \\x3d clamp(smoothstep(0.0,edge,blur),0.0,1.0);\\n\\tfloat e \\x3d clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\\n\\tcol \\x3d mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\\n\\tcol \\x3d mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\\n\\treturn col;\\n}\\nfloat linearize(float depth) {\\n\\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\\n}\\nfloat vignette() {\\n\\tfloat dist \\x3d distance(vUv.xy, vec2(0.5,0.5));\\n\\tdist \\x3d smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\\n\\treturn clamp(dist,0.0,1.0);\\n}\\nfloat gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\\n\\tfloat rings2 \\x3d float(rings);\\n\\tfloat step \\x3d PI*2.0 / float(ringsamples);\\n\\tfloat pw \\x3d cos(j*step)*i;\\n\\tfloat ph \\x3d sin(j*step)*i;\\n\\tfloat p \\x3d 1.0;\\n\\tif (pentagon) {\\n\\t\\tp \\x3d penta(vec2(pw,ph));\\n\\t}\\n\\tcol +\\x3d color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\\n\\treturn 1.0 * mix(1.0, i /rings2, bias) * p;\\n}\\nvoid main() {\\n\\t//scene depth calculation\\n\\tfloat depth \\x3d linearize(texture2D(tDepth,vUv.xy).x);\\n\\t// Blur depth?\\n\\tif ( depthblur ) {\\n\\t\\tdepth \\x3d linearize(bdepth(vUv.xy));\\n\\t}\\n\\t//focal plane calculation\\n\\tfloat fDepth \\x3d focalDepth;\\n\\tif (shaderFocus) {\\n\\t\\tfDepth \\x3d linearize(texture2D(tDepth,focusCoords).x);\\n\\t}\\n\\t// dof blur factor calculation\\n\\tfloat blur \\x3d 0.0;\\n\\tif (manualdof) {\\n\\t\\tfloat a \\x3d depth-fDepth; // Focal plane\\n\\t\\tfloat b \\x3d (a-fdofstart)/fdofdist; // Far DoF\\n\\t\\tfloat c \\x3d (-a-ndofstart)/ndofdist; // Near Dof\\n\\t\\tblur \\x3d (a\\x3e0.0) ? b : c;\\n\\t} else {\\n\\t\\tfloat f \\x3d focalLength; // focal length in mm\\n\\t\\tfloat d \\x3d fDepth*1000.0; // focal plane in mm\\n\\t\\tfloat o \\x3d depth*1000.0; // depth in mm\\n\\t\\tfloat a \\x3d (o*f)/(o-f);\\n\\t\\tfloat b \\x3d (d*f)/(d-f);\\n\\t\\tfloat c \\x3d (d-f)/(d*fstop*CoC);\\n\\t\\tblur \\x3d abs(a-b)*c;\\n\\t}\\n\\tblur \\x3d clamp(blur,0.0,1.0);\\n\\t// calculation of pattern for dithering\\n\\tvec2 noise \\x3d vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\\n\\t// getting blur x and y step factor\\n\\tfloat w \\x3d (1.0/textureWidth)*blur*maxblur+noise.x;\\n\\tfloat h \\x3d (1.0/textureHeight)*blur*maxblur+noise.y;\\n\\t// calculation of final color\\n\\tvec3 col \\x3d vec3(0.0);\\n\\tif(blur \\x3c 0.05) {\\n\\t\\t//some optimization thingy\\n\\t\\tcol \\x3d texture2D(tColor, vUv.xy).rgb;\\n\\t} else {\\n\\t\\tcol \\x3d texture2D(tColor, vUv.xy).rgb;\\n\\t\\tfloat s \\x3d 1.0;\\n\\t\\tint ringsamples;\\n\\t\\tfor (int i \\x3d 1; i \\x3c\\x3d rings; i++) {\\n\\t\\t\\t/*unboxstart*/\\n\\t\\t\\tringsamples \\x3d i * samples;\\n\\t\\t\\tfor (int j \\x3d 0 ; j \\x3c maxringsamples ; j++) {\\n\\t\\t\\t\\tif (j \\x3e\\x3d ringsamples) break;\\n\\t\\t\\t\\ts +\\x3d gather(float(i), float(j), ringsamples, col, w, h, blur);\\n\\t\\t\\t}\\n\\t\\t\\t/*unboxend*/\\n\\t\\t}\\n\\t\\tcol /\\x3d s; //divide by sample count\\n\\t}\\n\\tif (showFocus) {\\n\\t\\tcol \\x3d debugFocus(col, blur, depth);\\n\\t}\\n\\tif (vignetting) {\\n\\t\\tcol *\\x3d vignette();\\n\\t}\\n\\tgl_FragColor.rgb \\x3d col;\\n\\tgl_FragColor.a \\x3d 1.0;\\n} \"};\nexports.BokehShader2=global;exports.BokehDepthShader={uniforms:{mNear:{value:1},mFar:{value:1E3}},vertexShader:\"varying float vViewZDepth;\\nvoid main() {\\n\\t#include \\x3cbegin_vertex\\x3e\\n\\t#include \\x3cproject_vertex\\x3e\\n\\tvViewZDepth \\x3d - mvPosition.z;\\n}\",fragmentShader:\"uniform float mNear;\\nuniform float mFar;\\nvarying float vViewZDepth;\\nvoid main() {\\n\\tfloat color \\x3d 1.0 - smoothstep( mNear, mFar, vViewZDepth );\\n\\tgl_FragColor \\x3d vec4( vec3( color ), 1.0 );\\n} \"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$BokehShader2\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BokehShader2 = exports.BokehDepthShader = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\nvar BokehShader2 = {\n  uniforms: {\n    textureWidth: {\n      value: 1.0\n    },\n    textureHeight: {\n      value: 1.0\n    },\n    focalDepth: {\n      value: 1.0\n    },\n    focalLength: {\n      value: 24.0\n    },\n    fstop: {\n      value: 0.9\n    },\n    tColor: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    maxblur: {\n      value: 1.0\n    },\n    showFocus: {\n      value: 0\n    },\n    manualdof: {\n      value: 0\n    },\n    vignetting: {\n      value: 0\n    },\n    depthblur: {\n      value: 0\n    },\n    threshold: {\n      value: 0.5\n    },\n    gain: {\n      value: 2.0\n    },\n    bias: {\n      value: 0.5\n    },\n    fringe: {\n      value: 0.7\n    },\n    znear: {\n      value: 0.1\n    },\n    zfar: {\n      value: 100\n    },\n    noise: {\n      value: 1\n    },\n    dithering: {\n      value: 0.0001\n    },\n    pentagon: {\n      value: 0\n    },\n    shaderFocus: {\n      value: 1\n    },\n    focusCoords: {\n      value: new _three.Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'uniform float textureWidth;', 'uniform float textureHeight;', 'uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below', 'uniform float focalLength; //focal length in mm', 'uniform float fstop; //f-stop value', 'uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)', '/*', 'make sure that these two values are the same for your camera, otherwise distances will be wrong.', '*/', 'uniform float znear; // camera clipping start', 'uniform float zfar; // camera clipping end', '//------------------------------------------', '//user variables', 'const int samples = SAMPLES; //samples on the first ring', 'const int rings = RINGS; //ring count', 'const int maxringsamples = rings * samples;', 'uniform bool manualdof; // manual dof calculation', 'float ndofstart = 1.0; // near dof blur start', 'float ndofdist = 2.0; // near dof blur falloff distance', 'float fdofstart = 1.0; // far dof blur start', 'float fdofdist = 3.0; // far dof blur falloff distance', 'float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)', 'uniform bool vignetting; // use optical lens vignetting', 'float vignout = 1.3; // vignetting outer border', 'float vignin = 0.0; // vignetting inner border', 'float vignfade = 22.0; // f-stops till vignete fades', 'uniform bool shaderFocus;', '// disable if you use external focalDepth value', 'uniform vec2 focusCoords;', '// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)', '// if center of screen use vec2(0.5, 0.5);', 'uniform float maxblur;', '//clamp value of max blur (0.0 = no blur, 1.0 default)', 'uniform float threshold; // highlight threshold;', 'uniform float gain; // highlight gain;', 'uniform float bias; // bokeh edge bias', 'uniform float fringe; // bokeh chromatic aberration / fringing', 'uniform bool noise; //use noise instead of pattern for sample dithering', 'uniform float dithering;', 'uniform bool depthblur; // blur the depth buffer', 'float dbsize = 1.25; // depth blur size', '/*', 'next part is experimental', 'not looking good with small sample and ring count', 'looks okay starting from samples = 4, rings = 4', '*/', 'uniform bool pentagon; //use pentagon as bokeh shape?', 'float feather = 0.4; //pentagon shape feather', '//------------------------------------------', 'float penta(vec2 coords) {', '\t//pentagonal shape', '\tfloat scale = float(rings) - 1.3;', '\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);', '\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);', '\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);', '\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);', '\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);', '\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);', '\tvec4  one = vec4( 1.0 );', '\tvec4 P = vec4((coords),vec2(scale, scale));', '\tvec4 dist = vec4(0.0);', '\tfloat inorout = -4.0;', '\tdist.x = dot( P, HS0 );', '\tdist.y = dot( P, HS1 );', '\tdist.z = dot( P, HS2 );', '\tdist.w = dot( P, HS3 );', '\tdist = smoothstep( -feather, feather, dist );', '\tinorout += dot( dist, one );', '\tdist.x = dot( P, HS4 );', '\tdist.y = HS5.w - abs( P.z );', '\tdist = smoothstep( -feather, feather, dist );', '\tinorout += dist.x;', '\treturn clamp( inorout, 0.0, 1.0 );', '}', 'float bdepth(vec2 coords) {', '\t// Depth buffer blur', '\tfloat d = 0.0;', '\tfloat kernel[9];', '\tvec2 offset[9];', '\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;', '\toffset[0] = vec2(-wh.x,-wh.y);', '\toffset[1] = vec2( 0.0, -wh.y);', '\toffset[2] = vec2( wh.x -wh.y);', '\toffset[3] = vec2(-wh.x,  0.0);', '\toffset[4] = vec2( 0.0,   0.0);', '\toffset[5] = vec2( wh.x,  0.0);', '\toffset[6] = vec2(-wh.x, wh.y);', '\toffset[7] = vec2( 0.0,  wh.y);', '\toffset[8] = vec2( wh.x, wh.y);', '\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;', '\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;', '\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;', '\tfor( int i=0; i<9; i++ ) {', '\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;', '\t\td += tmp * kernel[i];', '\t}', '\treturn d;', '}', 'vec3 color(vec2 coords,float blur) {', '\t//processing the sample', '\tvec3 col = vec3(0.0);', '\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);', '\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;', '\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;', '\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;', '\tvec3 lumcoeff = vec3(0.299,0.587,0.114);', '\tfloat lum = dot(col.rgb, lumcoeff);', '\tfloat thresh = max((lum-threshold)*gain, 0.0);', '\treturn col+mix(vec3(0.0),col,thresh*blur);', '}', 'vec3 debugFocus(vec3 col, float blur, float depth) {', '\tfloat edge = 0.002*depth; //distance based edge smoothing', '\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);', '\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);', '\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);', '\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);', '\treturn col;', '}', 'float linearize(float depth) {', '\treturn -zfar * znear / (depth * (zfar - znear) - zfar);', '}', 'float vignette() {', '\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));', '\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);', '\treturn clamp(dist,0.0,1.0);', '}', 'float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {', '\tfloat rings2 = float(rings);', '\tfloat step = PI*2.0 / float(ringsamples);', '\tfloat pw = cos(j*step)*i;', '\tfloat ph = sin(j*step)*i;', '\tfloat p = 1.0;', '\tif (pentagon) {', '\t\tp = penta(vec2(pw,ph));', '\t}', '\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;', '\treturn 1.0 * mix(1.0, i /rings2, bias) * p;', '}', 'void main() {', '\t//scene depth calculation', '\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);', '\t// Blur depth?', '\tif ( depthblur ) {', '\t\tdepth = linearize(bdepth(vUv.xy));', '\t}', '\t//focal plane calculation', '\tfloat fDepth = focalDepth;', '\tif (shaderFocus) {', '\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);', '\t}', '\t// dof blur factor calculation', '\tfloat blur = 0.0;', '\tif (manualdof) {', '\t\tfloat a = depth-fDepth; // Focal plane', '\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF', '\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof', '\t\tblur = (a>0.0) ? b : c;', '\t} else {', '\t\tfloat f = focalLength; // focal length in mm', '\t\tfloat d = fDepth*1000.0; // focal plane in mm', '\t\tfloat o = depth*1000.0; // depth in mm', '\t\tfloat a = (o*f)/(o-f);', '\t\tfloat b = (d*f)/(d-f);', '\t\tfloat c = (d-f)/(d*fstop*CoC);', '\t\tblur = abs(a-b)*c;', '\t}', '\tblur = clamp(blur,0.0,1.0);', '\t// calculation of pattern for dithering', '\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;', '\t// getting blur x and y step factor', '\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;', '\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;', '\t// calculation of final color', '\tvec3 col = vec3(0.0);', '\tif(blur < 0.05) {', '\t\t//some optimization thingy', '\t\tcol = texture2D(tColor, vUv.xy).rgb;', '\t} else {', '\t\tcol = texture2D(tColor, vUv.xy).rgb;', '\t\tfloat s = 1.0;', '\t\tint ringsamples;', '\t\tfor (int i = 1; i <= rings; i++) {', '\t\t\t/*unboxstart*/', '\t\t\tringsamples = i * samples;', '\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {', '\t\t\t\tif (j >= ringsamples) break;', '\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);', '\t\t\t}', '\t\t\t/*unboxend*/', '\t\t}', '\t\tcol /= s; //divide by sample count', '\t}', '\tif (showFocus) {', '\t\tcol = debugFocus(col, blur, depth);', '\t}', '\tif (vignetting) {', '\t\tcol *= vignette();', '\t}', '\tgl_FragColor.rgb = col;', '\tgl_FragColor.a = 1.0;', '} '].join('\\n')\n};\nexports.BokehShader2 = BokehShader2;\nvar BokehDepthShader = {\n  uniforms: {\n    mNear: {\n      value: 1.0\n    },\n    mFar: {\n      value: 1000.0\n    }\n  },\n  vertexShader: ['varying float vViewZDepth;', 'void main() {', '\t#include <begin_vertex>', '\t#include <project_vertex>', '\tvViewZDepth = - mvPosition.z;', '}'].join('\\n'),\n  fragmentShader: ['uniform float mNear;', 'uniform float mFar;', 'varying float vViewZDepth;', 'void main() {', '\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );', '\tgl_FragColor = vec4( vec3( color ), 1.0 );', '} '].join('\\n')\n};\nexports.BokehDepthShader = BokehDepthShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","depthblur","shaderFocus","focusCoords","manualdof","__esModule","mNear","noise","tColor","dithering","vertexShader","pentagon","value","tDepth","mFar","threshold","BokehShader2","textureHeight","focalDepth","fringe","fstop","zfar","znear","textureWidth","BokehDepthShader","bias","maxblur","uniforms","focalLength","gain","vignetting","showFocus"]],"~:compiled-at",1630917515411,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$BokehShader2.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,qDAAA,CAA0E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGlHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,YAAR,CAAuBJ,OAAQK,CAAAA,gBAA/B,CAAkD,IAAK,EAWnDD,OAAAA,CAAe,CACjBE,SAAU,CACRC,aAAc,CACZJ,MAAO,CADK,CADN,CAIRK,cAAe,CACbL,MAAO,CADM,CAJP,CAORM,WAAY,CACVN,MAAO,CADG,CAPJ,CAURO,YAAa,CACXP,MAAO,EADI,CAVL,CAaRQ,MAAO,CACLR,MAAO,EADF,CAbC,CAgBRS,OAAQ,CACNT,MAAO,IADD,CAhBA,CAmBRU,OAAQ,CACNV,MAAO,IADD,CAnBA,CAsBRW,QAAS,CACPX,MAAO,CADA,CAtBD,CAyBRY,UAAW,CACTZ,MAAO,CADE,CAzBH,CA4BRa,UAAW,CACTb,MAAO,CADE,CA5BH,CA+BRc,WAAY,CACVd,MAAO,CADG,CA/BJ,CAkCRe,UAAW,CACTf,MAAO,CADE,CAlCH,CAqCRgB,UAAW,CACThB,MAAO,EADE,CArCH;AAwCRiB,KAAM,CACJjB,MAAO,CADH,CAxCE,CA2CRkB,KAAM,CACJlB,MAAO,EADH,CA3CE,CA8CRmB,OAAQ,CACNnB,MAAO,EADD,CA9CA,CAiDRoB,MAAO,CACLpB,MAAO,EADF,CAjDC,CAoDRqB,KAAM,CACJrB,MAAO,GADH,CApDE,CAuDRsB,MAAO,CACLtB,MAAO,CADF,CAvDC,CA0DRuB,UAAW,CACTvB,MAAO,IADE,CA1DH,CA6DRwB,SAAU,CACRxB,MAAO,CADC,CA7DF,CAgERyB,YAAa,CACXzB,MAAO,CADI,CAhEL,CAmER0B,YAAa,CACX1B,MAAO,KA9EAL,OAAAgC,CAAQ,8CAARA,CA8EWC,CAAAA,OAAX,CADI,CAnEL,CADO,CAwEjBC,aAAiJ,qIAxEhI,CAyEjBC,eAA6/H,u3PAzE5+H,CA2EnBjC;OAAQI,CAAAA,YAAR,CAAuBA,MAavBJ,QAAQK,CAAAA,gBAAR,CAZuBA,CACrBC,SAAU,CACR4B,MAAO,CACL/B,MAAO,CADF,CADC,CAIRgC,KAAM,CACJhC,MAAO,GADH,CAJE,CADWE,CASrB2B,aAA0J,sJATrI3B,CAUrB4B,eAA8N,6MAVzM5B,CA7F2F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/BokehShader2.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$BokehShader2\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.BokehShader2 = exports.BokehDepthShader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Depth-of-field shader with bokeh\\n * ported from GLSL shader by Martins Upitis\\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\\n *\\n * Requires #define RINGS and SAMPLES integers\\n */\\nvar BokehShader2 = {\\n  uniforms: {\\n    textureWidth: {\\n      value: 1.0\\n    },\\n    textureHeight: {\\n      value: 1.0\\n    },\\n    focalDepth: {\\n      value: 1.0\\n    },\\n    focalLength: {\\n      value: 24.0\\n    },\\n    fstop: {\\n      value: 0.9\\n    },\\n    tColor: {\\n      value: null\\n    },\\n    tDepth: {\\n      value: null\\n    },\\n    maxblur: {\\n      value: 1.0\\n    },\\n    showFocus: {\\n      value: 0\\n    },\\n    manualdof: {\\n      value: 0\\n    },\\n    vignetting: {\\n      value: 0\\n    },\\n    depthblur: {\\n      value: 0\\n    },\\n    threshold: {\\n      value: 0.5\\n    },\\n    gain: {\\n      value: 2.0\\n    },\\n    bias: {\\n      value: 0.5\\n    },\\n    fringe: {\\n      value: 0.7\\n    },\\n    znear: {\\n      value: 0.1\\n    },\\n    zfar: {\\n      value: 100\\n    },\\n    noise: {\\n      value: 1\\n    },\\n    dithering: {\\n      value: 0.0001\\n    },\\n    pentagon: {\\n      value: 0\\n    },\\n    shaderFocus: {\\n      value: 1\\n    },\\n    focusCoords: {\\n      value: new _three.Vector2()\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'uniform float textureWidth;', 'uniform float textureHeight;', 'uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below', 'uniform float focalLength; //focal length in mm', 'uniform float fstop; //f-stop value', 'uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)', '/*', 'make sure that these two values are the same for your camera, otherwise distances will be wrong.', '*/', 'uniform float znear; // camera clipping start', 'uniform float zfar; // camera clipping end', '//------------------------------------------', '//user variables', 'const int samples = SAMPLES; //samples on the first ring', 'const int rings = RINGS; //ring count', 'const int maxringsamples = rings * samples;', 'uniform bool manualdof; // manual dof calculation', 'float ndofstart = 1.0; // near dof blur start', 'float ndofdist = 2.0; // near dof blur falloff distance', 'float fdofstart = 1.0; // far dof blur start', 'float fdofdist = 3.0; // far dof blur falloff distance', 'float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)', 'uniform bool vignetting; // use optical lens vignetting', 'float vignout = 1.3; // vignetting outer border', 'float vignin = 0.0; // vignetting inner border', 'float vignfade = 22.0; // f-stops till vignete fades', 'uniform bool shaderFocus;', '// disable if you use external focalDepth value', 'uniform vec2 focusCoords;', '// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)', '// if center of screen use vec2(0.5, 0.5);', 'uniform float maxblur;', '//clamp value of max blur (0.0 = no blur, 1.0 default)', 'uniform float threshold; // highlight threshold;', 'uniform float gain; // highlight gain;', 'uniform float bias; // bokeh edge bias', 'uniform float fringe; // bokeh chromatic aberration / fringing', 'uniform bool noise; //use noise instead of pattern for sample dithering', 'uniform float dithering;', 'uniform bool depthblur; // blur the depth buffer', 'float dbsize = 1.25; // depth blur size', '/*', 'next part is experimental', 'not looking good with small sample and ring count', 'looks okay starting from samples = 4, rings = 4', '*/', 'uniform bool pentagon; //use pentagon as bokeh shape?', 'float feather = 0.4; //pentagon shape feather', '//------------------------------------------', 'float penta(vec2 coords) {', '\\t//pentagonal shape', '\\tfloat scale = float(rings) - 1.3;', '\\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);', '\\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);', '\\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);', '\\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);', '\\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);', '\\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);', '\\tvec4  one = vec4( 1.0 );', '\\tvec4 P = vec4((coords),vec2(scale, scale));', '\\tvec4 dist = vec4(0.0);', '\\tfloat inorout = -4.0;', '\\tdist.x = dot( P, HS0 );', '\\tdist.y = dot( P, HS1 );', '\\tdist.z = dot( P, HS2 );', '\\tdist.w = dot( P, HS3 );', '\\tdist = smoothstep( -feather, feather, dist );', '\\tinorout += dot( dist, one );', '\\tdist.x = dot( P, HS4 );', '\\tdist.y = HS5.w - abs( P.z );', '\\tdist = smoothstep( -feather, feather, dist );', '\\tinorout += dist.x;', '\\treturn clamp( inorout, 0.0, 1.0 );', '}', 'float bdepth(vec2 coords) {', '\\t// Depth buffer blur', '\\tfloat d = 0.0;', '\\tfloat kernel[9];', '\\tvec2 offset[9];', '\\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;', '\\toffset[0] = vec2(-wh.x,-wh.y);', '\\toffset[1] = vec2( 0.0, -wh.y);', '\\toffset[2] = vec2( wh.x -wh.y);', '\\toffset[3] = vec2(-wh.x,  0.0);', '\\toffset[4] = vec2( 0.0,   0.0);', '\\toffset[5] = vec2( wh.x,  0.0);', '\\toffset[6] = vec2(-wh.x, wh.y);', '\\toffset[7] = vec2( 0.0,  wh.y);', '\\toffset[8] = vec2( wh.x, wh.y);', '\\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;', '\\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;', '\\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;', '\\tfor( int i=0; i<9; i++ ) {', '\\t\\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;', '\\t\\td += tmp * kernel[i];', '\\t}', '\\treturn d;', '}', 'vec3 color(vec2 coords,float blur) {', '\\t//processing the sample', '\\tvec3 col = vec3(0.0);', '\\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);', '\\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;', '\\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;', '\\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;', '\\tvec3 lumcoeff = vec3(0.299,0.587,0.114);', '\\tfloat lum = dot(col.rgb, lumcoeff);', '\\tfloat thresh = max((lum-threshold)*gain, 0.0);', '\\treturn col+mix(vec3(0.0),col,thresh*blur);', '}', 'vec3 debugFocus(vec3 col, float blur, float depth) {', '\\tfloat edge = 0.002*depth; //distance based edge smoothing', '\\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);', '\\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);', '\\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);', '\\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);', '\\treturn col;', '}', 'float linearize(float depth) {', '\\treturn -zfar * znear / (depth * (zfar - znear) - zfar);', '}', 'float vignette() {', '\\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));', '\\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);', '\\treturn clamp(dist,0.0,1.0);', '}', 'float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {', '\\tfloat rings2 = float(rings);', '\\tfloat step = PI*2.0 / float(ringsamples);', '\\tfloat pw = cos(j*step)*i;', '\\tfloat ph = sin(j*step)*i;', '\\tfloat p = 1.0;', '\\tif (pentagon) {', '\\t\\tp = penta(vec2(pw,ph));', '\\t}', '\\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;', '\\treturn 1.0 * mix(1.0, i /rings2, bias) * p;', '}', 'void main() {', '\\t//scene depth calculation', '\\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);', '\\t// Blur depth?', '\\tif ( depthblur ) {', '\\t\\tdepth = linearize(bdepth(vUv.xy));', '\\t}', '\\t//focal plane calculation', '\\tfloat fDepth = focalDepth;', '\\tif (shaderFocus) {', '\\t\\tfDepth = linearize(texture2D(tDepth,focusCoords).x);', '\\t}', '\\t// dof blur factor calculation', '\\tfloat blur = 0.0;', '\\tif (manualdof) {', '\\t\\tfloat a = depth-fDepth; // Focal plane', '\\t\\tfloat b = (a-fdofstart)/fdofdist; // Far DoF', '\\t\\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof', '\\t\\tblur = (a>0.0) ? b : c;', '\\t} else {', '\\t\\tfloat f = focalLength; // focal length in mm', '\\t\\tfloat d = fDepth*1000.0; // focal plane in mm', '\\t\\tfloat o = depth*1000.0; // depth in mm', '\\t\\tfloat a = (o*f)/(o-f);', '\\t\\tfloat b = (d*f)/(d-f);', '\\t\\tfloat c = (d-f)/(d*fstop*CoC);', '\\t\\tblur = abs(a-b)*c;', '\\t}', '\\tblur = clamp(blur,0.0,1.0);', '\\t// calculation of pattern for dithering', '\\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;', '\\t// getting blur x and y step factor', '\\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;', '\\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;', '\\t// calculation of final color', '\\tvec3 col = vec3(0.0);', '\\tif(blur < 0.05) {', '\\t\\t//some optimization thingy', '\\t\\tcol = texture2D(tColor, vUv.xy).rgb;', '\\t} else {', '\\t\\tcol = texture2D(tColor, vUv.xy).rgb;', '\\t\\tfloat s = 1.0;', '\\t\\tint ringsamples;', '\\t\\tfor (int i = 1; i <= rings; i++) {', '\\t\\t\\t/*unboxstart*/', '\\t\\t\\tringsamples = i * samples;', '\\t\\t\\tfor (int j = 0 ; j < maxringsamples ; j++) {', '\\t\\t\\t\\tif (j >= ringsamples) break;', '\\t\\t\\t\\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);', '\\t\\t\\t}', '\\t\\t\\t/*unboxend*/', '\\t\\t}', '\\t\\tcol /= s; //divide by sample count', '\\t}', '\\tif (showFocus) {', '\\t\\tcol = debugFocus(col, blur, depth);', '\\t}', '\\tif (vignetting) {', '\\t\\tcol *= vignette();', '\\t}', '\\tgl_FragColor.rgb = col;', '\\tgl_FragColor.a = 1.0;', '} '].join('\\\\n')\\n};\\nexports.BokehShader2 = BokehShader2;\\nvar BokehDepthShader = {\\n  uniforms: {\\n    mNear: {\\n      value: 1.0\\n    },\\n    mFar: {\\n      value: 1000.0\\n    }\\n  },\\n  vertexShader: ['varying float vViewZDepth;', 'void main() {', '\\t#include <begin_vertex>', '\\t#include <project_vertex>', '\\tvViewZDepth = - mvPosition.z;', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform float mNear;', 'uniform float mFar;', 'varying float vViewZDepth;', 'void main() {', '\\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );', '\\tgl_FragColor = vec4( vec3( color ), 1.0 );', '} '].join('\\\\n')\\n};\\nexports.BokehDepthShader = BokehDepthShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"BokehShader2\",\"BokehDepthShader\",\"uniforms\",\"textureWidth\",\"textureHeight\",\"focalDepth\",\"focalLength\",\"fstop\",\"tColor\",\"tDepth\",\"maxblur\",\"showFocus\",\"manualdof\",\"vignetting\",\"depthblur\",\"threshold\",\"gain\",\"bias\",\"fringe\",\"znear\",\"zfar\",\"noise\",\"dithering\",\"pentagon\",\"shaderFocus\",\"focusCoords\",\"_three\",\"Vector2\",\"vertexShader\",\"fragmentShader\",\"mNear\",\"mFar\"]\n}\n"]