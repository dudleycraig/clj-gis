["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/exporters/DRACOExporter.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$exporters$DRACOExporter=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.DRACOExporter=void 0;var DRACOExporter=function(){};exports.DRACOExporter=DRACOExporter;DRACOExporter.prototype={constructor:DRACOExporter,parse:function(object,options){if(!0===object.isBufferGeometry)throw Error(\"DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.\");if(void 0===DracoEncoderModule)throw Error(\"THREE.DRACOExporter: required the draco_decoder to work.\");\nvoid 0===options&&(options={decodeSpeed:5,encodeSpeed:5,encoderMethod:DRACOExporter.MESH_EDGEBREAKER_ENCODING,quantization:[16,8,8,8,8],exportUvs:!0,exportNormals:!0,exportColor:!1});var geometry=object.geometry,dracoEncoder=DracoEncoderModule(),encoder=new dracoEncoder.Encoder;if(!0!==geometry.isBufferGeometry)throw Error(\"THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.\");if(!0===object.isMesh){var builder=new dracoEncoder.MeshBuilder;var dracoObject=\nnew dracoEncoder.Mesh;var vertices=geometry.getAttribute(\"position\");builder.AddFloatAttributeToMesh(dracoObject,dracoEncoder.POSITION,vertices.count,vertices.itemSize,vertices.array);var faces=geometry.getIndex();if(null!==faces)builder.AddFacesToMesh(dracoObject,faces.count/3,faces.array);else{faces=new (65535<vertices.count?Uint32Array:Uint16Array)(vertices.count);for(var i=0;i<faces.length;i++)faces[i]=i;builder.AddFacesToMesh(dracoObject,vertices.count,faces)}!0===options.exportNormals&&(vertices=\ngeometry.getAttribute(\"normal\"),void 0!==vertices&&builder.AddFloatAttributeToMesh(dracoObject,dracoEncoder.NORMAL,vertices.count,vertices.itemSize,vertices.array));!0===options.exportUvs&&(vertices=geometry.getAttribute(\"uv\"),void 0!==vertices&&builder.AddFloatAttributeToMesh(dracoObject,dracoEncoder.TEX_COORD,vertices.count,vertices.itemSize,vertices.array));!0===options.exportColor&&(geometry=geometry.getAttribute(\"color\"),void 0!==geometry&&builder.AddFloatAttributeToMesh(dracoObject,dracoEncoder.COLOR,\ngeometry.count,geometry.itemSize,geometry.array))}else if(!0===object.isPoints)builder=new dracoEncoder.PointCloudBuilder,dracoObject=new dracoEncoder.PointCloud,vertices=geometry.getAttribute(\"position\"),builder.AddFloatAttribute(dracoObject,dracoEncoder.POSITION,vertices.count,vertices.itemSize,vertices.array),!0===options.exportColor&&(geometry=geometry.getAttribute(\"color\"),void 0!==geometry&&builder.AddFloatAttribute(dracoObject,dracoEncoder.COLOR,geometry.count,geometry.itemSize,geometry.array));\nelse throw Error(\"DRACOExporter: Unsupported object type.\");geometry=new dracoEncoder.DracoInt8Array;encoder.SetSpeedOptions(void 0!==options.encodeSpeed?options.encodeSpeed:5,void 0!==options.decodeSpeed?options.decodeSpeed:5);void 0!==options.encoderMethod&&encoder.SetEncodingMethod(options.encoderMethod);if(void 0!==options.quantization)for(vertices=0;5>vertices;vertices++)void 0!==options.quantization[vertices]&&encoder.SetAttributeQuantization(vertices,options.quantization[vertices]);object=\n!0===object.isMesh?encoder.EncodeMeshToDracoBuffer(dracoObject,geometry):encoder.EncodePointCloudToDracoBuffer(dracoObject,!0,geometry);dracoEncoder.destroy(dracoObject);if(0===object)throw Error(\"THREE.DRACOExporter: Draco encoding failed.\");dracoObject=new Int8Array(new ArrayBuffer(object));for(options=0;options<object;options++)dracoObject[options]=geometry.GetValue(options);dracoEncoder.destroy(geometry);dracoEncoder.destroy(encoder);dracoEncoder.destroy(builder);return dracoObject}};DRACOExporter.MESH_EDGEBREAKER_ENCODING=\n1;DRACOExporter.MESH_SEQUENTIAL_ENCODING=0;DRACOExporter.POINT_CLOUD=0;DRACOExporter.TRIANGULAR_MESH=1;DRACOExporter.INVALID=-1;DRACOExporter.POSITION=0;DRACOExporter.NORMAL=1;DRACOExporter.COLOR=2;DRACOExporter.TEX_COORD=3;DRACOExporter.GENERIC=4}","~:source","shadow$provide[\"module$node_modules$three_stdlib$exporters$DRACOExporter\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DRACOExporter = void 0;\n\n/**\n * Export draco compressed files from threejs geometry objects.\n *\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\n *\n * The exporter receives a options object containing\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n *  - encoderMethod\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n *  - exportUvs\n *  - exportNormals\n */\n\n/* global DracoEncoderModule */\nvar DRACOExporter = function DRACOExporter() {};\n\nexports.DRACOExporter = DRACOExporter;\nDRACOExporter.prototype = {\n  constructor: DRACOExporter,\n  parse: function parse(object, options) {\n    if (object.isBufferGeometry === true) {\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\n    }\n\n    if (DracoEncoderModule === undefined) {\n      throw new Error('THREE.DRACOExporter: required the draco_decoder to work.');\n    }\n\n    if (options === undefined) {\n      options = {\n        decodeSpeed: 5,\n        encodeSpeed: 5,\n        encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n        quantization: [16, 8, 8, 8, 8],\n        exportUvs: true,\n        exportNormals: true,\n        exportColor: false\n      };\n    }\n\n    var geometry = object.geometry;\n    var dracoEncoder = DracoEncoderModule();\n    var encoder = new dracoEncoder.Encoder();\n    var builder;\n    var dracoObject;\n\n    if (geometry.isBufferGeometry !== true) {\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\n    }\n\n    if (object.isMesh === true) {\n      builder = new dracoEncoder.MeshBuilder();\n      dracoObject = new dracoEncoder.Mesh();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n      var faces = geometry.getIndex();\n\n      if (faces !== null) {\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n      } else {\n        var faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n\n        for (var i = 0; i < faces.length; i++) {\n          faces[i] = i;\n        }\n\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\n      }\n\n      if (options.exportNormals === true) {\n        var normals = geometry.getAttribute('normal');\n\n        if (normals !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n        }\n      }\n\n      if (options.exportUvs === true) {\n        var uvs = geometry.getAttribute('uv');\n\n        if (uvs !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n        }\n      }\n\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n\n        if (colors !== undefined) {\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else if (object.isPoints === true) {\n      builder = new dracoEncoder.PointCloudBuilder();\n      dracoObject = new dracoEncoder.PointCloud();\n      var vertices = geometry.getAttribute('position');\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n\n      if (options.exportColor === true) {\n        var colors = geometry.getAttribute('color');\n\n        if (colors !== undefined) {\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n        }\n      }\n    } else {\n      throw new Error('DRACOExporter: Unsupported object type.');\n    } //Compress using draco encoder\n\n\n    var encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n    var encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\n    var decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\n\n    if (options.encoderMethod !== undefined) {\n      encoder.SetEncodingMethod(options.encoderMethod);\n    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\n\n    if (options.quantization !== undefined) {\n      for (var _i = 0; _i < 5; _i++) {\n        if (options.quantization[_i] !== undefined) {\n          encoder.SetAttributeQuantization(_i, options.quantization[_i]);\n        }\n      }\n    }\n\n    var length;\n\n    if (object.isMesh === true) {\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n    } else {\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n    }\n\n    dracoEncoder.destroy(dracoObject);\n\n    if (length === 0) {\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\n    } //Copy encoded data to buffer.\n\n\n    var outputData = new Int8Array(new ArrayBuffer(length));\n\n    for (var _i2 = 0; _i2 < length; _i2++) {\n      outputData[_i2] = encodedData.GetValue(_i2);\n    }\n\n    dracoEncoder.destroy(encodedData);\n    dracoEncoder.destroy(encoder);\n    dracoEncoder.destroy(builder);\n    return outputData;\n  }\n}; // Encoder methods\n\nDRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\nDRACOExporter.MESH_SEQUENTIAL_ENCODING = 0; // Geometry type\n\nDRACOExporter.POINT_CLOUD = 0;\nDRACOExporter.TRIANGULAR_MESH = 1; // Attribute type\n\nDRACOExporter.INVALID = -1;\nDRACOExporter.POSITION = 0;\nDRACOExporter.NORMAL = 1;\nDRACOExporter.COLOR = 2;\nDRACOExporter.TEX_COORD = 3;\nDRACOExporter.GENERIC = 4;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["TRIANGULAR_MESH","NORMAL","exportColor","prototype","MESH_SEQUENTIAL_ENCODING","decodeSpeed","encodeSpeed","TEX_COORD","DRACOExporter","__esModule","POSITION","POINT_CLOUD","value","GENERIC","encoderMethod","INVALID","exportNormals","parse","COLOR","MESH_EDGEBREAKER_ENCODING","exportUvs","quantization","constructor"]],"~:compiled-at",1630917515306,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$exporters$DRACOExporter.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/exporters/DRACOExporter.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$exporters$DRACOExporter\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.DRACOExporter = void 0;\\n\\n/**\\n * Export draco compressed files from threejs geometry objects.\\n *\\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\\n *\\n * The exporter receives a options object containing\\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\\n *  - encoderMethod\\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\\n *  - exportUvs\\n *  - exportNormals\\n */\\n\\n/* global DracoEncoderModule */\\nvar DRACOExporter = function DRACOExporter() {};\\n\\nexports.DRACOExporter = DRACOExporter;\\nDRACOExporter.prototype = {\\n  constructor: DRACOExporter,\\n  parse: function parse(object, options) {\\n    if (object.isBufferGeometry === true) {\\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\\n    }\\n\\n    if (DracoEncoderModule === undefined) {\\n      throw new Error('THREE.DRACOExporter: required the draco_decoder to work.');\\n    }\\n\\n    if (options === undefined) {\\n      options = {\\n        decodeSpeed: 5,\\n        encodeSpeed: 5,\\n        encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\\n        quantization: [16, 8, 8, 8, 8],\\n        exportUvs: true,\\n        exportNormals: true,\\n        exportColor: false\\n      };\\n    }\\n\\n    var geometry = object.geometry;\\n    var dracoEncoder = DracoEncoderModule();\\n    var encoder = new dracoEncoder.Encoder();\\n    var builder;\\n    var dracoObject;\\n\\n    if (geometry.isBufferGeometry !== true) {\\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\\n    }\\n\\n    if (object.isMesh === true) {\\n      builder = new dracoEncoder.MeshBuilder();\\n      dracoObject = new dracoEncoder.Mesh();\\n      var vertices = geometry.getAttribute('position');\\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\\n      var faces = geometry.getIndex();\\n\\n      if (faces !== null) {\\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\\n      } else {\\n        var faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\\n\\n        for (var i = 0; i < faces.length; i++) {\\n          faces[i] = i;\\n        }\\n\\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\\n      }\\n\\n      if (options.exportNormals === true) {\\n        var normals = geometry.getAttribute('normal');\\n\\n        if (normals !== undefined) {\\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\\n        }\\n      }\\n\\n      if (options.exportUvs === true) {\\n        var uvs = geometry.getAttribute('uv');\\n\\n        if (uvs !== undefined) {\\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\\n        }\\n      }\\n\\n      if (options.exportColor === true) {\\n        var colors = geometry.getAttribute('color');\\n\\n        if (colors !== undefined) {\\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\\n        }\\n      }\\n    } else if (object.isPoints === true) {\\n      builder = new dracoEncoder.PointCloudBuilder();\\n      dracoObject = new dracoEncoder.PointCloud();\\n      var vertices = geometry.getAttribute('position');\\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\\n\\n      if (options.exportColor === true) {\\n        var colors = geometry.getAttribute('color');\\n\\n        if (colors !== undefined) {\\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\\n        }\\n      }\\n    } else {\\n      throw new Error('DRACOExporter: Unsupported object type.');\\n    } //Compress using draco encoder\\n\\n\\n    var encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\\n\\n    var encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\\n    var decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\\n\\n    if (options.encoderMethod !== undefined) {\\n      encoder.SetEncodingMethod(options.encoderMethod);\\n    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\\n\\n\\n    if (options.quantization !== undefined) {\\n      for (var _i = 0; _i < 5; _i++) {\\n        if (options.quantization[_i] !== undefined) {\\n          encoder.SetAttributeQuantization(_i, options.quantization[_i]);\\n        }\\n      }\\n    }\\n\\n    var length;\\n\\n    if (object.isMesh === true) {\\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\\n    } else {\\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\\n    }\\n\\n    dracoEncoder.destroy(dracoObject);\\n\\n    if (length === 0) {\\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\\n    } //Copy encoded data to buffer.\\n\\n\\n    var outputData = new Int8Array(new ArrayBuffer(length));\\n\\n    for (var _i2 = 0; _i2 < length; _i2++) {\\n      outputData[_i2] = encodedData.GetValue(_i2);\\n    }\\n\\n    dracoEncoder.destroy(encodedData);\\n    dracoEncoder.destroy(encoder);\\n    dracoEncoder.destroy(builder);\\n    return outputData;\\n  }\\n}; // Encoder methods\\n\\nDRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\\nDRACOExporter.MESH_SEQUENTIAL_ENCODING = 0; // Geometry type\\n\\nDRACOExporter.POINT_CLOUD = 0;\\nDRACOExporter.TRIANGULAR_MESH = 1; // Attribute type\\n\\nDRACOExporter.INVALID = -1;\\nDRACOExporter.POSITION = 0;\\nDRACOExporter.NORMAL = 1;\\nDRACOExporter.COLOR = 2;\\nDRACOExporter.TEX_COORD = 3;\\nDRACOExporter.GENERIC = 4;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"DRACOExporter\",\"prototype\",\"constructor\",\"parse\",\"object\",\"options\",\"isBufferGeometry\",\"Error\",\"undefined\",\"DracoEncoderModule\",\"decodeSpeed\",\"encodeSpeed\",\"encoderMethod\",\"MESH_EDGEBREAKER_ENCODING\",\"quantization\",\"exportUvs\",\"exportNormals\",\"exportColor\",\"geometry\",\"dracoEncoder\",\"encoder\",\"Encoder\",\"isMesh\",\"builder\",\"MeshBuilder\",\"dracoObject\",\"Mesh\",\"vertices\",\"getAttribute\",\"AddFloatAttributeToMesh\",\"POSITION\",\"count\",\"itemSize\",\"array\",\"faces\",\"getIndex\",\"AddFacesToMesh\",\"Uint32Array\",\"Uint16Array\",\"i\",\"length\",\"normals\",\"NORMAL\",\"uvs\",\"TEX_COORD\",\"colors\",\"COLOR\",\"isPoints\",\"PointCloudBuilder\",\"PointCloud\",\"AddFloatAttribute\",\"encodedData\",\"DracoInt8Array\",\"SetSpeedOptions\",\"SetEncodingMethod\",\"_i\",\"SetAttributeQuantization\",\"EncodeMeshToDracoBuffer\",\"EncodePointCloudToDracoBuffer\",\"destroy\",\"outputData\",\"Int8Array\",\"ArrayBuffer\",\"_i2\",\"GetValue\",\"MESH_SEQUENTIAL_ENCODING\",\"POINT_CLOUD\",\"TRIANGULAR_MESH\",\"INVALID\",\"GENERIC\"]\n}\n"]