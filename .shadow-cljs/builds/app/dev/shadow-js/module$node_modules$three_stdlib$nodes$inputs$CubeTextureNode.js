["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/nodes/inputs/CubeTextureNode.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$nodes$inputs$CubeTextureNode=function(global,require,module,exports){function CubeTextureNode(value,uv,bias){_InputNode.InputNode.call(this,\"v4\",{shared:!0});this.value=value;this.uv=uv||new _ReflectNode.ReflectNode;this.bias=bias}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.CubeTextureNode=CubeTextureNode;var _InputNode=require(\"module$node_modules$three_stdlib$nodes$core$InputNode\"),_ReflectNode=require(\"module$node_modules$three_stdlib$nodes$accessors$ReflectNode\"),\n_ColorSpaceNode=require(\"module$node_modules$three_stdlib$nodes$utils$ColorSpaceNode\"),_ExpressionNode=require(\"module$node_modules$three_stdlib$nodes$core$ExpressionNode\");CubeTextureNode.prototype=Object.create(_InputNode.InputNode.prototype);CubeTextureNode.prototype.constructor=CubeTextureNode;CubeTextureNode.prototype.nodeType=\"CubeTexture\";CubeTextureNode.prototype.getTexture=function(builder,output){return _InputNode.InputNode.prototype.generate.call(this,builder,output,this.value.uuid,\"tc\")};\nCubeTextureNode.prototype.generate=function(builder,output){if(\"samplerCube\"===output)return this.getTexture(builder,output);var cubetex=this.getTexture(builder,output),uv=this.uv.build(builder,\"v3\"),bias=this.bias?this.bias.build(builder,\"f\"):void 0;void 0===bias&&builder.context.bias&&(bias=builder.context.bias.setTexture(this).build(builder,\"f\"));cubetex=bias?\"texCubeBias( \"+cubetex+\", \"+uv+\", \"+bias+\" )\":\"texCube( \"+cubetex+\", \"+uv+\" )\";uv={include:builder.isShader(\"vertex\"),ignoreCache:!0};bias=\nthis.getType(builder);builder.addContext(uv);this.colorSpace=this.colorSpace||new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode(\"\",bias));this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));this.colorSpace.input.parse(cubetex);cubetex=this.colorSpace.build(builder,bias);builder.removeContext();return builder.format(cubetex,bias,output)};CubeTextureNode.prototype.copy=function(source){_InputNode.InputNode.prototype.copy.call(this,source);source.value&&(this.value=\nsource.value);this.uv=source.uv;source.bias&&(this.bias=source.bias);return this};CubeTextureNode.prototype.toJSON=function(meta){var data=this.getJSONNode(meta);data||(data=this.createJSONNode(meta),data.value=this.value.uuid,data.uv=this.uv.toJSON(meta).uuid,this.bias&&(data.bias=this.bias.toJSON(meta).uuid));return data}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$nodes$inputs$CubeTextureNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CubeTextureNode = CubeTextureNode;\n\nvar _InputNode = require(\"../core/InputNode.js\");\n\nvar _ReflectNode = require(\"../accessors/ReflectNode.js\");\n\nvar _ColorSpaceNode = require(\"../utils/ColorSpaceNode.js\");\n\nvar _ExpressionNode = require(\"../core/ExpressionNode.js\");\n\nfunction CubeTextureNode(value, uv, bias) {\n  _InputNode.InputNode.call(this, 'v4', {\n    shared: true\n  });\n\n  this.value = value;\n  this.uv = uv || new _ReflectNode.ReflectNode();\n  this.bias = bias;\n}\n\nCubeTextureNode.prototype = Object.create(_InputNode.InputNode.prototype);\nCubeTextureNode.prototype.constructor = CubeTextureNode;\nCubeTextureNode.prototype.nodeType = 'CubeTexture';\n\nCubeTextureNode.prototype.getTexture = function (builder, output) {\n  return _InputNode.InputNode.prototype.generate.call(this, builder, output, this.value.uuid, 'tc');\n};\n\nCubeTextureNode.prototype.generate = function (builder, output) {\n  if (output === 'samplerCube') {\n    return this.getTexture(builder, output);\n  }\n\n  var cubetex = this.getTexture(builder, output);\n  var uv = this.uv.build(builder, 'v3');\n  var bias = this.bias ? this.bias.build(builder, 'f') : undefined;\n\n  if (bias === undefined && builder.context.bias) {\n    bias = builder.context.bias.setTexture(this).build(builder, 'f');\n  }\n\n  var code;\n  if (bias) code = 'texCubeBias( ' + cubetex + ', ' + uv + ', ' + bias + ' )';else code = 'texCube( ' + cubetex + ', ' + uv + ' )'; // add a custom context for fix incompatibility with the core\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\n  // this should be removed in the future\n  // context.include =: is used to include or not functions if used FunctionNode\n  // context.ignoreCache =: not create variables temp nodeT0..9 to optimize the code\n\n  var context = {\n    include: builder.isShader('vertex'),\n    ignoreCache: true\n  };\n  var outputType = this.getType(builder);\n  builder.addContext(context);\n  this.colorSpace = this.colorSpace || new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode('', outputType));\n  this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));\n  this.colorSpace.input.parse(code);\n  code = this.colorSpace.build(builder, outputType); // end custom context\n\n  builder.removeContext();\n  return builder.format(code, outputType, output);\n};\n\nCubeTextureNode.prototype.copy = function (source) {\n  _InputNode.InputNode.prototype.copy.call(this, source);\n\n  if (source.value) this.value = source.value;\n  this.uv = source.uv;\n  if (source.bias) this.bias = source.bias;\n  return this;\n};\n\nCubeTextureNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.value = this.value.uuid;\n    data.uv = this.uv.toJSON(meta).uuid;\n    if (this.bias) data.bias = this.bias.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three_stdlib$nodes$accessors$ReflectNode","~$shadow.js","~$module$node_modules$three_stdlib$nodes$utils$ColorSpaceNode","~$module$node_modules$three_stdlib$nodes$core$InputNode","~$module$node_modules$three_stdlib$nodes$core$ExpressionNode"]],"~:properties",["^5",["copy","prototype","shared","__esModule","generate","nodeType","value","include","uv","ignoreCache","colorSpace","CubeTextureNode","bias","getTexture","constructor","toJSON"]],"~:compiled-at",1630917515233,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$nodes$inputs$CubeTextureNode.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/nodes/inputs/CubeTextureNode.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$nodes$inputs$CubeTextureNode\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.CubeTextureNode = CubeTextureNode;\\n\\nvar _InputNode = require(\\\"../core/InputNode.js\\\");\\n\\nvar _ReflectNode = require(\\\"../accessors/ReflectNode.js\\\");\\n\\nvar _ColorSpaceNode = require(\\\"../utils/ColorSpaceNode.js\\\");\\n\\nvar _ExpressionNode = require(\\\"../core/ExpressionNode.js\\\");\\n\\nfunction CubeTextureNode(value, uv, bias) {\\n  _InputNode.InputNode.call(this, 'v4', {\\n    shared: true\\n  });\\n\\n  this.value = value;\\n  this.uv = uv || new _ReflectNode.ReflectNode();\\n  this.bias = bias;\\n}\\n\\nCubeTextureNode.prototype = Object.create(_InputNode.InputNode.prototype);\\nCubeTextureNode.prototype.constructor = CubeTextureNode;\\nCubeTextureNode.prototype.nodeType = 'CubeTexture';\\n\\nCubeTextureNode.prototype.getTexture = function (builder, output) {\\n  return _InputNode.InputNode.prototype.generate.call(this, builder, output, this.value.uuid, 'tc');\\n};\\n\\nCubeTextureNode.prototype.generate = function (builder, output) {\\n  if (output === 'samplerCube') {\\n    return this.getTexture(builder, output);\\n  }\\n\\n  var cubetex = this.getTexture(builder, output);\\n  var uv = this.uv.build(builder, 'v3');\\n  var bias = this.bias ? this.bias.build(builder, 'f') : undefined;\\n\\n  if (bias === undefined && builder.context.bias) {\\n    bias = builder.context.bias.setTexture(this).build(builder, 'f');\\n  }\\n\\n  var code;\\n  if (bias) code = 'texCubeBias( ' + cubetex + ', ' + uv + ', ' + bias + ' )';else code = 'texCube( ' + cubetex + ', ' + uv + ' )'; // add a custom context for fix incompatibility with the core\\n  // include ColorSpace function only for vertex shader (in fragment shader color space functions is added automatically by core)\\n  // this should be removed in the future\\n  // context.include =: is used to include or not functions if used FunctionNode\\n  // context.ignoreCache =: not create variables temp nodeT0..9 to optimize the code\\n\\n  var context = {\\n    include: builder.isShader('vertex'),\\n    ignoreCache: true\\n  };\\n  var outputType = this.getType(builder);\\n  builder.addContext(context);\\n  this.colorSpace = this.colorSpace || new _ColorSpaceNode.ColorSpaceNode(new _ExpressionNode.ExpressionNode('', outputType));\\n  this.colorSpace.fromDecoding(builder.getTextureEncodingFromMap(this.value));\\n  this.colorSpace.input.parse(code);\\n  code = this.colorSpace.build(builder, outputType); // end custom context\\n\\n  builder.removeContext();\\n  return builder.format(code, outputType, output);\\n};\\n\\nCubeTextureNode.prototype.copy = function (source) {\\n  _InputNode.InputNode.prototype.copy.call(this, source);\\n\\n  if (source.value) this.value = source.value;\\n  this.uv = source.uv;\\n  if (source.bias) this.bias = source.bias;\\n  return this;\\n};\\n\\nCubeTextureNode.prototype.toJSON = function (meta) {\\n  var data = this.getJSONNode(meta);\\n\\n  if (!data) {\\n    data = this.createJSONNode(meta);\\n    data.value = this.value.uuid;\\n    data.uv = this.uv.toJSON(meta).uuid;\\n    if (this.bias) data.bias = this.bias.toJSON(meta).uuid;\\n  }\\n\\n  return data;\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"CubeTextureNode\",\"value\",\"uv\",\"bias\",\"_InputNode\",\"InputNode\",\"call\",\"shared\",\"_ReflectNode\",\"ReflectNode\",\"Object\",\"defineProperty\",\"_ColorSpaceNode\",\"_ExpressionNode\",\"prototype\",\"create\",\"constructor\",\"nodeType\",\"getTexture\",\"CubeTextureNode.prototype.getTexture\",\"builder\",\"output\",\"generate\",\"uuid\",\"CubeTextureNode.prototype.generate\",\"cubetex\",\"build\",\"undefined\",\"context\",\"setTexture\",\"code\",\"include\",\"isShader\",\"ignoreCache\",\"outputType\",\"getType\",\"addContext\",\"colorSpace\",\"ColorSpaceNode\",\"ExpressionNode\",\"fromDecoding\",\"getTextureEncodingFromMap\",\"input\",\"parse\",\"removeContext\",\"format\",\"copy\",\"CubeTextureNode.prototype.copy\",\"source\",\"toJSON\",\"CubeTextureNode.prototype.toJSON\",\"meta\",\"data\",\"getJSONNode\",\"createJSONNode\"]\n}\n"]