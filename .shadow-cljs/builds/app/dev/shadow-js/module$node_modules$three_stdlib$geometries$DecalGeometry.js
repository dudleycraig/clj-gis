["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/geometries/DecalGeometry.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$geometries$DecalGeometry=function(global,require,module,exports){function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);\nstaticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");\n}function _possibleConstructorReturn(self,call){if(call&&(\"object\"===_typeof(call)||\"function\"===typeof call))return call;if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&\nnull!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.DecalVertex=\nexports.DecalGeometry=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_BufferGeometry){function DecalGeometry(mesh,position,orientation,size){function pushDecalVertex(decalVertices,vertex,normal){vertex.applyMatrix4(mesh.matrixWorld);vertex.applyMatrix4(projectorMatrixInverse);normal.transformDirection(mesh.matrixWorld);decalVertices.push(new DecalVertex(vertex.clone(),normal.clone()))}function clipGeometry(inVertices,plane){for(var outVertices=[],s=.5*Math.abs(size.dot(plane)),\ni=0;i<inVertices.length;i+=3){var nV1=void 0,nV2=void 0,nV3=void 0,nV4=void 0;var v1Out=inVertices[i+0].position.dot(plane)-s;var v2Out=inVertices[i+1].position.dot(plane)-s;var v3Out=inVertices[i+2].position.dot(plane)-s;v1Out=0<v1Out;v2Out=0<v2Out;v3Out=0<v3Out;switch((v1Out?1:0)+(v2Out?1:0)+(v3Out?1:0)){case 0:outVertices.push(inVertices[i]);outVertices.push(inVertices[i+1]);outVertices.push(inVertices[i+2]);break;case 1:v1Out&&(nV1=inVertices[i+1],nV2=inVertices[i+2],nV3=clip(inVertices[i],nV1,\nplane,s),nV4=clip(inVertices[i],nV2,plane,s));if(v2Out){nV1=inVertices[i];nV2=inVertices[i+2];nV3=clip(inVertices[i+1],nV1,plane,s);nV4=clip(inVertices[i+1],nV2,plane,s);outVertices.push(nV3);outVertices.push(nV2.clone());outVertices.push(nV1.clone());outVertices.push(nV2.clone());outVertices.push(nV3.clone());outVertices.push(nV4);break}v3Out&&(nV1=inVertices[i],nV2=inVertices[i+1],nV3=clip(inVertices[i+2],nV1,plane,s),nV4=clip(inVertices[i+2],nV2,plane,s));outVertices.push(nV1.clone());outVertices.push(nV2.clone());\noutVertices.push(nV3);outVertices.push(nV4);outVertices.push(nV3.clone());outVertices.push(nV2.clone());break;case 2:v1Out||(nV1=inVertices[i].clone(),nV2=clip(nV1,inVertices[i+1],plane,s),nV3=clip(nV1,inVertices[i+2],plane,s),outVertices.push(nV1),outVertices.push(nV2),outVertices.push(nV3)),v2Out||(nV1=inVertices[i+1].clone(),nV2=clip(nV1,inVertices[i+2],plane,s),nV3=clip(nV1,inVertices[i],plane,s),outVertices.push(nV1),outVertices.push(nV2),outVertices.push(nV3)),v3Out||(nV1=inVertices[i+2].clone(),\nnV2=clip(nV1,inVertices[i],plane,s),nV3=clip(nV1,inVertices[i+1],plane,s),outVertices.push(nV1),outVertices.push(nV2),outVertices.push(nV3))}}return outVertices}function clip(v0,v1,p,s){var d0=v0.position.dot(p)-s;p=v1.position.dot(p)-s;d0/=d0-p;return new DecalVertex(new _three.Vector3(v0.position.x+d0*(v1.position.x-v0.position.x),v0.position.y+d0*(v1.position.y-v0.position.y),v0.position.z+d0*(v1.position.z-v0.position.z)),new _three.Vector3(v0.normal.x+d0*(v1.normal.x-v0.normal.x),v0.normal.y+\nd0*(v1.normal.y-v0.normal.y),v0.normal.z+d0*(v1.normal.z-v0.normal.z)))}_classCallCheck(this,DecalGeometry);var _this=_possibleConstructorReturn(this,_getPrototypeOf(DecalGeometry).call(this));var vertices=[],normals=[],uvs=[],plane$jscomp$0=new _three.Vector3,projectorMatrix=new _three.Matrix4;projectorMatrix.makeRotationFromEuler(orientation);projectorMatrix.setPosition(position);var projectorMatrixInverse=new _three.Matrix4;projectorMatrixInverse.copy(projectorMatrix).invert();(function(){var decalVertices=\n[],vertex=new _three.Vector3,normal=new _three.Vector3;if(!0===mesh.geometry.isGeometry)console.error(\"THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.\");else{var i=mesh.geometry;var positionAttribute=i.attributes.position,normalAttribute=i.attributes.normal;if(null!==i.index){var index=i.index;for(i=0;i<index.count;i++)vertex.fromBufferAttribute(positionAttribute,index.getX(i)),normal.fromBufferAttribute(normalAttribute,index.getX(i)),pushDecalVertex(decalVertices,\nvertex,normal)}else for(i=0;i<positionAttribute.count;i++)vertex.fromBufferAttribute(positionAttribute,i),normal.fromBufferAttribute(normalAttribute,i),pushDecalVertex(decalVertices,vertex,normal);decalVertices=clipGeometry(decalVertices,plane$jscomp$0.set(1,0,0));decalVertices=clipGeometry(decalVertices,plane$jscomp$0.set(-1,0,0));decalVertices=clipGeometry(decalVertices,plane$jscomp$0.set(0,1,0));decalVertices=clipGeometry(decalVertices,plane$jscomp$0.set(0,-1,0));decalVertices=clipGeometry(decalVertices,\nplane$jscomp$0.set(0,0,1));decalVertices=clipGeometry(decalVertices,plane$jscomp$0.set(0,0,-1));for(i=0;i<decalVertices.length;i++)vertex=decalVertices[i],uvs.push(.5+vertex.position.x/size.x,.5+vertex.position.y/size.y),vertex.position.applyMatrix4(projectorMatrix),vertices.push(vertex.position.x,vertex.position.y,vertex.position.z),normals.push(vertex.normal.x,vertex.normal.y,vertex.normal.z)}})();_this.setAttribute(\"position\",new _three.Float32BufferAttribute(vertices,3));_this.setAttribute(\"normal\",\nnew _three.Float32BufferAttribute(normals,3));_this.setAttribute(\"uv\",new _three.Float32BufferAttribute(uvs,2));return _this}_inherits(DecalGeometry,_BufferGeometry);return DecalGeometry}(_three.BufferGeometry);exports.DecalGeometry=global;var DecalVertex=function(){function DecalVertex(position,normal){_classCallCheck(this,DecalVertex);this.position=position;this.normal=normal}_createClass(DecalVertex,[{key:\"clone\",value:function(){return new this.constructor(this.position.clone(),this.normal.clone())}}]);\nreturn DecalVertex}();exports.DecalVertex=DecalVertex}","~:source","shadow$provide[\"module$node_modules$three_stdlib$geometries$DecalGeometry\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DecalVertex = exports.DecalGeometry = void 0;\n\nvar _three = require(\"three\");\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * You can use this geometry to create a decal mesh, that serves different kinds of purposes.\n * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams.\n *\n * Constructor parameter:\n *\n * mesh — Any mesh object\n * position — Position of the decal projector\n * orientation — Orientation of the decal projector\n * size — Size of the decal projector\n *\n * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/\n *\n */\nvar DecalGeometry =\n/*#__PURE__*/\nfunction (_BufferGeometry) {\n  _inherits(DecalGeometry, _BufferGeometry);\n\n  function DecalGeometry(mesh, position, orientation, size) {\n    var _this;\n\n    _classCallCheck(this, DecalGeometry);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DecalGeometry).call(this)); // buffers\n\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helpers\n\n    var plane = new _three.Vector3(); // this matrix represents the transformation of the decal projector\n\n    var projectorMatrix = new _three.Matrix4();\n    projectorMatrix.makeRotationFromEuler(orientation);\n    projectorMatrix.setPosition(position);\n    var projectorMatrixInverse = new _three.Matrix4();\n    projectorMatrixInverse.copy(projectorMatrix).invert(); // generate buffers\n\n    generate(); // build geometry\n\n    _this.setAttribute('position', new _three.Float32BufferAttribute(vertices, 3));\n\n    _this.setAttribute('normal', new _three.Float32BufferAttribute(normals, 3));\n\n    _this.setAttribute('uv', new _three.Float32BufferAttribute(uvs, 2));\n\n    function generate() {\n      var i;\n      var decalVertices = [];\n      var vertex = new _three.Vector3();\n      var normal = new _three.Vector3(); // handle different geometry types\n\n      if (mesh.geometry.isGeometry === true) {\n        console.error('THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.');\n        return;\n      }\n\n      var geometry = mesh.geometry;\n      var positionAttribute = geometry.attributes.position;\n      var normalAttribute = geometry.attributes.normal; // first, create an array of 'DecalVertex' objects\n      // three consecutive 'DecalVertex' objects represent a single face\n      //\n      // this data structure will be later used to perform the clipping\n\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n        var index = geometry.index;\n\n        for (i = 0; i < index.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, index.getX(i));\n          normal.fromBufferAttribute(normalAttribute, index.getX(i));\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } else {\n        // non-indexed BufferGeometry\n        for (i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n          normal.fromBufferAttribute(normalAttribute, i);\n          pushDecalVertex(decalVertices, vertex, normal);\n        }\n      } // second, clip the geometry so that it doesn't extend out from the projector\n\n\n      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1)); // third, generate final vertices, normals and uvs\n\n      for (i = 0; i < decalVertices.length; i++) {\n        var decalVertex = decalVertices[i]; // create texture coordinates (we are still in projector space)\n\n        uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y); // transform the vertex back to world space\n\n        decalVertex.position.applyMatrix4(projectorMatrix); // now create vertex and normal buffer data\n\n        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);\n        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);\n      }\n    }\n\n    function pushDecalVertex(decalVertices, vertex, normal) {\n      // transform the vertex to world space, then to projector space\n      vertex.applyMatrix4(mesh.matrixWorld);\n      vertex.applyMatrix4(projectorMatrixInverse);\n      normal.transformDirection(mesh.matrixWorld);\n      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));\n    }\n\n    function clipGeometry(inVertices, plane) {\n      var outVertices = [];\n      var s = 0.5 * Math.abs(size.dot(plane)); // a single iteration clips one face,\n      // which consists of three consecutive 'DecalVertex' objects\n\n      for (var i = 0; i < inVertices.length; i += 3) {\n        var v1Out = void 0,\n            v2Out = void 0,\n            v3Out = void 0,\n            total = 0;\n        var nV1 = void 0,\n            nV2 = void 0,\n            nV3 = void 0,\n            nV4 = void 0;\n        var d1 = inVertices[i + 0].position.dot(plane) - s;\n        var d2 = inVertices[i + 1].position.dot(plane) - s;\n        var d3 = inVertices[i + 2].position.dot(plane) - s;\n        v1Out = d1 > 0;\n        v2Out = d2 > 0;\n        v3Out = d3 > 0; // calculate, how many vertices of the face lie outside of the clipping plane\n\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n\n        switch (total) {\n          case 0:\n            {\n              // the entire face lies inside of the plane, no clipping needed\n              outVertices.push(inVertices[i]);\n              outVertices.push(inVertices[i + 1]);\n              outVertices.push(inVertices[i + 2]);\n              break;\n            }\n\n          case 1:\n            {\n              // one vertex lies outside of the plane, perform clipping\n              if (v1Out) {\n                nV1 = inVertices[i + 1];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i], nV1, plane, s);\n                nV4 = clip(inVertices[i], nV2, plane, s);\n              }\n\n              if (v2Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 2];\n                nV3 = clip(inVertices[i + 1], nV1, plane, s);\n                nV4 = clip(inVertices[i + 1], nV2, plane, s);\n                outVertices.push(nV3);\n                outVertices.push(nV2.clone());\n                outVertices.push(nV1.clone());\n                outVertices.push(nV2.clone());\n                outVertices.push(nV3.clone());\n                outVertices.push(nV4);\n                break;\n              }\n\n              if (v3Out) {\n                nV1 = inVertices[i];\n                nV2 = inVertices[i + 1];\n                nV3 = clip(inVertices[i + 2], nV1, plane, s);\n                nV4 = clip(inVertices[i + 2], nV2, plane, s);\n              }\n\n              outVertices.push(nV1.clone());\n              outVertices.push(nV2.clone());\n              outVertices.push(nV3);\n              outVertices.push(nV4);\n              outVertices.push(nV3.clone());\n              outVertices.push(nV2.clone());\n              break;\n            }\n\n          case 2:\n            {\n              // two vertices lies outside of the plane, perform clipping\n              if (!v1Out) {\n                nV1 = inVertices[i].clone();\n                nV2 = clip(nV1, inVertices[i + 1], plane, s);\n                nV3 = clip(nV1, inVertices[i + 2], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              if (!v2Out) {\n                nV1 = inVertices[i + 1].clone();\n                nV2 = clip(nV1, inVertices[i + 2], plane, s);\n                nV3 = clip(nV1, inVertices[i], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              if (!v3Out) {\n                nV1 = inVertices[i + 2].clone();\n                nV2 = clip(nV1, inVertices[i], plane, s);\n                nV3 = clip(nV1, inVertices[i + 1], plane, s);\n                outVertices.push(nV1);\n                outVertices.push(nV2);\n                outVertices.push(nV3);\n              }\n\n              break;\n            }\n        }\n      }\n\n      return outVertices;\n    }\n\n    function clip(v0, v1, p, s) {\n      var d0 = v0.position.dot(p) - s;\n      var d1 = v1.position.dot(p) - s;\n      var s0 = d0 / (d0 - d1);\n      var v = new DecalVertex(new _three.Vector3(v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new _three.Vector3(v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z))); // need to clip more values (texture coordinates)? do it this way:\n      // intersectpoint.value = a.value + s * ( b.value - a.value );\n\n      return v;\n    }\n\n    return _this;\n  }\n\n  return DecalGeometry;\n}(_three.BufferGeometry); // helper\n\n\nexports.DecalGeometry = DecalGeometry;\n\nvar DecalVertex =\n/*#__PURE__*/\nfunction () {\n  function DecalVertex(position, normal) {\n    _classCallCheck(this, DecalVertex);\n\n    this.position = position;\n    this.normal = normal;\n  }\n\n  _createClass(DecalVertex, [{\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this.position.clone(), this.normal.clone());\n    }\n  }]);\n\n  return DecalVertex;\n}();\n\nexports.DecalVertex = DecalVertex;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["prototype","key","__esModule","normal","position","configurable","value","enumerable","writable","__proto__","DecalGeometry","DecalVertex","constructor"]],"~:compiled-at",1630917515565,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$geometries$DecalGeometry.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/geometries/DecalGeometry.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$geometries$DecalGeometry\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.DecalVertex = exports.DecalGeometry = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * You can use this geometry to create a decal mesh, that serves different kinds of purposes.\\n * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams.\\n *\\n * Constructor parameter:\\n *\\n * mesh \\u2014 Any mesh object\\n * position \\u2014 Position of the decal projector\\n * orientation \\u2014 Orientation of the decal projector\\n * size \\u2014 Size of the decal projector\\n *\\n * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/\\n *\\n */\\nvar DecalGeometry =\\n/*#__PURE__*/\\nfunction (_BufferGeometry) {\\n  _inherits(DecalGeometry, _BufferGeometry);\\n\\n  function DecalGeometry(mesh, position, orientation, size) {\\n    var _this;\\n\\n    _classCallCheck(this, DecalGeometry);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DecalGeometry).call(this)); // buffers\\n\\n    var vertices = [];\\n    var normals = [];\\n    var uvs = []; // helpers\\n\\n    var plane = new _three.Vector3(); // this matrix represents the transformation of the decal projector\\n\\n    var projectorMatrix = new _three.Matrix4();\\n    projectorMatrix.makeRotationFromEuler(orientation);\\n    projectorMatrix.setPosition(position);\\n    var projectorMatrixInverse = new _three.Matrix4();\\n    projectorMatrixInverse.copy(projectorMatrix).invert(); // generate buffers\\n\\n    generate(); // build geometry\\n\\n    _this.setAttribute('position', new _three.Float32BufferAttribute(vertices, 3));\\n\\n    _this.setAttribute('normal', new _three.Float32BufferAttribute(normals, 3));\\n\\n    _this.setAttribute('uv', new _three.Float32BufferAttribute(uvs, 2));\\n\\n    function generate() {\\n      var i;\\n      var decalVertices = [];\\n      var vertex = new _three.Vector3();\\n      var normal = new _three.Vector3(); // handle different geometry types\\n\\n      if (mesh.geometry.isGeometry === true) {\\n        console.error('THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead.');\\n        return;\\n      }\\n\\n      var geometry = mesh.geometry;\\n      var positionAttribute = geometry.attributes.position;\\n      var normalAttribute = geometry.attributes.normal; // first, create an array of 'DecalVertex' objects\\n      // three consecutive 'DecalVertex' objects represent a single face\\n      //\\n      // this data structure will be later used to perform the clipping\\n\\n      if (geometry.index !== null) {\\n        // indexed BufferGeometry\\n        var index = geometry.index;\\n\\n        for (i = 0; i < index.count; i++) {\\n          vertex.fromBufferAttribute(positionAttribute, index.getX(i));\\n          normal.fromBufferAttribute(normalAttribute, index.getX(i));\\n          pushDecalVertex(decalVertices, vertex, normal);\\n        }\\n      } else {\\n        // non-indexed BufferGeometry\\n        for (i = 0; i < positionAttribute.count; i++) {\\n          vertex.fromBufferAttribute(positionAttribute, i);\\n          normal.fromBufferAttribute(normalAttribute, i);\\n          pushDecalVertex(decalVertices, vertex, normal);\\n        }\\n      } // second, clip the geometry so that it doesn't extend out from the projector\\n\\n\\n      decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));\\n      decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));\\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));\\n      decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));\\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));\\n      decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1)); // third, generate final vertices, normals and uvs\\n\\n      for (i = 0; i < decalVertices.length; i++) {\\n        var decalVertex = decalVertices[i]; // create texture coordinates (we are still in projector space)\\n\\n        uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y); // transform the vertex back to world space\\n\\n        decalVertex.position.applyMatrix4(projectorMatrix); // now create vertex and normal buffer data\\n\\n        vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);\\n        normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);\\n      }\\n    }\\n\\n    function pushDecalVertex(decalVertices, vertex, normal) {\\n      // transform the vertex to world space, then to projector space\\n      vertex.applyMatrix4(mesh.matrixWorld);\\n      vertex.applyMatrix4(projectorMatrixInverse);\\n      normal.transformDirection(mesh.matrixWorld);\\n      decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));\\n    }\\n\\n    function clipGeometry(inVertices, plane) {\\n      var outVertices = [];\\n      var s = 0.5 * Math.abs(size.dot(plane)); // a single iteration clips one face,\\n      // which consists of three consecutive 'DecalVertex' objects\\n\\n      for (var i = 0; i < inVertices.length; i += 3) {\\n        var v1Out = void 0,\\n            v2Out = void 0,\\n            v3Out = void 0,\\n            total = 0;\\n        var nV1 = void 0,\\n            nV2 = void 0,\\n            nV3 = void 0,\\n            nV4 = void 0;\\n        var d1 = inVertices[i + 0].position.dot(plane) - s;\\n        var d2 = inVertices[i + 1].position.dot(plane) - s;\\n        var d3 = inVertices[i + 2].position.dot(plane) - s;\\n        v1Out = d1 > 0;\\n        v2Out = d2 > 0;\\n        v3Out = d3 > 0; // calculate, how many vertices of the face lie outside of the clipping plane\\n\\n        total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\\n\\n        switch (total) {\\n          case 0:\\n            {\\n              // the entire face lies inside of the plane, no clipping needed\\n              outVertices.push(inVertices[i]);\\n              outVertices.push(inVertices[i + 1]);\\n              outVertices.push(inVertices[i + 2]);\\n              break;\\n            }\\n\\n          case 1:\\n            {\\n              // one vertex lies outside of the plane, perform clipping\\n              if (v1Out) {\\n                nV1 = inVertices[i + 1];\\n                nV2 = inVertices[i + 2];\\n                nV3 = clip(inVertices[i], nV1, plane, s);\\n                nV4 = clip(inVertices[i], nV2, plane, s);\\n              }\\n\\n              if (v2Out) {\\n                nV1 = inVertices[i];\\n                nV2 = inVertices[i + 2];\\n                nV3 = clip(inVertices[i + 1], nV1, plane, s);\\n                nV4 = clip(inVertices[i + 1], nV2, plane, s);\\n                outVertices.push(nV3);\\n                outVertices.push(nV2.clone());\\n                outVertices.push(nV1.clone());\\n                outVertices.push(nV2.clone());\\n                outVertices.push(nV3.clone());\\n                outVertices.push(nV4);\\n                break;\\n              }\\n\\n              if (v3Out) {\\n                nV1 = inVertices[i];\\n                nV2 = inVertices[i + 1];\\n                nV3 = clip(inVertices[i + 2], nV1, plane, s);\\n                nV4 = clip(inVertices[i + 2], nV2, plane, s);\\n              }\\n\\n              outVertices.push(nV1.clone());\\n              outVertices.push(nV2.clone());\\n              outVertices.push(nV3);\\n              outVertices.push(nV4);\\n              outVertices.push(nV3.clone());\\n              outVertices.push(nV2.clone());\\n              break;\\n            }\\n\\n          case 2:\\n            {\\n              // two vertices lies outside of the plane, perform clipping\\n              if (!v1Out) {\\n                nV1 = inVertices[i].clone();\\n                nV2 = clip(nV1, inVertices[i + 1], plane, s);\\n                nV3 = clip(nV1, inVertices[i + 2], plane, s);\\n                outVertices.push(nV1);\\n                outVertices.push(nV2);\\n                outVertices.push(nV3);\\n              }\\n\\n              if (!v2Out) {\\n                nV1 = inVertices[i + 1].clone();\\n                nV2 = clip(nV1, inVertices[i + 2], plane, s);\\n                nV3 = clip(nV1, inVertices[i], plane, s);\\n                outVertices.push(nV1);\\n                outVertices.push(nV2);\\n                outVertices.push(nV3);\\n              }\\n\\n              if (!v3Out) {\\n                nV1 = inVertices[i + 2].clone();\\n                nV2 = clip(nV1, inVertices[i], plane, s);\\n                nV3 = clip(nV1, inVertices[i + 1], plane, s);\\n                outVertices.push(nV1);\\n                outVertices.push(nV2);\\n                outVertices.push(nV3);\\n              }\\n\\n              break;\\n            }\\n        }\\n      }\\n\\n      return outVertices;\\n    }\\n\\n    function clip(v0, v1, p, s) {\\n      var d0 = v0.position.dot(p) - s;\\n      var d1 = v1.position.dot(p) - s;\\n      var s0 = d0 / (d0 - d1);\\n      var v = new DecalVertex(new _three.Vector3(v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new _three.Vector3(v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z))); // need to clip more values (texture coordinates)? do it this way:\\n      // intersectpoint.value = a.value + s * ( b.value - a.value );\\n\\n      return v;\\n    }\\n\\n    return _this;\\n  }\\n\\n  return DecalGeometry;\\n}(_three.BufferGeometry); // helper\\n\\n\\nexports.DecalGeometry = DecalGeometry;\\n\\nvar DecalVertex =\\n/*#__PURE__*/\\nfunction () {\\n  function DecalVertex(position, normal) {\\n    _classCallCheck(this, DecalVertex);\\n\\n    this.position = position;\\n    this.normal = normal;\\n  }\\n\\n  _createClass(DecalVertex, [{\\n    key: \\\"clone\\\",\\n    value: function clone() {\\n      return new this.constructor(this.position.clone(), this.normal.clone());\\n    }\\n  }]);\\n\\n  return DecalVertex;\\n}();\\n\\nexports.DecalVertex = DecalVertex;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"prototype\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"_classCallCheck\",\"instance\",\"TypeError\",\"_possibleConstructorReturn\",\"self\",\"call\",\"ReferenceError\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"DecalVertex\",\"DecalGeometry\",\"_three\",\"_BufferGeometry\",\"mesh\",\"position\",\"orientation\",\"size\",\"pushDecalVertex\",\"decalVertices\",\"vertex\",\"normal\",\"applyMatrix4\",\"matrixWorld\",\"projectorMatrixInverse\",\"transformDirection\",\"push\",\"clone\",\"clipGeometry\",\"inVertices\",\"plane\",\"outVertices\",\"s\",\"Math\",\"abs\",\"dot\",\"nV1\",\"nV2\",\"nV3\",\"nV4\",\"d1\",\"d2\",\"d3\",\"v1Out\",\"v2Out\",\"v3Out\",\"clip\",\"v0\",\"v1\",\"d0\",\"s0\",\"v\",\"Vector3\",\"x\",\"y\",\"z\",\"_this\",\"vertices\",\"normals\",\"uvs\",\"projectorMatrix\",\"Matrix4\",\"makeRotationFromEuler\",\"setPosition\",\"copy\",\"invert\",\"generate\",\"geometry\",\"isGeometry\",\"console\",\"error\",\"positionAttribute\",\"attributes\",\"normalAttribute\",\"index\",\"count\",\"fromBufferAttribute\",\"getX\",\"set\",\"decalVertex\",\"setAttribute\",\"Float32BufferAttribute\",\"BufferGeometry\"]\n}\n"]