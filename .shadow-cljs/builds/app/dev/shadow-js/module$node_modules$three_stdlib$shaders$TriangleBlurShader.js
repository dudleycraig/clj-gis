["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/TriangleBlurShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$TriangleBlurShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.TriangleBlurShader=void 0;global={uniforms:{texture:{value:null},delta:{value:new (require(\"module$node_modules$three$build$three_module\").Vector2)(1,1)}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"#include \\x3ccommon\\x3e\\n#define ITERATIONS 10.0\\nuniform sampler2D texture;\\nuniform vec2 delta;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 color \\x3d vec4( 0.0 );\\n\\tfloat total \\x3d 0.0;\\n\\tfloat offset \\x3d rand( vUv );\\n\\tfor ( float t \\x3d -ITERATIONS; t \\x3c\\x3d ITERATIONS; t ++ ) {\\n\\t\\tfloat percent \\x3d ( t + offset - 0.5 ) / ITERATIONS;\\n\\t\\tfloat weight \\x3d 1.0 - abs( percent );\\n\\t\\tcolor +\\x3d texture2D( texture, vUv + delta * percent ) * weight;\\n\\t\\ttotal +\\x3d weight;\\n\\t}\\n\\tgl_FragColor \\x3d color / total;\\n}\"};\nexports.TriangleBlurShader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$TriangleBlurShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TriangleBlurShader = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Triangle blur shader\n * based on glfx.js triangle blur shader\n * https://github.com/evanw/glfx.js\n *\n * A basic blur filter, which convolves the image with a\n * pyramid filter. The pyramid filter is separable and is applied as two\n * perpendicular triangle filters.\n */\nvar TriangleBlurShader = {\n  uniforms: {\n    texture: {\n      value: null\n    },\n    delta: {\n      value: new _three.Vector2(1, 1)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#define ITERATIONS 10.0', 'uniform sampler2D texture;', 'uniform vec2 delta;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color = vec4( 0.0 );', '\tfloat total = 0.0;', // randomize the lookup values to hide the fixed number of samples\n  '\tfloat offset = rand( vUv );', '\tfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {', '\t\tfloat percent = ( t + offset - 0.5 ) / ITERATIONS;', '\t\tfloat weight = 1.0 - abs( percent );', '\t\tcolor += texture2D( texture, vUv + delta * percent ) * weight;', '\t\ttotal += weight;', '\t}', '\tgl_FragColor = color / total;', '}'].join('\\n')\n};\nexports.TriangleBlurShader = TriangleBlurShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","texture","delta","__esModule","vertexShader","value","TriangleBlurShader","uniforms"]],"~:compiled-at",1630917515581,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$TriangleBlurShader.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,2DAAA,CAAgF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGxHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,kBAAR,CAA6B,IAAK,EAa9BA,OAAAA,CAAqB,CACvBC,SAAU,CACRC,QAAS,CACPH,MAAO,IADA,CADD,CAIRI,MAAO,CACLJ,MAAO,KAjBAL,OAAAU,CAAQ,8CAARA,CAiBWC,CAAAA,OAAX,EAAmB,CAAnB,CAAsB,CAAtB,CADF,CAJC,CADa,CASvBC,aAAiJ,qIAT1H,CAUvBC,eAC+T,uhBAXxS,CAazBX;OAAQI,CAAAA,kBAAR,CAA6BA,MAhC2F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/TriangleBlurShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$TriangleBlurShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.TriangleBlurShader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Triangle blur shader\\n * based on glfx.js triangle blur shader\\n * https://github.com/evanw/glfx.js\\n *\\n * A basic blur filter, which convolves the image with a\\n * pyramid filter. The pyramid filter is separable and is applied as two\\n * perpendicular triangle filters.\\n */\\nvar TriangleBlurShader = {\\n  uniforms: {\\n    texture: {\\n      value: null\\n    },\\n    delta: {\\n      value: new _three.Vector2(1, 1)\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['#include <common>', '#define ITERATIONS 10.0', 'uniform sampler2D texture;', 'uniform vec2 delta;', 'varying vec2 vUv;', 'void main() {', '\\tvec4 color = vec4( 0.0 );', '\\tfloat total = 0.0;', // randomize the lookup values to hide the fixed number of samples\\n  '\\tfloat offset = rand( vUv );', '\\tfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {', '\\t\\tfloat percent = ( t + offset - 0.5 ) / ITERATIONS;', '\\t\\tfloat weight = 1.0 - abs( percent );', '\\t\\tcolor += texture2D( texture, vUv + delta * percent ) * weight;', '\\t\\ttotal += weight;', '\\t}', '\\tgl_FragColor = color / total;', '}'].join('\\\\n')\\n};\\nexports.TriangleBlurShader = TriangleBlurShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"TriangleBlurShader\",\"uniforms\",\"texture\",\"delta\",\"_three\",\"Vector2\",\"vertexShader\",\"fragmentShader\"]\n}\n"]