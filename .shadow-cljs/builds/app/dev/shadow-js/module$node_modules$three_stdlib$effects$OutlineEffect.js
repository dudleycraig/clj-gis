["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/effects/OutlineEffect.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$effects$OutlineEffect=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.OutlineEffect=void 0;var _three=require(\"module$node_modules$three$build$three_module\");exports.OutlineEffect=function(renderer$jscomp$0,parameters){function getOutlineMaterial(originalMaterial){var outlineMaterial=cache[originalMaterial.uuid];void 0===outlineMaterial&&(outlineMaterial={material:new _three.ShaderMaterial({type:\"OutlineEffect\",\nuniforms:_three.UniformsUtils.merge([_three.UniformsLib.fog,_three.UniformsLib.displacementmap,uniformsOutline]),vertexShader:\"#include \\x3ccommon\\x3e\\n#include \\x3cuv_pars_vertex\\x3e\\n#include \\x3cdisplacementmap_pars_vertex\\x3e\\n#include \\x3cfog_pars_vertex\\x3e\\n#include \\x3cmorphtarget_pars_vertex\\x3e\\n#include \\x3cskinning_pars_vertex\\x3e\\n#include \\x3clogdepthbuf_pars_vertex\\x3e\\n#include \\x3cclipping_planes_pars_vertex\\x3e\\nuniform float outlineThickness;\\nvec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {\\n\\tfloat thickness \\x3d outlineThickness;\\n\\tconst float ratio \\x3d 1.0;\\n\\tvec4 pos2 \\x3d projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );\\n\\tvec4 norm \\x3d normalize( pos - pos2 );\\n\\treturn pos + norm * thickness * pos.w * ratio;\\n}\\nvoid main() {\\n\\t#include \\x3cuv_vertex\\x3e\\n\\t#include \\x3cbeginnormal_vertex\\x3e\\n\\t#include \\x3cmorphnormal_vertex\\x3e\\n\\t#include \\x3cskinbase_vertex\\x3e\\n\\t#include \\x3cskinnormal_vertex\\x3e\\n\\t#include \\x3cbegin_vertex\\x3e\\n\\t#include \\x3cmorphtarget_vertex\\x3e\\n\\t#include \\x3cskinning_vertex\\x3e\\n\\t#include \\x3cdisplacementmap_vertex\\x3e\\n\\t#include \\x3cproject_vertex\\x3e\\n\\tvec3 outlineNormal \\x3d - objectNormal;\\n\\tgl_Position \\x3d calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );\\n\\t#include \\x3clogdepthbuf_vertex\\x3e\\n\\t#include \\x3cclipping_planes_vertex\\x3e\\n\\t#include \\x3cfog_vertex\\x3e\\n}\",\nfragmentShader:\"#include \\x3ccommon\\x3e\\n#include \\x3cfog_pars_fragment\\x3e\\n#include \\x3clogdepthbuf_pars_fragment\\x3e\\n#include \\x3cclipping_planes_pars_fragment\\x3e\\nuniform vec3 outlineColor;\\nuniform float outlineAlpha;\\nvoid main() {\\n\\t#include \\x3cclipping_planes_fragment\\x3e\\n\\t#include \\x3clogdepthbuf_fragment\\x3e\\n\\tgl_FragColor \\x3d vec4( outlineColor, outlineAlpha );\\n\\t#include \\x3ctonemapping_fragment\\x3e\\n\\t#include \\x3cencodings_fragment\\x3e\\n\\t#include \\x3cfog_fragment\\x3e\\n\\t#include \\x3cpremultiplied_alpha_fragment\\x3e\\n}\",\nside:_three.BackSide}),used:!0,keepAlive:defaultKeepAlive,count:0},cache[originalMaterial.uuid]=outlineMaterial);outlineMaterial.used=!0;outlineMaterial=outlineMaterial.material;originalMaterials[outlineMaterial.uuid]=originalMaterial;if(\"invisible\"!==outlineMaterial.name){var outlineParameters=originalMaterial.userData.outlineParameters;outlineMaterial.skinning=originalMaterial.skinning;outlineMaterial.morphTargets=originalMaterial.morphTargets;outlineMaterial.morphNormals=originalMaterial.morphNormals;\noutlineMaterial.fog=originalMaterial.fog;outlineMaterial.toneMapped=originalMaterial.toneMapped;outlineMaterial.premultipliedAlpha=originalMaterial.premultipliedAlpha;outlineMaterial.displacementMap=originalMaterial.displacementMap;void 0!==outlineParameters?(outlineMaterial.visible=!1===originalMaterial.visible?!1:void 0!==outlineParameters.visible?outlineParameters.visible:!0,outlineMaterial.transparent=void 0!==outlineParameters.alpha&&1>outlineParameters.alpha?!0:originalMaterial.transparent,\nvoid 0!==outlineParameters.keepAlive&&(cache[originalMaterial.uuid].keepAlive=outlineParameters.keepAlive)):(outlineMaterial.transparent=originalMaterial.transparent,outlineMaterial.visible=originalMaterial.visible);if(!0===originalMaterial.wireframe||!1===originalMaterial.depthTest)outlineMaterial.visible=!1;originalMaterial.clippingPlanes&&(outlineMaterial.clipping=!0,outlineMaterial.clippingPlanes=originalMaterial.clippingPlanes,outlineMaterial.clipIntersection=originalMaterial.clipIntersection,\noutlineMaterial.clipShadows=originalMaterial.clipShadows);outlineMaterial.version=originalMaterial.version}return outlineMaterial}function isCompatible(object){var geometry=object.geometry,hasNormals=!1;void 0!==object.geometry&&(hasNormals=geometry.isBufferGeometry?void 0!==geometry.attributes.normal:!0);return!0===object.isMesh&&void 0!==object.material&&!0===hasNormals}function setOutlineMaterial(object){if(!1!==isCompatible(object)){if(Array.isArray(object.material))for(var i=0,il=object.material.length;i<\nil;i++)object.material[i]=getOutlineMaterial(object.material[i]);else object.material=getOutlineMaterial(object.material);originalOnBeforeRenders[object.uuid]=object.onBeforeRender;object.onBeforeRender=onBeforeRender}}function restoreOriginalMaterial(object){if(!1!==isCompatible(object)){if(Array.isArray(object.material))for(var i=0,il=object.material.length;i<il;i++)object.material[i]=originalMaterials[object.material[i].uuid];else object.material=originalMaterials[object.material.uuid];object.onBeforeRender=\noriginalOnBeforeRenders[object.uuid]}}function onBeforeRender(renderer,scene,camera,geometry,material){renderer=originalMaterials[material.uuid];void 0!==renderer&&(scene=renderer.userData.outlineParameters,material.uniforms.outlineAlpha.value=renderer.opacity,void 0!==scene&&(void 0!==scene.thickness&&(material.uniforms.outlineThickness.value=scene.thickness),void 0!==scene.color&&material.uniforms.outlineColor.value.fromArray(scene.color),void 0!==scene.alpha&&(material.uniforms.outlineAlpha.value=\nscene.alpha)),renderer.displacementMap&&(material.uniforms.displacementMap.value=renderer.displacementMap,material.uniforms.displacementScale.value=renderer.displacementScale,material.uniforms.displacementBias.value=renderer.displacementBias))}parameters=parameters||{};this.enabled=!0;var defaultThickness=void 0!==parameters.defaultThickness?parameters.defaultThickness:.003,defaultColor=(new _three.Color).fromArray(void 0!==parameters.defaultColor?parameters.defaultColor:[0,0,0]),defaultKeepAlive=\nvoid 0!==parameters.defaultKeepAlive?parameters.defaultKeepAlive:!1,cache={},originalMaterials={},originalOnBeforeRenders={},uniformsOutline={outlineThickness:{value:defaultThickness},outlineColor:{value:defaultColor},outlineAlpha:{value:void 0!==parameters.defaultAlpha?parameters.defaultAlpha:1}};this.render=function(scene,camera,JSCompiler_OptimizeArgumentsArray_p7,JSCompiler_OptimizeArgumentsArray_p8){var forceClear=!1;if(void 0!==JSCompiler_OptimizeArgumentsArray_p7){console.warn(\"THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.\");\nvar renderTarget=JSCompiler_OptimizeArgumentsArray_p7}void 0!==JSCompiler_OptimizeArgumentsArray_p8&&(console.warn(\"THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead.\"),forceClear=JSCompiler_OptimizeArgumentsArray_p8);void 0!==renderTarget&&renderer$jscomp$0.setRenderTarget(renderTarget);forceClear&&renderer$jscomp$0.clear();!1===this.enabled?renderer$jscomp$0.render(scene,camera):(JSCompiler_OptimizeArgumentsArray_p7=renderer$jscomp$0.autoClear,renderer$jscomp$0.autoClear=\nthis.autoClear,renderer$jscomp$0.render(scene,camera),renderer$jscomp$0.autoClear=JSCompiler_OptimizeArgumentsArray_p7,this.renderOutline(scene,camera))};this.renderOutline=function(scene,camera){var currentAutoClear=renderer$jscomp$0.autoClear,currentSceneAutoUpdate=scene.autoUpdate,currentSceneBackground=scene.background,currentShadowMapEnabled=renderer$jscomp$0.shadowMap.enabled;scene.autoUpdate=!1;scene.background=null;renderer$jscomp$0.autoClear=!1;renderer$jscomp$0.shadowMap.enabled=!1;scene.traverse(setOutlineMaterial);\nrenderer$jscomp$0.render(scene,camera);scene.traverse(restoreOriginalMaterial);camera=Object.keys(originalMaterials);for(var i=0,il=camera.length;i<il;i++)originalMaterials[camera[i]]=void 0;camera=Object.keys(originalOnBeforeRenders);i=0;for(il=camera.length;i<il;i++)originalOnBeforeRenders[camera[i]]=void 0;camera=Object.keys(cache);i=0;for(il=camera.length;i<il;i++){var key=camera[i];!1===cache[key].used?(cache[key].count++,!1===cache[key].keepAlive&&60<cache[key].count&&delete cache[key]):(cache[key].used=\n!1,cache[key].count=0)}scene.autoUpdate=currentSceneAutoUpdate;scene.background=currentSceneBackground;renderer$jscomp$0.autoClear=currentAutoClear;renderer$jscomp$0.shadowMap.enabled=currentShadowMapEnabled};this.autoClear=renderer$jscomp$0.autoClear;this.domElement=renderer$jscomp$0.domElement;this.shadowMap=renderer$jscomp$0.shadowMap;this.clear=function(color,depth,stencil){renderer$jscomp$0.clear(color,depth,stencil)};this.getPixelRatio=function(){return renderer$jscomp$0.getPixelRatio()};this.setPixelRatio=\nfunction(value){renderer$jscomp$0.setPixelRatio(value)};this.getSize=function(target){return renderer$jscomp$0.getSize(target)};this.setSize=function(width,height,updateStyle){renderer$jscomp$0.setSize(width,height,updateStyle)};this.setViewport=function(x,y,width,height){renderer$jscomp$0.setViewport(x,y,width,height)};this.setScissor=function(x,y,width,height){renderer$jscomp$0.setScissor(x,y,width,height)};this.setScissorTest=function(_boolean){renderer$jscomp$0.setScissorTest(_boolean)};this.setRenderTarget=\nfunction(renderTarget){renderer$jscomp$0.setRenderTarget(renderTarget)}}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$effects$OutlineEffect\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OutlineEffect = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\n *\n * API\n *\n * 1. Traditional\n *\n * var effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n *\n * 2. VR compatible\n *\n * var effect = new OutlineEffect( renderer );\n * var renderingOutline = false;\n *\n * scene.onAfterRender = function () {\n *\n * \tif ( renderingOutline ) return;\n *\n * \trenderingOutline = true;\n *\n * \teffect.renderOutline( scene, camera );\n *\n * \trenderingOutline = false;\n *\n * };\n *\n * function render() {\n *\n * \trenderer.render( scene, camera );\n *\n * }\n *\n * // How to set default outline parameters\n * new OutlineEffect( renderer, {\n * \tdefaultThickness: 0.01,\n * \tdefaultColor: [ 0, 0, 0 ],\n * \tdefaultAlpha: 0.8,\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n * } );\n *\n * // How to set outline parameters for each material\n * material.userData.outlineParameters = {\n * \tthickness: 0.01,\n * \tcolor: [ 0, 0, 0 ]\n * \talpha: 0.8,\n * \tvisible: true,\n * \tkeepAlive: true\n * };\n */\nvar OutlineEffect = function OutlineEffect(renderer, parameters) {\n  parameters = parameters || {};\n  this.enabled = true;\n  var defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n  var defaultColor = new _three.Color().fromArray(parameters.defaultColor !== undefined ? parameters.defaultColor : [0, 0, 0]);\n  var defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n  var defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false; // object.material.uuid -> outlineMaterial or\n  // object.material[ n ].uuid -> outlineMaterial\n  // save at the outline material creation and release\n  // if it's unused removeThresholdCount frames\n  // unless keepAlive is true.\n\n  var cache = {};\n  var removeThresholdCount = 60; // outlineMaterial.uuid -> object.material or\n  // outlineMaterial.uuid -> object.material[ n ]\n  // save before render and release after render.\n\n  var originalMaterials = {}; // object.uuid -> originalOnBeforeRender\n  // save before render and release after render.\n\n  var originalOnBeforeRenders = {}; //this.cache = cache;  // for debug\n\n  var uniformsOutline = {\n    outlineThickness: {\n      value: defaultThickness\n    },\n    outlineColor: {\n      value: defaultColor\n    },\n    outlineAlpha: {\n      value: defaultAlpha\n    }\n  };\n  var vertexShader = ['#include <common>', '#include <uv_pars_vertex>', '#include <displacementmap_pars_vertex>', '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>', 'uniform float outlineThickness;', 'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {', '\tfloat thickness = outlineThickness;', '\tconst float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex\n  '\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );', // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n  '\tvec4 norm = normalize( pos - pos2 );', '\treturn pos + norm * thickness * pos.w * ratio;', '}', 'void main() {', '\t#include <uv_vertex>', '\t#include <beginnormal_vertex>', '\t#include <morphnormal_vertex>', '\t#include <skinbase_vertex>', '\t#include <skinnormal_vertex>', '\t#include <begin_vertex>', '\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <displacementmap_vertex>', '\t#include <project_vertex>', '\tvec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide\n  '\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\t#include <fog_vertex>', '}'].join('\\n');\n  var fragmentShader = ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>', 'uniform vec3 outlineColor;', 'uniform float outlineAlpha;', 'void main() {', '\t#include <clipping_planes_fragment>', '\t#include <logdepthbuf_fragment>', '\tgl_FragColor = vec4( outlineColor, outlineAlpha );', '\t#include <tonemapping_fragment>', '\t#include <encodings_fragment>', '\t#include <fog_fragment>', '\t#include <premultiplied_alpha_fragment>', '}'].join('\\n');\n\n  function createMaterial() {\n    return new _three.ShaderMaterial({\n      type: 'OutlineEffect',\n      uniforms: _three.UniformsUtils.merge([_three.UniformsLib['fog'], _three.UniformsLib['displacementmap'], uniformsOutline]),\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      side: _three.BackSide\n    });\n  }\n\n  function getOutlineMaterialFromCache(originalMaterial) {\n    var data = cache[originalMaterial.uuid];\n\n    if (data === undefined) {\n      data = {\n        material: createMaterial(),\n        used: true,\n        keepAlive: defaultKeepAlive,\n        count: 0\n      };\n      cache[originalMaterial.uuid] = data;\n    }\n\n    data.used = true;\n    return data.material;\n  }\n\n  function getOutlineMaterial(originalMaterial) {\n    var outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n    originalMaterials[outlineMaterial.uuid] = originalMaterial;\n    updateOutlineMaterial(outlineMaterial, originalMaterial);\n    return outlineMaterial;\n  }\n\n  function isCompatible(object) {\n    var geometry = object.geometry;\n    var hasNormals = false;\n\n    if (object.geometry !== undefined) {\n      if (geometry.isBufferGeometry) {\n        hasNormals = geometry.attributes.normal !== undefined;\n      } else {\n        hasNormals = true; // the renderer always produces a normal attribute for Geometry\n      }\n    }\n\n    return object.isMesh === true && object.material !== undefined && hasNormals === true;\n  }\n\n  function setOutlineMaterial(object) {\n    if (isCompatible(object) === false) return;\n\n    if (Array.isArray(object.material)) {\n      for (var i = 0, il = object.material.length; i < il; i++) {\n        object.material[i] = getOutlineMaterial(object.material[i]);\n      }\n    } else {\n      object.material = getOutlineMaterial(object.material);\n    }\n\n    originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n    object.onBeforeRender = onBeforeRender;\n  }\n\n  function restoreOriginalMaterial(object) {\n    if (isCompatible(object) === false) return;\n\n    if (Array.isArray(object.material)) {\n      for (var i = 0, il = object.material.length; i < il; i++) {\n        object.material[i] = originalMaterials[object.material[i].uuid];\n      }\n    } else {\n      object.material = originalMaterials[object.material.uuid];\n    }\n\n    object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n  }\n\n  function onBeforeRender(renderer, scene, camera, geometry, material) {\n    var originalMaterial = originalMaterials[material.uuid]; // just in case\n\n    if (originalMaterial === undefined) return;\n    updateUniforms(material, originalMaterial);\n  }\n\n  function updateUniforms(material, originalMaterial) {\n    var outlineParameters = originalMaterial.userData.outlineParameters;\n    material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n\n    if (outlineParameters !== undefined) {\n      if (outlineParameters.thickness !== undefined) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n      if (outlineParameters.color !== undefined) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n      if (outlineParameters.alpha !== undefined) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n    }\n\n    if (originalMaterial.displacementMap) {\n      material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n      material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n      material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n    }\n  }\n\n  function updateOutlineMaterial(material, originalMaterial) {\n    if (material.name === 'invisible') return;\n    var outlineParameters = originalMaterial.userData.outlineParameters;\n    material.skinning = originalMaterial.skinning;\n    material.morphTargets = originalMaterial.morphTargets;\n    material.morphNormals = originalMaterial.morphNormals;\n    material.fog = originalMaterial.fog;\n    material.toneMapped = originalMaterial.toneMapped;\n    material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n    material.displacementMap = originalMaterial.displacementMap;\n\n    if (outlineParameters !== undefined) {\n      if (originalMaterial.visible === false) {\n        material.visible = false;\n      } else {\n        material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true;\n      }\n\n      material.transparent = outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ? true : originalMaterial.transparent;\n      if (outlineParameters.keepAlive !== undefined) cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n    } else {\n      material.transparent = originalMaterial.transparent;\n      material.visible = originalMaterial.visible;\n    }\n\n    if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;\n\n    if (originalMaterial.clippingPlanes) {\n      material.clipping = true;\n      material.clippingPlanes = originalMaterial.clippingPlanes;\n      material.clipIntersection = originalMaterial.clipIntersection;\n      material.clipShadows = originalMaterial.clipShadows;\n    }\n\n    material.version = originalMaterial.version; // update outline material if necessary\n  }\n\n  function cleanupCache() {\n    var keys; // clear originialMaterials\n\n    keys = Object.keys(originalMaterials);\n\n    for (var i = 0, il = keys.length; i < il; i++) {\n      originalMaterials[keys[i]] = undefined;\n    } // clear originalOnBeforeRenders\n\n\n    keys = Object.keys(originalOnBeforeRenders);\n\n    for (var _i = 0, _il = keys.length; _i < _il; _i++) {\n      originalOnBeforeRenders[keys[_i]] = undefined;\n    } // remove unused outlineMaterial from cache\n\n\n    keys = Object.keys(cache);\n\n    for (var _i2 = 0, _il2 = keys.length; _i2 < _il2; _i2++) {\n      var key = keys[_i2];\n\n      if (cache[key].used === false) {\n        cache[key].count++;\n\n        if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n          delete cache[key];\n        }\n      } else {\n        cache[key].used = false;\n        cache[key].count = 0;\n      }\n    }\n  }\n\n  this.render = function (scene, camera) {\n    var renderTarget;\n    var forceClear = false;\n\n    if (arguments[2] !== undefined) {\n      console.warn('THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');\n      renderTarget = arguments[2];\n    }\n\n    if (arguments[3] !== undefined) {\n      console.warn('THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead.');\n      forceClear = arguments[3];\n    }\n\n    if (renderTarget !== undefined) renderer.setRenderTarget(renderTarget);\n    if (forceClear) renderer.clear();\n\n    if (this.enabled === false) {\n      renderer.render(scene, camera);\n      return;\n    }\n\n    var currentAutoClear = renderer.autoClear;\n    renderer.autoClear = this.autoClear;\n    renderer.render(scene, camera);\n    renderer.autoClear = currentAutoClear;\n    this.renderOutline(scene, camera);\n  };\n\n  this.renderOutline = function (scene, camera) {\n    var currentAutoClear = renderer.autoClear;\n    var currentSceneAutoUpdate = scene.autoUpdate;\n    var currentSceneBackground = scene.background;\n    var currentShadowMapEnabled = renderer.shadowMap.enabled;\n    scene.autoUpdate = false;\n    scene.background = null;\n    renderer.autoClear = false;\n    renderer.shadowMap.enabled = false;\n    scene.traverse(setOutlineMaterial);\n    renderer.render(scene, camera);\n    scene.traverse(restoreOriginalMaterial);\n    cleanupCache();\n    scene.autoUpdate = currentSceneAutoUpdate;\n    scene.background = currentSceneBackground;\n    renderer.autoClear = currentAutoClear;\n    renderer.shadowMap.enabled = currentShadowMapEnabled;\n  };\n  /*\n   * See #9918\n   *\n   * The following property copies and wrapper methods enable\n   * OutlineEffect to be called from other *Effect, like\n   *\n   * effect = new StereoEffect( new OutlineEffect( renderer ) );\n   *\n   * function render () {\n   *\n   * \teffect.render( scene, camera );\n   *\n   * }\n   */\n\n\n  this.autoClear = renderer.autoClear;\n  this.domElement = renderer.domElement;\n  this.shadowMap = renderer.shadowMap;\n\n  this.clear = function (color, depth, stencil) {\n    renderer.clear(color, depth, stencil);\n  };\n\n  this.getPixelRatio = function () {\n    return renderer.getPixelRatio();\n  };\n\n  this.setPixelRatio = function (value) {\n    renderer.setPixelRatio(value);\n  };\n\n  this.getSize = function (target) {\n    return renderer.getSize(target);\n  };\n\n  this.setSize = function (width, height, updateStyle) {\n    renderer.setSize(width, height, updateStyle);\n  };\n\n  this.setViewport = function (x, y, width, height) {\n    renderer.setViewport(x, y, width, height);\n  };\n\n  this.setScissor = function (x, y, width, height) {\n    renderer.setScissor(x, y, width, height);\n  };\n\n  this.setScissorTest = function (_boolean) {\n    renderer.setScissorTest(_boolean);\n  };\n\n  this.setRenderTarget = function (renderTarget) {\n    renderer.setRenderTarget(renderTarget);\n  };\n};\n\nexports.OutlineEffect = OutlineEffect;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","setRenderTarget","outlineThickness","setViewport","outlineAlpha","displacementMap","skinning","transparent","side","autoUpdate","fog","clipShadows","__esModule","OutlineEffect","onBeforeRender","enabled","used","premultipliedAlpha","count","vertexShader","value","visible","toneMapped","setScissor","clipping","autoClear","clippingPlanes","renderOutline","setPixelRatio","type","shadowMap","render","outlineColor","version","setSize","morphTargets","clear","uniforms","getSize","background","setScissorTest","morphNormals","getPixelRatio","domElement","keepAlive","clipIntersection","material"]],"~:compiled-at",1630917515598,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$effects$OutlineEffect.js\",\n\"lineCount\":17,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/effects/OutlineEffect.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$effects$OutlineEffect\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.OutlineEffect = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\\n *\\n * API\\n *\\n * 1. Traditional\\n *\\n * var effect = new OutlineEffect( renderer );\\n *\\n * function render() {\\n *\\n * \\teffect.render( scene, camera );\\n *\\n * }\\n *\\n * 2. VR compatible\\n *\\n * var effect = new OutlineEffect( renderer );\\n * var renderingOutline = false;\\n *\\n * scene.onAfterRender = function () {\\n *\\n * \\tif ( renderingOutline ) return;\\n *\\n * \\trenderingOutline = true;\\n *\\n * \\teffect.renderOutline( scene, camera );\\n *\\n * \\trenderingOutline = false;\\n *\\n * };\\n *\\n * function render() {\\n *\\n * \\trenderer.render( scene, camera );\\n *\\n * }\\n *\\n * // How to set default outline parameters\\n * new OutlineEffect( renderer, {\\n * \\tdefaultThickness: 0.01,\\n * \\tdefaultColor: [ 0, 0, 0 ],\\n * \\tdefaultAlpha: 0.8,\\n * \\tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\\n * } );\\n *\\n * // How to set outline parameters for each material\\n * material.userData.outlineParameters = {\\n * \\tthickness: 0.01,\\n * \\tcolor: [ 0, 0, 0 ]\\n * \\talpha: 0.8,\\n * \\tvisible: true,\\n * \\tkeepAlive: true\\n * };\\n */\\nvar OutlineEffect = function OutlineEffect(renderer, parameters) {\\n  parameters = parameters || {};\\n  this.enabled = true;\\n  var defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\\n  var defaultColor = new _three.Color().fromArray(parameters.defaultColor !== undefined ? parameters.defaultColor : [0, 0, 0]);\\n  var defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\\n  var defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false; // object.material.uuid -> outlineMaterial or\\n  // object.material[ n ].uuid -> outlineMaterial\\n  // save at the outline material creation and release\\n  // if it's unused removeThresholdCount frames\\n  // unless keepAlive is true.\\n\\n  var cache = {};\\n  var removeThresholdCount = 60; // outlineMaterial.uuid -> object.material or\\n  // outlineMaterial.uuid -> object.material[ n ]\\n  // save before render and release after render.\\n\\n  var originalMaterials = {}; // object.uuid -> originalOnBeforeRender\\n  // save before render and release after render.\\n\\n  var originalOnBeforeRenders = {}; //this.cache = cache;  // for debug\\n\\n  var uniformsOutline = {\\n    outlineThickness: {\\n      value: defaultThickness\\n    },\\n    outlineColor: {\\n      value: defaultColor\\n    },\\n    outlineAlpha: {\\n      value: defaultAlpha\\n    }\\n  };\\n  var vertexShader = ['#include <common>', '#include <uv_pars_vertex>', '#include <displacementmap_pars_vertex>', '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>', 'uniform float outlineThickness;', 'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {', '\\tfloat thickness = outlineThickness;', '\\tconst float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex\\n  '\\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );', // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\\n  '\\tvec4 norm = normalize( pos - pos2 );', '\\treturn pos + norm * thickness * pos.w * ratio;', '}', 'void main() {', '\\t#include <uv_vertex>', '\\t#include <beginnormal_vertex>', '\\t#include <morphnormal_vertex>', '\\t#include <skinbase_vertex>', '\\t#include <skinnormal_vertex>', '\\t#include <begin_vertex>', '\\t#include <morphtarget_vertex>', '\\t#include <skinning_vertex>', '\\t#include <displacementmap_vertex>', '\\t#include <project_vertex>', '\\tvec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide\\n  '\\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );', '\\t#include <logdepthbuf_vertex>', '\\t#include <clipping_planes_vertex>', '\\t#include <fog_vertex>', '}'].join('\\\\n');\\n  var fragmentShader = ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>', 'uniform vec3 outlineColor;', 'uniform float outlineAlpha;', 'void main() {', '\\t#include <clipping_planes_fragment>', '\\t#include <logdepthbuf_fragment>', '\\tgl_FragColor = vec4( outlineColor, outlineAlpha );', '\\t#include <tonemapping_fragment>', '\\t#include <encodings_fragment>', '\\t#include <fog_fragment>', '\\t#include <premultiplied_alpha_fragment>', '}'].join('\\\\n');\\n\\n  function createMaterial() {\\n    return new _three.ShaderMaterial({\\n      type: 'OutlineEffect',\\n      uniforms: _three.UniformsUtils.merge([_three.UniformsLib['fog'], _three.UniformsLib['displacementmap'], uniformsOutline]),\\n      vertexShader: vertexShader,\\n      fragmentShader: fragmentShader,\\n      side: _three.BackSide\\n    });\\n  }\\n\\n  function getOutlineMaterialFromCache(originalMaterial) {\\n    var data = cache[originalMaterial.uuid];\\n\\n    if (data === undefined) {\\n      data = {\\n        material: createMaterial(),\\n        used: true,\\n        keepAlive: defaultKeepAlive,\\n        count: 0\\n      };\\n      cache[originalMaterial.uuid] = data;\\n    }\\n\\n    data.used = true;\\n    return data.material;\\n  }\\n\\n  function getOutlineMaterial(originalMaterial) {\\n    var outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\\n    originalMaterials[outlineMaterial.uuid] = originalMaterial;\\n    updateOutlineMaterial(outlineMaterial, originalMaterial);\\n    return outlineMaterial;\\n  }\\n\\n  function isCompatible(object) {\\n    var geometry = object.geometry;\\n    var hasNormals = false;\\n\\n    if (object.geometry !== undefined) {\\n      if (geometry.isBufferGeometry) {\\n        hasNormals = geometry.attributes.normal !== undefined;\\n      } else {\\n        hasNormals = true; // the renderer always produces a normal attribute for Geometry\\n      }\\n    }\\n\\n    return object.isMesh === true && object.material !== undefined && hasNormals === true;\\n  }\\n\\n  function setOutlineMaterial(object) {\\n    if (isCompatible(object) === false) return;\\n\\n    if (Array.isArray(object.material)) {\\n      for (var i = 0, il = object.material.length; i < il; i++) {\\n        object.material[i] = getOutlineMaterial(object.material[i]);\\n      }\\n    } else {\\n      object.material = getOutlineMaterial(object.material);\\n    }\\n\\n    originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\\n    object.onBeforeRender = onBeforeRender;\\n  }\\n\\n  function restoreOriginalMaterial(object) {\\n    if (isCompatible(object) === false) return;\\n\\n    if (Array.isArray(object.material)) {\\n      for (var i = 0, il = object.material.length; i < il; i++) {\\n        object.material[i] = originalMaterials[object.material[i].uuid];\\n      }\\n    } else {\\n      object.material = originalMaterials[object.material.uuid];\\n    }\\n\\n    object.onBeforeRender = originalOnBeforeRenders[object.uuid];\\n  }\\n\\n  function onBeforeRender(renderer, scene, camera, geometry, material) {\\n    var originalMaterial = originalMaterials[material.uuid]; // just in case\\n\\n    if (originalMaterial === undefined) return;\\n    updateUniforms(material, originalMaterial);\\n  }\\n\\n  function updateUniforms(material, originalMaterial) {\\n    var outlineParameters = originalMaterial.userData.outlineParameters;\\n    material.uniforms.outlineAlpha.value = originalMaterial.opacity;\\n\\n    if (outlineParameters !== undefined) {\\n      if (outlineParameters.thickness !== undefined) material.uniforms.outlineThickness.value = outlineParameters.thickness;\\n      if (outlineParameters.color !== undefined) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\\n      if (outlineParameters.alpha !== undefined) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\\n    }\\n\\n    if (originalMaterial.displacementMap) {\\n      material.uniforms.displacementMap.value = originalMaterial.displacementMap;\\n      material.uniforms.displacementScale.value = originalMaterial.displacementScale;\\n      material.uniforms.displacementBias.value = originalMaterial.displacementBias;\\n    }\\n  }\\n\\n  function updateOutlineMaterial(material, originalMaterial) {\\n    if (material.name === 'invisible') return;\\n    var outlineParameters = originalMaterial.userData.outlineParameters;\\n    material.skinning = originalMaterial.skinning;\\n    material.morphTargets = originalMaterial.morphTargets;\\n    material.morphNormals = originalMaterial.morphNormals;\\n    material.fog = originalMaterial.fog;\\n    material.toneMapped = originalMaterial.toneMapped;\\n    material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\\n    material.displacementMap = originalMaterial.displacementMap;\\n\\n    if (outlineParameters !== undefined) {\\n      if (originalMaterial.visible === false) {\\n        material.visible = false;\\n      } else {\\n        material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true;\\n      }\\n\\n      material.transparent = outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ? true : originalMaterial.transparent;\\n      if (outlineParameters.keepAlive !== undefined) cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\\n    } else {\\n      material.transparent = originalMaterial.transparent;\\n      material.visible = originalMaterial.visible;\\n    }\\n\\n    if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;\\n\\n    if (originalMaterial.clippingPlanes) {\\n      material.clipping = true;\\n      material.clippingPlanes = originalMaterial.clippingPlanes;\\n      material.clipIntersection = originalMaterial.clipIntersection;\\n      material.clipShadows = originalMaterial.clipShadows;\\n    }\\n\\n    material.version = originalMaterial.version; // update outline material if necessary\\n  }\\n\\n  function cleanupCache() {\\n    var keys; // clear originialMaterials\\n\\n    keys = Object.keys(originalMaterials);\\n\\n    for (var i = 0, il = keys.length; i < il; i++) {\\n      originalMaterials[keys[i]] = undefined;\\n    } // clear originalOnBeforeRenders\\n\\n\\n    keys = Object.keys(originalOnBeforeRenders);\\n\\n    for (var _i = 0, _il = keys.length; _i < _il; _i++) {\\n      originalOnBeforeRenders[keys[_i]] = undefined;\\n    } // remove unused outlineMaterial from cache\\n\\n\\n    keys = Object.keys(cache);\\n\\n    for (var _i2 = 0, _il2 = keys.length; _i2 < _il2; _i2++) {\\n      var key = keys[_i2];\\n\\n      if (cache[key].used === false) {\\n        cache[key].count++;\\n\\n        if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\\n          delete cache[key];\\n        }\\n      } else {\\n        cache[key].used = false;\\n        cache[key].count = 0;\\n      }\\n    }\\n  }\\n\\n  this.render = function (scene, camera) {\\n    var renderTarget;\\n    var forceClear = false;\\n\\n    if (arguments[2] !== undefined) {\\n      console.warn('THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');\\n      renderTarget = arguments[2];\\n    }\\n\\n    if (arguments[3] !== undefined) {\\n      console.warn('THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead.');\\n      forceClear = arguments[3];\\n    }\\n\\n    if (renderTarget !== undefined) renderer.setRenderTarget(renderTarget);\\n    if (forceClear) renderer.clear();\\n\\n    if (this.enabled === false) {\\n      renderer.render(scene, camera);\\n      return;\\n    }\\n\\n    var currentAutoClear = renderer.autoClear;\\n    renderer.autoClear = this.autoClear;\\n    renderer.render(scene, camera);\\n    renderer.autoClear = currentAutoClear;\\n    this.renderOutline(scene, camera);\\n  };\\n\\n  this.renderOutline = function (scene, camera) {\\n    var currentAutoClear = renderer.autoClear;\\n    var currentSceneAutoUpdate = scene.autoUpdate;\\n    var currentSceneBackground = scene.background;\\n    var currentShadowMapEnabled = renderer.shadowMap.enabled;\\n    scene.autoUpdate = false;\\n    scene.background = null;\\n    renderer.autoClear = false;\\n    renderer.shadowMap.enabled = false;\\n    scene.traverse(setOutlineMaterial);\\n    renderer.render(scene, camera);\\n    scene.traverse(restoreOriginalMaterial);\\n    cleanupCache();\\n    scene.autoUpdate = currentSceneAutoUpdate;\\n    scene.background = currentSceneBackground;\\n    renderer.autoClear = currentAutoClear;\\n    renderer.shadowMap.enabled = currentShadowMapEnabled;\\n  };\\n  /*\\n   * See #9918\\n   *\\n   * The following property copies and wrapper methods enable\\n   * OutlineEffect to be called from other *Effect, like\\n   *\\n   * effect = new StereoEffect( new OutlineEffect( renderer ) );\\n   *\\n   * function render () {\\n   *\\n   * \\teffect.render( scene, camera );\\n   *\\n   * }\\n   */\\n\\n\\n  this.autoClear = renderer.autoClear;\\n  this.domElement = renderer.domElement;\\n  this.shadowMap = renderer.shadowMap;\\n\\n  this.clear = function (color, depth, stencil) {\\n    renderer.clear(color, depth, stencil);\\n  };\\n\\n  this.getPixelRatio = function () {\\n    return renderer.getPixelRatio();\\n  };\\n\\n  this.setPixelRatio = function (value) {\\n    renderer.setPixelRatio(value);\\n  };\\n\\n  this.getSize = function (target) {\\n    return renderer.getSize(target);\\n  };\\n\\n  this.setSize = function (width, height, updateStyle) {\\n    renderer.setSize(width, height, updateStyle);\\n  };\\n\\n  this.setViewport = function (x, y, width, height) {\\n    renderer.setViewport(x, y, width, height);\\n  };\\n\\n  this.setScissor = function (x, y, width, height) {\\n    renderer.setScissor(x, y, width, height);\\n  };\\n\\n  this.setScissorTest = function (_boolean) {\\n    renderer.setScissorTest(_boolean);\\n  };\\n\\n  this.setRenderTarget = function (renderTarget) {\\n    renderer.setRenderTarget(renderTarget);\\n  };\\n};\\n\\nexports.OutlineEffect = OutlineEffect;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"OutlineEffect\",\"_three\",\"renderer\",\"parameters\",\"getOutlineMaterial\",\"originalMaterial\",\"data\",\"cache\",\"uuid\",\"undefined\",\"material\",\"ShaderMaterial\",\"type\",\"uniforms\",\"UniformsUtils\",\"merge\",\"UniformsLib\",\"uniformsOutline\",\"vertexShader\",\"fragmentShader\",\"side\",\"BackSide\",\"used\",\"keepAlive\",\"defaultKeepAlive\",\"count\",\"originalMaterials\",\"outlineMaterial\",\"name\",\"outlineParameters\",\"userData\",\"skinning\",\"morphTargets\",\"morphNormals\",\"fog\",\"toneMapped\",\"premultipliedAlpha\",\"displacementMap\",\"visible\",\"transparent\",\"alpha\",\"wireframe\",\"depthTest\",\"clippingPlanes\",\"clipping\",\"clipIntersection\",\"clipShadows\",\"version\",\"isCompatible\",\"object\",\"geometry\",\"hasNormals\",\"isBufferGeometry\",\"attributes\",\"normal\",\"isMesh\",\"setOutlineMaterial\",\"Array\",\"isArray\",\"i\",\"il\",\"length\",\"originalOnBeforeRenders\",\"onBeforeRender\",\"restoreOriginalMaterial\",\"scene\",\"camera\",\"outlineAlpha\",\"opacity\",\"thickness\",\"outlineThickness\",\"color\",\"outlineColor\",\"fromArray\",\"displacementScale\",\"displacementBias\",\"enabled\",\"defaultThickness\",\"defaultColor\",\"Color\",\"defaultAlpha\",\"render\",\"this.render\",\"forceClear\",\"console\",\"warn\",\"renderTarget\",\"setRenderTarget\",\"clear\",\"currentAutoClear\",\"autoClear\",\"renderOutline\",\"this.renderOutline\",\"currentSceneAutoUpdate\",\"autoUpdate\",\"currentSceneBackground\",\"background\",\"currentShadowMapEnabled\",\"shadowMap\",\"traverse\",\"keys\",\"_i\",\"_il\",\"_i2\",\"_il2\",\"key\",\"removeThresholdCount\",\"domElement\",\"this.clear\",\"depth\",\"stencil\",\"getPixelRatio\",\"this.getPixelRatio\",\"setPixelRatio\",\"this.setPixelRatio\",\"getSize\",\"this.getSize\",\"target\",\"setSize\",\"this.setSize\",\"width\",\"height\",\"updateStyle\",\"setViewport\",\"this.setViewport\",\"x\",\"y\",\"setScissor\",\"this.setScissor\",\"setScissorTest\",\"this.setScissorTest\",\"_boolean\",\"this.setRenderTarget\"]\n}\n"]