["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/csm/Shader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$csm$Shader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports[\"default\"]=void 0;global={lights_fragment_begin:\"\\nGeometricContext geometry;\\n\\ngeometry.position \\x3d - vViewPosition;\\ngeometry.normal \\x3d normal;\\ngeometry.viewDir \\x3d ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n\\n#ifdef CLEARCOAT\\n\\n\\tgeometry.clearcoatNormal \\x3d clearcoatNormal;\\n\\n#endif\\n\\nIncidentLight directLight;\\n\\n#if ( NUM_POINT_LIGHTS \\x3e 0 ) \\x26\\x26 defined( RE_Direct )\\n\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) \\x26\\x26 NUM_POINT_LIGHT_SHADOWS \\x3e 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i \\x3d 0; i \\x3c NUM_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\tpointLight \\x3d pointLights[ i ];\\n\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) \\x26\\x26 ( UNROLLED_LOOP_INDEX \\x3c NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow \\x3d pointLightShadows[ i ];\\n\\t\\tdirectLight.color *\\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_SPOT_LIGHTS \\x3e 0 ) \\x26\\x26 defined( RE_Direct )\\n\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) \\x26\\x26 NUM_SPOT_LIGHT_SHADOWS \\x3e 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i \\x3d 0; i \\x3c NUM_SPOT_LIGHTS; i ++ ) {\\n\\n\\t\\tspotLight \\x3d spotLights[ i ];\\n\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) \\x26\\x26 ( UNROLLED_LOOP_INDEX \\x3c NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow \\x3d spotLightShadows[ i ];\\n\\t\\tdirectLight.color *\\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_DIR_LIGHTS \\x3e 0) \\x26\\x26 defined( RE_Direct ) \\x26\\x26 defined( USE_CSM ) \\x26\\x26 defined( CSM_CASCADES )\\n\\n\\tDirectionalLight directionalLight;\\n\\tfloat linearDepth \\x3d (vViewPosition.z) / (shadowFar - cameraNear);\\n\\t#if defined( USE_SHADOWMAP ) \\x26\\x26 NUM_DIR_LIGHT_SHADOWS \\x3e 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\n\\t#if defined( USE_SHADOWMAP ) \\x26\\x26 defined( CSM_FADE )\\n\\tvec2 cascade;\\n\\tfloat cascadeCenter;\\n\\tfloat closestEdge;\\n\\tfloat margin;\\n\\tfloat csmx;\\n\\tfloat csmy;\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i \\x3d 0; i \\x3c NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tdirectionalLight \\x3d directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n\\t\\t// NOTE: Depth gets larger away from the camera.\\n\\t\\t// cascade.x is closer, cascade.y is further\\n\\t\\tcascade \\x3d CSM_cascades[ i ];\\n\\t\\tcascadeCenter \\x3d ( cascade.x + cascade.y ) / 2.0;\\n\\t\\tclosestEdge \\x3d linearDepth \\x3c cascadeCenter ? cascade.x : cascade.y;\\n\\t\\tmargin \\x3d 0.25 * pow( closestEdge, 2.0 );\\n\\t\\tcsmx \\x3d cascade.x - margin / 2.0;\\n\\t\\tcsmy \\x3d cascade.y + margin / 2.0;\\n\\t\\tif( UNROLLED_LOOP_INDEX \\x3c NUM_DIR_LIGHT_SHADOWS \\x26\\x26 linearDepth \\x3e\\x3d csmx \\x26\\x26 ( linearDepth \\x3c csmy || UNROLLED_LOOP_INDEX \\x3d\\x3d CSM_CASCADES - 1 ) ) {\\n\\n\\t\\t\\tfloat dist \\x3d min( linearDepth - csmx, csmy - linearDepth );\\n\\t\\t\\tfloat ratio \\x3d clamp( dist / margin, 0.0, 1.0 );\\n\\t\\t\\tif( UNROLLED_LOOP_INDEX \\x3c NUM_DIR_LIGHT_SHADOWS ) {\\n\\n\\t\\t\\t\\tvec3 prevColor \\x3d directLight.color;\\n\\t\\t\\t\\tdirectionalLightShadow \\x3d directionalLightShadows[ i ];\\n\\t\\t\\t\\tdirectLight.color *\\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\n\\t\\t\\t\\tbool shouldFadeLastCascade \\x3d UNROLLED_LOOP_INDEX \\x3d\\x3d CSM_CASCADES - 1 \\x26\\x26 linearDepth \\x3e cascadeCenter;\\n\\t\\t\\t\\tdirectLight.color \\x3d mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tReflectedLight prevLight \\x3d reflectedLight;\\n\\t\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t\\t\\tbool shouldBlend \\x3d UNROLLED_LOOP_INDEX !\\x3d CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX \\x3d\\x3d CSM_CASCADES - 1 \\x26\\x26 linearDepth \\x3c cascadeCenter;\\n\\t\\t\\tfloat blendRatio \\x3d shouldBlend ? ratio : 1.0;\\n\\n\\t\\t\\treflectedLight.directDiffuse \\x3d mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\\n\\t\\t\\treflectedLight.directSpecular \\x3d mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\\n\\t\\t\\treflectedLight.indirectDiffuse \\x3d mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\\n\\t\\t\\treflectedLight.indirectSpecular \\x3d mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\\n\\n\\t\\t}\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#else\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i \\x3d 0; i \\x3c NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tdirectionalLight \\x3d directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) \\x26\\x26 ( UNROLLED_LOOP_INDEX \\x3c NUM_DIR_LIGHT_SHADOWS )\\n\\n\\t\\tdirectionalLightShadow \\x3d directionalLightShadows[ i ];\\n\\t\\tif(linearDepth \\x3e\\x3d CSM_cascades[UNROLLED_LOOP_INDEX].x \\x26\\x26 linearDepth \\x3c CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *\\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\n\\t\\t#endif\\n\\n\\t\\tif(linearDepth \\x3e\\x3d CSM_cascades[UNROLLED_LOOP_INDEX].x \\x26\\x26 (linearDepth \\x3c CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX \\x3d\\x3d CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n\\t#endif\\n\\n#endif\\n\\n\\n#if ( NUM_DIR_LIGHTS \\x3e 0 ) \\x26\\x26 defined( RE_Direct ) \\x26\\x26 !defined( USE_CSM ) \\x26\\x26 !defined( CSM_CASCADES )\\n\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) \\x26\\x26 NUM_DIR_LIGHT_SHADOWS \\x3e 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i \\x3d 0; i \\x3c NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tdirectionalLight \\x3d directionalLights[ i ];\\n\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) \\x26\\x26 ( UNROLLED_LOOP_INDEX \\x3c NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow \\x3d directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *\\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_RECT_AREA_LIGHTS \\x3e 0 ) \\x26\\x26 defined( RE_Direct_RectArea )\\n\\n\\tRectAreaLight rectAreaLight;\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i \\x3d 0; i \\x3c NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\n\\t\\trectAreaLight \\x3d rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if defined( RE_IndirectDiffuse )\\n\\n\\tvec3 iblIrradiance \\x3d vec3( 0.0 );\\n\\n\\tvec3 irradiance \\x3d getAmbientLightIrradiance( ambientLightColor );\\n\\n\\tirradiance +\\x3d getLightProbeIrradiance( lightProbe, geometry );\\n\\n\\t#if ( NUM_HEMI_LIGHTS \\x3e 0 )\\n\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i \\x3d 0; i \\x3c NUM_HEMI_LIGHTS; i ++ ) {\\n\\n\\t\\t\\tirradiance +\\x3d getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\n\\t#endif\\n\\n#endif\\n\\n#if defined( RE_IndirectSpecular )\\n\\n\\tvec3 radiance \\x3d vec3( 0.0 );\\n\\tvec3 clearcoatRadiance \\x3d vec3( 0.0 );\\n\\n#endif\\n\",\nlights_pars_begin:\"\\n#if defined( USE_CSM ) \\x26\\x26 defined( CSM_CASCADES )\\nuniform vec2 CSM_cascades[CSM_CASCADES];\\nuniform float cameraNear;\\nuniform float shadowFar;\\n#endif\\n\\t\"+require(\"module$node_modules$three$build$three_module\").ShaderChunk.lights_pars_begin};exports[\"default\"]=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$csm$Shader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _three = require(\"three\");\n\nvar Shader = {\n  lights_fragment_begin:\n  /* glsl */\n  \"\\nGeometricContext geometry;\\n\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n\\n#ifdef CLEARCOAT\\n\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n\\n#endif\\n\\nIncidentLight directLight;\\n\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\tpointLight = pointLights[ i ];\\n\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\n\\t\\tspotLight = spotLights[ i ];\\n\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\\n\\n\\tDirectionalLight directionalLight;\\n\\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\n\\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\\n\\tvec2 cascade;\\n\\tfloat cascadeCenter;\\n\\tfloat closestEdge;\\n\\tfloat margin;\\n\\tfloat csmx;\\n\\tfloat csmy;\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n\\t\\t// NOTE: Depth gets larger away from the camera.\\n\\t\\t// cascade.x is closer, cascade.y is further\\n\\t\\tcascade = CSM_cascades[ i ];\\n\\t\\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\\n\\t\\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\\n\\t\\tmargin = 0.25 * pow( closestEdge, 2.0 );\\n\\t\\tcsmx = cascade.x - margin / 2.0;\\n\\t\\tcsmy = cascade.y + margin / 2.0;\\n\\t\\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS && linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\\n\\n\\t\\t\\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\\n\\t\\t\\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\\n\\t\\t\\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS ) {\\n\\n\\t\\t\\t\\tvec3 prevColor = directLight.color;\\n\\t\\t\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\t\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\n\\t\\t\\t\\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\\n\\t\\t\\t\\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tReflectedLight prevLight = reflectedLight;\\n\\t\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t\\t\\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\\n\\t\\t\\tfloat blendRatio = shouldBlend ? ratio : 1.0;\\n\\n\\t\\t\\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\\n\\t\\t\\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\\n\\t\\t\\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\\n\\t\\t\\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\\n\\n\\t\\t}\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#else\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\n\\t\\t#endif\\n\\n\\t\\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n\\t#endif\\n\\n#endif\\n\\n\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\\n\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\n\\tRectAreaLight rectAreaLight;\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if defined( RE_IndirectDiffuse )\\n\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\n\\t#endif\\n\\n#endif\\n\\n#if defined( RE_IndirectSpecular )\\n\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n\\n#endif\\n\",\n  lights_pars_begin:\n  /* glsl */\n  \"\\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\\nuniform vec2 CSM_cascades[CSM_CASCADES];\\nuniform float cameraNear;\\nuniform float shadowFar;\\n#endif\\n\\t\" + _three.ShaderChunk.lights_pars_begin\n};\nvar _default = Shader;\nexports[\"default\"] = _default;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["lights_pars_begin","lights_fragment_begin","__esModule","value"]],"~:compiled-at",1630917515574,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$csm$Shader.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,2CAAA,CAAgE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGxGC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAA,CAAQ,SAAR,CAAA,CAAqB,IAAK,EAItBI,OAAAA,CAAS,CACXC,sBAEA,2vQAHW;AAIXC,kBAEA,sKAFAA,CANWR,OAAAS,CAAQ,8CAARA,CAQ+JC,CAAAA,WAAYF,CAAAA,iBAN3K,CASbN,QAAA,CAAQ,SAAR,CAAA,CADeI,MAlByF;\",\n\"sources\":[\"node_modules/three-stdlib/csm/Shader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$csm$Shader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports[\\\"default\\\"] = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar Shader = {\\n  lights_fragment_begin:\\n  /* glsl */\\n  \\\"\\\\nGeometricContext geometry;\\\\n\\\\ngeometry.position = - vViewPosition;\\\\ngeometry.normal = normal;\\\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\\\n\\\\n#ifdef CLEARCOAT\\\\n\\\\n\\\\tgeometry.clearcoatNormal = clearcoatNormal;\\\\n\\\\n#endif\\\\n\\\\nIncidentLight directLight;\\\\n\\\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\n\\\\tPointLight pointLight;\\\\n\\\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\\\n\\\\tPointLightShadow pointLightShadow;\\\\n\\\\t#endif\\\\n\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tpointLight = pointLights[ i ];\\\\n\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\\\n\\\\n\\\\t\\\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\\\n\\\\t\\\\tpointLightShadow = pointLightShadows[ i ];\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\n#endif\\\\n\\\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\n\\\\tSpotLight spotLight;\\\\n\\\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\\\n\\\\tSpotLightShadow spotLightShadow;\\\\n\\\\t#endif\\\\n\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tspotLight = spotLights[ i ];\\\\n\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\\\n\\\\n\\\\t\\\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\\\n\\\\t\\\\tspotLightShadow = spotLightShadows[ i ];\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\n#endif\\\\n\\\\n#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\\\\n\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\\\\n\\\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\\\n\\\\tDirectionalLightShadow directionalLightShadow;\\\\n\\\\t#endif\\\\n\\\\n\\\\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\\\\n\\\\tvec2 cascade;\\\\n\\\\tfloat cascadeCenter;\\\\n\\\\tfloat closestEdge;\\\\n\\\\tfloat margin;\\\\n\\\\tfloat csmx;\\\\n\\\\tfloat csmy;\\\\n\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\\\n\\\\n\\\\t\\\\t// NOTE: Depth gets larger away from the camera.\\\\n\\\\t\\\\t// cascade.x is closer, cascade.y is further\\\\n\\\\t\\\\tcascade = CSM_cascades[ i ];\\\\n\\\\t\\\\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\\\\n\\\\t\\\\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\\\\n\\\\t\\\\tmargin = 0.25 * pow( closestEdge, 2.0 );\\\\n\\\\t\\\\tcsmx = cascade.x - margin / 2.0;\\\\n\\\\t\\\\tcsmy = cascade.y + margin / 2.0;\\\\n\\\\t\\\\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS && linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\\\\n\\\\n\\\\t\\\\t\\\\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\\\\n\\\\t\\\\t\\\\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\\\\n\\\\t\\\\t\\\\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec3 prevColor = directLight.color;\\\\n\\\\t\\\\t\\\\t\\\\tdirectionalLightShadow = directionalLightShadows[ i ];\\\\n\\\\t\\\\t\\\\t\\\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\\\\n\\\\t\\\\t\\\\t\\\\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\\\\n\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tReflectedLight prevLight = reflectedLight;\\\\n\\\\t\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\n\\\\t\\\\t\\\\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\\\\n\\\\t\\\\t\\\\tfloat blendRatio = shouldBlend ? ratio : 1.0;\\\\n\\\\n\\\\t\\\\t\\\\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\\\\n\\\\t\\\\t\\\\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\\\\n\\\\t\\\\t\\\\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\\\\n\\\\t\\\\t\\\\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\t#else\\\\n\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\\\n\\\\n\\\\t\\\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\\\n\\\\n\\\\t\\\\tdirectionalLightShadow = directionalLightShadows[ i ];\\\\n\\\\t\\\\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\n\\\\t#endif\\\\n\\\\n#endif\\\\n\\\\n\\\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\\\\n\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\\\n\\\\tDirectionalLightShadow directionalLightShadow;\\\\n\\\\t#endif\\\\n\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\\\n\\\\n\\\\t\\\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\\\n\\\\t\\\\tdirectionalLightShadow = directionalLightShadows[ i ];\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\n#endif\\\\n\\\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\\\n\\\\n\\\\tRectAreaLight rectAreaLight;\\\\n\\\\n\\\\t#pragma unroll_loop_start\\\\n\\\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\trectAreaLight = rectAreaLights[ i ];\\\\n\\\\t\\\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\\\n\\\\n\\\\t}\\\\n\\\\t#pragma unroll_loop_end\\\\n\\\\n#endif\\\\n\\\\n#if defined( RE_IndirectDiffuse )\\\\n\\\\n\\\\tvec3 iblIrradiance = vec3( 0.0 );\\\\n\\\\n\\\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\n\\\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\\\n\\\\n\\\\t#if ( NUM_HEMI_LIGHTS > 0 )\\\\n\\\\n\\\\t\\\\t#pragma unroll_loop_start\\\\n\\\\t\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\n\\\\t\\\\t\\\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\t#pragma unroll_loop_end\\\\n\\\\n\\\\t#endif\\\\n\\\\n#endif\\\\n\\\\n#if defined( RE_IndirectSpecular )\\\\n\\\\n\\\\tvec3 radiance = vec3( 0.0 );\\\\n\\\\tvec3 clearcoatRadiance = vec3( 0.0 );\\\\n\\\\n#endif\\\\n\\\",\\n  lights_pars_begin:\\n  /* glsl */\\n  \\\"\\\\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\\\\nuniform vec2 CSM_cascades[CSM_CASCADES];\\\\nuniform float cameraNear;\\\\nuniform float shadowFar;\\\\n#endif\\\\n\\\\t\\\" + _three.ShaderChunk.lights_pars_begin\\n};\\nvar _default = Shader;\\nexports[\\\"default\\\"] = _default;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"Shader\",\"lights_fragment_begin\",\"lights_pars_begin\",\"_three\",\"ShaderChunk\"]\n}\n"]