["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/TGALoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$TGALoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=\ndescriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};\nreturn _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};\nreturn _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.TGALoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_DataTextureLoader){function TGALoader(manager){if(!(this instanceof TGALoader))throw new TypeError(\"Cannot call a class as a function\");manager=_getPrototypeOf(TGALoader).call(this,manager);if(!manager||\"object\"!==_typeof(manager)&&\"function\"!==typeof manager){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\nmanager=this}return manager}_inherits(TGALoader,_DataTextureLoader);_createClass(TGALoader,[{key:\"parse\",value:function(buffer){19>buffer.length&&console.error(\"THREE.TGALoader: Not enough data to contain header.\");var offset$jscomp$0=0,content=new Uint8Array(buffer),header$jscomp$0={id_length:content[offset$jscomp$0++],colormap_type:content[offset$jscomp$0++],image_type:content[offset$jscomp$0++],colormap_index:content[offset$jscomp$0++]|content[offset$jscomp$0++]<<8,colormap_length:content[offset$jscomp$0++]|\ncontent[offset$jscomp$0++]<<8,colormap_size:content[offset$jscomp$0++],origin:[content[offset$jscomp$0++]|content[offset$jscomp$0++]<<8,content[offset$jscomp$0++]|content[offset$jscomp$0++]<<8],width:content[offset$jscomp$0++]|content[offset$jscomp$0++]<<8,height:content[offset$jscomp$0++]|content[offset$jscomp$0++]<<8,pixel_size:content[offset$jscomp$0++],flags:content[offset$jscomp$0++]};(function(header){switch(header.image_type){case 1:case 9:(256<header.colormap_length||24!==header.colormap_size||\n1!==header.colormap_type)&&console.error(\"THREE.TGALoader: Invalid type colormap data for indexed type.\");break;case 2:case 3:case 10:case 11:header.colormap_type&&console.error(\"THREE.TGALoader: Invalid type colormap data for colormap type.\");break;case 0:console.error(\"THREE.TGALoader: No data.\");default:console.error('THREE.TGALoader: Invalid type \"%s\".',header.image_type)}(0>=header.width||0>=header.height)&&console.error(\"THREE.TGALoader: Invalid image size.\");8!==header.pixel_size&&16!==header.pixel_size&&\n24!==header.pixel_size&&32!==header.pixel_size&&console.error('THREE.TGALoader: Invalid pixel size \"%s\".',header.pixel_size)})(header$jscomp$0);header$jscomp$0.id_length+offset$jscomp$0>buffer.length&&console.error(\"THREE.TGALoader: No data.\");offset$jscomp$0+=header$jscomp$0.id_length;var use_rle=!1,use_pal=!1,use_grey=!1;switch(header$jscomp$0.image_type){case 9:use_pal=use_rle=!0;break;case 1:use_pal=!0;break;case 10:use_rle=!0;break;case 11:use_grey=use_rle=!0;break;case 3:use_grey=!0}buffer=\nnew Uint8Array(header$jscomp$0.width*header$jscomp$0.height*4);offset$jscomp$0=function(use_rle,use_pal,header,offset,data){var palettes,pixel_size=header.pixel_size>>3,pixel_total=header.width*header.height*pixel_size;use_pal&&(palettes=data.subarray(offset,offset+=header.colormap_length*(header.colormap_size>>3)));if(use_rle){use_rle=new Uint8Array(pixel_total);header=0;for(var pixels=new Uint8Array(pixel_size);header<pixel_total;){var c=data[offset++];use_pal=(c&127)+1;if(c&128){for(c=0;c<pixel_size;++c)pixels[c]=\ndata[offset++];for(c=0;c<use_pal;++c)use_rle.set(pixels,header+c*pixel_size);header+=pixel_size*use_pal}else{use_pal*=pixel_size;for(c=0;c<use_pal;++c)use_rle[header+c]=data[offset++];header+=use_pal}}}else use_rle=data.subarray(offset,offset+(use_pal?header.width*header.height:pixel_total));return{pixel_data:use_rle,palettes}}(use_rle,use_pal,header$jscomp$0,offset$jscomp$0,content);(function(data,width,height,image,palette){switch((header$jscomp$0.flags&48)>>4){default:case 2:var x_start=0;var x_step=\n1;var x_end=width;width=0;var y_step=1;var y_end=height;break;case 0:x_start=0;x_step=1;x_end=width;width=height-1;y_end=y_step=-1;break;case 3:x_start=width-1;x_end=x_step=-1;width=0;y_step=1;y_end=height;break;case 1:x_start=width-1,x_end=x_step=-1,width=height-1,y_end=y_step=-1}if(use_grey)switch(header$jscomp$0.pixel_size){case 8:palette=y_step;height=y_end;y_end=0;var x,y;y_step=header$jscomp$0.width;for(y=width;y!==height;y+=palette)for(x=x_start;x!==x_end;x+=x_step,y_end++)width=image[y_end],\ndata[4*(x+y_step*y)]=width,data[4*(x+y_step*y)+1]=width,data[4*(x+y_step*y)+2]=width,data[4*(x+y_step*y)+3]=255;break;case 16:palette=y_step;height=y_end;y_end=0;y_step=header$jscomp$0.width;for(x=width;x!==height;x+=palette)for(width=x_start;width!==x_end;width+=x_step,y_end+=2)data[4*(width+y_step*x)]=image[y_end+0],data[4*(width+y_step*x)+1]=image[y_end+0],data[4*(width+y_step*x)+2]=image[y_end+0],data[4*(width+y_step*x)+3]=image[y_end+1];break;default:console.error(\"THREE.TGALoader: Format not supported.\")}else switch(header$jscomp$0.pixel_size){case 8:height=\ny_step;y_step=0;var y$jscomp$0;x=header$jscomp$0.width;for(y$jscomp$0=width;y$jscomp$0!==y_end;y$jscomp$0+=height)for(y=x_start;y!==x_end;y+=x_step,y_step++)width=image[y_step],data[4*(y+x*y$jscomp$0)+3]=255,data[4*(y+x*y$jscomp$0)+2]=palette[3*width],data[4*(y+x*y$jscomp$0)+1]=palette[3*width+1],data[4*(y+x*y$jscomp$0)]=palette[3*width+2];break;case 16:palette=y_step;height=y_end;y_end=0;y_step=header$jscomp$0.width;for(y=width;y!==height;y+=palette)for(x=x_start;x!==x_end;x+=x_step,y_end+=2)width=\nimage[y_end+0]+(image[y_end+1]<<8),data[4*(x+y_step*y)]=(width&31744)>>7,data[4*(x+y_step*y)+1]=(width&992)>>2,data[4*(x+y_step*y)+2]=(width&31)>>3,data[4*(x+y_step*y)+3]=width&32768?0:255;break;case 24:palette=y_step;height=y_end;y_end=0;y_step=header$jscomp$0.width;for(x=width;x!==height;x+=palette)for(width=x_start;width!==x_end;width+=x_step,y_end+=3)data[4*(width+y_step*x)+3]=255,data[4*(width+y_step*x)+2]=image[y_end+0],data[4*(width+y_step*x)+1]=image[y_end+1],data[4*(width+y_step*x)]=image[y_end+\n2];break;case 32:palette=y_step;height=y_end;y_end=0;y_step=header$jscomp$0.width;for(x=width;x!==height;x+=palette)for(width=x_start;width!==x_end;width+=x_step,y_end+=4)data[4*(width+y_step*x)+2]=image[y_end+0],data[4*(width+y_step*x)+1]=image[y_end+1],data[4*(width+y_step*x)]=image[y_end+2],data[4*(width+y_step*x)+3]=image[y_end+3];break;default:console.error(\"THREE.TGALoader: Format not supported.\")}return data})(buffer,header$jscomp$0.width,header$jscomp$0.height,offset$jscomp$0.pixel_data,offset$jscomp$0.palettes);\nreturn{data:buffer,width:header$jscomp$0.width,height:header$jscomp$0.height,flipY:!0,generateMipmaps:!0,minFilter:_three.LinearMipmapLinearFilter}}}]);return TGALoader}(_three.DataTextureLoader);exports.TGALoader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$TGALoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TGALoader = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar TGALoader =\n/*#__PURE__*/\nfunction (_DataTextureLoader) {\n  _inherits(TGALoader, _DataTextureLoader);\n\n  function TGALoader(manager) {\n    _classCallCheck(this, TGALoader);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TGALoader).call(this, manager));\n  }\n\n  _createClass(TGALoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n      function tgaCheckHeader(header) {\n        switch (header.image_type) {\n          // check indexed type\n          case TGA_TYPE_INDEXED:\n          case TGA_TYPE_RLE_INDEXED:\n            if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n              console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n            }\n\n            break;\n          // check colormap type\n\n          case TGA_TYPE_RGB:\n          case TGA_TYPE_GREY:\n          case TGA_TYPE_RLE_RGB:\n          case TGA_TYPE_RLE_GREY:\n            if (header.colormap_type) {\n              console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n            }\n\n            break;\n          // What the need of a file without data ?\n\n          case TGA_TYPE_NO_DATA:\n            console.error('THREE.TGALoader: No data.');\n          // Invalid type ?\n\n          default:\n            console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n        } // check image width and height\n\n\n        if (header.width <= 0 || header.height <= 0) {\n          console.error('THREE.TGALoader: Invalid image size.');\n        } // check image pixel size\n\n\n        if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n          console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n        }\n      } // parse tga image buffer\n\n\n      function tgaParse(use_rle, use_pal, header, offset, data) {\n        var pixel_data, palettes;\n        var pixel_size = header.pixel_size >> 3;\n        var pixel_total = header.width * header.height * pixel_size; // read palettes\n\n        if (use_pal) {\n          palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n        } // read RLE\n\n\n        if (use_rle) {\n          pixel_data = new Uint8Array(pixel_total);\n          var c, count, i;\n          var shift = 0;\n          var pixels = new Uint8Array(pixel_size);\n\n          while (shift < pixel_total) {\n            c = data[offset++];\n            count = (c & 0x7f) + 1; // RLE pixels\n\n            if (c & 0x80) {\n              // bind pixel tmp array\n              for (i = 0; i < pixel_size; ++i) {\n                pixels[i] = data[offset++];\n              } // copy pixel array\n\n\n              for (i = 0; i < count; ++i) {\n                pixel_data.set(pixels, shift + i * pixel_size);\n              }\n\n              shift += pixel_size * count;\n            } else {\n              // raw pixels\n              count *= pixel_size;\n\n              for (i = 0; i < count; ++i) {\n                pixel_data[shift + i] = data[offset++];\n              }\n\n              shift += count;\n            }\n          }\n        } else {\n          // raw pixels\n          pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n        }\n\n        return {\n          pixel_data: pixel_data,\n          palettes: palettes\n        };\n      }\n\n      function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n        var colormap = palettes;\n        var color,\n            i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i++) {\n            color = image[i];\n            imageData[(x + width * y) * 4 + 3] = 255;\n            imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n            imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n            imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n          }\n        }\n\n        return imageData;\n      }\n\n      function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var color,\n            i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 2) {\n            color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\n            imageData[(x + width * y) * 4 + 0] = (color & 0x7c00) >> 7;\n            imageData[(x + width * y) * 4 + 1] = (color & 0x03e0) >> 2;\n            imageData[(x + width * y) * 4 + 2] = (color & 0x001f) >> 3;\n            imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n          }\n        }\n\n        return imageData;\n      }\n\n      function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 3) {\n            imageData[(x + width * y) * 4 + 3] = 255;\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\n          }\n        }\n\n        return imageData;\n      }\n\n      function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 4) {\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\n            imageData[(x + width * y) * 4 + 3] = image[i + 3];\n          }\n        }\n\n        return imageData;\n      }\n\n      function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var color,\n            i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i++) {\n            color = image[i];\n            imageData[(x + width * y) * 4 + 0] = color;\n            imageData[(x + width * y) * 4 + 1] = color;\n            imageData[(x + width * y) * 4 + 2] = color;\n            imageData[(x + width * y) * 4 + 3] = 255;\n          }\n        }\n\n        return imageData;\n      }\n\n      function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 2) {\n            imageData[(x + width * y) * 4 + 0] = image[i + 0];\n            imageData[(x + width * y) * 4 + 1] = image[i + 0];\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData[(x + width * y) * 4 + 3] = image[i + 1];\n          }\n        }\n\n        return imageData;\n      }\n\n      function getTgaRGBA(data, width, height, image, palette) {\n        var x_start, y_start, x_step, y_step, x_end, y_end;\n\n        switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n          default:\n          case TGA_ORIGIN_UL:\n            x_start = 0;\n            x_step = 1;\n            x_end = width;\n            y_start = 0;\n            y_step = 1;\n            y_end = height;\n            break;\n\n          case TGA_ORIGIN_BL:\n            x_start = 0;\n            x_step = 1;\n            x_end = width;\n            y_start = height - 1;\n            y_step = -1;\n            y_end = -1;\n            break;\n\n          case TGA_ORIGIN_UR:\n            x_start = width - 1;\n            x_step = -1;\n            x_end = -1;\n            y_start = 0;\n            y_step = 1;\n            y_end = height;\n            break;\n\n          case TGA_ORIGIN_BR:\n            x_start = width - 1;\n            x_step = -1;\n            x_end = -1;\n            y_start = height - 1;\n            y_step = -1;\n            y_end = -1;\n            break;\n        }\n\n        if (use_grey) {\n          switch (header.pixel_size) {\n            case 8:\n              tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n\n            case 16:\n              tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n\n            default:\n              console.error('THREE.TGALoader: Format not supported.');\n              break;\n          }\n        } else {\n          switch (header.pixel_size) {\n            case 8:\n              tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n              break;\n\n            case 16:\n              tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n\n            case 24:\n              tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n\n            case 32:\n              tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n\n            default:\n              console.error('THREE.TGALoader: Format not supported.');\n              break;\n          }\n        } // Load image data according to specific method\n        // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n        // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\n\n        return data;\n      } // TGA constants\n\n\n      var TGA_TYPE_NO_DATA = 0,\n          TGA_TYPE_INDEXED = 1,\n          TGA_TYPE_RGB = 2,\n          TGA_TYPE_GREY = 3,\n          TGA_TYPE_RLE_INDEXED = 9,\n          TGA_TYPE_RLE_RGB = 10,\n          TGA_TYPE_RLE_GREY = 11,\n          TGA_ORIGIN_MASK = 0x30,\n          TGA_ORIGIN_SHIFT = 0x04,\n          TGA_ORIGIN_BL = 0x00,\n          TGA_ORIGIN_BR = 0x01,\n          TGA_ORIGIN_UL = 0x02,\n          TGA_ORIGIN_UR = 0x03;\n      if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\n      var offset = 0;\n      var content = new Uint8Array(buffer),\n          header = {\n        id_length: content[offset++],\n        colormap_type: content[offset++],\n        image_type: content[offset++],\n        colormap_index: content[offset++] | content[offset++] << 8,\n        colormap_length: content[offset++] | content[offset++] << 8,\n        colormap_size: content[offset++],\n        origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n        width: content[offset++] | content[offset++] << 8,\n        height: content[offset++] | content[offset++] << 8,\n        pixel_size: content[offset++],\n        flags: content[offset++]\n      }; // check tga if it is valid format\n\n      tgaCheckHeader(header);\n\n      if (header.id_length + offset > buffer.length) {\n        console.error('THREE.TGALoader: No data.');\n      } // skip the needn't data\n\n\n      offset += header.id_length; // get targa information about RLE compression and palette\n\n      var use_rle = false,\n          use_pal = false,\n          use_grey = false;\n\n      switch (header.image_type) {\n        case TGA_TYPE_RLE_INDEXED:\n          use_rle = true;\n          use_pal = true;\n          break;\n\n        case TGA_TYPE_INDEXED:\n          use_pal = true;\n          break;\n\n        case TGA_TYPE_RLE_RGB:\n          use_rle = true;\n          break;\n\n        case TGA_TYPE_RGB:\n          break;\n\n        case TGA_TYPE_RLE_GREY:\n          use_rle = true;\n          use_grey = true;\n          break;\n\n        case TGA_TYPE_GREY:\n          use_grey = true;\n          break;\n      } //\n\n\n      var imageData = new Uint8Array(header.width * header.height * 4);\n      var result = tgaParse(use_rle, use_pal, header, offset, content);\n      getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n      return {\n        data: imageData,\n        width: header.width,\n        height: header.height,\n        flipY: true,\n        generateMipmaps: true,\n        minFilter: _three.LinearMipmapLinearFilter\n      };\n    }\n  }]);\n\n  return TGALoader;\n}(_three.DataTextureLoader);\n\nexports.TGALoader = TGALoader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["width","palettes","origin","prototype","height","image_type","key","TGALoader","__esModule","colormap_size","flags","pixel_size","configurable","value","pixel_data","enumerable","writable","colormap_type","colormap_length","id_length","colormap_index","__proto__","generateMipmaps","minFilter","flipY","data","constructor"]],"~:compiled-at",1630917515602,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$TGALoader.js\",\n\"lineCount\":16,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/TGALoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$TGALoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.TGALoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar TGALoader =\\n/*#__PURE__*/\\nfunction (_DataTextureLoader) {\\n  _inherits(TGALoader, _DataTextureLoader);\\n\\n  function TGALoader(manager) {\\n    _classCallCheck(this, TGALoader);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(TGALoader).call(this, manager));\\n  }\\n\\n  _createClass(TGALoader, [{\\n    key: \\\"parse\\\",\\n    value: function parse(buffer) {\\n      // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\\n      function tgaCheckHeader(header) {\\n        switch (header.image_type) {\\n          // check indexed type\\n          case TGA_TYPE_INDEXED:\\n          case TGA_TYPE_RLE_INDEXED:\\n            if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\\n              console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\\n            }\\n\\n            break;\\n          // check colormap type\\n\\n          case TGA_TYPE_RGB:\\n          case TGA_TYPE_GREY:\\n          case TGA_TYPE_RLE_RGB:\\n          case TGA_TYPE_RLE_GREY:\\n            if (header.colormap_type) {\\n              console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\\n            }\\n\\n            break;\\n          // What the need of a file without data ?\\n\\n          case TGA_TYPE_NO_DATA:\\n            console.error('THREE.TGALoader: No data.');\\n          // Invalid type ?\\n\\n          default:\\n            console.error('THREE.TGALoader: Invalid type \\\"%s\\\".', header.image_type);\\n        } // check image width and height\\n\\n\\n        if (header.width <= 0 || header.height <= 0) {\\n          console.error('THREE.TGALoader: Invalid image size.');\\n        } // check image pixel size\\n\\n\\n        if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\\n          console.error('THREE.TGALoader: Invalid pixel size \\\"%s\\\".', header.pixel_size);\\n        }\\n      } // parse tga image buffer\\n\\n\\n      function tgaParse(use_rle, use_pal, header, offset, data) {\\n        var pixel_data, palettes;\\n        var pixel_size = header.pixel_size >> 3;\\n        var pixel_total = header.width * header.height * pixel_size; // read palettes\\n\\n        if (use_pal) {\\n          palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\\n        } // read RLE\\n\\n\\n        if (use_rle) {\\n          pixel_data = new Uint8Array(pixel_total);\\n          var c, count, i;\\n          var shift = 0;\\n          var pixels = new Uint8Array(pixel_size);\\n\\n          while (shift < pixel_total) {\\n            c = data[offset++];\\n            count = (c & 0x7f) + 1; // RLE pixels\\n\\n            if (c & 0x80) {\\n              // bind pixel tmp array\\n              for (i = 0; i < pixel_size; ++i) {\\n                pixels[i] = data[offset++];\\n              } // copy pixel array\\n\\n\\n              for (i = 0; i < count; ++i) {\\n                pixel_data.set(pixels, shift + i * pixel_size);\\n              }\\n\\n              shift += pixel_size * count;\\n            } else {\\n              // raw pixels\\n              count *= pixel_size;\\n\\n              for (i = 0; i < count; ++i) {\\n                pixel_data[shift + i] = data[offset++];\\n              }\\n\\n              shift += count;\\n            }\\n          }\\n        } else {\\n          // raw pixels\\n          pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\\n        }\\n\\n        return {\\n          pixel_data: pixel_data,\\n          palettes: palettes\\n        };\\n      }\\n\\n      function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\\n        var colormap = palettes;\\n        var color,\\n            i = 0,\\n            x,\\n            y;\\n        var width = header.width;\\n\\n        for (y = y_start; y !== y_end; y += y_step) {\\n          for (x = x_start; x !== x_end; x += x_step, i++) {\\n            color = image[i];\\n            imageData[(x + width * y) * 4 + 3] = 255;\\n            imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\\n            imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\\n            imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\\n          }\\n        }\\n\\n        return imageData;\\n      }\\n\\n      function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\\n        var color,\\n            i = 0,\\n            x,\\n            y;\\n        var width = header.width;\\n\\n        for (y = y_start; y !== y_end; y += y_step) {\\n          for (x = x_start; x !== x_end; x += x_step, i += 2) {\\n            color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\\n\\n            imageData[(x + width * y) * 4 + 0] = (color & 0x7c00) >> 7;\\n            imageData[(x + width * y) * 4 + 1] = (color & 0x03e0) >> 2;\\n            imageData[(x + width * y) * 4 + 2] = (color & 0x001f) >> 3;\\n            imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\\n          }\\n        }\\n\\n        return imageData;\\n      }\\n\\n      function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\\n        var i = 0,\\n            x,\\n            y;\\n        var width = header.width;\\n\\n        for (y = y_start; y !== y_end; y += y_step) {\\n          for (x = x_start; x !== x_end; x += x_step, i += 3) {\\n            imageData[(x + width * y) * 4 + 3] = 255;\\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\\n          }\\n        }\\n\\n        return imageData;\\n      }\\n\\n      function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\\n        var i = 0,\\n            x,\\n            y;\\n        var width = header.width;\\n\\n        for (y = y_start; y !== y_end; y += y_step) {\\n          for (x = x_start; x !== x_end; x += x_step, i += 4) {\\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\\n            imageData[(x + width * y) * 4 + 3] = image[i + 3];\\n          }\\n        }\\n\\n        return imageData;\\n      }\\n\\n      function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\\n        var color,\\n            i = 0,\\n            x,\\n            y;\\n        var width = header.width;\\n\\n        for (y = y_start; y !== y_end; y += y_step) {\\n          for (x = x_start; x !== x_end; x += x_step, i++) {\\n            color = image[i];\\n            imageData[(x + width * y) * 4 + 0] = color;\\n            imageData[(x + width * y) * 4 + 1] = color;\\n            imageData[(x + width * y) * 4 + 2] = color;\\n            imageData[(x + width * y) * 4 + 3] = 255;\\n          }\\n        }\\n\\n        return imageData;\\n      }\\n\\n      function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\\n        var i = 0,\\n            x,\\n            y;\\n        var width = header.width;\\n\\n        for (y = y_start; y !== y_end; y += y_step) {\\n          for (x = x_start; x !== x_end; x += x_step, i += 2) {\\n            imageData[(x + width * y) * 4 + 0] = image[i + 0];\\n            imageData[(x + width * y) * 4 + 1] = image[i + 0];\\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\\n            imageData[(x + width * y) * 4 + 3] = image[i + 1];\\n          }\\n        }\\n\\n        return imageData;\\n      }\\n\\n      function getTgaRGBA(data, width, height, image, palette) {\\n        var x_start, y_start, x_step, y_step, x_end, y_end;\\n\\n        switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\\n          default:\\n          case TGA_ORIGIN_UL:\\n            x_start = 0;\\n            x_step = 1;\\n            x_end = width;\\n            y_start = 0;\\n            y_step = 1;\\n            y_end = height;\\n            break;\\n\\n          case TGA_ORIGIN_BL:\\n            x_start = 0;\\n            x_step = 1;\\n            x_end = width;\\n            y_start = height - 1;\\n            y_step = -1;\\n            y_end = -1;\\n            break;\\n\\n          case TGA_ORIGIN_UR:\\n            x_start = width - 1;\\n            x_step = -1;\\n            x_end = -1;\\n            y_start = 0;\\n            y_step = 1;\\n            y_end = height;\\n            break;\\n\\n          case TGA_ORIGIN_BR:\\n            x_start = width - 1;\\n            x_step = -1;\\n            x_end = -1;\\n            y_start = height - 1;\\n            y_step = -1;\\n            y_end = -1;\\n            break;\\n        }\\n\\n        if (use_grey) {\\n          switch (header.pixel_size) {\\n            case 8:\\n              tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\\n              break;\\n\\n            case 16:\\n              tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\\n              break;\\n\\n            default:\\n              console.error('THREE.TGALoader: Format not supported.');\\n              break;\\n          }\\n        } else {\\n          switch (header.pixel_size) {\\n            case 8:\\n              tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\\n              break;\\n\\n            case 16:\\n              tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\\n              break;\\n\\n            case 24:\\n              tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\\n              break;\\n\\n            case 32:\\n              tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\\n              break;\\n\\n            default:\\n              console.error('THREE.TGALoader: Format not supported.');\\n              break;\\n          }\\n        } // Load image data according to specific method\\n        // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\\n        // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\\n\\n\\n        return data;\\n      } // TGA constants\\n\\n\\n      var TGA_TYPE_NO_DATA = 0,\\n          TGA_TYPE_INDEXED = 1,\\n          TGA_TYPE_RGB = 2,\\n          TGA_TYPE_GREY = 3,\\n          TGA_TYPE_RLE_INDEXED = 9,\\n          TGA_TYPE_RLE_RGB = 10,\\n          TGA_TYPE_RLE_GREY = 11,\\n          TGA_ORIGIN_MASK = 0x30,\\n          TGA_ORIGIN_SHIFT = 0x04,\\n          TGA_ORIGIN_BL = 0x00,\\n          TGA_ORIGIN_BR = 0x01,\\n          TGA_ORIGIN_UL = 0x02,\\n          TGA_ORIGIN_UR = 0x03;\\n      if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\\n      var offset = 0;\\n      var content = new Uint8Array(buffer),\\n          header = {\\n        id_length: content[offset++],\\n        colormap_type: content[offset++],\\n        image_type: content[offset++],\\n        colormap_index: content[offset++] | content[offset++] << 8,\\n        colormap_length: content[offset++] | content[offset++] << 8,\\n        colormap_size: content[offset++],\\n        origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\\n        width: content[offset++] | content[offset++] << 8,\\n        height: content[offset++] | content[offset++] << 8,\\n        pixel_size: content[offset++],\\n        flags: content[offset++]\\n      }; // check tga if it is valid format\\n\\n      tgaCheckHeader(header);\\n\\n      if (header.id_length + offset > buffer.length) {\\n        console.error('THREE.TGALoader: No data.');\\n      } // skip the needn't data\\n\\n\\n      offset += header.id_length; // get targa information about RLE compression and palette\\n\\n      var use_rle = false,\\n          use_pal = false,\\n          use_grey = false;\\n\\n      switch (header.image_type) {\\n        case TGA_TYPE_RLE_INDEXED:\\n          use_rle = true;\\n          use_pal = true;\\n          break;\\n\\n        case TGA_TYPE_INDEXED:\\n          use_pal = true;\\n          break;\\n\\n        case TGA_TYPE_RLE_RGB:\\n          use_rle = true;\\n          break;\\n\\n        case TGA_TYPE_RGB:\\n          break;\\n\\n        case TGA_TYPE_RLE_GREY:\\n          use_rle = true;\\n          use_grey = true;\\n          break;\\n\\n        case TGA_TYPE_GREY:\\n          use_grey = true;\\n          break;\\n      } //\\n\\n\\n      var imageData = new Uint8Array(header.width * header.height * 4);\\n      var result = tgaParse(use_rle, use_pal, header, offset, content);\\n      getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\\n      return {\\n        data: imageData,\\n        width: header.width,\\n        height: header.height,\\n        flipY: true,\\n        generateMipmaps: true,\\n        minFilter: _three.LinearMipmapLinearFilter\\n      };\\n    }\\n  }]);\\n\\n  return TGALoader;\\n}(_three.DataTextureLoader);\\n\\nexports.TGALoader = TGALoader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"TGALoader\",\"_three\",\"_DataTextureLoader\",\"manager\",\"instance\",\"call\",\"self\",\"ReferenceError\",\"parse\",\"buffer\",\"console\",\"error\",\"offset\",\"content\",\"Uint8Array\",\"header\",\"id_length\",\"colormap_type\",\"image_type\",\"colormap_index\",\"colormap_length\",\"colormap_size\",\"origin\",\"width\",\"height\",\"pixel_size\",\"flags\",\"tgaCheckHeader\",\"TGA_TYPE_INDEXED\",\"TGA_TYPE_RLE_INDEXED\",\"TGA_TYPE_RGB\",\"TGA_TYPE_GREY\",\"TGA_TYPE_RLE_RGB\",\"TGA_TYPE_RLE_GREY\",\"TGA_TYPE_NO_DATA\",\"use_rle\",\"use_pal\",\"use_grey\",\"imageData\",\"result\",\"tgaParse\",\"data\",\"palettes\",\"pixel_total\",\"subarray\",\"pixel_data\",\"shift\",\"pixels\",\"c\",\"count\",\"set\",\"getTgaRGBA\",\"image\",\"palette\",\"TGA_ORIGIN_MASK\",\"TGA_ORIGIN_SHIFT\",\"TGA_ORIGIN_UL\",\"x_start\",\"x_step\",\"x_end\",\"y_start\",\"y_step\",\"y_end\",\"TGA_ORIGIN_BL\",\"TGA_ORIGIN_UR\",\"TGA_ORIGIN_BR\",\"x\",\"y\",\"color\",\"flipY\",\"generateMipmaps\",\"minFilter\",\"LinearMipmapLinearFilter\",\"DataTextureLoader\"]\n}\n"]