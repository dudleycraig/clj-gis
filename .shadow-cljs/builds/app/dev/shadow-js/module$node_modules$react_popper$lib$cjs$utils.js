["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-popper/lib/cjs/utils.js"],"~:js","shadow$provide.module$node_modules$react_popper$lib$cjs$utils=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.setRef=exports.shallowEqual=exports.safeInvoke=exports.unwrapArray=void 0;exports.unwrapArray=function(arg){return Array.isArray(arg)?arg[0]:arg};var safeInvoke=function(fn){if(\"function\"===typeof fn){for(var _len=arguments.length,args=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return fn.apply(void 0,args)}};\nexports.safeInvoke=safeInvoke;exports.shallowEqual=function(objA,objB){var aKeys=Object.keys(objA),bKeys=Object.keys(objB);if(bKeys.length!==aKeys.length)return!1;for(var i=0;i<bKeys.length;i++){var key=aKeys[i];if(objA[key]!==objB[key])return!1}return!0};exports.setRef=function(ref,node){if(\"function\"===typeof ref)return safeInvoke(ref,node);null!=ref&&(ref.current=node)}}","~:source","shadow$provide[\"module$node_modules$react_popper$lib$cjs$utils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setRef = exports.shallowEqual = exports.safeInvoke = exports.unwrapArray = void 0;\n\n/**\n * Takes an argument and if it's an array, returns the first item in the array,\n * otherwise returns the argument. Used for Preact compatibility.\n */\nvar unwrapArray = function unwrapArray(arg) {\n  return Array.isArray(arg) ? arg[0] : arg;\n};\n/**\n * Takes a maybe-undefined function and arbitrary args and invokes the function\n * only if it is defined.\n */\n\n\nexports.unwrapArray = unwrapArray;\n\nvar safeInvoke = function safeInvoke(fn) {\n  if (typeof fn === \"function\") {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return fn.apply(void 0, args);\n  }\n};\n/**\n * Does a shallow equality check of two objects by comparing the reference\n * equality of each value.\n */\n\n\nexports.safeInvoke = safeInvoke;\n\nvar shallowEqual = function shallowEqual(objA, objB) {\n  var aKeys = Object.keys(objA);\n  var bKeys = Object.keys(objB);\n\n  if (bKeys.length !== aKeys.length) {\n    return false;\n  }\n\n  for (var i = 0; i < bKeys.length; i++) {\n    var key = aKeys[i];\n\n    if (objA[key] !== objB[key]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Sets a ref using either a ref callback or a ref object\n */\n\n\nexports.shallowEqual = shallowEqual;\n\nvar setRef = function setRef(ref, node) {\n  // if its a function call it\n  if (typeof ref === \"function\") {\n    return safeInvoke(ref, node);\n  } // otherwise we should treat it as a ref object\n  else if (ref != null) {\n      ref.current = node;\n    }\n};\n\nexports.setRef = setRef;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["shallowEqual","__esModule","value","setRef","current","safeInvoke","unwrapArray"]],"~:compiled-at",1630405505000,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_popper$lib$cjs$utils.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,8CAAA,CAAmE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG3GC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,MAAR,CAAiBJ,OAAQK,CAAAA,YAAzB,CAAwCL,OAAQM,CAAAA,UAAhD,CAA6DN,OAAQO,CAAAA,WAArE,CAAmF,IAAK,EAexFP,QAAQO,CAAAA,WAAR,CATkBA,QAAoB,CAACC,GAAD,CAAM,CAC1C,MAAOC,MAAMC,CAAAA,OAAN,CAAcF,GAAd,CAAA,CAAqBA,GAAA,CAAI,CAAJ,CAArB,CAA8BA,GADK,CAW5C,KAAIF,WAAaA,QAAmB,CAACK,EAAD,CAAK,CACvC,GAAkB,UAAlB,GAAI,MAAOA,GAAX,CAA8B,CAC5B,IAD4B,IACnBC,KAAOC,SAAUC,CAAAA,MADE,CACMC,KAAWN,KAAJ,CAAiB,CAAP,CAAAG,IAAA,CAAWA,IAAX,CAAkB,CAAlB,CAAsB,CAAhC,CADb,CACiDI,KAAO,CAApF,CAAuFA,IAAvF,CAA8FJ,IAA9F,CAAoGI,IAAA,EAApG,CACED,IAAA,CAAKC,IAAL,CAAY,CAAZ,CAAA,CAAiBH,SAAA,CAAUG,IAAV,CAGnB,OAAOL,GAAGM,CAAAA,KAAH,CAAS,IAAK,EAAd,CAAiBF,IAAjB,CALqB,CADS,CAezCf;OAAQM,CAAAA,UAAR,CAAqBA,UAyBrBN,QAAQK,CAAAA,YAAR,CAvBmBA,QAAqB,CAACa,IAAD,CAAOC,IAAP,CAAa,CACnD,IAAIC,MAAQnB,MAAOoB,CAAAA,IAAP,CAAYH,IAAZ,CAAZ,CACII,MAAQrB,MAAOoB,CAAAA,IAAP,CAAYF,IAAZ,CAEZ,IAAIG,KAAMR,CAAAA,MAAV,GAAqBM,KAAMN,CAAAA,MAA3B,CACE,MAAO,CAAA,CAGT,KAAK,IAAIS,EAAI,CAAb,CAAgBA,CAAhB,CAAoBD,KAAMR,CAAAA,MAA1B,CAAkCS,CAAA,EAAlC,CAAuC,CACrC,IAAIC,IAAMJ,KAAA,CAAMG,CAAN,CAEV,IAAIL,IAAA,CAAKM,GAAL,CAAJ,GAAkBL,IAAA,CAAKK,GAAL,CAAlB,CACE,MAAO,CAAA,CAJ4B,CAQvC,MAAO,CAAA,CAhB4C,CAmCrDxB,QAAQI,CAAAA,MAAR,CAVaA,QAAe,CAACqB,GAAD,CAAMC,IAAN,CAAY,CAEtC,GAAmB,UAAnB,GAAI,MAAOD,IAAX,CACE,MAAOnB,WAAA,CAAWmB,GAAX,CAAgBC,IAAhB,CAEO,KAAX,EAAID,GAAJ,GACDA,GAAIE,CAAAA,OADH,CACaD,IADb,CALiC,CAjEmE;\",\n\"sources\":[\"node_modules/react-popper/lib/cjs/utils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_popper$lib$cjs$utils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.setRef = exports.shallowEqual = exports.safeInvoke = exports.unwrapArray = void 0;\\n\\n/**\\n * Takes an argument and if it's an array, returns the first item in the array,\\n * otherwise returns the argument. Used for Preact compatibility.\\n */\\nvar unwrapArray = function unwrapArray(arg) {\\n  return Array.isArray(arg) ? arg[0] : arg;\\n};\\n/**\\n * Takes a maybe-undefined function and arbitrary args and invokes the function\\n * only if it is defined.\\n */\\n\\n\\nexports.unwrapArray = unwrapArray;\\n\\nvar safeInvoke = function safeInvoke(fn) {\\n  if (typeof fn === \\\"function\\\") {\\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n      args[_key - 1] = arguments[_key];\\n    }\\n\\n    return fn.apply(void 0, args);\\n  }\\n};\\n/**\\n * Does a shallow equality check of two objects by comparing the reference\\n * equality of each value.\\n */\\n\\n\\nexports.safeInvoke = safeInvoke;\\n\\nvar shallowEqual = function shallowEqual(objA, objB) {\\n  var aKeys = Object.keys(objA);\\n  var bKeys = Object.keys(objB);\\n\\n  if (bKeys.length !== aKeys.length) {\\n    return false;\\n  }\\n\\n  for (var i = 0; i < bKeys.length; i++) {\\n    var key = aKeys[i];\\n\\n    if (objA[key] !== objB[key]) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n/**\\n * Sets a ref using either a ref callback or a ref object\\n */\\n\\n\\nexports.shallowEqual = shallowEqual;\\n\\nvar setRef = function setRef(ref, node) {\\n  // if its a function call it\\n  if (typeof ref === \\\"function\\\") {\\n    return safeInvoke(ref, node);\\n  } // otherwise we should treat it as a ref object\\n  else if (ref != null) {\\n      ref.current = node;\\n    }\\n};\\n\\nexports.setRef = setRef;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"setRef\",\"shallowEqual\",\"safeInvoke\",\"unwrapArray\",\"arg\",\"Array\",\"isArray\",\"fn\",\"_len\",\"arguments\",\"length\",\"args\",\"_key\",\"apply\",\"objA\",\"objB\",\"aKeys\",\"keys\",\"bKeys\",\"i\",\"key\",\"ref\",\"node\",\"current\"]\n}\n"]