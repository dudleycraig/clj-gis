["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$parse$parser$traits$gast_recorder=function(global,require,module,exports){function recordProd(prodConstructor,mainProdArg,occurrence,handleSep){void 0===handleSep&&(handleSep=!1);assertMethodIdxIsValid(occurrence);var prevProd=utils_1.peek(this.recordingProdStack),grammarAction=utils_1.isFunction(mainProdArg)?mainProdArg:mainProdArg.DEF;prodConstructor=new prodConstructor({definition:[],idx:occurrence});handleSep&&(prodConstructor.separator=mainProdArg.SEP);\nutils_1.has(mainProdArg,\"MAX_LOOKAHEAD\")&&(prodConstructor.maxLookahead=mainProdArg.MAX_LOOKAHEAD);this.recordingProdStack.push(prodConstructor);grammarAction.call(this);prevProd.definition.push(prodConstructor);this.recordingProdStack.pop();return RECORDING_NULL_OBJECT}function recordOrProd(mainProdArg,occurrence){var _this=this;assertMethodIdxIsValid(occurrence);var prevProd=utils_1.peek(this.recordingProdStack),hasOptions=!1===utils_1.isArray(mainProdArg),alts=!1===hasOptions?mainProdArg:mainProdArg.DEF,\nnewOrProd=new gast_public_1.Alternation({definition:[],idx:occurrence,ignoreAmbiguities:hasOptions&&!0===mainProdArg.IGNORE_AMBIGUITIES});utils_1.has(mainProdArg,\"MAX_LOOKAHEAD\")&&(newOrProd.maxLookahead=mainProdArg.MAX_LOOKAHEAD);mainProdArg=utils_1.some(alts,function(currAlt){return utils_1.isFunction(currAlt.GATE)});newOrProd.hasPredicates=mainProdArg;prevProd.definition.push(newOrProd);utils_1.forEach(alts,function(currAlt){var currAltFlat=new gast_public_1.Alternative({definition:[]});newOrProd.definition.push(currAltFlat);\nutils_1.has(currAlt,\"IGNORE_AMBIGUITIES\")?currAltFlat.ignoreAmbiguities=currAlt.IGNORE_AMBIGUITIES:utils_1.has(currAlt,\"GATE\")&&(currAltFlat.ignoreAmbiguities=!0);_this.recordingProdStack.push(currAltFlat);currAlt.ALT.call(_this);_this.recordingProdStack.pop()});return RECORDING_NULL_OBJECT}function assertMethodIdxIsValid(idx){if(0>idx||idx>MAX_METHOD_IDX)throw idx=Error(\"Invalid DSL Method idx value: \\x3c\"+idx+\"\\x3e\\n\\tIdx value must be a none negative value smaller than \"+(MAX_METHOD_IDX+1)),idx.KNOWN_RECORDER_ERROR=\n!0,idx;}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.GastRecorder=void 0;var utils_1=require(\"module$node_modules$$chevrotain$utils$lib$src$api\"),gast_public_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_public\");module=require(\"module$node_modules$chevrotain$lib$src$scan$lexer_public\");var tokens_1=require(\"module$node_modules$chevrotain$lib$src$scan$tokens\");global=require(\"module$node_modules$chevrotain$lib$src$scan$tokens_public\");var parser_1=require(\"module$node_modules$chevrotain$lib$src$parse$parser$parser\");\nrequire=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$keys\");var RECORDING_NULL_OBJECT={description:\"This Object indicates the Parser is during Recording Phase\"};Object.freeze(RECORDING_NULL_OBJECT);var MAX_METHOD_IDX=Math.pow(2,require.BITS_FOR_OCCURRENCE_IDX)-1;require=global.createToken({name:\"RECORDING_PHASE_TOKEN\",pattern:module.Lexer.NA});tokens_1.augmentTokenTypes([require]);var RECORDING_PHASE_TOKEN=global.createTokenInstance(require,\"This IToken indicates the Parser is in Recording Phase\\n\\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n-1,-1,-1,-1,-1,-1);Object.freeze(RECORDING_PHASE_TOKEN);var RECORDING_PHASE_CSTNODE={name:\"This CSTNode indicates the Parser is in Recording Phase\\n\\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",children:{}};require=function(){function GastRecorder(){}GastRecorder.prototype.initGastRecorder=function(config){this.recordingProdStack=[];this.RECORDING_PHASE=!1};GastRecorder.prototype.enableRecording=function(){var _this=this;this.RECORDING_PHASE=!0;this.TRACE_INIT(\"Enable Recording\",\nfunction(){for(var _loop_1=function(i){var idx=0<i?i:\"\";_this[\"CONSUME\"+idx]=function(arg1,arg2){return this.consumeInternalRecord(arg1,i,arg2)};_this[\"SUBRULE\"+idx]=function(arg1,arg2){return this.subruleInternalRecord(arg1,i,arg2)};_this[\"OPTION\"+idx]=function(arg1){return this.optionInternalRecord(arg1,i)};_this[\"OR\"+idx]=function(arg1){return this.orInternalRecord(arg1,i)};_this[\"MANY\"+idx]=function(arg1){this.manyInternalRecord(i,arg1)};_this[\"MANY_SEP\"+idx]=function(arg1){this.manySepFirstInternalRecord(i,\narg1)};_this[\"AT_LEAST_ONE\"+idx]=function(arg1){this.atLeastOneInternalRecord(i,arg1)};_this[\"AT_LEAST_ONE_SEP\"+idx]=function(arg1){this.atLeastOneSepFirstInternalRecord(i,arg1)}},i$jscomp$0=0;10>i$jscomp$0;i$jscomp$0++)_loop_1(i$jscomp$0);_this.consume=function(idx,arg1,arg2){return this.consumeInternalRecord(arg1,idx,arg2)};_this.subrule=function(idx,arg1,arg2){return this.subruleInternalRecord(arg1,idx,arg2)};_this.option=function(idx,arg1){return this.optionInternalRecord(arg1,idx)};_this.or=\nfunction(idx,arg1){return this.orInternalRecord(arg1,idx)};_this.many=function(idx,arg1){this.manyInternalRecord(idx,arg1)};_this.atLeastOne=function(idx,arg1){this.atLeastOneInternalRecord(idx,arg1)};_this.ACTION=_this.ACTION_RECORD;_this.BACKTRACK=_this.BACKTRACK_RECORD;_this.LA=_this.LA_RECORD})};GastRecorder.prototype.disableRecording=function(){var _this=this;this.RECORDING_PHASE=!1;this.TRACE_INIT(\"Deleting Recording methods\",function(){for(var i=0;10>i;i++){var idx=0<i?i:\"\";delete _this[\"CONSUME\"+\nidx];delete _this[\"SUBRULE\"+idx];delete _this[\"OPTION\"+idx];delete _this[\"OR\"+idx];delete _this[\"MANY\"+idx];delete _this[\"MANY_SEP\"+idx];delete _this[\"AT_LEAST_ONE\"+idx];delete _this[\"AT_LEAST_ONE_SEP\"+idx]}delete _this.consume;delete _this.subrule;delete _this.option;delete _this.or;delete _this.many;delete _this.atLeastOne;delete _this.ACTION;delete _this.BACKTRACK;delete _this.LA})};GastRecorder.prototype.ACTION_RECORD=function(impl){};GastRecorder.prototype.BACKTRACK_RECORD=function(grammarRule,\nargs){return function(){return!0}};GastRecorder.prototype.LA_RECORD=function(howMuch){return parser_1.END_OF_FILE};GastRecorder.prototype.topLevelRuleRecord=function(name,def){try{var newTopLevelRule=new gast_public_1.Rule({definition:[],name});newTopLevelRule.name=name;this.recordingProdStack.push(newTopLevelRule);def.call(this);this.recordingProdStack.pop();return newTopLevelRule}catch(originalError){if(!0!==originalError.KNOWN_RECORDER_ERROR)try{originalError.message+='\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\thttps://chevrotain.io/docs/guide/internals.html#grammar-recording'}catch(mutabilityError){}throw originalError;\n}};GastRecorder.prototype.optionInternalRecord=function(actionORMethodDef,occurrence){return recordProd.call(this,gast_public_1.Option,actionORMethodDef,occurrence)};GastRecorder.prototype.atLeastOneInternalRecord=function(occurrence,actionORMethodDef){recordProd.call(this,gast_public_1.RepetitionMandatory,actionORMethodDef,occurrence)};GastRecorder.prototype.atLeastOneSepFirstInternalRecord=function(occurrence,options){recordProd.call(this,gast_public_1.RepetitionMandatoryWithSeparator,options,occurrence,\n!0)};GastRecorder.prototype.manyInternalRecord=function(occurrence,actionORMethodDef){recordProd.call(this,gast_public_1.Repetition,actionORMethodDef,occurrence)};GastRecorder.prototype.manySepFirstInternalRecord=function(occurrence,options){recordProd.call(this,gast_public_1.RepetitionWithSeparator,options,occurrence,!0)};GastRecorder.prototype.orInternalRecord=function(altsOrOpts,occurrence){return recordOrProd.call(this,altsOrOpts,occurrence)};GastRecorder.prototype.subruleInternalRecord=function(ruleToCall,\noccurrence,options){assertMethodIdxIsValid(occurrence);if(!ruleToCall||!1===utils_1.has(ruleToCall,\"ruleName\")){var error=Error(\"\\x3cSUBRULE\"+(0===occurrence?\"\":\"\"+occurrence)+\"\\x3e argument is invalid expecting a Parser method reference but got: \\x3c\"+(JSON.stringify(ruleToCall)+\"\\x3e\\n inside top level rule: \\x3c\")+(this.recordingProdStack[0].name+\"\\x3e\"));error.KNOWN_RECORDER_ERROR=!0;throw error;}error=utils_1.peek(this.recordingProdStack);ruleToCall=new gast_public_1.NonTerminal({idx:occurrence,\nnonTerminalName:ruleToCall.ruleName,label:null===options||void 0===options?void 0:options.LABEL,referencedRule:void 0});error.definition.push(ruleToCall);return this.outputCst?RECORDING_PHASE_CSTNODE:RECORDING_NULL_OBJECT};GastRecorder.prototype.consumeInternalRecord=function(tokType,occurrence,options){assertMethodIdxIsValid(occurrence);if(!tokens_1.hasShortKeyProperty(tokType)){var error=Error(\"\\x3cCONSUME\"+(0===occurrence?\"\":\"\"+occurrence)+\"\\x3e argument is invalid expecting a TokenType reference but got: \\x3c\"+\n(JSON.stringify(tokType)+\"\\x3e\\n inside top level rule: \\x3c\")+(this.recordingProdStack[0].name+\"\\x3e\"));error.KNOWN_RECORDER_ERROR=!0;throw error;}error=utils_1.peek(this.recordingProdStack);tokType=new gast_public_1.Terminal({idx:occurrence,terminalType:tokType,label:null===options||void 0===options?void 0:options.LABEL});error.definition.push(tokType);return RECORDING_PHASE_TOKEN};return GastRecorder}();exports.GastRecorder=require}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$parse$parser$traits$gast_recorder\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GastRecorder = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar gast_public_1 = require(\"../../grammar/gast/gast_public\");\nvar lexer_public_1 = require(\"../../../scan/lexer_public\");\nvar tokens_1 = require(\"../../../scan/tokens\");\nvar tokens_public_1 = require(\"../../../scan/tokens_public\");\nvar parser_1 = require(\"../parser\");\nvar keys_1 = require(\"../../grammar/keys\");\nvar RECORDING_NULL_OBJECT = {\n    description: \"This Object indicates the Parser is during Recording Phase\"\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nvar HANDLE_SEPARATOR = true;\nvar MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;\nvar RFT = tokens_public_1.createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: lexer_public_1.Lexer.NA });\ntokens_1.augmentTokenTypes([RFT]);\nvar RECORDING_PHASE_TOKEN = tokens_public_1.createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\n    \"\" +\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\", \n// Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nvar RECORDING_PHASE_CSTNODE = {\n    name: \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\n        \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    children: {}\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nvar GastRecorder = /** @class */ (function () {\n    function GastRecorder() {\n    }\n    GastRecorder.prototype.initGastRecorder = function (config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    };\n    GastRecorder.prototype.enableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT(\"Enable Recording\", function () {\n            var _loop_1 = function (i) {\n                var idx = i > 0 ? i : \"\";\n                _this[\"CONSUME\" + idx] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                _this[\"SUBRULE\" + idx] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                _this[\"OPTION\" + idx] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                _this[\"OR\" + idx] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                _this[\"MANY\" + idx] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                _this[\"MANY_SEP\" + idx] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE\" + idx] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                _this[\"AT_LEAST_ONE_SEP\" + idx] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            };\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are \"replacing\" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n             *   implementations directly instead.\n             */\n            for (var i = 0; i < 10; i++) {\n                _loop_1(i);\n            }\n            // DSL methods with the idx(suffix) as an argument\n            _this[\"consume\"] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"subrule\"] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            _this[\"option\"] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            _this[\"or\"] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            _this[\"many\"] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            _this[\"atLeastOne\"] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            _this.ACTION = _this.ACTION_RECORD;\n            _this.BACKTRACK = _this.BACKTRACK_RECORD;\n            _this.LA = _this.LA_RECORD;\n        });\n    };\n    GastRecorder.prototype.disableRecording = function () {\n        var _this = this;\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT(\"Deleting Recording methods\", function () {\n            for (var i = 0; i < 10; i++) {\n                var idx = i > 0 ? i : \"\";\n                delete _this[\"CONSUME\" + idx];\n                delete _this[\"SUBRULE\" + idx];\n                delete _this[\"OPTION\" + idx];\n                delete _this[\"OR\" + idx];\n                delete _this[\"MANY\" + idx];\n                delete _this[\"MANY_SEP\" + idx];\n                delete _this[\"AT_LEAST_ONE\" + idx];\n                delete _this[\"AT_LEAST_ONE_SEP\" + idx];\n            }\n            delete _this[\"consume\"];\n            delete _this[\"subrule\"];\n            delete _this[\"option\"];\n            delete _this[\"or\"];\n            delete _this[\"many\"];\n            delete _this[\"atLeastOne\"];\n            delete _this.ACTION;\n            delete _this.BACKTRACK;\n            delete _this.LA;\n        });\n    };\n    // TODO: is there any way to use this method to check no\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    GastRecorder.prototype.ACTION_RECORD = function (impl) {\n        // NO-OP during recording\n        return;\n    };\n    // Executing backtracking logic will break our recording logic assumptions\n    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\n        return function () { return true; };\n    };\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    GastRecorder.prototype.LA_RECORD = function (howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return parser_1.END_OF_FILE;\n    };\n    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\n        try {\n            var newTopLevelRule = new gast_public_1.Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n                            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    };\n    // Implementation of parsing DSL\n    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\n        return recordProd.call(this, gast_public_1.Option, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, gast_public_1.RepetitionMandatory, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, gast_public_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\n        recordProd.call(this, gast_public_1.Repetition, actionORMethodDef, occurrence);\n    };\n    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\n        recordProd.call(this, gast_public_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    };\n    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    };\n    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || utils_1.has(ruleToCall, \"ruleName\") === false) {\n            var error = new Error(\"<SUBRULE\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a Parser method reference but got: <\" + JSON.stringify(ruleToCall) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = utils_1.peek(this.recordingProdStack);\n        var ruleName = ruleToCall[\"ruleName\"];\n        var newNoneTerminal = new gast_public_1.NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: undefined\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n    };\n    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!tokens_1.hasShortKeyProperty(tokType)) {\n            var error = new Error(\"<CONSUME\" + getIdxSuffix(occurrence) + \"> argument is invalid\" +\n                (\" expecting a TokenType reference but got: <\" + JSON.stringify(tokType) + \">\") +\n                (\"\\n inside top level rule: <\" + this.recordingProdStack[0].name + \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        var prevProd = utils_1.peek(this.recordingProdStack);\n        var newNoneTerminal = new gast_public_1.Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    };\n    return GastRecorder;\n}());\nexports.GastRecorder = GastRecorder;\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\n    if (handleSep === void 0) { handleSep = false; }\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = utils_1.peek(this.recordingProdStack);\n    var grammarAction = utils_1.isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    var newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if (utils_1.has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    var _this = this;\n    assertMethodIdxIsValid(occurrence);\n    var prevProd = utils_1.peek(this.recordingProdStack);\n    // Only an array of alternatives\n    var hasOptions = utils_1.isArray(mainProdArg) === false;\n    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    var newOrProd = new gast_public_1.Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n    });\n    if (utils_1.has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    var hasPredicates = utils_1.some(alts, function (currAlt) { return utils_1.isFunction(currAlt.GATE); });\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    utils_1.forEach(alts, function (currAlt) {\n        var currAltFlat = new gast_public_1.Alternative({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if (utils_1.has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if (utils_1.has(currAlt, \"GATE\")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        _this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(_this);\n        _this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? \"\" : \"\" + idx;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        var error = new Error(\n        // The stack trace will contain all the needed details\n        \"Invalid DSL Method idx value: <\" + idx + \">\\n\\t\" +\n            (\"Idx value must be a none negative value smaller than \" + (MAX_METHOD_IDX + 1)));\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$chevrotain$utils$lib$src$api","~$module$node_modules$chevrotain$lib$src$scan$tokens","~$shadow.js","~$module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_public","~$module$node_modules$chevrotain$lib$src$parse$grammar$keys","~$module$node_modules$chevrotain$lib$src$scan$tokens_public","~$module$node_modules$chevrotain$lib$src$parse$parser$parser","~$module$node_modules$chevrotain$lib$src$scan$lexer_public"]],"~:properties",["^5",["message","subruleInternalRecord","maxLookahead","recordingProdStack","ACTION_RECORD","orInternalRecord","GastRecorder","BACKTRACK","ACTION","referencedRule","label","children","manyInternalRecord","__esModule","LA_RECORD","KNOWN_RECORDER_ERROR","name","value","disableRecording","RECORDING_PHASE","hasPredicates","BACKTRACK_RECORD","ignoreAmbiguities","nonTerminalName","atLeastOneInternalRecord","definition","LA","topLevelRuleRecord","pattern","initGastRecorder","optionInternalRecord","consumeInternalRecord","enableRecording","idx","separator","description","manySepFirstInternalRecord","atLeastOneSepFirstInternalRecord","terminalType"]],"~:compiled-at",1630917515716,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$parse$parser$traits$gast_recorder.js\",\n\"lineCount\":17,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$parse$parser$traits$gast_recorder\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.GastRecorder = void 0;\\nvar utils_1 = require(\\\"@chevrotain/utils\\\");\\nvar gast_public_1 = require(\\\"../../grammar/gast/gast_public\\\");\\nvar lexer_public_1 = require(\\\"../../../scan/lexer_public\\\");\\nvar tokens_1 = require(\\\"../../../scan/tokens\\\");\\nvar tokens_public_1 = require(\\\"../../../scan/tokens_public\\\");\\nvar parser_1 = require(\\\"../parser\\\");\\nvar keys_1 = require(\\\"../../grammar/keys\\\");\\nvar RECORDING_NULL_OBJECT = {\\n    description: \\\"This Object indicates the Parser is during Recording Phase\\\"\\n};\\nObject.freeze(RECORDING_NULL_OBJECT);\\nvar HANDLE_SEPARATOR = true;\\nvar MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;\\nvar RFT = tokens_public_1.createToken({ name: \\\"RECORDING_PHASE_TOKEN\\\", pattern: lexer_public_1.Lexer.NA });\\ntokens_1.augmentTokenTypes([RFT]);\\nvar RECORDING_PHASE_TOKEN = tokens_public_1.createTokenInstance(RFT, \\\"This IToken indicates the Parser is in Recording Phase\\\\n\\\\t\\\" +\\n    \\\"\\\" +\\n    \\\"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\\\", \\n// Using \\\"-1\\\" instead of NaN (as in EOF) because an actual number is less likely to\\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\\n-1, -1, -1, -1, -1, -1);\\nObject.freeze(RECORDING_PHASE_TOKEN);\\nvar RECORDING_PHASE_CSTNODE = {\\n    name: \\\"This CSTNode indicates the Parser is in Recording Phase\\\\n\\\\t\\\" +\\n        \\\"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\\\",\\n    children: {}\\n};\\n/**\\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\\n */\\nvar GastRecorder = /** @class */ (function () {\\n    function GastRecorder() {\\n    }\\n    GastRecorder.prototype.initGastRecorder = function (config) {\\n        this.recordingProdStack = [];\\n        this.RECORDING_PHASE = false;\\n    };\\n    GastRecorder.prototype.enableRecording = function () {\\n        var _this = this;\\n        this.RECORDING_PHASE = true;\\n        this.TRACE_INIT(\\\"Enable Recording\\\", function () {\\n            var _loop_1 = function (i) {\\n                var idx = i > 0 ? i : \\\"\\\";\\n                _this[\\\"CONSUME\\\" + idx] = function (arg1, arg2) {\\n                    return this.consumeInternalRecord(arg1, i, arg2);\\n                };\\n                _this[\\\"SUBRULE\\\" + idx] = function (arg1, arg2) {\\n                    return this.subruleInternalRecord(arg1, i, arg2);\\n                };\\n                _this[\\\"OPTION\\\" + idx] = function (arg1) {\\n                    return this.optionInternalRecord(arg1, i);\\n                };\\n                _this[\\\"OR\\\" + idx] = function (arg1) {\\n                    return this.orInternalRecord(arg1, i);\\n                };\\n                _this[\\\"MANY\\\" + idx] = function (arg1) {\\n                    this.manyInternalRecord(i, arg1);\\n                };\\n                _this[\\\"MANY_SEP\\\" + idx] = function (arg1) {\\n                    this.manySepFirstInternalRecord(i, arg1);\\n                };\\n                _this[\\\"AT_LEAST_ONE\\\" + idx] = function (arg1) {\\n                    this.atLeastOneInternalRecord(i, arg1);\\n                };\\n                _this[\\\"AT_LEAST_ONE_SEP\\\" + idx] = function (arg1) {\\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\\n                };\\n            };\\n            /**\\n             * Warning Dark Voodoo Magic upcoming!\\n             * We are \\\"replacing\\\" the public parsing DSL methods API\\n             * With **new** alternative implementations on the Parser **instance**\\n             *\\n             * So far this is the only way I've found to avoid performance regressions during parsing time.\\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \\\"internal\\\"\\n             *   implementations directly instead.\\n             */\\n            for (var i = 0; i < 10; i++) {\\n                _loop_1(i);\\n            }\\n            // DSL methods with the idx(suffix) as an argument\\n            _this[\\\"consume\\\"] = function (idx, arg1, arg2) {\\n                return this.consumeInternalRecord(arg1, idx, arg2);\\n            };\\n            _this[\\\"subrule\\\"] = function (idx, arg1, arg2) {\\n                return this.subruleInternalRecord(arg1, idx, arg2);\\n            };\\n            _this[\\\"option\\\"] = function (idx, arg1) {\\n                return this.optionInternalRecord(arg1, idx);\\n            };\\n            _this[\\\"or\\\"] = function (idx, arg1) {\\n                return this.orInternalRecord(arg1, idx);\\n            };\\n            _this[\\\"many\\\"] = function (idx, arg1) {\\n                this.manyInternalRecord(idx, arg1);\\n            };\\n            _this[\\\"atLeastOne\\\"] = function (idx, arg1) {\\n                this.atLeastOneInternalRecord(idx, arg1);\\n            };\\n            _this.ACTION = _this.ACTION_RECORD;\\n            _this.BACKTRACK = _this.BACKTRACK_RECORD;\\n            _this.LA = _this.LA_RECORD;\\n        });\\n    };\\n    GastRecorder.prototype.disableRecording = function () {\\n        var _this = this;\\n        this.RECORDING_PHASE = false;\\n        // By deleting these **instance** properties, any future invocation\\n        // will be deferred to the original methods on the **prototype** object\\n        // This seems to get rid of any incorrect optimizations that V8 may\\n        // do during the recording phase.\\n        this.TRACE_INIT(\\\"Deleting Recording methods\\\", function () {\\n            for (var i = 0; i < 10; i++) {\\n                var idx = i > 0 ? i : \\\"\\\";\\n                delete _this[\\\"CONSUME\\\" + idx];\\n                delete _this[\\\"SUBRULE\\\" + idx];\\n                delete _this[\\\"OPTION\\\" + idx];\\n                delete _this[\\\"OR\\\" + idx];\\n                delete _this[\\\"MANY\\\" + idx];\\n                delete _this[\\\"MANY_SEP\\\" + idx];\\n                delete _this[\\\"AT_LEAST_ONE\\\" + idx];\\n                delete _this[\\\"AT_LEAST_ONE_SEP\\\" + idx];\\n            }\\n            delete _this[\\\"consume\\\"];\\n            delete _this[\\\"subrule\\\"];\\n            delete _this[\\\"option\\\"];\\n            delete _this[\\\"or\\\"];\\n            delete _this[\\\"many\\\"];\\n            delete _this[\\\"atLeastOne\\\"];\\n            delete _this.ACTION;\\n            delete _this.BACKTRACK;\\n            delete _this.LA;\\n        });\\n    };\\n    // TODO: is there any way to use this method to check no\\n    //   Parser methods are called inside an ACTION?\\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\\n    GastRecorder.prototype.ACTION_RECORD = function (impl) {\\n        // NO-OP during recording\\n        return;\\n    };\\n    // Executing backtracking logic will break our recording logic assumptions\\n    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {\\n        return function () { return true; };\\n    };\\n    // LA is part of the official API and may be used for custom lookahead logic\\n    // by end users who may forget to wrap it in ACTION or inside a GATE\\n    GastRecorder.prototype.LA_RECORD = function (howMuch) {\\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\\n        // On LA return EOF at the end of the input so an infinite loop may occur.\\n        return parser_1.END_OF_FILE;\\n    };\\n    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {\\n        try {\\n            var newTopLevelRule = new gast_public_1.Rule({ definition: [], name: name });\\n            newTopLevelRule.name = name;\\n            this.recordingProdStack.push(newTopLevelRule);\\n            def.call(this);\\n            this.recordingProdStack.pop();\\n            return newTopLevelRule;\\n        }\\n        catch (originalError) {\\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\\n                try {\\n                    originalError.message =\\n                        originalError.message +\\n                            '\\\\n\\\\t This error was thrown during the \\\"grammar recording phase\\\" For more info see:\\\\n\\\\t' +\\n                            \\\"https://chevrotain.io/docs/guide/internals.html#grammar-recording\\\";\\n                }\\n                catch (mutabilityError) {\\n                    // We may not be able to modify the original error object\\n                    throw originalError;\\n                }\\n            }\\n            throw originalError;\\n        }\\n    };\\n    // Implementation of parsing DSL\\n    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {\\n        return recordProd.call(this, gast_public_1.Option, actionORMethodDef, occurrence);\\n    };\\n    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {\\n        recordProd.call(this, gast_public_1.RepetitionMandatory, actionORMethodDef, occurrence);\\n    };\\n    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {\\n        recordProd.call(this, gast_public_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\\n    };\\n    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {\\n        recordProd.call(this, gast_public_1.Repetition, actionORMethodDef, occurrence);\\n    };\\n    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {\\n        recordProd.call(this, gast_public_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\\n    };\\n    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {\\n        return recordOrProd.call(this, altsOrOpts, occurrence);\\n    };\\n    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {\\n        assertMethodIdxIsValid(occurrence);\\n        if (!ruleToCall || utils_1.has(ruleToCall, \\\"ruleName\\\") === false) {\\n            var error = new Error(\\\"<SUBRULE\\\" + getIdxSuffix(occurrence) + \\\"> argument is invalid\\\" +\\n                (\\\" expecting a Parser method reference but got: <\\\" + JSON.stringify(ruleToCall) + \\\">\\\") +\\n                (\\\"\\\\n inside top level rule: <\\\" + this.recordingProdStack[0].name + \\\">\\\"));\\n            error.KNOWN_RECORDER_ERROR = true;\\n            throw error;\\n        }\\n        var prevProd = utils_1.peek(this.recordingProdStack);\\n        var ruleName = ruleToCall[\\\"ruleName\\\"];\\n        var newNoneTerminal = new gast_public_1.NonTerminal({\\n            idx: occurrence,\\n            nonTerminalName: ruleName,\\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\\n            referencedRule: undefined\\n        });\\n        prevProd.definition.push(newNoneTerminal);\\n        return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\\n    };\\n    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {\\n        assertMethodIdxIsValid(occurrence);\\n        if (!tokens_1.hasShortKeyProperty(tokType)) {\\n            var error = new Error(\\\"<CONSUME\\\" + getIdxSuffix(occurrence) + \\\"> argument is invalid\\\" +\\n                (\\\" expecting a TokenType reference but got: <\\\" + JSON.stringify(tokType) + \\\">\\\") +\\n                (\\\"\\\\n inside top level rule: <\\\" + this.recordingProdStack[0].name + \\\">\\\"));\\n            error.KNOWN_RECORDER_ERROR = true;\\n            throw error;\\n        }\\n        var prevProd = utils_1.peek(this.recordingProdStack);\\n        var newNoneTerminal = new gast_public_1.Terminal({\\n            idx: occurrence,\\n            terminalType: tokType,\\n            label: options === null || options === void 0 ? void 0 : options.LABEL\\n        });\\n        prevProd.definition.push(newNoneTerminal);\\n        return RECORDING_PHASE_TOKEN;\\n    };\\n    return GastRecorder;\\n}());\\nexports.GastRecorder = GastRecorder;\\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {\\n    if (handleSep === void 0) { handleSep = false; }\\n    assertMethodIdxIsValid(occurrence);\\n    var prevProd = utils_1.peek(this.recordingProdStack);\\n    var grammarAction = utils_1.isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\\n    var newProd = new prodConstructor({ definition: [], idx: occurrence });\\n    if (handleSep) {\\n        newProd.separator = mainProdArg.SEP;\\n    }\\n    if (utils_1.has(mainProdArg, \\\"MAX_LOOKAHEAD\\\")) {\\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\\n    }\\n    this.recordingProdStack.push(newProd);\\n    grammarAction.call(this);\\n    prevProd.definition.push(newProd);\\n    this.recordingProdStack.pop();\\n    return RECORDING_NULL_OBJECT;\\n}\\nfunction recordOrProd(mainProdArg, occurrence) {\\n    var _this = this;\\n    assertMethodIdxIsValid(occurrence);\\n    var prevProd = utils_1.peek(this.recordingProdStack);\\n    // Only an array of alternatives\\n    var hasOptions = utils_1.isArray(mainProdArg) === false;\\n    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\\n    var newOrProd = new gast_public_1.Alternation({\\n        definition: [],\\n        idx: occurrence,\\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\\n    });\\n    if (utils_1.has(mainProdArg, \\\"MAX_LOOKAHEAD\\\")) {\\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\\n    }\\n    var hasPredicates = utils_1.some(alts, function (currAlt) { return utils_1.isFunction(currAlt.GATE); });\\n    newOrProd.hasPredicates = hasPredicates;\\n    prevProd.definition.push(newOrProd);\\n    utils_1.forEach(alts, function (currAlt) {\\n        var currAltFlat = new gast_public_1.Alternative({ definition: [] });\\n        newOrProd.definition.push(currAltFlat);\\n        if (utils_1.has(currAlt, \\\"IGNORE_AMBIGUITIES\\\")) {\\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\\n        }\\n        // **implicit** ignoreAmbiguities due to usage of gate\\n        else if (utils_1.has(currAlt, \\\"GATE\\\")) {\\n            currAltFlat.ignoreAmbiguities = true;\\n        }\\n        _this.recordingProdStack.push(currAltFlat);\\n        currAlt.ALT.call(_this);\\n        _this.recordingProdStack.pop();\\n    });\\n    return RECORDING_NULL_OBJECT;\\n}\\nfunction getIdxSuffix(idx) {\\n    return idx === 0 ? \\\"\\\" : \\\"\\\" + idx;\\n}\\nfunction assertMethodIdxIsValid(idx) {\\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\\n        var error = new Error(\\n        // The stack trace will contain all the needed details\\n        \\\"Invalid DSL Method idx value: <\\\" + idx + \\\">\\\\n\\\\t\\\" +\\n            (\\\"Idx value must be a none negative value smaller than \\\" + (MAX_METHOD_IDX + 1)));\\n        error.KNOWN_RECORDER_ERROR = true;\\n        throw error;\\n    }\\n}\\n//# sourceMappingURL=gast_recorder.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"recordProd\",\"prodConstructor\",\"mainProdArg\",\"occurrence\",\"handleSep\",\"assertMethodIdxIsValid\",\"prevProd\",\"utils_1\",\"peek\",\"recordingProdStack\",\"grammarAction\",\"isFunction\",\"DEF\",\"newProd\",\"definition\",\"idx\",\"separator\",\"SEP\",\"has\",\"maxLookahead\",\"MAX_LOOKAHEAD\",\"push\",\"call\",\"pop\",\"RECORDING_NULL_OBJECT\",\"recordOrProd\",\"_this\",\"hasOptions\",\"isArray\",\"alts\",\"newOrProd\",\"gast_public_1\",\"Alternation\",\"ignoreAmbiguities\",\"IGNORE_AMBIGUITIES\",\"hasPredicates\",\"some\",\"currAlt\",\"GATE\",\"forEach\",\"currAltFlat\",\"Alternative\",\"ALT\",\"MAX_METHOD_IDX\",\"error\",\"Error\",\"KNOWN_RECORDER_ERROR\",\"Object\",\"defineProperty\",\"value\",\"GastRecorder\",\"lexer_public_1\",\"tokens_1\",\"tokens_public_1\",\"parser_1\",\"keys_1\",\"description\",\"freeze\",\"Math\",\"pow\",\"BITS_FOR_OCCURRENCE_IDX\",\"RFT\",\"createToken\",\"name\",\"pattern\",\"Lexer\",\"NA\",\"augmentTokenTypes\",\"RECORDING_PHASE_TOKEN\",\"createTokenInstance\",\"RECORDING_PHASE_CSTNODE\",\"children\",\"prototype\",\"initGastRecorder\",\"GastRecorder.prototype.initGastRecorder\",\"config\",\"RECORDING_PHASE\",\"enableRecording\",\"GastRecorder.prototype.enableRecording\",\"TRACE_INIT\",\"_loop_1\",\"i\",\"arg1\",\"arg2\",\"consumeInternalRecord\",\"subruleInternalRecord\",\"optionInternalRecord\",\"orInternalRecord\",\"manyInternalRecord\",\"manySepFirstInternalRecord\",\"atLeastOneInternalRecord\",\"atLeastOneSepFirstInternalRecord\",\"ACTION\",\"ACTION_RECORD\",\"BACKTRACK\",\"BACKTRACK_RECORD\",\"LA\",\"LA_RECORD\",\"disableRecording\",\"GastRecorder.prototype.disableRecording\",\"GastRecorder.prototype.ACTION_RECORD\",\"impl\",\"GastRecorder.prototype.BACKTRACK_RECORD\",\"grammarRule\",\"args\",\"GastRecorder.prototype.LA_RECORD\",\"howMuch\",\"END_OF_FILE\",\"topLevelRuleRecord\",\"GastRecorder.prototype.topLevelRuleRecord\",\"def\",\"newTopLevelRule\",\"Rule\",\"originalError\",\"message\",\"mutabilityError\",\"GastRecorder.prototype.optionInternalRecord\",\"actionORMethodDef\",\"Option\",\"GastRecorder.prototype.atLeastOneInternalRecord\",\"RepetitionMandatory\",\"GastRecorder.prototype.atLeastOneSepFirstInternalRecord\",\"options\",\"RepetitionMandatoryWithSeparator\",\"HANDLE_SEPARATOR\",\"GastRecorder.prototype.manyInternalRecord\",\"Repetition\",\"GastRecorder.prototype.manySepFirstInternalRecord\",\"RepetitionWithSeparator\",\"GastRecorder.prototype.orInternalRecord\",\"altsOrOpts\",\"GastRecorder.prototype.subruleInternalRecord\",\"ruleToCall\",\"JSON\",\"stringify\",\"newNoneTerminal\",\"NonTerminal\",\"nonTerminalName\",\"ruleName\",\"label\",\"LABEL\",\"referencedRule\",\"undefined\",\"outputCst\",\"GastRecorder.prototype.consumeInternalRecord\",\"tokType\",\"hasShortKeyProperty\",\"Terminal\",\"terminalType\"]\n}\n"]