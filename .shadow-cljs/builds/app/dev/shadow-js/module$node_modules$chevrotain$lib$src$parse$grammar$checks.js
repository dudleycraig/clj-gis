["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/parse/grammar/checks.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$parse$grammar$checks=function(global,require,module,exports){function validateDuplicateProductions(topLevelRule,errMsgProvider){var collectorVisitor=new OccurrenceValidationCollector;topLevelRule.accept(collectorVisitor);collectorVisitor=utils.groupBy(collectorVisitor.allProductions,identifyProductionForDuplicates);collectorVisitor=utils.pick(collectorVisitor,function(currGroup){return 1<currGroup.length});return utils.map(utils.values(collectorVisitor),\nfunction(currDuplicates){var firstProd=utils.first(currDuplicates);currDuplicates=errMsgProvider.buildDuplicateFoundError(topLevelRule,currDuplicates);var dslName=gast_1.getProductionDslName(firstProd);currDuplicates={message:currDuplicates,type:parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,ruleName:topLevelRule.name,dslName,occurrence:firstProd.idx};if(firstProd=getExtraProductionArgument(firstProd))currDuplicates.parameter=firstProd;return currDuplicates})}function identifyProductionForDuplicates(prod){return gast_1.getProductionDslName(prod)+\n\"_#_\"+prod.idx+\"_#_\"+getExtraProductionArgument(prod)}function getExtraProductionArgument(prod){return prod instanceof gast_public_1.Terminal?prod.terminalType.name:prod instanceof gast_public_1.NonTerminal?prod.nonTerminalName:\"\"}function validateRuleDoesNotAlreadyExist(rule,allRules,className,errMsgProvider){var errors=[];1<utils_1.reduce(allRules,function(result,curRule){return curRule.name===rule.name?result+1:result},0)&&(allRules=errMsgProvider.buildDuplicateRuleNameError({topLevelRule:rule,\ngrammarName:className}),errors.push({message:allRules,type:parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:rule.name}));return errors}function validateNoLeftRecursion(topRule,currRule,errMsgProvider,path){void 0===path&&(path=[]);var errors=[];currRule=getFirstNoneTerminal(currRule.definition);if(utils.isEmpty(currRule))return[];var ruleName=topRule.name;utils.contains(currRule,topRule)&&errors.push({message:errMsgProvider.buildLeftRecursionError({topLevelRule:topRule,leftRecursionPath:path}),\ntype:parser_1.ParserDefinitionErrorType.LEFT_RECURSION,ruleName});currRule=utils.difference(currRule,path.concat([topRule]));currRule=utils.map(currRule,function(currRefRule){var newPath=utils.cloneArr(path);newPath.push(currRefRule);return validateNoLeftRecursion(topRule,currRefRule,errMsgProvider,newPath)});return errors.concat(utils.flatten(currRule))}function getFirstNoneTerminal(definition){var result=[];if(utils.isEmpty(definition))return result;var firstProd=utils.first(definition);if(firstProd instanceof\ngast_public_1.NonTerminal)result.push(firstProd.referencedRule);else if(firstProd instanceof gast_public_1.Alternative||firstProd instanceof gast_public_1.Option||firstProd instanceof gast_public_1.RepetitionMandatory||firstProd instanceof gast_public_1.RepetitionMandatoryWithSeparator||firstProd instanceof gast_public_1.RepetitionWithSeparator||firstProd instanceof gast_public_1.Repetition)result=result.concat(getFirstNoneTerminal(firstProd.definition));else if(firstProd instanceof gast_public_1.Alternation)result=\nutils.flatten(utils.map(firstProd.definition,function(currSubDef){return getFirstNoneTerminal(currSubDef.definition)}));else if(!(firstProd instanceof gast_public_1.Terminal))throw Error(\"non exhaustive match\");firstProd=gast_1.isOptionalProd(firstProd);var hasMore=1<definition.length;return firstProd&&hasMore?(definition=utils.drop(definition),result.concat(getFirstNoneTerminal(definition))):result}function validateEmptyOrAlternative(topLevelRule,errMsgProvider){var orCollector=new OrCollector;topLevelRule.accept(orCollector);\nreturn utils.reduce(orCollector.alternations,function(errors,currOr){var exceptLast=utils.dropRight(currOr.definition);exceptLast=utils.map(exceptLast,function(currAlternative,currAltIdx){currAlternative=interpreter_1.nextPossibleTokensAfter([currAlternative],[],null,1);return utils.isEmpty(currAlternative)?{message:errMsgProvider.buildEmptyAlternationError({topLevelRule,alternation:currOr,emptyChoiceIdx:currAltIdx}),type:parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,ruleName:topLevelRule.name,\noccurrence:currOr.idx,alternative:currAltIdx+1}:null});return errors.concat(utils.compact(exceptLast))},[])}function validateAmbiguousAlternationAlternatives(topLevelRule,globalMaxLookahead,errMsgProvider){var orCollector=new OrCollector;topLevelRule.accept(orCollector);orCollector=orCollector.alternations;orCollector=utils_1.reject(orCollector,function(currOr){return!0===currOr.ignoreAmbiguities});return utils.reduce(orCollector,function(result,currOr){var alternatives=lookahead_1.getLookaheadPathsForOr(currOr.idx,\ntopLevelRule,currOr.maxLookahead||globalMaxLookahead,currOr),altsAmbiguityErrors=checkAlternativesAmbiguities(alternatives,currOr,topLevelRule,errMsgProvider);currOr=checkPrefixAlternativesAmbiguities(alternatives,currOr,topLevelRule,errMsgProvider);return result.concat(altsAmbiguityErrors,currOr)},[])}function validateTooManyAlts(topLevelRule,errMsgProvider){var orCollector=new OrCollector;topLevelRule.accept(orCollector);return utils.reduce(orCollector.alternations,function(errors,currOr){255<currOr.definition.length&&\nerrors.push({message:errMsgProvider.buildTooManyAlternativesError({topLevelRule,alternation:currOr}),type:parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,ruleName:topLevelRule.name,occurrence:currOr.idx});return errors},[])}function validateSomeNonEmptyLookaheadPath(topLevelRules,maxLookahead,errMsgProvider){var errors=[];utils_1.forEach(topLevelRules,function(currTopRule){var collectorVisitor=new RepetionCollector;currTopRule.accept(collectorVisitor);utils_1.forEach(collectorVisitor.allProductions,\nfunction(currProd){var prodType=lookahead_1.getProdType(currProd);prodType=lookahead_1.getLookaheadPathsForOptionalProd(currProd.idx,currTopRule,prodType,currProd.maxLookahead||maxLookahead)[0];utils_1.isEmpty(utils_1.flatten(prodType))&&(currProd=errMsgProvider.buildEmptyRepetitionError({topLevelRule:currTopRule,repetition:currProd}),errors.push({message:currProd,type:parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,ruleName:currTopRule.name}))})});return errors}function checkAlternativesAmbiguities(alternatives,\nalternation,rule,errMsgProvider){var foundAmbiguousPaths=[],identicalAmbiguities=utils_1.reduce(alternatives,function(result,currAlt,currAltIdx){if(!0===alternation.definition[currAltIdx].ignoreAmbiguities)return result;utils_1.forEach(currAlt,function(currPath){var altsCurrPathAppearsIn=[currAltIdx];utils_1.forEach(alternatives,function(currOtherAlt,currOtherAltIdx){currAltIdx!==currOtherAltIdx&&lookahead_1.containsPath(currOtherAlt,currPath)&&!0!==alternation.definition[currOtherAltIdx].ignoreAmbiguities&&\naltsCurrPathAppearsIn.push(currOtherAltIdx)});1<altsCurrPathAppearsIn.length&&!lookahead_1.containsPath(foundAmbiguousPaths,currPath)&&(foundAmbiguousPaths.push(currPath),result.push({alts:altsCurrPathAppearsIn,path:currPath}))});return result},[]);return utils.map(identicalAmbiguities,function(currAmbDescriptor){var ambgIndices=utils_1.map(currAmbDescriptor.alts,function(currAltIdx){return currAltIdx+1});return{message:errMsgProvider.buildAlternationAmbiguityError({topLevelRule:rule,alternation,\nambiguityIndices:ambgIndices,prefixPath:currAmbDescriptor.path}),type:parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,ruleName:rule.name,occurrence:alternation.idx,alternatives:[currAmbDescriptor.alts]}})}function checkPrefixAlternativesAmbiguities(alternatives,alternation,rule,errMsgProvider){var errors=[],pathsAndIndices=utils_1.reduce(alternatives,function(result,currAlt,idx){currAlt=utils_1.map(currAlt,function(currPath){return{idx,path:currPath}});return result.concat(currAlt)},[]);utils_1.forEach(pathsAndIndices,\nfunction(currPathAndIdx){if(!0!==alternation.definition[currPathAndIdx.idx].ignoreAmbiguities){var targetIdx=currPathAndIdx.idx,targetPath=currPathAndIdx.path;currPathAndIdx=utils_1.findAll(pathsAndIndices,function(searchPathAndIdx){return!0!==alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities&&searchPathAndIdx.idx<targetIdx&&lookahead_1.isStrictPrefixOfPath(searchPathAndIdx.path,targetPath)});currPathAndIdx=utils_1.map(currPathAndIdx,function(currAmbPathAndIdx){var ambgIndices=[currAmbPathAndIdx.idx+\n1,targetIdx+1],occurrence=0===alternation.idx?\"\":alternation.idx;return{message:errMsgProvider.buildAlternationPrefixAmbiguityError({topLevelRule:rule,alternation,ambiguityIndices:ambgIndices,prefixPath:currAmbPathAndIdx.path}),type:parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,ruleName:rule.name,occurrence,alternatives:ambgIndices}});errors=errors.concat(currPathAndIdx)}});return errors}function checkTerminalAndNoneTerminalsNameSpace(topLevels,tokenTypes,errMsgProvider){var errors=[],\ntokenNames=utils_1.map(tokenTypes,function(currToken){return currToken.name});utils_1.forEach(topLevels,function(currRule){var currRuleName=currRule.name;utils_1.contains(tokenNames,currRuleName)&&(currRule=errMsgProvider.buildNamespaceConflictError(currRule),errors.push({message:currRule,type:parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,ruleName:currRuleName}))});return errors}var __extends=this&&this.__extends||function(){var extendStatics=function(d$jscomp$0,b$jscomp$0){extendStatics=\nObject.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)Object.prototype.hasOwnProperty.call(b,p)&&(d[p]=b[p])};return extendStatics(d$jscomp$0,b$jscomp$0)};return function(d,b){function __(){this.constructor=d}if(\"function\"!==typeof b&&null!==b)throw new TypeError(\"Class extends value \"+String(b)+\" is not a constructor or null\");extendStatics(d,b);d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,\n\"__esModule\",{value:!0});exports.checkPrefixAlternativesAmbiguities=exports.validateSomeNonEmptyLookaheadPath=exports.validateTooManyAlts=exports.RepetionCollector=exports.validateAmbiguousAlternationAlternatives=exports.validateEmptyOrAlternative=exports.getFirstNoneTerminal=exports.validateNoLeftRecursion=exports.validateRuleIsOverridden=exports.validateRuleDoesNotAlreadyExist=exports.OccurrenceValidationCollector=exports.identifyProductionForDuplicates=exports.validateGrammar=void 0;var utils=\nrequire(\"module$node_modules$$chevrotain$utils$lib$src$api\"),utils_1=require(\"module$node_modules$$chevrotain$utils$lib$src$api\"),parser_1=require(\"module$node_modules$chevrotain$lib$src$parse$parser$parser\"),gast_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast\"),lookahead_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$lookahead\"),interpreter_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$interpreter\"),gast_public_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_public\");\nglobal=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_visitor_public\");exports.validateGrammar=function(topLevels,globalMaxLookahead,tokenTypes,errMsgProvider,grammarName){var duplicateErrors=utils.map(topLevels,function(currTopLevel){return validateDuplicateProductions(currTopLevel,errMsgProvider)}),leftRecursionErrors=utils.map(topLevels,function(currTopRule){return validateNoLeftRecursion(currTopRule,currTopRule,errMsgProvider)}),emptyAltErrors=[],ambiguousAltsErrors=[],\nemptyRepetitionErrors=[];utils_1.every(leftRecursionErrors,utils_1.isEmpty)&&(emptyAltErrors=utils_1.map(topLevels,function(currTopRule){return validateEmptyOrAlternative(currTopRule,errMsgProvider)}),ambiguousAltsErrors=utils_1.map(topLevels,function(currTopRule){return validateAmbiguousAlternationAlternatives(currTopRule,globalMaxLookahead,errMsgProvider)}),emptyRepetitionErrors=validateSomeNonEmptyLookaheadPath(topLevels,globalMaxLookahead,errMsgProvider));tokenTypes=checkTerminalAndNoneTerminalsNameSpace(topLevels,\ntokenTypes,errMsgProvider);var tooManyAltsErrors=utils_1.map(topLevels,function(curRule){return validateTooManyAlts(curRule,errMsgProvider)}),duplicateRulesError=utils_1.map(topLevels,function(curRule){return validateRuleDoesNotAlreadyExist(curRule,topLevels,grammarName,errMsgProvider)});return utils.flatten(duplicateErrors.concat(emptyRepetitionErrors,leftRecursionErrors,emptyAltErrors,ambiguousAltsErrors,tokenTypes,tooManyAltsErrors,duplicateRulesError))};exports.identifyProductionForDuplicates=\nidentifyProductionForDuplicates;var OccurrenceValidationCollector=function(_super){function OccurrenceValidationCollector(){var _this=null!==_super&&_super.apply(this,arguments)||this;_this.allProductions=[];return _this}__extends(OccurrenceValidationCollector,_super);OccurrenceValidationCollector.prototype.visitNonTerminal=function(subrule){this.allProductions.push(subrule)};OccurrenceValidationCollector.prototype.visitOption=function(option){this.allProductions.push(option)};OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator=\nfunction(manySep){this.allProductions.push(manySep)};OccurrenceValidationCollector.prototype.visitRepetitionMandatory=function(atLeastOne){this.allProductions.push(atLeastOne)};OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator=function(atLeastOneSep){this.allProductions.push(atLeastOneSep)};OccurrenceValidationCollector.prototype.visitRepetition=function(many){this.allProductions.push(many)};OccurrenceValidationCollector.prototype.visitAlternation=function(or){this.allProductions.push(or)};\nOccurrenceValidationCollector.prototype.visitTerminal=function(terminal){this.allProductions.push(terminal)};return OccurrenceValidationCollector}(global.GAstVisitor);exports.OccurrenceValidationCollector=OccurrenceValidationCollector;exports.validateRuleDoesNotAlreadyExist=validateRuleDoesNotAlreadyExist;exports.validateRuleIsOverridden=function(ruleName,definedRulesNames,className){var errors=[];utils.contains(definedRulesNames,ruleName)||errors.push({message:\"Invalid rule override, rule: -\\x3e\"+\nruleName+\"\\x3c- cannot be overridden in the grammar: -\\x3e\"+className+\"\\x3c-as it is not defined in any of the super grammars \",type:parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,ruleName});return errors};exports.validateNoLeftRecursion=validateNoLeftRecursion;exports.getFirstNoneTerminal=getFirstNoneTerminal;var OrCollector=function(_super){function OrCollector(){var _this=null!==_super&&_super.apply(this,arguments)||this;_this.alternations=[];return _this}__extends(OrCollector,_super);\nOrCollector.prototype.visitAlternation=function(node){this.alternations.push(node)};return OrCollector}(global.GAstVisitor);exports.validateEmptyOrAlternative=validateEmptyOrAlternative;exports.validateAmbiguousAlternationAlternatives=validateAmbiguousAlternationAlternatives;var RepetionCollector=function(_super){function RepetionCollector(){var _this=null!==_super&&_super.apply(this,arguments)||this;_this.allProductions=[];return _this}__extends(RepetionCollector,_super);RepetionCollector.prototype.visitRepetitionWithSeparator=\nfunction(manySep){this.allProductions.push(manySep)};RepetionCollector.prototype.visitRepetitionMandatory=function(atLeastOne){this.allProductions.push(atLeastOne)};RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator=function(atLeastOneSep){this.allProductions.push(atLeastOneSep)};RepetionCollector.prototype.visitRepetition=function(many){this.allProductions.push(many)};return RepetionCollector}(global.GAstVisitor);exports.RepetionCollector=RepetionCollector;exports.validateTooManyAlts=\nvalidateTooManyAlts;exports.validateSomeNonEmptyLookaheadPath=validateSomeNonEmptyLookaheadPath;exports.checkPrefixAlternativesAmbiguities=checkPrefixAlternativesAmbiguities}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$parse$grammar$checks\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;\nvar utils = require(\"@chevrotain/utils\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar parser_1 = require(\"../parser/parser\");\nvar gast_1 = require(\"./gast/gast\");\nvar lookahead_1 = require(\"./lookahead\");\nvar interpreter_1 = require(\"./interpreter\");\nvar gast_public_1 = require(\"./gast/gast_public\");\nvar gast_visitor_public_1 = require(\"./gast/gast_visitor_public\");\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n    var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n        return validateDuplicateProductions(currTopLevel, errMsgProvider);\n    });\n    var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n    });\n    var emptyAltErrors = [];\n    var ambiguousAltsErrors = [];\n    var emptyRepetitionErrors = [];\n    // left recursion could cause infinite loops in the following validations.\n    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n    if (utils_1.every(leftRecursionErrors, utils_1.isEmpty)) {\n        emptyAltErrors = utils_1.map(topLevels, function (currTopRule) {\n            return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n        });\n        ambiguousAltsErrors = utils_1.map(topLevels, function (currTopRule) {\n            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n        });\n        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n    }\n    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    var tooManyAltsErrors = utils_1.map(topLevels, function (curRule) {\n        return validateTooManyAlts(curRule, errMsgProvider);\n    });\n    var duplicateRulesError = utils_1.map(topLevels, function (curRule) {\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n    });\n    return (utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError)));\n}\nexports.validateGrammar = validateGrammar;\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    var collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n    var duplicates = utils.pick(productionGroups, function (currGroup) {\n        return currGroup.length > 1;\n    });\n    var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n        var firstProd = utils.first(currDuplicates);\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        var dslName = gast_1.getProductionDslName(firstProd);\n        var defError = {\n            message: msg,\n            type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx\n        };\n        var param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n    return gast_1.getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof gast_public_1.Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof gast_public_1.NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nvar OccurrenceValidationCollector = /** @class */ (function (_super) {\n    __extends(OccurrenceValidationCollector, _super);\n    function OccurrenceValidationCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n        this.allProductions.push(subrule);\n    };\n    OccurrenceValidationCollector.prototype.visitOption = function (option) {\n        this.allProductions.push(option);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n        this.allProductions.push(or);\n    };\n    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n        this.allProductions.push(terminal);\n    };\n    return OccurrenceValidationCollector;\n}(gast_visitor_public_1.GAstVisitor));\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    var errors = [];\n    var occurrences = utils_1.reduce(allRules, function (result, curRule) {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className\n        });\n        errors.push({\n            message: errMsg,\n            type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name\n        });\n    }\n    return errors;\n}\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    var errors = [];\n    var errMsg;\n    if (!utils.contains(definedRulesNames, ruleName)) {\n        errMsg =\n            \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" +\n                \"as it is not defined in any of the super grammars \";\n        errors.push({\n            message: errMsg,\n            type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n    if (path === void 0) { path = []; }\n    var errors = [];\n    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (utils.isEmpty(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        var ruleName = topRule.name;\n        var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path\n                }),\n                type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n        var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n            var newPath = utils.cloneArr(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(utils.flatten(errorsFromNextSteps));\n    }\n}\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\nfunction getFirstNoneTerminal(definition) {\n    var result = [];\n    if (utils.isEmpty(definition)) {\n        return result;\n    }\n    var firstProd = utils.first(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof gast_public_1.NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof gast_public_1.Alternative ||\n        firstProd instanceof gast_public_1.Option ||\n        firstProd instanceof gast_public_1.RepetitionMandatory ||\n        firstProd instanceof gast_public_1.RepetitionMandatoryWithSeparator ||\n        firstProd instanceof gast_public_1.RepetitionWithSeparator ||\n        firstProd instanceof gast_public_1.Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof gast_public_1.Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n            return getFirstNoneTerminal(currSubDef.definition);\n        }));\n    }\n    else if (firstProd instanceof gast_public_1.Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    var isFirstOptional = gast_1.isOptionalProd(firstProd);\n    var hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        var rest = utils.drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\nvar OrCollector = /** @class */ (function (_super) {\n    __extends(OrCollector, _super);\n    function OrCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.alternations = [];\n        return _this;\n    }\n    OrCollector.prototype.visitAlternation = function (node) {\n        this.alternations.push(node);\n    };\n    return OrCollector;\n}(gast_visitor_public_1.GAstVisitor));\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = utils.reduce(ors, function (errors, currOr) {\n        var exceptLast = utils.dropRight(currOr.definition);\n        var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n            var possibleFirstInAlt = interpreter_1.nextPossibleTokensAfter([currAlternative], [], null, 1);\n            if (utils.isEmpty(possibleFirstInAlt)) {\n                return {\n                    message: errMsgProvider.buildEmptyAlternationError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                        emptyChoiceIdx: currAltIdx\n                    }),\n                    type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                    alternative: currAltIdx + 1\n                };\n            }\n            else {\n                return null;\n            }\n        });\n        return errors.concat(utils.compact(currErrors));\n    }, []);\n    return errors;\n}\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = utils_1.reject(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });\n    var errors = utils.reduce(ors, function (result, currOr) {\n        var currOccurrence = currOr.idx;\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        var alternatives = lookahead_1.getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n    }, []);\n    return errors;\n}\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\nvar RepetionCollector = /** @class */ (function (_super) {\n    __extends(RepetionCollector, _super);\n    function RepetionCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    RepetionCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    return RepetionCollector;\n}(gast_visitor_public_1.GAstVisitor));\nexports.RepetionCollector = RepetionCollector;\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = utils.reduce(ors, function (errors, currOr) {\n        if (currOr.definition.length > 255) {\n            errors.push({\n                message: errMsgProvider.buildTooManyAlternativesError({\n                    topLevelRule: topLevelRule,\n                    alternation: currOr\n                }),\n                type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n                ruleName: topLevelRule.name,\n                occurrence: currOr.idx\n            });\n        }\n        return errors;\n    }, []);\n    return errors;\n}\nexports.validateTooManyAlts = validateTooManyAlts;\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    var errors = [];\n    utils_1.forEach(topLevelRules, function (currTopRule) {\n        var collectorVisitor = new RepetionCollector();\n        currTopRule.accept(collectorVisitor);\n        var allRuleProductions = collectorVisitor.allProductions;\n        utils_1.forEach(allRuleProductions, function (currProd) {\n            var prodType = lookahead_1.getProdType(currProd);\n            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            var currOccurrence = currProd.idx;\n            var paths = lookahead_1.getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            var pathsInsideProduction = paths[0];\n            if (utils_1.isEmpty(utils_1.flatten(pathsInsideProduction))) {\n                var errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd\n                });\n                errors.push({\n                    message: errMsg,\n                    type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name\n                });\n            }\n        });\n    });\n    return errors;\n}\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var foundAmbiguousPaths = [];\n    var identicalAmbiguities = utils_1.reduce(alternatives, function (result, currAlt, currAltIdx) {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        utils_1.forEach(currAlt, function (currPath) {\n            var altsCurrPathAppearsIn = [currAltIdx];\n            utils_1.forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n                if (currAltIdx !== currOtherAltIdx &&\n                    lookahead_1.containsPath(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !lookahead_1.containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath\n                });\n            }\n        });\n        return result;\n    }, []);\n    var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n        var ambgIndices = utils_1.map(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path\n        });\n        return {\n            message: currMessage,\n            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: [currAmbDescriptor.alts]\n        };\n    });\n    return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var errors = [];\n    // flatten\n    var pathsAndIndices = utils_1.reduce(alternatives, function (result, currAlt, idx) {\n        var currPathsAndIdx = utils_1.map(currAlt, function (currPath) {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    utils_1.forEach(pathsAndIndices, function (currPathAndIdx) {\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return;\n        }\n        var targetIdx = currPathAndIdx.idx;\n        var targetPath = currPathAndIdx.path;\n        var prefixAmbiguitiesPathsAndIndices = utils_1.findAll(pathsAndIndices, function (searchPathAndIdx) {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                lookahead_1.isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        var currPathPrefixErrors = utils_1.map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path\n            });\n            return {\n                message: message,\n                type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices\n            };\n        });\n        errors = errors.concat(currPathPrefixErrors);\n    });\n    return errors;\n}\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    var errors = [];\n    var tokenNames = utils_1.map(tokenTypes, function (currToken) { return currToken.name; });\n    utils_1.forEach(topLevels, function (currRule) {\n        var currRuleName = currRule.name;\n        if (utils_1.contains(tokenNames, currRuleName)) {\n            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$chevrotain$utils$lib$src$api","~$module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast","~$module$node_modules$chevrotain$lib$src$parse$grammar$interpreter","~$shadow.js","~$module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_public","~$module$node_modules$chevrotain$lib$src$parse$parser$parser","~$module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_visitor_public","~$module$node_modules$chevrotain$lib$src$parse$grammar$lookahead"]],"~:properties",["^5",["message","alts","dslName","visitRepetition","validateRuleIsOverridden","validateSomeNonEmptyLookaheadPath","parameter","ruleName","checkPrefixAlternativesAmbiguities","prototype","ambiguityIndices","leftRecursionPath","getFirstNoneTerminal","prefixPath","alternatives","visitRepetitionMandatoryWithSeparator","__esModule","path","validateRuleDoesNotAlreadyExist","identifyProductionForDuplicates","value","visitNonTerminal","validateAmbiguousAlternationAlternatives","visitTerminal","visitAlternation","RepetionCollector","visitOption","occurrence","type","visitRepetitionWithSeparator","__proto__","alternations","validateGrammar","emptyChoiceIdx","validateTooManyAlts","repetition","idx","topLevelRule","allProductions","OccurrenceValidationCollector","visitRepetitionMandatory","validateEmptyOrAlternative","alternative","alternation","validateNoLeftRecursion","grammarName","constructor"]],"~:compiled-at",1630917515697,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$parse$grammar$checks.js\",\n\"lineCount\":31,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/chevrotain/lib/src/parse/grammar/checks.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$parse$grammar$checks\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        if (typeof b !== \\\"function\\\" && b !== null)\\n            throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;\\nvar utils = require(\\\"@chevrotain/utils\\\");\\nvar utils_1 = require(\\\"@chevrotain/utils\\\");\\nvar parser_1 = require(\\\"../parser/parser\\\");\\nvar gast_1 = require(\\\"./gast/gast\\\");\\nvar lookahead_1 = require(\\\"./lookahead\\\");\\nvar interpreter_1 = require(\\\"./interpreter\\\");\\nvar gast_public_1 = require(\\\"./gast/gast_public\\\");\\nvar gast_visitor_public_1 = require(\\\"./gast/gast_visitor_public\\\");\\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\\n    var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\\n        return validateDuplicateProductions(currTopLevel, errMsgProvider);\\n    });\\n    var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\\n        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\\n    });\\n    var emptyAltErrors = [];\\n    var ambiguousAltsErrors = [];\\n    var emptyRepetitionErrors = [];\\n    // left recursion could cause infinite loops in the following validations.\\n    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\\n    if (utils_1.every(leftRecursionErrors, utils_1.isEmpty)) {\\n        emptyAltErrors = utils_1.map(topLevels, function (currTopRule) {\\n            return validateEmptyOrAlternative(currTopRule, errMsgProvider);\\n        });\\n        ambiguousAltsErrors = utils_1.map(topLevels, function (currTopRule) {\\n            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\\n        });\\n        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\\n    }\\n    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\\n    var tooManyAltsErrors = utils_1.map(topLevels, function (curRule) {\\n        return validateTooManyAlts(curRule, errMsgProvider);\\n    });\\n    var duplicateRulesError = utils_1.map(topLevels, function (curRule) {\\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\\n    });\\n    return (utils.flatten(duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError)));\\n}\\nexports.validateGrammar = validateGrammar;\\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\\n    var collectorVisitor = new OccurrenceValidationCollector();\\n    topLevelRule.accept(collectorVisitor);\\n    var allRuleProductions = collectorVisitor.allProductions;\\n    var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\\n    var duplicates = utils.pick(productionGroups, function (currGroup) {\\n        return currGroup.length > 1;\\n    });\\n    var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\\n        var firstProd = utils.first(currDuplicates);\\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\\n        var dslName = gast_1.getProductionDslName(firstProd);\\n        var defError = {\\n            message: msg,\\n            type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\\n            ruleName: topLevelRule.name,\\n            dslName: dslName,\\n            occurrence: firstProd.idx\\n        };\\n        var param = getExtraProductionArgument(firstProd);\\n        if (param) {\\n            defError.parameter = param;\\n        }\\n        return defError;\\n    });\\n    return errors;\\n}\\nfunction identifyProductionForDuplicates(prod) {\\n    return gast_1.getProductionDslName(prod) + \\\"_#_\\\" + prod.idx + \\\"_#_\\\" + getExtraProductionArgument(prod);\\n}\\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\\nfunction getExtraProductionArgument(prod) {\\n    if (prod instanceof gast_public_1.Terminal) {\\n        return prod.terminalType.name;\\n    }\\n    else if (prod instanceof gast_public_1.NonTerminal) {\\n        return prod.nonTerminalName;\\n    }\\n    else {\\n        return \\\"\\\";\\n    }\\n}\\nvar OccurrenceValidationCollector = /** @class */ (function (_super) {\\n    __extends(OccurrenceValidationCollector, _super);\\n    function OccurrenceValidationCollector() {\\n        var _this = _super !== null && _super.apply(this, arguments) || this;\\n        _this.allProductions = [];\\n        return _this;\\n    }\\n    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\\n        this.allProductions.push(subrule);\\n    };\\n    OccurrenceValidationCollector.prototype.visitOption = function (option) {\\n        this.allProductions.push(option);\\n    };\\n    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\\n        this.allProductions.push(manySep);\\n    };\\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\\n        this.allProductions.push(atLeastOne);\\n    };\\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\\n        this.allProductions.push(atLeastOneSep);\\n    };\\n    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\\n        this.allProductions.push(many);\\n    };\\n    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\\n        this.allProductions.push(or);\\n    };\\n    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\\n        this.allProductions.push(terminal);\\n    };\\n    return OccurrenceValidationCollector;\\n}(gast_visitor_public_1.GAstVisitor));\\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\\n    var errors = [];\\n    var occurrences = utils_1.reduce(allRules, function (result, curRule) {\\n        if (curRule.name === rule.name) {\\n            return result + 1;\\n        }\\n        return result;\\n    }, 0);\\n    if (occurrences > 1) {\\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\\n            topLevelRule: rule,\\n            grammarName: className\\n        });\\n        errors.push({\\n            message: errMsg,\\n            type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\\n            ruleName: rule.name\\n        });\\n    }\\n    return errors;\\n}\\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;\\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\\n// The grammar structure, only at runtime.\\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\\n    var errors = [];\\n    var errMsg;\\n    if (!utils.contains(definedRulesNames, ruleName)) {\\n        errMsg =\\n            \\\"Invalid rule override, rule: ->\\\" + ruleName + \\\"<- cannot be overridden in the grammar: ->\\\" + className + \\\"<-\\\" +\\n                \\\"as it is not defined in any of the super grammars \\\";\\n        errors.push({\\n            message: errMsg,\\n            type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\\n            ruleName: ruleName\\n        });\\n    }\\n    return errors;\\n}\\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\\n    if (path === void 0) { path = []; }\\n    var errors = [];\\n    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\\n    if (utils.isEmpty(nextNonTerminals)) {\\n        return [];\\n    }\\n    else {\\n        var ruleName = topRule.name;\\n        var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\\n        if (foundLeftRecursion) {\\n            errors.push({\\n                message: errMsgProvider.buildLeftRecursionError({\\n                    topLevelRule: topRule,\\n                    leftRecursionPath: path\\n                }),\\n                type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\\n                ruleName: ruleName\\n            });\\n        }\\n        // we are only looking for cyclic paths leading back to the specific topRule\\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\\n        var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\\n        var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\\n            var newPath = utils.cloneArr(path);\\n            newPath.push(currRefRule);\\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\\n        });\\n        return errors.concat(utils.flatten(errorsFromNextSteps));\\n    }\\n}\\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\\nfunction getFirstNoneTerminal(definition) {\\n    var result = [];\\n    if (utils.isEmpty(definition)) {\\n        return result;\\n    }\\n    var firstProd = utils.first(definition);\\n    /* istanbul ignore else */\\n    if (firstProd instanceof gast_public_1.NonTerminal) {\\n        result.push(firstProd.referencedRule);\\n    }\\n    else if (firstProd instanceof gast_public_1.Alternative ||\\n        firstProd instanceof gast_public_1.Option ||\\n        firstProd instanceof gast_public_1.RepetitionMandatory ||\\n        firstProd instanceof gast_public_1.RepetitionMandatoryWithSeparator ||\\n        firstProd instanceof gast_public_1.RepetitionWithSeparator ||\\n        firstProd instanceof gast_public_1.Repetition) {\\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\\n    }\\n    else if (firstProd instanceof gast_public_1.Alternation) {\\n        // each sub definition in alternation is a FLAT\\n        result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\\n            return getFirstNoneTerminal(currSubDef.definition);\\n        }));\\n    }\\n    else if (firstProd instanceof gast_public_1.Terminal) {\\n        // nothing to see, move along\\n    }\\n    else {\\n        throw Error(\\\"non exhaustive match\\\");\\n    }\\n    var isFirstOptional = gast_1.isOptionalProd(firstProd);\\n    var hasMore = definition.length > 1;\\n    if (isFirstOptional && hasMore) {\\n        var rest = utils.drop(definition);\\n        return result.concat(getFirstNoneTerminal(rest));\\n    }\\n    else {\\n        return result;\\n    }\\n}\\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\\nvar OrCollector = /** @class */ (function (_super) {\\n    __extends(OrCollector, _super);\\n    function OrCollector() {\\n        var _this = _super !== null && _super.apply(this, arguments) || this;\\n        _this.alternations = [];\\n        return _this;\\n    }\\n    OrCollector.prototype.visitAlternation = function (node) {\\n        this.alternations.push(node);\\n    };\\n    return OrCollector;\\n}(gast_visitor_public_1.GAstVisitor));\\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\\n    var orCollector = new OrCollector();\\n    topLevelRule.accept(orCollector);\\n    var ors = orCollector.alternations;\\n    var errors = utils.reduce(ors, function (errors, currOr) {\\n        var exceptLast = utils.dropRight(currOr.definition);\\n        var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\\n            var possibleFirstInAlt = interpreter_1.nextPossibleTokensAfter([currAlternative], [], null, 1);\\n            if (utils.isEmpty(possibleFirstInAlt)) {\\n                return {\\n                    message: errMsgProvider.buildEmptyAlternationError({\\n                        topLevelRule: topLevelRule,\\n                        alternation: currOr,\\n                        emptyChoiceIdx: currAltIdx\\n                    }),\\n                    type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\\n                    ruleName: topLevelRule.name,\\n                    occurrence: currOr.idx,\\n                    alternative: currAltIdx + 1\\n                };\\n            }\\n            else {\\n                return null;\\n            }\\n        });\\n        return errors.concat(utils.compact(currErrors));\\n    }, []);\\n    return errors;\\n}\\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\\n    var orCollector = new OrCollector();\\n    topLevelRule.accept(orCollector);\\n    var ors = orCollector.alternations;\\n    // New Handling of ignoring ambiguities\\n    // - https://github.com/chevrotain/chevrotain/issues/869\\n    ors = utils_1.reject(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });\\n    var errors = utils.reduce(ors, function (result, currOr) {\\n        var currOccurrence = currOr.idx;\\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\\n        var alternatives = lookahead_1.getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\\n        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\\n    }, []);\\n    return errors;\\n}\\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\\nvar RepetionCollector = /** @class */ (function (_super) {\\n    __extends(RepetionCollector, _super);\\n    function RepetionCollector() {\\n        var _this = _super !== null && _super.apply(this, arguments) || this;\\n        _this.allProductions = [];\\n        return _this;\\n    }\\n    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\\n        this.allProductions.push(manySep);\\n    };\\n    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\\n        this.allProductions.push(atLeastOne);\\n    };\\n    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\\n        this.allProductions.push(atLeastOneSep);\\n    };\\n    RepetionCollector.prototype.visitRepetition = function (many) {\\n        this.allProductions.push(many);\\n    };\\n    return RepetionCollector;\\n}(gast_visitor_public_1.GAstVisitor));\\nexports.RepetionCollector = RepetionCollector;\\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\\n    var orCollector = new OrCollector();\\n    topLevelRule.accept(orCollector);\\n    var ors = orCollector.alternations;\\n    var errors = utils.reduce(ors, function (errors, currOr) {\\n        if (currOr.definition.length > 255) {\\n            errors.push({\\n                message: errMsgProvider.buildTooManyAlternativesError({\\n                    topLevelRule: topLevelRule,\\n                    alternation: currOr\\n                }),\\n                type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\\n                ruleName: topLevelRule.name,\\n                occurrence: currOr.idx\\n            });\\n        }\\n        return errors;\\n    }, []);\\n    return errors;\\n}\\nexports.validateTooManyAlts = validateTooManyAlts;\\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\\n    var errors = [];\\n    utils_1.forEach(topLevelRules, function (currTopRule) {\\n        var collectorVisitor = new RepetionCollector();\\n        currTopRule.accept(collectorVisitor);\\n        var allRuleProductions = collectorVisitor.allProductions;\\n        utils_1.forEach(allRuleProductions, function (currProd) {\\n            var prodType = lookahead_1.getProdType(currProd);\\n            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\\n            var currOccurrence = currProd.idx;\\n            var paths = lookahead_1.getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\\n            var pathsInsideProduction = paths[0];\\n            if (utils_1.isEmpty(utils_1.flatten(pathsInsideProduction))) {\\n                var errMsg = errMsgProvider.buildEmptyRepetitionError({\\n                    topLevelRule: currTopRule,\\n                    repetition: currProd\\n                });\\n                errors.push({\\n                    message: errMsg,\\n                    type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\\n                    ruleName: currTopRule.name\\n                });\\n            }\\n        });\\n    });\\n    return errors;\\n}\\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\\n    var foundAmbiguousPaths = [];\\n    var identicalAmbiguities = utils_1.reduce(alternatives, function (result, currAlt, currAltIdx) {\\n        // ignore (skip) ambiguities with this alternative\\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\\n            return result;\\n        }\\n        utils_1.forEach(currAlt, function (currPath) {\\n            var altsCurrPathAppearsIn = [currAltIdx];\\n            utils_1.forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\\n                if (currAltIdx !== currOtherAltIdx &&\\n                    lookahead_1.containsPath(currOtherAlt, currPath) &&\\n                    // ignore (skip) ambiguities with this \\\"other\\\" alternative\\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\\n                }\\n            });\\n            if (altsCurrPathAppearsIn.length > 1 &&\\n                !lookahead_1.containsPath(foundAmbiguousPaths, currPath)) {\\n                foundAmbiguousPaths.push(currPath);\\n                result.push({\\n                    alts: altsCurrPathAppearsIn,\\n                    path: currPath\\n                });\\n            }\\n        });\\n        return result;\\n    }, []);\\n    var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\\n        var ambgIndices = utils_1.map(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });\\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\\n            topLevelRule: rule,\\n            alternation: alternation,\\n            ambiguityIndices: ambgIndices,\\n            prefixPath: currAmbDescriptor.path\\n        });\\n        return {\\n            message: currMessage,\\n            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\\n            ruleName: rule.name,\\n            occurrence: alternation.idx,\\n            alternatives: [currAmbDescriptor.alts]\\n        };\\n    });\\n    return currErrors;\\n}\\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\\n    var errors = [];\\n    // flatten\\n    var pathsAndIndices = utils_1.reduce(alternatives, function (result, currAlt, idx) {\\n        var currPathsAndIdx = utils_1.map(currAlt, function (currPath) {\\n            return { idx: idx, path: currPath };\\n        });\\n        return result.concat(currPathsAndIdx);\\n    }, []);\\n    utils_1.forEach(pathsAndIndices, function (currPathAndIdx) {\\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\\n        // ignore (skip) ambiguities with this alternative\\n        if (alternativeGast.ignoreAmbiguities === true) {\\n            return;\\n        }\\n        var targetIdx = currPathAndIdx.idx;\\n        var targetPath = currPathAndIdx.path;\\n        var prefixAmbiguitiesPathsAndIndices = utils_1.findAll(pathsAndIndices, function (searchPathAndIdx) {\\n            // prefix ambiguity can only be created from lower idx (higher priority) path\\n            return (\\n            // ignore (skip) ambiguities with this \\\"other\\\" alternative\\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\\n                true &&\\n                searchPathAndIdx.idx < targetIdx &&\\n                // checking for strict prefix because identical lookaheads\\n                // will be be detected using a different validation.\\n                lookahead_1.isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\\n        });\\n        var currPathPrefixErrors = utils_1.map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\\n            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\\n            var occurrence = alternation.idx === 0 ? \\\"\\\" : alternation.idx;\\n            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\\n                topLevelRule: rule,\\n                alternation: alternation,\\n                ambiguityIndices: ambgIndices,\\n                prefixPath: currAmbPathAndIdx.path\\n            });\\n            return {\\n                message: message,\\n                type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\\n                ruleName: rule.name,\\n                occurrence: occurrence,\\n                alternatives: ambgIndices\\n            };\\n        });\\n        errors = errors.concat(currPathPrefixErrors);\\n    });\\n    return errors;\\n}\\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\\n    var errors = [];\\n    var tokenNames = utils_1.map(tokenTypes, function (currToken) { return currToken.name; });\\n    utils_1.forEach(topLevels, function (currRule) {\\n        var currRuleName = currRule.name;\\n        if (utils_1.contains(tokenNames, currRuleName)) {\\n            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\\n            errors.push({\\n                message: errMsg,\\n                type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\\n                ruleName: currRuleName\\n            });\\n        }\\n    });\\n    return errors;\\n}\\n//# sourceMappingURL=checks.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"validateDuplicateProductions\",\"topLevelRule\",\"errMsgProvider\",\"collectorVisitor\",\"OccurrenceValidationCollector\",\"accept\",\"productionGroups\",\"utils\",\"groupBy\",\"allProductions\",\"identifyProductionForDuplicates\",\"duplicates\",\"pick\",\"currGroup\",\"length\",\"map\",\"errors\",\"values\",\"currDuplicates\",\"firstProd\",\"first\",\"msg\",\"buildDuplicateFoundError\",\"dslName\",\"gast_1\",\"getProductionDslName\",\"defError\",\"message\",\"type\",\"parser_1\",\"ParserDefinitionErrorType\",\"DUPLICATE_PRODUCTIONS\",\"ruleName\",\"name\",\"occurrence\",\"idx\",\"param\",\"getExtraProductionArgument\",\"parameter\",\"prod\",\"gast_public_1\",\"Terminal\",\"terminalType\",\"NonTerminal\",\"nonTerminalName\",\"validateRuleDoesNotAlreadyExist\",\"rule\",\"allRules\",\"className\",\"utils_1\",\"reduce\",\"occurrences\",\"result\",\"curRule\",\"errMsg\",\"buildDuplicateRuleNameError\",\"grammarName\",\"push\",\"DUPLICATE_RULE_NAME\",\"validateNoLeftRecursion\",\"topRule\",\"currRule\",\"path\",\"nextNonTerminals\",\"getFirstNoneTerminal\",\"definition\",\"isEmpty\",\"contains\",\"foundLeftRecursion\",\"buildLeftRecursionError\",\"leftRecursionPath\",\"LEFT_RECURSION\",\"validNextSteps\",\"difference\",\"concat\",\"errorsFromNextSteps\",\"currRefRule\",\"newPath\",\"cloneArr\",\"flatten\",\"referencedRule\",\"Alternative\",\"Option\",\"RepetitionMandatory\",\"RepetitionMandatoryWithSeparator\",\"RepetitionWithSeparator\",\"Repetition\",\"Alternation\",\"currSubDef\",\"Error\",\"isFirstOptional\",\"isOptionalProd\",\"hasMore\",\"rest\",\"drop\",\"validateEmptyOrAlternative\",\"orCollector\",\"OrCollector\",\"alternations\",\"currOr\",\"exceptLast\",\"dropRight\",\"currErrors\",\"currAlternative\",\"currAltIdx\",\"possibleFirstInAlt\",\"interpreter_1\",\"nextPossibleTokensAfter\",\"buildEmptyAlternationError\",\"alternation\",\"emptyChoiceIdx\",\"NONE_LAST_EMPTY_ALT\",\"alternative\",\"compact\",\"validateAmbiguousAlternationAlternatives\",\"globalMaxLookahead\",\"ors\",\"reject\",\"ignoreAmbiguities\",\"alternatives\",\"lookahead_1\",\"getLookaheadPathsForOr\",\"maxLookahead\",\"altsAmbiguityErrors\",\"checkAlternativesAmbiguities\",\"altsPrefixAmbiguityErrors\",\"checkPrefixAlternativesAmbiguities\",\"validateTooManyAlts\",\"buildTooManyAlternativesError\",\"TOO_MANY_ALTS\",\"validateSomeNonEmptyLookaheadPath\",\"topLevelRules\",\"forEach\",\"currTopRule\",\"RepetionCollector\",\"currProd\",\"prodType\",\"getProdType\",\"pathsInsideProduction\",\"getLookaheadPathsForOptionalProd\",\"paths\",\"buildEmptyRepetitionError\",\"repetition\",\"NO_NON_EMPTY_LOOKAHEAD\",\"foundAmbiguousPaths\",\"identicalAmbiguities\",\"currAlt\",\"currPath\",\"altsCurrPathAppearsIn\",\"currOtherAlt\",\"currOtherAltIdx\",\"containsPath\",\"alts\",\"currAmbDescriptor\",\"ambgIndices\",\"buildAlternationAmbiguityError\",\"currMessage\",\"ambiguityIndices\",\"prefixPath\",\"AMBIGUOUS_ALTS\",\"pathsAndIndices\",\"currPathsAndIdx\",\"currPathAndIdx\",\"alternativeGast\",\"targetIdx\",\"targetPath\",\"prefixAmbiguitiesPathsAndIndices\",\"findAll\",\"searchPathAndIdx\",\"isStrictPrefixOfPath\",\"currPathPrefixErrors\",\"currAmbPathAndIdx\",\"buildAlternationPrefixAmbiguityError\",\"AMBIGUOUS_PREFIX_ALTS\",\"checkTerminalAndNoneTerminalsNameSpace\",\"topLevels\",\"tokenTypes\",\"tokenNames\",\"currToken\",\"currRuleName\",\"buildNamespaceConflictError\",\"CONFLICT_TOKENS_RULES_NAMESPACE\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"Object\",\"setPrototypeOf\",\"__proto__\",\"Array\",\"p\",\"prototype\",\"hasOwnProperty\",\"call\",\"__\",\"constructor\",\"TypeError\",\"String\",\"create\",\"defineProperty\",\"value\",\"validateRuleIsOverridden\",\"validateGrammar\",\"gast_visitor_public_1\",\"duplicateErrors\",\"currTopLevel\",\"leftRecursionErrors\",\"emptyAltErrors\",\"ambiguousAltsErrors\",\"emptyRepetitionErrors\",\"every\",\"termsNamespaceConflictErrors\",\"tooManyAltsErrors\",\"duplicateRulesError\",\"_super\",\"_this\",\"apply\",\"arguments\",\"visitNonTerminal\",\"OccurrenceValidationCollector.prototype.visitNonTerminal\",\"subrule\",\"visitOption\",\"OccurrenceValidationCollector.prototype.visitOption\",\"option\",\"visitRepetitionWithSeparator\",\"OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator\",\"manySep\",\"visitRepetitionMandatory\",\"OccurrenceValidationCollector.prototype.visitRepetitionMandatory\",\"atLeastOne\",\"visitRepetitionMandatoryWithSeparator\",\"OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator\",\"atLeastOneSep\",\"visitRepetition\",\"OccurrenceValidationCollector.prototype.visitRepetition\",\"many\",\"visitAlternation\",\"OccurrenceValidationCollector.prototype.visitAlternation\",\"or\",\"visitTerminal\",\"OccurrenceValidationCollector.prototype.visitTerminal\",\"terminal\",\"GAstVisitor\",\"definedRulesNames\",\"INVALID_RULE_OVERRIDE\",\"OrCollector.prototype.visitAlternation\",\"node\",\"RepetionCollector.prototype.visitRepetitionWithSeparator\",\"RepetionCollector.prototype.visitRepetitionMandatory\",\"RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator\",\"RepetionCollector.prototype.visitRepetition\"]\n}\n"]