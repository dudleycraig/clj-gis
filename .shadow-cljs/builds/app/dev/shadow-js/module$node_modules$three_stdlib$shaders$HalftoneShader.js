["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/HalftoneShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$HalftoneShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.HalftoneShader=void 0;exports.HalftoneShader={uniforms:{tDiffuse:{value:null},shape:{value:1},radius:{value:4},rotateR:{value:Math.PI/12},rotateG:{value:Math.PI/12*2},rotateB:{value:Math.PI/12*3},scatter:{value:0},width:{value:1},height:{value:1},blending:{value:1},blendingMode:{value:1},greyscale:{value:!1},disable:{value:!1}},\nvertexShader:\"varying vec2 vUV;\\nvoid main() {\\n\\tvUV \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\",fragmentShader:\"#define SQRT2_MINUS_ONE 0.41421356\\n#define SQRT2_HALF_MINUS_ONE 0.20710678\\n#define PI2 6.28318531\\n#define SHAPE_DOT 1\\n#define SHAPE_ELLIPSE 2\\n#define SHAPE_LINE 3\\n#define SHAPE_SQUARE 4\\n#define BLENDING_LINEAR 1\\n#define BLENDING_MULTIPLY 2\\n#define BLENDING_ADD 3\\n#define BLENDING_LIGHTER 4\\n#define BLENDING_DARKER 5\\nuniform sampler2D tDiffuse;\\nuniform float radius;\\nuniform float rotateR;\\nuniform float rotateG;\\nuniform float rotateB;\\nuniform float scatter;\\nuniform float width;\\nuniform float height;\\nuniform int shape;\\nuniform bool disable;\\nuniform float blending;\\nuniform int blendingMode;\\nvarying vec2 vUV;\\nuniform bool greyscale;\\nconst int samples \\x3d 8;\\nfloat blend( float a, float b, float t ) {\\n\\treturn a * ( 1.0 - t ) + b * t;\\n}\\nfloat hypot( float x, float y ) {\\n\\treturn sqrt( x * x + y * y );\\n}\\nfloat rand( vec2 seed ){\\nreturn fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\\n}\\nfloat distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {\\n\\tfloat dist \\x3d hypot( coord.x - p.x, coord.y - p.y );\\n\\tfloat rad \\x3d channel;\\n\\tif ( shape \\x3d\\x3d SHAPE_DOT ) {\\n\\t\\trad \\x3d pow( abs( rad ), 1.125 ) * rad_max;\\n\\t} else if ( shape \\x3d\\x3d SHAPE_ELLIPSE ) {\\n\\t\\trad \\x3d pow( abs( rad ), 1.125 ) * rad_max;\\n\\t\\tif ( dist !\\x3d 0.0 ) {\\n\\t\\t\\tfloat dot_p \\x3d abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );\\n\\t\\t\\tdist \\x3d ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;\\n\\t\\t}\\n\\t} else if ( shape \\x3d\\x3d SHAPE_LINE ) {\\n\\t\\trad \\x3d pow( abs( rad ), 1.5) * rad_max;\\n\\t\\tfloat dot_p \\x3d ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;\\n\\t\\tdist \\x3d hypot( normal.x * dot_p, normal.y * dot_p );\\n\\t} else if ( shape \\x3d\\x3d SHAPE_SQUARE ) {\\n\\t\\tfloat theta \\x3d atan( p.y - coord.y, p.x - coord.x ) - angle;\\n\\t\\tfloat sin_t \\x3d abs( sin( theta ) );\\n\\t\\tfloat cos_t \\x3d abs( cos( theta ) );\\n\\t\\trad \\x3d pow( abs( rad ), 1.4 );\\n\\t\\trad \\x3d rad_max * ( rad + ( ( sin_t \\x3e cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );\\n\\t}\\n\\treturn rad - dist;\\n}\\nstruct Cell {\\n\\tvec2 normal;\\n\\tvec2 p1;\\n\\tvec2 p2;\\n\\tvec2 p3;\\n\\tvec2 p4;\\n\\tfloat samp2;\\n\\tfloat samp1;\\n\\tfloat samp3;\\n\\tfloat samp4;\\n};\\nvec4 getSample( vec2 point ) {\\n\\tvec4 tex \\x3d texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );\\n\\tfloat base \\x3d rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;\\n\\tfloat step \\x3d PI2 / float( samples );\\n\\tfloat dist \\x3d radius * 0.66;\\n\\tfor ( int i \\x3d 0; i \\x3c samples; ++i ) {\\n\\t\\tfloat r \\x3d base + step * float( i );\\n\\t\\tvec2 coord \\x3d point + vec2( cos( r ) * dist, sin( r ) * dist );\\n\\t\\ttex +\\x3d texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );\\n\\t}\\n\\ttex /\\x3d float( samples ) + 1.0;\\n\\treturn tex;\\n}\\nfloat getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {\\n\\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;\\n\\tif ( channel \\x3d\\x3d 0 ) {\\n\\t\\tc.samp1 \\x3d getSample( c.p1 ).r;\\n\\t\\tc.samp2 \\x3d getSample( c.p2 ).r;\\n\\t\\tc.samp3 \\x3d getSample( c.p3 ).r;\\n\\t\\tc.samp4 \\x3d getSample( c.p4 ).r;\\n\\t} else if (channel \\x3d\\x3d 1) {\\n\\t\\tc.samp1 \\x3d getSample( c.p1 ).g;\\n\\t\\tc.samp2 \\x3d getSample( c.p2 ).g;\\n\\t\\tc.samp3 \\x3d getSample( c.p3 ).g;\\n\\t\\tc.samp4 \\x3d getSample( c.p4 ).g;\\n\\t} else {\\n\\t\\tc.samp1 \\x3d getSample( c.p1 ).b;\\n\\t\\tc.samp3 \\x3d getSample( c.p3 ).b;\\n\\t\\tc.samp2 \\x3d getSample( c.p2 ).b;\\n\\t\\tc.samp4 \\x3d getSample( c.p4 ).b;\\n\\t}\\n\\tdist_c_1 \\x3d distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );\\n\\tdist_c_2 \\x3d distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );\\n\\tdist_c_3 \\x3d distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );\\n\\tdist_c_4 \\x3d distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );\\n\\tres \\x3d ( dist_c_1 \\x3e 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;\\n\\tres +\\x3d ( dist_c_2 \\x3e 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;\\n\\tres +\\x3d ( dist_c_3 \\x3e 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;\\n\\tres +\\x3d ( dist_c_4 \\x3e 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;\\n\\tres \\x3d clamp( res, 0.0, 1.0 );\\n\\treturn res;\\n}\\nCell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {\\n\\tCell c;\\n\\tvec2 n \\x3d vec2( cos( grid_angle ), sin( grid_angle ) );\\n\\tfloat threshold \\x3d step * 0.5;\\n\\tfloat dot_normal \\x3d n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );\\n\\tfloat dot_line \\x3d -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );\\n\\tvec2 offset \\x3d vec2( n.x * dot_normal, n.y * dot_normal );\\n\\tfloat offset_normal \\x3d mod( hypot( offset.x, offset.y ), step );\\n\\tfloat normal_dir \\x3d ( dot_normal \\x3c 0.0 ) ? 1.0 : -1.0;\\n\\tfloat normal_scale \\x3d ( ( offset_normal \\x3c threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;\\n\\tfloat offset_line \\x3d mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );\\n\\tfloat line_dir \\x3d ( dot_line \\x3c 0.0 ) ? 1.0 : -1.0;\\n\\tfloat line_scale \\x3d ( ( offset_line \\x3c threshold ) ? -offset_line : step - offset_line ) * line_dir;\\n\\tc.normal \\x3d n;\\n\\tc.p1.x \\x3d p.x - n.x * normal_scale + n.y * line_scale;\\n\\tc.p1.y \\x3d p.y - n.y * normal_scale - n.x * line_scale;\\n\\tif ( scatter !\\x3d 0.0 ) {\\n\\t\\tfloat off_mag \\x3d scatter * threshold * 0.5;\\n\\t\\tfloat off_angle \\x3d rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;\\n\\t\\tc.p1.x +\\x3d cos( off_angle ) * off_mag;\\n\\t\\tc.p1.y +\\x3d sin( off_angle ) * off_mag;\\n\\t}\\n\\tfloat normal_step \\x3d normal_dir * ( ( offset_normal \\x3c threshold ) ? step : -step );\\n\\tfloat line_step \\x3d line_dir * ( ( offset_line \\x3c threshold ) ? step : -step );\\n\\tc.p2.x \\x3d c.p1.x - n.x * normal_step;\\n\\tc.p2.y \\x3d c.p1.y - n.y * normal_step;\\n\\tc.p3.x \\x3d c.p1.x + n.y * line_step;\\n\\tc.p3.y \\x3d c.p1.y - n.x * line_step;\\n\\tc.p4.x \\x3d c.p1.x - n.x * normal_step + n.y * line_step;\\n\\tc.p4.y \\x3d c.p1.y - n.y * normal_step - n.x * line_step;\\n\\treturn c;\\n}\\nfloat blendColour( float a, float b, float t ) {\\n\\tif ( blendingMode \\x3d\\x3d BLENDING_LINEAR ) {\\n\\t\\treturn blend( a, b, 1.0 - t );\\n\\t} else if ( blendingMode \\x3d\\x3d BLENDING_ADD ) {\\n\\t\\treturn blend( a, min( 1.0, a + b ), t );\\n\\t} else if ( blendingMode \\x3d\\x3d BLENDING_MULTIPLY ) {\\n\\t\\treturn blend( a, max( 0.0, a * b ), t );\\n\\t} else if ( blendingMode \\x3d\\x3d BLENDING_LIGHTER ) {\\n\\t\\treturn blend( a, max( a, b ), t );\\n\\t} else if ( blendingMode \\x3d\\x3d BLENDING_DARKER ) {\\n\\t\\treturn blend( a, min( a, b ), t );\\n\\t} else {\\n\\t\\treturn blend( a, b, 1.0 - t );\\n\\t}\\n}\\nvoid main() {\\n\\tif ( ! disable ) {\\n\\t\\tvec2 p \\x3d vec2( vUV.x * width, vUV.y * height );\\n\\t\\tvec2 origin \\x3d vec2( 0, 0 );\\n\\t\\tfloat aa \\x3d ( radius \\x3c 2.5 ) ? radius * 0.5 : 1.25;\\n\\t\\tCell cell_r \\x3d getReferenceCell( p, origin, rotateR, radius );\\n\\t\\tCell cell_g \\x3d getReferenceCell( p, origin, rotateG, radius );\\n\\t\\tCell cell_b \\x3d getReferenceCell( p, origin, rotateB, radius );\\n\\t\\tfloat r \\x3d getDotColour( cell_r, p, 0, rotateR, aa );\\n\\t\\tfloat g \\x3d getDotColour( cell_g, p, 1, rotateG, aa );\\n\\t\\tfloat b \\x3d getDotColour( cell_b, p, 2, rotateB, aa );\\n\\t\\tvec4 colour \\x3d texture2D( tDiffuse, vUV );\\n\\t\\tr \\x3d blendColour( r, colour.r, blending );\\n\\t\\tg \\x3d blendColour( g, colour.g, blending );\\n\\t\\tb \\x3d blendColour( b, colour.b, blending );\\n\\t\\tif ( greyscale ) {\\n\\t\\t\\tr \\x3d g \\x3d b \\x3d (r + b + g) / 3.0;\\n\\t\\t}\\n\\t\\tgl_FragColor \\x3d vec4( r, g, b, 1.0 );\\n\\t} else {\\n\\t\\tgl_FragColor \\x3d texture2D( tDiffuse, vUV );\\n\\t}\\n}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$HalftoneShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HalftoneShader = void 0;\n\n/**\n * RGB Halftone shader for three.js.\n *\tNOTE:\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\n */\nvar HalftoneShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    shape: {\n      value: 1\n    },\n    radius: {\n      value: 4\n    },\n    rotateR: {\n      value: Math.PI / 12 * 1\n    },\n    rotateG: {\n      value: Math.PI / 12 * 2\n    },\n    rotateB: {\n      value: Math.PI / 12 * 3\n    },\n    scatter: {\n      value: 0\n    },\n    width: {\n      value: 1\n    },\n    height: {\n      value: 1\n    },\n    blending: {\n      value: 1\n    },\n    blendingMode: {\n      value: 1\n    },\n    greyscale: {\n      value: false\n    },\n    disable: {\n      value: false\n    }\n  },\n  vertexShader: ['varying vec2 vUV;', 'void main() {', '\tvUV = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);', '}'].join('\\n'),\n  fragmentShader: ['#define SQRT2_MINUS_ONE 0.41421356', '#define SQRT2_HALF_MINUS_ONE 0.20710678', '#define PI2 6.28318531', '#define SHAPE_DOT 1', '#define SHAPE_ELLIPSE 2', '#define SHAPE_LINE 3', '#define SHAPE_SQUARE 4', '#define BLENDING_LINEAR 1', '#define BLENDING_MULTIPLY 2', '#define BLENDING_ADD 3', '#define BLENDING_LIGHTER 4', '#define BLENDING_DARKER 5', 'uniform sampler2D tDiffuse;', 'uniform float radius;', 'uniform float rotateR;', 'uniform float rotateG;', 'uniform float rotateB;', 'uniform float scatter;', 'uniform float width;', 'uniform float height;', 'uniform int shape;', 'uniform bool disable;', 'uniform float blending;', 'uniform int blendingMode;', 'varying vec2 vUV;', 'uniform bool greyscale;', 'const int samples = 8;', 'float blend( float a, float b, float t ) {', // linear blend\n  '\treturn a * ( 1.0 - t ) + b * t;', '}', 'float hypot( float x, float y ) {', // vector magnitude\n  '\treturn sqrt( x * x + y * y );', '}', 'float rand( vec2 seed ){', // get pseudo-random number\n  'return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );', '}', 'float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {', // apply shape-specific transforms\n  '\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );', '\tfloat rad = channel;', '\tif ( shape == SHAPE_DOT ) {', '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\t} else if ( shape == SHAPE_ELLIPSE ) {', '\t\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\t\tif ( dist != 0.0 ) {', '\t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );', '\t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;', '\t\t}', '\t} else if ( shape == SHAPE_LINE ) {', '\t\trad = pow( abs( rad ), 1.5) * rad_max;', '\t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;', '\t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );', '\t} else if ( shape == SHAPE_SQUARE ) {', '\t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;', '\t\tfloat sin_t = abs( sin( theta ) );', '\t\tfloat cos_t = abs( cos( theta ) );', '\t\trad = pow( abs( rad ), 1.4 );', '\t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );', '\t}', '\treturn rad - dist;', '}', 'struct Cell {', // grid sample positions\n  '\tvec2 normal;', '\tvec2 p1;', '\tvec2 p2;', '\tvec2 p3;', '\tvec2 p4;', '\tfloat samp2;', '\tfloat samp1;', '\tfloat samp3;', '\tfloat samp4;', '};', 'vec4 getSample( vec2 point ) {', // multi-sampled point\n  '\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );', '\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;', '\tfloat step = PI2 / float( samples );', '\tfloat dist = radius * 0.66;', '\tfor ( int i = 0; i < samples; ++i ) {', '\t\tfloat r = base + step * float( i );', '\t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );', '\t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );', '\t}', '\ttex /= float( samples ) + 1.0;', '\treturn tex;', '}', 'float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {', // get colour for given point\n  '\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;', '\tif ( channel == 0 ) {', '\t\tc.samp1 = getSample( c.p1 ).r;', '\t\tc.samp2 = getSample( c.p2 ).r;', '\t\tc.samp3 = getSample( c.p3 ).r;', '\t\tc.samp4 = getSample( c.p4 ).r;', '\t} else if (channel == 1) {', '\t\tc.samp1 = getSample( c.p1 ).g;', '\t\tc.samp2 = getSample( c.p2 ).g;', '\t\tc.samp3 = getSample( c.p3 ).g;', '\t\tc.samp4 = getSample( c.p4 ).g;', '\t} else {', '\t\tc.samp1 = getSample( c.p1 ).b;', '\t\tc.samp3 = getSample( c.p3 ).b;', '\t\tc.samp2 = getSample( c.p2 ).b;', '\t\tc.samp4 = getSample( c.p4 ).b;', '\t}', '\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );', '\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );', '\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );', '\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );', '\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;', '\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;', '\tres = clamp( res, 0.0, 1.0 );', '\treturn res;', '}', 'Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {', // get containing cell\n  '\tCell c;', // calc grid\n  '\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );', '\tfloat threshold = step * 0.5;', '\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );', '\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );', '\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );', '\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );', '\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;', '\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;', '\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );', '\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;', '\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;', // get closest corner\n  '\tc.normal = n;', '\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;', '\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;', // scatter\n  '\tif ( scatter != 0.0 ) {', '\t\tfloat off_mag = scatter * threshold * 0.5;', '\t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;', '\t\tc.p1.x += cos( off_angle ) * off_mag;', '\t\tc.p1.y += sin( off_angle ) * off_mag;', '\t}', // find corners\n  '\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );', '\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );', '\tc.p2.x = c.p1.x - n.x * normal_step;', '\tc.p2.y = c.p1.y - n.y * normal_step;', '\tc.p3.x = c.p1.x + n.y * line_step;', '\tc.p3.y = c.p1.y - n.x * line_step;', '\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;', '\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;', '\treturn c;', '}', 'float blendColour( float a, float b, float t ) {', // blend colours\n  '\tif ( blendingMode == BLENDING_LINEAR ) {', '\t\treturn blend( a, b, 1.0 - t );', '\t} else if ( blendingMode == BLENDING_ADD ) {', '\t\treturn blend( a, min( 1.0, a + b ), t );', '\t} else if ( blendingMode == BLENDING_MULTIPLY ) {', '\t\treturn blend( a, max( 0.0, a * b ), t );', '\t} else if ( blendingMode == BLENDING_LIGHTER ) {', '\t\treturn blend( a, max( a, b ), t );', '\t} else if ( blendingMode == BLENDING_DARKER ) {', '\t\treturn blend( a, min( a, b ), t );', '\t} else {', '\t\treturn blend( a, b, 1.0 - t );', '\t}', '}', 'void main() {', '\tif ( ! disable ) {', // setup\n  '\t\tvec2 p = vec2( vUV.x * width, vUV.y * height );', '\t\tvec2 origin = vec2( 0, 0 );', '\t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;', // get channel samples\n  '\t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );', '\t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );', '\t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );', '\t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );', '\t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );', '\t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );', // blend with original\n  '\t\tvec4 colour = texture2D( tDiffuse, vUV );', '\t\tr = blendColour( r, colour.r, blending );', '\t\tg = blendColour( g, colour.g, blending );', '\t\tb = blendColour( b, colour.b, blending );', '\t\tif ( greyscale ) {', '\t\t\tr = g = b = (r + b + g) / 3.0;', '\t\t}', '\t\tgl_FragColor = vec4( r, g, b, 1.0 );', '\t} else {', '\t\tgl_FragColor = texture2D( tDiffuse, vUV );', '\t}', '}'].join('\\n')\n};\nexports.HalftoneShader = HalftoneShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["fragmentShader","width","blending","rotateR","height","shape","__esModule","radius","tDiffuse","vertexShader","scatter","value","rotateB","disable","greyscale","rotateG","blendingMode","uniforms","HalftoneShader"]],"~:compiled-at",1630917515481,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$HalftoneShader.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,uDAAA,CAA4E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGpHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,cAAR,CAAyB,IAAK,EAqE9BJ,QAAQI,CAAAA,cAAR,CA7DqBA,CACnBC,SAAU,CACRC,SAAU,CACRH,MAAO,IADC,CADF,CAIRI,MAAO,CACLJ,MAAO,CADF,CAJC,CAORK,OAAQ,CACNL,MAAO,CADD,CAPA,CAURM,QAAS,CACPN,MAAOO,IAAKC,CAAAA,EAAZR,CAAiB,EADV,CAVD,CAaRS,QAAS,CACPT,MAAOO,IAAKC,CAAAA,EAAZR,CAAiB,EAAjBA,CAAsB,CADf,CAbD,CAgBRU,QAAS,CACPV,MAAOO,IAAKC,CAAAA,EAAZR,CAAiB,EAAjBA,CAAsB,CADf,CAhBD,CAmBRW,QAAS,CACPX,MAAO,CADA,CAnBD,CAsBRY,MAAO,CACLZ,MAAO,CADF,CAtBC,CAyBRa,OAAQ,CACNb,MAAO,CADD,CAzBA,CA4BRc,SAAU,CACRd,MAAO,CADC,CA5BF,CA+BRe,aAAc,CACZf,MAAO,CADK,CA/BN,CAkCRgB,UAAW,CACThB,MAAO,CAAA,CADE,CAlCH,CAqCRiB,QAAS,CACPjB,MAAO,CAAA,CADA,CArCD,CADSC;AA0CnBiB,aAA+I,mIA1C5HjB,CA2CnBkB,eAgB6W,49OA3D1VlB,CAd+F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/HalftoneShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$HalftoneShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.HalftoneShader = void 0;\\n\\n/**\\n * RGB Halftone shader for three.js.\\n *\\tNOTE:\\n * \\t\\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\\n *\\t\\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\\n */\\nvar HalftoneShader = {\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    shape: {\\n      value: 1\\n    },\\n    radius: {\\n      value: 4\\n    },\\n    rotateR: {\\n      value: Math.PI / 12 * 1\\n    },\\n    rotateG: {\\n      value: Math.PI / 12 * 2\\n    },\\n    rotateB: {\\n      value: Math.PI / 12 * 3\\n    },\\n    scatter: {\\n      value: 0\\n    },\\n    width: {\\n      value: 1\\n    },\\n    height: {\\n      value: 1\\n    },\\n    blending: {\\n      value: 1\\n    },\\n    blendingMode: {\\n      value: 1\\n    },\\n    greyscale: {\\n      value: false\\n    },\\n    disable: {\\n      value: false\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUV;', 'void main() {', '\\tvUV = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);', '}'].join('\\\\n'),\\n  fragmentShader: ['#define SQRT2_MINUS_ONE 0.41421356', '#define SQRT2_HALF_MINUS_ONE 0.20710678', '#define PI2 6.28318531', '#define SHAPE_DOT 1', '#define SHAPE_ELLIPSE 2', '#define SHAPE_LINE 3', '#define SHAPE_SQUARE 4', '#define BLENDING_LINEAR 1', '#define BLENDING_MULTIPLY 2', '#define BLENDING_ADD 3', '#define BLENDING_LIGHTER 4', '#define BLENDING_DARKER 5', 'uniform sampler2D tDiffuse;', 'uniform float radius;', 'uniform float rotateR;', 'uniform float rotateG;', 'uniform float rotateB;', 'uniform float scatter;', 'uniform float width;', 'uniform float height;', 'uniform int shape;', 'uniform bool disable;', 'uniform float blending;', 'uniform int blendingMode;', 'varying vec2 vUV;', 'uniform bool greyscale;', 'const int samples = 8;', 'float blend( float a, float b, float t ) {', // linear blend\\n  '\\treturn a * ( 1.0 - t ) + b * t;', '}', 'float hypot( float x, float y ) {', // vector magnitude\\n  '\\treturn sqrt( x * x + y * y );', '}', 'float rand( vec2 seed ){', // get pseudo-random number\\n  'return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );', '}', 'float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {', // apply shape-specific transforms\\n  '\\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );', '\\tfloat rad = channel;', '\\tif ( shape == SHAPE_DOT ) {', '\\t\\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\\t} else if ( shape == SHAPE_ELLIPSE ) {', '\\t\\trad = pow( abs( rad ), 1.125 ) * rad_max;', '\\t\\tif ( dist != 0.0 ) {', '\\t\\t\\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );', '\\t\\t\\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;', '\\t\\t}', '\\t} else if ( shape == SHAPE_LINE ) {', '\\t\\trad = pow( abs( rad ), 1.5) * rad_max;', '\\t\\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;', '\\t\\tdist = hypot( normal.x * dot_p, normal.y * dot_p );', '\\t} else if ( shape == SHAPE_SQUARE ) {', '\\t\\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;', '\\t\\tfloat sin_t = abs( sin( theta ) );', '\\t\\tfloat cos_t = abs( cos( theta ) );', '\\t\\trad = pow( abs( rad ), 1.4 );', '\\t\\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );', '\\t}', '\\treturn rad - dist;', '}', 'struct Cell {', // grid sample positions\\n  '\\tvec2 normal;', '\\tvec2 p1;', '\\tvec2 p2;', '\\tvec2 p3;', '\\tvec2 p4;', '\\tfloat samp2;', '\\tfloat samp1;', '\\tfloat samp3;', '\\tfloat samp4;', '};', 'vec4 getSample( vec2 point ) {', // multi-sampled point\\n  '\\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );', '\\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;', '\\tfloat step = PI2 / float( samples );', '\\tfloat dist = radius * 0.66;', '\\tfor ( int i = 0; i < samples; ++i ) {', '\\t\\tfloat r = base + step * float( i );', '\\t\\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );', '\\t\\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );', '\\t}', '\\ttex /= float( samples ) + 1.0;', '\\treturn tex;', '}', 'float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {', // get colour for given point\\n  '\\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;', '\\tif ( channel == 0 ) {', '\\t\\tc.samp1 = getSample( c.p1 ).r;', '\\t\\tc.samp2 = getSample( c.p2 ).r;', '\\t\\tc.samp3 = getSample( c.p3 ).r;', '\\t\\tc.samp4 = getSample( c.p4 ).r;', '\\t} else if (channel == 1) {', '\\t\\tc.samp1 = getSample( c.p1 ).g;', '\\t\\tc.samp2 = getSample( c.p2 ).g;', '\\t\\tc.samp3 = getSample( c.p3 ).g;', '\\t\\tc.samp4 = getSample( c.p4 ).g;', '\\t} else {', '\\t\\tc.samp1 = getSample( c.p1 ).b;', '\\t\\tc.samp3 = getSample( c.p3 ).b;', '\\t\\tc.samp2 = getSample( c.p2 ).b;', '\\t\\tc.samp4 = getSample( c.p4 ).b;', '\\t}', '\\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );', '\\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );', '\\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );', '\\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );', '\\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;', '\\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;', '\\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;', '\\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;', '\\tres = clamp( res, 0.0, 1.0 );', '\\treturn res;', '}', 'Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {', // get containing cell\\n  '\\tCell c;', // calc grid\\n  '\\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );', '\\tfloat threshold = step * 0.5;', '\\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );', '\\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );', '\\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );', '\\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );', '\\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;', '\\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;', '\\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );', '\\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;', '\\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;', // get closest corner\\n  '\\tc.normal = n;', '\\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;', '\\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;', // scatter\\n  '\\tif ( scatter != 0.0 ) {', '\\t\\tfloat off_mag = scatter * threshold * 0.5;', '\\t\\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;', '\\t\\tc.p1.x += cos( off_angle ) * off_mag;', '\\t\\tc.p1.y += sin( off_angle ) * off_mag;', '\\t}', // find corners\\n  '\\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );', '\\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );', '\\tc.p2.x = c.p1.x - n.x * normal_step;', '\\tc.p2.y = c.p1.y - n.y * normal_step;', '\\tc.p3.x = c.p1.x + n.y * line_step;', '\\tc.p3.y = c.p1.y - n.x * line_step;', '\\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;', '\\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;', '\\treturn c;', '}', 'float blendColour( float a, float b, float t ) {', // blend colours\\n  '\\tif ( blendingMode == BLENDING_LINEAR ) {', '\\t\\treturn blend( a, b, 1.0 - t );', '\\t} else if ( blendingMode == BLENDING_ADD ) {', '\\t\\treturn blend( a, min( 1.0, a + b ), t );', '\\t} else if ( blendingMode == BLENDING_MULTIPLY ) {', '\\t\\treturn blend( a, max( 0.0, a * b ), t );', '\\t} else if ( blendingMode == BLENDING_LIGHTER ) {', '\\t\\treturn blend( a, max( a, b ), t );', '\\t} else if ( blendingMode == BLENDING_DARKER ) {', '\\t\\treturn blend( a, min( a, b ), t );', '\\t} else {', '\\t\\treturn blend( a, b, 1.0 - t );', '\\t}', '}', 'void main() {', '\\tif ( ! disable ) {', // setup\\n  '\\t\\tvec2 p = vec2( vUV.x * width, vUV.y * height );', '\\t\\tvec2 origin = vec2( 0, 0 );', '\\t\\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;', // get channel samples\\n  '\\t\\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );', '\\t\\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );', '\\t\\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );', '\\t\\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );', '\\t\\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );', '\\t\\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );', // blend with original\\n  '\\t\\tvec4 colour = texture2D( tDiffuse, vUV );', '\\t\\tr = blendColour( r, colour.r, blending );', '\\t\\tg = blendColour( g, colour.g, blending );', '\\t\\tb = blendColour( b, colour.b, blending );', '\\t\\tif ( greyscale ) {', '\\t\\t\\tr = g = b = (r + b + g) / 3.0;', '\\t\\t}', '\\t\\tgl_FragColor = vec4( r, g, b, 1.0 );', '\\t} else {', '\\t\\tgl_FragColor = texture2D( tDiffuse, vUV );', '\\t}', '}'].join('\\\\n')\\n};\\nexports.HalftoneShader = HalftoneShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"HalftoneShader\",\"uniforms\",\"tDiffuse\",\"shape\",\"radius\",\"rotateR\",\"Math\",\"PI\",\"rotateG\",\"rotateB\",\"scatter\",\"width\",\"height\",\"blending\",\"blendingMode\",\"greyscale\",\"disable\",\"vertexShader\",\"fragmentShader\"]\n}\n"]