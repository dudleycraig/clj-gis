["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/postprocessing/LUTPass.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$postprocessing$LUTPass=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||\nObject.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,\nstaticProps);return Constructor}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,\np$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.LUTPass=void 0;var LUTShader={defines:{USE_3DTEXTURE:1},uniforms:{lut3d:{value:null},lut:{value:null},lutSize:{value:0},tDiffuse:{value:null},intensity:{value:1}},vertexShader:\"\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv \\x3d uv;\\n\\t\\t\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\\n\\n\\t\",fragmentShader:\"\\n\\t\\tprecision highp sampler3D;\\n\\n\\t\\tuniform float lutSize;\\n\\t\\t#if USE_3DTEXTURE\\n\\t\\tuniform sampler3D lut3d;\\n\\t\\t#else\\n\\t\\tuniform sampler2D lut;\\n\\n\\t\\tvec3 lutLookup( sampler2D tex, float size, vec3 rgb ) {\\n\\n\\t\\t\\tfloat sliceHeight \\x3d 1.0 / size;\\n\\t\\t\\tfloat yPixelHeight \\x3d 1.0 / ( size * size );\\n\\n\\t\\t\\t// Get the slices on either side of the sample\\n\\t\\t\\tfloat slice \\x3d rgb.b * size;\\n\\t\\t\\tfloat interp \\x3d fract( slice );\\n\\t\\t\\tfloat slice0 \\x3d slice - interp;\\n\\t\\t\\tfloat centeredInterp \\x3d interp - 0.5;\\n\\n\\t\\t\\tfloat slice1 \\x3d slice0 + sign( centeredInterp );\\n\\n\\t\\t\\t// Pull y sample in by half a pixel in each direction to avoid color\\n\\t\\t\\t// bleeding from adjacent slices.\\n\\t\\t\\tfloat greenOffset \\x3d clamp( rgb.g * sliceHeight, yPixelHeight * 0.5, sliceHeight - yPixelHeight * 0.5 );\\n\\n\\t\\t\\tvec2 uv0 \\x3d vec2(\\n\\t\\t\\t\\trgb.r,\\n\\t\\t\\t\\tslice0 * sliceHeight + greenOffset\\n\\t\\t\\t);\\n\\t\\t\\tvec2 uv1 \\x3d vec2(\\n\\t\\t\\t\\trgb.r,\\n\\t\\t\\t\\tslice1 * sliceHeight + greenOffset\\n\\t\\t\\t);\\n\\n\\t\\t\\tvec3 sample0 \\x3d texture2D( tex, uv0 ).rgb;\\n\\t\\t\\tvec3 sample1 \\x3d texture2D( tex, uv1 ).rgb;\\n\\n\\t\\t\\treturn mix( sample0, sample1, abs( centeredInterp ) );\\n\\n\\t\\t}\\n\\t\\t#endif\\n\\n\\t\\tvarying vec2 vUv;\\n\\t\\tuniform float intensity;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvec4 val \\x3d texture2D( tDiffuse, vUv );\\n\\t\\t\\tvec4 lutVal;\\n\\n\\t\\t\\t// pull the sample in by half a pixel so the sample begins\\n\\t\\t\\t// at the center of the edge pixels.\\n\\t\\t\\tfloat pixelWidth \\x3d 1.0 / lutSize;\\n\\t\\t\\tfloat halfPixelWidth \\x3d 0.5 / lutSize;\\n\\t\\t\\tvec3 uvw \\x3d vec3( halfPixelWidth ) + val.rgb * ( 1.0 - pixelWidth );\\n\\n\\t\\t\\t#if USE_3DTEXTURE\\n\\n\\t\\t\\tlutVal \\x3d vec4( texture( lut3d, uvw ).rgb, val.a );\\n\\n\\t\\t\\t#else\\n\\n\\t\\t\\tlutVal \\x3d vec4( lutLookup( lut, lutSize, uvw ), val.a );\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tgl_FragColor \\x3d vec4( mix( val, lutVal, intensity ) );\\n\\n\\t\\t}\\n\\n\\t\"};\nglobal=function(_ShaderPass){function LUTPass(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(!(this instanceof LUTPass))throw new TypeError(\"Cannot call a class as a function\");var _this=_getPrototypeOf(LUTPass).call(this,LUTShader);if(!_this||\"object\"!==_typeof(_this)&&\"function\"!==typeof _this){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");_this=this}_this.lut=options.lut||null;_this.intensity=\"intensity\"in options?\noptions.intensity:1;return _this}_inherits(LUTPass,_ShaderPass);_createClass(LUTPass,[{key:\"lut\",set:function(v){var material=this.material;if(v!==this.lut&&(material.uniforms.lut3d.value=null,material.uniforms.lut.value=null,v)){var is3dTextureDefine=v.isDataTexture3D?1:0;is3dTextureDefine!==material.defines.USE_3DTEXTURE&&(material.defines.USE_3DTEXTURE=is3dTextureDefine,material.needsUpdate=!0);material.uniforms.lutSize.value=v.image.width;v.isDataTexture3D?material.uniforms.lut3d.value=v:material.uniforms.lut.value=\nv}},get:function(){return this.material.uniforms.lut.value||this.material.uniforms.lut3d.value}},{key:\"intensity\",set:function(v){this.material.uniforms.intensity.value=v},get:function(){return this.material.uniforms.intensity.value}}]);return LUTPass}(require(\"module$node_modules$three_stdlib$postprocessing$ShaderPass\").ShaderPass);exports.LUTPass=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$postprocessing$LUTPass\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LUTPass = void 0;\n\nvar _ShaderPass2 = require(\"./ShaderPass.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar LUTShader = {\n  defines: {\n    USE_3DTEXTURE: 1\n  },\n  uniforms: {\n    lut3d: {\n      value: null\n    },\n    lut: {\n      value: null\n    },\n    lutSize: {\n      value: 0\n    },\n    tDiffuse: {\n      value: null\n    },\n    intensity: {\n      value: 1.0\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = uv;\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\\n\\n\\t\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\t\\tprecision highp sampler3D;\\n\\n\\t\\tuniform float lutSize;\\n\\t\\t#if USE_3DTEXTURE\\n\\t\\tuniform sampler3D lut3d;\\n\\t\\t#else\\n\\t\\tuniform sampler2D lut;\\n\\n\\t\\tvec3 lutLookup( sampler2D tex, float size, vec3 rgb ) {\\n\\n\\t\\t\\tfloat sliceHeight = 1.0 / size;\\n\\t\\t\\tfloat yPixelHeight = 1.0 / ( size * size );\\n\\n\\t\\t\\t// Get the slices on either side of the sample\\n\\t\\t\\tfloat slice = rgb.b * size;\\n\\t\\t\\tfloat interp = fract( slice );\\n\\t\\t\\tfloat slice0 = slice - interp;\\n\\t\\t\\tfloat centeredInterp = interp - 0.5;\\n\\n\\t\\t\\tfloat slice1 = slice0 + sign( centeredInterp );\\n\\n\\t\\t\\t// Pull y sample in by half a pixel in each direction to avoid color\\n\\t\\t\\t// bleeding from adjacent slices.\\n\\t\\t\\tfloat greenOffset = clamp( rgb.g * sliceHeight, yPixelHeight * 0.5, sliceHeight - yPixelHeight * 0.5 );\\n\\n\\t\\t\\tvec2 uv0 = vec2(\\n\\t\\t\\t\\trgb.r,\\n\\t\\t\\t\\tslice0 * sliceHeight + greenOffset\\n\\t\\t\\t);\\n\\t\\t\\tvec2 uv1 = vec2(\\n\\t\\t\\t\\trgb.r,\\n\\t\\t\\t\\tslice1 * sliceHeight + greenOffset\\n\\t\\t\\t);\\n\\n\\t\\t\\tvec3 sample0 = texture2D( tex, uv0 ).rgb;\\n\\t\\t\\tvec3 sample1 = texture2D( tex, uv1 ).rgb;\\n\\n\\t\\t\\treturn mix( sample0, sample1, abs( centeredInterp ) );\\n\\n\\t\\t}\\n\\t\\t#endif\\n\\n\\t\\tvarying vec2 vUv;\\n\\t\\tuniform float intensity;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvec4 val = texture2D( tDiffuse, vUv );\\n\\t\\t\\tvec4 lutVal;\\n\\n\\t\\t\\t// pull the sample in by half a pixel so the sample begins\\n\\t\\t\\t// at the center of the edge pixels.\\n\\t\\t\\tfloat pixelWidth = 1.0 / lutSize;\\n\\t\\t\\tfloat halfPixelWidth = 0.5 / lutSize;\\n\\t\\t\\tvec3 uvw = vec3( halfPixelWidth ) + val.rgb * ( 1.0 - pixelWidth );\\n\\n\\t\\t\\t#if USE_3DTEXTURE\\n\\n\\t\\t\\tlutVal = vec4( texture( lut3d, uvw ).rgb, val.a );\\n\\n\\t\\t\\t#else\\n\\n\\t\\t\\tlutVal = vec4( lutLookup( lut, lutSize, uvw ), val.a );\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tgl_FragColor = vec4( mix( val, lutVal, intensity ) );\\n\\n\\t\\t}\\n\\n\\t\"\n};\n\nvar LUTPass =\n/*#__PURE__*/\nfunction (_ShaderPass) {\n  _inherits(LUTPass, _ShaderPass);\n\n  _createClass(LUTPass, [{\n    key: \"lut\",\n    set: function set(v) {\n      var material = this.material;\n\n      if (v !== this.lut) {\n        material.uniforms.lut3d.value = null;\n        material.uniforms.lut.value = null;\n\n        if (v) {\n          var is3dTextureDefine = v.isDataTexture3D ? 1 : 0;\n\n          if (is3dTextureDefine !== material.defines.USE_3DTEXTURE) {\n            material.defines.USE_3DTEXTURE = is3dTextureDefine;\n            material.needsUpdate = true;\n          }\n\n          material.uniforms.lutSize.value = v.image.width;\n\n          if (v.isDataTexture3D) {\n            material.uniforms.lut3d.value = v;\n          } else {\n            material.uniforms.lut.value = v;\n          }\n        }\n      }\n    },\n    get: function get() {\n      return this.material.uniforms.lut.value || this.material.uniforms.lut3d.value;\n    }\n  }, {\n    key: \"intensity\",\n    set: function set(v) {\n      this.material.uniforms.intensity.value = v;\n    },\n    get: function get() {\n      return this.material.uniforms.intensity.value;\n    }\n  }]);\n\n  function LUTPass() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LUTPass);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LUTPass).call(this, LUTShader));\n    _this.lut = options.lut || null;\n    _this.intensity = 'intensity' in options ? options.intensity : 1;\n    return _this;\n  }\n\n  return LUTPass;\n}(_ShaderPass2.ShaderPass);\n\nexports.LUTPass = LUTPass;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$three_stdlib$postprocessing$ShaderPass"]],"~:properties",["^5",["fragmentShader","intensity","needsUpdate","prototype","key","__esModule","tDiffuse","LUTPass","defines","vertexShader","configurable","value","lut3d","enumerable","writable","lutSize","__proto__","lut","USE_3DTEXTURE","set","uniforms","get","constructor"]],"~:compiled-at",1630917515477,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$postprocessing$LUTPass.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/postprocessing/LUTPass.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$postprocessing$LUTPass\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.LUTPass = void 0;\\n\\nvar _ShaderPass2 = require(\\\"./ShaderPass.js\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar LUTShader = {\\n  defines: {\\n    USE_3DTEXTURE: 1\\n  },\\n  uniforms: {\\n    lut3d: {\\n      value: null\\n    },\\n    lut: {\\n      value: null\\n    },\\n    lutSize: {\\n      value: 0\\n    },\\n    tDiffuse: {\\n      value: null\\n    },\\n    intensity: {\\n      value: 1.0\\n    }\\n  },\\n  vertexShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\n\\\\t\\\\tvarying vec2 vUv;\\\\n\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\tvUv = uv;\\\\n\\\\t\\\\t\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\",\\n  fragmentShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\t\\\\tprecision highp sampler3D;\\\\n\\\\n\\\\t\\\\tuniform float lutSize;\\\\n\\\\t\\\\t#if USE_3DTEXTURE\\\\n\\\\t\\\\tuniform sampler3D lut3d;\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\tuniform sampler2D lut;\\\\n\\\\n\\\\t\\\\tvec3 lutLookup( sampler2D tex, float size, vec3 rgb ) {\\\\n\\\\n\\\\t\\\\t\\\\tfloat sliceHeight = 1.0 / size;\\\\n\\\\t\\\\t\\\\tfloat yPixelHeight = 1.0 / ( size * size );\\\\n\\\\n\\\\t\\\\t\\\\t// Get the slices on either side of the sample\\\\n\\\\t\\\\t\\\\tfloat slice = rgb.b * size;\\\\n\\\\t\\\\t\\\\tfloat interp = fract( slice );\\\\n\\\\t\\\\t\\\\tfloat slice0 = slice - interp;\\\\n\\\\t\\\\t\\\\tfloat centeredInterp = interp - 0.5;\\\\n\\\\n\\\\t\\\\t\\\\tfloat slice1 = slice0 + sign( centeredInterp );\\\\n\\\\n\\\\t\\\\t\\\\t// Pull y sample in by half a pixel in each direction to avoid color\\\\n\\\\t\\\\t\\\\t// bleeding from adjacent slices.\\\\n\\\\t\\\\t\\\\tfloat greenOffset = clamp( rgb.g * sliceHeight, yPixelHeight * 0.5, sliceHeight - yPixelHeight * 0.5 );\\\\n\\\\n\\\\t\\\\t\\\\tvec2 uv0 = vec2(\\\\n\\\\t\\\\t\\\\t\\\\trgb.r,\\\\n\\\\t\\\\t\\\\t\\\\tslice0 * sliceHeight + greenOffset\\\\n\\\\t\\\\t\\\\t);\\\\n\\\\t\\\\t\\\\tvec2 uv1 = vec2(\\\\n\\\\t\\\\t\\\\t\\\\trgb.r,\\\\n\\\\t\\\\t\\\\t\\\\tslice1 * sliceHeight + greenOffset\\\\n\\\\t\\\\t\\\\t);\\\\n\\\\n\\\\t\\\\t\\\\tvec3 sample0 = texture2D( tex, uv0 ).rgb;\\\\n\\\\t\\\\t\\\\tvec3 sample1 = texture2D( tex, uv1 ).rgb;\\\\n\\\\n\\\\t\\\\t\\\\treturn mix( sample0, sample1, abs( centeredInterp ) );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tvarying vec2 vUv;\\\\n\\\\t\\\\tuniform float intensity;\\\\n\\\\t\\\\tuniform sampler2D tDiffuse;\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\tvec4 val = texture2D( tDiffuse, vUv );\\\\n\\\\t\\\\t\\\\tvec4 lutVal;\\\\n\\\\n\\\\t\\\\t\\\\t// pull the sample in by half a pixel so the sample begins\\\\n\\\\t\\\\t\\\\t// at the center of the edge pixels.\\\\n\\\\t\\\\t\\\\tfloat pixelWidth = 1.0 / lutSize;\\\\n\\\\t\\\\t\\\\tfloat halfPixelWidth = 0.5 / lutSize;\\\\n\\\\t\\\\t\\\\tvec3 uvw = vec3( halfPixelWidth ) + val.rgb * ( 1.0 - pixelWidth );\\\\n\\\\n\\\\t\\\\t\\\\t#if USE_3DTEXTURE\\\\n\\\\n\\\\t\\\\t\\\\tlutVal = vec4( texture( lut3d, uvw ).rgb, val.a );\\\\n\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\n\\\\t\\\\t\\\\tlutVal = vec4( lutLookup( lut, lutSize, uvw ), val.a );\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\tgl_FragColor = vec4( mix( val, lutVal, intensity ) );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\"\\n};\\n\\nvar LUTPass =\\n/*#__PURE__*/\\nfunction (_ShaderPass) {\\n  _inherits(LUTPass, _ShaderPass);\\n\\n  _createClass(LUTPass, [{\\n    key: \\\"lut\\\",\\n    set: function set(v) {\\n      var material = this.material;\\n\\n      if (v !== this.lut) {\\n        material.uniforms.lut3d.value = null;\\n        material.uniforms.lut.value = null;\\n\\n        if (v) {\\n          var is3dTextureDefine = v.isDataTexture3D ? 1 : 0;\\n\\n          if (is3dTextureDefine !== material.defines.USE_3DTEXTURE) {\\n            material.defines.USE_3DTEXTURE = is3dTextureDefine;\\n            material.needsUpdate = true;\\n          }\\n\\n          material.uniforms.lutSize.value = v.image.width;\\n\\n          if (v.isDataTexture3D) {\\n            material.uniforms.lut3d.value = v;\\n          } else {\\n            material.uniforms.lut.value = v;\\n          }\\n        }\\n      }\\n    },\\n    get: function get() {\\n      return this.material.uniforms.lut.value || this.material.uniforms.lut3d.value;\\n    }\\n  }, {\\n    key: \\\"intensity\\\",\\n    set: function set(v) {\\n      this.material.uniforms.intensity.value = v;\\n    },\\n    get: function get() {\\n      return this.material.uniforms.intensity.value;\\n    }\\n  }]);\\n\\n  function LUTPass() {\\n    var _this;\\n\\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n    _classCallCheck(this, LUTPass);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LUTPass).call(this, LUTShader));\\n    _this.lut = options.lut || null;\\n    _this.intensity = 'intensity' in options ? options.intensity : 1;\\n    return _this;\\n  }\\n\\n  return LUTPass;\\n}(_ShaderPass2.ShaderPass);\\n\\nexports.LUTPass = LUTPass;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"LUTPass\",\"LUTShader\",\"defines\",\"USE_3DTEXTURE\",\"uniforms\",\"lut3d\",\"lut\",\"lutSize\",\"tDiffuse\",\"intensity\",\"vertexShader\",\"fragmentShader\",\"_ShaderPass\",\"options\",\"arguments\",\"undefined\",\"instance\",\"call\",\"self\",\"ReferenceError\",\"_this\",\"set\",\"v\",\"material\",\"is3dTextureDefine\",\"isDataTexture3D\",\"needsUpdate\",\"image\",\"width\",\"get\",\"_ShaderPass2\",\"ShaderPass\"]\n}\n"]