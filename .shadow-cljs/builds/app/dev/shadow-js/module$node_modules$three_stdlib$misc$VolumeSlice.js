["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/misc/VolumeSlice.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$misc$VolumeSlice=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.VolumeSlice=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(volume,index,axis){var slice=this;this.volume=volume;index=index||0;Object.defineProperty(this,\"index\",{get:function(){return index},set:function(value){index=value;slice.geometryNeedsUpdate=!0;return index}});this.axis=axis||\"z\";this.canvas=\ndocument.createElement(\"canvas\");this.canvasBuffer=document.createElement(\"canvas\");this.updateGeometry();volume=new _three.Texture(this.canvas);volume.minFilter=_three.LinearFilter;volume.wrapS=volume.wrapT=_three.ClampToEdgeWrapping;volume=new _three.MeshBasicMaterial({map:volume,side:_three.DoubleSide,transparent:!0});this.mesh=new _three.Mesh(this.geometry,volume);this.mesh.matrixAutoUpdate=!1;this.geometryNeedsUpdate=!0;this.repaint()};exports.VolumeSlice=global;global.prototype={constructor:global,\nrepaint:function(){this.geometryNeedsUpdate&&this.updateGeometry();var iLength=this.iLength,jLength=this.jLength,sliceAccess=this.sliceAccess,volume=this.volume,canvas=this.canvasBuffer,ctx=this.ctxBuffer,imgData=ctx.getImageData(0,0,iLength,jLength),data=imgData.data,volumeData=volume.data,upperThreshold=volume.upperThreshold,lowerThreshold=volume.lowerThreshold,windowLow=volume.windowLow,windowHigh=volume.windowHigh,pixelCount=0;if(\"label\"===volume.dataType)for(upperThreshold=0;upperThreshold<jLength;upperThreshold++)for(lowerThreshold=\n0;lowerThreshold<iLength;lowerThreshold++)windowLow=volumeData[sliceAccess(lowerThreshold,upperThreshold)],windowLow=windowLow>=this.colorMap.length?windowLow%this.colorMap.length+1:windowLow,windowLow=this.colorMap[windowLow],data[4*pixelCount]=windowLow>>24&255,data[4*pixelCount+1]=windowLow>>16&255,data[4*pixelCount+2]=windowLow>>8&255,data[4*pixelCount+3]=windowLow&255,pixelCount++;else for(volume=0;volume<jLength;volume++)for(var _i=0;_i<iLength;_i++){var value=volumeData[sliceAccess(_i,volume)],\nalpha=255;alpha=upperThreshold>=value?lowerThreshold<=value?alpha:0:0;value=Math.floor(255*(value-windowLow)/(windowHigh-windowLow));value=255<value?255:0>value?0:value|0;data[4*pixelCount]=value;data[4*pixelCount+1]=value;data[4*pixelCount+2]=value;data[4*pixelCount+3]=alpha;pixelCount++}ctx.putImageData(imgData,0,0);this.ctx.drawImage(canvas,0,0,iLength,jLength,0,0,this.canvas.width,this.canvas.height);this.mesh.material.map.needsUpdate=!0},updateGeometry:function(){var extracted=this.volume.extractPerpendicularPlane(this.axis,\nthis.index);this.sliceAccess=extracted.sliceAccess;this.jLength=extracted.jLength;this.iLength=extracted.iLength;this.matrix=extracted.matrix;this.canvas.width=extracted.planeWidth;this.canvas.height=extracted.planeHeight;this.canvasBuffer.width=this.iLength;this.canvasBuffer.height=this.jLength;this.ctx=this.canvas.getContext(\"2d\");this.ctxBuffer=this.canvasBuffer.getContext(\"2d\");this.geometry&&this.geometry.dispose();this.geometry=new _three.PlaneGeometry(extracted.planeWidth,extracted.planeHeight);\nthis.mesh&&(this.mesh.geometry=this.geometry,this.mesh.matrix.identity(),this.mesh.applyMatrix4(this.matrix));this.geometryNeedsUpdate=!1}}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$misc$VolumeSlice\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VolumeSlice = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * This class has been made to hold a slice of a volume data\n * @class\n * @param   {Volume} volume    The associated volume\n * @param   {number}       [index=0] The index of the slice\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\n * @see Volume\n */\nvar VolumeSlice = function VolumeSlice(volume, index, axis) {\n  var slice = this;\n  /**\n   * @member {Volume} volume The associated volume\n   */\n\n  this.volume = volume;\n  /**\n   * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\n   */\n\n  index = index || 0;\n  Object.defineProperty(this, 'index', {\n    get: function get() {\n      return index;\n    },\n    set: function set(value) {\n      index = value;\n      slice.geometryNeedsUpdate = true;\n      return index;\n    }\n  });\n  /**\n   * @member {String} axis The normal axis\n   */\n\n  this.axis = axis || 'z';\n  /**\n   * @member {HTMLCanvasElement} canvas The final canvas used for the texture\n   */\n\n  /**\n   * @member {CanvasRenderingContext2D} ctx Context of the canvas\n   */\n\n  this.canvas = document.createElement('canvas');\n  /**\n   * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\n   */\n\n  /**\n   * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\n   */\n\n  this.canvasBuffer = document.createElement('canvas');\n  this.updateGeometry();\n  var canvasMap = new _three.Texture(this.canvas);\n  canvasMap.minFilter = _three.LinearFilter;\n  canvasMap.wrapS = canvasMap.wrapT = _three.ClampToEdgeWrapping;\n  var material = new _three.MeshBasicMaterial({\n    map: canvasMap,\n    side: _three.DoubleSide,\n    transparent: true\n  });\n  /**\n   * @member {Mesh} mesh The mesh ready to get used in the scene\n   */\n\n  this.mesh = new _three.Mesh(this.geometry, material);\n  this.mesh.matrixAutoUpdate = false;\n  /**\n   * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\n   */\n\n  this.geometryNeedsUpdate = true;\n  this.repaint();\n  /**\n   * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\n   */\n\n  /**\n   * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\n   */\n\n  /**\n   * @member {Function} sliceAccess Function that allow the slice to access right data\n   * @see Volume.extractPerpendicularPlane\n   * @param {Number} i The first coordinate\n   * @param {Number} j The second coordinate\n   * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\n   */\n};\n\nexports.VolumeSlice = VolumeSlice;\nVolumeSlice.prototype = {\n  constructor: VolumeSlice,\n\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  repaint: function repaint() {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry();\n    }\n\n    var iLength = this.iLength,\n        jLength = this.jLength,\n        sliceAccess = this.sliceAccess,\n        volume = this.volume,\n        canvas = this.canvasBuffer,\n        ctx = this.ctxBuffer; // get the imageData and pixel array from the canvas\n\n    var imgData = ctx.getImageData(0, 0, iLength, jLength);\n    var data = imgData.data;\n    var volumeData = volume.data;\n    var upperThreshold = volume.upperThreshold;\n    var lowerThreshold = volume.lowerThreshold;\n    var windowLow = volume.windowLow;\n    var windowHigh = volume.windowHigh; // manipulate some pixel elements\n\n    var pixelCount = 0;\n\n    if (volume.dataType === 'label') {\n      //this part is currently useless but will be used when colortables will be handled\n      for (var j = 0; j < jLength; j++) {\n        for (var i = 0; i < iLength; i++) {\n          var label = volumeData[sliceAccess(i, j)];\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n          var color = this.colorMap[label];\n          data[4 * pixelCount] = color >> 24 & 0xff;\n          data[4 * pixelCount + 1] = color >> 16 & 0xff;\n          data[4 * pixelCount + 2] = color >> 8 & 0xff;\n          data[4 * pixelCount + 3] = color & 0xff;\n          pixelCount++;\n        }\n      }\n    } else {\n      for (var _j = 0; _j < jLength; _j++) {\n        for (var _i = 0; _i < iLength; _i++) {\n          var value = volumeData[sliceAccess(_i, _j)];\n          var alpha = 0xff; //apply threshold\n\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0; //apply window level\n\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n          data[4 * pixelCount] = value;\n          data[4 * pixelCount + 1] = value;\n          data[4 * pixelCount + 2] = value;\n          data[4 * pixelCount + 3] = alpha;\n          pixelCount++;\n        }\n      }\n    }\n\n    ctx.putImageData(imgData, 0, 0);\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n    this.mesh.material.map.needsUpdate = true;\n  },\n\n  /**\n   * @member {Function} Refresh the geometry according to axis and index\n   * @see Volume.extractPerpendicularPlane\n   * @memberof VolumeSlice\n   */\n  updateGeometry: function updateGeometry() {\n    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n    this.sliceAccess = extracted.sliceAccess;\n    this.jLength = extracted.jLength;\n    this.iLength = extracted.iLength;\n    this.matrix = extracted.matrix;\n    this.canvas.width = extracted.planeWidth;\n    this.canvas.height = extracted.planeHeight;\n    this.canvasBuffer.width = this.iLength;\n    this.canvasBuffer.height = this.jLength;\n    this.ctx = this.canvas.getContext('2d');\n    this.ctxBuffer = this.canvasBuffer.getContext('2d');\n    if (this.geometry) this.geometry.dispose(); // dispose existing geometry\n\n    this.geometry = new _three.PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry; //reset mesh matrix\n\n      this.mesh.matrix.identity();\n      this.mesh.applyMatrix4(this.matrix);\n    }\n\n    this.geometryNeedsUpdate = false;\n  }\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["map","wrapS","canvas","width","index","needsUpdate","prototype","height","transparent","side","jLength","matrix","__esModule","axis","matrixAutoUpdate","ctxBuffer","geometryNeedsUpdate","sliceAccess","value","VolumeSlice","geometry","repaint","mesh","wrapT","volume","canvasBuffer","set","iLength","ctx","minFilter","updateGeometry","get","constructor"]],"~:compiled-at",1630917515121,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$misc$VolumeSlice.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/misc/VolumeSlice.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$misc$VolumeSlice\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.VolumeSlice = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * This class has been made to hold a slice of a volume data\\n * @class\\n * @param   {Volume} volume    The associated volume\\n * @param   {number}       [index=0] The index of the slice\\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\\n * @see Volume\\n */\\nvar VolumeSlice = function VolumeSlice(volume, index, axis) {\\n  var slice = this;\\n  /**\\n   * @member {Volume} volume The associated volume\\n   */\\n\\n  this.volume = volume;\\n  /**\\n   * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\\n   */\\n\\n  index = index || 0;\\n  Object.defineProperty(this, 'index', {\\n    get: function get() {\\n      return index;\\n    },\\n    set: function set(value) {\\n      index = value;\\n      slice.geometryNeedsUpdate = true;\\n      return index;\\n    }\\n  });\\n  /**\\n   * @member {String} axis The normal axis\\n   */\\n\\n  this.axis = axis || 'z';\\n  /**\\n   * @member {HTMLCanvasElement} canvas The final canvas used for the texture\\n   */\\n\\n  /**\\n   * @member {CanvasRenderingContext2D} ctx Context of the canvas\\n   */\\n\\n  this.canvas = document.createElement('canvas');\\n  /**\\n   * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\\n   */\\n\\n  /**\\n   * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\\n   */\\n\\n  this.canvasBuffer = document.createElement('canvas');\\n  this.updateGeometry();\\n  var canvasMap = new _three.Texture(this.canvas);\\n  canvasMap.minFilter = _three.LinearFilter;\\n  canvasMap.wrapS = canvasMap.wrapT = _three.ClampToEdgeWrapping;\\n  var material = new _three.MeshBasicMaterial({\\n    map: canvasMap,\\n    side: _three.DoubleSide,\\n    transparent: true\\n  });\\n  /**\\n   * @member {Mesh} mesh The mesh ready to get used in the scene\\n   */\\n\\n  this.mesh = new _three.Mesh(this.geometry, material);\\n  this.mesh.matrixAutoUpdate = false;\\n  /**\\n   * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\\n   */\\n\\n  this.geometryNeedsUpdate = true;\\n  this.repaint();\\n  /**\\n   * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\\n   */\\n\\n  /**\\n   * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\\n   */\\n\\n  /**\\n   * @member {Function} sliceAccess Function that allow the slice to access right data\\n   * @see Volume.extractPerpendicularPlane\\n   * @param {Number} i The first coordinate\\n   * @param {Number} j The second coordinate\\n   * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\\n   */\\n};\\n\\nexports.VolumeSlice = VolumeSlice;\\nVolumeSlice.prototype = {\\n  constructor: VolumeSlice,\\n\\n  /**\\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\\n   * @memberof VolumeSlice\\n   */\\n  repaint: function repaint() {\\n    if (this.geometryNeedsUpdate) {\\n      this.updateGeometry();\\n    }\\n\\n    var iLength = this.iLength,\\n        jLength = this.jLength,\\n        sliceAccess = this.sliceAccess,\\n        volume = this.volume,\\n        canvas = this.canvasBuffer,\\n        ctx = this.ctxBuffer; // get the imageData and pixel array from the canvas\\n\\n    var imgData = ctx.getImageData(0, 0, iLength, jLength);\\n    var data = imgData.data;\\n    var volumeData = volume.data;\\n    var upperThreshold = volume.upperThreshold;\\n    var lowerThreshold = volume.lowerThreshold;\\n    var windowLow = volume.windowLow;\\n    var windowHigh = volume.windowHigh; // manipulate some pixel elements\\n\\n    var pixelCount = 0;\\n\\n    if (volume.dataType === 'label') {\\n      //this part is currently useless but will be used when colortables will be handled\\n      for (var j = 0; j < jLength; j++) {\\n        for (var i = 0; i < iLength; i++) {\\n          var label = volumeData[sliceAccess(i, j)];\\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\\n          var color = this.colorMap[label];\\n          data[4 * pixelCount] = color >> 24 & 0xff;\\n          data[4 * pixelCount + 1] = color >> 16 & 0xff;\\n          data[4 * pixelCount + 2] = color >> 8 & 0xff;\\n          data[4 * pixelCount + 3] = color & 0xff;\\n          pixelCount++;\\n        }\\n      }\\n    } else {\\n      for (var _j = 0; _j < jLength; _j++) {\\n        for (var _i = 0; _i < iLength; _i++) {\\n          var value = volumeData[sliceAccess(_i, _j)];\\n          var alpha = 0xff; //apply threshold\\n\\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0; //apply window level\\n\\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\\n          data[4 * pixelCount] = value;\\n          data[4 * pixelCount + 1] = value;\\n          data[4 * pixelCount + 2] = value;\\n          data[4 * pixelCount + 3] = alpha;\\n          pixelCount++;\\n        }\\n      }\\n    }\\n\\n    ctx.putImageData(imgData, 0, 0);\\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\\n    this.mesh.material.map.needsUpdate = true;\\n  },\\n\\n  /**\\n   * @member {Function} Refresh the geometry according to axis and index\\n   * @see Volume.extractPerpendicularPlane\\n   * @memberof VolumeSlice\\n   */\\n  updateGeometry: function updateGeometry() {\\n    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\\n    this.sliceAccess = extracted.sliceAccess;\\n    this.jLength = extracted.jLength;\\n    this.iLength = extracted.iLength;\\n    this.matrix = extracted.matrix;\\n    this.canvas.width = extracted.planeWidth;\\n    this.canvas.height = extracted.planeHeight;\\n    this.canvasBuffer.width = this.iLength;\\n    this.canvasBuffer.height = this.jLength;\\n    this.ctx = this.canvas.getContext('2d');\\n    this.ctxBuffer = this.canvasBuffer.getContext('2d');\\n    if (this.geometry) this.geometry.dispose(); // dispose existing geometry\\n\\n    this.geometry = new _three.PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\\n\\n    if (this.mesh) {\\n      this.mesh.geometry = this.geometry; //reset mesh matrix\\n\\n      this.mesh.matrix.identity();\\n      this.mesh.applyMatrix4(this.matrix);\\n    }\\n\\n    this.geometryNeedsUpdate = false;\\n  }\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"VolumeSlice\",\"_three\",\"volume\",\"index\",\"axis\",\"slice\",\"get\",\"set\",\"geometryNeedsUpdate\",\"canvas\",\"document\",\"createElement\",\"canvasBuffer\",\"updateGeometry\",\"canvasMap\",\"Texture\",\"minFilter\",\"LinearFilter\",\"wrapS\",\"wrapT\",\"ClampToEdgeWrapping\",\"material\",\"MeshBasicMaterial\",\"map\",\"side\",\"DoubleSide\",\"transparent\",\"mesh\",\"Mesh\",\"geometry\",\"matrixAutoUpdate\",\"repaint\",\"prototype\",\"constructor\",\"iLength\",\"jLength\",\"sliceAccess\",\"ctx\",\"ctxBuffer\",\"imgData\",\"getImageData\",\"data\",\"volumeData\",\"upperThreshold\",\"lowerThreshold\",\"windowLow\",\"windowHigh\",\"pixelCount\",\"dataType\",\"j\",\"i\",\"label\",\"colorMap\",\"length\",\"color\",\"_j\",\"_i\",\"alpha\",\"Math\",\"floor\",\"putImageData\",\"drawImage\",\"width\",\"height\",\"needsUpdate\",\"extracted\",\"extractPerpendicularPlane\",\"matrix\",\"planeWidth\",\"planeHeight\",\"getContext\",\"dispose\",\"PlaneGeometry\",\"identity\",\"applyMatrix4\"]\n}\n"]