["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/FilmShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$FilmShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.FilmShader=void 0;exports.FilmShader={uniforms:{tDiffuse:{value:null},time:{value:0},nIntensity:{value:.5},sIntensity:{value:.05},sCount:{value:4096},grayscale:{value:1}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"#include \\x3ccommon\\x3e\\nuniform float time;\\nuniform bool grayscale;\\nuniform float nIntensity;\\nuniform float sIntensity;\\nuniform float sCount;\\nuniform sampler2D tDiffuse;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 cTextureScreen \\x3d texture2D( tDiffuse, vUv );\\n\\tfloat dx \\x3d rand( vUv + time );\\n\\tvec3 cResult \\x3d cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\\n\\tvec2 sc \\x3d vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\\n\\tcResult +\\x3d cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\\n\\tcResult \\x3d cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\\n\\tif( grayscale ) {\\n\\t\\tcResult \\x3d vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\\n\\t}\\n\\tgl_FragColor \\x3d  vec4( cResult, cTextureScreen.a );\\n}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$FilmShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FilmShader = void 0;\n\n/**\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\nvar FilmShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    time: {\n      value: 0.0\n    },\n    nIntensity: {\n      value: 0.5\n    },\n    sIntensity: {\n      value: 0.05\n    },\n    sCount: {\n      value: 4096\n    },\n    grayscale: {\n      value: 1\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', // control parameter\n  'uniform float time;', 'uniform bool grayscale;', // noise effect intensity value (0 = no effect, 1 = full effect)\n  'uniform float nIntensity;', // scanlines effect intensity value (0 = no effect, 1 = full effect)\n  'uniform float sIntensity;', // scanlines effect count value (0 = no effect, 4096 = full effect)\n  'uniform float sCount;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', // sample the source\n  '\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );', // make some noise\n  '\tfloat dx = rand( vUv + time );', // add noise\n  '\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );', // get us a sine and cosine\n  '\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );', // add scanlines\n  '\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;', // interpolate between source and result by intensity\n  '\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );', // convert to grayscale if desired\n  '\tif( grayscale ) {', '\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );', '\t}', '\tgl_FragColor =  vec4( cResult, cTextureScreen.a );', '}'].join('\\n')\n};\nexports.FilmShader = FilmShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["fragmentShader","grayscale","nIntensity","FilmShader","__esModule","tDiffuse","vertexShader","sIntensity","value","time","sCount","uniforms"]],"~:compiled-at",1630917515494,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$FilmShader.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAA,mDAAA,CAAwE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGhHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,UAAR,CAAqB,IAAK,EAwD1BJ,QAAQI,CAAAA,UAAR,CAnCiBA,CACfC,SAAU,CACRC,SAAU,CACRH,MAAO,IADC,CADF,CAIRI,KAAM,CACJJ,MAAO,CADH,CAJE,CAORK,WAAY,CACVL,MAAO,EADG,CAPJ,CAURM,WAAY,CACVN,MAAO,GADG,CAVJ,CAaRO,OAAQ,CACNP,MAAO,IADD,CAbA,CAgBRQ,UAAW,CACTR,MAAO,CADE,CAhBH,CADKC,CAqBfQ,aAAiJ,qIArBlIR,CAsBfS,eAWiK,4yBAjClJT,CA3B+F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/FilmShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$FilmShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.FilmShader = void 0;\\n\\n/**\\n * Film grain & scanlines shader\\n *\\n * - ported from HLSL to WebGL / GLSL\\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\\n *\\n * Screen Space Static Postprocessor\\n *\\n * Produces an analogue noise overlay similar to a film grain / TV static\\n *\\n * Original implementation and noise algorithm\\n * Pat 'Hawthorne' Shearon\\n *\\n * Optimized scanlines + noise version with intensity scaling\\n * Georg 'Leviathan' Steinrohder\\n *\\n * This version is provided under a Creative Commons Attribution 3.0 License\\n * http://creativecommons.org/licenses/by/3.0/\\n */\\nvar FilmShader = {\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    time: {\\n      value: 0.0\\n    },\\n    nIntensity: {\\n      value: 0.5\\n    },\\n    sIntensity: {\\n      value: 0.05\\n    },\\n    sCount: {\\n      value: 4096\\n    },\\n    grayscale: {\\n      value: 1\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['#include <common>', // control parameter\\n  'uniform float time;', 'uniform bool grayscale;', // noise effect intensity value (0 = no effect, 1 = full effect)\\n  'uniform float nIntensity;', // scanlines effect intensity value (0 = no effect, 1 = full effect)\\n  'uniform float sIntensity;', // scanlines effect count value (0 = no effect, 4096 = full effect)\\n  'uniform float sCount;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', // sample the source\\n  '\\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );', // make some noise\\n  '\\tfloat dx = rand( vUv + time );', // add noise\\n  '\\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );', // get us a sine and cosine\\n  '\\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );', // add scanlines\\n  '\\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;', // interpolate between source and result by intensity\\n  '\\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );', // convert to grayscale if desired\\n  '\\tif( grayscale ) {', '\\t\\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );', '\\t}', '\\tgl_FragColor =  vec4( cResult, cTextureScreen.a );', '}'].join('\\\\n')\\n};\\nexports.FilmShader = FilmShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"FilmShader\",\"uniforms\",\"tDiffuse\",\"time\",\"nIntensity\",\"sIntensity\",\"sCount\",\"grayscale\",\"vertexShader\",\"fragmentShader\"]\n}\n"]