["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/interactive/SelectionBox.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$interactive$SelectionBox=function(global,require,module,exports){function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);\nstaticProps&&_defineProperties(Constructor,staticProps);return Constructor}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.SelectionBox=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(){var frustum$jscomp$0=new _three.Frustum,center=new _three.Vector3,tmpPoint=new _three.Vector3,vecNear=new _three.Vector3,vecTopLeft=new _three.Vector3,vecTopRight=new _three.Vector3,vecDownRight=new _three.Vector3,vecDownLeft=new _three.Vector3,vecFarTopLeft=\nnew _three.Vector3,vecFarTopRight=new _three.Vector3,vecFarDownRight=new _three.Vector3,vecFarDownLeft=new _three.Vector3,vectemp1=new _three.Vector3,vectemp2=new _three.Vector3,vectemp3=new _three.Vector3;return function(){function SelectionBox(camera,scene,deep){if(!(this instanceof SelectionBox))throw new TypeError(\"Cannot call a class as a function\");this.camera=camera;this.scene=scene;this.startPoint=new _three.Vector3;this.endPoint=new _three.Vector3;this.collection=[];this.deep=deep||Number.MAX_VALUE}\n_createClass(SelectionBox,[{key:\"select\",value:function(startPoint,endPoint){this.startPoint=startPoint||this.startPoint;this.endPoint=endPoint||this.endPoint;this.collection=[];this.updateFrustum(this.startPoint,this.endPoint);this.searchChildInFrustum(frustum$jscomp$0,this.scene);return this.collection}},{key:\"updateFrustum\",value:function(startPoint,endPoint){startPoint=startPoint||this.startPoint;endPoint=endPoint||this.endPoint;startPoint.x===endPoint.x&&(endPoint.x+=Number.EPSILON);startPoint.y===\nendPoint.y&&(endPoint.y+=Number.EPSILON);this.camera.updateProjectionMatrix();this.camera.updateMatrixWorld();if(this.camera.isPerspectiveCamera){tmpPoint.copy(startPoint);tmpPoint.x=Math.min(startPoint.x,endPoint.x);tmpPoint.y=Math.max(startPoint.y,endPoint.y);endPoint.x=Math.max(startPoint.x,endPoint.x);endPoint.y=Math.min(startPoint.y,endPoint.y);vecNear.setFromMatrixPosition(this.camera.matrixWorld);vecTopLeft.copy(tmpPoint);vecTopRight.set(endPoint.x,tmpPoint.y,0);vecDownRight.copy(endPoint);\nvecDownLeft.set(tmpPoint.x,endPoint.y,0);vecTopLeft.unproject(this.camera);vecTopRight.unproject(this.camera);vecDownRight.unproject(this.camera);vecDownLeft.unproject(this.camera);vectemp1.copy(vecTopLeft).sub(vecNear);vectemp2.copy(vecTopRight).sub(vecNear);vectemp3.copy(vecDownRight).sub(vecNear);vectemp1.normalize();vectemp2.normalize();vectemp3.normalize();vectemp1.multiplyScalar(this.deep);vectemp2.multiplyScalar(this.deep);vectemp3.multiplyScalar(this.deep);vectemp1.add(vecNear);vectemp2.add(vecNear);\nvectemp3.add(vecNear);var planes=frustum$jscomp$0.planes;planes[0].setFromCoplanarPoints(vecNear,vecTopLeft,vecTopRight);planes[1].setFromCoplanarPoints(vecNear,vecTopRight,vecDownRight);planes[2].setFromCoplanarPoints(vecDownRight,vecDownLeft,vecNear);planes[3].setFromCoplanarPoints(vecDownLeft,vecTopLeft,vecNear);planes[4].setFromCoplanarPoints(vecTopRight,vecDownRight,vecDownLeft);planes[5].setFromCoplanarPoints(vectemp3,vectemp2,vectemp1);planes[5].normal.multiplyScalar(-1)}else if(this.camera.isOrthographicCamera){planes=\nMath.min(startPoint.x,endPoint.x);var top=Math.max(startPoint.y,endPoint.y),right=Math.max(startPoint.x,endPoint.x);startPoint=Math.min(startPoint.y,endPoint.y);vecTopLeft.set(planes,top,-1);vecTopRight.set(right,top,-1);vecDownRight.set(right,startPoint,-1);vecDownLeft.set(planes,startPoint,-1);vecFarTopLeft.set(planes,top,1);vecFarTopRight.set(right,top,1);vecFarDownRight.set(right,startPoint,1);vecFarDownLeft.set(planes,startPoint,1);vecTopLeft.unproject(this.camera);vecTopRight.unproject(this.camera);\nvecDownRight.unproject(this.camera);vecDownLeft.unproject(this.camera);vecFarTopLeft.unproject(this.camera);vecFarTopRight.unproject(this.camera);vecFarDownRight.unproject(this.camera);vecFarDownLeft.unproject(this.camera);planes=frustum$jscomp$0.planes;planes[0].setFromCoplanarPoints(vecTopLeft,vecFarTopLeft,vecFarTopRight);planes[1].setFromCoplanarPoints(vecTopRight,vecFarTopRight,vecFarDownRight);planes[2].setFromCoplanarPoints(vecFarDownRight,vecFarDownLeft,vecDownLeft);planes[3].setFromCoplanarPoints(vecFarDownLeft,\nvecFarTopLeft,vecTopLeft);planes[4].setFromCoplanarPoints(vecTopRight,vecDownRight,vecDownLeft);planes[5].setFromCoplanarPoints(vecFarDownRight,vecFarTopRight,vecFarTopLeft);planes[5].normal.multiplyScalar(-1)}else console.error(\"THREE.SelectionBox: Unsupported camera type.\")}},{key:\"searchChildInFrustum\",value:function(frustum,object){(object.isMesh||object.isLine||object.isPoints)&&void 0!==object.material&&(null===object.geometry.boundingSphere&&object.geometry.computeBoundingSphere(),center.copy(object.geometry.boundingSphere.center),\ncenter.applyMatrix4(object.matrixWorld),frustum.containsPoint(center)&&this.collection.push(object));if(0<object.children.length)for(var x=0;x<object.children.length;x++)this.searchChildInFrustum(frustum,object.children[x])}}]);return SelectionBox}()}();exports.SelectionBox=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$interactive$SelectionBox\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SelectionBox = void 0;\n\nvar _three = require(\"three\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * This is a class to check whether objects are in a selection area in 3D space\n */\nvar SelectionBox = function () {\n  var frustum = new _three.Frustum();\n  var center = new _three.Vector3();\n  var tmpPoint = new _three.Vector3();\n  var vecNear = new _three.Vector3();\n  var vecTopLeft = new _three.Vector3();\n  var vecTopRight = new _three.Vector3();\n  var vecDownRight = new _three.Vector3();\n  var vecDownLeft = new _three.Vector3();\n  var vecFarTopLeft = new _three.Vector3();\n  var vecFarTopRight = new _three.Vector3();\n  var vecFarDownRight = new _three.Vector3();\n  var vecFarDownLeft = new _three.Vector3();\n  var vectemp1 = new _three.Vector3();\n  var vectemp2 = new _three.Vector3();\n  var vectemp3 = new _three.Vector3();\n\n  var SelectionBox =\n  /*#__PURE__*/\n  function () {\n    function SelectionBox(camera, scene, deep) {\n      _classCallCheck(this, SelectionBox);\n\n      this.camera = camera;\n      this.scene = scene;\n      this.startPoint = new _three.Vector3();\n      this.endPoint = new _three.Vector3();\n      this.collection = [];\n      this.deep = deep || Number.MAX_VALUE;\n    }\n\n    _createClass(SelectionBox, [{\n      key: \"select\",\n      value: function select(startPoint, endPoint) {\n        this.startPoint = startPoint || this.startPoint;\n        this.endPoint = endPoint || this.endPoint;\n        this.collection = [];\n        this.updateFrustum(this.startPoint, this.endPoint);\n        this.searchChildInFrustum(frustum, this.scene);\n        return this.collection;\n      }\n    }, {\n      key: \"updateFrustum\",\n      value: function updateFrustum(startPoint, endPoint) {\n        startPoint = startPoint || this.startPoint;\n        endPoint = endPoint || this.endPoint; // Avoid invalid frustum\n\n        if (startPoint.x === endPoint.x) {\n          endPoint.x += Number.EPSILON;\n        }\n\n        if (startPoint.y === endPoint.y) {\n          endPoint.y += Number.EPSILON;\n        }\n\n        this.camera.updateProjectionMatrix();\n        this.camera.updateMatrixWorld();\n\n        if (this.camera.isPerspectiveCamera) {\n          tmpPoint.copy(startPoint);\n          tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n          tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n          endPoint.x = Math.max(startPoint.x, endPoint.x);\n          endPoint.y = Math.min(startPoint.y, endPoint.y);\n          vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n          vecTopLeft.copy(tmpPoint);\n          vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n          vecDownRight.copy(endPoint);\n          vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n          vecTopLeft.unproject(this.camera);\n          vecTopRight.unproject(this.camera);\n          vecDownRight.unproject(this.camera);\n          vecDownLeft.unproject(this.camera);\n          vectemp1.copy(vecTopLeft).sub(vecNear);\n          vectemp2.copy(vecTopRight).sub(vecNear);\n          vectemp3.copy(vecDownRight).sub(vecNear);\n          vectemp1.normalize();\n          vectemp2.normalize();\n          vectemp3.normalize();\n          vectemp1.multiplyScalar(this.deep);\n          vectemp2.multiplyScalar(this.deep);\n          vectemp3.multiplyScalar(this.deep);\n          vectemp1.add(vecNear);\n          vectemp2.add(vecNear);\n          vectemp3.add(vecNear);\n          var planes = frustum.planes;\n          planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n          planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n          planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n          planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n          planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n          planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n          planes[5].normal.multiplyScalar(-1);\n        } else if (this.camera.isOrthographicCamera) {\n          var left = Math.min(startPoint.x, endPoint.x);\n          var top = Math.max(startPoint.y, endPoint.y);\n          var right = Math.max(startPoint.x, endPoint.x);\n          var down = Math.min(startPoint.y, endPoint.y);\n          vecTopLeft.set(left, top, -1);\n          vecTopRight.set(right, top, -1);\n          vecDownRight.set(right, down, -1);\n          vecDownLeft.set(left, down, -1);\n          vecFarTopLeft.set(left, top, 1);\n          vecFarTopRight.set(right, top, 1);\n          vecFarDownRight.set(right, down, 1);\n          vecFarDownLeft.set(left, down, 1);\n          vecTopLeft.unproject(this.camera);\n          vecTopRight.unproject(this.camera);\n          vecDownRight.unproject(this.camera);\n          vecDownLeft.unproject(this.camera);\n          vecFarTopLeft.unproject(this.camera);\n          vecFarTopRight.unproject(this.camera);\n          vecFarDownRight.unproject(this.camera);\n          vecFarDownLeft.unproject(this.camera);\n          var planes = frustum.planes;\n          planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n          planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n          planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n          planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n          planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n          planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n          planes[5].normal.multiplyScalar(-1);\n        } else {\n          console.error('THREE.SelectionBox: Unsupported camera type.');\n        }\n      }\n    }, {\n      key: \"searchChildInFrustum\",\n      value: function searchChildInFrustum(frustum, object) {\n        if (object.isMesh || object.isLine || object.isPoints) {\n          if (object.material !== undefined) {\n            if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n            center.copy(object.geometry.boundingSphere.center);\n            center.applyMatrix4(object.matrixWorld);\n\n            if (frustum.containsPoint(center)) {\n              this.collection.push(object);\n            }\n          }\n        }\n\n        if (object.children.length > 0) {\n          for (var x = 0; x < object.children.length; x++) {\n            this.searchChildInFrustum(frustum, object.children[x]);\n          }\n        }\n      }\n    }]);\n\n    return SelectionBox;\n  }();\n\n  return SelectionBox;\n}();\n\nexports.SelectionBox = SelectionBox;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["key","collection","x","__esModule","startPoint","camera","configurable","value","enumerable","SelectionBox","writable","deep","y","endPoint","scene"]],"~:compiled-at",1630917515595,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$interactive$SelectionBox.js\",\n\"lineCount\":11,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/interactive/SelectionBox.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$interactive$SelectionBox\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.SelectionBox = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n/**\\n * This is a class to check whether objects are in a selection area in 3D space\\n */\\nvar SelectionBox = function () {\\n  var frustum = new _three.Frustum();\\n  var center = new _three.Vector3();\\n  var tmpPoint = new _three.Vector3();\\n  var vecNear = new _three.Vector3();\\n  var vecTopLeft = new _three.Vector3();\\n  var vecTopRight = new _three.Vector3();\\n  var vecDownRight = new _three.Vector3();\\n  var vecDownLeft = new _three.Vector3();\\n  var vecFarTopLeft = new _three.Vector3();\\n  var vecFarTopRight = new _three.Vector3();\\n  var vecFarDownRight = new _three.Vector3();\\n  var vecFarDownLeft = new _three.Vector3();\\n  var vectemp1 = new _three.Vector3();\\n  var vectemp2 = new _three.Vector3();\\n  var vectemp3 = new _three.Vector3();\\n\\n  var SelectionBox =\\n  /*#__PURE__*/\\n  function () {\\n    function SelectionBox(camera, scene, deep) {\\n      _classCallCheck(this, SelectionBox);\\n\\n      this.camera = camera;\\n      this.scene = scene;\\n      this.startPoint = new _three.Vector3();\\n      this.endPoint = new _three.Vector3();\\n      this.collection = [];\\n      this.deep = deep || Number.MAX_VALUE;\\n    }\\n\\n    _createClass(SelectionBox, [{\\n      key: \\\"select\\\",\\n      value: function select(startPoint, endPoint) {\\n        this.startPoint = startPoint || this.startPoint;\\n        this.endPoint = endPoint || this.endPoint;\\n        this.collection = [];\\n        this.updateFrustum(this.startPoint, this.endPoint);\\n        this.searchChildInFrustum(frustum, this.scene);\\n        return this.collection;\\n      }\\n    }, {\\n      key: \\\"updateFrustum\\\",\\n      value: function updateFrustum(startPoint, endPoint) {\\n        startPoint = startPoint || this.startPoint;\\n        endPoint = endPoint || this.endPoint; // Avoid invalid frustum\\n\\n        if (startPoint.x === endPoint.x) {\\n          endPoint.x += Number.EPSILON;\\n        }\\n\\n        if (startPoint.y === endPoint.y) {\\n          endPoint.y += Number.EPSILON;\\n        }\\n\\n        this.camera.updateProjectionMatrix();\\n        this.camera.updateMatrixWorld();\\n\\n        if (this.camera.isPerspectiveCamera) {\\n          tmpPoint.copy(startPoint);\\n          tmpPoint.x = Math.min(startPoint.x, endPoint.x);\\n          tmpPoint.y = Math.max(startPoint.y, endPoint.y);\\n          endPoint.x = Math.max(startPoint.x, endPoint.x);\\n          endPoint.y = Math.min(startPoint.y, endPoint.y);\\n          vecNear.setFromMatrixPosition(this.camera.matrixWorld);\\n          vecTopLeft.copy(tmpPoint);\\n          vecTopRight.set(endPoint.x, tmpPoint.y, 0);\\n          vecDownRight.copy(endPoint);\\n          vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\\n          vecTopLeft.unproject(this.camera);\\n          vecTopRight.unproject(this.camera);\\n          vecDownRight.unproject(this.camera);\\n          vecDownLeft.unproject(this.camera);\\n          vectemp1.copy(vecTopLeft).sub(vecNear);\\n          vectemp2.copy(vecTopRight).sub(vecNear);\\n          vectemp3.copy(vecDownRight).sub(vecNear);\\n          vectemp1.normalize();\\n          vectemp2.normalize();\\n          vectemp3.normalize();\\n          vectemp1.multiplyScalar(this.deep);\\n          vectemp2.multiplyScalar(this.deep);\\n          vectemp3.multiplyScalar(this.deep);\\n          vectemp1.add(vecNear);\\n          vectemp2.add(vecNear);\\n          vectemp3.add(vecNear);\\n          var planes = frustum.planes;\\n          planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\\n          planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\\n          planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\\n          planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\\n          planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\\n          planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\\n          planes[5].normal.multiplyScalar(-1);\\n        } else if (this.camera.isOrthographicCamera) {\\n          var left = Math.min(startPoint.x, endPoint.x);\\n          var top = Math.max(startPoint.y, endPoint.y);\\n          var right = Math.max(startPoint.x, endPoint.x);\\n          var down = Math.min(startPoint.y, endPoint.y);\\n          vecTopLeft.set(left, top, -1);\\n          vecTopRight.set(right, top, -1);\\n          vecDownRight.set(right, down, -1);\\n          vecDownLeft.set(left, down, -1);\\n          vecFarTopLeft.set(left, top, 1);\\n          vecFarTopRight.set(right, top, 1);\\n          vecFarDownRight.set(right, down, 1);\\n          vecFarDownLeft.set(left, down, 1);\\n          vecTopLeft.unproject(this.camera);\\n          vecTopRight.unproject(this.camera);\\n          vecDownRight.unproject(this.camera);\\n          vecDownLeft.unproject(this.camera);\\n          vecFarTopLeft.unproject(this.camera);\\n          vecFarTopRight.unproject(this.camera);\\n          vecFarDownRight.unproject(this.camera);\\n          vecFarDownLeft.unproject(this.camera);\\n          var planes = frustum.planes;\\n          planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\\n          planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\\n          planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\\n          planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\\n          planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\\n          planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\\n          planes[5].normal.multiplyScalar(-1);\\n        } else {\\n          console.error('THREE.SelectionBox: Unsupported camera type.');\\n        }\\n      }\\n    }, {\\n      key: \\\"searchChildInFrustum\\\",\\n      value: function searchChildInFrustum(frustum, object) {\\n        if (object.isMesh || object.isLine || object.isPoints) {\\n          if (object.material !== undefined) {\\n            if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\\n            center.copy(object.geometry.boundingSphere.center);\\n            center.applyMatrix4(object.matrixWorld);\\n\\n            if (frustum.containsPoint(center)) {\\n              this.collection.push(object);\\n            }\\n          }\\n        }\\n\\n        if (object.children.length > 0) {\\n          for (var x = 0; x < object.children.length; x++) {\\n            this.searchChildInFrustum(frustum, object.children[x]);\\n          }\\n        }\\n      }\\n    }]);\\n\\n    return SelectionBox;\\n  }();\\n\\n  return SelectionBox;\\n}();\\n\\nexports.SelectionBox = SelectionBox;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"prototype\",\"value\",\"SelectionBox\",\"_three\",\"frustum\",\"Frustum\",\"center\",\"Vector3\",\"tmpPoint\",\"vecNear\",\"vecTopLeft\",\"vecTopRight\",\"vecDownRight\",\"vecDownLeft\",\"vecFarTopLeft\",\"vecFarTopRight\",\"vecFarDownRight\",\"vecFarDownLeft\",\"vectemp1\",\"vectemp2\",\"vectemp3\",\"camera\",\"scene\",\"deep\",\"instance\",\"TypeError\",\"startPoint\",\"endPoint\",\"collection\",\"Number\",\"MAX_VALUE\",\"select\",\"updateFrustum\",\"searchChildInFrustum\",\"x\",\"EPSILON\",\"y\",\"updateProjectionMatrix\",\"updateMatrixWorld\",\"isPerspectiveCamera\",\"copy\",\"Math\",\"min\",\"max\",\"setFromMatrixPosition\",\"matrixWorld\",\"set\",\"unproject\",\"sub\",\"normalize\",\"multiplyScalar\",\"add\",\"planes\",\"setFromCoplanarPoints\",\"normal\",\"isOrthographicCamera\",\"left\",\"top\",\"right\",\"down\",\"console\",\"error\",\"object\",\"isMesh\",\"isLine\",\"isPoints\",\"undefined\",\"material\",\"geometry\",\"boundingSphere\",\"computeBoundingSphere\",\"applyMatrix4\",\"containsPoint\",\"push\",\"children\"]\n}\n"]