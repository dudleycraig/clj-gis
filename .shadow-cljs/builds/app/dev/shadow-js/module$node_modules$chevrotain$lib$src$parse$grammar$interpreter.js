["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/parse/grammar/interpreter.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$parse$grammar$interpreter=function(global,require,module,exports){function possiblePathsFrom(targetDef,maxLength,currPath){function getAlternativesForProd(definition){definition=possiblePathsFrom(definition.concat(utils_1.drop(targetDef,i+1)),maxLength,currPath);return result.concat(definition)}void 0===currPath&&(currPath=[]);currPath=utils_1.cloneArr(currPath);for(var result=[],i=0;currPath.length<maxLength&&i<targetDef.length;){var prod=targetDef[i];\nif(prod instanceof gast_public_1.Alternative||prod instanceof gast_public_1.NonTerminal)return getAlternativesForProd(prod.definition);if(prod instanceof gast_public_1.Option)result=getAlternativesForProd(prod.definition);else{if(prod instanceof gast_public_1.RepetitionMandatory)return prod=prod.definition.concat([new gast_public_1.Repetition({definition:prod.definition})]),getAlternativesForProd(prod);if(prod instanceof gast_public_1.RepetitionMandatoryWithSeparator)return prod=[new gast_public_1.Alternative({definition:prod.definition}),\nnew gast_public_1.Repetition({definition:[new gast_public_1.Terminal({terminalType:prod.separator})].concat(prod.definition)})],getAlternativesForProd(prod);if(prod instanceof gast_public_1.RepetitionWithSeparator)prod=prod.definition.concat([new gast_public_1.Repetition({definition:[new gast_public_1.Terminal({terminalType:prod.separator})].concat(prod.definition)})]),result=getAlternativesForProd(prod);else if(prod instanceof gast_public_1.Repetition)prod=prod.definition.concat([new gast_public_1.Repetition({definition:prod.definition})]),\nresult=getAlternativesForProd(prod);else{if(prod instanceof gast_public_1.Alternation)return utils_1.forEach(prod.definition,function(currAlt){!1===utils_1.isEmpty(currAlt.definition)&&(result=getAlternativesForProd(currAlt.definition))}),result;if(prod instanceof gast_public_1.Terminal)currPath.push(prod.terminalType);else throw Error(\"non exhaustive match\");}}i++}result.push({partialPath:currPath,suffixDef:utils_1.drop(targetDef,i)});return result}var __extends=this&&this.__extends||function(){var extendStatics=\nfunction(d$jscomp$0,b$jscomp$0){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)Object.prototype.hasOwnProperty.call(b,p)&&(d[p]=b[p])};return extendStatics(d$jscomp$0,b$jscomp$0)};return function(d,b){function __(){this.constructor=d}if(\"function\"!==typeof b&&null!==b)throw new TypeError(\"Class extends value \"+String(b)+\" is not a constructor or null\");extendStatics(d,b);d.prototype=null===b?Object.create(b):(__.prototype=\nb.prototype,new __)}}();Object.defineProperty(exports,\"__esModule\",{value:!0});exports.nextPossibleTokensAfter=exports.possiblePathsFrom=exports.NextTerminalAfterAtLeastOneSepWalker=exports.NextTerminalAfterAtLeastOneWalker=exports.NextTerminalAfterManySepWalker=exports.NextTerminalAfterManyWalker=exports.AbstractNextTerminalAfterProductionWalker=exports.NextAfterTokenWalker=exports.AbstractNextPossibleTokensWalker=void 0;global=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$rest\");\nvar utils_1=require(\"module$node_modules$$chevrotain$utils$lib$src$api\"),first_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$first\"),gast_public_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_public\");require=function(_super){function AbstractNextPossibleTokensWalker(topProd,path){var _this=_super.call(this)||this;_this.topProd=topProd;_this.path=path;_this.possibleTokTypes=[];_this.nextProductionName=\"\";_this.nextProductionOccurrence=0;_this.found=!1;\n_this.isAtEndOfPath=!1;return _this}__extends(AbstractNextPossibleTokensWalker,_super);AbstractNextPossibleTokensWalker.prototype.startWalking=function(){this.found=!1;if(this.path.ruleStack[0]!==this.topProd.name)throw Error(\"The path does not start with the walker's top Rule!\");this.ruleStack=utils_1.cloneArr(this.path.ruleStack).reverse();this.occurrenceStack=utils_1.cloneArr(this.path.occurrenceStack).reverse();this.ruleStack.pop();this.occurrenceStack.pop();this.updateExpectedNext();this.walk(this.topProd);\nreturn this.possibleTokTypes};AbstractNextPossibleTokensWalker.prototype.walk=function(prod,prevRest){void 0===prevRest&&(prevRest=[]);this.found||_super.prototype.walk.call(this,prod,prevRest)};AbstractNextPossibleTokensWalker.prototype.walkProdRef=function(refProd,currRest,prevRest){refProd.referencedRule.name===this.nextProductionName&&refProd.idx===this.nextProductionOccurrence&&(currRest=currRest.concat(prevRest),this.updateExpectedNext(),this.walk(refProd.referencedRule,currRest))};AbstractNextPossibleTokensWalker.prototype.updateExpectedNext=\nfunction(){utils_1.isEmpty(this.ruleStack)?(this.nextProductionName=\"\",this.nextProductionOccurrence=0,this.isAtEndOfPath=!0):(this.nextProductionName=this.ruleStack.pop(),this.nextProductionOccurrence=this.occurrenceStack.pop())};return AbstractNextPossibleTokensWalker}(global.RestWalker);exports.AbstractNextPossibleTokensWalker=require;require=function(_super){function NextAfterTokenWalker(topProd,path){topProd=_super.call(this,topProd,path)||this;topProd.path=path;topProd.nextTerminalName=\"\";topProd.nextTerminalOccurrence=\n0;topProd.nextTerminalName=topProd.path.lastTok.name;topProd.nextTerminalOccurrence=topProd.path.lastTokOccurrence;return topProd}__extends(NextAfterTokenWalker,_super);NextAfterTokenWalker.prototype.walkTerminal=function(terminal,currRest,prevRest){this.isAtEndOfPath&&terminal.terminalType.name===this.nextTerminalName&&terminal.idx===this.nextTerminalOccurrence&&!this.found&&(terminal=currRest.concat(prevRest),terminal=new gast_public_1.Alternative({definition:terminal}),this.possibleTokTypes=first_1.first(terminal),\nthis.found=!0)};return NextAfterTokenWalker}(require);exports.NextAfterTokenWalker=require;require=function(_super){function AbstractNextTerminalAfterProductionWalker(topRule,occurrence){var _this=_super.call(this)||this;_this.topRule=topRule;_this.occurrence=occurrence;_this.result={token:void 0,occurrence:void 0,isEndOfRule:void 0};return _this}__extends(AbstractNextTerminalAfterProductionWalker,_super);AbstractNextTerminalAfterProductionWalker.prototype.startWalking=function(){this.walk(this.topRule);\nreturn this.result};return AbstractNextTerminalAfterProductionWalker}(global.RestWalker);exports.AbstractNextTerminalAfterProductionWalker=require;global=function(_super){function NextTerminalAfterManyWalker(){return null!==_super&&_super.apply(this,arguments)||this}__extends(NextTerminalAfterManyWalker,_super);NextTerminalAfterManyWalker.prototype.walkMany=function(manyProd,currRest,prevRest){manyProd.idx===this.occurrence?(manyProd=utils_1.first(currRest.concat(prevRest)),this.result.isEndOfRule=\nvoid 0===manyProd,manyProd instanceof gast_public_1.Terminal&&(this.result.token=manyProd.terminalType,this.result.occurrence=manyProd.idx)):_super.prototype.walkMany.call(this,manyProd,currRest,prevRest)};return NextTerminalAfterManyWalker}(require);exports.NextTerminalAfterManyWalker=global;global=function(_super){function NextTerminalAfterManySepWalker(){return null!==_super&&_super.apply(this,arguments)||this}__extends(NextTerminalAfterManySepWalker,_super);NextTerminalAfterManySepWalker.prototype.walkManySep=\nfunction(manySepProd,currRest,prevRest){manySepProd.idx===this.occurrence?(manySepProd=utils_1.first(currRest.concat(prevRest)),this.result.isEndOfRule=void 0===manySepProd,manySepProd instanceof gast_public_1.Terminal&&(this.result.token=manySepProd.terminalType,this.result.occurrence=manySepProd.idx)):_super.prototype.walkManySep.call(this,manySepProd,currRest,prevRest)};return NextTerminalAfterManySepWalker}(require);exports.NextTerminalAfterManySepWalker=global;global=function(_super){function NextTerminalAfterAtLeastOneWalker(){return null!==\n_super&&_super.apply(this,arguments)||this}__extends(NextTerminalAfterAtLeastOneWalker,_super);NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne=function(atLeastOneProd,currRest,prevRest){atLeastOneProd.idx===this.occurrence?(atLeastOneProd=utils_1.first(currRest.concat(prevRest)),this.result.isEndOfRule=void 0===atLeastOneProd,atLeastOneProd instanceof gast_public_1.Terminal&&(this.result.token=atLeastOneProd.terminalType,this.result.occurrence=atLeastOneProd.idx)):_super.prototype.walkAtLeastOne.call(this,\natLeastOneProd,currRest,prevRest)};return NextTerminalAfterAtLeastOneWalker}(require);exports.NextTerminalAfterAtLeastOneWalker=global;require=function(_super){function NextTerminalAfterAtLeastOneSepWalker(){return null!==_super&&_super.apply(this,arguments)||this}__extends(NextTerminalAfterAtLeastOneSepWalker,_super);NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep=function(atleastOneSepProd,currRest,prevRest){atleastOneSepProd.idx===this.occurrence?(atleastOneSepProd=utils_1.first(currRest.concat(prevRest)),\nthis.result.isEndOfRule=void 0===atleastOneSepProd,atleastOneSepProd instanceof gast_public_1.Terminal&&(this.result.token=atleastOneSepProd.terminalType,this.result.occurrence=atleastOneSepProd.idx)):_super.prototype.walkAtLeastOneSep.call(this,atleastOneSepProd,currRest,prevRest)};return NextTerminalAfterAtLeastOneSepWalker}(require);exports.NextTerminalAfterAtLeastOneSepWalker=require;exports.possiblePathsFrom=possiblePathsFrom;exports.nextPossibleTokensAfter=function(initialDef,tokenVector,tokMatcher,\nmaxLookAhead){var EXIT_NON_TERMINAL_ARR=[\"EXIT_NONE_TERMINAL\"],foundCompletePath=!1,tokenVectorLength=tokenVector.length;maxLookAhead=tokenVectorLength-maxLookAhead-1;var result=[],possiblePaths=[];for(possiblePaths.push({idx:-1,def:initialDef,ruleStack:[],occurrenceStack:[]});!utils_1.isEmpty(possiblePaths);){var currPath=possiblePaths.pop();if(\"EXIT_ALTERNATIVE\"===currPath)foundCompletePath&&utils_1.last(possiblePaths).idx<=maxLookAhead&&possiblePaths.pop();else{var currDef=currPath.def,currIdx=\ncurrPath.idx;initialDef=currPath.ruleStack;currPath=currPath.occurrenceStack;if(!utils_1.isEmpty(currDef)){var prod=currDef[0];if(\"EXIT_NONE_TERMINAL\"===prod)initialDef={idx:currIdx,def:utils_1.drop(currDef),ruleStack:utils_1.dropRight(initialDef),occurrenceStack:utils_1.dropRight(currPath)},possiblePaths.push(initialDef);else if(prod instanceof gast_public_1.Terminal)if(currIdx<tokenVectorLength-1)currIdx+=1,tokMatcher(tokenVector[currIdx],prod.terminalType)&&(initialDef={idx:currIdx,def:utils_1.drop(currDef),\nruleStack:initialDef,occurrenceStack:currPath},possiblePaths.push(initialDef));else if(currIdx===tokenVectorLength-1)result.push({nextTokenType:prod.terminalType,nextTokenOccurrence:prod.idx,ruleStack:initialDef,occurrenceStack:currPath}),foundCompletePath=!0;else throw Error(\"non exhaustive match\");else if(prod instanceof gast_public_1.NonTerminal)initialDef=utils_1.cloneArr(initialDef),initialDef.push(prod.nonTerminalName),currPath=utils_1.cloneArr(currPath),currPath.push(prod.idx),initialDef={idx:currIdx,\ndef:prod.definition.concat(EXIT_NON_TERMINAL_ARR,utils_1.drop(currDef)),ruleStack:initialDef,occurrenceStack:currPath},possiblePaths.push(initialDef);else if(prod instanceof gast_public_1.Option){var nextPathWithout={idx:currIdx,def:utils_1.drop(currDef),ruleStack:initialDef,occurrenceStack:currPath};possiblePaths.push(nextPathWithout);possiblePaths.push(\"EXIT_ALTERNATIVE\");initialDef={idx:currIdx,def:prod.definition.concat(utils_1.drop(currDef)),ruleStack:initialDef,occurrenceStack:currPath};possiblePaths.push(initialDef)}else if(prod instanceof\ngast_public_1.RepetitionMandatory)nextPathWithout=new gast_public_1.Repetition({definition:prod.definition,idx:prod.idx}),prod=prod.definition.concat([nextPathWithout],utils_1.drop(currDef)),initialDef={idx:currIdx,def:prod,ruleStack:initialDef,occurrenceStack:currPath},possiblePaths.push(initialDef);else if(prod instanceof gast_public_1.RepetitionMandatoryWithSeparator)nextPathWithout=new gast_public_1.Terminal({terminalType:prod.separator}),nextPathWithout=new gast_public_1.Repetition({definition:[nextPathWithout].concat(prod.definition),\nidx:prod.idx}),prod=prod.definition.concat([nextPathWithout],utils_1.drop(currDef)),initialDef={idx:currIdx,def:prod,ruleStack:initialDef,occurrenceStack:currPath},possiblePaths.push(initialDef);else if(prod instanceof gast_public_1.RepetitionWithSeparator)nextPathWithout={idx:currIdx,def:utils_1.drop(currDef),ruleStack:initialDef,occurrenceStack:currPath},possiblePaths.push(nextPathWithout),possiblePaths.push(\"EXIT_ALTERNATIVE\"),nextPathWithout=new gast_public_1.Terminal({terminalType:prod.separator}),\nnextPathWithout=new gast_public_1.Repetition({definition:[nextPathWithout].concat(prod.definition),idx:prod.idx}),prod=prod.definition.concat([nextPathWithout],utils_1.drop(currDef)),initialDef={idx:currIdx,def:prod,ruleStack:initialDef,occurrenceStack:currPath},possiblePaths.push(initialDef);else if(prod instanceof gast_public_1.Repetition)nextPathWithout={idx:currIdx,def:utils_1.drop(currDef),ruleStack:initialDef,occurrenceStack:currPath},possiblePaths.push(nextPathWithout),possiblePaths.push(\"EXIT_ALTERNATIVE\"),\nnextPathWithout=new gast_public_1.Repetition({definition:prod.definition,idx:prod.idx}),prod=prod.definition.concat([nextPathWithout],utils_1.drop(currDef)),initialDef={idx:currIdx,def:prod,ruleStack:initialDef,occurrenceStack:currPath},possiblePaths.push(initialDef);else if(prod instanceof gast_public_1.Alternation)for(nextPathWithout=prod.definition.length-1;0<=nextPathWithout;nextPathWithout--){var currAltPath={idx:currIdx,def:prod.definition[nextPathWithout].definition.concat(utils_1.drop(currDef)),\nruleStack:initialDef,occurrenceStack:currPath};possiblePaths.push(currAltPath);possiblePaths.push(\"EXIT_ALTERNATIVE\")}else if(prod instanceof gast_public_1.Alternative)possiblePaths.push({idx:currIdx,def:prod.definition.concat(utils_1.drop(currDef)),ruleStack:initialDef,occurrenceStack:currPath});else if(prod instanceof gast_public_1.Rule)currDef=possiblePaths,nextPathWithout=currDef.push,initialDef=utils_1.cloneArr(initialDef),initialDef.push(prod.name),currPath=utils_1.cloneArr(currPath),currPath.push(1),\nnextPathWithout.call(currDef,{idx:currIdx,def:prod.definition,ruleStack:initialDef,occurrenceStack:currPath});else throw Error(\"non exhaustive match\");}}}return result}}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$parse$grammar$interpreter\"] = function(global,require,module,exports) {\n\"use strict\";\n/* istanbul ignore next */ var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nextPossibleTokensAfter = exports.possiblePathsFrom = exports.NextTerminalAfterAtLeastOneSepWalker = exports.NextTerminalAfterAtLeastOneWalker = exports.NextTerminalAfterManySepWalker = exports.NextTerminalAfterManyWalker = exports.AbstractNextTerminalAfterProductionWalker = exports.NextAfterTokenWalker = exports.AbstractNextPossibleTokensWalker = void 0;\nvar rest_1 = require(\"./rest\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar first_1 = require(\"./first\");\nvar gast_public_1 = require(\"./gast/gast_public\");\nvar AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextPossibleTokensWalker, _super);\n    function AbstractNextPossibleTokensWalker(topProd, path) {\n        var _this = _super.call(this) /* istanbul ignore next */ || this;\n        _this.topProd = topProd;\n        _this.path = path;\n        _this.possibleTokTypes = [];\n        _this.nextProductionName = \"\";\n        _this.nextProductionOccurrence = 0;\n        _this.found = false;\n        _this.isAtEndOfPath = false;\n        return _this;\n    }\n    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n        }\n        // immutable for the win\n        this.ruleStack = utils_1.cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = utils_1.cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    };\n    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n        if (prevRest === void 0) { prevRest = []; }\n        // stop scanning once we found the path\n        if (!this.found) {\n            _super.prototype.walk.call(this, prod, prevRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            var fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    };\n    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n        // need to consume the Terminal\n        if (utils_1.isEmpty(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    };\n    return AbstractNextPossibleTokensWalker;\n}(rest_1.RestWalker));\nexports.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;\nvar NextAfterTokenWalker = /** @class */ (function (_super) {\n    __extends(NextAfterTokenWalker, _super);\n    function NextAfterTokenWalker(topProd, path) {\n        var _this = _super.call(this, topProd, path) /* istanbul ignore next */ || this;\n        _this.path = path;\n        _this.nextTerminalName = \"\";\n        _this.nextTerminalOccurrence = 0;\n        _this.nextTerminalName = _this.path.lastTok.name;\n        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n        return _this;\n    }\n    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            var fullRest = currRest.concat(prevRest);\n            var restProd = new gast_public_1.Alternative({ definition: fullRest });\n            this.possibleTokTypes = first_1.first(restProd);\n            this.found = true;\n        }\n    };\n    return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker));\nexports.NextAfterTokenWalker = NextAfterTokenWalker;\n/**\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n * it never \"follows\" production refs\n */\nvar AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {\n    __extends(AbstractNextTerminalAfterProductionWalker, _super);\n    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n        var _this = _super.call(this) /* istanbul ignore next */ || this;\n        _this.topRule = topRule;\n        _this.occurrence = occurrence;\n        _this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined\n        };\n        return _this;\n    }\n    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n        this.walk(this.topRule);\n        return this.result;\n    };\n    return AbstractNextTerminalAfterProductionWalker;\n}(rest_1.RestWalker));\nexports.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;\nvar NextTerminalAfterManyWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManyWalker, _super);\n    function NextTerminalAfterManyWalker() {\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\n    }\n    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            var firstAfterMany = utils_1.first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof gast_public_1.Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexports.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;\nvar NextTerminalAfterManySepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterManySepWalker, _super);\n    function NextTerminalAfterManySepWalker() {\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\n    }\n    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            var firstAfterManySep = utils_1.first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof gast_public_1.Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexports.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;\nvar NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneWalker, _super);\n    function NextTerminalAfterAtLeastOneWalker() {\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\n    }\n    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            var firstAfterAtLeastOne = utils_1.first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof gast_public_1.Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexports.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;\n// TODO: reduce code duplication in the AfterWalkers\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {\n    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n    function NextTerminalAfterAtLeastOneSepWalker() {\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\n    }\n    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            var firstAfterfirstAfterAtLeastOneSep = utils_1.first(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof gast_public_1.Terminal) {\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n        }\n    };\n    return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker));\nexports.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;\nfunction possiblePathsFrom(targetDef, maxLength, currPath) {\n    if (currPath === void 0) { currPath = []; }\n    // avoid side effects\n    currPath = utils_1.cloneArr(currPath);\n    var result = [];\n    var i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat(utils_1.drop(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        var prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof gast_public_1.Alternative) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof gast_public_1.NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof gast_public_1.Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof gast_public_1.RepetitionMandatory) {\n            var newDef = prod.definition.concat([\n                new gast_public_1.Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\n            var newDef = [\n                new gast_public_1.Alternative({ definition: prod.definition }),\n                new gast_public_1.Repetition({\n                    definition: [new gast_public_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)\n                })\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\n            var newDef = prod.definition.concat([\n                new gast_public_1.Repetition({\n                    definition: [new gast_public_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof gast_public_1.Repetition) {\n            var newDef = prod.definition.concat([\n                new gast_public_1.Repetition({\n                    definition: prod.definition\n                })\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof gast_public_1.Alternation) {\n            utils_1.forEach(prod.definition, function (currAlt) {\n                // TODO: this is a limited check for empty alternatives\n                //   It would prevent a common case of infinite loops during parser initialization.\n                //   However **in-directly** empty alternatives may still cause issues.\n                if (utils_1.isEmpty(currAlt.definition) === false) {\n                    result = getAlternativesForProd(currAlt.definition);\n                }\n            });\n            return result;\n        }\n        else if (prod instanceof gast_public_1.Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: utils_1.drop(targetDef, i)\n    });\n    return result;\n}\nexports.possiblePathsFrom = possiblePathsFrom;\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n    // to avoid creating a new Array each time.\n    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n    var foundCompletePath = false;\n    var tokenVectorLength = tokenVector.length;\n    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    var result = [];\n    var possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: []\n    });\n    while (!utils_1.isEmpty(possiblePaths)) {\n        var currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                utils_1.last(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        var currDef = currPath.def;\n        var currIdx = currPath.idx;\n        var currRuleStack = currPath.ruleStack;\n        var currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if (utils_1.isEmpty(currDef)) {\n            continue;\n        }\n        var prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            var nextPath = {\n                idx: currIdx,\n                def: utils_1.drop(currDef),\n                ruleStack: utils_1.dropRight(currRuleStack),\n                occurrenceStack: utils_1.dropRight(currOccurrenceStack)\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof gast_public_1.Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                var nextIdx = currIdx + 1;\n                var actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    var nextPath = {\n                        idx: nextIdx,\n                        def: utils_1.drop(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        }\n        else if (prod instanceof gast_public_1.NonTerminal) {\n            var newRuleStack = utils_1.cloneArr(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            var newOccurrenceStack = utils_1.cloneArr(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            var nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, utils_1.drop(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof gast_public_1.Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: utils_1.drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat(utils_1.drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof gast_public_1.RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var secondIteration = new gast_public_1.Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], utils_1.drop(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            var separatorGast = new gast_public_1.Terminal({\n                terminalType: prod.separator\n            });\n            var secondIteration = new gast_public_1.Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([secondIteration], utils_1.drop(currDef));\n            var nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: utils_1.drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            var separatorGast = new gast_public_1.Terminal({\n                terminalType: prod.separator\n            });\n            var nthRepetition = new gast_public_1.Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], utils_1.drop(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof gast_public_1.Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            var nextPathWithout = {\n                idx: currIdx,\n                def: utils_1.drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            var nthRepetition = new gast_public_1.Repetition({\n                definition: prod.definition,\n                idx: prod.idx\n            });\n            var nextDef = prod.definition.concat([nthRepetition], utils_1.drop(currDef));\n            var nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof gast_public_1.Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (var i = prod.definition.length - 1; i >= 0; i--) {\n                var currAlt = prod.definition[i];\n                var currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat(utils_1.drop(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof gast_public_1.Alternative) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat(utils_1.drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n            });\n        }\n        else if (prod instanceof gast_public_1.Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error(\"non exhaustive match\");\n        }\n    }\n    return result;\n}\nexports.nextPossibleTokensAfter = nextPossibleTokensAfter;\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    var newRuleStack = utils_1.cloneArr(currRuleStack);\n    newRuleStack.push(topRule.name);\n    var newCurrOccurrenceStack = utils_1.cloneArr(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack\n    };\n}\n//# sourceMappingURL=interpreter.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$chevrotain$utils$lib$src$api","~$shadow.js","~$module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_public","~$module$node_modules$chevrotain$lib$src$parse$grammar$rest","~$module$node_modules$chevrotain$lib$src$parse$grammar$first"]],"~:properties",["^5",["NextTerminalAfterAtLeastOneWalker","possibleTokTypes","updateExpectedNext","token","nextProductionOccurrence","walkAtLeastOneSep","AbstractNextTerminalAfterProductionWalker","walkMany","NextAfterTokenWalker","prototype","nextProductionName","walkManySep","nextTokenOccurrence","isEndOfRule","found","__esModule","walkTerminal","path","NextTerminalAfterAtLeastOneSepWalker","occurrenceStack","nextTerminalOccurrence","possiblePathsFrom","isAtEndOfPath","walkAtLeastOne","nextTokenType","value","NextTerminalAfterManySepWalker","walk","ruleStack","definition","occurrence","partialPath","walkProdRef","NextTerminalAfterManyWalker","AbstractNextPossibleTokensWalker","suffixDef","__proto__","startWalking","nextPossibleTokensAfter","def","idx","nextTerminalName","result","constructor","topProd","topRule","terminalType"]],"~:compiled-at",1630917515692,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$parse$grammar$interpreter.js\",\n\"lineCount\":28,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/chevrotain/lib/src/parse/grammar/interpreter.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$parse$grammar$interpreter\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n/* istanbul ignore next */ var __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        if (typeof b !== \\\"function\\\" && b !== null)\\n            throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.nextPossibleTokensAfter = exports.possiblePathsFrom = exports.NextTerminalAfterAtLeastOneSepWalker = exports.NextTerminalAfterAtLeastOneWalker = exports.NextTerminalAfterManySepWalker = exports.NextTerminalAfterManyWalker = exports.AbstractNextTerminalAfterProductionWalker = exports.NextAfterTokenWalker = exports.AbstractNextPossibleTokensWalker = void 0;\\nvar rest_1 = require(\\\"./rest\\\");\\nvar utils_1 = require(\\\"@chevrotain/utils\\\");\\nvar first_1 = require(\\\"./first\\\");\\nvar gast_public_1 = require(\\\"./gast/gast_public\\\");\\nvar AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {\\n    __extends(AbstractNextPossibleTokensWalker, _super);\\n    function AbstractNextPossibleTokensWalker(topProd, path) {\\n        var _this = _super.call(this) /* istanbul ignore next */ || this;\\n        _this.topProd = topProd;\\n        _this.path = path;\\n        _this.possibleTokTypes = [];\\n        _this.nextProductionName = \\\"\\\";\\n        _this.nextProductionOccurrence = 0;\\n        _this.found = false;\\n        _this.isAtEndOfPath = false;\\n        return _this;\\n    }\\n    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\\n        this.found = false;\\n        if (this.path.ruleStack[0] !== this.topProd.name) {\\n            throw Error(\\\"The path does not start with the walker's top Rule!\\\");\\n        }\\n        // immutable for the win\\n        this.ruleStack = utils_1.cloneArr(this.path.ruleStack).reverse(); // intelij bug requires assertion\\n        this.occurrenceStack = utils_1.cloneArr(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\\n        // already verified that the first production is valid, we now seek the 2nd production\\n        this.ruleStack.pop();\\n        this.occurrenceStack.pop();\\n        this.updateExpectedNext();\\n        this.walk(this.topProd);\\n        return this.possibleTokTypes;\\n    };\\n    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\\n        if (prevRest === void 0) { prevRest = []; }\\n        // stop scanning once we found the path\\n        if (!this.found) {\\n            _super.prototype.walk.call(this, prod, prevRest);\\n        }\\n    };\\n    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\\n        // found the next production, need to keep walking in it\\n        if (refProd.referencedRule.name === this.nextProductionName &&\\n            refProd.idx === this.nextProductionOccurrence) {\\n            var fullRest = currRest.concat(prevRest);\\n            this.updateExpectedNext();\\n            this.walk(refProd.referencedRule, fullRest);\\n        }\\n    };\\n    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\\n        // need to consume the Terminal\\n        if (utils_1.isEmpty(this.ruleStack)) {\\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\\n            // really seeking is the last Terminal...\\n            this.nextProductionName = \\\"\\\";\\n            this.nextProductionOccurrence = 0;\\n            this.isAtEndOfPath = true;\\n        }\\n        else {\\n            this.nextProductionName = this.ruleStack.pop();\\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\\n        }\\n    };\\n    return AbstractNextPossibleTokensWalker;\\n}(rest_1.RestWalker));\\nexports.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;\\nvar NextAfterTokenWalker = /** @class */ (function (_super) {\\n    __extends(NextAfterTokenWalker, _super);\\n    function NextAfterTokenWalker(topProd, path) {\\n        var _this = _super.call(this, topProd, path) /* istanbul ignore next */ || this;\\n        _this.path = path;\\n        _this.nextTerminalName = \\\"\\\";\\n        _this.nextTerminalOccurrence = 0;\\n        _this.nextTerminalName = _this.path.lastTok.name;\\n        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\\n        return _this;\\n    }\\n    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\\n        if (this.isAtEndOfPath &&\\n            terminal.terminalType.name === this.nextTerminalName &&\\n            terminal.idx === this.nextTerminalOccurrence &&\\n            !this.found) {\\n            var fullRest = currRest.concat(prevRest);\\n            var restProd = new gast_public_1.Alternative({ definition: fullRest });\\n            this.possibleTokTypes = first_1.first(restProd);\\n            this.found = true;\\n        }\\n    };\\n    return NextAfterTokenWalker;\\n}(AbstractNextPossibleTokensWalker));\\nexports.NextAfterTokenWalker = NextAfterTokenWalker;\\n/**\\n * This walker only \\\"walks\\\" a single \\\"TOP\\\" level in the Grammar Ast, this means\\n * it never \\\"follows\\\" production refs\\n */\\nvar AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {\\n    __extends(AbstractNextTerminalAfterProductionWalker, _super);\\n    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\\n        var _this = _super.call(this) /* istanbul ignore next */ || this;\\n        _this.topRule = topRule;\\n        _this.occurrence = occurrence;\\n        _this.result = {\\n            token: undefined,\\n            occurrence: undefined,\\n            isEndOfRule: undefined\\n        };\\n        return _this;\\n    }\\n    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\\n        this.walk(this.topRule);\\n        return this.result;\\n    };\\n    return AbstractNextTerminalAfterProductionWalker;\\n}(rest_1.RestWalker));\\nexports.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;\\nvar NextTerminalAfterManyWalker = /** @class */ (function (_super) {\\n    __extends(NextTerminalAfterManyWalker, _super);\\n    function NextTerminalAfterManyWalker() {\\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\\n    }\\n    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\\n        if (manyProd.idx === this.occurrence) {\\n            var firstAfterMany = utils_1.first(currRest.concat(prevRest));\\n            this.result.isEndOfRule = firstAfterMany === undefined;\\n            if (firstAfterMany instanceof gast_public_1.Terminal) {\\n                this.result.token = firstAfterMany.terminalType;\\n                this.result.occurrence = firstAfterMany.idx;\\n            }\\n        }\\n        else {\\n            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\\n        }\\n    };\\n    return NextTerminalAfterManyWalker;\\n}(AbstractNextTerminalAfterProductionWalker));\\nexports.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;\\nvar NextTerminalAfterManySepWalker = /** @class */ (function (_super) {\\n    __extends(NextTerminalAfterManySepWalker, _super);\\n    function NextTerminalAfterManySepWalker() {\\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\\n    }\\n    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\\n        if (manySepProd.idx === this.occurrence) {\\n            var firstAfterManySep = utils_1.first(currRest.concat(prevRest));\\n            this.result.isEndOfRule = firstAfterManySep === undefined;\\n            if (firstAfterManySep instanceof gast_public_1.Terminal) {\\n                this.result.token = firstAfterManySep.terminalType;\\n                this.result.occurrence = firstAfterManySep.idx;\\n            }\\n        }\\n        else {\\n            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\\n        }\\n    };\\n    return NextTerminalAfterManySepWalker;\\n}(AbstractNextTerminalAfterProductionWalker));\\nexports.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;\\nvar NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {\\n    __extends(NextTerminalAfterAtLeastOneWalker, _super);\\n    function NextTerminalAfterAtLeastOneWalker() {\\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\\n    }\\n    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\\n        if (atLeastOneProd.idx === this.occurrence) {\\n            var firstAfterAtLeastOne = utils_1.first(currRest.concat(prevRest));\\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\\n            if (firstAfterAtLeastOne instanceof gast_public_1.Terminal) {\\n                this.result.token = firstAfterAtLeastOne.terminalType;\\n                this.result.occurrence = firstAfterAtLeastOne.idx;\\n            }\\n        }\\n        else {\\n            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\\n        }\\n    };\\n    return NextTerminalAfterAtLeastOneWalker;\\n}(AbstractNextTerminalAfterProductionWalker));\\nexports.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;\\n// TODO: reduce code duplication in the AfterWalkers\\nvar NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {\\n    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\\n    function NextTerminalAfterAtLeastOneSepWalker() {\\n        return _super !== null && _super.apply(this, arguments) /* istanbul ignore next */ || this;\\n    }\\n    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\\n        if (atleastOneSepProd.idx === this.occurrence) {\\n            var firstAfterfirstAfterAtLeastOneSep = utils_1.first(currRest.concat(prevRest));\\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\\n            if (firstAfterfirstAfterAtLeastOneSep instanceof gast_public_1.Terminal) {\\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\\n            }\\n        }\\n        else {\\n            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\\n        }\\n    };\\n    return NextTerminalAfterAtLeastOneSepWalker;\\n}(AbstractNextTerminalAfterProductionWalker));\\nexports.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;\\nfunction possiblePathsFrom(targetDef, maxLength, currPath) {\\n    if (currPath === void 0) { currPath = []; }\\n    // avoid side effects\\n    currPath = utils_1.cloneArr(currPath);\\n    var result = [];\\n    var i = 0;\\n    // TODO: avoid inner funcs\\n    function remainingPathWith(nextDef) {\\n        return nextDef.concat(utils_1.drop(targetDef, i + 1));\\n    }\\n    // TODO: avoid inner funcs\\n    function getAlternativesForProd(definition) {\\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\\n        return result.concat(alternatives);\\n    }\\n    /**\\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\\n     * following (rest) of the targetDef.\\n     *\\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\\n     * the optional production.\\n     */\\n    while (currPath.length < maxLength && i < targetDef.length) {\\n        var prod = targetDef[i];\\n        /* istanbul ignore else */\\n        if (prod instanceof gast_public_1.Alternative) {\\n            return getAlternativesForProd(prod.definition);\\n        }\\n        else if (prod instanceof gast_public_1.NonTerminal) {\\n            return getAlternativesForProd(prod.definition);\\n        }\\n        else if (prod instanceof gast_public_1.Option) {\\n            result = getAlternativesForProd(prod.definition);\\n        }\\n        else if (prod instanceof gast_public_1.RepetitionMandatory) {\\n            var newDef = prod.definition.concat([\\n                new gast_public_1.Repetition({\\n                    definition: prod.definition\\n                })\\n            ]);\\n            return getAlternativesForProd(newDef);\\n        }\\n        else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\\n            var newDef = [\\n                new gast_public_1.Alternative({ definition: prod.definition }),\\n                new gast_public_1.Repetition({\\n                    definition: [new gast_public_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)\\n                })\\n            ];\\n            return getAlternativesForProd(newDef);\\n        }\\n        else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\\n            var newDef = prod.definition.concat([\\n                new gast_public_1.Repetition({\\n                    definition: [new gast_public_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)\\n                })\\n            ]);\\n            result = getAlternativesForProd(newDef);\\n        }\\n        else if (prod instanceof gast_public_1.Repetition) {\\n            var newDef = prod.definition.concat([\\n                new gast_public_1.Repetition({\\n                    definition: prod.definition\\n                })\\n            ]);\\n            result = getAlternativesForProd(newDef);\\n        }\\n        else if (prod instanceof gast_public_1.Alternation) {\\n            utils_1.forEach(prod.definition, function (currAlt) {\\n                // TODO: this is a limited check for empty alternatives\\n                //   It would prevent a common case of infinite loops during parser initialization.\\n                //   However **in-directly** empty alternatives may still cause issues.\\n                if (utils_1.isEmpty(currAlt.definition) === false) {\\n                    result = getAlternativesForProd(currAlt.definition);\\n                }\\n            });\\n            return result;\\n        }\\n        else if (prod instanceof gast_public_1.Terminal) {\\n            currPath.push(prod.terminalType);\\n        }\\n        else {\\n            throw Error(\\\"non exhaustive match\\\");\\n        }\\n        i++;\\n    }\\n    result.push({\\n        partialPath: currPath,\\n        suffixDef: utils_1.drop(targetDef, i)\\n    });\\n    return result;\\n}\\nexports.possiblePathsFrom = possiblePathsFrom;\\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\\n    var EXIT_NON_TERMINAL = \\\"EXIT_NONE_TERMINAL\\\";\\n    // to avoid creating a new Array each time.\\n    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\\n    var EXIT_ALTERNATIVE = \\\"EXIT_ALTERNATIVE\\\";\\n    var foundCompletePath = false;\\n    var tokenVectorLength = tokenVector.length;\\n    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\\n    var result = [];\\n    var possiblePaths = [];\\n    possiblePaths.push({\\n        idx: -1,\\n        def: initialDef,\\n        ruleStack: [],\\n        occurrenceStack: []\\n    });\\n    while (!utils_1.isEmpty(possiblePaths)) {\\n        var currPath = possiblePaths.pop();\\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\\n        if (currPath === EXIT_ALTERNATIVE) {\\n            if (foundCompletePath &&\\n                utils_1.last(possiblePaths).idx <= minimalAlternativesIndex) {\\n                // remove irrelevant alternative\\n                possiblePaths.pop();\\n            }\\n            continue;\\n        }\\n        var currDef = currPath.def;\\n        var currIdx = currPath.idx;\\n        var currRuleStack = currPath.ruleStack;\\n        var currOccurrenceStack = currPath.occurrenceStack;\\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\\n        if (utils_1.isEmpty(currDef)) {\\n            continue;\\n        }\\n        var prod = currDef[0];\\n        /* istanbul ignore else */\\n        if (prod === EXIT_NON_TERMINAL) {\\n            var nextPath = {\\n                idx: currIdx,\\n                def: utils_1.drop(currDef),\\n                ruleStack: utils_1.dropRight(currRuleStack),\\n                occurrenceStack: utils_1.dropRight(currOccurrenceStack)\\n            };\\n            possiblePaths.push(nextPath);\\n        }\\n        else if (prod instanceof gast_public_1.Terminal) {\\n            /* istanbul ignore else */\\n            if (currIdx < tokenVectorLength - 1) {\\n                var nextIdx = currIdx + 1;\\n                var actualToken = tokenVector[nextIdx];\\n                if (tokMatcher(actualToken, prod.terminalType)) {\\n                    var nextPath = {\\n                        idx: nextIdx,\\n                        def: utils_1.drop(currDef),\\n                        ruleStack: currRuleStack,\\n                        occurrenceStack: currOccurrenceStack\\n                    };\\n                    possiblePaths.push(nextPath);\\n                }\\n                // end of the line\\n            }\\n            else if (currIdx === tokenVectorLength - 1) {\\n                // IGNORE ABOVE ELSE\\n                result.push({\\n                    nextTokenType: prod.terminalType,\\n                    nextTokenOccurrence: prod.idx,\\n                    ruleStack: currRuleStack,\\n                    occurrenceStack: currOccurrenceStack\\n                });\\n                foundCompletePath = true;\\n            }\\n            else {\\n                throw Error(\\\"non exhaustive match\\\");\\n            }\\n        }\\n        else if (prod instanceof gast_public_1.NonTerminal) {\\n            var newRuleStack = utils_1.cloneArr(currRuleStack);\\n            newRuleStack.push(prod.nonTerminalName);\\n            var newOccurrenceStack = utils_1.cloneArr(currOccurrenceStack);\\n            newOccurrenceStack.push(prod.idx);\\n            var nextPath = {\\n                idx: currIdx,\\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, utils_1.drop(currDef)),\\n                ruleStack: newRuleStack,\\n                occurrenceStack: newOccurrenceStack\\n            };\\n            possiblePaths.push(nextPath);\\n        }\\n        else if (prod instanceof gast_public_1.Option) {\\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\\n            var nextPathWithout = {\\n                idx: currIdx,\\n                def: utils_1.drop(currDef),\\n                ruleStack: currRuleStack,\\n                occurrenceStack: currOccurrenceStack\\n            };\\n            possiblePaths.push(nextPathWithout);\\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\\n            possiblePaths.push(EXIT_ALTERNATIVE);\\n            var nextPathWith = {\\n                idx: currIdx,\\n                def: prod.definition.concat(utils_1.drop(currDef)),\\n                ruleStack: currRuleStack,\\n                occurrenceStack: currOccurrenceStack\\n            };\\n            possiblePaths.push(nextPathWith);\\n        }\\n        else if (prod instanceof gast_public_1.RepetitionMandatory) {\\n            // TODO:(THE NEW operators here take a while...) (convert once?)\\n            var secondIteration = new gast_public_1.Repetition({\\n                definition: prod.definition,\\n                idx: prod.idx\\n            });\\n            var nextDef = prod.definition.concat([secondIteration], utils_1.drop(currDef));\\n            var nextPath = {\\n                idx: currIdx,\\n                def: nextDef,\\n                ruleStack: currRuleStack,\\n                occurrenceStack: currOccurrenceStack\\n            };\\n            possiblePaths.push(nextPath);\\n        }\\n        else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\\n            // TODO:(THE NEW operators here take a while...) (convert once?)\\n            var separatorGast = new gast_public_1.Terminal({\\n                terminalType: prod.separator\\n            });\\n            var secondIteration = new gast_public_1.Repetition({\\n                definition: [separatorGast].concat(prod.definition),\\n                idx: prod.idx\\n            });\\n            var nextDef = prod.definition.concat([secondIteration], utils_1.drop(currDef));\\n            var nextPath = {\\n                idx: currIdx,\\n                def: nextDef,\\n                ruleStack: currRuleStack,\\n                occurrenceStack: currOccurrenceStack\\n            };\\n            possiblePaths.push(nextPath);\\n        }\\n        else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\\n            var nextPathWithout = {\\n                idx: currIdx,\\n                def: utils_1.drop(currDef),\\n                ruleStack: currRuleStack,\\n                occurrenceStack: currOccurrenceStack\\n            };\\n            possiblePaths.push(nextPathWithout);\\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\\n            possiblePaths.push(EXIT_ALTERNATIVE);\\n            var separatorGast = new gast_public_1.Terminal({\\n                terminalType: prod.separator\\n            });\\n            var nthRepetition = new gast_public_1.Repetition({\\n                definition: [separatorGast].concat(prod.definition),\\n                idx: prod.idx\\n            });\\n            var nextDef = prod.definition.concat([nthRepetition], utils_1.drop(currDef));\\n            var nextPathWith = {\\n                idx: currIdx,\\n                def: nextDef,\\n                ruleStack: currRuleStack,\\n                occurrenceStack: currOccurrenceStack\\n            };\\n            possiblePaths.push(nextPathWith);\\n        }\\n        else if (prod instanceof gast_public_1.Repetition) {\\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\\n            var nextPathWithout = {\\n                idx: currIdx,\\n                def: utils_1.drop(currDef),\\n                ruleStack: currRuleStack,\\n                occurrenceStack: currOccurrenceStack\\n            };\\n            possiblePaths.push(nextPathWithout);\\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\\n            possiblePaths.push(EXIT_ALTERNATIVE);\\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\\n            var nthRepetition = new gast_public_1.Repetition({\\n                definition: prod.definition,\\n                idx: prod.idx\\n            });\\n            var nextDef = prod.definition.concat([nthRepetition], utils_1.drop(currDef));\\n            var nextPathWith = {\\n                idx: currIdx,\\n                def: nextDef,\\n                ruleStack: currRuleStack,\\n                occurrenceStack: currOccurrenceStack\\n            };\\n            possiblePaths.push(nextPathWith);\\n        }\\n        else if (prod instanceof gast_public_1.Alternation) {\\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\\n            for (var i = prod.definition.length - 1; i >= 0; i--) {\\n                var currAlt = prod.definition[i];\\n                var currAltPath = {\\n                    idx: currIdx,\\n                    def: currAlt.definition.concat(utils_1.drop(currDef)),\\n                    ruleStack: currRuleStack,\\n                    occurrenceStack: currOccurrenceStack\\n                };\\n                possiblePaths.push(currAltPath);\\n                possiblePaths.push(EXIT_ALTERNATIVE);\\n            }\\n        }\\n        else if (prod instanceof gast_public_1.Alternative) {\\n            possiblePaths.push({\\n                idx: currIdx,\\n                def: prod.definition.concat(utils_1.drop(currDef)),\\n                ruleStack: currRuleStack,\\n                occurrenceStack: currOccurrenceStack\\n            });\\n        }\\n        else if (prod instanceof gast_public_1.Rule) {\\n            // last because we should only encounter at most a single one of these per invocation.\\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\\n        }\\n        else {\\n            throw Error(\\\"non exhaustive match\\\");\\n        }\\n    }\\n    return result;\\n}\\nexports.nextPossibleTokensAfter = nextPossibleTokensAfter;\\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\\n    var newRuleStack = utils_1.cloneArr(currRuleStack);\\n    newRuleStack.push(topRule.name);\\n    var newCurrOccurrenceStack = utils_1.cloneArr(currOccurrenceStack);\\n    // top rule is always assumed to have been called with occurrence index 1\\n    newCurrOccurrenceStack.push(1);\\n    return {\\n        idx: currIdx,\\n        def: topRule.definition,\\n        ruleStack: newRuleStack,\\n        occurrenceStack: newCurrOccurrenceStack\\n    };\\n}\\n//# sourceMappingURL=interpreter.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"possiblePathsFrom\",\"targetDef\",\"maxLength\",\"currPath\",\"getAlternativesForProd\",\"definition\",\"alternatives\",\"concat\",\"utils_1\",\"drop\",\"i\",\"result\",\"cloneArr\",\"length\",\"prod\",\"gast_public_1\",\"Alternative\",\"NonTerminal\",\"Option\",\"RepetitionMandatory\",\"newDef\",\"Repetition\",\"RepetitionMandatoryWithSeparator\",\"Terminal\",\"terminalType\",\"separator\",\"RepetitionWithSeparator\",\"Alternation\",\"forEach\",\"currAlt\",\"isEmpty\",\"push\",\"Error\",\"partialPath\",\"suffixDef\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"Object\",\"setPrototypeOf\",\"__proto__\",\"Array\",\"p\",\"prototype\",\"hasOwnProperty\",\"call\",\"__\",\"constructor\",\"TypeError\",\"String\",\"create\",\"defineProperty\",\"value\",\"nextPossibleTokensAfter\",\"NextTerminalAfterAtLeastOneSepWalker\",\"NextTerminalAfterAtLeastOneWalker\",\"NextTerminalAfterManySepWalker\",\"NextTerminalAfterManyWalker\",\"AbstractNextTerminalAfterProductionWalker\",\"NextAfterTokenWalker\",\"AbstractNextPossibleTokensWalker\",\"rest_1\",\"first_1\",\"_super\",\"topProd\",\"path\",\"_this\",\"possibleTokTypes\",\"nextProductionName\",\"nextProductionOccurrence\",\"found\",\"isAtEndOfPath\",\"startWalking\",\"AbstractNextPossibleTokensWalker.prototype.startWalking\",\"ruleStack\",\"name\",\"reverse\",\"occurrenceStack\",\"pop\",\"updateExpectedNext\",\"walk\",\"AbstractNextPossibleTokensWalker.prototype.walk\",\"prevRest\",\"walkProdRef\",\"AbstractNextPossibleTokensWalker.prototype.walkProdRef\",\"refProd\",\"currRest\",\"referencedRule\",\"idx\",\"fullRest\",\"AbstractNextPossibleTokensWalker.prototype.updateExpectedNext\",\"RestWalker\",\"nextTerminalName\",\"nextTerminalOccurrence\",\"lastTok\",\"lastTokOccurrence\",\"walkTerminal\",\"NextAfterTokenWalker.prototype.walkTerminal\",\"terminal\",\"restProd\",\"first\",\"topRule\",\"occurrence\",\"token\",\"undefined\",\"isEndOfRule\",\"AbstractNextTerminalAfterProductionWalker.prototype.startWalking\",\"apply\",\"arguments\",\"walkMany\",\"NextTerminalAfterManyWalker.prototype.walkMany\",\"manyProd\",\"firstAfterMany\",\"walkManySep\",\"NextTerminalAfterManySepWalker.prototype.walkManySep\",\"manySepProd\",\"firstAfterManySep\",\"walkAtLeastOne\",\"NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne\",\"atLeastOneProd\",\"firstAfterAtLeastOne\",\"walkAtLeastOneSep\",\"NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep\",\"atleastOneSepProd\",\"firstAfterfirstAfterAtLeastOneSep\",\"initialDef\",\"tokenVector\",\"tokMatcher\",\"maxLookAhead\",\"EXIT_NON_TERMINAL_ARR\",\"EXIT_NON_TERMINAL\",\"foundCompletePath\",\"tokenVectorLength\",\"minimalAlternativesIndex\",\"possiblePaths\",\"def\",\"EXIT_ALTERNATIVE\",\"last\",\"currDef\",\"currIdx\",\"currRuleStack\",\"currOccurrenceStack\",\"nextPath\",\"dropRight\",\"actualToken\",\"nextIdx\",\"nextTokenType\",\"nextTokenOccurrence\",\"newRuleStack\",\"nonTerminalName\",\"newOccurrenceStack\",\"nextPathWithout\",\"nextPathWith\",\"secondIteration\",\"nextDef\",\"separatorGast\",\"nthRepetition\",\"currAltPath\",\"Rule\",\"newCurrOccurrenceStack\"]\n}\n"]