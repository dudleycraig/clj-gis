["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/nodes/accessors/ReflectNode.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$nodes$accessors$ReflectNode=function(global,require,module,exports){function ReflectNode(scope){_TempNode.TempNode.call(this,\"v3\");this.scope=scope||ReflectNode.CUBE}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ReflectNode=ReflectNode;var _TempNode=require(\"module$node_modules$three_stdlib$nodes$core$TempNode\"),_PositionNode=require(\"module$node_modules$three_stdlib$nodes$accessors$PositionNode\"),_NormalNode=require(\"module$node_modules$three_stdlib$nodes$accessors$NormalNode\");\nReflectNode.CUBE=\"cube\";ReflectNode.SPHERE=\"sphere\";ReflectNode.VECTOR=\"vector\";ReflectNode.prototype=Object.create(_TempNode.TempNode.prototype);ReflectNode.prototype.constructor=ReflectNode;ReflectNode.prototype.nodeType=\"Reflect\";ReflectNode.prototype.getUnique=function(builder){return!builder.context.viewNormal};ReflectNode.prototype.getType=function(){switch(this.scope){case ReflectNode.SPHERE:return\"v2\"}return this.type};ReflectNode.prototype.generate=function(builder,output){var isUnique=this.getUnique(builder);\nif(builder.isShader(\"fragment\")){switch(this.scope){case ReflectNode.VECTOR:var result=new _NormalNode.NormalNode(_NormalNode.NormalNode.VIEW);var roughnessNode=builder.context.roughness;result=result.build(builder,\"v3\");var viewPosition=(new _PositionNode.PositionNode(_PositionNode.PositionNode.VIEW)).build(builder,\"v3\");roughnessNode=roughnessNode?roughnessNode.build(builder,\"f\"):void 0;viewPosition=\"reflect( -normalize( \".concat(viewPosition,\" ), \").concat(result,\" )\");roughnessNode&&(viewPosition=\n\"normalize( mix( \".concat(viewPosition,\", \").concat(result,\", \").concat(roughnessNode,\" * \").concat(roughnessNode,\" ) )\"));result=\"inverseTransformDirection( \".concat(viewPosition,\", viewMatrix )\");isUnique&&(builder.addNodeCode(\"vec3 reflectVec \\x3d \".concat(result,\";\")),result=\"reflectVec\");break;case ReflectNode.CUBE:result=(new ReflectNode(ReflectNode.VECTOR)).build(builder,\"v3\");result=\"vec3( -\"+result+\".x, \"+result+\".yz )\";isUnique&&(builder.addNodeCode(\"vec3 reflectCubeVec \\x3d \".concat(result,\n\";\")),result=\"reflectCubeVec\");break;case ReflectNode.SPHERE:result=(new ReflectNode(ReflectNode.VECTOR)).build(builder,\"v3\"),result=\"normalize( ( viewMatrix * vec4( \"+result+\", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5\",isUnique&&(builder.addNodeCode(\"vec2 reflectSphereVec \\x3d \".concat(result,\";\")),result=\"reflectSphereVec\")}return builder.format(result,this.getType(builder),output)}console.warn(\"THREE.ReflectNode is not compatible with \"+builder.shader+\" shader.\");return builder.format(\"vec3( 0.0 )\",\nthis.type,output)};ReflectNode.prototype.toJSON=function(meta){var data=this.getJSONNode(meta);data||(data=this.createJSONNode(meta),data.scope=this.scope);return data}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$nodes$accessors$ReflectNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReflectNode = ReflectNode;\n\nvar _TempNode = require(\"../core/TempNode.js\");\n\nvar _PositionNode = require(\"./PositionNode.js\");\n\nvar _NormalNode = require(\"./NormalNode.js\");\n\nfunction ReflectNode(scope) {\n  _TempNode.TempNode.call(this, 'v3');\n\n  this.scope = scope || ReflectNode.CUBE;\n}\n\nReflectNode.CUBE = 'cube';\nReflectNode.SPHERE = 'sphere';\nReflectNode.VECTOR = 'vector';\nReflectNode.prototype = Object.create(_TempNode.TempNode.prototype);\nReflectNode.prototype.constructor = ReflectNode;\nReflectNode.prototype.nodeType = 'Reflect';\n\nReflectNode.prototype.getUnique = function (builder) {\n  return !builder.context.viewNormal;\n};\n\nReflectNode.prototype.getType = function ()\n/* builder */\n{\n  switch (this.scope) {\n    case ReflectNode.SPHERE:\n      return 'v2';\n  }\n\n  return this.type;\n};\n\nReflectNode.prototype.generate = function (builder, output) {\n  var isUnique = this.getUnique(builder);\n\n  if (builder.isShader('fragment')) {\n    var result;\n\n    switch (this.scope) {\n      case ReflectNode.VECTOR:\n        var viewNormalNode = new _NormalNode.NormalNode(_NormalNode.NormalNode.VIEW);\n        var roughnessNode = builder.context.roughness;\n        var viewNormal = viewNormalNode.build(builder, 'v3');\n        var viewPosition = new _PositionNode.PositionNode(_PositionNode.PositionNode.VIEW).build(builder, 'v3');\n        var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\n        var method = \"reflect( -normalize( \".concat(viewPosition, \" ), \").concat(viewNormal, \" )\");\n\n        if (roughness) {\n          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n          method = \"normalize( mix( \".concat(method, \", \").concat(viewNormal, \", \").concat(roughness, \" * \").concat(roughness, \" ) )\");\n        }\n\n        var code = \"inverseTransformDirection( \".concat(method, \", viewMatrix )\");\n\n        if (isUnique) {\n          builder.addNodeCode(\"vec3 reflectVec = \".concat(code, \";\"));\n          result = 'reflectVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.CUBE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\n\n        if (isUnique) {\n          builder.addNodeCode(\"vec3 reflectCubeVec = \".concat(code, \";\"));\n          result = 'reflectCubeVec';\n        } else {\n          result = code;\n        }\n\n        break;\n\n      case ReflectNode.SPHERE:\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n        var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\n\n        if (isUnique) {\n          builder.addNodeCode(\"vec2 reflectSphereVec = \".concat(code, \";\"));\n          result = 'reflectSphereVec';\n        } else {\n          result = code;\n        }\n\n        break;\n    }\n\n    return builder.format(result, this.getType(builder), output);\n  } else {\n    console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\n    return builder.format('vec3( 0.0 )', this.type, output);\n  }\n};\n\nReflectNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.scope = this.scope;\n  }\n\n  return data;\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three_stdlib$nodes$accessors$NormalNode","~$shadow.js","~$module$node_modules$three_stdlib$nodes$accessors$PositionNode","~$module$node_modules$three_stdlib$nodes$core$TempNode"]],"~:properties",["^5",["getType","prototype","__esModule","ReflectNode","generate","CUBE","VECTOR","nodeType","value","SPHERE","getUnique","scope","constructor","toJSON"]],"~:compiled-at",1630917515215,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$nodes$accessors$ReflectNode.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/nodes/accessors/ReflectNode.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$nodes$accessors$ReflectNode\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ReflectNode = ReflectNode;\\n\\nvar _TempNode = require(\\\"../core/TempNode.js\\\");\\n\\nvar _PositionNode = require(\\\"./PositionNode.js\\\");\\n\\nvar _NormalNode = require(\\\"./NormalNode.js\\\");\\n\\nfunction ReflectNode(scope) {\\n  _TempNode.TempNode.call(this, 'v3');\\n\\n  this.scope = scope || ReflectNode.CUBE;\\n}\\n\\nReflectNode.CUBE = 'cube';\\nReflectNode.SPHERE = 'sphere';\\nReflectNode.VECTOR = 'vector';\\nReflectNode.prototype = Object.create(_TempNode.TempNode.prototype);\\nReflectNode.prototype.constructor = ReflectNode;\\nReflectNode.prototype.nodeType = 'Reflect';\\n\\nReflectNode.prototype.getUnique = function (builder) {\\n  return !builder.context.viewNormal;\\n};\\n\\nReflectNode.prototype.getType = function ()\\n/* builder */\\n{\\n  switch (this.scope) {\\n    case ReflectNode.SPHERE:\\n      return 'v2';\\n  }\\n\\n  return this.type;\\n};\\n\\nReflectNode.prototype.generate = function (builder, output) {\\n  var isUnique = this.getUnique(builder);\\n\\n  if (builder.isShader('fragment')) {\\n    var result;\\n\\n    switch (this.scope) {\\n      case ReflectNode.VECTOR:\\n        var viewNormalNode = new _NormalNode.NormalNode(_NormalNode.NormalNode.VIEW);\\n        var roughnessNode = builder.context.roughness;\\n        var viewNormal = viewNormalNode.build(builder, 'v3');\\n        var viewPosition = new _PositionNode.PositionNode(_PositionNode.PositionNode.VIEW).build(builder, 'v3');\\n        var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\\n        var method = \\\"reflect( -normalize( \\\".concat(viewPosition, \\\" ), \\\").concat(viewNormal, \\\" )\\\");\\n\\n        if (roughness) {\\n          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\\n          method = \\\"normalize( mix( \\\".concat(method, \\\", \\\").concat(viewNormal, \\\", \\\").concat(roughness, \\\" * \\\").concat(roughness, \\\" ) )\\\");\\n        }\\n\\n        var code = \\\"inverseTransformDirection( \\\".concat(method, \\\", viewMatrix )\\\");\\n\\n        if (isUnique) {\\n          builder.addNodeCode(\\\"vec3 reflectVec = \\\".concat(code, \\\";\\\"));\\n          result = 'reflectVec';\\n        } else {\\n          result = code;\\n        }\\n\\n        break;\\n\\n      case ReflectNode.CUBE:\\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\\n        var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\\n\\n        if (isUnique) {\\n          builder.addNodeCode(\\\"vec3 reflectCubeVec = \\\".concat(code, \\\";\\\"));\\n          result = 'reflectCubeVec';\\n        } else {\\n          result = code;\\n        }\\n\\n        break;\\n\\n      case ReflectNode.SPHERE:\\n        var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\\n        var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\\n\\n        if (isUnique) {\\n          builder.addNodeCode(\\\"vec2 reflectSphereVec = \\\".concat(code, \\\";\\\"));\\n          result = 'reflectSphereVec';\\n        } else {\\n          result = code;\\n        }\\n\\n        break;\\n    }\\n\\n    return builder.format(result, this.getType(builder), output);\\n  } else {\\n    console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\\n    return builder.format('vec3( 0.0 )', this.type, output);\\n  }\\n};\\n\\nReflectNode.prototype.toJSON = function (meta) {\\n  var data = this.getJSONNode(meta);\\n\\n  if (!data) {\\n    data = this.createJSONNode(meta);\\n    data.scope = this.scope;\\n  }\\n\\n  return data;\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"ReflectNode\",\"scope\",\"_TempNode\",\"TempNode\",\"call\",\"CUBE\",\"Object\",\"defineProperty\",\"value\",\"_PositionNode\",\"_NormalNode\",\"SPHERE\",\"VECTOR\",\"prototype\",\"create\",\"constructor\",\"nodeType\",\"getUnique\",\"ReflectNode.prototype.getUnique\",\"builder\",\"context\",\"viewNormal\",\"getType\",\"ReflectNode.prototype.getType\",\"type\",\"generate\",\"ReflectNode.prototype.generate\",\"output\",\"isUnique\",\"isShader\",\"viewNormalNode\",\"NormalNode\",\"VIEW\",\"roughnessNode\",\"roughness\",\"build\",\"viewPosition\",\"PositionNode\",\"undefined\",\"method\",\"concat\",\"code\",\"addNodeCode\",\"result\",\"reflectVec\",\"format\",\"console\",\"warn\",\"shader\",\"toJSON\",\"ReflectNode.prototype.toJSON\",\"meta\",\"data\",\"getJSONNode\",\"createJSONNode\"]\n}\n"]