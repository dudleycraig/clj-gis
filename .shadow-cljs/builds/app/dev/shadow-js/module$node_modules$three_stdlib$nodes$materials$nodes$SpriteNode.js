["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/nodes/materials/nodes/SpriteNode.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$nodes$materials$nodes$SpriteNode=function(global,require,module,exports){function SpriteNode(){_Node.Node.call(this);this.color=new _ColorNode.ColorNode(15658734);this.spherical=!0}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.SpriteNode=SpriteNode;var _three=require(\"module$node_modules$three$build$three_module\"),_Node=require(\"module$node_modules$three_stdlib$nodes$core$Node\"),_ColorNode=require(\"module$node_modules$three_stdlib$nodes$inputs$ColorNode\");\nSpriteNode.prototype=Object.create(_Node.Node.prototype);SpriteNode.prototype.constructor=SpriteNode;SpriteNode.prototype.nodeType=\"Sprite\";SpriteNode.prototype.build=function(builder){builder.define(\"SPRITE\");builder.requires.lights=!1;builder.requires.transparent=void 0!==this.alpha;if(builder.isShader(\"vertex\")){var position=this.position?this.position.analyzeAndFlow(builder,\"v3\",{cache:\"position\"}):void 0;builder.mergeUniform(_three.UniformsUtils.merge([_three.UniformsLib.fog]));builder.addParsCode(\"#include \\x3cfog_pars_vertex\\x3e\\n#include \\x3clogdepthbuf_pars_vertex\\x3e\\n#include \\x3cclipping_planes_pars_vertex\\x3e\");\nbuilder=[\"#include \\x3cclipping_planes_fragment\\x3e\",\"#include \\x3cbegin_vertex\\x3e\"];position&&builder.push(position.code,position.result?\"transformed \\x3d \"+position.result+\";\":\"\");builder.push(\"#include \\x3cproject_vertex\\x3e\",\"#include \\x3cfog_vertex\\x3e\",\"mat4 modelViewMtx \\x3d modelViewMatrix;\",\"mat4 modelMtx \\x3d modelMatrix;\",\"modelMtx[3][0] \\x3d 0.0;\",\"modelMtx[3][1] \\x3d 0.0;\",\"modelMtx[3][2] \\x3d 0.0;\");this.spherical||builder.push(\"modelMtx[1][1] \\x3d 1.0;\");builder.push(\"modelViewMtx[0][0] \\x3d 1.0;\",\n\"modelViewMtx[0][1] \\x3d 0.0;\",\"modelViewMtx[0][2] \\x3d 0.0;\");this.spherical&&builder.push(\"modelViewMtx[1][0] \\x3d 0.0;\",\"modelViewMtx[1][1] \\x3d 1.0;\",\"modelViewMtx[1][2] \\x3d 0.0;\");builder.push(\"modelViewMtx[2][0] \\x3d 0.0;\",\"modelViewMtx[2][1] \\x3d 0.0;\",\"modelViewMtx[2][2] \\x3d 1.0;\",\"gl_Position \\x3d projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );\",\"#include \\x3clogdepthbuf_vertex\\x3e\",\"#include \\x3cclipping_planes_vertex\\x3e\",\"#include \\x3cfog_vertex\\x3e\")}else{builder.addParsCode(\"#include \\x3cfog_pars_fragment\\x3e\\n#include \\x3clogdepthbuf_pars_fragment\\x3e\\n#include \\x3cclipping_planes_pars_fragment\\x3e\");\nbuilder.addCode(\"#include \\x3cclipping_planes_fragment\\x3e\\n#include \\x3clogdepthbuf_fragment\\x3e\");this.mask&&this.mask.analyze(builder);this.alpha&&this.alpha.analyze(builder);this.color.analyze(builder,{slot:\"color\"});position=this.mask?this.mask.flow(builder,\"b\"):void 0;var alpha=this.alpha?this.alpha.flow(builder,\"f\"):void 0,color=this.color.flow(builder,\"c\",{slot:\"color\"});builder=[];position&&builder.push(position.code,\"if ( ! \"+position.result+\" ) discard;\");alpha?builder.push(alpha.code,\n\"#ifdef ALPHATEST\",\"if ( \"+alpha.result+\" \\x3c\\x3d ALPHATEST ) discard;\",\"#endif\",color.code,\"gl_FragColor \\x3d vec4( \"+color.result+\", \"+alpha.result+\" );\"):builder.push(color.code,\"gl_FragColor \\x3d vec4( \"+color.result+\", 1.0 );\");builder.push(\"#include \\x3ctonemapping_fragment\\x3e\",\"#include \\x3cencodings_fragment\\x3e\",\"#include \\x3cfog_fragment\\x3e\")}return builder.join(\"\\n\")};SpriteNode.prototype.copy=function(source){_Node.Node.prototype.copy.call(this,source);source.position&&(this.position=\nsource.position);this.color=source.color;void 0!==source.spherical&&(this.spherical=source.spherical);source.mask&&(this.mask=source.mask);source.alpha&&(this.alpha=source.alpha);return this};SpriteNode.prototype.toJSON=function(meta){var data=this.getJSONNode(meta);data||(data=this.createJSONNode(meta),this.position&&(data.position=this.position.toJSON(meta).uuid),data.color=this.color.toJSON(meta).uuid,!1===this.spherical&&(data.spherical=!1),this.mask&&(data.mask=this.mask.toJSON(meta).uuid),this.alpha&&\n(data.alpha=this.alpha.toJSON(meta).uuid));return data}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$nodes$materials$nodes$SpriteNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SpriteNode = SpriteNode;\n\nvar _three = require(\"three\");\n\nvar _Node = require(\"../../core/Node.js\");\n\nvar _ColorNode = require(\"../../inputs/ColorNode.js\");\n\nfunction SpriteNode() {\n  _Node.Node.call(this);\n\n  this.color = new _ColorNode.ColorNode(0xeeeeee);\n  this.spherical = true;\n}\n\nSpriteNode.prototype = Object.create(_Node.Node.prototype);\nSpriteNode.prototype.constructor = SpriteNode;\nSpriteNode.prototype.nodeType = 'Sprite';\n\nSpriteNode.prototype.build = function (builder) {\n  var output;\n  builder.define('SPRITE');\n  builder.requires.lights = false;\n  builder.requires.transparent = this.alpha !== undefined;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(_three.UniformsUtils.merge([_three.UniformsLib.fog]));\n    builder.addParsCode(['#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    output = ['#include <clipping_planes_fragment>', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('#include <project_vertex>', '#include <fog_vertex>', 'mat4 modelViewMtx = modelViewMatrix;', 'mat4 modelMtx = modelMatrix;', // ignore position from modelMatrix (use vary position)\n    'modelMtx[3][0] = 0.0;', 'modelMtx[3][1] = 0.0;', 'modelMtx[3][2] = 0.0;');\n\n    if (!this.spherical) {\n      output.push('modelMtx[1][1] = 1.0;');\n    }\n\n    output.push( // http://www.geeks3d.com/20140807/billboarding-vertex-shader-glsl/\n    // First colunm.\n    'modelViewMtx[0][0] = 1.0;', 'modelViewMtx[0][1] = 0.0;', 'modelViewMtx[0][2] = 0.0;');\n\n    if (this.spherical) {\n      output.push( // Second colunm.\n      'modelViewMtx[1][0] = 0.0;', 'modelViewMtx[1][1] = 1.0;', 'modelViewMtx[1][2] = 0.0;');\n    }\n\n    output.push( // Thrid colunm.\n    'modelViewMtx[2][0] = 0.0;', 'modelViewMtx[2][1] = 0.0;', 'modelViewMtx[2][2] = 1.0;', 'gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '#include <fog_vertex>');\n  } else {\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>'].join('\\n'));\n    builder.addCode(['#include <clipping_planes_fragment>', '#include <logdepthbuf_fragment>'].join('\\n')); // analyze all nodes to reuse generate codes\n\n    if (this.mask) this.mask.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    }); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined,\n        alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined,\n        color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    }),\n        output = [];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif', color.code, 'gl_FragColor = vec4( ' + color.result + ', ' + alpha.result + ' );');\n    } else {\n      output.push(color.code, 'gl_FragColor = vec4( ' + color.result + ', 1.0 );');\n    }\n\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>');\n  }\n\n  return output.join('\\n');\n};\n\nSpriteNode.prototype.copy = function (source) {\n  _Node.Node.prototype.copy.call(this, source); // vertex\n\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  if (source.spherical !== undefined) this.spherical = source.spherical;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  return this;\n};\n\nSpriteNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    if (this.spherical === false) data.spherical = false;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$three_stdlib$nodes$inputs$ColorNode","~$module$node_modules$three_stdlib$nodes$core$Node"]],"~:properties",["^5",["spherical","copy","prototype","transparent","lights","slot","__esModule","cache","position","nodeType","value","build","SpriteNode","alpha","color","mask","constructor","toJSON"]],"~:compiled-at",1630917515249,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$nodes$materials$nodes$SpriteNode.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/nodes/materials/nodes/SpriteNode.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$nodes$materials$nodes$SpriteNode\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.SpriteNode = SpriteNode;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _Node = require(\\\"../../core/Node.js\\\");\\n\\nvar _ColorNode = require(\\\"../../inputs/ColorNode.js\\\");\\n\\nfunction SpriteNode() {\\n  _Node.Node.call(this);\\n\\n  this.color = new _ColorNode.ColorNode(0xeeeeee);\\n  this.spherical = true;\\n}\\n\\nSpriteNode.prototype = Object.create(_Node.Node.prototype);\\nSpriteNode.prototype.constructor = SpriteNode;\\nSpriteNode.prototype.nodeType = 'Sprite';\\n\\nSpriteNode.prototype.build = function (builder) {\\n  var output;\\n  builder.define('SPRITE');\\n  builder.requires.lights = false;\\n  builder.requires.transparent = this.alpha !== undefined;\\n\\n  if (builder.isShader('vertex')) {\\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\\n      cache: 'position'\\n    }) : undefined;\\n    builder.mergeUniform(_three.UniformsUtils.merge([_three.UniformsLib.fog]));\\n    builder.addParsCode(['#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\\\n'));\\n    output = ['#include <clipping_planes_fragment>', '#include <begin_vertex>'];\\n\\n    if (position) {\\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\\n    }\\n\\n    output.push('#include <project_vertex>', '#include <fog_vertex>', 'mat4 modelViewMtx = modelViewMatrix;', 'mat4 modelMtx = modelMatrix;', // ignore position from modelMatrix (use vary position)\\n    'modelMtx[3][0] = 0.0;', 'modelMtx[3][1] = 0.0;', 'modelMtx[3][2] = 0.0;');\\n\\n    if (!this.spherical) {\\n      output.push('modelMtx[1][1] = 1.0;');\\n    }\\n\\n    output.push( // http://www.geeks3d.com/20140807/billboarding-vertex-shader-glsl/\\n    // First colunm.\\n    'modelViewMtx[0][0] = 1.0;', 'modelViewMtx[0][1] = 0.0;', 'modelViewMtx[0][2] = 0.0;');\\n\\n    if (this.spherical) {\\n      output.push( // Second colunm.\\n      'modelViewMtx[1][0] = 0.0;', 'modelViewMtx[1][1] = 1.0;', 'modelViewMtx[1][2] = 0.0;');\\n    }\\n\\n    output.push( // Thrid colunm.\\n    'modelViewMtx[2][0] = 0.0;', 'modelViewMtx[2][1] = 0.0;', 'modelViewMtx[2][2] = 1.0;', 'gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '#include <fog_vertex>');\\n  } else {\\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>'].join('\\\\n'));\\n    builder.addCode(['#include <clipping_planes_fragment>', '#include <logdepthbuf_fragment>'].join('\\\\n')); // analyze all nodes to reuse generate codes\\n\\n    if (this.mask) this.mask.analyze(builder);\\n    if (this.alpha) this.alpha.analyze(builder);\\n    this.color.analyze(builder, {\\n      slot: 'color'\\n    }); // build code\\n\\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined,\\n        alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined,\\n        color = this.color.flow(builder, 'c', {\\n      slot: 'color'\\n    }),\\n        output = [];\\n\\n    if (mask) {\\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\\n    }\\n\\n    if (alpha) {\\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif', color.code, 'gl_FragColor = vec4( ' + color.result + ', ' + alpha.result + ' );');\\n    } else {\\n      output.push(color.code, 'gl_FragColor = vec4( ' + color.result + ', 1.0 );');\\n    }\\n\\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>');\\n  }\\n\\n  return output.join('\\\\n');\\n};\\n\\nSpriteNode.prototype.copy = function (source) {\\n  _Node.Node.prototype.copy.call(this, source); // vertex\\n\\n\\n  if (source.position) this.position = source.position; // fragment\\n\\n  this.color = source.color;\\n  if (source.spherical !== undefined) this.spherical = source.spherical;\\n  if (source.mask) this.mask = source.mask;\\n  if (source.alpha) this.alpha = source.alpha;\\n  return this;\\n};\\n\\nSpriteNode.prototype.toJSON = function (meta) {\\n  var data = this.getJSONNode(meta);\\n\\n  if (!data) {\\n    data = this.createJSONNode(meta); // vertex\\n\\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\\n\\n    data.color = this.color.toJSON(meta).uuid;\\n    if (this.spherical === false) data.spherical = false;\\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\\n  }\\n\\n  return data;\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"SpriteNode\",\"_Node\",\"Node\",\"call\",\"color\",\"_ColorNode\",\"ColorNode\",\"spherical\",\"Object\",\"defineProperty\",\"value\",\"_three\",\"prototype\",\"create\",\"constructor\",\"nodeType\",\"build\",\"SpriteNode.prototype.build\",\"builder\",\"define\",\"requires\",\"lights\",\"transparent\",\"undefined\",\"alpha\",\"isShader\",\"position\",\"analyzeAndFlow\",\"cache\",\"mergeUniform\",\"UniformsUtils\",\"merge\",\"UniformsLib\",\"fog\",\"addParsCode\",\"output\",\"push\",\"code\",\"result\",\"addCode\",\"mask\",\"analyze\",\"slot\",\"flow\",\"join\",\"copy\",\"SpriteNode.prototype.copy\",\"source\",\"toJSON\",\"SpriteNode.prototype.toJSON\",\"meta\",\"data\",\"getJSONNode\",\"createJSONNode\",\"uuid\"]\n}\n"]