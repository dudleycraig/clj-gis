["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/AssimpLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$AssimpLoader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.AssimpLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(manager){_three.Loader.call(this,manager)};exports.AssimpLoader=global;global.prototype=Object.assign(Object.create(_three.Loader.prototype),{constructor:global,load:function(url,onLoad,onProgress,onError){var scope=this,path=\n\"\"===scope.path?_three.LoaderUtils.extractUrlBase(url):scope.path,loader=new _three.FileLoader(scope.manager);loader.setPath(scope.path);loader.setResponseType(\"arraybuffer\");loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(buffer){try{onLoad(scope.parse(buffer,path))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}},onProgress,onError)},parse:function(buffer,path){function cloneTreeToBones(root,scene){var rootBone=\nnew _three.Bone;rootBone.matrix.copy(root.matrix);rootBone.matrixWorld.copy(root.matrixWorld);rootBone.position.copy(root.position);rootBone.quaternion.copy(root.quaternion);rootBone.scale.copy(root.scale);scene.nodeCount++;rootBone.name=\"bone_\"+root.name+scene.nodeCount.toString();scene.nodeToBoneMap[root.name]||(scene.nodeToBoneMap[root.name]=[]);scene.nodeToBoneMap[root.name].push(rootBone);for(var i in root.children){var child=cloneTreeToBones(root.children[i],scene);rootBone.add(child)}return rootBone}\nfunction sortWeights(indexes,weights){for(var pairs=[],i=0;i<indexes.length;i++)pairs.push({i:indexes[i],w:weights[i]});for(pairs.sort(function(a,b){return b.w-a.w});4>pairs.length;)pairs.push({i:0,w:0});4<pairs.length&&(pairs.length=4);for(var _i=i=0;4>_i;_i++)i+=pairs[_i].w*pairs[_i].w;i=Math.sqrt(i);for(_i=0;4>_i;_i++)pairs[_i].w/=i,indexes[_i]=pairs[_i].i,weights[_i]=pairs[_i].w}function findMatchingBone(root,name){if(0==root.name.indexOf(\"bone_\"+name))return root;for(var i in root.children){var ret=\nfindMatchingBone(root.children[i],name);if(ret)return ret}}function aiMesh(){this.mMaterialIndex=this.mNumBones=this.mNumFaces=this.mNumVertices=this.mPrimitiveTypes=0;this.mVertices=[];this.mNormals=[];this.mTangents=[];this.mBitangents=[];this.mColors=[[]];this.mTextureCoords=[[]];this.mFaces=[];this.mBones=[];this.hookupSkeletons=function(scene){if(0!=this.mBones.length){for(var allBones=[],offsetMatrix=[],skeletonRoot=scene.findNode(this.mBones[0].mName);skeletonRoot.mParent&&skeletonRoot.mParent.isBone;)skeletonRoot=\nskeletonRoot.mParent;skeletonRoot=skeletonRoot.toTHREE(scene);skeletonRoot=cloneTreeToBones(skeletonRoot,scene);this.threeNode.add(skeletonRoot);for(var i=0;i<this.mBones.length;i++){var bone=findMatchingBone(skeletonRoot,this.mBones[i].mName);if(!bone){skeletonRoot=scene.findNode(this.mBones[i].mName);if(!skeletonRoot)return;skeletonRoot=skeletonRoot.toTHREE(scene);skeletonRoot=cloneTreeToBones(skeletonRoot,scene);this.threeNode.add(skeletonRoot);bone=findMatchingBone(skeletonRoot,this.mBones[i].mName)}allBones.push(bone);\noffsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE())}scene=new _three.Skeleton(allBones,offsetMatrix);this.threeNode.bind(scene,new _three.Matrix4);this.threeNode.material.skinning=!0}};this.toTHREE=function(scene){if(this.threeNode)return this.threeNode;var geometry=new _three.BufferGeometry;scene=scene.mMaterials[this.mMaterialIndex]?scene.mMaterials[this.mMaterialIndex].toTHREE(scene):new _three.MeshLambertMaterial;geometry.setIndex(new _three.BufferAttribute(new Uint32Array(this.mIndexArray),\n1));geometry.setAttribute(\"position\",new _three.BufferAttribute(this.mVertexBuffer,3));this.mNormalBuffer&&0<this.mNormalBuffer.length&&geometry.setAttribute(\"normal\",new _three.BufferAttribute(this.mNormalBuffer,3));this.mColorBuffer&&0<this.mColorBuffer.length&&geometry.setAttribute(\"color\",new _three.BufferAttribute(this.mColorBuffer,4));this.mTexCoordsBuffers[0]&&0<this.mTexCoordsBuffers[0].length&&geometry.setAttribute(\"uv\",new _three.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]),\n2));this.mTexCoordsBuffers[1]&&0<this.mTexCoordsBuffers[1].length&&geometry.setAttribute(\"uv1\",new _three.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]),2));this.mTangentBuffer&&0<this.mTangentBuffer.length&&geometry.setAttribute(\"tangents\",new _three.BufferAttribute(this.mTangentBuffer,3));this.mBitangentBuffer&&0<this.mBitangentBuffer.length&&geometry.setAttribute(\"bitangents\",new _three.BufferAttribute(this.mBitangentBuffer,3));if(0<this.mBones.length){for(var weights=[],bones=[],\ni=0;i<this.mBones.length;i++)for(var j=0;j<this.mBones[i].mWeights.length;j++){var weight=this.mBones[i].mWeights[j];weight&&(weights[weight.mVertexId]||(weights[weight.mVertexId]=[]),bones[weight.mVertexId]||(bones[weight.mVertexId]=[]),weights[weight.mVertexId].push(weight.mWeight),bones[weight.mVertexId].push(parseInt(i)))}for(var _i3 in bones)sortWeights(bones[_i3],weights[_i3]);_i3=[];i=[];for(j=0;j<weights.length;j++)for(weight=0;4>weight;weight++)weights[j]&&bones[j]?(_i3.push(weights[j][weight]),\ni.push(bones[j][weight])):(_i3.push(0),i.push(0));geometry.setAttribute(\"skinWeight\",new _three.BufferAttribute(new Float32Array(_i3),4));geometry.setAttribute(\"skinIndex\",new _three.BufferAttribute(new Float32Array(i),4))}var mesh;0==this.mBones.length&&(mesh=new _three.Mesh(geometry,scene));0<this.mBones.length&&(mesh=new _three.SkinnedMesh(geometry,scene),mesh.normalizeSkinWeights());return this.threeNode=mesh}}function aiFace(){this.mNumIndices=0;this.mIndices=[]}function aiVector3D(){this.z=\nthis.y=this.x=0;this.toTHREE=function(){return new _three.Vector3(this.x,this.y,this.z)}}function aiColor3D(){this.a=this.b=this.g=this.r=0;this.toTHREE=function(){return new _three.Color(this.r,this.g,this.b)}}function aiQuaternion(){this.w=this.z=this.y=this.x=0;this.toTHREE=function(){return new _three.Quaternion(this.x,this.y,this.z,this.w)}}function aiVertexWeight(){this.mWeight=this.mVertexId=0}function aiString(){this.data=[];this.toString=function(){var str=\"\";this.data.forEach(function(i){str+=\nString.fromCharCode(i)});return str.replace(/[^\\x20-\\x7E]+/g,\"\")}}function aiVectorKey(){this.mTime=0;this.mValue=null}function aiQuatKey(){this.mTime=0;this.mValue=null}function aiNode(){this.mName=\"\";this.mTransformation=[];this.mNumMeshes=this.mNumChildren=0;this.mMeshes=[];this.mChildren=[];this.toTHREE=function(scene){if(this.threeNode)return this.threeNode;var o=new _three.Object3D;o.name=this.mName;o.matrix=this.mTransformation.toTHREE();for(var i=0;i<this.mChildren.length;i++)o.add(this.mChildren[i].toTHREE(scene));\nfor(i=0;i<this.mMeshes.length;i++)o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));this.threeNode=o;o.matrix.decompose(o.position,o.quaternion,o.scale);return o}}function aiBone(){this.mName=\"\";this.mOffsetMatrix=this.mNumWeights=0}function aiMaterialProperty(){this.mKey=\"\";this.mIndex=this.mSemantic=0;this.mData=[];this.mType=this.mDataLength=0;this.dataAsColor=function(){var array=(new Uint8Array(this.mData)).buffer,reader=new DataView(array);array=reader.getFloat32(0,!0);var g=reader.getFloat32(4,\n!0);reader=reader.getFloat32(8,!0);return new _three.Color(array,g,reader)};this.dataAsFloat=function(){var array=(new Uint8Array(this.mData)).buffer;return(new DataView(array)).getFloat32(0,!0)};this.dataAsBool=function(){var array=(new Uint8Array(this.mData)).buffer;return!!(new DataView(array)).getFloat32(0,!0)};this.dataAsString=function(){var s=new aiString;s.data=this.mData;return s.toString()};this.dataAsMap=function(){var s=new aiString;s.data=this.mData;s=s.toString();s=s.replace(/\\\\/g,\"/\");\n-1!=s.indexOf(\"/\")&&(s=s.substr(s.lastIndexOf(\"/\")+1));return textureLoader.load(s)}}function aiMaterial(){this.mNumProperties=this.mNumAllocated=0;this.mProperties=[];this.toTHREE=function(){for(var mat=new _three.MeshPhongMaterial,i=0;i<this.mProperties.length;i++)if(\"float\"==nameTypeMapping[this.mProperties[i].mKey]&&(mat[namePropMapping[this.mProperties[i].mKey]]=this.mProperties[i].dataAsFloat()),\"color\"==nameTypeMapping[this.mProperties[i].mKey]&&(mat[namePropMapping[this.mProperties[i].mKey]]=\nthis.mProperties[i].dataAsColor()),\"bool\"==nameTypeMapping[this.mProperties[i].mKey]&&(mat[namePropMapping[this.mProperties[i].mKey]]=this.mProperties[i].dataAsBool()),\"string\"==nameTypeMapping[this.mProperties[i].mKey]&&(mat[namePropMapping[this.mProperties[i].mKey]]=this.mProperties[i].dataAsString()),\"map\"==nameTypeMapping[this.mProperties[i].mKey]){var prop=this.mProperties[i];1==prop.mSemantic&&(mat.map=this.mProperties[i].dataAsMap());6==prop.mSemantic&&(mat.normalMap=this.mProperties[i].dataAsMap());\n10==prop.mSemantic&&(mat.lightMap=this.mProperties[i].dataAsMap());8==prop.mSemantic&&(mat.alphaMap=this.mProperties[i].dataAsMap())}mat.ambient.r=.53;mat.ambient.g=.53;mat.ambient.b=.53;mat.color.r=1;mat.color.g=1;mat.color.b=1;return mat}}function veclerp(v1,v2,l){var v=new _three.Vector3,lm1=1-l;v.x=v1.x*l+v2.x*lm1;v.y=v1.y*l+v2.y*lm1;v.z=v1.z*l+v2.z*lm1;return v}function quatlerp(q1,q2,l){return q1.clone().slerp(q2,1-l)}function sampleTrack(keys,time,lne,lerp){if(1==keys.length)return keys[0].mValue.toTHREE();\nfor(var dist=Infinity,key=null,nextKey=null,i=0;i<keys.length;i++){var timeDist=Math.abs(keys[i].mTime-time);timeDist<dist&&keys[i].mTime<=time&&(dist=timeDist,key=keys[i],nextKey=keys[i+1])}return key?(nextKey?(keys=nextKey.mTime-key.mTime,time=key.mTime-time,time/=keys):(nextKey=keys[0].clone(),nextKey.mTime+=lne,keys=nextKey.mTime-key.mTime,time=key.mTime-time,time/=keys),lerp(key.mValue.toTHREE(),nextKey.mValue.toTHREE(),time)):null}function aiNodeAnim(){this.mNodeName=\"\";this.mNumScalingKeys=\nthis.mNumRotationKeys=this.mNumPositionKeys=0;this.mPositionKeys=[];this.mRotationKeys=[];this.mScalingKeys=[];this.mPostState=this.mPreState=\"\";this.init=function(tps){function t$jscomp$0(t){t.mTime/=tps}tps||(tps=1);this.mPositionKeys.forEach(t$jscomp$0);this.mRotationKeys.forEach(t$jscomp$0);this.mScalingKeys.forEach(t$jscomp$0)};this.sortKeys=function(){function comp(a,b){return a.mTime-b.mTime}this.mPositionKeys.sort(comp);this.mRotationKeys.sort(comp);this.mScalingKeys.sort(comp)};this.getLength=\nfunction(){return Math.max(Math.max.apply(null,this.mPositionKeys.map(function(a){return a.mTime})),Math.max.apply(null,this.mRotationKeys.map(function(a){return a.mTime})),Math.max.apply(null,this.mScalingKeys.map(function(a){return a.mTime})))};this.toTHREE=function(o){this.sortKeys();for(var length=this.getLength(),track=new Virtulous.KeyFrameTrack,i=0;i<length;i+=.05){var matrix=new _three.Matrix4,time=i,pos=sampleTrack(this.mPositionKeys,time,length,veclerp),scale=sampleTrack(this.mScalingKeys,\ntime,length,veclerp),rotation=sampleTrack(this.mRotationKeys,time,length,quatlerp);matrix.compose(pos,rotation,scale);matrix=new Virtulous.KeyFrame(time,matrix);track.addKey(matrix)}track.target=o.findNode(this.mNodeName).toTHREE();length=[track];if(o.nodeToBoneMap[this.mNodeName])for(i=0;i<o.nodeToBoneMap[this.mNodeName].length;i++)matrix=track.clone(),matrix.target=o.nodeToBoneMap[this.mNodeName][i],length.push(matrix);return length}}function aiAnimation(){this.mName=\"\";this.mNumChannels=this.mTicksPerSecond=\nthis.mDuration=0;this.mChannels=[];this.toTHREE=function(root){var animationHandle=new Virtulous.Animation,i;for(i in this.mChannels){this.mChannels[i].init(this.mTicksPerSecond);var tracks=this.mChannels[i].toTHREE(root),j;for(j in tracks)tracks[j].init(),animationHandle.addTrack(tracks[j])}animationHandle.length=Math.max.apply(null,animationHandle.tracks.map(function(e){return e.length}));return animationHandle}}function aiTexture(){this.mHeight=this.mWidth=0;this.texAchFormatHint=[];this.pcData=\n[]}function aiLight(){this.mName=\"\";this.mAngleOuterCone=this.mAngleInnerCone=this.mAttenuationQuadratic=this.mAttenuationLinear=this.mAttenuationConstant=this.mType=0;this.mColorAmbient=this.mColorSpecular=this.mColorDiffuse=null}function aiCamera(){this.mName=\"\";this.mUp=this.mLookAt=this.mPosition=null;this.mAspect=this.mClipPlaneFar=this.mClipPlaneNear=this.mHorizontalFOV=0}function aiScene(){this.mNumCameras=this.mNumLights=this.mNumTextures=this.mNumAnimations=this.mNumMaterials=this.mNumMeshes=\nthis.mFlags=this.compileFlags=this.versionRevision=this.versionMinor=this.versionMajor=0;this.mRootNode=null;this.mMeshes=[];this.mMaterials=[];this.mAnimations=[];this.mLights=[];this.mCameras=[];this.nodeToBoneMap={};this.findNode=function(name,root){root||(root=this.mRootNode);if(root.mName==name)return root;for(var i=0;i<root.mChildren.length;i++){var ret=this.findNode(name,root.mChildren[i]);if(ret)return ret}return null};this.toTHREE=function(){this.nodeCount=0;for(var i in this.mMeshes){var mesh=\nthis.mMeshes[i],k;for(k in mesh.mBones){var boneNode=this.findNode(mesh.mBones[k].mName);boneNode&&(boneNode.isBone=!0)}}i=this.mRootNode.toTHREE(this);for(var i$jscomp$0 in this.mMeshes)this.mMeshes[i$jscomp$0].hookupSkeletons(this);if(0<this.mAnimations.length)var a=this.mAnimations[0].toTHREE(this);return{object:i,animation:a}}}function aiMatrix4(){this.elements=[[],[],[],[]];this.toTHREE=function(){for(var m=new _three.Matrix4,i=0;4>i;++i)for(var i2=0;4>i2;++i2)m.elements[4*i+i2]=this.elements[i2][i];\nreturn m}}function readFloat(dataview){var val=dataview.getFloat32(dataview.readOffset,!0);dataview.readOffset+=4;return val}function Read_double(dataview){var val=dataview.getFloat64(dataview.readOffset,!0);dataview.readOffset+=8;return val}function Read_uint16_t(dataview){var val=dataview.getUint16(dataview.readOffset,!0);dataview.readOffset+=2;return val}function Read_unsigned_int(dataview){var val=dataview.getUint32(dataview.readOffset,!0);dataview.readOffset+=4;return val}function Read_uint32_t(dataview){var val=\ndataview.getUint32(dataview.readOffset,!0);dataview.readOffset+=4;return val}function Read_aiVector3D(stream){var v=new aiVector3D;v.x=readFloat(stream);v.y=readFloat(stream);v.z=readFloat(stream);return v}function Read_aiColor3D(stream){var c=new aiColor3D;c.r=readFloat(stream);c.g=readFloat(stream);c.b=readFloat(stream);return c}function Read_aiString(stream){var s=new aiString,stringlengthbytes=Read_unsigned_int(stream);stream.ReadBytes(s.data,1,stringlengthbytes);return s.toString()}function Read_aiMatrix4x4(stream){for(var m=\nnew aiMatrix4,i=0;4>i;++i)for(var i2=0;4>i2;++i2)m.elements[i][i2]=readFloat(stream);return m}function Read_aiVectorKey(stream){var v=new aiVectorKey;v.mTime=Read_double(stream);v.mValue=Read_aiVector3D(stream);return v}function ReadBounds(stream,T,n){return stream.Seek(sizeof(T)*n,aiOrigin_CUR)}function ai_assert(bool){if(!bool)throw\"asset failed\";}function ReadBinaryNode(stream,parent,depth){var chunkID=Read_uint32_t(stream);ai_assert(4668==chunkID);Read_uint32_t(stream);chunkID=new aiNode;chunkID.mParent=\nparent;chunkID.mDepth=depth;chunkID.mName=Read_aiString(stream);chunkID.mTransformation=Read_aiMatrix4x4(stream);chunkID.mNumChildren=Read_unsigned_int(stream);chunkID.mNumMeshes=Read_unsigned_int(stream);if(chunkID.mNumMeshes)for(chunkID.mMeshes=[],parent=0;parent<chunkID.mNumMeshes;++parent)chunkID.mMeshes[parent]=Read_unsigned_int(stream);if(chunkID.mNumChildren)for(chunkID.mChildren=[],parent=0;parent<chunkID.mNumChildren;++parent){var node2=ReadBinaryNode(stream,chunkID,depth++);chunkID.mChildren[parent]=\nnode2}return chunkID}function ReadBinaryScene(stream$jscomp$2,scene){var chunkID=Read_uint32_t(stream$jscomp$2);ai_assert(4665==chunkID);Read_uint32_t(stream$jscomp$2);scene.mFlags=Read_unsigned_int(stream$jscomp$2);scene.mNumMeshes=Read_unsigned_int(stream$jscomp$2);scene.mNumMaterials=Read_unsigned_int(stream$jscomp$2);scene.mNumAnimations=Read_unsigned_int(stream$jscomp$2);scene.mNumTextures=Read_unsigned_int(stream$jscomp$2);scene.mNumLights=Read_unsigned_int(stream$jscomp$2);scene.mNumCameras=\nRead_unsigned_int(stream$jscomp$2);scene.mRootNode=new aiNode;scene.mRootNode=ReadBinaryNode(stream$jscomp$2,null,0);if(scene.mNumMeshes)for(scene.mMeshes=[],chunkID=0;chunkID<scene.mNumMeshes;++chunkID){scene.mMeshes[chunkID]=new aiMesh;var stream=stream$jscomp$2,mesh=scene.mMeshes[chunkID],chunkID$jscomp$0=Read_uint32_t(stream);ai_assert(4663==chunkID$jscomp$0);Read_uint32_t(stream);mesh.mPrimitiveTypes=Read_unsigned_int(stream);mesh.mNumVertices=Read_unsigned_int(stream);mesh.mNumFaces=Read_unsigned_int(stream);\nmesh.mNumBones=Read_unsigned_int(stream);mesh.mMaterialIndex=Read_unsigned_int(stream);mesh.mNumUVComponents=[];chunkID$jscomp$0=Read_unsigned_int(stream);chunkID$jscomp$0&1&&(shortened?ReadBounds(stream,mesh.mVertices,mesh.mNumVertices):(mesh.mVertices=[],mesh.mVertexBuffer=stream.subArray32(stream.readOffset,stream.readOffset+12*mesh.mNumVertices),stream.Seek(12*mesh.mNumVertices,aiOrigin_CUR)));chunkID$jscomp$0&2&&(shortened?ReadBounds(stream,mesh.mNormals,mesh.mNumVertices):(mesh.mNormals=[],\nmesh.mNormalBuffer=stream.subArray32(stream.readOffset,stream.readOffset+12*mesh.mNumVertices),stream.Seek(12*mesh.mNumVertices,aiOrigin_CUR)));chunkID$jscomp$0&4&&(shortened?(ReadBounds(stream,mesh.mTangents,mesh.mNumVertices),ReadBounds(stream,mesh.mBitangents,mesh.mNumVertices)):(mesh.mTangents=[],mesh.mTangentBuffer=stream.subArray32(stream.readOffset,stream.readOffset+12*mesh.mNumVertices),stream.Seek(12*mesh.mNumVertices,aiOrigin_CUR),mesh.mBitangents=[],mesh.mBitangentBuffer=stream.subArray32(stream.readOffset,\nstream.readOffset+12*mesh.mNumVertices),stream.Seek(12*mesh.mNumVertices,aiOrigin_CUR)));for(var n=0;1>n&&chunkID$jscomp$0&65536<<n;++n)shortened?ReadBounds(stream,mesh.mColors[n],mesh.mNumVertices):(mesh.mColors[n]=[],mesh.mColorBuffer=stream.subArray32(stream.readOffset,stream.readOffset+16*mesh.mNumVertices),stream.Seek(16*mesh.mNumVertices,aiOrigin_CUR));mesh.mTexCoordsBuffers=[];for(n=0;4>n&&chunkID$jscomp$0&256<<n;++n)if(mesh.mNumUVComponents[n]=Read_unsigned_int(stream),shortened)ReadBounds(stream,\nmesh.mTextureCoords[n],mesh.mNumVertices);else{mesh.mTextureCoords[n]=[];mesh.mTexCoordsBuffers[n]=[];for(var uv=0;uv<mesh.mNumVertices;uv++)mesh.mTexCoordsBuffers[n].push(readFloat(stream)),mesh.mTexCoordsBuffers[n].push(readFloat(stream)),readFloat(stream)}if(shortened)Read_unsigned_int(stream);else for(mesh.mFaces=[],mesh.mIndexArray=[],chunkID$jscomp$0=0;chunkID$jscomp$0<mesh.mNumFaces;++chunkID$jscomp$0){n=mesh.mFaces[chunkID$jscomp$0]=new aiFace;n.mNumIndices=Read_uint16_t(stream);n.mIndices=\n[];for(uv=0;uv<n.mNumIndices;++uv)n.mIndices[uv]=65536>mesh.mNumVertices?Read_uint16_t(stream):Read_unsigned_int(stream);if(3===n.mNumIndices)mesh.mIndexArray.push(n.mIndices[0]),mesh.mIndexArray.push(n.mIndices[1]),mesh.mIndexArray.push(n.mIndices[2]);else if(4===n.mNumIndices)mesh.mIndexArray.push(n.mIndices[0]),mesh.mIndexArray.push(n.mIndices[1]),mesh.mIndexArray.push(n.mIndices[2]),mesh.mIndexArray.push(n.mIndices[2]),mesh.mIndexArray.push(n.mIndices[3]),mesh.mIndexArray.push(n.mIndices[0]);\nelse throw Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");}if(mesh.mNumBones)for(mesh.mBones=[],chunkID$jscomp$0=0;chunkID$jscomp$0<mesh.mNumBones;++chunkID$jscomp$0){mesh.mBones[chunkID$jscomp$0]=new aiBone;n=stream;var b=mesh.mBones[chunkID$jscomp$0];uv=Read_uint32_t(n);ai_assert(4666==uv);Read_uint32_t(n);b.mName=Read_aiString(n);b.mNumWeights=Read_unsigned_int(n);b.mOffsetMatrix=Read_aiMatrix4x4(n);if(shortened)ReadBounds(n,b.mWeights,b.mNumWeights);\nelse{b.mWeights=[];uv=b.mWeights;b=b.mNumWeights;for(var i=0;i<b;i++){var JSCompiler_temp_const=uv,JSCompiler_temp_const$jscomp$0=i,stream$jscomp$0=n,w=new aiVertexWeight;w.mVertexId=Read_unsigned_int(stream$jscomp$0);w.mWeight=readFloat(stream$jscomp$0);JSCompiler_temp_const[JSCompiler_temp_const$jscomp$0]=w}}}}if(scene.mNumMaterials)for(scene.mMaterials=[],chunkID=0;chunkID<scene.mNumMaterials;++chunkID)if(scene.mMaterials[chunkID]=new aiMaterial,stream=stream$jscomp$2,mesh=scene.mMaterials[chunkID],\nchunkID$jscomp$0=Read_uint32_t(stream),ai_assert(4669==chunkID$jscomp$0),Read_uint32_t(stream),mesh.mNumAllocated=mesh.mNumProperties=Read_unsigned_int(stream),mesh.mNumProperties)for(mesh.mProperties&&delete mesh.mProperties,mesh.mProperties=[],chunkID$jscomp$0=0;chunkID$jscomp$0<mesh.mNumProperties;++chunkID$jscomp$0)mesh.mProperties[chunkID$jscomp$0]=new aiMaterialProperty,n=stream,uv=mesh.mProperties[chunkID$jscomp$0],b=Read_uint32_t(n),ai_assert(4670==b),Read_uint32_t(n),uv.mKey=Read_aiString(n),\nuv.mSemantic=Read_unsigned_int(n),uv.mIndex=Read_unsigned_int(n),uv.mDataLength=Read_unsigned_int(n),uv.mType=Read_unsigned_int(n),uv.mData=[],n.ReadBytes(uv.mData,1,uv.mDataLength);if(scene.mNumAnimations)for(scene.mAnimations=[],chunkID=0;chunkID<scene.mNumAnimations;++chunkID)if(scene.mAnimations[chunkID]=new aiAnimation,stream=stream$jscomp$2,mesh=scene.mAnimations[chunkID],chunkID$jscomp$0=Read_uint32_t(stream),ai_assert(4667==chunkID$jscomp$0),Read_uint32_t(stream),mesh.mName=Read_aiString(stream),\nmesh.mDuration=Read_double(stream),mesh.mTicksPerSecond=Read_double(stream),mesh.mNumChannels=Read_unsigned_int(stream),mesh.mNumChannels)for(mesh.mChannels=[],chunkID$jscomp$0=0;chunkID$jscomp$0<mesh.mNumChannels;++chunkID$jscomp$0){mesh.mChannels[chunkID$jscomp$0]=new aiNodeAnim;uv=stream;n=mesh.mChannels[chunkID$jscomp$0];b=Read_uint32_t(uv);ai_assert(4664==b);Read_uint32_t(uv);n.mNodeName=Read_aiString(uv);n.mNumPositionKeys=Read_unsigned_int(uv);n.mNumRotationKeys=Read_unsigned_int(uv);n.mNumScalingKeys=\nRead_unsigned_int(uv);n.mPreState=Read_unsigned_int(uv);n.mPostState=Read_unsigned_int(uv);if(n.mNumPositionKeys)if(shortened)ReadBounds(uv,n.mPositionKeys,n.mNumPositionKeys);else for(n.mPositionKeys=[],b=uv,i=n.mPositionKeys,JSCompiler_temp_const=n.mNumPositionKeys,JSCompiler_temp_const$jscomp$0=0;JSCompiler_temp_const$jscomp$0<JSCompiler_temp_const;JSCompiler_temp_const$jscomp$0++)i[JSCompiler_temp_const$jscomp$0]=Read_aiVectorKey(b);if(n.mNumRotationKeys)if(shortened)ReadBounds(uv,n.mRotationKeys,\nn.mNumRotationKeys);else for(n.mRotationKeys=[],b=uv,i=n.mRotationKeys,JSCompiler_temp_const=n.mNumRotationKeys,JSCompiler_temp_const$jscomp$0=0;JSCompiler_temp_const$jscomp$0<JSCompiler_temp_const;JSCompiler_temp_const$jscomp$0++){stream$jscomp$0=i;w=JSCompiler_temp_const$jscomp$0;var stream$jscomp$1=b,v=new aiQuatKey;v.mTime=Read_double(stream$jscomp$1);var v$jscomp$0=new aiQuaternion;v$jscomp$0.w=readFloat(stream$jscomp$1);v$jscomp$0.x=readFloat(stream$jscomp$1);v$jscomp$0.y=readFloat(stream$jscomp$1);\nv$jscomp$0.z=readFloat(stream$jscomp$1);stream$jscomp$1=v$jscomp$0;v.mValue=stream$jscomp$1;stream$jscomp$0[w]=v}if(n.mNumScalingKeys)if(shortened)ReadBounds(uv,n.mScalingKeys,n.mNumScalingKeys);else for(n.mScalingKeys=[],b=n.mScalingKeys,n=n.mNumScalingKeys,i=0;i<n;i++)b[i]=Read_aiVectorKey(uv)}if(scene.mNumTextures)for(scene.mTextures=[],chunkID=0;chunkID<scene.mNumTextures;++chunkID)scene.mTextures[chunkID]=new aiTexture,stream=stream$jscomp$2,mesh=scene.mTextures[chunkID],chunkID$jscomp$0=Read_uint32_t(stream),\nai_assert(4662==chunkID$jscomp$0),Read_uint32_t(stream),mesh.mWidth=Read_unsigned_int(stream),mesh.mHeight=Read_unsigned_int(stream),stream.ReadBytes(mesh.achFormatHint,1,4),shortened||(mesh.mHeight?(mesh.pcData=[],stream.ReadBytes(mesh.pcData,1,mesh.mWidth*mesh.mHeight*4)):(mesh.pcData=[],stream.ReadBytes(mesh.pcData,1,mesh.mWidth)));if(scene.mNumLights)for(scene.mLights=[],chunkID=0;chunkID<scene.mNumLights;++chunkID)scene.mLights[chunkID]=new aiLight,stream=stream$jscomp$2,mesh=scene.mLights[chunkID],\nchunkID$jscomp$0=Read_uint32_t(stream),ai_assert(4661==chunkID$jscomp$0),Read_uint32_t(stream),mesh.mName=Read_aiString(stream),mesh.mType=Read_unsigned_int(stream),1!=mesh.mType&&(mesh.mAttenuationConstant=readFloat(stream),mesh.mAttenuationLinear=readFloat(stream),mesh.mAttenuationQuadratic=readFloat(stream)),mesh.mColorDiffuse=Read_aiColor3D(stream),mesh.mColorSpecular=Read_aiColor3D(stream),mesh.mColorAmbient=Read_aiColor3D(stream),3==mesh.mType&&(mesh.mAngleInnerCone=readFloat(stream),mesh.mAngleOuterCone=\nreadFloat(stream));if(scene.mNumCameras)for(scene.mCameras=[],chunkID=0;chunkID<scene.mNumCameras;++chunkID)scene.mCameras[chunkID]=new aiCamera,stream=stream$jscomp$2,mesh=scene.mCameras[chunkID],chunkID$jscomp$0=Read_uint32_t(stream),ai_assert(4660==chunkID$jscomp$0),Read_uint32_t(stream),mesh.mName=Read_aiString(stream),mesh.mPosition=Read_aiVector3D(stream),mesh.mLookAt=Read_aiVector3D(stream),mesh.mUp=Read_aiVector3D(stream),mesh.mHorizontalFOV=readFloat(stream),mesh.mClipPlaneNear=readFloat(stream),\nmesh.mClipPlaneFar=readFloat(stream),mesh.mAspect=readFloat(stream)}function extendStream(stream){stream.readOffset=0;stream.Seek=function(off,ori){ori==aiOrigin_CUR&&(stream.readOffset+=off);1==ori&&(stream.readOffset=off)};stream.ReadBytes=function(buff,size,n){size*=n;for(n=0;n<size;n++){var JSCompiler_temp_const=n,val=this.getUint8(this.readOffset);this.readOffset+=1;buff[JSCompiler_temp_const]=val}};stream.subArray32=function(start,end){start=this.buffer.slice(start,end);return new Float32Array(start)};\nstream.subArrayUint16=function(start,end){start=this.buffer.slice(start,end);return new Uint16Array(start)};stream.subArrayUint8=function(start,end){start=this.buffer.slice(start,end);return new Uint8Array(start)};stream.subArrayUint32=function(start,end){start=this.buffer.slice(start,end);return new Uint32Array(start)}}var textureLoader=new _three.TextureLoader(this.manager);textureLoader.setPath(this.resourcePath||path).setCrossOrigin(this.crossOrigin);var Virtulous={KeyFrame:function(time$jscomp$0,\nmatrix){this.time=time$jscomp$0;this.matrix=matrix.clone();this.position=new _three.Vector3;this.quaternion=new _three.Quaternion;this.scale=new _three.Vector3(1,1,1);this.matrix.decompose(this.position,this.quaternion,this.scale);this.clone=function(){return new Virtulous.KeyFrame(this.time,this.matrix)};this.lerp=function(nextKey,time){time-=this.time;time/=nextKey.time-this.time;var l2=1-time,keypos=this.position,keyrot=this.quaternion,key2pos=nextKey.position;nextKey=nextKey.quaternion;Virtulous.KeyFrame.tempAniPos.x=\nkeypos.x*l2+key2pos.x*time;Virtulous.KeyFrame.tempAniPos.y=keypos.y*l2+key2pos.y*time;Virtulous.KeyFrame.tempAniPos.z=keypos.z*l2+key2pos.z*time;Virtulous.KeyFrame.tempAniQuat.set(keyrot.x,keyrot.y,keyrot.z,keyrot.w);Virtulous.KeyFrame.tempAniQuat.slerp(nextKey,time);return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos,Virtulous.KeyFrame.tempAniQuat,Virtulous.KeyFrame.tempAniScale)}}};Virtulous.KeyFrame.tempAniPos=new _three.Vector3;Virtulous.KeyFrame.tempAniQuat=new _three.Quaternion;\nVirtulous.KeyFrame.tempAniScale=new _three.Vector3(1,1,1);Virtulous.KeyFrame.tempAniMatrix=new _three.Matrix4;Virtulous.KeyFrameTrack=function(){this.keys=[];this.target=null;this.length=this.time=0;this._accelTable={};this.fps=20;this.addKey=function(key){this.keys.push(key)};this.init=function(){this.sortKeys();this.length=0<this.keys.length?this.keys[this.keys.length-1].time:0;if(this.fps)for(var j=0;j<this.length*this.fps;j++)for(var i=0;i<this.keys.length;i++)if(this.keys[i].time==j){this._accelTable[j]=\ni;break}else if(this.keys[i].time<j/this.fps&&this.keys[i+1]&&this.keys[i+1].time>=j/this.fps){this._accelTable[j]=i;break}};this.parseFromThree=function(data){var fps=data.fps;this.target=data.node;data=data.hierarchy[0].keys;for(var i=0;i<data.length;i++)this.addKey(new Virtulous.KeyFrame(i/fps||data[i].time,data[i].targets[0].data));this.init()};this.parseFromCollada=function(data){data=data.keys;for(var fps=this.fps,i=0;i<data.length;i++)this.addKey(new Virtulous.KeyFrame(i/fps||data[i].time,\ndata[i].matrix));this.init()};this.sortKeys=function(){this.keys.sort(this.keySortFunc)};this.keySortFunc=function(a,b){return a.time-b.time};this.clone=function(){var t=new Virtulous.KeyFrameTrack;t.target=this.target;t.time=this.time;t.length=this.length;for(var i=0;i<this.keys.length;i++)t.addKey(this.keys[i].clone());t.init();return t};this.reTarget=function(root,compareitor){compareitor||(compareitor=Virtulous.TrackTargetNodeNameCompare);this.target=compareitor(root,this.target)};this.keySearchAccel=\nfunction(time){time*=this.fps;time=Math.floor(time);return this._accelTable[time]||0};this.setTime=function(time){time=Math.abs(time);this.length&&(time=time%this.length+.05);for(var key0=null,key1=null,i=this.keySearchAccel(time);i<this.keys.length;i++)if(this.keys[i].time==time){key0=this.keys[i];key1=this.keys[i];break}else if(this.keys[i].time<time&&this.keys[i+1]&&this.keys[i+1].time>time){key0=this.keys[i];key1=this.keys[i+1];break}else if(this.keys[i].time<time&&i==this.keys.length-1){key0=\nthis.keys[i];key1=this.keys[0].clone();key1.time+=this.length+.05;break}key0&&key1&&key0!==key1?(this.target.matrixAutoUpdate=!1,this.target.matrix.copy(key0.lerp(key1,time)),this.target.matrixWorldNeedsUpdate=!0):key0&&key1&&key0==key1&&(this.target.matrixAutoUpdate=!1,this.target.matrix.copy(key0.matrix),this.target.matrixWorldNeedsUpdate=!0)}};Virtulous.TrackTargetNodeNameCompare=function(root,target){function find(node,name){if(node.name==name)return node;for(var i=0;i<node.children.length;i++){var r=\nfind(node.children[i],name);if(r)return r}return null}return find(root,target.name)};Virtulous.Animation=function(){this.tracks=[];this.length=0;this.addTrack=function(track){this.tracks.push(track);this.length=Math.max(track.length,this.length)};this.setTime=function(time){this.time=time;for(var i=0;i<this.tracks.length;i++)this.tracks[i].setTime(time)};this.clone=function(target,compareitor){compareitor||(compareitor=Virtulous.TrackTargetNodeNameCompare);var n=new Virtulous.Animation;n.target=target;\nfor(var i=0;i<this.tracks.length;i++){var track=this.tracks[i].clone();track.reTarget(target,compareitor);n.addTrack(track)}return n}};var namePropMapping={\"?mat.name\":\"name\",\"$mat.shadingm\":\"shading\",\"$mat.twosided\":\"twoSided\",\"$mat.wireframe\":\"wireframe\",\"$clr.ambient\":\"ambient\",\"$clr.diffuse\":\"color\",\"$clr.specular\":\"specular\",\"$clr.emissive\":\"emissive\",\"$clr.transparent\":\"transparent\",\"$clr.reflective\":\"reflect\",\"$mat.shininess\":\"shininess\",\"$mat.reflectivity\":\"reflectivity\",\"$mat.refracti\":\"refraction\",\n\"$tex.file\":\"map\"},nameTypeMapping={\"?mat.name\":\"string\",\"$mat.shadingm\":\"bool\",\"$mat.twosided\":\"bool\",\"$mat.wireframe\":\"bool\",\"$clr.ambient\":\"color\",\"$clr.diffuse\":\"color\",\"$clr.specular\":\"color\",\"$clr.emissive\":\"color\",\"$clr.transparent\":\"color\",\"$clr.reflective\":\"color\",\"$mat.shininess\":\"float\",\"$mat.reflectivity\":\"float\",\"$mat.refracti\":\"float\",\"$tex.file\":\"map\"},aiOrigin_CUR=0,shortened,compressed;return function(pFiledata){var pScene=new aiScene,stream=new DataView(pFiledata);extendStream(stream);\nstream.Seek(44,aiOrigin_CUR);pScene.versionMajor=Read_unsigned_int(stream);pScene.versionMinor=Read_unsigned_int(stream);pScene.versionRevision=Read_unsigned_int(stream);pScene.compileFlags=Read_unsigned_int(stream);shortened=0<Read_uint16_t(stream);compressed=0<Read_uint16_t(stream);if(shortened)throw\"Shortened binaries are not supported!\";stream.Seek(256,aiOrigin_CUR);stream.Seek(128,aiOrigin_CUR);stream.Seek(64,aiOrigin_CUR);if(compressed){pFiledata=Read_uint32_t(stream);var compressedSize=stream.FileSize()-\nstream.Tell(),compressedData=[];stream.Read(compressedData,1,compressedSize);stream=[];uncompress(stream,pFiledata,compressedData,compressedSize);pFiledata=new ArrayBuffer(stream);ReadBinaryScene(pFiledata,pScene)}else ReadBinaryScene(stream,pScene);return pScene.toTHREE()}(buffer)}})}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$AssimpLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AssimpLoader = void 0;\n\nvar _three = require(\"three\");\n\nvar AssimpLoader = function AssimpLoader(manager) {\n  _three.Loader.call(this, manager);\n};\n\nexports.AssimpLoader = AssimpLoader;\nAssimpLoader.prototype = Object.assign(Object.create(_three.Loader.prototype), {\n  constructor: AssimpLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? _three.LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new _three.FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function parse(buffer, path) {\n    var textureLoader = new _three.TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var Virtulous = {};\n\n    Virtulous.KeyFrame = function (time, matrix) {\n      this.time = time;\n      this.matrix = matrix.clone();\n      this.position = new _three.Vector3();\n      this.quaternion = new _three.Quaternion();\n      this.scale = new _three.Vector3(1, 1, 1);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n\n      this.clone = function () {\n        var n = new Virtulous.KeyFrame(this.time, this.matrix);\n        return n;\n      };\n\n      this.lerp = function (nextKey, time) {\n        time -= this.time;\n        var dist = nextKey.time - this.time;\n        var l = time / dist;\n        var l2 = 1 - l;\n        var keypos = this.position;\n        var keyrot = this.quaternion; //      var keyscl =  key.parentspaceScl || key.scl;\n\n        var key2pos = nextKey.position;\n        var key2rot = nextKey.quaternion; //  var key2scl =  key2.parentspaceScl || key2.scl;\n\n        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l; //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n        //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n        //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\n        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n      };\n    };\n\n    Virtulous.KeyFrame.tempAniPos = new _three.Vector3();\n    Virtulous.KeyFrame.tempAniQuat = new _three.Quaternion();\n    Virtulous.KeyFrame.tempAniScale = new _three.Vector3(1, 1, 1);\n    Virtulous.KeyFrame.tempAniMatrix = new _three.Matrix4();\n\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = [];\n      this.target = null;\n      this.time = 0;\n      this.length = 0;\n      this._accelTable = {};\n      this.fps = 20;\n\n      this.addKey = function (key) {\n        this.keys.push(key);\n      };\n\n      this.init = function () {\n        this.sortKeys();\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n        if (!this.fps) return;\n\n        for (var j = 0; j < this.length * this.fps; j++) {\n          for (var i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i;\n              break;\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i;\n              break;\n            }\n          }\n        }\n      };\n\n      this.parseFromThree = function (data) {\n        var fps = data.fps;\n        this.target = data.node;\n        var track = data.hierarchy[0].keys;\n\n        for (var i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n        }\n\n        this.init();\n      };\n\n      this.parseFromCollada = function (data) {\n        var track = data.keys;\n        var fps = this.fps;\n\n        for (var i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n        }\n\n        this.init();\n      };\n\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc);\n      };\n\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time;\n      };\n\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack();\n        t.target = this.target;\n        t.time = this.time;\n        t.length = this.length;\n\n        for (var i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone());\n        }\n\n        t.init();\n        return t;\n      };\n\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        this.target = compareitor(root, this.target);\n      };\n\n      this.keySearchAccel = function (time) {\n        time *= this.fps;\n        time = Math.floor(time);\n        return this._accelTable[time] || 0;\n      };\n\n      this.setTime = function (time) {\n        time = Math.abs(time);\n        if (this.length) time = time % this.length + 0.05;\n        var key0 = null;\n        var key1 = null;\n\n        for (var i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i];\n            break;\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i + 1];\n            break;\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i];\n            key1 = this.keys[0].clone();\n            key1.time += this.length + 0.05;\n            break;\n          }\n        }\n\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.lerp(key1, time));\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.matrix);\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n      };\n    };\n\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node;\n\n        for (var i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name);\n          if (r) return r;\n        }\n\n        return null;\n      }\n\n      return find(root, target.name);\n    };\n\n    Virtulous.Animation = function () {\n      this.tracks = [];\n      this.length = 0;\n\n      this.addTrack = function (track) {\n        this.tracks.push(track);\n        this.length = Math.max(track.length, this.length);\n      };\n\n      this.setTime = function (time) {\n        this.time = time;\n\n        for (var i = 0; i < this.tracks.length; i++) {\n          this.tracks[i].setTime(time);\n        }\n      };\n\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        var n = new Virtulous.Animation();\n        n.target = target;\n\n        for (var i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone();\n          track.reTarget(target, compareitor);\n          n.addTrack(track);\n        }\n\n        return n;\n      };\n    };\n\n    var ASSBIN_CHUNK_AICAMERA = 0x1234;\n    var ASSBIN_CHUNK_AILIGHT = 0x1235;\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236;\n    var ASSBIN_CHUNK_AIMESH = 0x1237;\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238;\n    var ASSBIN_CHUNK_AISCENE = 0x1239;\n    var ASSBIN_CHUNK_AIBONE = 0x123a;\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b;\n    var ASSBIN_CHUNK_AINODE = 0x123c;\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1;\n    var ASSBIN_MESH_HAS_NORMALS = 0x2;\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4; //var aiLightSource_UNDEFINED = 0x0;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n\n    var aiLightSource_DIRECTIONAL = 0x1; //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //var aiLightSource_POINT = 0x2;\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n\n    var aiLightSource_SPOT = 0x3; //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    //var aiLightSource_AMBIENT = 0x4;\n\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    //var aiShadingMode_Flat = 0x1;\n\n    /** Simple Gouraud shading.\n     */\n    //var aiShadingMode_Gouraud = 0x2;\n\n    /** Phong-Shading -\n     */\n    //var aiShadingMode_Phong = 0x3;\n\n    /** Phong-Blinn-Shading\n     */\n    //var aiShadingMode_Blinn = 0x4;\n\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    //var aiShadingMode_Toon = 0x5;\n\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    //var aiShadingMode_OrenNayar = 0x6;\n\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    //var aiShadingMode_Minnaert = 0x7;\n\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    //var aiShadingMode_CookTorrance = 0x8;\n\n    /** No shading at all. Constant light influence of 1.0.\n     */\n    //var aiShadingMode_NoShading = 0x9;\n\n    /** Fresnel shading\n     */\n    //var aiShadingMode_Fresnel = 0xa;\n    //var aiTextureType_NONE = 0x0;\n\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n\n    var aiTextureType_DIFFUSE = 0x1;\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    //var aiTextureType_SPECULAR = 0x2;\n\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    //var aiTextureType_AMBIENT = 0x3;\n\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    //var aiTextureType_EMISSIVE = 0x4;\n\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    //var aiTextureType_HEIGHT = 0x5;\n\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n\n    var aiTextureType_NORMALS = 0x6;\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n     */\n    //var aiTextureType_SHININESS = 0x7;\n\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n     */\n\n    var aiTextureType_OPACITY = 0x8;\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n     */\n    //var aiTextureType_DISPLACEMENT = 0x9;\n\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n     */\n\n    var aiTextureType_LIGHTMAP = 0xa;\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n     */\n    //var aiTextureType_REFLECTION = 0xB;\n\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further postprocessing.\n     */\n    //var aiTextureType_UNKNOWN = 0xC;\n\n    var BONESPERVERT = 4;\n\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n    }\n\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\n    }\n\n    function markBones(scene) {\n      for (var i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i];\n\n        for (var k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\n          if (boneNode) boneNode.isBone = true;\n        }\n      }\n    }\n\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new _three.Bone();\n      rootBone.matrix.copy(root.matrix);\n      rootBone.matrixWorld.copy(root.matrixWorld);\n      rootBone.position.copy(root.position);\n      rootBone.quaternion.copy(root.quaternion);\n      rootBone.scale.copy(root.scale);\n      scene.nodeCount++;\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString();\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n      scene.nodeToBoneMap[root.name].push(rootBone);\n\n      for (var i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene);\n        rootBone.add(child);\n      }\n\n      return rootBone;\n    }\n\n    function sortWeights(indexes, weights) {\n      var pairs = [];\n\n      for (var i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i]\n        });\n      }\n\n      pairs.sort(function (a, b) {\n        return b.w - a.w;\n      });\n\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0\n        });\n      }\n\n      if (pairs.length > 4) pairs.length = 4;\n      var sum = 0;\n\n      for (var _i = 0; _i < 4; _i++) {\n        sum += pairs[_i].w * pairs[_i].w;\n      }\n\n      sum = Math.sqrt(sum);\n\n      for (var _i2 = 0; _i2 < 4; _i2++) {\n        pairs[_i2].w = pairs[_i2].w / sum;\n        indexes[_i2] = pairs[_i2].i;\n        weights[_i2] = pairs[_i2].w;\n      }\n    }\n\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf('bone_' + name) == 0) return root;\n\n      for (var i in root.children) {\n        var ret = findMatchingBone(root.children[i], name);\n        if (ret) return ret;\n      }\n\n      return undefined;\n    }\n\n    function aiMesh() {\n      this.mPrimitiveTypes = 0;\n      this.mNumVertices = 0;\n      this.mNumFaces = 0;\n      this.mNumBones = 0;\n      this.mMaterialIndex = 0;\n      this.mVertices = [];\n      this.mNormals = [];\n      this.mTangents = [];\n      this.mBitangents = [];\n      this.mColors = [[]];\n      this.mTextureCoords = [[]];\n      this.mFaces = [];\n      this.mBones = [];\n\n      this.hookupSkeletons = function (scene) {\n        if (this.mBones.length == 0) return;\n        var allBones = [];\n        var offsetMatrix = [];\n        var skeletonRoot = scene.findNode(this.mBones[0].mName);\n\n        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n          skeletonRoot = skeletonRoot.mParent;\n        }\n\n        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n        this.threeNode.add(threeSkeletonRootBone);\n\n        for (var i = 0; i < this.mBones.length; i++) {\n          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n\n          if (bone) {\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          } else {\n            var skeletonRoot = scene.findNode(this.mBones[i].mName);\n            if (!skeletonRoot) return;\n            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n            this.threeNode.add(threeSkeletonRootBone);\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          }\n        }\n\n        var skeleton = new _three.Skeleton(allBones, offsetMatrix);\n        this.threeNode.bind(skeleton, new _three.Matrix4());\n        this.threeNode.material.skinning = true;\n      };\n\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var geometry = new _three.BufferGeometry();\n        var mat;\n        if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new _three.MeshLambertMaterial();\n        geometry.setIndex(new _three.BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n        geometry.setAttribute('position', new _three.BufferAttribute(this.mVertexBuffer, 3));\n        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) geometry.setAttribute('normal', new _three.BufferAttribute(this.mNormalBuffer, 3));\n        if (this.mColorBuffer && this.mColorBuffer.length > 0) geometry.setAttribute('color', new _three.BufferAttribute(this.mColorBuffer, 4));\n        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) geometry.setAttribute('uv', new _three.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) geometry.setAttribute('uv1', new _three.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) geometry.setAttribute('tangents', new _three.BufferAttribute(this.mTangentBuffer, 3));\n        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) geometry.setAttribute('bitangents', new _three.BufferAttribute(this.mBitangentBuffer, 3));\n\n        if (this.mBones.length > 0) {\n          var weights = [];\n          var bones = [];\n\n          for (var i = 0; i < this.mBones.length; i++) {\n            for (var j = 0; j < this.mBones[i].mWeights.length; j++) {\n              var weight = this.mBones[i].mWeights[j];\n\n              if (weight) {\n                if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n                if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n                weights[weight.mVertexId].push(weight.mWeight);\n                bones[weight.mVertexId].push(parseInt(i));\n              }\n            }\n          }\n\n          for (var _i3 in bones) {\n            sortWeights(bones[_i3], weights[_i3]);\n          }\n\n          var _weights = [];\n          var _bones = [];\n\n          for (var _i4 = 0; _i4 < weights.length; _i4++) {\n            for (var _j = 0; _j < 4; _j++) {\n              if (weights[_i4] && bones[_i4]) {\n                _weights.push(weights[_i4][_j]);\n\n                _bones.push(bones[_i4][_j]);\n              } else {\n                _weights.push(0);\n\n                _bones.push(0);\n              }\n            }\n          }\n\n          geometry.setAttribute('skinWeight', new _three.BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n          geometry.setAttribute('skinIndex', new _three.BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n        }\n\n        var mesh;\n        if (this.mBones.length == 0) mesh = new _three.Mesh(geometry, mat);\n\n        if (this.mBones.length > 0) {\n          mesh = new _three.SkinnedMesh(geometry, mat);\n          mesh.normalizeSkinWeights();\n        }\n\n        this.threeNode = mesh; //mesh.matrixAutoUpdate = false;\n\n        return mesh;\n      };\n    }\n\n    function aiFace() {\n      this.mNumIndices = 0;\n      this.mIndices = [];\n    }\n\n    function aiVector3D() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n\n      this.toTHREE = function () {\n        return new _three.Vector3(this.x, this.y, this.z);\n      };\n    }\n\n    function aiColor3D() {\n      this.r = 0;\n      this.g = 0;\n      this.b = 0;\n      this.a = 0;\n\n      this.toTHREE = function () {\n        return new _three.Color(this.r, this.g, this.b);\n      };\n    }\n\n    function aiQuaternion() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 0;\n\n      this.toTHREE = function () {\n        return new _three.Quaternion(this.x, this.y, this.z, this.w);\n      };\n    }\n\n    function aiVertexWeight() {\n      this.mVertexId = 0;\n      this.mWeight = 0;\n    }\n\n    function aiString() {\n      this.data = [];\n\n      this.toString = function () {\n        var str = '';\n        this.data.forEach(function (i) {\n          str += String.fromCharCode(i);\n        });\n        return str.replace(/[^\\x20-\\x7E]+/g, '');\n      };\n    }\n\n    function aiVectorKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n\n    function aiQuatKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n\n    function aiNode() {\n      this.mName = '';\n      this.mTransformation = [];\n      this.mNumChildren = 0;\n      this.mNumMeshes = 0;\n      this.mMeshes = [];\n      this.mChildren = [];\n\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var o = new _three.Object3D();\n        o.name = this.mName;\n        o.matrix = this.mTransformation.toTHREE();\n\n        for (var i = 0; i < this.mChildren.length; i++) {\n          o.add(this.mChildren[i].toTHREE(scene));\n        }\n\n        for (var _i5 = 0; _i5 < this.mMeshes.length; _i5++) {\n          o.add(scene.mMeshes[this.mMeshes[_i5]].toTHREE(scene));\n        }\n\n        this.threeNode = o; //o.matrixAutoUpdate = false;\n\n        o.matrix.decompose(o.position, o.quaternion, o.scale);\n        return o;\n      };\n    }\n\n    function aiBone() {\n      this.mName = '';\n      this.mNumWeights = 0;\n      this.mOffsetMatrix = 0;\n    }\n\n    function aiMaterialProperty() {\n      this.mKey = '';\n      this.mSemantic = 0;\n      this.mIndex = 0;\n      this.mData = [];\n      this.mDataLength = 0;\n      this.mType = 0;\n\n      this.dataAsColor = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        var g = reader.getFloat32(4, true);\n        var b = reader.getFloat32(8, true); //var a = reader.getFloat32(12, true);\n\n        return new _three.Color(r, g, b);\n      };\n\n      this.dataAsFloat = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return r;\n      };\n\n      this.dataAsBool = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return !!r;\n      };\n\n      this.dataAsString = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        return s.toString();\n      };\n\n      this.dataAsMap = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        var path = s.toString();\n        path = path.replace(/\\\\/g, '/');\n\n        if (path.indexOf('/') != -1) {\n          path = path.substr(path.lastIndexOf('/') + 1);\n        }\n\n        return textureLoader.load(path);\n      };\n    }\n\n    var namePropMapping = {\n      '?mat.name': 'name',\n      '$mat.shadingm': 'shading',\n      '$mat.twosided': 'twoSided',\n      '$mat.wireframe': 'wireframe',\n      '$clr.ambient': 'ambient',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'specular',\n      '$clr.emissive': 'emissive',\n      '$clr.transparent': 'transparent',\n      '$clr.reflective': 'reflect',\n      '$mat.shininess': 'shininess',\n      '$mat.reflectivity': 'reflectivity',\n      '$mat.refracti': 'refraction',\n      '$tex.file': 'map'\n    };\n    var nameTypeMapping = {\n      '?mat.name': 'string',\n      '$mat.shadingm': 'bool',\n      '$mat.twosided': 'bool',\n      '$mat.wireframe': 'bool',\n      '$clr.ambient': 'color',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'color',\n      '$clr.emissive': 'color',\n      '$clr.transparent': 'color',\n      '$clr.reflective': 'color',\n      '$mat.shininess': 'float',\n      '$mat.reflectivity': 'float',\n      '$mat.refracti': 'float',\n      '$tex.file': 'map'\n    };\n\n    function aiMaterial() {\n      this.mNumAllocated = 0;\n      this.mNumProperties = 0;\n      this.mProperties = [];\n\n      this.toTHREE = function () {\n        var mat = new _three.MeshPhongMaterial();\n\n        for (var i = 0; i < this.mProperties.length; i++) {\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'float') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'color') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'string') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n            var prop = this.mProperties[i];\n            if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n          }\n        }\n\n        mat.ambient.r = 0.53;\n        mat.ambient.g = 0.53;\n        mat.ambient.b = 0.53;\n        mat.color.r = 1;\n        mat.color.g = 1;\n        mat.color.b = 1;\n        return mat;\n      };\n    }\n\n    function veclerp(v1, v2, l) {\n      var v = new _three.Vector3();\n      var lm1 = 1 - l;\n      v.x = v1.x * l + v2.x * lm1;\n      v.y = v1.y * l + v2.y * lm1;\n      v.z = v1.z * l + v2.z * lm1;\n      return v;\n    }\n\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l);\n    }\n\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE();\n      var dist = Infinity;\n      var key = null;\n      var nextKey = null;\n\n      for (var i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time);\n\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist;\n          key = keys[i];\n          nextKey = keys[i + 1];\n        }\n      }\n\n      if (!key) {\n        return null;\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      } else {\n        nextKey = keys[0].clone();\n        nextKey.mTime += lne;\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      }\n    }\n\n    function aiNodeAnim() {\n      this.mNodeName = '';\n      this.mNumPositionKeys = 0;\n      this.mNumRotationKeys = 0;\n      this.mNumScalingKeys = 0;\n      this.mPositionKeys = [];\n      this.mRotationKeys = [];\n      this.mScalingKeys = [];\n      this.mPreState = '';\n      this.mPostState = '';\n\n      this.init = function (tps) {\n        if (!tps) tps = 1;\n\n        function t(t) {\n          t.mTime /= tps;\n        }\n\n        this.mPositionKeys.forEach(t);\n        this.mRotationKeys.forEach(t);\n        this.mScalingKeys.forEach(t);\n      };\n\n      this.sortKeys = function () {\n        function comp(a, b) {\n          return a.mTime - b.mTime;\n        }\n\n        this.mPositionKeys.sort(comp);\n        this.mRotationKeys.sort(comp);\n        this.mScalingKeys.sort(comp);\n      };\n\n      this.getLength = function () {\n        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n          return a.mTime;\n        })));\n      };\n\n      this.toTHREE = function (o) {\n        this.sortKeys();\n        var length = this.getLength();\n        var track = new Virtulous.KeyFrameTrack();\n\n        for (var i = 0; i < length; i += 0.05) {\n          var matrix = new _three.Matrix4();\n          var time = i;\n          var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n          var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n          var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n          matrix.compose(pos, rotation, scale);\n          var key = new Virtulous.KeyFrame(time, matrix);\n          track.addKey(key);\n        }\n\n        track.target = o.findNode(this.mNodeName).toTHREE();\n        var tracks = [track];\n\n        if (o.nodeToBoneMap[this.mNodeName]) {\n          for (var _i6 = 0; _i6 < o.nodeToBoneMap[this.mNodeName].length; _i6++) {\n            var t2 = track.clone();\n            t2.target = o.nodeToBoneMap[this.mNodeName][_i6];\n            tracks.push(t2);\n          }\n        }\n\n        return tracks;\n      };\n    }\n\n    function aiAnimation() {\n      this.mName = '';\n      this.mDuration = 0;\n      this.mTicksPerSecond = 0;\n      this.mNumChannels = 0;\n      this.mChannels = [];\n\n      this.toTHREE = function (root) {\n        var animationHandle = new Virtulous.Animation();\n\n        for (var i in this.mChannels) {\n          this.mChannels[i].init(this.mTicksPerSecond);\n          var tracks = this.mChannels[i].toTHREE(root);\n\n          for (var j in tracks) {\n            tracks[j].init();\n            animationHandle.addTrack(tracks[j]);\n          }\n        }\n\n        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n          return e.length;\n        }));\n        return animationHandle;\n      };\n    }\n\n    function aiTexture() {\n      this.mWidth = 0;\n      this.mHeight = 0;\n      this.texAchFormatHint = [];\n      this.pcData = [];\n    }\n\n    function aiLight() {\n      this.mName = '';\n      this.mType = 0;\n      this.mAttenuationConstant = 0;\n      this.mAttenuationLinear = 0;\n      this.mAttenuationQuadratic = 0;\n      this.mAngleInnerCone = 0;\n      this.mAngleOuterCone = 0;\n      this.mColorDiffuse = null;\n      this.mColorSpecular = null;\n      this.mColorAmbient = null;\n    }\n\n    function aiCamera() {\n      this.mName = '';\n      this.mPosition = null;\n      this.mLookAt = null;\n      this.mUp = null;\n      this.mHorizontalFOV = 0;\n      this.mClipPlaneNear = 0;\n      this.mClipPlaneFar = 0;\n      this.mAspect = 0;\n    }\n\n    function aiScene() {\n      this.versionMajor = 0;\n      this.versionMinor = 0;\n      this.versionRevision = 0;\n      this.compileFlags = 0;\n      this.mFlags = 0;\n      this.mNumMeshes = 0;\n      this.mNumMaterials = 0;\n      this.mNumAnimations = 0;\n      this.mNumTextures = 0;\n      this.mNumLights = 0;\n      this.mNumCameras = 0;\n      this.mRootNode = null;\n      this.mMeshes = [];\n      this.mMaterials = [];\n      this.mAnimations = [];\n      this.mLights = [];\n      this.mCameras = [];\n      this.nodeToBoneMap = {};\n\n      this.findNode = function (name, root) {\n        if (!root) {\n          root = this.mRootNode;\n        }\n\n        if (root.mName == name) {\n          return root;\n        }\n\n        for (var i = 0; i < root.mChildren.length; i++) {\n          var ret = this.findNode(name, root.mChildren[i]);\n          if (ret) return ret;\n        }\n\n        return null;\n      };\n\n      this.toTHREE = function () {\n        this.nodeCount = 0;\n        markBones(this);\n        var o = this.mRootNode.toTHREE(this);\n\n        for (var i in this.mMeshes) {\n          this.mMeshes[i].hookupSkeletons(this);\n        }\n\n        if (this.mAnimations.length > 0) {\n          var a = this.mAnimations[0].toTHREE(this);\n        }\n\n        return {\n          object: o,\n          animation: a\n        };\n      };\n    }\n\n    function aiMatrix4() {\n      this.elements = [[], [], [], []];\n\n      this.toTHREE = function () {\n        var m = new _three.Matrix4();\n\n        for (var i = 0; i < 4; ++i) {\n          for (var i2 = 0; i2 < 4; ++i2) {\n            m.elements[i * 4 + i2] = this.elements[i2][i];\n          }\n        }\n\n        return m;\n      };\n    }\n\n    var littleEndian = true;\n\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n      dataview.readOffset += 8;\n      return val;\n    }\n\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset);\n      dataview.readOffset += 1;\n      return val;\n    }\n\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\n      dataview.readOffset += 2;\n      return val;\n    }\n\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D();\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D();\n      c.r = readFloat(stream);\n      c.g = readFloat(stream);\n      c.b = readFloat(stream);\n      return c;\n    }\n\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion();\n      v.w = readFloat(stream);\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n\n    function Read_aiString(stream) {\n      var s = new aiString();\n      var stringlengthbytes = Read_unsigned_int(stream);\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\n      return s.toString();\n    }\n\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight();\n      w.mVertexId = Read_unsigned_int(stream);\n      w.mWeight = readFloat(stream);\n      return w;\n    }\n\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4();\n\n      for (var i = 0; i < 4; ++i) {\n        for (var i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream);\n        }\n      }\n\n      return m;\n    }\n\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiVector3D(stream);\n      return v;\n    }\n\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiQuaternion(stream);\n      return v;\n    }\n\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (var i = 0; i < size; i++) {\n        data[i] = Read_aiVertexWeight(stream);\n      }\n    }\n\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (var i = 0; i < size; i++) {\n        data[i] = Read_aiVectorKey(stream);\n      }\n    }\n\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (var i = 0; i < size; i++) {\n        data[i] = Read_aiQuatKey(stream);\n      }\n    }\n\n    function ReadBounds(stream, T\n    /*p*/\n    , n) {\n      // not sure what to do here, the data isn't really useful.\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR); // eslint-disable-line no-undef\n    }\n\n    function ai_assert(bool) {\n      if (!bool) throw 'asset failed';\n    }\n\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      var node = new aiNode();\n      node.mParent = parent;\n      node.mDepth = depth;\n      node.mName = Read_aiString(stream);\n      node.mTransformation = Read_aiMatrix4x4(stream);\n      node.mNumChildren = Read_unsigned_int(stream);\n      node.mNumMeshes = Read_unsigned_int(stream);\n\n      if (node.mNumMeshes) {\n        node.mMeshes = [];\n\n        for (var i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream);\n        }\n      }\n\n      if (node.mNumChildren) {\n        node.mChildren = [];\n\n        for (var _i7 = 0; _i7 < node.mNumChildren; ++_i7) {\n          var node2 = ReadBinaryNode(stream, node, depth++);\n          node.mChildren[_i7] = node2;\n        }\n      }\n\n      return node;\n    } // -----------------------------------------------------------------------------------\n\n\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      b.mName = Read_aiString(stream);\n      b.mNumWeights = Read_unsigned_int(stream);\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream); // for the moment we write dumb min/max values for the bones, too.\n      // maybe I'll add a better, hash-like solution later\n\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\n      } else {\n        // else write as usual\n        b.mWeights = [];\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n      }\n\n      return b;\n    }\n\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n      mesh.mNumVertices = Read_unsigned_int(stream);\n      mesh.mNumFaces = Read_unsigned_int(stream);\n      mesh.mNumBones = Read_unsigned_int(stream);\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\n      mesh.mNumUVComponents = []; // first of all, write bits for all existent vertex components\n\n      var c = Read_unsigned_int(stream);\n\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mVertices = [];\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mNormals = [];\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTangents = [];\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          mesh.mBitangents = [];\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      for (var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mColors[n] = [];\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n        }\n      }\n\n      mesh.mTexCoordsBuffers = [];\n\n      for (var _n = 0; _n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++_n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(_n))) break; // write number of UV components\n\n        mesh.mNumUVComponents[_n] = Read_unsigned_int(stream);\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[_n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTextureCoords[_n] = []; //note that assbin always writes 3d texcoords\n\n          mesh.mTexCoordsBuffers[_n] = [];\n\n          for (var uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\n\n            mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\n\n            readFloat(stream);\n          }\n        }\n      } // write faces. There are no floating-point calculations involved\n      // in these, so we can write a simple hash over the face data\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\n      // using Assimp's standard hashing function.\n\n\n      if (shortened) {\n        Read_unsigned_int(stream);\n      } else {\n        // else write as usual\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n        mesh.mFaces = [];\n        mesh.mIndexArray = [];\n\n        for (var i = 0; i < mesh.mNumFaces; ++i) {\n          var f = mesh.mFaces[i] = new aiFace(); // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\n          f.mNumIndices = Read_uint16_t(stream);\n          f.mIndices = [];\n\n          for (var a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream);\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream);\n            }\n          }\n\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[3]);\n            mesh.mIndexArray.push(f.mIndices[0]);\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n          }\n        }\n      } // write bones\n\n\n      if (mesh.mNumBones) {\n        mesh.mBones = [];\n\n        for (var _a = 0; _a < mesh.mNumBones; ++_a) {\n          mesh.mBones[_a] = new aiBone();\n          ReadBinaryBone(stream, mesh.mBones[_a]);\n        }\n      }\n    }\n\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      prop.mKey = Read_aiString(stream);\n      prop.mSemantic = Read_unsigned_int(stream);\n      prop.mIndex = Read_unsigned_int(stream);\n      prop.mDataLength = Read_unsigned_int(stream);\n      prop.mType = Read_unsigned_int(stream);\n      prop.mData = [];\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n    } // -----------------------------------------------------------------------------------\n\n\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties;\n        }\n\n        mat.mProperties = [];\n\n        for (var i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty();\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n        }\n      }\n    }\n\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      nd.mNodeName = Read_aiString(stream);\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\n      nd.mPreState = Read_unsigned_int(stream);\n      nd.mPostState = Read_unsigned_int(stream);\n\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        } else {\n          // else write as usual\n          nd.mPositionKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        }\n      }\n\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        } else {\n          // else write as usual\n          nd.mRotationKeys = [];\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        }\n      }\n\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        } else {\n          // else write as usual\n          nd.mScalingKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        }\n      }\n    }\n\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      anim.mName = Read_aiString(stream);\n      anim.mDuration = Read_double(stream);\n      anim.mTicksPerSecond = Read_double(stream);\n      anim.mNumChannels = Read_unsigned_int(stream);\n\n      if (anim.mNumChannels) {\n        anim.mChannels = [];\n\n        for (var a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim();\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n        }\n      }\n    }\n\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      tex.mWidth = Read_unsigned_int(stream);\n      tex.mHeight = Read_unsigned_int(stream);\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\n\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n        } else {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n        }\n      }\n    }\n\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      l.mName = Read_aiString(stream);\n      l.mType = Read_unsigned_int(stream);\n\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream);\n        l.mAttenuationLinear = readFloat(stream);\n        l.mAttenuationQuadratic = readFloat(stream);\n      }\n\n      l.mColorDiffuse = Read_aiColor3D(stream);\n      l.mColorSpecular = Read_aiColor3D(stream);\n      l.mColorAmbient = Read_aiColor3D(stream);\n\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream);\n        l.mAngleOuterCone = readFloat(stream);\n      }\n    }\n\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      cam.mName = Read_aiString(stream);\n      cam.mPosition = Read_aiVector3D(stream);\n      cam.mLookAt = Read_aiVector3D(stream);\n      cam.mUp = Read_aiVector3D(stream);\n      cam.mHorizontalFOV = readFloat(stream);\n      cam.mClipPlaneNear = readFloat(stream);\n      cam.mClipPlaneFar = readFloat(stream);\n      cam.mAspect = readFloat(stream);\n    }\n\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      scene.mFlags = Read_unsigned_int(stream);\n      scene.mNumMeshes = Read_unsigned_int(stream);\n      scene.mNumMaterials = Read_unsigned_int(stream);\n      scene.mNumAnimations = Read_unsigned_int(stream);\n      scene.mNumTextures = Read_unsigned_int(stream);\n      scene.mNumLights = Read_unsigned_int(stream);\n      scene.mNumCameras = Read_unsigned_int(stream); // Read node graph\n\n      scene.mRootNode = new aiNode();\n      scene.mRootNode = ReadBinaryNode(stream, null, 0); // Read all meshes\n\n      if (scene.mNumMeshes) {\n        scene.mMeshes = [];\n\n        for (var i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh();\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\n        }\n      } // Read materials\n\n\n      if (scene.mNumMaterials) {\n        scene.mMaterials = [];\n\n        for (var _i8 = 0; _i8 < scene.mNumMaterials; ++_i8) {\n          scene.mMaterials[_i8] = new aiMaterial();\n          ReadBinaryMaterial(stream, scene.mMaterials[_i8]);\n        }\n      } // Read all animations\n\n\n      if (scene.mNumAnimations) {\n        scene.mAnimations = [];\n\n        for (var _i9 = 0; _i9 < scene.mNumAnimations; ++_i9) {\n          scene.mAnimations[_i9] = new aiAnimation();\n          ReadBinaryAnim(stream, scene.mAnimations[_i9]);\n        }\n      } // Read all textures\n\n\n      if (scene.mNumTextures) {\n        scene.mTextures = [];\n\n        for (var _i10 = 0; _i10 < scene.mNumTextures; ++_i10) {\n          scene.mTextures[_i10] = new aiTexture();\n          ReadBinaryTexture(stream, scene.mTextures[_i10]);\n        }\n      } // Read lights\n\n\n      if (scene.mNumLights) {\n        scene.mLights = [];\n\n        for (var _i11 = 0; _i11 < scene.mNumLights; ++_i11) {\n          scene.mLights[_i11] = new aiLight();\n          ReadBinaryLight(stream, scene.mLights[_i11]);\n        }\n      } // Read cameras\n\n\n      if (scene.mNumCameras) {\n        scene.mCameras = [];\n\n        for (var _i12 = 0; _i12 < scene.mNumCameras; ++_i12) {\n          scene.mCameras[_i12] = new aiCamera();\n          ReadBinaryCamera(stream, scene.mCameras[_i12]);\n        }\n      }\n    }\n\n    var aiOrigin_CUR = 0;\n    var aiOrigin_BEG = 1;\n\n    function extendStream(stream) {\n      stream.readOffset = 0;\n\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off;\n        }\n\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off;\n        }\n      };\n\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n;\n\n        for (var i = 0; i < bytes; i++) {\n          buff[i] = Read_uint8_t(this);\n        }\n      };\n\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Float32Array(newbuff);\n      };\n\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint16Array(newbuff);\n      };\n\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint8Array(newbuff);\n      };\n\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint32Array(newbuff);\n      };\n    }\n\n    var shortened, compressed;\n\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene();\n      var stream = new DataView(pFiledata);\n      extendStream(stream);\n      stream.Seek(44, aiOrigin_CUR); // signature\n\n      /*unsigned int versionMajor =*/\n\n      pScene.versionMajor = Read_unsigned_int(stream);\n      /*unsigned int versionMinor =*/\n\n      pScene.versionMinor = Read_unsigned_int(stream);\n      /*unsigned int versionRevision =*/\n\n      pScene.versionRevision = Read_unsigned_int(stream);\n      /*unsigned int compileFlags =*/\n\n      pScene.compileFlags = Read_unsigned_int(stream);\n      shortened = Read_uint16_t(stream) > 0;\n      compressed = Read_uint16_t(stream) > 0;\n      if (shortened) throw 'Shortened binaries are not supported!';\n      stream.Seek(256, aiOrigin_CUR); // original filename\n\n      stream.Seek(128, aiOrigin_CUR); // options\n\n      stream.Seek(64, aiOrigin_CUR); // padding\n\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream);\n        var compressedSize = stream.FileSize() - stream.Tell();\n        var compressedData = [];\n        stream.Read(compressedData, 1, compressedSize);\n        var uncompressedData = [];\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize); // eslint-disable-line no-undef\n\n        var buff = new ArrayBuffer(uncompressedData);\n        ReadBinaryScene(buff, pScene);\n      } else {\n        ReadBinaryScene(stream, pScene);\n      }\n\n      return pScene.toTHREE();\n    }\n\n    return InternReadFile(buffer);\n  }\n});\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["mDepth","mNumMeshes","tempAniQuat","mIndexArray","mAttenuationLinear","lightMap","map","dataAsMap","mColorAmbient","object","z","nodeCount","w","mIndex","mAngleInnerCone","mMaterialIndex","mNumWeights","mHeight","threeNode","mPreState","mTangentBuffer","setTime","keys","AssimpLoader","mNumRotationKeys","mAnimations","mPositionKeys","quaternion","readOffset","dataAsBool","mNumFaces","mNumChannels","mNormalBuffer","prototype","TrackTargetNodeNameCompare","mColors","mParent","skinning","scale","mNumTextures","mTextures","mAttenuationQuadratic","addTrack","mBones","mDataLength","load","mColorDiffuse","hookupSkeletons","mNumLights","mTime","matrix","x","__esModule","mAngleOuterCone","mVertexBuffer","sortKeys","mLookAt","alphaMap","matrixAutoUpdate","mTransformation","keySortFunc","lerp","toString","normalMap","parseFromCollada","versionMinor","keySearchAccel","mDuration","mNumAnimations","subArrayUint16","mUp","subArrayUint8","mIndices","Seek","mNumAllocated","mAspect","mFaces","findNode","mFlags","mNumCameras","mNumScalingKeys","position","mAttenuationConstant","tempAniMatrix","dataAsColor","name","subArrayUint32","mNumMaterials","mBitangents","animation","value","mChannels","compileFlags","tempAniPos","KeyFrameTrack","tracks","mTangents","toTHREE","addKey","mPosition","mProperties","a","mTexCoordsBuffers","mNumProperties","mNumIndices","time","versionRevision","mScalingKeys","mType","length","ReadBytes","isBone","getLength","dataAsFloat","mNodeName","i","b","mMeshes","mRootNode","r","y","mColorSpecular","mChildren","init","mWeights","g","mMaterials","target","clone","parseFromThree","mSemantic","mLights","parse","texAchFormatHint","reTarget","fps","mTextureCoords","mNumPositionKeys","mClipPlaneFar","mTicksPerSecond","mNumUVComponents","mData","mVertices","mKey","mWidth","mWeight","mNumChildren","mPrimitiveTypes","mBitangentBuffer","mClipPlaneNear","subArray32","mNormals","matrixWorldNeedsUpdate","mNumVertices","mCameras","mColorBuffer","data","mHorizontalFOV","pcData","mName","tempAniScale","mValue","KeyFrame","mNumBones","mOffsetMatrix","mVertexId","Animation","elements","dataAsString","nodeToBoneMap","mPostState","mRotationKeys","constructor","_accelTable","versionMajor"]],"~:compiled-at",1630917515861,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$AssimpLoader.js\",\n\"lineCount\":62,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/AssimpLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$AssimpLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.AssimpLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar AssimpLoader = function AssimpLoader(manager) {\\n  _three.Loader.call(this, manager);\\n};\\n\\nexports.AssimpLoader = AssimpLoader;\\nAssimpLoader.prototype = Object.assign(Object.create(_three.Loader.prototype), {\\n  constructor: AssimpLoader,\\n  load: function load(url, onLoad, onProgress, onError) {\\n    var scope = this;\\n    var path = scope.path === '' ? _three.LoaderUtils.extractUrlBase(url) : scope.path;\\n    var loader = new _three.FileLoader(scope.manager);\\n    loader.setPath(scope.path);\\n    loader.setResponseType('arraybuffer');\\n    loader.setRequestHeader(scope.requestHeader);\\n    loader.setWithCredentials(scope.withCredentials);\\n    loader.load(url, function (buffer) {\\n      try {\\n        onLoad(scope.parse(buffer, path));\\n      } catch (e) {\\n        if (onError) {\\n          onError(e);\\n        } else {\\n          console.error(e);\\n        }\\n\\n        scope.manager.itemError(url);\\n      }\\n    }, onProgress, onError);\\n  },\\n  parse: function parse(buffer, path) {\\n    var textureLoader = new _three.TextureLoader(this.manager);\\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\\n    var Virtulous = {};\\n\\n    Virtulous.KeyFrame = function (time, matrix) {\\n      this.time = time;\\n      this.matrix = matrix.clone();\\n      this.position = new _three.Vector3();\\n      this.quaternion = new _three.Quaternion();\\n      this.scale = new _three.Vector3(1, 1, 1);\\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\\n\\n      this.clone = function () {\\n        var n = new Virtulous.KeyFrame(this.time, this.matrix);\\n        return n;\\n      };\\n\\n      this.lerp = function (nextKey, time) {\\n        time -= this.time;\\n        var dist = nextKey.time - this.time;\\n        var l = time / dist;\\n        var l2 = 1 - l;\\n        var keypos = this.position;\\n        var keyrot = this.quaternion; //      var keyscl =  key.parentspaceScl || key.scl;\\n\\n        var key2pos = nextKey.position;\\n        var key2rot = nextKey.quaternion; //  var key2scl =  key2.parentspaceScl || key2.scl;\\n\\n        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\\n        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\\n        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l; //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\\n        //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\\n        //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\\n\\n        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\\n        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\\n        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\\n      };\\n    };\\n\\n    Virtulous.KeyFrame.tempAniPos = new _three.Vector3();\\n    Virtulous.KeyFrame.tempAniQuat = new _three.Quaternion();\\n    Virtulous.KeyFrame.tempAniScale = new _three.Vector3(1, 1, 1);\\n    Virtulous.KeyFrame.tempAniMatrix = new _three.Matrix4();\\n\\n    Virtulous.KeyFrameTrack = function () {\\n      this.keys = [];\\n      this.target = null;\\n      this.time = 0;\\n      this.length = 0;\\n      this._accelTable = {};\\n      this.fps = 20;\\n\\n      this.addKey = function (key) {\\n        this.keys.push(key);\\n      };\\n\\n      this.init = function () {\\n        this.sortKeys();\\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\\n        if (!this.fps) return;\\n\\n        for (var j = 0; j < this.length * this.fps; j++) {\\n          for (var i = 0; i < this.keys.length; i++) {\\n            if (this.keys[i].time == j) {\\n              this._accelTable[j] = i;\\n              break;\\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\\n              this._accelTable[j] = i;\\n              break;\\n            }\\n          }\\n        }\\n      };\\n\\n      this.parseFromThree = function (data) {\\n        var fps = data.fps;\\n        this.target = data.node;\\n        var track = data.hierarchy[0].keys;\\n\\n        for (var i = 0; i < track.length; i++) {\\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\\n        }\\n\\n        this.init();\\n      };\\n\\n      this.parseFromCollada = function (data) {\\n        var track = data.keys;\\n        var fps = this.fps;\\n\\n        for (var i = 0; i < track.length; i++) {\\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\\n        }\\n\\n        this.init();\\n      };\\n\\n      this.sortKeys = function () {\\n        this.keys.sort(this.keySortFunc);\\n      };\\n\\n      this.keySortFunc = function (a, b) {\\n        return a.time - b.time;\\n      };\\n\\n      this.clone = function () {\\n        var t = new Virtulous.KeyFrameTrack();\\n        t.target = this.target;\\n        t.time = this.time;\\n        t.length = this.length;\\n\\n        for (var i = 0; i < this.keys.length; i++) {\\n          t.addKey(this.keys[i].clone());\\n        }\\n\\n        t.init();\\n        return t;\\n      };\\n\\n      this.reTarget = function (root, compareitor) {\\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\\n        this.target = compareitor(root, this.target);\\n      };\\n\\n      this.keySearchAccel = function (time) {\\n        time *= this.fps;\\n        time = Math.floor(time);\\n        return this._accelTable[time] || 0;\\n      };\\n\\n      this.setTime = function (time) {\\n        time = Math.abs(time);\\n        if (this.length) time = time % this.length + 0.05;\\n        var key0 = null;\\n        var key1 = null;\\n\\n        for (var i = this.keySearchAccel(time); i < this.keys.length; i++) {\\n          if (this.keys[i].time == time) {\\n            key0 = this.keys[i];\\n            key1 = this.keys[i];\\n            break;\\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\\n            key0 = this.keys[i];\\n            key1 = this.keys[i + 1];\\n            break;\\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\\n            key0 = this.keys[i];\\n            key1 = this.keys[0].clone();\\n            key1.time += this.length + 0.05;\\n            break;\\n          }\\n        }\\n\\n        if (key0 && key1 && key0 !== key1) {\\n          this.target.matrixAutoUpdate = false;\\n          this.target.matrix.copy(key0.lerp(key1, time));\\n          this.target.matrixWorldNeedsUpdate = true;\\n          return;\\n        }\\n\\n        if (key0 && key1 && key0 == key1) {\\n          this.target.matrixAutoUpdate = false;\\n          this.target.matrix.copy(key0.matrix);\\n          this.target.matrixWorldNeedsUpdate = true;\\n          return;\\n        }\\n      };\\n    };\\n\\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\\n      function find(node, name) {\\n        if (node.name == name) return node;\\n\\n        for (var i = 0; i < node.children.length; i++) {\\n          var r = find(node.children[i], name);\\n          if (r) return r;\\n        }\\n\\n        return null;\\n      }\\n\\n      return find(root, target.name);\\n    };\\n\\n    Virtulous.Animation = function () {\\n      this.tracks = [];\\n      this.length = 0;\\n\\n      this.addTrack = function (track) {\\n        this.tracks.push(track);\\n        this.length = Math.max(track.length, this.length);\\n      };\\n\\n      this.setTime = function (time) {\\n        this.time = time;\\n\\n        for (var i = 0; i < this.tracks.length; i++) {\\n          this.tracks[i].setTime(time);\\n        }\\n      };\\n\\n      this.clone = function (target, compareitor) {\\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\\n        var n = new Virtulous.Animation();\\n        n.target = target;\\n\\n        for (var i = 0; i < this.tracks.length; i++) {\\n          var track = this.tracks[i].clone();\\n          track.reTarget(target, compareitor);\\n          n.addTrack(track);\\n        }\\n\\n        return n;\\n      };\\n    };\\n\\n    var ASSBIN_CHUNK_AICAMERA = 0x1234;\\n    var ASSBIN_CHUNK_AILIGHT = 0x1235;\\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236;\\n    var ASSBIN_CHUNK_AIMESH = 0x1237;\\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238;\\n    var ASSBIN_CHUNK_AISCENE = 0x1239;\\n    var ASSBIN_CHUNK_AIBONE = 0x123a;\\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b;\\n    var ASSBIN_CHUNK_AINODE = 0x123c;\\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d;\\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1;\\n    var ASSBIN_MESH_HAS_NORMALS = 0x2;\\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4; //var aiLightSource_UNDEFINED = 0x0;\\n    //! A directional light source has a well-defined direction\\n    //! but is infinitely far away. That's quite a good\\n    //! approximation for sun light.\\n\\n    var aiLightSource_DIRECTIONAL = 0x1; //! A point light source has a well-defined position\\n    //! in space but no direction - it emits light in all\\n    //! directions. A normal bulb is a point light.\\n    //var aiLightSource_POINT = 0x2;\\n    //! A spot light source emits light in a specific\\n    //! angle. It has a position and a direction it is pointing to.\\n    //! A good example for a spot light is a light spot in\\n    //! sport arenas.\\n\\n    var aiLightSource_SPOT = 0x3; //! The generic light level of the world, including the bounces\\n    //! of all other lightsources.\\n    //! Typically, there's at most one ambient light in a scene.\\n    //! This light type doesn't have a valid position, direction, or\\n    //! other properties, just a color.\\n    //var aiLightSource_AMBIENT = 0x4;\\n\\n    /** Flat shading. Shading is done on per-face base,\\n     *  diffuse only. Also known as 'faceted shading'.\\n     */\\n    //var aiShadingMode_Flat = 0x1;\\n\\n    /** Simple Gouraud shading.\\n     */\\n    //var aiShadingMode_Gouraud = 0x2;\\n\\n    /** Phong-Shading -\\n     */\\n    //var aiShadingMode_Phong = 0x3;\\n\\n    /** Phong-Blinn-Shading\\n     */\\n    //var aiShadingMode_Blinn = 0x4;\\n\\n    /** Toon-Shading per pixel\\n     *\\n     *  Also known as 'comic' shader.\\n     */\\n    //var aiShadingMode_Toon = 0x5;\\n\\n    /** OrenNayar-Shading per pixel\\n     *\\n     *  Extension to standard Lambertian shading, taking the\\n     *  roughness of the material into account\\n     */\\n    //var aiShadingMode_OrenNayar = 0x6;\\n\\n    /** Minnaert-Shading per pixel\\n     *\\n     *  Extension to standard Lambertian shading, taking the\\n     *  \\\"darkness\\\" of the material into account\\n     */\\n    //var aiShadingMode_Minnaert = 0x7;\\n\\n    /** CookTorrance-Shading per pixel\\n     *\\n     *  Special shader for metallic surfaces.\\n     */\\n    //var aiShadingMode_CookTorrance = 0x8;\\n\\n    /** No shading at all. Constant light influence of 1.0.\\n     */\\n    //var aiShadingMode_NoShading = 0x9;\\n\\n    /** Fresnel shading\\n     */\\n    //var aiShadingMode_Fresnel = 0xa;\\n    //var aiTextureType_NONE = 0x0;\\n\\n    /** The texture is combined with the result of the diffuse\\n     *  lighting equation.\\n     */\\n\\n    var aiTextureType_DIFFUSE = 0x1;\\n    /** The texture is combined with the result of the specular\\n     *  lighting equation.\\n     */\\n    //var aiTextureType_SPECULAR = 0x2;\\n\\n    /** The texture is combined with the result of the ambient\\n     *  lighting equation.\\n     */\\n    //var aiTextureType_AMBIENT = 0x3;\\n\\n    /** The texture is added to the result of the lighting\\n     *  calculation. It isn't influenced by incoming light.\\n     */\\n    //var aiTextureType_EMISSIVE = 0x4;\\n\\n    /** The texture is a height map.\\n     *\\n     *  By convention, higher gray-scale values stand for\\n     *  higher elevations from the base height.\\n     */\\n    //var aiTextureType_HEIGHT = 0x5;\\n\\n    /** The texture is a (tangent space) normal-map.\\n     *\\n     *  Again, there are several conventions for tangent-space\\n     *  normal maps. Assimp does (intentionally) not\\n     *  distinguish here.\\n     */\\n\\n    var aiTextureType_NORMALS = 0x6;\\n    /** The texture defines the glossiness of the material.\\n     *\\n     *  The glossiness is in fact the exponent of the specular\\n     *  (phong) lighting equation. Usually there is a conversion\\n     *  function defined to map the linear color values in the\\n     *  texture to a suitable exponent. Have fun.\\n     */\\n    //var aiTextureType_SHININESS = 0x7;\\n\\n    /** The texture defines per-pixel opacity.\\n     *\\n     *  Usually 'white' means opaque and 'black' means\\n     *  'transparency'. Or quite the opposite. Have fun.\\n     */\\n\\n    var aiTextureType_OPACITY = 0x8;\\n    /** Displacement texture\\n     *\\n     *  The exact purpose and format is application-dependent.\\n     *  Higher color values stand for higher vertex displacements.\\n     */\\n    //var aiTextureType_DISPLACEMENT = 0x9;\\n\\n    /** Lightmap texture (aka Ambient Occlusion)\\n     *\\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\\n     *  covered by this material property. The texture contains a\\n     *  scaling value for the final color value of a pixel. Its\\n     *  intensity is not affected by incoming light.\\n     */\\n\\n    var aiTextureType_LIGHTMAP = 0xa;\\n    /** Reflection texture\\n     *\\n     * Contains the color of a perfect mirror reflection.\\n     * Rarely used, almost never for real-time applications.\\n     */\\n    //var aiTextureType_REFLECTION = 0xB;\\n\\n    /** Unknown texture\\n     *\\n     *  A texture reference that does not match any of the definitions\\n     *  above is considered to be 'unknown'. It is still imported,\\n     *  but is excluded from any further postprocessing.\\n     */\\n    //var aiTextureType_UNKNOWN = 0xC;\\n\\n    var BONESPERVERT = 4;\\n\\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\\n    }\\n\\n    function ASSBIN_MESH_HAS_COLOR(n) {\\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\\n    }\\n\\n    function markBones(scene) {\\n      for (var i in scene.mMeshes) {\\n        var mesh = scene.mMeshes[i];\\n\\n        for (var k in mesh.mBones) {\\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\\n          if (boneNode) boneNode.isBone = true;\\n        }\\n      }\\n    }\\n\\n    function cloneTreeToBones(root, scene) {\\n      var rootBone = new _three.Bone();\\n      rootBone.matrix.copy(root.matrix);\\n      rootBone.matrixWorld.copy(root.matrixWorld);\\n      rootBone.position.copy(root.position);\\n      rootBone.quaternion.copy(root.quaternion);\\n      rootBone.scale.copy(root.scale);\\n      scene.nodeCount++;\\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString();\\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\\n      scene.nodeToBoneMap[root.name].push(rootBone);\\n\\n      for (var i in root.children) {\\n        var child = cloneTreeToBones(root.children[i], scene);\\n        rootBone.add(child);\\n      }\\n\\n      return rootBone;\\n    }\\n\\n    function sortWeights(indexes, weights) {\\n      var pairs = [];\\n\\n      for (var i = 0; i < indexes.length; i++) {\\n        pairs.push({\\n          i: indexes[i],\\n          w: weights[i]\\n        });\\n      }\\n\\n      pairs.sort(function (a, b) {\\n        return b.w - a.w;\\n      });\\n\\n      while (pairs.length < 4) {\\n        pairs.push({\\n          i: 0,\\n          w: 0\\n        });\\n      }\\n\\n      if (pairs.length > 4) pairs.length = 4;\\n      var sum = 0;\\n\\n      for (var _i = 0; _i < 4; _i++) {\\n        sum += pairs[_i].w * pairs[_i].w;\\n      }\\n\\n      sum = Math.sqrt(sum);\\n\\n      for (var _i2 = 0; _i2 < 4; _i2++) {\\n        pairs[_i2].w = pairs[_i2].w / sum;\\n        indexes[_i2] = pairs[_i2].i;\\n        weights[_i2] = pairs[_i2].w;\\n      }\\n    }\\n\\n    function findMatchingBone(root, name) {\\n      if (root.name.indexOf('bone_' + name) == 0) return root;\\n\\n      for (var i in root.children) {\\n        var ret = findMatchingBone(root.children[i], name);\\n        if (ret) return ret;\\n      }\\n\\n      return undefined;\\n    }\\n\\n    function aiMesh() {\\n      this.mPrimitiveTypes = 0;\\n      this.mNumVertices = 0;\\n      this.mNumFaces = 0;\\n      this.mNumBones = 0;\\n      this.mMaterialIndex = 0;\\n      this.mVertices = [];\\n      this.mNormals = [];\\n      this.mTangents = [];\\n      this.mBitangents = [];\\n      this.mColors = [[]];\\n      this.mTextureCoords = [[]];\\n      this.mFaces = [];\\n      this.mBones = [];\\n\\n      this.hookupSkeletons = function (scene) {\\n        if (this.mBones.length == 0) return;\\n        var allBones = [];\\n        var offsetMatrix = [];\\n        var skeletonRoot = scene.findNode(this.mBones[0].mName);\\n\\n        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\\n          skeletonRoot = skeletonRoot.mParent;\\n        }\\n\\n        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\\n        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\\n        this.threeNode.add(threeSkeletonRootBone);\\n\\n        for (var i = 0; i < this.mBones.length; i++) {\\n          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\\n\\n          if (bone) {\\n            var tbone = bone;\\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\\n\\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\\n          } else {\\n            var skeletonRoot = scene.findNode(this.mBones[i].mName);\\n            if (!skeletonRoot) return;\\n            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\\n            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\\n            this.threeNode.add(threeSkeletonRootBone);\\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\\n            var tbone = bone;\\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\\n\\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\\n          }\\n        }\\n\\n        var skeleton = new _three.Skeleton(allBones, offsetMatrix);\\n        this.threeNode.bind(skeleton, new _three.Matrix4());\\n        this.threeNode.material.skinning = true;\\n      };\\n\\n      this.toTHREE = function (scene) {\\n        if (this.threeNode) return this.threeNode;\\n        var geometry = new _three.BufferGeometry();\\n        var mat;\\n        if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new _three.MeshLambertMaterial();\\n        geometry.setIndex(new _three.BufferAttribute(new Uint32Array(this.mIndexArray), 1));\\n        geometry.setAttribute('position', new _three.BufferAttribute(this.mVertexBuffer, 3));\\n        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) geometry.setAttribute('normal', new _three.BufferAttribute(this.mNormalBuffer, 3));\\n        if (this.mColorBuffer && this.mColorBuffer.length > 0) geometry.setAttribute('color', new _three.BufferAttribute(this.mColorBuffer, 4));\\n        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) geometry.setAttribute('uv', new _three.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\\n        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) geometry.setAttribute('uv1', new _three.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\\n        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) geometry.setAttribute('tangents', new _three.BufferAttribute(this.mTangentBuffer, 3));\\n        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) geometry.setAttribute('bitangents', new _three.BufferAttribute(this.mBitangentBuffer, 3));\\n\\n        if (this.mBones.length > 0) {\\n          var weights = [];\\n          var bones = [];\\n\\n          for (var i = 0; i < this.mBones.length; i++) {\\n            for (var j = 0; j < this.mBones[i].mWeights.length; j++) {\\n              var weight = this.mBones[i].mWeights[j];\\n\\n              if (weight) {\\n                if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\\n                if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\\n                weights[weight.mVertexId].push(weight.mWeight);\\n                bones[weight.mVertexId].push(parseInt(i));\\n              }\\n            }\\n          }\\n\\n          for (var _i3 in bones) {\\n            sortWeights(bones[_i3], weights[_i3]);\\n          }\\n\\n          var _weights = [];\\n          var _bones = [];\\n\\n          for (var _i4 = 0; _i4 < weights.length; _i4++) {\\n            for (var _j = 0; _j < 4; _j++) {\\n              if (weights[_i4] && bones[_i4]) {\\n                _weights.push(weights[_i4][_j]);\\n\\n                _bones.push(bones[_i4][_j]);\\n              } else {\\n                _weights.push(0);\\n\\n                _bones.push(0);\\n              }\\n            }\\n          }\\n\\n          geometry.setAttribute('skinWeight', new _three.BufferAttribute(new Float32Array(_weights), BONESPERVERT));\\n          geometry.setAttribute('skinIndex', new _three.BufferAttribute(new Float32Array(_bones), BONESPERVERT));\\n        }\\n\\n        var mesh;\\n        if (this.mBones.length == 0) mesh = new _three.Mesh(geometry, mat);\\n\\n        if (this.mBones.length > 0) {\\n          mesh = new _three.SkinnedMesh(geometry, mat);\\n          mesh.normalizeSkinWeights();\\n        }\\n\\n        this.threeNode = mesh; //mesh.matrixAutoUpdate = false;\\n\\n        return mesh;\\n      };\\n    }\\n\\n    function aiFace() {\\n      this.mNumIndices = 0;\\n      this.mIndices = [];\\n    }\\n\\n    function aiVector3D() {\\n      this.x = 0;\\n      this.y = 0;\\n      this.z = 0;\\n\\n      this.toTHREE = function () {\\n        return new _three.Vector3(this.x, this.y, this.z);\\n      };\\n    }\\n\\n    function aiColor3D() {\\n      this.r = 0;\\n      this.g = 0;\\n      this.b = 0;\\n      this.a = 0;\\n\\n      this.toTHREE = function () {\\n        return new _three.Color(this.r, this.g, this.b);\\n      };\\n    }\\n\\n    function aiQuaternion() {\\n      this.x = 0;\\n      this.y = 0;\\n      this.z = 0;\\n      this.w = 0;\\n\\n      this.toTHREE = function () {\\n        return new _three.Quaternion(this.x, this.y, this.z, this.w);\\n      };\\n    }\\n\\n    function aiVertexWeight() {\\n      this.mVertexId = 0;\\n      this.mWeight = 0;\\n    }\\n\\n    function aiString() {\\n      this.data = [];\\n\\n      this.toString = function () {\\n        var str = '';\\n        this.data.forEach(function (i) {\\n          str += String.fromCharCode(i);\\n        });\\n        return str.replace(/[^\\\\x20-\\\\x7E]+/g, '');\\n      };\\n    }\\n\\n    function aiVectorKey() {\\n      this.mTime = 0;\\n      this.mValue = null;\\n    }\\n\\n    function aiQuatKey() {\\n      this.mTime = 0;\\n      this.mValue = null;\\n    }\\n\\n    function aiNode() {\\n      this.mName = '';\\n      this.mTransformation = [];\\n      this.mNumChildren = 0;\\n      this.mNumMeshes = 0;\\n      this.mMeshes = [];\\n      this.mChildren = [];\\n\\n      this.toTHREE = function (scene) {\\n        if (this.threeNode) return this.threeNode;\\n        var o = new _three.Object3D();\\n        o.name = this.mName;\\n        o.matrix = this.mTransformation.toTHREE();\\n\\n        for (var i = 0; i < this.mChildren.length; i++) {\\n          o.add(this.mChildren[i].toTHREE(scene));\\n        }\\n\\n        for (var _i5 = 0; _i5 < this.mMeshes.length; _i5++) {\\n          o.add(scene.mMeshes[this.mMeshes[_i5]].toTHREE(scene));\\n        }\\n\\n        this.threeNode = o; //o.matrixAutoUpdate = false;\\n\\n        o.matrix.decompose(o.position, o.quaternion, o.scale);\\n        return o;\\n      };\\n    }\\n\\n    function aiBone() {\\n      this.mName = '';\\n      this.mNumWeights = 0;\\n      this.mOffsetMatrix = 0;\\n    }\\n\\n    function aiMaterialProperty() {\\n      this.mKey = '';\\n      this.mSemantic = 0;\\n      this.mIndex = 0;\\n      this.mData = [];\\n      this.mDataLength = 0;\\n      this.mType = 0;\\n\\n      this.dataAsColor = function () {\\n        var array = new Uint8Array(this.mData).buffer;\\n        var reader = new DataView(array);\\n        var r = reader.getFloat32(0, true);\\n        var g = reader.getFloat32(4, true);\\n        var b = reader.getFloat32(8, true); //var a = reader.getFloat32(12, true);\\n\\n        return new _three.Color(r, g, b);\\n      };\\n\\n      this.dataAsFloat = function () {\\n        var array = new Uint8Array(this.mData).buffer;\\n        var reader = new DataView(array);\\n        var r = reader.getFloat32(0, true);\\n        return r;\\n      };\\n\\n      this.dataAsBool = function () {\\n        var array = new Uint8Array(this.mData).buffer;\\n        var reader = new DataView(array);\\n        var r = reader.getFloat32(0, true);\\n        return !!r;\\n      };\\n\\n      this.dataAsString = function () {\\n        var s = new aiString();\\n        s.data = this.mData;\\n        return s.toString();\\n      };\\n\\n      this.dataAsMap = function () {\\n        var s = new aiString();\\n        s.data = this.mData;\\n        var path = s.toString();\\n        path = path.replace(/\\\\\\\\/g, '/');\\n\\n        if (path.indexOf('/') != -1) {\\n          path = path.substr(path.lastIndexOf('/') + 1);\\n        }\\n\\n        return textureLoader.load(path);\\n      };\\n    }\\n\\n    var namePropMapping = {\\n      '?mat.name': 'name',\\n      '$mat.shadingm': 'shading',\\n      '$mat.twosided': 'twoSided',\\n      '$mat.wireframe': 'wireframe',\\n      '$clr.ambient': 'ambient',\\n      '$clr.diffuse': 'color',\\n      '$clr.specular': 'specular',\\n      '$clr.emissive': 'emissive',\\n      '$clr.transparent': 'transparent',\\n      '$clr.reflective': 'reflect',\\n      '$mat.shininess': 'shininess',\\n      '$mat.reflectivity': 'reflectivity',\\n      '$mat.refracti': 'refraction',\\n      '$tex.file': 'map'\\n    };\\n    var nameTypeMapping = {\\n      '?mat.name': 'string',\\n      '$mat.shadingm': 'bool',\\n      '$mat.twosided': 'bool',\\n      '$mat.wireframe': 'bool',\\n      '$clr.ambient': 'color',\\n      '$clr.diffuse': 'color',\\n      '$clr.specular': 'color',\\n      '$clr.emissive': 'color',\\n      '$clr.transparent': 'color',\\n      '$clr.reflective': 'color',\\n      '$mat.shininess': 'float',\\n      '$mat.reflectivity': 'float',\\n      '$mat.refracti': 'float',\\n      '$tex.file': 'map'\\n    };\\n\\n    function aiMaterial() {\\n      this.mNumAllocated = 0;\\n      this.mNumProperties = 0;\\n      this.mProperties = [];\\n\\n      this.toTHREE = function () {\\n        var mat = new _three.MeshPhongMaterial();\\n\\n        for (var i = 0; i < this.mProperties.length; i++) {\\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'float') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'color') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'string') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\\n\\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\\n            var prop = this.mProperties[i];\\n            if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\\n            if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\\n            if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\\n            if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\\n          }\\n        }\\n\\n        mat.ambient.r = 0.53;\\n        mat.ambient.g = 0.53;\\n        mat.ambient.b = 0.53;\\n        mat.color.r = 1;\\n        mat.color.g = 1;\\n        mat.color.b = 1;\\n        return mat;\\n      };\\n    }\\n\\n    function veclerp(v1, v2, l) {\\n      var v = new _three.Vector3();\\n      var lm1 = 1 - l;\\n      v.x = v1.x * l + v2.x * lm1;\\n      v.y = v1.y * l + v2.y * lm1;\\n      v.z = v1.z * l + v2.z * lm1;\\n      return v;\\n    }\\n\\n    function quatlerp(q1, q2, l) {\\n      return q1.clone().slerp(q2, 1 - l);\\n    }\\n\\n    function sampleTrack(keys, time, lne, lerp) {\\n      if (keys.length == 1) return keys[0].mValue.toTHREE();\\n      var dist = Infinity;\\n      var key = null;\\n      var nextKey = null;\\n\\n      for (var i = 0; i < keys.length; i++) {\\n        var timeDist = Math.abs(keys[i].mTime - time);\\n\\n        if (timeDist < dist && keys[i].mTime <= time) {\\n          dist = timeDist;\\n          key = keys[i];\\n          nextKey = keys[i + 1];\\n        }\\n      }\\n\\n      if (!key) {\\n        return null;\\n      } else if (nextKey) {\\n        var dT = nextKey.mTime - key.mTime;\\n        var T = key.mTime - time;\\n        var l = T / dT;\\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\\n      } else {\\n        nextKey = keys[0].clone();\\n        nextKey.mTime += lne;\\n        var dT = nextKey.mTime - key.mTime;\\n        var T = key.mTime - time;\\n        var l = T / dT;\\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\\n      }\\n    }\\n\\n    function aiNodeAnim() {\\n      this.mNodeName = '';\\n      this.mNumPositionKeys = 0;\\n      this.mNumRotationKeys = 0;\\n      this.mNumScalingKeys = 0;\\n      this.mPositionKeys = [];\\n      this.mRotationKeys = [];\\n      this.mScalingKeys = [];\\n      this.mPreState = '';\\n      this.mPostState = '';\\n\\n      this.init = function (tps) {\\n        if (!tps) tps = 1;\\n\\n        function t(t) {\\n          t.mTime /= tps;\\n        }\\n\\n        this.mPositionKeys.forEach(t);\\n        this.mRotationKeys.forEach(t);\\n        this.mScalingKeys.forEach(t);\\n      };\\n\\n      this.sortKeys = function () {\\n        function comp(a, b) {\\n          return a.mTime - b.mTime;\\n        }\\n\\n        this.mPositionKeys.sort(comp);\\n        this.mRotationKeys.sort(comp);\\n        this.mScalingKeys.sort(comp);\\n      };\\n\\n      this.getLength = function () {\\n        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\\n          return a.mTime;\\n        })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\\n          return a.mTime;\\n        })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\\n          return a.mTime;\\n        })));\\n      };\\n\\n      this.toTHREE = function (o) {\\n        this.sortKeys();\\n        var length = this.getLength();\\n        var track = new Virtulous.KeyFrameTrack();\\n\\n        for (var i = 0; i < length; i += 0.05) {\\n          var matrix = new _three.Matrix4();\\n          var time = i;\\n          var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\\n          var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\\n          var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\\n          matrix.compose(pos, rotation, scale);\\n          var key = new Virtulous.KeyFrame(time, matrix);\\n          track.addKey(key);\\n        }\\n\\n        track.target = o.findNode(this.mNodeName).toTHREE();\\n        var tracks = [track];\\n\\n        if (o.nodeToBoneMap[this.mNodeName]) {\\n          for (var _i6 = 0; _i6 < o.nodeToBoneMap[this.mNodeName].length; _i6++) {\\n            var t2 = track.clone();\\n            t2.target = o.nodeToBoneMap[this.mNodeName][_i6];\\n            tracks.push(t2);\\n          }\\n        }\\n\\n        return tracks;\\n      };\\n    }\\n\\n    function aiAnimation() {\\n      this.mName = '';\\n      this.mDuration = 0;\\n      this.mTicksPerSecond = 0;\\n      this.mNumChannels = 0;\\n      this.mChannels = [];\\n\\n      this.toTHREE = function (root) {\\n        var animationHandle = new Virtulous.Animation();\\n\\n        for (var i in this.mChannels) {\\n          this.mChannels[i].init(this.mTicksPerSecond);\\n          var tracks = this.mChannels[i].toTHREE(root);\\n\\n          for (var j in tracks) {\\n            tracks[j].init();\\n            animationHandle.addTrack(tracks[j]);\\n          }\\n        }\\n\\n        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\\n          return e.length;\\n        }));\\n        return animationHandle;\\n      };\\n    }\\n\\n    function aiTexture() {\\n      this.mWidth = 0;\\n      this.mHeight = 0;\\n      this.texAchFormatHint = [];\\n      this.pcData = [];\\n    }\\n\\n    function aiLight() {\\n      this.mName = '';\\n      this.mType = 0;\\n      this.mAttenuationConstant = 0;\\n      this.mAttenuationLinear = 0;\\n      this.mAttenuationQuadratic = 0;\\n      this.mAngleInnerCone = 0;\\n      this.mAngleOuterCone = 0;\\n      this.mColorDiffuse = null;\\n      this.mColorSpecular = null;\\n      this.mColorAmbient = null;\\n    }\\n\\n    function aiCamera() {\\n      this.mName = '';\\n      this.mPosition = null;\\n      this.mLookAt = null;\\n      this.mUp = null;\\n      this.mHorizontalFOV = 0;\\n      this.mClipPlaneNear = 0;\\n      this.mClipPlaneFar = 0;\\n      this.mAspect = 0;\\n    }\\n\\n    function aiScene() {\\n      this.versionMajor = 0;\\n      this.versionMinor = 0;\\n      this.versionRevision = 0;\\n      this.compileFlags = 0;\\n      this.mFlags = 0;\\n      this.mNumMeshes = 0;\\n      this.mNumMaterials = 0;\\n      this.mNumAnimations = 0;\\n      this.mNumTextures = 0;\\n      this.mNumLights = 0;\\n      this.mNumCameras = 0;\\n      this.mRootNode = null;\\n      this.mMeshes = [];\\n      this.mMaterials = [];\\n      this.mAnimations = [];\\n      this.mLights = [];\\n      this.mCameras = [];\\n      this.nodeToBoneMap = {};\\n\\n      this.findNode = function (name, root) {\\n        if (!root) {\\n          root = this.mRootNode;\\n        }\\n\\n        if (root.mName == name) {\\n          return root;\\n        }\\n\\n        for (var i = 0; i < root.mChildren.length; i++) {\\n          var ret = this.findNode(name, root.mChildren[i]);\\n          if (ret) return ret;\\n        }\\n\\n        return null;\\n      };\\n\\n      this.toTHREE = function () {\\n        this.nodeCount = 0;\\n        markBones(this);\\n        var o = this.mRootNode.toTHREE(this);\\n\\n        for (var i in this.mMeshes) {\\n          this.mMeshes[i].hookupSkeletons(this);\\n        }\\n\\n        if (this.mAnimations.length > 0) {\\n          var a = this.mAnimations[0].toTHREE(this);\\n        }\\n\\n        return {\\n          object: o,\\n          animation: a\\n        };\\n      };\\n    }\\n\\n    function aiMatrix4() {\\n      this.elements = [[], [], [], []];\\n\\n      this.toTHREE = function () {\\n        var m = new _three.Matrix4();\\n\\n        for (var i = 0; i < 4; ++i) {\\n          for (var i2 = 0; i2 < 4; ++i2) {\\n            m.elements[i * 4 + i2] = this.elements[i2][i];\\n          }\\n        }\\n\\n        return m;\\n      };\\n    }\\n\\n    var littleEndian = true;\\n\\n    function readFloat(dataview) {\\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\\n      dataview.readOffset += 4;\\n      return val;\\n    }\\n\\n    function Read_double(dataview) {\\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\\n      dataview.readOffset += 8;\\n      return val;\\n    }\\n\\n    function Read_uint8_t(dataview) {\\n      var val = dataview.getUint8(dataview.readOffset);\\n      dataview.readOffset += 1;\\n      return val;\\n    }\\n\\n    function Read_uint16_t(dataview) {\\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\\n      dataview.readOffset += 2;\\n      return val;\\n    }\\n\\n    function Read_unsigned_int(dataview) {\\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\\n      dataview.readOffset += 4;\\n      return val;\\n    }\\n\\n    function Read_uint32_t(dataview) {\\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\\n      dataview.readOffset += 4;\\n      return val;\\n    }\\n\\n    function Read_aiVector3D(stream) {\\n      var v = new aiVector3D();\\n      v.x = readFloat(stream);\\n      v.y = readFloat(stream);\\n      v.z = readFloat(stream);\\n      return v;\\n    }\\n\\n    function Read_aiColor3D(stream) {\\n      var c = new aiColor3D();\\n      c.r = readFloat(stream);\\n      c.g = readFloat(stream);\\n      c.b = readFloat(stream);\\n      return c;\\n    }\\n\\n    function Read_aiQuaternion(stream) {\\n      var v = new aiQuaternion();\\n      v.w = readFloat(stream);\\n      v.x = readFloat(stream);\\n      v.y = readFloat(stream);\\n      v.z = readFloat(stream);\\n      return v;\\n    }\\n\\n    function Read_aiString(stream) {\\n      var s = new aiString();\\n      var stringlengthbytes = Read_unsigned_int(stream);\\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\\n      return s.toString();\\n    }\\n\\n    function Read_aiVertexWeight(stream) {\\n      var w = new aiVertexWeight();\\n      w.mVertexId = Read_unsigned_int(stream);\\n      w.mWeight = readFloat(stream);\\n      return w;\\n    }\\n\\n    function Read_aiMatrix4x4(stream) {\\n      var m = new aiMatrix4();\\n\\n      for (var i = 0; i < 4; ++i) {\\n        for (var i2 = 0; i2 < 4; ++i2) {\\n          m.elements[i][i2] = readFloat(stream);\\n        }\\n      }\\n\\n      return m;\\n    }\\n\\n    function Read_aiVectorKey(stream) {\\n      var v = new aiVectorKey();\\n      v.mTime = Read_double(stream);\\n      v.mValue = Read_aiVector3D(stream);\\n      return v;\\n    }\\n\\n    function Read_aiQuatKey(stream) {\\n      var v = new aiQuatKey();\\n      v.mTime = Read_double(stream);\\n      v.mValue = Read_aiQuaternion(stream);\\n      return v;\\n    }\\n\\n    function ReadArray_aiVertexWeight(stream, data, size) {\\n      for (var i = 0; i < size; i++) {\\n        data[i] = Read_aiVertexWeight(stream);\\n      }\\n    }\\n\\n    function ReadArray_aiVectorKey(stream, data, size) {\\n      for (var i = 0; i < size; i++) {\\n        data[i] = Read_aiVectorKey(stream);\\n      }\\n    }\\n\\n    function ReadArray_aiQuatKey(stream, data, size) {\\n      for (var i = 0; i < size; i++) {\\n        data[i] = Read_aiQuatKey(stream);\\n      }\\n    }\\n\\n    function ReadBounds(stream, T\\n    /*p*/\\n    , n) {\\n      // not sure what to do here, the data isn't really useful.\\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR); // eslint-disable-line no-undef\\n    }\\n\\n    function ai_assert(bool) {\\n      if (!bool) throw 'asset failed';\\n    }\\n\\n    function ReadBinaryNode(stream, parent, depth) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      var node = new aiNode();\\n      node.mParent = parent;\\n      node.mDepth = depth;\\n      node.mName = Read_aiString(stream);\\n      node.mTransformation = Read_aiMatrix4x4(stream);\\n      node.mNumChildren = Read_unsigned_int(stream);\\n      node.mNumMeshes = Read_unsigned_int(stream);\\n\\n      if (node.mNumMeshes) {\\n        node.mMeshes = [];\\n\\n        for (var i = 0; i < node.mNumMeshes; ++i) {\\n          node.mMeshes[i] = Read_unsigned_int(stream);\\n        }\\n      }\\n\\n      if (node.mNumChildren) {\\n        node.mChildren = [];\\n\\n        for (var _i7 = 0; _i7 < node.mNumChildren; ++_i7) {\\n          var node2 = ReadBinaryNode(stream, node, depth++);\\n          node.mChildren[_i7] = node2;\\n        }\\n      }\\n\\n      return node;\\n    } // -----------------------------------------------------------------------------------\\n\\n\\n    function ReadBinaryBone(stream, b) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      b.mName = Read_aiString(stream);\\n      b.mNumWeights = Read_unsigned_int(stream);\\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream); // for the moment we write dumb min/max values for the bones, too.\\n      // maybe I'll add a better, hash-like solution later\\n\\n      if (shortened) {\\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\\n      } else {\\n        // else write as usual\\n        b.mWeights = [];\\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\\n      }\\n\\n      return b;\\n    }\\n\\n    function ReadBinaryMesh(stream, mesh) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\\n      mesh.mNumVertices = Read_unsigned_int(stream);\\n      mesh.mNumFaces = Read_unsigned_int(stream);\\n      mesh.mNumBones = Read_unsigned_int(stream);\\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\\n      mesh.mNumUVComponents = []; // first of all, write bits for all existent vertex components\\n\\n      var c = Read_unsigned_int(stream);\\n\\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\\n        if (shortened) {\\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\\n        } else {\\n          // else write as usual\\n          mesh.mVertices = [];\\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\\n        }\\n      }\\n\\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\\n        if (shortened) {\\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\\n        } else {\\n          // else write as usual\\n          mesh.mNormals = [];\\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\\n        }\\n      }\\n\\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\\n        if (shortened) {\\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\\n        } else {\\n          // else write as usual\\n          mesh.mTangents = [];\\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\\n          mesh.mBitangents = [];\\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\\n        }\\n      }\\n\\n      for (var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\\n\\n        if (shortened) {\\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\\n        } else {\\n          // else write as usual\\n          mesh.mColors[n] = [];\\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\\n        }\\n      }\\n\\n      mesh.mTexCoordsBuffers = [];\\n\\n      for (var _n = 0; _n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++_n) {\\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(_n))) break; // write number of UV components\\n\\n        mesh.mNumUVComponents[_n] = Read_unsigned_int(stream);\\n\\n        if (shortened) {\\n          ReadBounds(stream, mesh.mTextureCoords[_n], mesh.mNumVertices);\\n        } else {\\n          // else write as usual\\n          mesh.mTextureCoords[_n] = []; //note that assbin always writes 3d texcoords\\n\\n          mesh.mTexCoordsBuffers[_n] = [];\\n\\n          for (var uv = 0; uv < mesh.mNumVertices; uv++) {\\n            mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\\n\\n            mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\\n\\n            readFloat(stream);\\n          }\\n        }\\n      } // write faces. There are no floating-point calculations involved\\n      // in these, so we can write a simple hash over the face data\\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\\n      // using Assimp's standard hashing function.\\n\\n\\n      if (shortened) {\\n        Read_unsigned_int(stream);\\n      } else {\\n        // else write as usual\\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\\n        mesh.mFaces = [];\\n        mesh.mIndexArray = [];\\n\\n        for (var i = 0; i < mesh.mNumFaces; ++i) {\\n          var f = mesh.mFaces[i] = new aiFace(); // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\\n\\n          f.mNumIndices = Read_uint16_t(stream);\\n          f.mIndices = [];\\n\\n          for (var a = 0; a < f.mNumIndices; ++a) {\\n            if (mesh.mNumVertices < 1 << 16) {\\n              f.mIndices[a] = Read_uint16_t(stream);\\n            } else {\\n              f.mIndices[a] = Read_unsigned_int(stream);\\n            }\\n          }\\n\\n          if (f.mNumIndices === 3) {\\n            mesh.mIndexArray.push(f.mIndices[0]);\\n            mesh.mIndexArray.push(f.mIndices[1]);\\n            mesh.mIndexArray.push(f.mIndices[2]);\\n          } else if (f.mNumIndices === 4) {\\n            mesh.mIndexArray.push(f.mIndices[0]);\\n            mesh.mIndexArray.push(f.mIndices[1]);\\n            mesh.mIndexArray.push(f.mIndices[2]);\\n            mesh.mIndexArray.push(f.mIndices[2]);\\n            mesh.mIndexArray.push(f.mIndices[3]);\\n            mesh.mIndexArray.push(f.mIndices[0]);\\n          } else {\\n            throw new Error(\\\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\\\");\\n          }\\n        }\\n      } // write bones\\n\\n\\n      if (mesh.mNumBones) {\\n        mesh.mBones = [];\\n\\n        for (var _a = 0; _a < mesh.mNumBones; ++_a) {\\n          mesh.mBones[_a] = new aiBone();\\n          ReadBinaryBone(stream, mesh.mBones[_a]);\\n        }\\n      }\\n    }\\n\\n    function ReadBinaryMaterialProperty(stream, prop) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      prop.mKey = Read_aiString(stream);\\n      prop.mSemantic = Read_unsigned_int(stream);\\n      prop.mIndex = Read_unsigned_int(stream);\\n      prop.mDataLength = Read_unsigned_int(stream);\\n      prop.mType = Read_unsigned_int(stream);\\n      prop.mData = [];\\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\\n    } // -----------------------------------------------------------------------------------\\n\\n\\n    function ReadBinaryMaterial(stream, mat) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\\n\\n      if (mat.mNumProperties) {\\n        if (mat.mProperties) {\\n          delete mat.mProperties;\\n        }\\n\\n        mat.mProperties = [];\\n\\n        for (var i = 0; i < mat.mNumProperties; ++i) {\\n          mat.mProperties[i] = new aiMaterialProperty();\\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\\n        }\\n      }\\n    }\\n\\n    function ReadBinaryNodeAnim(stream, nd) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      nd.mNodeName = Read_aiString(stream);\\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\\n      nd.mPreState = Read_unsigned_int(stream);\\n      nd.mPostState = Read_unsigned_int(stream);\\n\\n      if (nd.mNumPositionKeys) {\\n        if (shortened) {\\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\\n        } else {\\n          // else write as usual\\n          nd.mPositionKeys = [];\\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\\n        }\\n      }\\n\\n      if (nd.mNumRotationKeys) {\\n        if (shortened) {\\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\\n        } else {\\n          // else write as usual\\n          nd.mRotationKeys = [];\\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\\n        }\\n      }\\n\\n      if (nd.mNumScalingKeys) {\\n        if (shortened) {\\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\\n        } else {\\n          // else write as usual\\n          nd.mScalingKeys = [];\\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\\n        }\\n      }\\n    }\\n\\n    function ReadBinaryAnim(stream, anim) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      anim.mName = Read_aiString(stream);\\n      anim.mDuration = Read_double(stream);\\n      anim.mTicksPerSecond = Read_double(stream);\\n      anim.mNumChannels = Read_unsigned_int(stream);\\n\\n      if (anim.mNumChannels) {\\n        anim.mChannels = [];\\n\\n        for (var a = 0; a < anim.mNumChannels; ++a) {\\n          anim.mChannels[a] = new aiNodeAnim();\\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\\n        }\\n      }\\n    }\\n\\n    function ReadBinaryTexture(stream, tex) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      tex.mWidth = Read_unsigned_int(stream);\\n      tex.mHeight = Read_unsigned_int(stream);\\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\\n\\n      if (!shortened) {\\n        if (!tex.mHeight) {\\n          tex.pcData = [];\\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\\n        } else {\\n          tex.pcData = [];\\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\\n        }\\n      }\\n    }\\n\\n    function ReadBinaryLight(stream, l) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      l.mName = Read_aiString(stream);\\n      l.mType = Read_unsigned_int(stream);\\n\\n      if (l.mType != aiLightSource_DIRECTIONAL) {\\n        l.mAttenuationConstant = readFloat(stream);\\n        l.mAttenuationLinear = readFloat(stream);\\n        l.mAttenuationQuadratic = readFloat(stream);\\n      }\\n\\n      l.mColorDiffuse = Read_aiColor3D(stream);\\n      l.mColorSpecular = Read_aiColor3D(stream);\\n      l.mColorAmbient = Read_aiColor3D(stream);\\n\\n      if (l.mType == aiLightSource_SPOT) {\\n        l.mAngleInnerCone = readFloat(stream);\\n        l.mAngleOuterCone = readFloat(stream);\\n      }\\n    }\\n\\n    function ReadBinaryCamera(stream, cam) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      cam.mName = Read_aiString(stream);\\n      cam.mPosition = Read_aiVector3D(stream);\\n      cam.mLookAt = Read_aiVector3D(stream);\\n      cam.mUp = Read_aiVector3D(stream);\\n      cam.mHorizontalFOV = readFloat(stream);\\n      cam.mClipPlaneNear = readFloat(stream);\\n      cam.mClipPlaneFar = readFloat(stream);\\n      cam.mAspect = readFloat(stream);\\n    }\\n\\n    function ReadBinaryScene(stream, scene) {\\n      var chunkID = Read_uint32_t(stream);\\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\\n      /*uint32_t size =*/\\n\\n      Read_uint32_t(stream);\\n      scene.mFlags = Read_unsigned_int(stream);\\n      scene.mNumMeshes = Read_unsigned_int(stream);\\n      scene.mNumMaterials = Read_unsigned_int(stream);\\n      scene.mNumAnimations = Read_unsigned_int(stream);\\n      scene.mNumTextures = Read_unsigned_int(stream);\\n      scene.mNumLights = Read_unsigned_int(stream);\\n      scene.mNumCameras = Read_unsigned_int(stream); // Read node graph\\n\\n      scene.mRootNode = new aiNode();\\n      scene.mRootNode = ReadBinaryNode(stream, null, 0); // Read all meshes\\n\\n      if (scene.mNumMeshes) {\\n        scene.mMeshes = [];\\n\\n        for (var i = 0; i < scene.mNumMeshes; ++i) {\\n          scene.mMeshes[i] = new aiMesh();\\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\\n        }\\n      } // Read materials\\n\\n\\n      if (scene.mNumMaterials) {\\n        scene.mMaterials = [];\\n\\n        for (var _i8 = 0; _i8 < scene.mNumMaterials; ++_i8) {\\n          scene.mMaterials[_i8] = new aiMaterial();\\n          ReadBinaryMaterial(stream, scene.mMaterials[_i8]);\\n        }\\n      } // Read all animations\\n\\n\\n      if (scene.mNumAnimations) {\\n        scene.mAnimations = [];\\n\\n        for (var _i9 = 0; _i9 < scene.mNumAnimations; ++_i9) {\\n          scene.mAnimations[_i9] = new aiAnimation();\\n          ReadBinaryAnim(stream, scene.mAnimations[_i9]);\\n        }\\n      } // Read all textures\\n\\n\\n      if (scene.mNumTextures) {\\n        scene.mTextures = [];\\n\\n        for (var _i10 = 0; _i10 < scene.mNumTextures; ++_i10) {\\n          scene.mTextures[_i10] = new aiTexture();\\n          ReadBinaryTexture(stream, scene.mTextures[_i10]);\\n        }\\n      } // Read lights\\n\\n\\n      if (scene.mNumLights) {\\n        scene.mLights = [];\\n\\n        for (var _i11 = 0; _i11 < scene.mNumLights; ++_i11) {\\n          scene.mLights[_i11] = new aiLight();\\n          ReadBinaryLight(stream, scene.mLights[_i11]);\\n        }\\n      } // Read cameras\\n\\n\\n      if (scene.mNumCameras) {\\n        scene.mCameras = [];\\n\\n        for (var _i12 = 0; _i12 < scene.mNumCameras; ++_i12) {\\n          scene.mCameras[_i12] = new aiCamera();\\n          ReadBinaryCamera(stream, scene.mCameras[_i12]);\\n        }\\n      }\\n    }\\n\\n    var aiOrigin_CUR = 0;\\n    var aiOrigin_BEG = 1;\\n\\n    function extendStream(stream) {\\n      stream.readOffset = 0;\\n\\n      stream.Seek = function (off, ori) {\\n        if (ori == aiOrigin_CUR) {\\n          stream.readOffset += off;\\n        }\\n\\n        if (ori == aiOrigin_BEG) {\\n          stream.readOffset = off;\\n        }\\n      };\\n\\n      stream.ReadBytes = function (buff, size, n) {\\n        var bytes = size * n;\\n\\n        for (var i = 0; i < bytes; i++) {\\n          buff[i] = Read_uint8_t(this);\\n        }\\n      };\\n\\n      stream.subArray32 = function (start, end) {\\n        var buff = this.buffer;\\n        var newbuff = buff.slice(start, end);\\n        return new Float32Array(newbuff);\\n      };\\n\\n      stream.subArrayUint16 = function (start, end) {\\n        var buff = this.buffer;\\n        var newbuff = buff.slice(start, end);\\n        return new Uint16Array(newbuff);\\n      };\\n\\n      stream.subArrayUint8 = function (start, end) {\\n        var buff = this.buffer;\\n        var newbuff = buff.slice(start, end);\\n        return new Uint8Array(newbuff);\\n      };\\n\\n      stream.subArrayUint32 = function (start, end) {\\n        var buff = this.buffer;\\n        var newbuff = buff.slice(start, end);\\n        return new Uint32Array(newbuff);\\n      };\\n    }\\n\\n    var shortened, compressed;\\n\\n    function InternReadFile(pFiledata) {\\n      var pScene = new aiScene();\\n      var stream = new DataView(pFiledata);\\n      extendStream(stream);\\n      stream.Seek(44, aiOrigin_CUR); // signature\\n\\n      /*unsigned int versionMajor =*/\\n\\n      pScene.versionMajor = Read_unsigned_int(stream);\\n      /*unsigned int versionMinor =*/\\n\\n      pScene.versionMinor = Read_unsigned_int(stream);\\n      /*unsigned int versionRevision =*/\\n\\n      pScene.versionRevision = Read_unsigned_int(stream);\\n      /*unsigned int compileFlags =*/\\n\\n      pScene.compileFlags = Read_unsigned_int(stream);\\n      shortened = Read_uint16_t(stream) > 0;\\n      compressed = Read_uint16_t(stream) > 0;\\n      if (shortened) throw 'Shortened binaries are not supported!';\\n      stream.Seek(256, aiOrigin_CUR); // original filename\\n\\n      stream.Seek(128, aiOrigin_CUR); // options\\n\\n      stream.Seek(64, aiOrigin_CUR); // padding\\n\\n      if (compressed) {\\n        var uncompressedSize = Read_uint32_t(stream);\\n        var compressedSize = stream.FileSize() - stream.Tell();\\n        var compressedData = [];\\n        stream.Read(compressedData, 1, compressedSize);\\n        var uncompressedData = [];\\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize); // eslint-disable-line no-undef\\n\\n        var buff = new ArrayBuffer(uncompressedData);\\n        ReadBinaryScene(buff, pScene);\\n      } else {\\n        ReadBinaryScene(stream, pScene);\\n      }\\n\\n      return pScene.toTHREE();\\n    }\\n\\n    return InternReadFile(buffer);\\n  }\\n});\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"AssimpLoader\",\"_three\",\"manager\",\"Loader\",\"call\",\"prototype\",\"assign\",\"create\",\"constructor\",\"load\",\"url\",\"onLoad\",\"onProgress\",\"onError\",\"scope\",\"path\",\"LoaderUtils\",\"extractUrlBase\",\"loader\",\"FileLoader\",\"setPath\",\"setResponseType\",\"setRequestHeader\",\"requestHeader\",\"setWithCredentials\",\"withCredentials\",\"buffer\",\"parse\",\"e\",\"console\",\"error\",\"itemError\",\"cloneTreeToBones\",\"root\",\"scene\",\"rootBone\",\"Bone\",\"matrix\",\"copy\",\"matrixWorld\",\"position\",\"quaternion\",\"scale\",\"nodeCount\",\"name\",\"toString\",\"nodeToBoneMap\",\"push\",\"i\",\"children\",\"child\",\"add\",\"sortWeights\",\"indexes\",\"weights\",\"pairs\",\"length\",\"w\",\"sort\",\"a\",\"b\",\"_i\",\"sum\",\"Math\",\"sqrt\",\"_i2\",\"findMatchingBone\",\"indexOf\",\"ret\",\"aiMesh\",\"mMaterialIndex\",\"mNumBones\",\"mNumFaces\",\"mNumVertices\",\"mPrimitiveTypes\",\"mVertices\",\"mNormals\",\"mTangents\",\"mBitangents\",\"mColors\",\"mTextureCoords\",\"mFaces\",\"mBones\",\"hookupSkeletons\",\"this.hookupSkeletons\",\"allBones\",\"offsetMatrix\",\"skeletonRoot\",\"findNode\",\"mName\",\"mParent\",\"isBone\",\"threeSkeletonRoot\",\"toTHREE\",\"threeSkeletonRootBone\",\"threeNode\",\"bone\",\"tbone\",\"mOffsetMatrix\",\"skeleton\",\"Skeleton\",\"bind\",\"Matrix4\",\"material\",\"skinning\",\"this.toTHREE\",\"geometry\",\"BufferGeometry\",\"mat\",\"mMaterials\",\"MeshLambertMaterial\",\"setIndex\",\"BufferAttribute\",\"Uint32Array\",\"mIndexArray\",\"setAttribute\",\"mVertexBuffer\",\"mNormalBuffer\",\"mColorBuffer\",\"mTexCoordsBuffers\",\"Float32Array\",\"mTangentBuffer\",\"mBitangentBuffer\",\"bones\",\"j\",\"mWeights\",\"weight\",\"mVertexId\",\"mWeight\",\"parseInt\",\"_i3\",\"_weights\",\"_bones\",\"_i4\",\"_j\",\"BONESPERVERT\",\"mesh\",\"Mesh\",\"SkinnedMesh\",\"normalizeSkinWeights\",\"aiFace\",\"mNumIndices\",\"mIndices\",\"aiVector3D\",\"z\",\"y\",\"x\",\"Vector3\",\"aiColor3D\",\"g\",\"r\",\"Color\",\"aiQuaternion\",\"Quaternion\",\"aiVertexWeight\",\"aiString\",\"data\",\"this.toString\",\"str\",\"forEach\",\"String\",\"fromCharCode\",\"replace\",\"aiVectorKey\",\"mTime\",\"mValue\",\"aiQuatKey\",\"aiNode\",\"mTransformation\",\"mNumMeshes\",\"mNumChildren\",\"mMeshes\",\"mChildren\",\"o\",\"Object3D\",\"_i5\",\"decompose\",\"aiBone\",\"mNumWeights\",\"aiMaterialProperty\",\"mKey\",\"mIndex\",\"mSemantic\",\"mData\",\"mType\",\"mDataLength\",\"dataAsColor\",\"this.dataAsColor\",\"array\",\"Uint8Array\",\"reader\",\"DataView\",\"getFloat32\",\"dataAsFloat\",\"this.dataAsFloat\",\"dataAsBool\",\"this.dataAsBool\",\"dataAsString\",\"this.dataAsString\",\"s\",\"dataAsMap\",\"this.dataAsMap\",\"substr\",\"lastIndexOf\",\"textureLoader\",\"aiMaterial\",\"mNumProperties\",\"mNumAllocated\",\"mProperties\",\"MeshPhongMaterial\",\"nameTypeMapping\",\"namePropMapping\",\"prop\",\"aiTextureType_DIFFUSE\",\"map\",\"aiTextureType_NORMALS\",\"normalMap\",\"aiTextureType_LIGHTMAP\",\"lightMap\",\"aiTextureType_OPACITY\",\"alphaMap\",\"ambient\",\"color\",\"veclerp\",\"v1\",\"v2\",\"l\",\"v\",\"lm1\",\"quatlerp\",\"q1\",\"q2\",\"clone\",\"slerp\",\"sampleTrack\",\"keys\",\"time\",\"lne\",\"lerp\",\"dist\",\"Infinity\",\"key\",\"nextKey\",\"timeDist\",\"abs\",\"dT\",\"T\",\"aiNodeAnim\",\"mNodeName\",\"mNumScalingKeys\",\"mNumRotationKeys\",\"mNumPositionKeys\",\"mPositionKeys\",\"mRotationKeys\",\"mScalingKeys\",\"mPostState\",\"mPreState\",\"init\",\"this.init\",\"tps\",\"t\",\"sortKeys\",\"this.sortKeys\",\"comp\",\"getLength\",\"this.getLength\",\"max\",\"apply\",\"track\",\"Virtulous\",\"KeyFrameTrack\",\"pos\",\"rotation\",\"compose\",\"KeyFrame\",\"addKey\",\"target\",\"tracks\",\"_i6\",\"t2\",\"aiAnimation\",\"mNumChannels\",\"mTicksPerSecond\",\"mDuration\",\"mChannels\",\"animationHandle\",\"Animation\",\"addTrack\",\"aiTexture\",\"mHeight\",\"mWidth\",\"texAchFormatHint\",\"pcData\",\"aiLight\",\"mAngleOuterCone\",\"mAngleInnerCone\",\"mAttenuationQuadratic\",\"mAttenuationLinear\",\"mAttenuationConstant\",\"mColorAmbient\",\"mColorSpecular\",\"mColorDiffuse\",\"aiCamera\",\"mUp\",\"mLookAt\",\"mPosition\",\"mAspect\",\"mClipPlaneFar\",\"mClipPlaneNear\",\"mHorizontalFOV\",\"aiScene\",\"mNumCameras\",\"mNumLights\",\"mNumTextures\",\"mNumAnimations\",\"mNumMaterials\",\"mFlags\",\"compileFlags\",\"versionRevision\",\"versionMinor\",\"versionMajor\",\"mRootNode\",\"mAnimations\",\"mLights\",\"mCameras\",\"this.findNode\",\"k\",\"boneNode\",\"object\",\"animation\",\"aiMatrix4\",\"elements\",\"m\",\"i2\",\"readFloat\",\"dataview\",\"val\",\"readOffset\",\"littleEndian\",\"Read_double\",\"getFloat64\",\"Read_uint16_t\",\"getUint16\",\"Read_unsigned_int\",\"getUint32\",\"Read_uint32_t\",\"Read_aiVector3D\",\"stream\",\"Read_aiColor3D\",\"c\",\"Read_aiString\",\"stringlengthbytes\",\"ReadBytes\",\"Read_aiMatrix4x4\",\"Read_aiVectorKey\",\"ReadBounds\",\"n\",\"Seek\",\"sizeof\",\"aiOrigin_CUR\",\"ai_assert\",\"bool\",\"ReadBinaryNode\",\"parent\",\"depth\",\"chunkID\",\"ASSBIN_CHUNK_AINODE\",\"node\",\"mDepth\",\"_i7\",\"node2\",\"ReadBinaryScene\",\"ASSBIN_CHUNK_AISCENE\",\"ASSBIN_CHUNK_AIMESH\",\"mNumUVComponents\",\"ASSBIN_MESH_HAS_POSITIONS\",\"shortened\",\"subArray32\",\"ASSBIN_MESH_HAS_NORMALS\",\"ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS\",\"AI_MAX_NUMBER_OF_COLOR_SETS\",\"ASSBIN_MESH_HAS_COLOR_BASE\",\"_n\",\"AI_MAX_NUMBER_OF_TEXTURECOORDS\",\"ASSBIN_MESH_HAS_TEXCOORD_BASE\",\"uv\",\"f\",\"Error\",\"_a\",\"ASSBIN_CHUNK_AIBONE\",\"size\",\"_i8\",\"ASSBIN_CHUNK_AIMATERIAL\",\"ASSBIN_CHUNK_AIMATERIALPROPERTY\",\"_i9\",\"ASSBIN_CHUNK_AIANIMATION\",\"anim\",\"ASSBIN_CHUNK_AINODEANIM\",\"nd\",\"mTextures\",\"_i10\",\"ASSBIN_CHUNK_AITEXTURE\",\"tex\",\"achFormatHint\",\"_i11\",\"ASSBIN_CHUNK_AILIGHT\",\"aiLightSource_DIRECTIONAL\",\"aiLightSource_SPOT\",\"_i12\",\"ASSBIN_CHUNK_AICAMERA\",\"cam\",\"extendStream\",\"stream.Seek\",\"off\",\"ori\",\"aiOrigin_BEG\",\"stream.ReadBytes\",\"buff\",\"bytes\",\"getUint8\",\"stream.subArray32\",\"start\",\"end\",\"newbuff\",\"slice\",\"subArrayUint16\",\"stream.subArrayUint16\",\"Uint16Array\",\"subArrayUint8\",\"stream.subArrayUint8\",\"subArrayUint32\",\"stream.subArrayUint32\",\"TextureLoader\",\"resourcePath\",\"setCrossOrigin\",\"crossOrigin\",\"Virtulous.KeyFrame\",\"this.clone\",\"this.lerp\",\"l2\",\"keypos\",\"keyrot\",\"key2pos\",\"key2rot\",\"tempAniPos\",\"tempAniQuat\",\"set\",\"tempAniMatrix\",\"tempAniScale\",\"Virtulous.KeyFrameTrack\",\"_accelTable\",\"fps\",\"this.addKey\",\"parseFromThree\",\"this.parseFromThree\",\"hierarchy\",\"targets\",\"parseFromCollada\",\"this.parseFromCollada\",\"keySortFunc\",\"this.keySortFunc\",\"reTarget\",\"this.reTarget\",\"compareitor\",\"TrackTargetNodeNameCompare\",\"keySearchAccel\",\"this.keySearchAccel\",\"floor\",\"setTime\",\"this.setTime\",\"key0\",\"key1\",\"matrixAutoUpdate\",\"matrixWorldNeedsUpdate\",\"Virtulous.TrackTargetNodeNameCompare\",\"find\",\"Virtulous.Animation\",\"this.addTrack\",\"compressed\",\"InternReadFile\",\"pFiledata\",\"pScene\",\"uncompressedSize\",\"compressedSize\",\"FileSize\",\"Tell\",\"compressedData\",\"Read\",\"uncompressedData\",\"uncompress\",\"ArrayBuffer\"]\n}\n"]