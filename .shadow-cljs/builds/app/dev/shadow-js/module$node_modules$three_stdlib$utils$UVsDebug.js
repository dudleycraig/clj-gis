["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/utils/UVsDebug.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$utils$UVsDebug=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.UVsDebug=void 0;var _three=require(\"module$node_modules$three$build$three_module\");exports.UVsDebug=function(geometry,size){function processFace(face,uvs,index){ctx.beginPath();a.set(0,0);for(var _j=0,_jl=uvs.length;_j<_jl;_j++){var uv=uvs[_j];a.x+=uv.x;a.y+=uv.y;0===_j?ctx.moveTo(uv.x*(width-2)+.5,(1-uv.y)*(height-2)+.5):ctx.lineTo(uv.x*\n(width-2)+.5,(1-uv.y)*(height-2)+.5)}ctx.closePath();ctx.stroke();a.divideScalar(uvs.length);ctx.font=\"18px Arial\";ctx.fillStyle=\"rgb( 63, 63, 63 )\";ctx.fillText(index,a.x*width,(1-a.y)*height);.95<a.x&&ctx.fillText(index,a.x%1*width,(1-a.y)*height);ctx.font=\"12px Arial\";ctx.fillStyle=\"rgb( 191, 191, 191 )\";j=0;for(jl=uvs.length;j<jl;j++)uv=uvs[j],b.addVectors(a,uv).divideScalar(2),index=face[j],ctx.fillText(\"abc\"[j]+index,b.x*width,(1-b.y)*height),.95<b.x&&ctx.fillText(\"abc\"[j]+index,b.x%1*width,\n(1-b.y)*height)}var a=new _three.Vector2,b=new _three.Vector2,uvs$jscomp$0=[new _three.Vector2,new _three.Vector2,new _three.Vector2],face$jscomp$0=[],canvas=document.createElement(\"canvas\"),width=size||1024,height=size||1024;canvas.width=width;canvas.height=height;var ctx=canvas.getContext(\"2d\");ctx.lineWidth=1;ctx.strokeStyle=\"rgb( 63, 63, 63 )\";ctx.textAlign=\"center\";ctx.fillStyle=\"rgb( 255, 255, 255 )\";ctx.fillRect(0,0,width,height);if(geometry.isGeometry)console.error(\"THREE.UVsDebug no longer supports Geometry. Use THREE.BufferGeometry instead.\");\nelse{size=geometry.index;geometry=geometry.attributes.uv;if(size)for(var i=0,il=size.count;i<il;i+=3)face$jscomp$0[0]=size.getX(i),face$jscomp$0[1]=size.getX(i+1),face$jscomp$0[2]=size.getX(i+2),uvs$jscomp$0[0].fromBufferAttribute(geometry,face$jscomp$0[0]),uvs$jscomp$0[1].fromBufferAttribute(geometry,face$jscomp$0[1]),uvs$jscomp$0[2].fromBufferAttribute(geometry,face$jscomp$0[2]),processFace(face$jscomp$0,uvs$jscomp$0,i/3);else for(size=0,i=geometry.count;size<i;size+=3)face$jscomp$0[0]=size,face$jscomp$0[1]=\nsize+1,face$jscomp$0[2]=size+2,uvs$jscomp$0[0].fromBufferAttribute(geometry,face$jscomp$0[0]),uvs$jscomp$0[1].fromBufferAttribute(geometry,face$jscomp$0[1]),uvs$jscomp$0[2].fromBufferAttribute(geometry,face$jscomp$0[2]),processFace(face$jscomp$0,uvs$jscomp$0,size/3);return canvas}}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$utils$UVsDebug\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UVsDebug = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * tool for \"unwrapping\" and debugging three.js geometries UV mapping\n *\n * Sample usage:\n *\tdocument.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\n *\n */\nvar UVsDebug = function UVsDebug(geometry, size) {\n  // handles wrapping of uv.x > 1 only\n  var abc = 'abc';\n  var a = new _three.Vector2();\n  var b = new _three.Vector2();\n  var uvs = [new _three.Vector2(), new _three.Vector2(), new _three.Vector2()];\n  var face = [];\n  var canvas = document.createElement('canvas');\n  var width = size || 1024; // power of 2 required for wrapping\n\n  var height = size || 1024;\n  canvas.width = width;\n  canvas.height = height;\n  var ctx = canvas.getContext('2d');\n  ctx.lineWidth = 1;\n  ctx.strokeStyle = 'rgb( 63, 63, 63 )';\n  ctx.textAlign = 'center'; // paint background white\n\n  ctx.fillStyle = 'rgb( 255, 255, 255 )';\n  ctx.fillRect(0, 0, width, height);\n\n  if (geometry.isGeometry) {\n    console.error('THREE.UVsDebug no longer supports Geometry. Use THREE.BufferGeometry instead.');\n    return;\n  } else {\n    var index = geometry.index;\n    var uvAttribute = geometry.attributes.uv;\n\n    if (index) {\n      // indexed geometry\n      for (var i = 0, il = index.count; i < il; i += 3) {\n        face[0] = index.getX(i);\n        face[1] = index.getX(i + 1);\n        face[2] = index.getX(i + 2);\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, i / 3);\n      }\n    } else {\n      // non-indexed geometry\n      for (var _i = 0, _il = uvAttribute.count; _i < _il; _i += 3) {\n        face[0] = _i;\n        face[1] = _i + 1;\n        face[2] = _i + 2;\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, _i / 3);\n      }\n    }\n  }\n\n  return canvas;\n\n  function processFace(face, uvs, index) {\n    // draw contour of face\n    ctx.beginPath();\n    a.set(0, 0);\n\n    for (var _j = 0, _jl = uvs.length; _j < _jl; _j++) {\n      var uv = uvs[_j];\n      a.x += uv.x;\n      a.y += uv.y;\n\n      if (_j === 0) {\n        ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      } else {\n        ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      }\n    }\n\n    ctx.closePath();\n    ctx.stroke(); // calculate center of face\n\n    a.divideScalar(uvs.length); // label the face number\n\n    ctx.font = '18px Arial';\n    ctx.fillStyle = 'rgb( 63, 63, 63 )';\n    ctx.fillText(index, a.x * width, (1 - a.y) * height);\n\n    if (a.x > 0.95) {\n      // wrap x // 0.95 is arbitrary\n      ctx.fillText(index, a.x % 1 * width, (1 - a.y) * height);\n    } //\n\n\n    ctx.font = '12px Arial';\n    ctx.fillStyle = 'rgb( 191, 191, 191 )'; // label uv edge orders\n\n    for (j = 0, jl = uvs.length; j < jl; j++) {\n      var uv = uvs[j];\n      b.addVectors(a, uv).divideScalar(2);\n      var vnum = face[j];\n      ctx.fillText(abc[j] + vnum, b.x * width, (1 - b.y) * height);\n\n      if (b.x > 0.95) {\n        // wrap x\n        ctx.fillText(abc[j] + vnum, b.x % 1 * width, (1 - b.y) * height);\n      }\n    }\n  }\n};\n\nexports.UVsDebug = UVsDebug;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["width","lineWidth","height","x","__esModule","UVsDebug","value","font","y","strokeStyle","textAlign","fillStyle"]],"~:compiled-at",1630917515396,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$utils$UVsDebug.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/utils/UVsDebug.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$utils$UVsDebug\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.UVsDebug = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * tool for \\\"unwrapping\\\" and debugging three.js geometries UV mapping\\n *\\n * Sample usage:\\n *\\tdocument.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\\n *\\n */\\nvar UVsDebug = function UVsDebug(geometry, size) {\\n  // handles wrapping of uv.x > 1 only\\n  var abc = 'abc';\\n  var a = new _three.Vector2();\\n  var b = new _three.Vector2();\\n  var uvs = [new _three.Vector2(), new _three.Vector2(), new _three.Vector2()];\\n  var face = [];\\n  var canvas = document.createElement('canvas');\\n  var width = size || 1024; // power of 2 required for wrapping\\n\\n  var height = size || 1024;\\n  canvas.width = width;\\n  canvas.height = height;\\n  var ctx = canvas.getContext('2d');\\n  ctx.lineWidth = 1;\\n  ctx.strokeStyle = 'rgb( 63, 63, 63 )';\\n  ctx.textAlign = 'center'; // paint background white\\n\\n  ctx.fillStyle = 'rgb( 255, 255, 255 )';\\n  ctx.fillRect(0, 0, width, height);\\n\\n  if (geometry.isGeometry) {\\n    console.error('THREE.UVsDebug no longer supports Geometry. Use THREE.BufferGeometry instead.');\\n    return;\\n  } else {\\n    var index = geometry.index;\\n    var uvAttribute = geometry.attributes.uv;\\n\\n    if (index) {\\n      // indexed geometry\\n      for (var i = 0, il = index.count; i < il; i += 3) {\\n        face[0] = index.getX(i);\\n        face[1] = index.getX(i + 1);\\n        face[2] = index.getX(i + 2);\\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\\n        processFace(face, uvs, i / 3);\\n      }\\n    } else {\\n      // non-indexed geometry\\n      for (var _i = 0, _il = uvAttribute.count; _i < _il; _i += 3) {\\n        face[0] = _i;\\n        face[1] = _i + 1;\\n        face[2] = _i + 2;\\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\\n        processFace(face, uvs, _i / 3);\\n      }\\n    }\\n  }\\n\\n  return canvas;\\n\\n  function processFace(face, uvs, index) {\\n    // draw contour of face\\n    ctx.beginPath();\\n    a.set(0, 0);\\n\\n    for (var _j = 0, _jl = uvs.length; _j < _jl; _j++) {\\n      var uv = uvs[_j];\\n      a.x += uv.x;\\n      a.y += uv.y;\\n\\n      if (_j === 0) {\\n        ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\\n      } else {\\n        ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\\n      }\\n    }\\n\\n    ctx.closePath();\\n    ctx.stroke(); // calculate center of face\\n\\n    a.divideScalar(uvs.length); // label the face number\\n\\n    ctx.font = '18px Arial';\\n    ctx.fillStyle = 'rgb( 63, 63, 63 )';\\n    ctx.fillText(index, a.x * width, (1 - a.y) * height);\\n\\n    if (a.x > 0.95) {\\n      // wrap x // 0.95 is arbitrary\\n      ctx.fillText(index, a.x % 1 * width, (1 - a.y) * height);\\n    } //\\n\\n\\n    ctx.font = '12px Arial';\\n    ctx.fillStyle = 'rgb( 191, 191, 191 )'; // label uv edge orders\\n\\n    for (j = 0, jl = uvs.length; j < jl; j++) {\\n      var uv = uvs[j];\\n      b.addVectors(a, uv).divideScalar(2);\\n      var vnum = face[j];\\n      ctx.fillText(abc[j] + vnum, b.x * width, (1 - b.y) * height);\\n\\n      if (b.x > 0.95) {\\n        // wrap x\\n        ctx.fillText(abc[j] + vnum, b.x % 1 * width, (1 - b.y) * height);\\n      }\\n    }\\n  }\\n};\\n\\nexports.UVsDebug = UVsDebug;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"UVsDebug\",\"_three\",\"geometry\",\"size\",\"processFace\",\"face\",\"uvs\",\"index\",\"ctx\",\"beginPath\",\"a\",\"set\",\"_j\",\"_jl\",\"length\",\"uv\",\"x\",\"y\",\"moveTo\",\"width\",\"height\",\"lineTo\",\"closePath\",\"stroke\",\"divideScalar\",\"font\",\"fillStyle\",\"fillText\",\"j\",\"jl\",\"b\",\"addVectors\",\"vnum\",\"abc\",\"Vector2\",\"canvas\",\"document\",\"createElement\",\"getContext\",\"lineWidth\",\"strokeStyle\",\"textAlign\",\"fillRect\",\"isGeometry\",\"console\",\"error\",\"uvAttribute\",\"attributes\",\"i\",\"il\",\"count\",\"getX\",\"fromBufferAttribute\",\"_i\",\"_il\"]\n}\n"]