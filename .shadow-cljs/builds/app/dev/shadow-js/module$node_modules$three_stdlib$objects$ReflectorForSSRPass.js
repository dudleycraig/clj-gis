["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/objects/ReflectorForSSRPass.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$objects$ReflectorForSSRPass=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _possibleConstructorReturn(self,call){return!call||\"object\"!==_typeof(call)&&\"function\"!==\ntypeof call?_assertThisInitialized(self):call}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");\nsubClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ReflectorForSSRPass=void 0;var _three=require(\"module$node_modules$three$build$three_module\");\nglobal=function(_Mesh){function ReflectorForSSRPass(geometry){var options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!(this instanceof ReflectorForSSRPass))throw new TypeError(\"Cannot call a class as a function\");var _this=_possibleConstructorReturn(this,_getPrototypeOf(ReflectorForSSRPass).call(this,geometry));_this.type=\"ReflectorForSSRPass\";var scope=_assertThisInitialized(_this),color=void 0!==options.color?new _three.Color(options.color):new _three.Color(8355711),textureWidth=\noptions.textureWidth||512,textureHeight=options.textureHeight||512,clipBias=options.clipBias||0,shader=options.shader||ReflectorForSSRPass.ReflectorShader,useDepthTexture=!0===options.useDepthTexture,yAxis=new _three.Vector3(0,1,0),vecTemp0=new _three.Vector3,vecTemp1=new _three.Vector3;scope.needsUpdate=!1;scope.maxDistance=ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;scope.opacity=ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;scope.color=color;scope.resolution=options.resolution||\nnew _three.Vector2(window.innerWidth,window.innerHeight);scope._distanceAttenuation=ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;Object.defineProperty(scope,\"distanceAttenuation\",{get:function(){return scope._distanceAttenuation},set:function(val){scope._distanceAttenuation!==val&&(scope._distanceAttenuation=val,scope.material.defines.DISTANCE_ATTENUATION=val,scope.material.needsUpdate=!0)}});scope._fresnel=ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;Object.defineProperty(scope,\n\"fresnel\",{get:function(){return scope._fresnel},set:function(val){scope._fresnel!==val&&(scope._fresnel=val,scope.material.defines.FRESNEL=val,scope.material.needsUpdate=!0)}});var normal=new _three.Vector3,reflectorWorldPosition=new _three.Vector3,cameraWorldPosition=new _three.Vector3,rotationMatrix=new _three.Matrix4,lookAtPosition=new _three.Vector3(0,0,-1),view=new _three.Vector3,target=new _three.Vector3,textureMatrix=new _three.Matrix4,virtualCamera=new _three.PerspectiveCamera;if(useDepthTexture){var depthTexture=\nnew _three.DepthTexture;depthTexture.type=_three.UnsignedShortType;depthTexture.minFilter=_three.NearestFilter;depthTexture.magFilter=_three.NearestFilter}var renderTarget=new _three.WebGLRenderTarget(textureWidth,textureHeight,{minFilter:_three.LinearFilter,magFilter:_three.LinearFilter,format:_three.RGBFormat,depthTexture:useDepthTexture?depthTexture:null});_three.MathUtils.isPowerOfTwo(textureWidth)&&_three.MathUtils.isPowerOfTwo(textureHeight)||(renderTarget.texture.generateMipmaps=!1);var material=\nnew _three.ShaderMaterial({transparent:useDepthTexture,defines:Object.assign({},ReflectorForSSRPass.ReflectorShader.defines,{useDepthTexture}),uniforms:_three.UniformsUtils.clone(shader.uniforms),fragmentShader:shader.fragmentShader,vertexShader:shader.vertexShader});material.uniforms.tDiffuse.value=renderTarget.texture;material.uniforms.color.value=scope.color;material.uniforms.textureMatrix.value=textureMatrix;useDepthTexture&&(material.uniforms.tDepth.value=renderTarget.depthTexture);_this.material=\nmaterial;var globalPlanes=[new _three.Plane(new _three.Vector3(0,1,0),clipBias)];_this.doRender=function(renderer,scene,camera){material.uniforms.maxDistance.value=scope.maxDistance;material.uniforms.color.value=scope.color;material.uniforms.opacity.value=scope.opacity;vecTemp0.copy(camera.position).normalize();vecTemp1.copy(vecTemp0).reflect(yAxis);material.uniforms.fresnelCoe.value=(vecTemp0.dot(vecTemp1)+1)/2;reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\nrotationMatrix.extractRotation(scope.matrixWorld);normal.set(0,0,1);normal.applyMatrix4(rotationMatrix);view.subVectors(reflectorWorldPosition,cameraWorldPosition);if(!(0<view.dot(normal))){view.reflect(normal).negate();view.add(reflectorWorldPosition);rotationMatrix.extractRotation(camera.matrixWorld);lookAtPosition.set(0,0,-1);lookAtPosition.applyMatrix4(rotationMatrix);lookAtPosition.add(cameraWorldPosition);target.subVectors(reflectorWorldPosition,lookAtPosition);target.reflect(normal).negate();\ntarget.add(reflectorWorldPosition);virtualCamera.position.copy(view);virtualCamera.up.set(0,1,0);virtualCamera.up.applyMatrix4(rotationMatrix);virtualCamera.up.reflect(normal);virtualCamera.lookAt(target);virtualCamera.far=camera.far;virtualCamera.updateMatrixWorld();virtualCamera.projectionMatrix.copy(camera.projectionMatrix);material.uniforms.virtualCameraNear.value=camera.near;material.uniforms.virtualCameraFar.value=camera.far;material.uniforms.virtualCameraMatrixWorld.value=virtualCamera.matrixWorld;\nmaterial.uniforms.virtualCameraProjectionMatrix.value=camera.projectionMatrix;material.uniforms.virtualCameraProjectionMatrixInverse.value=camera.projectionMatrixInverse;material.uniforms.resolution.value=scope.resolution;textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);textureMatrix.multiply(virtualCamera.projectionMatrix);textureMatrix.multiply(virtualCamera.matrixWorldInverse);textureMatrix.multiply(scope.matrixWorld);renderTarget.texture.encoding=renderer.outputEncoding;var currentRenderTarget=\nrenderer.getRenderTarget(),currentXrEnabled=renderer.xr.enabled,currentShadowAutoUpdate=renderer.shadowMap.autoUpdate,currentClippingPlanes=renderer.clippingPlanes;renderer.xr.enabled=!1;renderer.shadowMap.autoUpdate=!1;renderer.clippingPlanes=globalPlanes;renderer.setRenderTarget(renderTarget);renderer.state.buffers.depth.setMask(!0);!1===renderer.autoClear&&renderer.clear();renderer.render(scene,virtualCamera);renderer.xr.enabled=currentXrEnabled;renderer.shadowMap.autoUpdate=currentShadowAutoUpdate;\nrenderer.clippingPlanes=currentClippingPlanes;renderer.setRenderTarget(currentRenderTarget);scene=camera.viewport;void 0!==scene&&renderer.state.viewport(scene)}};_this.getRenderTarget=function(){return renderTarget};return _this}_inherits(ReflectorForSSRPass,_Mesh);return ReflectorForSSRPass}(_three.Mesh);exports.ReflectorForSSRPass=global;global.prototype.isReflectorForSSRPass=!0;global.ReflectorShader={defines:{DISTANCE_ATTENUATION:!0,FRESNEL:!0},uniforms:{color:{value:null},tDiffuse:{value:null},\ntDepth:{value:null},textureMatrix:{value:new _three.Matrix4},maxDistance:{value:180},opacity:{value:.5},fresnelCoe:{value:null},virtualCameraNear:{value:null},virtualCameraFar:{value:null},virtualCameraProjectionMatrix:{value:new _three.Matrix4},virtualCameraMatrixWorld:{value:new _three.Matrix4},virtualCameraProjectionMatrixInverse:{value:new _three.Matrix4},resolution:{value:new _three.Vector2}},vertexShader:\"\\n\\t\\tuniform mat4 textureMatrix;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv \\x3d textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\nfragmentShader:\"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tuniform sampler2D tDepth;\\n\\t\\tuniform float maxDistance;\\n\\t\\tuniform float opacity;\\n\\t\\tuniform float fresnelCoe;\\n\\t\\tuniform float virtualCameraNear;\\n\\t\\tuniform float virtualCameraFar;\\n\\t\\tuniform mat4 virtualCameraProjectionMatrix;\\n\\t\\tuniform mat4 virtualCameraProjectionMatrixInverse;\\n\\t\\tuniform mat4 virtualCameraMatrixWorld;\\n\\t\\tuniform vec2 resolution;\\n\\t\\tvarying vec4 vUv;\\n\\t\\t#include \\x3cpacking\\x3e\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\t\\t\\treturn( base \\x3c 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\t\\t}\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\t\\t}\\n\\t\\tfloat getDepth( const in vec2 uv ) {\\n\\t\\t\\treturn texture2D( tDepth, uv ).x;\\n\\t\\t}\\n\\t\\tfloat getViewZ( const in float depth ) {\\n\\t\\t\\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\\n\\t\\t}\\n\\t\\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\\n\\t\\t\\tvec4 clipPosition \\x3d vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\\n\\t\\t\\tclipPosition *\\x3d clipW; //clip\\n\\t\\t\\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\\n\\t\\t}\\n\\t\\tvoid main() {\\n\\t\\t\\tvec4 base \\x3d texture2DProj( tDiffuse, vUv );\\n\\t\\t\\t#ifdef useDepthTexture\\n\\t\\t\\t\\tvec2 uv\\x3d(gl_FragCoord.xy-.5)/resolution.xy;\\n\\t\\t\\t\\tuv.x\\x3d1.-uv.x;\\n\\t\\t\\t\\tfloat depth \\x3d texture2DProj( tDepth, vUv ).r;\\n\\t\\t\\t\\tfloat viewZ \\x3d getViewZ( depth );\\n\\t\\t\\t\\tfloat clipW \\x3d virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\\n\\t\\t\\t\\tvec3 viewPosition\\x3dgetViewPosition( uv, depth, clipW );\\n\\t\\t\\t\\tvec3 worldPosition\\x3d(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\\n\\t\\t\\t\\tif(worldPosition.y\\x3emaxDistance) discard;\\n\\t\\t\\t\\tfloat op\\x3dopacity;\\n\\t\\t\\t\\t#ifdef DISTANCE_ATTENUATION\\n\\t\\t\\t\\t\\tfloat ratio\\x3d1.-(worldPosition.y/maxDistance);\\n\\t\\t\\t\\t\\tfloat attenuation\\x3dratio*ratio;\\n\\t\\t\\t\\t\\top\\x3dopacity*attenuation;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#ifdef FRESNEL\\n\\t\\t\\t\\t\\top*\\x3dfresnelCoe;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tgl_FragColor \\x3d vec4( blendOverlay( base.rgb, color ), op );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tgl_FragColor \\x3d vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$objects$ReflectorForSSRPass\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReflectorForSSRPass = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar ReflectorForSSRPass =\n/*#__PURE__*/\nfunction (_Mesh) {\n  _inherits(ReflectorForSSRPass, _Mesh);\n\n  function ReflectorForSSRPass(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ReflectorForSSRPass);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReflectorForSSRPass).call(this, geometry));\n    _this.type = 'ReflectorForSSRPass';\n\n    var scope = _assertThisInitialized(_this);\n\n    var color = options.color !== undefined ? new _three.Color(options.color) : new _three.Color(0x7f7f7f);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || ReflectorForSSRPass.ReflectorShader;\n    var useDepthTexture = options.useDepthTexture === true;\n    var yAxis = new _three.Vector3(0, 1, 0);\n    var vecTemp0 = new _three.Vector3();\n    var vecTemp1 = new _three.Vector3(); //\n\n    scope.needsUpdate = false;\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new _three.Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get: function get() {\n        return scope._distanceAttenuation;\n      },\n      set: function set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, 'fresnel', {\n      get: function get() {\n        return scope._fresnel;\n      },\n      set: function set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    var normal = new _three.Vector3();\n    var reflectorWorldPosition = new _three.Vector3();\n    var cameraWorldPosition = new _three.Vector3();\n    var rotationMatrix = new _three.Matrix4();\n    var lookAtPosition = new _three.Vector3(0, 0, -1);\n    var view = new _three.Vector3();\n    var target = new _three.Vector3();\n    var textureMatrix = new _three.Matrix4();\n    var virtualCamera = new _three.PerspectiveCamera();\n    var depthTexture;\n\n    if (useDepthTexture) {\n      depthTexture = new _three.DepthTexture();\n      depthTexture.type = _three.UnsignedShortType;\n      depthTexture.minFilter = _three.NearestFilter;\n      depthTexture.magFilter = _three.NearestFilter;\n    }\n\n    var parameters = {\n      minFilter: _three.LinearFilter,\n      magFilter: _three.LinearFilter,\n      format: _three.RGBFormat,\n      depthTexture: useDepthTexture ? depthTexture : null\n    };\n    var renderTarget = new _three.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n    if (!_three.MathUtils.isPowerOfTwo(textureWidth) || !_three.MathUtils.isPowerOfTwo(textureHeight)) {\n      renderTarget.texture.generateMipmaps = false;\n    }\n\n    var material = new _three.ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture: useDepthTexture\n      }),\n      uniforms: _three.UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = scope.color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\n    }\n\n    _this.material = material;\n    var globalPlane = new _three.Plane(new _three.Vector3(0, 1, 0), clipBias);\n    var globalPlanes = [globalPlane];\n\n    _this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance;\n      material.uniforms['color'].value = scope.color;\n      material.uniforms['opacity'].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms['virtualCameraNear'].value = camera.near;\n      material.uniforms['virtualCameraFar'].value = camera.far;\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\n      material.uniforms['resolution'].value = scope.resolution; // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\n\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      var currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      var viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      } // scope.visible = true;\n\n    };\n\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    return _this;\n  }\n\n  return ReflectorForSSRPass;\n}(_three.Mesh);\n\nexports.ReflectorForSSRPass = ReflectorForSSRPass;\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\nReflectorForSSRPass.ReflectorShader = {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new _three.Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new _three.Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new _three.Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new _three.Matrix4()\n    },\n    resolution: {\n      value: new _three.Vector2()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\t\\tuniform mat4 textureMatrix;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tuniform sampler2D tDepth;\\n\\t\\tuniform float maxDistance;\\n\\t\\tuniform float opacity;\\n\\t\\tuniform float fresnelCoe;\\n\\t\\tuniform float virtualCameraNear;\\n\\t\\tuniform float virtualCameraFar;\\n\\t\\tuniform mat4 virtualCameraProjectionMatrix;\\n\\t\\tuniform mat4 virtualCameraProjectionMatrixInverse;\\n\\t\\tuniform mat4 virtualCameraMatrixWorld;\\n\\t\\tuniform vec2 resolution;\\n\\t\\tvarying vec4 vUv;\\n\\t\\t#include <packing>\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\t\\t}\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\t\\t}\\n\\t\\tfloat getDepth( const in vec2 uv ) {\\n\\t\\t\\treturn texture2D( tDepth, uv ).x;\\n\\t\\t}\\n\\t\\tfloat getViewZ( const in float depth ) {\\n\\t\\t\\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\\n\\t\\t}\\n\\t\\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\\n\\t\\t\\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\\n\\t\\t\\tclipPosition *= clipW; //clip\\n\\t\\t\\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\\n\\t\\t}\\n\\t\\tvoid main() {\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\t#ifdef useDepthTexture\\n\\t\\t\\t\\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\\n\\t\\t\\t\\tuv.x=1.-uv.x;\\n\\t\\t\\t\\tfloat depth = texture2DProj( tDepth, vUv ).r;\\n\\t\\t\\t\\tfloat viewZ = getViewZ( depth );\\n\\t\\t\\t\\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\\n\\t\\t\\t\\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\\n\\t\\t\\t\\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\\n\\t\\t\\t\\tif(worldPosition.y>maxDistance) discard;\\n\\t\\t\\t\\tfloat op=opacity;\\n\\t\\t\\t\\t#ifdef DISTANCE_ATTENUATION\\n\\t\\t\\t\\t\\tfloat ratio=1.-(worldPosition.y/maxDistance);\\n\\t\\t\\t\\t\\tfloat attenuation=ratio*ratio;\\n\\t\\t\\t\\t\\top=opacity*attenuation;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#ifdef FRESNEL\\n\\t\\t\\t\\t\\top*=fresnelCoe;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t\"\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","useDepthTexture","ReflectorShader","needsUpdate","textureMatrix","prototype","virtualCameraMatrixWorld","transparent","autoUpdate","far","fresnel","__esModule","DISTANCE_ATTENUATION","encoding","enabled","isReflectorForSSRPass","tDiffuse","getRenderTarget","defines","maxDistance","fresnelCoe","doRender","vertexShader","configurable","value","virtualCameraProjectionMatrix","tDepth","_distanceAttenuation","magFilter","writable","clippingPlanes","virtualCameraFar","type","__proto__","set","virtualCameraProjectionMatrixInverse","generateMipmaps","distanceAttenuation","uniforms","_fresnel","minFilter","ReflectorForSSRPass","get","color","virtualCameraNear","opacity","FRESNEL","format","constructor","resolution","depthTexture","material"]],"~:compiled-at",1630917515391,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$objects$ReflectorForSSRPass.js\",\n\"lineCount\":17,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/objects/ReflectorForSSRPass.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$objects$ReflectorForSSRPass\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ReflectorForSSRPass = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar ReflectorForSSRPass =\\n/*#__PURE__*/\\nfunction (_Mesh) {\\n  _inherits(ReflectorForSSRPass, _Mesh);\\n\\n  function ReflectorForSSRPass(geometry) {\\n    var _this;\\n\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n    _classCallCheck(this, ReflectorForSSRPass);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReflectorForSSRPass).call(this, geometry));\\n    _this.type = 'ReflectorForSSRPass';\\n\\n    var scope = _assertThisInitialized(_this);\\n\\n    var color = options.color !== undefined ? new _three.Color(options.color) : new _three.Color(0x7f7f7f);\\n    var textureWidth = options.textureWidth || 512;\\n    var textureHeight = options.textureHeight || 512;\\n    var clipBias = options.clipBias || 0;\\n    var shader = options.shader || ReflectorForSSRPass.ReflectorShader;\\n    var useDepthTexture = options.useDepthTexture === true;\\n    var yAxis = new _three.Vector3(0, 1, 0);\\n    var vecTemp0 = new _three.Vector3();\\n    var vecTemp1 = new _three.Vector3(); //\\n\\n    scope.needsUpdate = false;\\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\\n    scope.color = color;\\n    scope.resolution = options.resolution || new _three.Vector2(window.innerWidth, window.innerHeight);\\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\\n    Object.defineProperty(scope, 'distanceAttenuation', {\\n      get: function get() {\\n        return scope._distanceAttenuation;\\n      },\\n      set: function set(val) {\\n        if (scope._distanceAttenuation === val) return;\\n        scope._distanceAttenuation = val;\\n        scope.material.defines.DISTANCE_ATTENUATION = val;\\n        scope.material.needsUpdate = true;\\n      }\\n    });\\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\\n    Object.defineProperty(scope, 'fresnel', {\\n      get: function get() {\\n        return scope._fresnel;\\n      },\\n      set: function set(val) {\\n        if (scope._fresnel === val) return;\\n        scope._fresnel = val;\\n        scope.material.defines.FRESNEL = val;\\n        scope.material.needsUpdate = true;\\n      }\\n    });\\n    var normal = new _three.Vector3();\\n    var reflectorWorldPosition = new _three.Vector3();\\n    var cameraWorldPosition = new _three.Vector3();\\n    var rotationMatrix = new _three.Matrix4();\\n    var lookAtPosition = new _three.Vector3(0, 0, -1);\\n    var view = new _three.Vector3();\\n    var target = new _three.Vector3();\\n    var textureMatrix = new _three.Matrix4();\\n    var virtualCamera = new _three.PerspectiveCamera();\\n    var depthTexture;\\n\\n    if (useDepthTexture) {\\n      depthTexture = new _three.DepthTexture();\\n      depthTexture.type = _three.UnsignedShortType;\\n      depthTexture.minFilter = _three.NearestFilter;\\n      depthTexture.magFilter = _three.NearestFilter;\\n    }\\n\\n    var parameters = {\\n      minFilter: _three.LinearFilter,\\n      magFilter: _three.LinearFilter,\\n      format: _three.RGBFormat,\\n      depthTexture: useDepthTexture ? depthTexture : null\\n    };\\n    var renderTarget = new _three.WebGLRenderTarget(textureWidth, textureHeight, parameters);\\n\\n    if (!_three.MathUtils.isPowerOfTwo(textureWidth) || !_three.MathUtils.isPowerOfTwo(textureHeight)) {\\n      renderTarget.texture.generateMipmaps = false;\\n    }\\n\\n    var material = new _three.ShaderMaterial({\\n      transparent: useDepthTexture,\\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\\n        useDepthTexture: useDepthTexture\\n      }),\\n      uniforms: _three.UniformsUtils.clone(shader.uniforms),\\n      fragmentShader: shader.fragmentShader,\\n      vertexShader: shader.vertexShader\\n    });\\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\\n    material.uniforms['color'].value = scope.color;\\n    material.uniforms['textureMatrix'].value = textureMatrix;\\n\\n    if (useDepthTexture) {\\n      material.uniforms['tDepth'].value = renderTarget.depthTexture;\\n    }\\n\\n    _this.material = material;\\n    var globalPlane = new _three.Plane(new _three.Vector3(0, 1, 0), clipBias);\\n    var globalPlanes = [globalPlane];\\n\\n    _this.doRender = function (renderer, scene, camera) {\\n      material.uniforms['maxDistance'].value = scope.maxDistance;\\n      material.uniforms['color'].value = scope.color;\\n      material.uniforms['opacity'].value = scope.opacity;\\n      vecTemp0.copy(camera.position).normalize();\\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2; // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\\n\\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\\n      rotationMatrix.extractRotation(scope.matrixWorld);\\n      normal.set(0, 0, 1);\\n      normal.applyMatrix4(rotationMatrix);\\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\\n\\n      if (view.dot(normal) > 0) return;\\n      view.reflect(normal).negate();\\n      view.add(reflectorWorldPosition);\\n      rotationMatrix.extractRotation(camera.matrixWorld);\\n      lookAtPosition.set(0, 0, -1);\\n      lookAtPosition.applyMatrix4(rotationMatrix);\\n      lookAtPosition.add(cameraWorldPosition);\\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\\n      target.reflect(normal).negate();\\n      target.add(reflectorWorldPosition);\\n      virtualCamera.position.copy(view);\\n      virtualCamera.up.set(0, 1, 0);\\n      virtualCamera.up.applyMatrix4(rotationMatrix);\\n      virtualCamera.up.reflect(normal);\\n      virtualCamera.lookAt(target);\\n      virtualCamera.far = camera.far; // Used in WebGLBackground\\n\\n      virtualCamera.updateMatrixWorld();\\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\\n      material.uniforms['virtualCameraNear'].value = camera.near;\\n      material.uniforms['virtualCameraFar'].value = camera.far;\\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld;\\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix;\\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse;\\n      material.uniforms['resolution'].value = scope.resolution; // Update the texture matrix\\n\\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\\n      textureMatrix.multiply(scope.matrixWorld); // Render\\n\\n      renderTarget.texture.encoding = renderer.outputEncoding; // scope.visible = false;\\n\\n      var currentRenderTarget = renderer.getRenderTarget();\\n      var currentXrEnabled = renderer.xr.enabled;\\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\\n      var currentClippingPlanes = renderer.clippingPlanes;\\n      renderer.xr.enabled = false; // Avoid camera modification\\n\\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\\n\\n      renderer.clippingPlanes = globalPlanes;\\n      renderer.setRenderTarget(renderTarget);\\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\\n\\n      if (renderer.autoClear === false) renderer.clear();\\n      renderer.render(scene, virtualCamera);\\n      renderer.xr.enabled = currentXrEnabled;\\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\\n      renderer.clippingPlanes = currentClippingPlanes;\\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\\n\\n      var viewport = camera.viewport;\\n\\n      if (viewport !== undefined) {\\n        renderer.state.viewport(viewport);\\n      } // scope.visible = true;\\n\\n    };\\n\\n    _this.getRenderTarget = function () {\\n      return renderTarget;\\n    };\\n\\n    return _this;\\n  }\\n\\n  return ReflectorForSSRPass;\\n}(_three.Mesh);\\n\\nexports.ReflectorForSSRPass = ReflectorForSSRPass;\\nReflectorForSSRPass.prototype.isReflectorForSSRPass = true;\\nReflectorForSSRPass.ReflectorShader = {\\n  defines: {\\n    DISTANCE_ATTENUATION: true,\\n    FRESNEL: true\\n  },\\n  uniforms: {\\n    color: {\\n      value: null\\n    },\\n    tDiffuse: {\\n      value: null\\n    },\\n    tDepth: {\\n      value: null\\n    },\\n    textureMatrix: {\\n      value: new _three.Matrix4()\\n    },\\n    maxDistance: {\\n      value: 180\\n    },\\n    opacity: {\\n      value: 0.5\\n    },\\n    fresnelCoe: {\\n      value: null\\n    },\\n    virtualCameraNear: {\\n      value: null\\n    },\\n    virtualCameraFar: {\\n      value: null\\n    },\\n    virtualCameraProjectionMatrix: {\\n      value: new _three.Matrix4()\\n    },\\n    virtualCameraMatrixWorld: {\\n      value: new _three.Matrix4()\\n    },\\n    virtualCameraProjectionMatrixInverse: {\\n      value: new _three.Matrix4()\\n    },\\n    resolution: {\\n      value: new _three.Vector2()\\n    }\\n  },\\n  vertexShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\t\\\\tuniform mat4 textureMatrix;\\\\n\\\\t\\\\tvarying vec4 vUv;\\\\n\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\tvUv = textureMatrix * vec4( position, 1.0 );\\\\n\\\\n\\\\t\\\\t\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\n\\\\t\\\\t}\\\",\\n  fragmentShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\t\\\\tuniform vec3 color;\\\\n\\\\t\\\\tuniform sampler2D tDiffuse;\\\\n\\\\t\\\\tuniform sampler2D tDepth;\\\\n\\\\t\\\\tuniform float maxDistance;\\\\n\\\\t\\\\tuniform float opacity;\\\\n\\\\t\\\\tuniform float fresnelCoe;\\\\n\\\\t\\\\tuniform float virtualCameraNear;\\\\n\\\\t\\\\tuniform float virtualCameraFar;\\\\n\\\\t\\\\tuniform mat4 virtualCameraProjectionMatrix;\\\\n\\\\t\\\\tuniform mat4 virtualCameraProjectionMatrixInverse;\\\\n\\\\t\\\\tuniform mat4 virtualCameraMatrixWorld;\\\\n\\\\t\\\\tuniform vec2 resolution;\\\\n\\\\t\\\\tvarying vec4 vUv;\\\\n\\\\t\\\\t#include <packing>\\\\n\\\\t\\\\tfloat blendOverlay( float base, float blend ) {\\\\n\\\\t\\\\t\\\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\\\n\\\\t\\\\t\\\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tfloat getDepth( const in vec2 uv ) {\\\\n\\\\t\\\\t\\\\treturn texture2D( tDepth, uv ).x;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tfloat getViewZ( const in float depth ) {\\\\n\\\\t\\\\t\\\\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\\\\n\\\\t\\\\t\\\\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\\\\n\\\\t\\\\t\\\\tclipPosition *= clipW; //clip\\\\n\\\\t\\\\t\\\\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\t\\\\t\\\\tvec4 base = texture2DProj( tDiffuse, vUv );\\\\n\\\\t\\\\t\\\\t#ifdef useDepthTexture\\\\n\\\\t\\\\t\\\\t\\\\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\\\\n\\\\t\\\\t\\\\t\\\\tuv.x=1.-uv.x;\\\\n\\\\t\\\\t\\\\t\\\\tfloat depth = texture2DProj( tDepth, vUv ).r;\\\\n\\\\t\\\\t\\\\t\\\\tfloat viewZ = getViewZ( depth );\\\\n\\\\t\\\\t\\\\t\\\\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\\\\n\\\\t\\\\t\\\\t\\\\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\\\\n\\\\t\\\\t\\\\t\\\\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\\\\n\\\\t\\\\t\\\\t\\\\tif(worldPosition.y>maxDistance) discard;\\\\n\\\\t\\\\t\\\\t\\\\tfloat op=opacity;\\\\n\\\\t\\\\t\\\\t\\\\t#ifdef DISTANCE_ATTENUATION\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat ratio=1.-(worldPosition.y/maxDistance);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat attenuation=ratio*ratio;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\top=opacity*attenuation;\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\t\\\\t#ifdef FRESNEL\\\\n\\\\t\\\\t\\\\t\\\\t\\\\top*=fresnelCoe;\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\t\\\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t}\\\\n\\\\t\\\"\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_possibleConstructorReturn\",\"self\",\"call\",\"_assertThisInitialized\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"ReferenceError\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"defineProperty\",\"ReflectorForSSRPass\",\"_three\",\"_Mesh\",\"geometry\",\"options\",\"arguments\",\"length\",\"undefined\",\"instance\",\"_this\",\"type\",\"scope\",\"color\",\"Color\",\"textureWidth\",\"textureHeight\",\"clipBias\",\"shader\",\"ReflectorShader\",\"useDepthTexture\",\"yAxis\",\"Vector3\",\"vecTemp0\",\"vecTemp1\",\"needsUpdate\",\"maxDistance\",\"uniforms\",\"opacity\",\"resolution\",\"Vector2\",\"window\",\"innerWidth\",\"innerHeight\",\"_distanceAttenuation\",\"defines\",\"DISTANCE_ATTENUATION\",\"get\",\"set\",\"val\",\"material\",\"_fresnel\",\"FRESNEL\",\"normal\",\"reflectorWorldPosition\",\"cameraWorldPosition\",\"rotationMatrix\",\"Matrix4\",\"lookAtPosition\",\"view\",\"target\",\"textureMatrix\",\"virtualCamera\",\"PerspectiveCamera\",\"depthTexture\",\"DepthTexture\",\"UnsignedShortType\",\"minFilter\",\"NearestFilter\",\"magFilter\",\"renderTarget\",\"WebGLRenderTarget\",\"parameters\",\"LinearFilter\",\"format\",\"RGBFormat\",\"MathUtils\",\"isPowerOfTwo\",\"texture\",\"generateMipmaps\",\"ShaderMaterial\",\"transparent\",\"assign\",\"UniformsUtils\",\"clone\",\"fragmentShader\",\"vertexShader\",\"globalPlanes\",\"globalPlane\",\"Plane\",\"doRender\",\"_this.doRender\",\"renderer\",\"scene\",\"camera\",\"copy\",\"position\",\"normalize\",\"reflect\",\"dot\",\"setFromMatrixPosition\",\"matrixWorld\",\"extractRotation\",\"applyMatrix4\",\"subVectors\",\"negate\",\"add\",\"up\",\"lookAt\",\"far\",\"updateMatrixWorld\",\"projectionMatrix\",\"near\",\"projectionMatrixInverse\",\"multiply\",\"matrixWorldInverse\",\"encoding\",\"outputEncoding\",\"currentRenderTarget\",\"getRenderTarget\",\"currentXrEnabled\",\"xr\",\"enabled\",\"currentShadowAutoUpdate\",\"shadowMap\",\"autoUpdate\",\"currentClippingPlanes\",\"clippingPlanes\",\"setRenderTarget\",\"state\",\"buffers\",\"depth\",\"setMask\",\"autoClear\",\"clear\",\"render\",\"viewport\",\"_this.getRenderTarget\",\"Mesh\",\"isReflectorForSSRPass\",\"tDiffuse\",\"tDepth\",\"fresnelCoe\",\"virtualCameraNear\",\"virtualCameraFar\",\"virtualCameraProjectionMatrix\",\"virtualCameraMatrixWorld\",\"virtualCameraProjectionMatrixInverse\"]\n}\n"]