["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/nodes/materials/nodes/PhongNode.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$nodes$materials$nodes$PhongNode=function(global,require,module,exports){function PhongNode(){_Node.Node.call(this);this.color=new _ColorNode.ColorNode(15658734);this.specular=new _ColorNode.ColorNode(1118481);this.shininess=new _FloatNode.FloatNode(30)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.PhongNode=PhongNode;var _three=require(\"module$node_modules$three$build$three_module\"),_Node=require(\"module$node_modules$three_stdlib$nodes$core$Node\"),\n_ColorNode=require(\"module$node_modules$three_stdlib$nodes$inputs$ColorNode\"),_FloatNode=require(\"module$node_modules$three_stdlib$nodes$inputs$FloatNode\");PhongNode.prototype=Object.create(_Node.Node.prototype);PhongNode.prototype.constructor=PhongNode;PhongNode.prototype.nodeType=\"Phong\";PhongNode.prototype.build=function(builder){builder.define(\"PHONG\");builder.requires.lights=!0;if(builder.isShader(\"vertex\")){var position=this.position?this.position.analyzeAndFlow(builder,\"v3\",{cache:\"position\"}):\nvoid 0;builder.mergeUniform(_three.UniformsUtils.merge([_three.UniformsLib.fog,_three.UniformsLib.lights]));builder.addParsCode(\"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include \\x3cfog_pars_vertex\\x3e\\n#include \\x3cmorphtarget_pars_vertex\\x3e\\n#include \\x3cskinning_pars_vertex\\x3e\\n#include \\x3cshadowmap_pars_vertex\\x3e\\n#include \\x3clogdepthbuf_pars_vertex\\x3e\\n#include \\x3cclipping_planes_pars_vertex\\x3e\");builder=\"#include \\x3cbeginnormal_vertex\\x3e,#include \\x3cmorphnormal_vertex\\x3e,#include \\x3cskinbase_vertex\\x3e,#include \\x3cskinnormal_vertex\\x3e,#include \\x3cdefaultnormal_vertex\\x3e,#ifndef FLAT_SHADED,\\tvNormal \\x3d normalize( transformedNormal );,#endif,#include \\x3cbegin_vertex\\x3e\".split(\",\");\nposition&&builder.push(position.code,position.result?\"transformed \\x3d \"+position.result+\";\":\"\");builder.push(\"\\t#include \\x3cmorphtarget_vertex\\x3e\",\"\\t#include \\x3cskinning_vertex\\x3e\",\"\\t#include \\x3cproject_vertex\\x3e\",\"\\t#include \\x3cfog_vertex\\x3e\",\"\\t#include \\x3clogdepthbuf_vertex\\x3e\",\"\\t#include \\x3cclipping_planes_vertex\\x3e\",\"\\tvViewPosition \\x3d - mvPosition.xyz;\",\"\\t#include \\x3cworldpos_vertex\\x3e\",\"\\t#include \\x3cshadowmap_vertex\\x3e\",\"\\t#include \\x3cfog_vertex\\x3e\")}else{this.mask&&\nthis.mask.analyze(builder);this.color.analyze(builder,{slot:\"color\"});this.specular.analyze(builder);this.shininess.analyze(builder);this.alpha&&this.alpha.analyze(builder);this.normal&&this.normal.analyze(builder);this.light&&this.light.analyze(builder,{cache:\"light\"});this.ao&&this.ao.analyze(builder);this.ambient&&this.ambient.analyze(builder);this.shadow&&this.shadow.analyze(builder);this.emissive&&this.emissive.analyze(builder,{slot:\"emissive\"});this.environment&&this.environment.analyze(builder,\n{slot:\"environment\"});this.environmentAlpha&&this.environment&&this.environmentAlpha.analyze(builder);position=this.mask?this.mask.flow(builder,\"b\"):void 0;var color=this.color.flow(builder,\"c\",{slot:\"color\"}),specular=this.specular.flow(builder,\"c\"),shininess=this.shininess.flow(builder,\"f\"),alpha=this.alpha?this.alpha.flow(builder,\"f\"):void 0,normal=this.normal?this.normal.flow(builder,\"v3\"):void 0,light=this.light?this.light.flow(builder,\"v3\",{cache:\"light\"}):void 0,ao=this.ao?this.ao.flow(builder,\n\"f\"):void 0,ambient=this.ambient?this.ambient.flow(builder,\"c\"):void 0,shadow=this.shadow?this.shadow.flow(builder,\"c\"):void 0,emissive=this.emissive?this.emissive.flow(builder,\"c\",{slot:\"emissive\"}):void 0,environment=this.environment?this.environment.flow(builder,\"c\",{slot:\"environment\"}):void 0,environmentAlpha=this.environmentAlpha&&this.environment?this.environmentAlpha.flow(builder,\"f\"):void 0;builder.requires.transparent=void 0!==alpha;builder.addParsCode(\"#include \\x3cfog_pars_fragment\\x3e\\n#include \\x3cbsdfs\\x3e\\n#include \\x3clights_pars_begin\\x3e\\n#include \\x3clights_phong_pars_fragment\\x3e\\n#include \\x3cshadowmap_pars_fragment\\x3e\\n#include \\x3clogdepthbuf_pars_fragment\\x3e\");\nbuilder=[\"#include \\x3cnormal_fragment_begin\\x3e\",\"\\tBlinnPhongMaterial material;\"];position&&builder.push(position.code,\"if ( ! \"+position.result+\" ) discard;\");builder.push(color.code,\"\\tvec3 diffuseColor \\x3d \"+color.result+\";\",\"\\tReflectedLight reflectedLight \\x3d ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\",\"#include \\x3clogdepthbuf_fragment\\x3e\",specular.code,\"\\tvec3 specular \\x3d \"+specular.result+\";\",shininess.code,\"\\tfloat shininess \\x3d max( 0.0001, \"+shininess.result+\n\" );\",\"\\tfloat specularStrength \\x3d 1.0;\");alpha&&builder.push(alpha.code,\"#ifdef ALPHATEST\",\"if ( \"+alpha.result+\" \\x3c\\x3d ALPHATEST ) discard;\",\"#endif\");normal&&builder.push(normal.code,\"normal \\x3d \"+normal.result+\";\");builder.push(\"material.diffuseColor \\x3d \"+(light?\"vec3( 1.0 )\":\"diffuseColor\")+\";\");builder.push(\"material.specularColor \\x3d specular;\",\"material.specularShininess \\x3d shininess;\",\"material.specularStrength \\x3d specularStrength;\",\"#include \\x3clights_fragment_begin\\x3e\",\"#include \\x3clights_fragment_end\\x3e\");\nlight&&(builder.push(light.code,\"reflectedLight.directDiffuse \\x3d \"+light.result+\";\"),builder.push(\"reflectedLight.directDiffuse *\\x3d diffuseColor;\",\"reflectedLight.indirectDiffuse *\\x3d diffuseColor;\"));ao&&builder.push(ao.code,\"reflectedLight.indirectDiffuse *\\x3d \"+ao.result+\";\");ambient&&builder.push(ambient.code,\"reflectedLight.indirectDiffuse +\\x3d \"+ambient.result+\";\");shadow&&builder.push(shadow.code,\"reflectedLight.directDiffuse *\\x3d \"+shadow.result+\";\",\"reflectedLight.directSpecular *\\x3d \"+\nshadow.result+\";\");emissive&&builder.push(emissive.code,\"reflectedLight.directDiffuse +\\x3d \"+emissive.result+\";\");builder.push(\"vec3 outgoingLight \\x3d reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;\");environment&&(builder.push(environment.code),environmentAlpha?builder.push(environmentAlpha.code,\"outgoingLight \\x3d mix( outgoingLight, \"+environment.result+\", \"+environmentAlpha.result+\" );\"):builder.push(\"outgoingLight \\x3d \"+environment.result+\";\"));\nalpha?builder.push(\"gl_FragColor \\x3d vec4( outgoingLight, \"+alpha.result+\" );\"):builder.push(\"gl_FragColor \\x3d vec4( outgoingLight, 1.0 );\");builder.push(\"#include \\x3ctonemapping_fragment\\x3e\",\"#include \\x3cencodings_fragment\\x3e\",\"#include \\x3cfog_fragment\\x3e\",\"#include \\x3cpremultiplied_alpha_fragment\\x3e\")}return builder.join(\"\\n\")};PhongNode.prototype.copy=function(source){_Node.Node.prototype.copy.call(this,source);source.position&&(this.position=source.position);this.color=source.color;\nthis.specular=source.specular;this.shininess=source.shininess;source.mask&&(this.mask=source.mask);source.alpha&&(this.alpha=source.alpha);source.normal&&(this.normal=source.normal);source.light&&(this.light=source.light);source.shadow&&(this.shadow=source.shadow);source.ao&&(this.ao=source.ao);source.emissive&&(this.emissive=source.emissive);source.ambient&&(this.ambient=source.ambient);source.environment&&(this.environment=source.environment);source.environmentAlpha&&(this.environmentAlpha=source.environmentAlpha);\nreturn this};PhongNode.prototype.toJSON=function(meta){var data=this.getJSONNode(meta);data||(data=this.createJSONNode(meta),this.position&&(data.position=this.position.toJSON(meta).uuid),data.color=this.color.toJSON(meta).uuid,data.specular=this.specular.toJSON(meta).uuid,data.shininess=this.shininess.toJSON(meta).uuid,this.mask&&(data.mask=this.mask.toJSON(meta).uuid),this.alpha&&(data.alpha=this.alpha.toJSON(meta).uuid),this.normal&&(data.normal=this.normal.toJSON(meta).uuid),this.light&&(data.light=\nthis.light.toJSON(meta).uuid),this.ao&&(data.ao=this.ao.toJSON(meta).uuid),this.ambient&&(data.ambient=this.ambient.toJSON(meta).uuid),this.shadow&&(data.shadow=this.shadow.toJSON(meta).uuid),this.emissive&&(data.emissive=this.emissive.toJSON(meta).uuid),this.environment&&(data.environment=this.environment.toJSON(meta).uuid),this.environmentAlpha&&(data.environmentAlpha=this.environmentAlpha.toJSON(meta).uuid));return data}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$nodes$materials$nodes$PhongNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PhongNode = PhongNode;\n\nvar _three = require(\"three\");\n\nvar _Node = require(\"../../core/Node.js\");\n\nvar _ColorNode = require(\"../../inputs/ColorNode.js\");\n\nvar _FloatNode = require(\"../../inputs/FloatNode.js\");\n\nfunction PhongNode() {\n  _Node.Node.call(this);\n\n  this.color = new _ColorNode.ColorNode(0xeeeeee);\n  this.specular = new _ColorNode.ColorNode(0x111111);\n  this.shininess = new _FloatNode.FloatNode(30);\n}\n\nPhongNode.prototype = Object.create(_Node.Node.prototype);\nPhongNode.prototype.constructor = PhongNode;\nPhongNode.prototype.nodeType = 'Phong';\n\nPhongNode.prototype.build = function (builder) {\n  var code;\n  builder.define('PHONG');\n  builder.requires.lights = true;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.mergeUniform(_three.UniformsUtils.merge([_three.UniformsLib.fog, _three.UniformsLib.lights]));\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', '\tvarying vec3 vNormal;', '#endif', //\"#include <encodings_pars_fragment>\", // encoding functions\n    '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <morphnormal_vertex>', '#include <skinbase_vertex>', '#include <skinnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED', // normal computed with derivatives when FLAT_SHADED\n    '\tvNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\t#include <fog_vertex>', '\t#include <logdepthbuf_vertex>', '\t#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '\t#include <worldpos_vertex>', '\t#include <shadowmap_vertex>', '\t#include <fog_vertex>');\n    code = output.join('\\n');\n  } else {\n    // analyze all nodes to reuse generate codes\n    if (this.mask) this.mask.analyze(builder);\n    this.color.analyze(builder, {\n      slot: 'color'\n    });\n    this.specular.analyze(builder);\n    this.shininess.analyze(builder);\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.normal) this.normal.analyze(builder);\n    if (this.light) this.light.analyze(builder, {\n      cache: 'light'\n    });\n    if (this.ao) this.ao.analyze(builder);\n    if (this.ambient) this.ambient.analyze(builder);\n    if (this.shadow) this.shadow.analyze(builder);\n    if (this.emissive) this.emissive.analyze(builder, {\n      slot: 'emissive'\n    });\n    if (this.environment) this.environment.analyze(builder, {\n      slot: 'environment'\n    });\n    if (this.environmentAlpha && this.environment) this.environmentAlpha.analyze(builder); // build code\n\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    });\n    var specular = this.specular.flow(builder, 'c');\n    var shininess = this.shininess.flow(builder, 'f');\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var normal = this.normal ? this.normal.flow(builder, 'v3') : undefined;\n    var light = this.light ? this.light.flow(builder, 'v3', {\n      cache: 'light'\n    }) : undefined;\n    var ao = this.ao ? this.ao.flow(builder, 'f') : undefined;\n    var ambient = this.ambient ? this.ambient.flow(builder, 'c') : undefined;\n    var shadow = this.shadow ? this.shadow.flow(builder, 'c') : undefined;\n    var emissive = this.emissive ? this.emissive.flow(builder, 'c', {\n      slot: 'emissive'\n    }) : undefined;\n    var environment = this.environment ? this.environment.flow(builder, 'c', {\n      slot: 'environment'\n    }) : undefined;\n    var environmentAlpha = this.environmentAlpha && this.environment ? this.environmentAlpha.flow(builder, 'f') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <bsdfs>', '#include <lights_pars_begin>', '#include <lights_phong_pars_fragment>', '#include <shadowmap_pars_fragment>', '#include <logdepthbuf_pars_fragment>'].join('\\n'));\n    var output = [// prevent undeclared normal\n    '#include <normal_fragment_begin>', // prevent undeclared material\n    '\tBlinnPhongMaterial material;'];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    output.push(color.code, '\tvec3 diffuseColor = ' + color.result + ';', '\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', '#include <logdepthbuf_fragment>', specular.code, '\tvec3 specular = ' + specular.result + ';', shininess.code, '\tfloat shininess = max( 0.0001, ' + shininess.result + ' );', '\tfloat specularStrength = 1.0;' // Ignored in MaterialNode ( replace to specular )\n    );\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n\n    if (normal) {\n      output.push(normal.code, 'normal = ' + normal.result + ';');\n    } // optimization for now\n\n\n    output.push('material.diffuseColor = ' + (light ? 'vec3( 1.0 )' : 'diffuseColor') + ';');\n    output.push( // accumulation\n    'material.specularColor = specular;', 'material.specularShininess = shininess;', 'material.specularStrength = specularStrength;', '#include <lights_fragment_begin>', '#include <lights_fragment_end>');\n\n    if (light) {\n      output.push(light.code, 'reflectedLight.directDiffuse = ' + light.result + ';'); // apply color\n\n      output.push('reflectedLight.directDiffuse *= diffuseColor;', 'reflectedLight.indirectDiffuse *= diffuseColor;');\n    }\n\n    if (ao) {\n      output.push(ao.code, 'reflectedLight.indirectDiffuse *= ' + ao.result + ';');\n    }\n\n    if (ambient) {\n      output.push(ambient.code, 'reflectedLight.indirectDiffuse += ' + ambient.result + ';');\n    }\n\n    if (shadow) {\n      output.push(shadow.code, 'reflectedLight.directDiffuse *= ' + shadow.result + ';', 'reflectedLight.directSpecular *= ' + shadow.result + ';');\n    }\n\n    if (emissive) {\n      output.push(emissive.code, 'reflectedLight.directDiffuse += ' + emissive.result + ';');\n    }\n\n    output.push('vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;');\n\n    if (environment) {\n      output.push(environment.code);\n\n      if (environmentAlpha) {\n        output.push(environmentAlpha.code, 'outgoingLight = mix( outgoingLight, ' + environment.result + ', ' + environmentAlpha.result + ' );');\n      } else {\n        output.push('outgoingLight = ' + environment.result + ';');\n      }\n    }\n    /*\n    switch( builder.material.combine ) {\n    case ENVMAP_BLENDING_MULTIPLY:\n    \t//output.push( \"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\" );\n    //outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n    \tbreak;\n    }\n    */\n\n\n    if (alpha) {\n      output.push('gl_FragColor = vec4( outgoingLight, ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4( outgoingLight, 1.0 );');\n    }\n\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>', '#include <premultiplied_alpha_fragment>');\n    code = output.join('\\n');\n  }\n\n  return code;\n};\n\nPhongNode.prototype.copy = function (source) {\n  _Node.Node.prototype.copy.call(this, source); // vertex\n\n\n  if (source.position) this.position = source.position; // fragment\n\n  this.color = source.color;\n  this.specular = source.specular;\n  this.shininess = source.shininess;\n  if (source.mask) this.mask = source.mask;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.normal) this.normal = source.normal;\n  if (source.light) this.light = source.light;\n  if (source.shadow) this.shadow = source.shadow;\n  if (source.ao) this.ao = source.ao;\n  if (source.emissive) this.emissive = source.emissive;\n  if (source.ambient) this.ambient = source.ambient;\n  if (source.environment) this.environment = source.environment;\n  if (source.environmentAlpha) this.environmentAlpha = source.environmentAlpha;\n  return this;\n};\n\nPhongNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta); // vertex\n\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\n\n    data.color = this.color.toJSON(meta).uuid;\n    data.specular = this.specular.toJSON(meta).uuid;\n    data.shininess = this.shininess.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.normal) data.normal = this.normal.toJSON(meta).uuid;\n    if (this.light) data.light = this.light.toJSON(meta).uuid;\n    if (this.ao) data.ao = this.ao.toJSON(meta).uuid;\n    if (this.ambient) data.ambient = this.ambient.toJSON(meta).uuid;\n    if (this.shadow) data.shadow = this.shadow.toJSON(meta).uuid;\n    if (this.emissive) data.emissive = this.emissive.toJSON(meta).uuid;\n    if (this.environment) data.environment = this.environment.toJSON(meta).uuid;\n    if (this.environmentAlpha) data.environmentAlpha = this.environmentAlpha.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$three_stdlib$nodes$inputs$FloatNode","~$module$node_modules$three_stdlib$nodes$inputs$ColorNode","~$module$node_modules$three_stdlib$nodes$core$Node"]],"~:properties",["^5",["light","PhongNode","copy","prototype","transparent","lights","emissive","slot","__esModule","normal","cache","shadow","specular","position","nodeType","value","ambient","build","shininess","environment","environmentAlpha","alpha","color","mask","ao","constructor","toJSON"]],"~:compiled-at",1630917515248,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$nodes$materials$nodes$PhongNode.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/nodes/materials/nodes/PhongNode.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$nodes$materials$nodes$PhongNode\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.PhongNode = PhongNode;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _Node = require(\\\"../../core/Node.js\\\");\\n\\nvar _ColorNode = require(\\\"../../inputs/ColorNode.js\\\");\\n\\nvar _FloatNode = require(\\\"../../inputs/FloatNode.js\\\");\\n\\nfunction PhongNode() {\\n  _Node.Node.call(this);\\n\\n  this.color = new _ColorNode.ColorNode(0xeeeeee);\\n  this.specular = new _ColorNode.ColorNode(0x111111);\\n  this.shininess = new _FloatNode.FloatNode(30);\\n}\\n\\nPhongNode.prototype = Object.create(_Node.Node.prototype);\\nPhongNode.prototype.constructor = PhongNode;\\nPhongNode.prototype.nodeType = 'Phong';\\n\\nPhongNode.prototype.build = function (builder) {\\n  var code;\\n  builder.define('PHONG');\\n  builder.requires.lights = true;\\n\\n  if (builder.isShader('vertex')) {\\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\\n      cache: 'position'\\n    }) : undefined;\\n    builder.mergeUniform(_three.UniformsUtils.merge([_three.UniformsLib.fog, _three.UniformsLib.lights]));\\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', '\\tvarying vec3 vNormal;', '#endif', //\\\"#include <encodings_pars_fragment>\\\", // encoding functions\\n    '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>'].join('\\\\n'));\\n    var output = ['#include <beginnormal_vertex>', '#include <morphnormal_vertex>', '#include <skinbase_vertex>', '#include <skinnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED', // normal computed with derivatives when FLAT_SHADED\\n    '\\tvNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\\n\\n    if (position) {\\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\\n    }\\n\\n    output.push('\\t#include <morphtarget_vertex>', '\\t#include <skinning_vertex>', '\\t#include <project_vertex>', '\\t#include <fog_vertex>', '\\t#include <logdepthbuf_vertex>', '\\t#include <clipping_planes_vertex>', '\\tvViewPosition = - mvPosition.xyz;', '\\t#include <worldpos_vertex>', '\\t#include <shadowmap_vertex>', '\\t#include <fog_vertex>');\\n    code = output.join('\\\\n');\\n  } else {\\n    // analyze all nodes to reuse generate codes\\n    if (this.mask) this.mask.analyze(builder);\\n    this.color.analyze(builder, {\\n      slot: 'color'\\n    });\\n    this.specular.analyze(builder);\\n    this.shininess.analyze(builder);\\n    if (this.alpha) this.alpha.analyze(builder);\\n    if (this.normal) this.normal.analyze(builder);\\n    if (this.light) this.light.analyze(builder, {\\n      cache: 'light'\\n    });\\n    if (this.ao) this.ao.analyze(builder);\\n    if (this.ambient) this.ambient.analyze(builder);\\n    if (this.shadow) this.shadow.analyze(builder);\\n    if (this.emissive) this.emissive.analyze(builder, {\\n      slot: 'emissive'\\n    });\\n    if (this.environment) this.environment.analyze(builder, {\\n      slot: 'environment'\\n    });\\n    if (this.environmentAlpha && this.environment) this.environmentAlpha.analyze(builder); // build code\\n\\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\\n    var color = this.color.flow(builder, 'c', {\\n      slot: 'color'\\n    });\\n    var specular = this.specular.flow(builder, 'c');\\n    var shininess = this.shininess.flow(builder, 'f');\\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\\n    var normal = this.normal ? this.normal.flow(builder, 'v3') : undefined;\\n    var light = this.light ? this.light.flow(builder, 'v3', {\\n      cache: 'light'\\n    }) : undefined;\\n    var ao = this.ao ? this.ao.flow(builder, 'f') : undefined;\\n    var ambient = this.ambient ? this.ambient.flow(builder, 'c') : undefined;\\n    var shadow = this.shadow ? this.shadow.flow(builder, 'c') : undefined;\\n    var emissive = this.emissive ? this.emissive.flow(builder, 'c', {\\n      slot: 'emissive'\\n    }) : undefined;\\n    var environment = this.environment ? this.environment.flow(builder, 'c', {\\n      slot: 'environment'\\n    }) : undefined;\\n    var environmentAlpha = this.environmentAlpha && this.environment ? this.environmentAlpha.flow(builder, 'f') : undefined;\\n    builder.requires.transparent = alpha !== undefined;\\n    builder.addParsCode(['#include <fog_pars_fragment>', '#include <bsdfs>', '#include <lights_pars_begin>', '#include <lights_phong_pars_fragment>', '#include <shadowmap_pars_fragment>', '#include <logdepthbuf_pars_fragment>'].join('\\\\n'));\\n    var output = [// prevent undeclared normal\\n    '#include <normal_fragment_begin>', // prevent undeclared material\\n    '\\tBlinnPhongMaterial material;'];\\n\\n    if (mask) {\\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\\n    }\\n\\n    output.push(color.code, '\\tvec3 diffuseColor = ' + color.result + ';', '\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', '#include <logdepthbuf_fragment>', specular.code, '\\tvec3 specular = ' + specular.result + ';', shininess.code, '\\tfloat shininess = max( 0.0001, ' + shininess.result + ' );', '\\tfloat specularStrength = 1.0;' // Ignored in MaterialNode ( replace to specular )\\n    );\\n\\n    if (alpha) {\\n      output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\\n    }\\n\\n    if (normal) {\\n      output.push(normal.code, 'normal = ' + normal.result + ';');\\n    } // optimization for now\\n\\n\\n    output.push('material.diffuseColor = ' + (light ? 'vec3( 1.0 )' : 'diffuseColor') + ';');\\n    output.push( // accumulation\\n    'material.specularColor = specular;', 'material.specularShininess = shininess;', 'material.specularStrength = specularStrength;', '#include <lights_fragment_begin>', '#include <lights_fragment_end>');\\n\\n    if (light) {\\n      output.push(light.code, 'reflectedLight.directDiffuse = ' + light.result + ';'); // apply color\\n\\n      output.push('reflectedLight.directDiffuse *= diffuseColor;', 'reflectedLight.indirectDiffuse *= diffuseColor;');\\n    }\\n\\n    if (ao) {\\n      output.push(ao.code, 'reflectedLight.indirectDiffuse *= ' + ao.result + ';');\\n    }\\n\\n    if (ambient) {\\n      output.push(ambient.code, 'reflectedLight.indirectDiffuse += ' + ambient.result + ';');\\n    }\\n\\n    if (shadow) {\\n      output.push(shadow.code, 'reflectedLight.directDiffuse *= ' + shadow.result + ';', 'reflectedLight.directSpecular *= ' + shadow.result + ';');\\n    }\\n\\n    if (emissive) {\\n      output.push(emissive.code, 'reflectedLight.directDiffuse += ' + emissive.result + ';');\\n    }\\n\\n    output.push('vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;');\\n\\n    if (environment) {\\n      output.push(environment.code);\\n\\n      if (environmentAlpha) {\\n        output.push(environmentAlpha.code, 'outgoingLight = mix( outgoingLight, ' + environment.result + ', ' + environmentAlpha.result + ' );');\\n      } else {\\n        output.push('outgoingLight = ' + environment.result + ';');\\n      }\\n    }\\n    /*\\n    switch( builder.material.combine ) {\\n    case ENVMAP_BLENDING_MULTIPLY:\\n    \\t//output.push( \\\"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\\" );\\n    //outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n    \\tbreak;\\n    }\\n    */\\n\\n\\n    if (alpha) {\\n      output.push('gl_FragColor = vec4( outgoingLight, ' + alpha.result + ' );');\\n    } else {\\n      output.push('gl_FragColor = vec4( outgoingLight, 1.0 );');\\n    }\\n\\n    output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>', '#include <premultiplied_alpha_fragment>');\\n    code = output.join('\\\\n');\\n  }\\n\\n  return code;\\n};\\n\\nPhongNode.prototype.copy = function (source) {\\n  _Node.Node.prototype.copy.call(this, source); // vertex\\n\\n\\n  if (source.position) this.position = source.position; // fragment\\n\\n  this.color = source.color;\\n  this.specular = source.specular;\\n  this.shininess = source.shininess;\\n  if (source.mask) this.mask = source.mask;\\n  if (source.alpha) this.alpha = source.alpha;\\n  if (source.normal) this.normal = source.normal;\\n  if (source.light) this.light = source.light;\\n  if (source.shadow) this.shadow = source.shadow;\\n  if (source.ao) this.ao = source.ao;\\n  if (source.emissive) this.emissive = source.emissive;\\n  if (source.ambient) this.ambient = source.ambient;\\n  if (source.environment) this.environment = source.environment;\\n  if (source.environmentAlpha) this.environmentAlpha = source.environmentAlpha;\\n  return this;\\n};\\n\\nPhongNode.prototype.toJSON = function (meta) {\\n  var data = this.getJSONNode(meta);\\n\\n  if (!data) {\\n    data = this.createJSONNode(meta); // vertex\\n\\n    if (this.position) data.position = this.position.toJSON(meta).uuid; // fragment\\n\\n    data.color = this.color.toJSON(meta).uuid;\\n    data.specular = this.specular.toJSON(meta).uuid;\\n    data.shininess = this.shininess.toJSON(meta).uuid;\\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\\n    if (this.normal) data.normal = this.normal.toJSON(meta).uuid;\\n    if (this.light) data.light = this.light.toJSON(meta).uuid;\\n    if (this.ao) data.ao = this.ao.toJSON(meta).uuid;\\n    if (this.ambient) data.ambient = this.ambient.toJSON(meta).uuid;\\n    if (this.shadow) data.shadow = this.shadow.toJSON(meta).uuid;\\n    if (this.emissive) data.emissive = this.emissive.toJSON(meta).uuid;\\n    if (this.environment) data.environment = this.environment.toJSON(meta).uuid;\\n    if (this.environmentAlpha) data.environmentAlpha = this.environmentAlpha.toJSON(meta).uuid;\\n  }\\n\\n  return data;\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"PhongNode\",\"_Node\",\"Node\",\"call\",\"color\",\"_ColorNode\",\"ColorNode\",\"specular\",\"shininess\",\"_FloatNode\",\"FloatNode\",\"Object\",\"defineProperty\",\"value\",\"_three\",\"prototype\",\"create\",\"constructor\",\"nodeType\",\"build\",\"PhongNode.prototype.build\",\"builder\",\"define\",\"requires\",\"lights\",\"isShader\",\"position\",\"analyzeAndFlow\",\"cache\",\"undefined\",\"mergeUniform\",\"UniformsUtils\",\"merge\",\"UniformsLib\",\"fog\",\"addParsCode\",\"output\",\"push\",\"code\",\"result\",\"mask\",\"analyze\",\"slot\",\"alpha\",\"normal\",\"light\",\"ao\",\"ambient\",\"shadow\",\"emissive\",\"environment\",\"environmentAlpha\",\"flow\",\"transparent\",\"join\",\"copy\",\"PhongNode.prototype.copy\",\"source\",\"toJSON\",\"PhongNode.prototype.toJSON\",\"meta\",\"data\",\"getJSONNode\",\"createJSONNode\",\"uuid\"]\n}\n"]