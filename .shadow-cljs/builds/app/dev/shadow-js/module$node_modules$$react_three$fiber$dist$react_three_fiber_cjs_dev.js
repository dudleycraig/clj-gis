["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js"],"~:js","shadow$provide.module$node_modules$$react_three$fiber$dist$react_three_fiber_cjs_dev=function(global,require,module,exports){function _interopDefault(e){return e&&e.__esModule?e:{\"default\":e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var n=Object.create(null);e&&Object.keys(e).forEach(function(k){if(\"default\"!==k){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:!0,get:function(){return e[k]}})}});n[\"default\"]=e;return Object.freeze(n)}function makeId(event){return(event.eventObject||\nevent.object).uuid+\"/\"+event.index}function removeInteractivity(store,object){const {internal}=store.getState();internal.interaction=internal.interaction.filter(o=>o!==object);internal.initialHits=internal.initialHits.filter(o=>o!==object);internal.hovered.forEach((value,key)=>{value.eventObject!==object&&value.object!==object||internal.hovered.delete(key)})}function createEvents(store){function prepareRay(event){var _raycaster$computeOff;const state=store.getState(),{raycaster,mouse,camera,size}=\nstate,{offsetX,offsetY}=null!=(_raycaster$computeOff=null==raycaster.computeOffsets?void 0:raycaster.computeOffsets(event,state))?_raycaster$computeOff:event,{width,height}=size;mouse.set(offsetX/width*2-1,2*-(offsetY/height)+1);raycaster.setFromCamera(mouse,camera)}function calculateDistance(event){const {internal}=store.getState(),dx=event.offsetX-internal.initialClick[0];event=event.offsetY-internal.initialClick[1];return Math.round(Math.sqrt(dx*dx+event*event))}function filterPointerEvents(objects){return objects.filter(obj=>\n[\"Move\",\"Over\",\"Enter\",\"Out\",\"Leave\"].some(name=>{var _r3f$handlers;return null==(_r3f$handlers=obj.__r3f.handlers)?void 0:_r3f$handlers[\"onPointer\"+name]}))}function intersect$jscomp$0(filter){var state=store.getState();const {raycaster,internal}=state;if(!raycaster.enabled)return[];const seen=new Set,intersections=[];filter=filter?filter(internal.interaction):internal.interaction;filter=raycaster.intersectObjects(filter,!0).filter(item=>{item=makeId(item);if(seen.has(item))return!1;seen.add(item);\nreturn!0});raycaster.filter&&(filter=raycaster.filter(filter,state));for(const intersect of filter)for(state=intersect.object;state;){var _r3f;(null==(_r3f=state.__r3f)?0:_r3f.handlers)&&intersections.push(Object.assign({},intersect,{eventObject:state}));state=state.parent}return intersections}function patchIntersects(intersections,event){const {internal}=store.getState();\"pointerId\"in event&&internal.capturedMap.has(event.pointerId)&&intersections.push(...internal.capturedMap.get(event.pointerId).values());\nreturn intersections}function handleIntersects(intersections,event,callback){const {raycaster,mouse,camera,internal}=store.getState();if(intersections.length){const unprojectedPoint=temp.set(mouse.x,mouse.y,0).unproject(camera),delta=\"click\"===event.type?calculateDistance(event):0,releasePointerCapture=id=>event.target.releasePointerCapture(id);var JSCompiler_object_inline_stopped_741=!1;for(const hit of intersections){const hasPointerCapture=id=>{var _internal$capturedMap,_internal$capturedMap2;\nreturn null!=(_internal$capturedMap=null==(_internal$capturedMap2=internal.capturedMap.get(id))?void 0:_internal$capturedMap2.has(hit.eventObject))?_internal$capturedMap:!1},setPointerCapture=id=>{internal.capturedMap.has(id)?internal.capturedMap.get(id).set(hit.eventObject,hit):internal.capturedMap.set(id,new Map([[hit.eventObject,hit]]));event.target.setPointerCapture(id)};let extractEventProps={};for(let prop in Object.getPrototypeOf(event)){let property=event[prop];\"function\"!==typeof property&&\n(extractEventProps[prop]=property)}let raycastEvent=Object.assign({},hit,extractEventProps,{spaceX:mouse.x,spaceY:mouse.y,intersections,stopped:JSCompiler_object_inline_stopped_741,delta,unprojectedPoint,ray:raycaster.ray,camera,stopPropagation:()=>{var capturesForPointer=\"pointerId\"in event&&internal.capturedMap.get(event.pointerId);if(!capturesForPointer||capturesForPointer.has(hit.eventObject))raycastEvent.stopped=JSCompiler_object_inline_stopped_741=!0,internal.hovered.size&&Array.from(internal.hovered.values()).find(i=>\ni.eventObject===hit.eventObject)&&(capturesForPointer=intersections.slice(0,intersections.indexOf(hit)),cancelPointer([...capturesForPointer,hit]))},target:{hasPointerCapture,setPointerCapture,releasePointerCapture},currentTarget:{hasPointerCapture,setPointerCapture,releasePointerCapture},sourceEvent:event,nativeEvent:event});callback(raycastEvent);if(!0===JSCompiler_object_inline_stopped_741)break}}return intersections}function cancelPointer(hits){const {internal}=store.getState();Array.from(internal.hovered.values()).forEach(hoveredObj=>\n{if(!hits.length||!hits.find(hit=>hit.object===hoveredObj.object&&hit.index===hoveredObj.index)){const handlers=hoveredObj.eventObject.__r3f.handlers;internal.hovered.delete(makeId(hoveredObj));if(handlers){const data=Object.assign({},hoveredObj,{intersections:hits||[]});null==handlers.onPointerOut?void 0:handlers.onPointerOut(data);null==handlers.onPointerLeave?void 0:handlers.onPointerLeave(data)}}})}function pointerMissed(event,objects){objects.forEach(object=>{var _r3f$handlers2;return null==\n(_r3f$handlers2=object.__r3f.handlers)?void 0:null==_r3f$handlers2.onPointerMissed?void 0:_r3f$handlers2.onPointerMissed(event)})}const temp=new THREE__namespace.Vector3;return{handlePointer:name=>{switch(name){case \"onPointerLeave\":case \"onPointerCancel\":return()=>cancelPointer([]);case \"onLostPointerCapture\":return event=>{\"pointerId\"in event&&store.getState().internal.capturedMap.delete(event.pointerId);cancelPointer([])}}return event=>{const {onPointerMissed,internal}=store.getState();prepareRay(event);\nconst isPointerMove=\"onPointerMove\"===name,hits=patchIntersects(intersect$jscomp$0(isPointerMove?filterPointerEvents:void 0),event);isPointerMove&&cancelPointer(hits);handleIntersects(hits,event,data=>{const eventObject=data.eventObject;var handlers=eventObject.__r3f.handlers;if(handlers)if(isPointerMove){if(handlers.onPointerOver||handlers.onPointerEnter||handlers.onPointerOut||handlers.onPointerLeave){const id=makeId(data),hoveredItem=internal.hovered.get(id);hoveredItem?hoveredItem.stopped&&data.stopPropagation():\n(internal.hovered.set(id,data),null==handlers.onPointerOver?void 0:handlers.onPointerOver(data),null==handlers.onPointerEnter?void 0:handlers.onPointerEnter(data))}null==handlers.onPointerMove?void 0:handlers.onPointerMove(data)}else(handlers=null==handlers?void 0:handlers[name])&&(\"onClick\"!==name&&\"onContextMenu\"!==name&&\"onDoubleClick\"!==name||internal.initialHits.includes(eventObject))&&(handlers(data),pointerMissed(event,internal.interaction.filter(object=>object!==eventObject)))});\"onPointerDown\"===\nname&&(internal.initialClick=[event.offsetX,event.offsetY],internal.initialHits=hits.map(hit=>hit.eventObject));(\"onClick\"===name||\"onContextMenu\"===name||\"onDoubleClick\"===name)&&!hits.length&&2>=calculateDistance(event)&&(pointerMissed(event,internal.interaction),onPointerMissed&&onPointerMissed(event))}}}}function prepare(object,state){if(null!=state&&state.instance||!object.__r3f)object.__r3f=Object.assign({},{root:null,memoizedProps:{},objects:[]},state);return object}function createSubs(callback,\nsubs){const index=subs.length;subs.push(callback);return()=>void subs.splice(index,1)}function run(effects,timestamp){for(i$jscomp$0=0;i$jscomp$0<effects.length;i$jscomp$0++)effects[i$jscomp$0](timestamp)}function render$1(timestamp,state){let delta=state.clock.getDelta();\"never\"===state.frameloop&&\"number\"===typeof timestamp&&(delta=timestamp-state.clock.elapsedTime,state.clock.oldTime=state.clock.elapsedTime,state.clock.elapsedTime=timestamp);for(i$jscomp$0=0;i$jscomp$0<state.internal.subscribers.length;i$jscomp$0++)state.internal.subscribers[i$jscomp$0].ref.current(state,\ndelta);!state.internal.priority&&state.gl.render&&state.gl.render(state.scene,state.camera);state.internal.frames=Math.max(0,state.internal.frames-1);return\"always\"===state.frameloop?1:state.internal.frames}function createPointerEvents(store){const {handlePointer}=createEvents(store),names={onClick:[\"click\",!1],onContextMenu:[\"contextmenu\",!1],onDoubleClick:[\"dblclick\",!1],onWheel:[\"wheel\",!0],onPointerDown:[\"pointerdown\",!0],onPointerUp:[\"pointerup\",!0],onPointerLeave:[\"pointerleave\",!0],onPointerMove:[\"pointermove\",\n!0],onPointerCancel:[\"pointercancel\",!0],onLostPointerCapture:[\"lostpointercapture\",!0]};return{connected:!1,handlers:Object.keys(names).reduce((acc,key)=>Object.assign({},acc,{[key]:handlePointer(key)}),{}),connect:target=>{var _events$handlers;const {set,events}=store.getState();null==events.disconnect?void 0:events.disconnect();set(state=>({events:Object.assign({},state.events,{connected:target})}));Object.entries(null!=(_events$handlers=null==events?void 0:events.handlers)?_events$handlers:[]).forEach($jscomp$destructuring$var38=>\n{var [name,event]=$jscomp$destructuring$var38;const [eventName,passive]=names[name];target.addEventListener(eventName,event,{passive})})},disconnect:()=>{const {set,events}=store.getState();if(events.connected){var _events$handlers2;Object.entries(null!=(_events$handlers2=events.handlers)?_events$handlers2:[]).forEach($jscomp$destructuring$var39=>{var [name,event]=$jscomp$destructuring$var39;events&&events.connected instanceof HTMLElement&&([$jscomp$destructuring$var39]=names[name],events.connected.removeEventListener($jscomp$destructuring$var39,\nevent))});set(state=>({events:Object.assign({},state.events,{connected:!1})}))}}}}function Block($jscomp$destructuring$var40){var {set}=$jscomp$destructuring$var40;useIsomorphicLayoutEffect(()=>{set(new Promise(()=>null));return()=>set(!1)},[]);return null}function buildGraph(object){const data={nodes:{},materials:{}};object&&object.traverse(obj=>{obj.name&&(data.nodes[obj.name]=obj);obj.material&&!data.materials[obj.material.name]&&(data.materials[obj.material.name]=obj.material)});return data}function loadingFn(extensions,\nonProgress){return function(Proto,...input$jscomp$0){const loader=new Proto;extensions&&extensions(loader);return Promise.all(input$jscomp$0.map(input=>new Promise((res,reject)=>loader.load(input,data=>{data.scene&&Object.assign(data,buildGraph(data.scene));res(data)},onProgress,error=>reject(`Could not load ${input}: ${error.message}`)))))}}function useLoader(Proto,input,extensions,onProgress){const keys=Array.isArray(input)?input:[input];Proto=useAsset.useAsset(loadingFn(extensions,onProgress),\nProto,...keys);return Array.isArray(input)?Proto:Proto[0]}function render(element,canvas,$jscomp$destructuring$var44){var $jscomp$destructuring$var45=void 0===$jscomp$destructuring$var44?{}:$jscomp$destructuring$var44,$jscomp$destructuring$var46=Object.assign({},$jscomp$destructuring$var45),gl=$jscomp$destructuring$var45.gl,size=$jscomp$destructuring$var45.size;$jscomp$destructuring$var44=void 0===$jscomp$destructuring$var45.mode?modes[1]:$jscomp$destructuring$var45.mode;var events=$jscomp$destructuring$var45.events;\n$jscomp$destructuring$var45=$jscomp$destructuring$var45.onCreated;$jscomp$destructuring$var46=(delete $jscomp$destructuring$var46.gl,delete $jscomp$destructuring$var46.size,delete $jscomp$destructuring$var46.mode,delete $jscomp$destructuring$var46.events,delete $jscomp$destructuring$var46.onCreated,$jscomp$destructuring$var46);var _store;if(!size){var _canvas$parentElement,_canvas$parentElement2,_canvas$parentElement3,_canvas$parentElement4;size={width:null!=(_canvas$parentElement=null==(_canvas$parentElement2=\ncanvas.parentElement)?void 0:_canvas$parentElement2.clientWidth)?_canvas$parentElement:0,height:null!=(_canvas$parentElement3=null==(_canvas$parentElement4=canvas.parentElement)?void 0:_canvas$parentElement4.clientHeight)?_canvas$parentElement3:0}}_canvas$parentElement2=roots$jscomp$0.get(canvas);_canvas$parentElement=null==_canvas$parentElement2?void 0:_canvas$parentElement2.fiber;_canvas$parentElement2=null==_canvas$parentElement2?void 0:_canvas$parentElement2.store;_canvas$parentElement3=null==\n(_store=_canvas$parentElement2)?void 0:_store.getState();_canvas$parentElement&&_canvas$parentElement3&&(_store=_canvas$parentElement3.internal.lastProps,void 0===$jscomp$destructuring$var46.dpr||is.equ(_store.dpr,$jscomp$destructuring$var46.dpr)||_canvas$parentElement3.setDpr($jscomp$destructuring$var46.dpr),is.equ(_store.size,size)||_canvas$parentElement3.setSize(size.width,size.height),$jscomp$destructuring$var46.linear!==_store.linear&&(unmountComponentAtNode(canvas),_canvas$parentElement=void 0));\n_canvas$parentElement||(gl=gl&&gl.render?gl:new THREE__namespace.WebGLRenderer(Object.assign({},{powerPreference:\"high-performance\",canvas,antialias:!0,alpha:!0},gl)),$jscomp$destructuring$var46.vr&&(gl.xr.enabled=!0,gl.setAnimationLoop(timestamp=>advance$jscomp$0(timestamp,!0))),_canvas$parentElement2=createStore(applyProps$jscomp$0,invalidate$jscomp$0,advance$jscomp$0,Object.assign({},{gl,size},$jscomp$destructuring$var46)),size=_canvas$parentElement2.getState(),_canvas$parentElement=reconciler.createContainer(_canvas$parentElement2,\nmodes.indexOf($jscomp$destructuring$var44),!1,null),roots$jscomp$0.set(canvas,{fiber:_canvas$parentElement,store:_canvas$parentElement2}),events&&size.set({events:events(_canvas$parentElement2)}));if(_canvas$parentElement2&&_canvas$parentElement)return reconciler.updateContainer(React__namespace.createElement(Provider,{store:_canvas$parentElement2,element,onCreated:$jscomp$destructuring$var45,target:canvas}),_canvas$parentElement,null,()=>{}),_canvas$parentElement2;throw\"Error creating root!\";}function Provider($jscomp$destructuring$var47){var {store,\nelement,onCreated,target}=$jscomp$destructuring$var47;React__namespace.useEffect(()=>{const state$jscomp$0=store.getState();state$jscomp$0.set(state=>({internal:Object.assign({},state.internal,{active:!0})}));null==state$jscomp$0.events.connect?void 0:state$jscomp$0.events.connect(target);onCreated&&onCreated(state$jscomp$0)},[]);return React__namespace.createElement(context.Provider,{value:store},element)}function unmountComponentAtNode(canvas,callback){const root=roots$jscomp$0.get(canvas),fiber=\nnull==root?void 0:root.fiber;if(fiber){const state=null==root?void 0:root.store.getState();state&&(state.internal.active=!1);reconciler.updateContainer(null,fiber,null,()=>{state&&setTimeout(()=>{var _state$gl,_state$gl$renderLists,_state$gl2;null==state.events.disconnect?void 0:state.events.disconnect();null==(_state$gl=state.gl)?void 0:null==(_state$gl$renderLists=_state$gl.renderLists)?void 0:null==_state$gl$renderLists.dispose?void 0:_state$gl$renderLists.dispose();null==(_state$gl2=state.gl)?\nvoid 0:null==_state$gl2.forceContextLoss?void 0:_state$gl2.forceContextLoss();dispose$jscomp$0(state);roots$jscomp$0.delete(canvas);callback&&callback(canvas)},500)})}}function dispose$jscomp$0(obj){obj.dispose&&\"Scene\"!==obj.type&&obj.dispose();for(const p in obj){var _dispose,_ref;null==(_dispose=(_ref=p).dispose)?void 0:_dispose.call(_ref);delete obj[p]}}Object.defineProperty(exports,\"__esModule\",{value:!0});global=require(\"module$node_modules$three$build$three\");module=require(\"module$node_modules$react$index\");\nvar create=require(\"module$node_modules$zustand$index\"),shallow=require(\"module$node_modules$zustand$shallow\"),Reconciler=require(\"module$node_modules$react_reconciler$index\"),scheduler=require(\"module$node_modules$scheduler$index\"),useAsset=require(\"module$node_modules$use_asset$dist$index_cjs\"),mergeRefs=require(\"module$node_modules$react_merge_refs$dist$index\");require=require(\"module$node_modules$react_use_measure$dist$web_cjs\");var THREE__namespace=_interopNamespace(global),React__namespace=\n_interopNamespace(module),create__default=_interopDefault(create),shallow__default=_interopDefault(shallow),Reconciler__default=_interopDefault(Reconciler),mergeRefs__default=_interopDefault(mergeRefs),useMeasure__default=_interopDefault(require);require=Object.freeze({__proto__:null});const is={obj:a=>a===Object(a)&&!is.arr(a)&&\"function\"!==typeof a,fun:a=>\"function\"===typeof a,str:a=>\"string\"===typeof a,num:a=>\"number\"===typeof a,und:a=>void 0===a,arr:a=>Array.isArray(a),equ(a,b){if(typeof a!==\ntypeof b||!!a!==!!b)return!1;if(is.str(a)||is.num(a)||is.obj(a))return a===b;if(is.arr(a)&&a==b)return!0;let i;for(i in a)if(!(i in b))return!1;for(i in b)if(a[i]!==b[i])return!1;return is.und(i)?a===b:!0}},getContainer=(container,child)=>{var _container$__r3f$root,_container$__r3f;return{root:container&&container.getState?container:null!=(_container$__r3f$root=null==(_container$__r3f=container.__r3f)?void 0:_container$__r3f.root)?_container$__r3f$root:child.__r3f.root,container:container&&container.getState?\ncontainer.getState().scene:container}},EMPTY={},FILTER=[\"children\",\"key\",\"ref\"];let catalogue={};const context=React__namespace.createContext(null),createStore=(applyProps,invalidate,advance,props)=>{const {gl,size:size$jscomp$0,shadows=!1,linear=!1,flat=!1,vr=!1,orthographic=!1,frameloop=\"always\",dpr:dpr$jscomp$0=1,performance,clock=new THREE__namespace.Clock,raycaster:raycastOptions,camera:cameraOptions,onPointerMissed}=props;shadows&&(gl.shadowMap.enabled=!0,\"object\"===typeof shadows?Object.assign(gl.shadowMap,\nshadows):gl.shadowMap.type=THREE__namespace.PCFSoftShadowMap);linear||(flat||(gl.toneMapping=THREE__namespace.ACESFilmicToneMapping),gl.outputEncoding=THREE__namespace.sRGBEncoding);\"never\"===frameloop&&(clock.stop(),clock.elapsedTime=0);const rootState=create__default[\"default\"]((set,get)=>{function setDpr(dpr){return Array.isArray(dpr)?Math.min(Math.max(dpr[0],window.devicePixelRatio),dpr[1]):dpr}function getCurrentViewport(camera,target,size){camera=void 0===camera?get().camera:camera;target=void 0===\ntarget?defaultTarget:target;size=void 0===size?get().size:size;const {width,height}=size;size=width/height;target=camera.getWorldPosition(position).distanceTo(target);if(camera&&camera.isOrthographicCamera)return{width:width/camera.zoom,height:height/camera.zoom,factor:1,distance:target,aspect:size};camera=2*Math.tan(camera.fov*Math.PI/180/2)*target;const w=width/height*camera;return{width:w,height:camera,factor:width/w,distance:target,aspect:size}}const raycaster=new THREE__namespace.Raycaster;var $jscomp$destructuring$var34=\nraycastOptions||{},$jscomp$destructuring$var35=Object.assign({},$jscomp$destructuring$var34);$jscomp$destructuring$var34=$jscomp$destructuring$var34.params;$jscomp$destructuring$var35=(delete $jscomp$destructuring$var35.params,$jscomp$destructuring$var35);applyProps(raycaster,Object.assign({},{enabled:!0},$jscomp$destructuring$var35,{params:Object.assign({},raycaster.params,$jscomp$destructuring$var34)}),{});const camera$jscomp$0=($jscomp$destructuring$var35=cameraOptions instanceof THREE__namespace.Camera)?\ncameraOptions:orthographic?new THREE__namespace.OrthographicCamera(0,0,0,0,.1,1E3):new THREE__namespace.PerspectiveCamera(75,0,.1,1E3);$jscomp$destructuring$var35||(camera$jscomp$0.position.z=5,cameraOptions&&applyProps(camera$jscomp$0,cameraOptions,{}),camera$jscomp$0.lookAt(0,0,0));$jscomp$destructuring$var35=setDpr(dpr$jscomp$0);const position=new THREE__namespace.Vector3,defaultTarget=new THREE__namespace.Vector3;let performanceTimeout=void 0;const setPerformanceCurrent=current=>set(state=>({performance:Object.assign({},\nstate.performance,{current})}));return{gl,set,get,invalidate:()=>invalidate(get()),advance:(timestamp,runGlobalEffects)=>advance(timestamp,runGlobalEffects,get()),linear,flat,scene:prepare(new THREE__namespace.Scene),camera:camera$jscomp$0,controls:null,raycaster,clock,mouse:new THREE__namespace.Vector2,vr,frameloop,onPointerMissed,performance:Object.assign({},{current:1,min:.5,max:1,debounce:200},performance,{regress:()=>{const state=get();performanceTimeout&&clearTimeout(performanceTimeout);state.performance.current!==\nstate.performance.min&&setPerformanceCurrent(state.performance.min);performanceTimeout=setTimeout(()=>setPerformanceCurrent(get().performance.max),state.performance.debounce)}}),size:{width:0,height:0},viewport:{initialDpr:$jscomp$destructuring$var35,dpr:$jscomp$destructuring$var35,width:0,height:0,aspect:0,distance:0,factor:0,getCurrentViewport},setSize:(width,height)=>{const size={width,height};set(state=>({size,viewport:Object.assign({},state.viewport,getCurrentViewport(camera$jscomp$0,defaultTarget,\nsize))}))},setDpr:dpr=>set(state=>({viewport:Object.assign({},state.viewport,{dpr:setDpr(dpr)})})),events:{connected:!1},internal:{active:!1,priority:0,frames:0,lastProps:props,interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(ref,priority)=>{priority=void 0===priority?0:priority;set($jscomp$destructuring$var36=>{({internal:$jscomp$destructuring$var36}=$jscomp$destructuring$var36);return{internal:Object.assign({},$jscomp$destructuring$var36,\n{priority:$jscomp$destructuring$var36.priority+(0<priority?1:0),subscribers:[...$jscomp$destructuring$var36.subscribers,{ref,priority}].sort((a,b)=>a.priority-b.priority)})}});return()=>{set($jscomp$destructuring$var37=>{({internal:$jscomp$destructuring$var37}=$jscomp$destructuring$var37);return{internal:Object.assign({},$jscomp$destructuring$var37,{priority:$jscomp$destructuring$var37.priority-(0<priority?1:0),subscribers:$jscomp$destructuring$var37.subscribers.filter(s=>s.ref!==ref)})}})}}}}});\nrootState.subscribe(()=>{const {camera,size,viewport,internal}=rootState.getState();internal.lastProps.camera instanceof THREE__namespace.Camera||(camera&&camera.isOrthographicCamera?(camera.left=size.width/-2,camera.right=size.width/2,camera.top=size.height/2,camera.bottom=size.height/-2):camera.aspect=size.width/size.height,camera.updateProjectionMatrix(),camera.updateMatrixWorld());gl.setPixelRatio(viewport.dpr);gl.setSize(size.width,size.height)},state=>[state.viewport.dpr,state.size],shallow__default[\"default\"]);\nconst state$jscomp$0=rootState.getState();size$jscomp$0&&state$jscomp$0.setSize(size$jscomp$0.width,size$jscomp$0.height);rootState.subscribe(state=>invalidate(state));return rootState};let i$jscomp$0,globalEffects=[],globalAfterEffects=[],globalTailEffects=[];const useIsomorphicLayoutEffect=\"undefined\"!==typeof window?React__namespace.useLayoutEffect:React__namespace.useEffect;class ErrorBoundary extends React__namespace.Component{constructor(...args){super(...args);this.state={error:!1}}componentDidCatch(error){this.props.set(error)}render(){return this.state.error?\nnull:this.props.children}}ErrorBoundary.getDerivedStateFromError=()=>({error:!0});global=React__namespace.forwardRef(function($jscomp$destructuring$var41,forwardedRef){var $jscomp$destructuring$var43=Object.assign({},$jscomp$destructuring$var41),children=$jscomp$destructuring$var41.children,fallback=$jscomp$destructuring$var41.fallback,tabIndex=$jscomp$destructuring$var41.tabIndex,resize=$jscomp$destructuring$var41.resize,id=$jscomp$destructuring$var41.id,style=$jscomp$destructuring$var41.style,className=\n$jscomp$destructuring$var41.className,events=$jscomp$destructuring$var41.events,props=(delete $jscomp$destructuring$var43.children,delete $jscomp$destructuring$var43.fallback,delete $jscomp$destructuring$var43.tabIndex,delete $jscomp$destructuring$var43.resize,delete $jscomp$destructuring$var43.id,delete $jscomp$destructuring$var43.style,delete $jscomp$destructuring$var43.className,delete $jscomp$destructuring$var43.events,$jscomp$destructuring$var43);const [containerRef,size]=useMeasure__default[\"default\"](Object.assign({},\n{scroll:!0,debounce:{scroll:50,resize:0}},resize)),canvasRef=React__namespace.useRef(null),[block,setBlock]=React__namespace.useState(!1),[error,setError]=React__namespace.useState(!1);if(block)throw block;if(error)throw error;useIsomorphicLayoutEffect(()=>{0<size.width&&0<size.height&&render(React__namespace.createElement(ErrorBoundary,{set:setError},React__namespace.createElement(React__namespace.Suspense,{fallback:React__namespace.createElement(Block,{set:setBlock})},children)),canvasRef.current,\nObject.assign({},props,{size,events:events||createPointerEvents}))},[size,children]);useIsomorphicLayoutEffect(()=>{const container=canvasRef.current;return()=>unmountComponentAtNode(container)},[]);return React__namespace.createElement(\"div\",{ref:containerRef,id,className,tabIndex,style:Object.assign({},{position:\"relative\",width:\"100%\",height:\"100%\",overflow:\"hidden\"},style)},React__namespace.createElement(\"canvas\",{ref:mergeRefs__default[\"default\"]([canvasRef,forwardedRef]),style:{display:\"block\"}},\nfallback))});useLoader.preload=function(Proto,input,extensions){input=Array.isArray(input)?input:[input];return useAsset.useAsset.preload(loadingFn(extensions),Proto,...input)};useLoader.clear=function(Proto,input){input=Array.isArray(input)?input:[input];return useAsset.useAsset.clear(Proto,...input)};const roots$jscomp$0=new Map,modes=[\"legacy\",\"blocking\",\"concurrent\"],{invalidate:invalidate$jscomp$0,advance:advance$jscomp$0}=function(roots){function loop(timestamp){running=!0;repeat=0;run(globalEffects,\ntimestamp);roots.forEach(root=>{root=root.store.getState();root.internal.active&&(\"always\"===root.frameloop||0<root.internal.frames)&&(repeat+=render$1(timestamp,root))});run(globalAfterEffects,timestamp);if(0<repeat)return requestAnimationFrame(loop);run(globalTailEffects,timestamp);running=!1}function invalidate(state){if(!state)return roots.forEach(root=>invalidate(root.store.getState()));!state.vr&&state.internal.active&&\"never\"!==state.frameloop&&(state.internal.frames=Math.min(60,state.internal.frames+\n1),running||(running=!0,requestAnimationFrame(loop)))}let running=!1,repeat;return{loop,invalidate,advance:function(timestamp,runGlobalEffects,state){(runGlobalEffects=void 0===runGlobalEffects?!0:runGlobalEffects)&&run(globalEffects,timestamp);state?render$1(timestamp,state):roots.forEach(root=>render$1(timestamp,root.store.getState()));runGlobalEffects&&run(globalAfterEffects,timestamp)}}}(roots$jscomp$0),{reconciler,applyProps:applyProps$jscomp$0}=function(roots){function applyProps(instance,newProps,\noldProps,accumulative){oldProps=void 0===oldProps?{}:oldProps;accumulative=void 0===accumulative?!1:accumulative;var _instance$__r3f,_root$getState,_instance$__r3f2;const localState=null!=(_instance$__r3f=null==instance?void 0:instance.__r3f)?_instance$__r3f:{};_instance$__r3f=localState.root;const rootState=null!=(_root$getState=null==_instance$__r3f?void 0:null==_instance$__r3f.getState?void 0:_instance$__r3f.getState())?_root$getState:{},sameProps=[],handlers=[],newMemoizedProps={};_root$getState=\n0;Object.entries(newProps).forEach($jscomp$destructuring$var24=>{var [key,entry]=$jscomp$destructuring$var24;-1===FILTER.indexOf(key)&&(newMemoizedProps[key]=entry)});localState.memoizedProps&&localState.memoizedProps.args&&(newMemoizedProps.args=localState.memoizedProps.args);localState.memoizedProps&&localState.memoizedProps.attach&&(newMemoizedProps.attach=localState.memoizedProps.attach);instance.__r3f&&(instance.__r3f.memoizedProps=newMemoizedProps);let objectKeys=Object.keys(newProps);for(_root$getState=\n0;_root$getState<objectKeys.length;_root$getState++)is.equ(newProps[objectKeys[_root$getState]],oldProps[objectKeys[_root$getState]])&&sameProps.push(objectKeys[_root$getState]),is.fun(newProps[objectKeys[_root$getState]])&&/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(objectKeys[_root$getState])&&handlers.push(objectKeys[_root$getState]);const leftOvers=[];if(accumulative)for(objectKeys=Object.keys(oldProps),_root$getState=0;_root$getState<objectKeys.length;_root$getState++)newProps.hasOwnProperty(objectKeys[_root$getState])||\nleftOvers.push(objectKeys[_root$getState]);oldProps=[...sameProps,...FILTER];null!=(_instance$__r3f2=instance.__r3f)&&_instance$__r3f2.instance&&oldProps.push(\"object\");_instance$__r3f2=Object.assign({},newProps);objectKeys=Object.keys(_instance$__r3f2);for(_root$getState=0;_root$getState<objectKeys.length;_root$getState++)-1<oldProps.indexOf(objectKeys[_root$getState])&&delete _instance$__r3f2[objectKeys[_root$getState]];_instance$__r3f2=Object.entries(_instance$__r3f2);for(_root$getState=0;_root$getState<\nleftOvers.length;_root$getState++)\"children\"!==leftOvers[_root$getState]&&_instance$__r3f2.unshift([leftOvers[_root$getState],\"__defaultremove\"]);0<_instance$__r3f2.length&&(_instance$__r3f2.forEach($jscomp$destructuring$var25=>{var [key$jscomp$0,value]=$jscomp$destructuring$var25;if(!handlers.includes(key$jscomp$0)){var currentInstance=instance;$jscomp$destructuring$var25=currentInstance[key$jscomp$0];if(key$jscomp$0.includes(\"-\")){var entries=key$jscomp$0.split(\"-\");$jscomp$destructuring$var25=\nentries.reduce((acc,key)=>acc[key],instance);if(!$jscomp$destructuring$var25||!$jscomp$destructuring$var25.set){const [name,...reverseEntries]=entries.reverse();currentInstance=reverseEntries.reverse().reduce((acc,key)=>acc[key],instance);key$jscomp$0=name}}\"__defaultremove\"===value&&($jscomp$destructuring$var25&&$jscomp$destructuring$var25.constructor?value=new $jscomp$destructuring$var25.constructor(newMemoizedProps.args):currentInstance.constructor?(entries=new currentInstance.constructor(currentInstance.__r3f.memoizedProps.args),\nvalue=entries[$jscomp$destructuring$var25],entries.dispose&&entries.dispose()):value=0);$jscomp$destructuring$var25&&$jscomp$destructuring$var25.set&&($jscomp$destructuring$var25.copy||$jscomp$destructuring$var25 instanceof THREE__namespace.Layers)?Array.isArray(value)?$jscomp$destructuring$var25.fromArray?$jscomp$destructuring$var25.fromArray(value):$jscomp$destructuring$var25.set(...value):$jscomp$destructuring$var25.copy&&value&&value.constructor&&$jscomp$destructuring$var25.constructor.name===\nvalue.constructor.name?$jscomp$destructuring$var25.copy(value):void 0!==value&&(currentInstance=$jscomp$destructuring$var25 instanceof THREE__namespace.Color,!currentInstance&&$jscomp$destructuring$var25.setScalar?$jscomp$destructuring$var25.setScalar(value):$jscomp$destructuring$var25 instanceof THREE__namespace.Layers&&value instanceof THREE__namespace.Layers?$jscomp$destructuring$var25.mask=value.mask:$jscomp$destructuring$var25.set(value),!rootState.linear&&currentInstance&&$jscomp$destructuring$var25.convertSRGBToLinear()):\n(currentInstance[key$jscomp$0]=value,!rootState.linear&&currentInstance[key$jscomp$0]instanceof THREE__namespace.Texture&&(currentInstance[key$jscomp$0].encoding=THREE__namespace.sRGBEncoding));invalidateInstance(instance)}}),accumulative&&_instance$__r3f&&instance.raycast&&localState.handlers&&(localState.handlers=void 0,_instance$__r3f2=rootState.internal.interaction.indexOf(instance),-1<_instance$__r3f2&&rootState.internal.interaction.splice(_instance$__r3f2,1)),handlers.length&&(accumulative&&\n_instance$__r3f&&instance.raycast&&rootState.internal.interaction.push(instance),localState.handlers=handlers.reduce((acc,key)=>Object.assign({},acc,{[key]:newProps[key]}),{})),instance.parent&&updateInstance(instance))}function invalidateInstance(instance){var _instance$__r3f3,_instance$__r3f3$root;(instance=null==(_instance$__r3f3=instance.__r3f)?void 0:null==(_instance$__r3f3$root=_instance$__r3f3.root)?void 0:null==_instance$__r3f3$root.getState?void 0:_instance$__r3f3$root.getState())&&0===instance.internal.frames&&\ninstance.invalidate()}function updateInstance(instance){null==instance.onUpdate?void 0:instance.onUpdate(instance)}function createInstance(type,$jscomp$destructuring$var26,root,hostContext,internalInstanceHandle){hostContext=Object.assign({},$jscomp$destructuring$var26);$jscomp$destructuring$var26=void 0===$jscomp$destructuring$var26.args?[]:$jscomp$destructuring$var26.args;hostContext=(delete hostContext.args,hostContext);let name=`${type[0].toUpperCase()}${type.slice(1)}`;if((!root||!root.getState)&&\ninternalInstanceHandle){const fn=node=>node.return?fn(node.return):node.stateNode&&node.stateNode.containerInfo;root=fn(internalInstanceHandle)}if(!root||!root||!root.getState)throw`No valid root for ${name}!`;if(\"primitive\"===type){if(void 0===hostContext.object)throw\"Primitives without 'object' are invalid!\";root=prepare(hostContext.object,{root,instance:!0})}else{type=catalogue[name]||THREE__namespace[name];if(!type)throw`${name} is not part of the THREE namespace! Did you forget to extend? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively`;\ninternalInstanceHandle=is.arr($jscomp$destructuring$var26);root=prepare(internalInstanceHandle?new type(...$jscomp$destructuring$var26):new type($jscomp$destructuring$var26),{root,memoizedProps:{args:internalInstanceHandle&&0===$jscomp$destructuring$var26.length?null:$jscomp$destructuring$var26}})}\"attachFns\"in hostContext||(name.endsWith(\"Geometry\")?hostContext=Object.assign({},{attach:\"geometry\"},hostContext):name.endsWith(\"Material\")&&(hostContext=Object.assign({},{attach:\"material\"},hostContext)));\napplyProps(root,hostContext,{});return root}function appendChild(parentInstance,child){let addedAsChild=!1;if(child){if(child.attachArray)is.arr(parentInstance[child.attachArray])||(parentInstance[child.attachArray]=[]),parentInstance[child.attachArray].push(child);else if(child.attachObject)is.obj(parentInstance[child.attachObject[0]])||(parentInstance[child.attachObject[0]]={}),parentInstance[child.attachObject[0]][child.attachObject[1]]=child;else if(child.attach&&!is.fun(child.attach))parentInstance[child.attach]=\nchild;else if(is.arr(child.attachFns)){const [attachFn]=child.attachFns;if(is.str(attachFn)&&is.fun(parentInstance[attachFn]))parentInstance[attachFn](child);else is.fun(attachFn)&&attachFn(child,parentInstance)}else child.isObject3D&&(parentInstance.add(child),addedAsChild=!0);addedAsChild||(parentInstance.__r3f.objects.push(child),child.parent=parentInstance);updateInstance(child);invalidateInstance(child)}}function insertBefore(parentInstance,child,beforeChild){var added=!1;if(child){if(child.attachArray){const array=\nparentInstance[child.attachArray];is.arr(array)||(parentInstance[child.attachArray]=[]);array.splice(array.indexOf(beforeChild),0,child)}else{if(child.attachObject||child.attach&&!is.fun(child.attach))return appendChild(parentInstance,child);child.isObject3D&&(child.parent=parentInstance,child.dispatchEvent({type:\"added\"}),added=parentInstance.children.filter(sibling=>sibling!==child),beforeChild=added.indexOf(beforeChild),parentInstance.children=[...added.slice(0,beforeChild),child,...added.slice(beforeChild)],\nadded=!0)}added||(parentInstance.__r3f.objects.push(child),child.parent=parentInstance);updateInstance(child);invalidateInstance(child)}}function removeRecursive(array,parent,dispose){dispose=void 0===dispose?!1:dispose;array&&[...array].forEach(child=>removeChild(parent,child,dispose))}function removeChild(parentInstance,child,dispose){if(child){var _child$__r3f2;if(parentInstance.__r3f.objects){const oldLength=parentInstance.__r3f.objects.length;parentInstance.__r3f.objects=parentInstance.__r3f.objects.filter(x=>\nx!==child);parentInstance.__r3f.objects.length<oldLength&&(child.parent=null)}if(child.attachArray)parentInstance[child.attachArray]=parentInstance[child.attachArray].filter(x=>x!==child);else if(child.attachObject)delete parentInstance[child.attachObject[0]][child.attachObject[1]];else if(child.attach&&!is.fun(child.attach))parentInstance[child.attach]=null;else if(is.arr(child.attachFns)){var [,detachFn]=child.attachFns;if(is.str(detachFn)&&is.fun(parentInstance[detachFn]))parentInstance[detachFn](child);\nelse is.fun(detachFn)&&detachFn(child,parentInstance)}else child.isObject3D&&(parentInstance.remove(child),null!=(detachFn=child.__r3f)&&detachFn.root&&removeInteractivity(child.__r3f.root,child));detachFn=null==(_child$__r3f2=child.__r3f)?void 0:_child$__r3f2.instance;dispose=void 0===dispose?null!==child.dispose&&!detachFn:dispose;if(!detachFn){var _child$__r3f3;removeRecursive(null==(_child$__r3f3=child.__r3f)?void 0:_child$__r3f3.objects,child,dispose);removeRecursive(child.children,child,dispose)}child.__r3f&&\n(delete child.__r3f.root,delete child.__r3f.objects,delete child.__r3f.handlers,delete child.__r3f.memoizedProps,detachFn||delete child.__r3f);dispose&&child.dispose&&\"Scene\"!==child.type&&scheduler.unstable_runWithPriority(scheduler.unstable_IdlePriority,()=>child.dispose());invalidateInstance(parentInstance)}}function switchInstance(instance,type,newProps,fiber$jscomp$0){const parent=instance.parent;if(parent){var newInstance=createInstance(type,newProps,instance.__r3f.root);instance.children&&\n(instance.children.forEach(child=>appendChild(newInstance,child)),instance.children=[]);instance.__r3f.objects.forEach(child=>appendChild(newInstance,child));instance.__r3f.objects=[];removeChild(parent,instance);appendChild(parent,newInstance);[fiber$jscomp$0,fiber$jscomp$0.alternate].forEach(fiber=>{null!==fiber&&(fiber.stateNode=newInstance,fiber.ref&&(\"function\"===typeof fiber.ref?fiber.ref(newInstance):fiber.ref.current=newInstance))})}}return{reconciler:Reconciler__default[\"default\"]({now:scheduler.unstable_now,\ncreateInstance,removeChild,appendChild,appendInitialChild:appendChild,insertBefore,warnsIfNotActing:!0,supportsMutation:!0,isPrimaryRenderer:!1,scheduleTimeout:is.fun(setTimeout)?setTimeout:void 0,cancelTimeout:is.fun(clearTimeout)?clearTimeout:void 0,setTimeout:is.fun(setTimeout)?setTimeout:void 0,clearTimeout:is.fun(clearTimeout)?clearTimeout:void 0,noTimeout:-1,appendChildToContainer:(parentInstance,child)=>{const {container,root}=getContainer(parentInstance,child);container.__r3f.root=root;appendChild(container,\nchild)},removeChildFromContainer:(parentInstance,child)=>{({container:parentInstance}=getContainer(parentInstance,child));removeChild(parentInstance,child)},insertInContainerBefore:(parentInstance,child,beforeChild)=>{({container:parentInstance}=getContainer(parentInstance,child));insertBefore(parentInstance,child,beforeChild)},commitUpdate(instance,updatePayload,type,oldProps,newProps,fiber){if(instance.__r3f.instance&&newProps.object&&newProps.object!==instance)switchInstance(instance,type,newProps,\nfiber);else{var $jscomp$destructuring$var30=Object.assign({},newProps);updatePayload=void 0===newProps.args?[]:newProps.args;$jscomp$destructuring$var30=(delete $jscomp$destructuring$var30.args,$jscomp$destructuring$var30);var $jscomp$destructuring$var32=Object.assign({},oldProps);const argsOld=void 0===oldProps.args?[]:oldProps.args;oldProps=(delete $jscomp$destructuring$var32.args,$jscomp$destructuring$var32);updatePayload.some((value,index)=>is.obj(value)?Object.entries(value).some($jscomp$destructuring$var33=>\n{var [key,val]=$jscomp$destructuring$var33;return val!==argsOld[index][key]}):value!==argsOld[index])?switchInstance(instance,type,newProps,fiber):applyProps(instance,$jscomp$destructuring$var30,oldProps,!0)}},hideInstance(instance){instance.isObject3D&&(instance.visible=!1,invalidateInstance(instance))},unhideInstance(instance,props){if(instance.isObject3D&&null==props.visible||props.visible)instance.visible=!0,invalidateInstance(instance)},hideTextInstance(){throw Error(\"Text is not allowed in the R3F tree.\");\n},getPublicInstance(instance){return instance},getRootHostContext(rootContainer){return EMPTY},getChildHostContext(parentHostContext){return EMPTY},createTextInstance(){},finalizeInitialChildren(instance){return!!instance.__r3f.handlers},commitMount(instance){instance.raycast&&instance.__r3f.handlers&&instance.__r3f.root.getState().internal.interaction.push(instance)},prepareUpdate(){return EMPTY},shouldDeprioritizeSubtree(){return!1},prepareForCommit(){return null},preparePortalMount(...args){},\nresetAfterCommit(){},shouldSetTextContent(){return!1},clearContainer(){return!1}}),applyProps}}();module=reconciler.act;const REACT_PORTAL_TYPE=is.fun(Symbol)&&Symbol.for?Symbol.for(\"react.portal\"):60106;reconciler.injectIntoDevTools({bundleType:1,rendererPackageName:\"@react-three/fiber\",version:\"17.0.2\"});exports.Canvas=global;exports.ReactThreeFiber=require;exports._roots=roots$jscomp$0;exports.act=module;exports.addAfterEffect=callback=>createSubs(callback,globalAfterEffects);exports.addEffect=\ncallback=>createSubs(callback,globalEffects);exports.addTail=callback=>createSubs(callback,globalTailEffects);exports.advance=advance$jscomp$0;exports.applyProps=applyProps$jscomp$0;exports.context=context;exports.createPortal=function(children,container,implementation,key){key=void 0===key?null:key;return{$$typeof:REACT_PORTAL_TYPE,key:null==key?null:\"\"+key,children,containerInfo:prepare(container),implementation}};exports.dispose=dispose$jscomp$0;exports.events=createPointerEvents;exports.extend=\nobjects=>void(catalogue=Object.assign({},catalogue,objects));exports.invalidate=invalidate$jscomp$0;exports.reconciler=reconciler;exports.render=render;exports.unmountComponentAtNode=unmountComponentAtNode;exports.useFrame=function(callback,renderPriority){renderPriority=void 0===renderPriority?0:renderPriority;const {subscribe}=React__namespace.useContext(context).getState().internal,ref=React__namespace.useRef(callback);React__namespace.useLayoutEffect(()=>void(ref.current=callback),[callback]);\nReact__namespace.useLayoutEffect(()=>{const unsubscribe=subscribe(ref,renderPriority);return()=>unsubscribe()},[renderPriority,subscribe]);return null};exports.useGraph=function(object){return React__namespace.useMemo(()=>buildGraph(object),[object])};exports.useLoader=useLoader;exports.useThree=function(selector,equalityFn){selector=void 0===selector?state=>state:selector;const useStore=React__namespace.useContext(context);if(!useStore)throw\"R3F hooks can only be used within the Canvas component!\";\nreturn useStore(selector,equalityFn)}}","~:source","shadow$provide[\"module$node_modules$$react_three$fiber$dist$react_three_fiber_cjs_dev\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar THREE = require('three');\nvar React = require('react');\nvar create = require('zustand');\nvar shallow = require('zustand/shallow');\nvar Reconciler = require('react-reconciler');\nvar scheduler = require('scheduler');\nvar useAsset = require('use-asset');\nvar mergeRefs = require('react-merge-refs');\nvar useMeasure = require('react-use-measure');\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar create__default = /*#__PURE__*/_interopDefault(create);\nvar shallow__default = /*#__PURE__*/_interopDefault(shallow);\nvar Reconciler__default = /*#__PURE__*/_interopDefault(Reconciler);\nvar mergeRefs__default = /*#__PURE__*/_interopDefault(mergeRefs);\nvar useMeasure__default = /*#__PURE__*/_interopDefault(useMeasure);\n\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  und: a => a === void 0,\n  arr: a => Array.isArray(a),\n\n  equ(a, b) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false; // Atomic, just compare a against b\n\n    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match\n\n    if (is.arr(a) && a == b) return true; // Last resort, go through keys\n\n    let i;\n\n    for (i in a) if (!(i in b)) return false;\n\n    for (i in b) if (a[i] !== b[i]) return false;\n\n    return is.und(i) ? a === b : true;\n  }\n\n};\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index;\n}\n\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState(); // Removes every trace of an object from the data store\n\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      internal.hovered.delete(key);\n    }\n  });\n}\nfunction createEvents(store) {\n  const temp = new THREE__namespace.Vector3();\n  /** Sets up defaultRaycaster */\n\n  function prepareRay(event) {\n    var _raycaster$computeOff;\n\n    const state = store.getState();\n    const {\n      raycaster,\n      mouse,\n      camera,\n      size\n    } = state; // https://github.com/pmndrs/react-three-fiber/pull/782\n    // Events trigger outside of canvas when moved\n\n    const {\n      offsetX,\n      offsetY\n    } = (_raycaster$computeOff = raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, state)) != null ? _raycaster$computeOff : event;\n    const {\n      width,\n      height\n    } = size;\n    mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);\n    raycaster.setFromCamera(mouse, camera);\n  }\n  /** Calculates delta */\n\n\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n\n\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f$handlers;\n\n      return (_r3f$handlers = obj.__r3f.handlers) == null ? void 0 : _r3f$handlers['onPointer' + name];\n    }));\n  }\n\n  function intersect(filter) {\n    const state = store.getState();\n    const {\n      raycaster,\n      internal\n    } = state; // Skip event handling when noEvents is set\n\n    if (!raycaster.enabled) return [];\n    const seen = new Set();\n    const intersections = []; // Allow callers to eliminate event objects\n\n    const eventsObjects = filter ? filter(internal.interaction) : internal.interaction; // Intersect known handler objects and filter against duplicates\n\n    let intersects = raycaster.intersectObjects(eventsObjects, true).filter(item => {\n      const id = makeId(item);\n      if (seen.has(id)) return false;\n      seen.add(id);\n      return true;\n    }); // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order\n\n    if (raycaster.filter) intersects = raycaster.filter(intersects, state);\n\n    for (const intersect of intersects) {\n      let eventObject = intersect.object; // Bubble event up\n\n      while (eventObject) {\n        var _r3f;\n\n        const handlers = (_r3f = eventObject.__r3f) == null ? void 0 : _r3f.handlers;\n        if (handlers) intersections.push({ ...intersect,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n\n    return intersections;\n  }\n  /**  Creates filtered intersects and returns an array of positive hits */\n\n\n  function patchIntersects(intersections, event) {\n    const {\n      internal\n    } = store.getState(); // If the interaction is captured, make all capturing targets  part of the\n    // intersect.\n\n    if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n      intersections.push(...internal.capturedMap.get(event.pointerId).values());\n    }\n\n    return intersections;\n  }\n  /**  Handles intersections by forwarding them to handlers */\n\n\n  function handleIntersects(intersections, event, callback) {\n    const {\n      raycaster,\n      mouse,\n      camera,\n      internal\n    } = store.getState(); // If anything has been found, forward it to the event listeners\n\n    if (intersections.length) {\n      const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);\n      const delta = event.type === 'click' ? calculateDistance(event) : 0;\n\n      const releasePointerCapture = id => event.target.releasePointerCapture(id);\n\n      const localState = {\n        stopped: false\n      };\n\n      for (const hit of intersections) {\n        const hasPointerCapture = id => {\n          var _internal$capturedMap, _internal$capturedMap2;\n\n          return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n        };\n\n        const setPointerCapture = id => {\n          if (internal.capturedMap.has(id)) {\n            // if the pointerId was previously captured, we add the hit to the\n            // event capturedMap.\n            internal.capturedMap.get(id).set(hit.eventObject, hit);\n          } else {\n            // if the pointerId was not previously captured, we create a map\n            // containing the hitObject, and the hit. hitObject is used for\n            // faster access.\n            internal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));\n          } // Call the original event now\n          event.target.setPointerCapture(id);\n        }; // Add native event props\n\n\n        let extractEventProps = {};\n\n        for (let prop in Object.getPrototypeOf(event)) {\n          let property = event[prop]; // Only copy over atomics, leave functions alone as these should be\n          // called as event.nativeEvent.fn()\n\n          if (typeof property !== 'function') extractEventProps[prop] = property;\n        }\n\n        let raycastEvent = { ...hit,\n          ...extractEventProps,\n          spaceX: mouse.x,\n          spaceY: mouse.y,\n          intersections,\n          stopped: localState.stopped,\n          delta,\n          unprojectedPoint,\n          ray: raycaster.ray,\n          camera: camera,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation: () => {\n            // https://github.com/pmndrs/react-three-fiber/issues/596\n            // Events are not allowed to stop propagation if the pointer has been captured\n            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId); // We only authorize stopPropagation...\n\n            if ( // ...if this pointer hasn't been captured\n            !capturesForPointer || // ... or if the hit object is capturing the pointer\n            capturesForPointer.has(hit.eventObject)) {\n              raycastEvent.stopped = localState.stopped = true; // Propagation is stopped, remove all other hover records\n              // An event handler is only allowed to flush other handlers if it is hovered itself\n\n              if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                // Objects cannot flush out higher up objects that have already caught the event\n                const higher = intersections.slice(0, intersections.indexOf(hit));\n                cancelPointer([...higher, hit]);\n              }\n            }\n          },\n          // there should be a distinction between target and currentTarget\n          target: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          currentTarget: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          sourceEvent: event,\n          // deprecated\n          nativeEvent: event\n        }; // Call subscribers\n\n        callback(raycastEvent); // Event bubbling may be interrupted by stopPropagation\n\n        if (localState.stopped === true) break;\n      }\n    }\n\n    return intersections;\n  }\n\n  function cancelPointer(hits) {\n    const {\n      internal\n    } = store.getState();\n    Array.from(internal.hovered.values()).forEach(hoveredObj => {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!hits.length || !hits.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index)) {\n        const eventObject = hoveredObj.eventObject;\n        const handlers = eventObject.__r3f.handlers;\n        internal.hovered.delete(makeId(hoveredObj));\n\n        if (handlers) {\n          // Clear out intersects, they are outdated by now\n          const data = { ...hoveredObj,\n            intersections: hits || []\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    });\n  }\n\n  const handlePointer = name => {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n\n      case 'onLostPointerCapture':\n        return event => {\n          if ('pointerId' in event) {\n            // this will be a problem if one target releases the pointerId\n            // and another one is still keeping it, as the line below\n            // indifferently deletes all capturing references.\n            store.getState().internal.capturedMap.delete(event.pointerId);\n          }\n\n          cancelPointer([]);\n        };\n    } // Any other pointer goes here ...\n\n\n    return event => {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n      prepareRay(event); // Get fresh intersects\n\n      const isPointerMove = name === 'onPointerMove';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = patchIntersects(intersect(filter), event); // Take care of unhover\n\n      if (isPointerMove) cancelPointer(hits);\n      handleIntersects(hits, event, data => {\n        const eventObject = data.eventObject;\n        const handlers = eventObject.__r3f.handlers; // Check presence of handlers\n\n        if (!handlers) return;\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          } // Call mouse move\n\n\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers == null ? void 0 : handlers[name];\n\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (name !== 'onClick' && name !== 'onContextMenu' && name !== 'onDoubleClick' || internal.initialHits.includes(eventObject)) {\n              handler(data);\n              pointerMissed(event, internal.interaction.filter(object => object !== eventObject));\n            }\n          }\n        }\n      }); // Save initial coordinates on pointer-down\n\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      } // If a click yields no results, pass it back to the user as a miss\n\n\n      if ((name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick') && !hits.length) {\n        if (calculateDistance(event) <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      }\n    };\n  };\n\n  function pointerMissed(event, objects) {\n    objects.forEach(object => {\n      var _r3f$handlers2;\n\n      return (_r3f$handlers2 = object.__r3f.handlers) == null ? void 0 : _r3f$handlers2.onPointerMissed == null ? void 0 : _r3f$handlers2.onPointerMissed(event);\n    });\n  }\n\n  return {\n    handlePointer\n  };\n}\n\n// Type guard to tell a store from a portal\nconst isStore = def => def && !!def.getState;\n\nconst getContainer = (container, child) => {\n  var _container$__r3f$root, _container$__r3f;\n\n  return {\n    // If the container is not a root-store then it must be a THREE.Object3D into which part of the\n    // scene is portalled into. Now there can be two variants of this, either that object is part of\n    // the regular jsx tree, in which case it already has __r3f with a valid root attached, or it lies\n    // outside react, in which case we must take the root of the child that is about to be attached to it.\n    root: isStore(container) ? container : (_container$__r3f$root = (_container$__r3f = container.__r3f) == null ? void 0 : _container$__r3f.root) != null ? _container$__r3f$root : child.__r3f.root,\n    // The container is the eventual target into which objects are mounted, it has to be a THREE.Object3D\n    container: isStore(container) ? container.getState().scene : container\n  };\n};\n\nconst DEFAULT = '__default';\nconst EMPTY = {};\nconst FILTER = ['children', 'key', 'ref'];\nlet catalogue = {};\n\nlet extend = objects => void (catalogue = { ...catalogue,\n  ...objects\n}); // Each object in the scene carries a small LocalState descriptor\n\n\nfunction prepare(object, state) {\n  const instance = object;\n\n  if (state != null && state.instance || !instance.__r3f) {\n    instance.__r3f = {\n      root: null,\n      memoizedProps: {},\n      objects: [],\n      ...state\n    };\n  }\n\n  return object;\n}\n\nfunction createRenderer(roots) {\n  function applyProps(instance, newProps, oldProps = {}, accumulative = false) {\n    var _instance$__r3f, _root$getState, _instance$__r3f2;\n\n    // Filter equals, events and reserved props\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const sameProps = [];\n    const handlers = [];\n    const newMemoizedProps = {};\n    let i = 0;\n    Object.entries(newProps).forEach(([key, entry]) => {\n      // we don't want children, ref or key in the memoized props\n      if (FILTER.indexOf(key) === -1) {\n        newMemoizedProps[key] = entry;\n      }\n    });\n\n    if (localState.memoizedProps && localState.memoizedProps.args) {\n      newMemoizedProps.args = localState.memoizedProps.args;\n    }\n\n    if (localState.memoizedProps && localState.memoizedProps.attach) {\n      newMemoizedProps.attach = localState.memoizedProps.attach;\n    }\n\n    if (instance.__r3f) {\n      instance.__r3f.memoizedProps = newMemoizedProps;\n    }\n\n    let objectKeys = Object.keys(newProps);\n\n    for (i = 0; i < objectKeys.length; i++) {\n      if (is.equ(newProps[objectKeys[i]], oldProps[objectKeys[i]])) {\n        sameProps.push(objectKeys[i]);\n      } // Event-handlers ...\n      //   are functions, that\n      //   start with \"on\", and\n      //   contain the name \"Pointer\", \"Click\", \"DoubleClick\", \"ContextMenu\", or \"Wheel\"\n\n\n      if (is.fun(newProps[objectKeys[i]]) && /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(objectKeys[i])) {\n        handlers.push(objectKeys[i]);\n      }\n    } // Catch props that existed, but now exist no more ...\n\n\n    const leftOvers = [];\n\n    if (accumulative) {\n      objectKeys = Object.keys(oldProps);\n\n      for (i = 0; i < objectKeys.length; i++) {\n        if (!newProps.hasOwnProperty(objectKeys[i])) {\n          leftOvers.push(objectKeys[i]);\n        }\n      }\n    }\n\n    const toFilter = [...sameProps, ...FILTER]; // Instances use \"object\" as a reserved identifier\n\n    if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.instance) toFilter.push('object');\n    const filteredProps = { ...newProps\n    }; // Removes sameProps and reserved props from newProps\n\n    objectKeys = Object.keys(filteredProps);\n\n    for (i = 0; i < objectKeys.length; i++) {\n      if (toFilter.indexOf(objectKeys[i]) > -1) {\n        delete filteredProps[objectKeys[i]];\n      }\n    } // Collect all new props\n\n\n    const filteredPropsEntries = Object.entries(filteredProps); // Prepend left-overs so they can be reset or removed\n    // Left-overs must come first!\n\n    for (i = 0; i < leftOvers.length; i++) {\n      if (leftOvers[i] !== 'children') {\n        filteredPropsEntries.unshift([leftOvers[i], DEFAULT + 'remove']);\n      }\n    }\n\n    if (filteredPropsEntries.length > 0) {\n      filteredPropsEntries.forEach(([key, value]) => {\n        if (!handlers.includes(key)) {\n          let currentInstance = instance;\n          let targetProp = currentInstance[key];\n\n          if (key.includes('-')) {\n            const entries = key.split('-');\n            targetProp = entries.reduce((acc, key) => acc[key], instance); // If the target is atomic, it forces us to switch the root\n\n            if (!(targetProp && targetProp.set)) {\n              const [name, ...reverseEntries] = entries.reverse();\n              currentInstance = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\n              key = name;\n            }\n          } // https://github.com/mrdoob/three.js/issues/21209\n          // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n          // has no means to do this. Hence we curate a small collection of value-classes\n          // with their respective constructor/set arguments\n          // For removed props, try to set default values, if possible\n\n\n          if (value === DEFAULT + 'remove') {\n            if (targetProp && targetProp.constructor) {\n              // use the prop constructor to find the default it should be\n              value = new targetProp.constructor(newMemoizedProps.args);\n            } else if (currentInstance.constructor) {\n              // create a blank slate of the instance and copy the particular parameter.\n              // @ts-ignore\n              const defaultClassCall = new currentInstance.constructor(currentInstance.__r3f.memoizedProps.args);\n              value = defaultClassCall[targetProp]; // destory the instance\n\n              if (defaultClassCall.dispose) {\n                defaultClassCall.dispose();\n              }\n            } else {\n              // instance does not have constructor, just set it to 0\n              value = 0;\n            }\n          } // Special treatment for objects with support for set/copy, and layers\n\n\n          if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof THREE__namespace.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n              if (targetProp.fromArray) {\n                targetProp.fromArray(value);\n              } else {\n                targetProp.set(...value);\n              }\n            } // Test again target.copy(class) next ...\n            else if (targetProp.copy && value && value.constructor && targetProp.constructor.name === value.constructor.name) {\n                targetProp.copy(value);\n              } // If nothing else fits, just set the single value, ignore undefined\n              // https://github.com/react-spring/react-three-fiber/issues/274\n              else if (value !== undefined) {\n                  const isColor = targetProp instanceof THREE__namespace.Color; // Allow setting array scalars\n\n                  if (!isColor && targetProp.setScalar) targetProp.setScalar(value); // Layers have no copy function, we must therefore copy the mask property\n                  else if (targetProp instanceof THREE__namespace.Layers && value instanceof THREE__namespace.Layers) targetProp.mask = value.mask; // Otherwise just set ...\n                    else targetProp.set(value); // Auto-convert sRGB colors, for now ...\n                  // https://github.com/react-spring/react-three-fiber/issues/344\n\n                  if (!rootState.linear && isColor) targetProp.convertSRGBToLinear();\n                } // Else, just overwrite the value\n\n          } else {\n            currentInstance[key] = value; // Auto-convert sRGB textures, for now ...\n            // https://github.com/react-spring/react-three-fiber/issues/344\n\n            if (!rootState.linear && currentInstance[key] instanceof THREE__namespace.Texture) currentInstance[key].encoding = THREE__namespace.sRGBEncoding;\n          }\n\n          invalidateInstance(instance);\n        }\n      }); // Preemptively delete the instance from the containers interaction\n\n      if (accumulative && root && instance.raycast && localState.handlers) {\n        localState.handlers = undefined;\n        const index = rootState.internal.interaction.indexOf(instance);\n        if (index > -1) rootState.internal.interaction.splice(index, 1);\n      } // Prep interaction handlers\n\n\n      if (handlers.length) {\n        if (accumulative && root && instance.raycast) {\n          rootState.internal.interaction.push(instance);\n        } // Add handlers to the instances handler-map\n\n\n        localState.handlers = handlers.reduce((acc, key) => ({ ...acc,\n          [key]: newProps[key]\n        }), {});\n      } // Call the update lifecycle when it is being updated, but only when it is part of the scene\n\n\n      if (instance.parent) updateInstance(instance);\n    }\n  }\n\n  function invalidateInstance(instance) {\n    var _instance$__r3f3, _instance$__r3f3$root;\n\n    const state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n  }\n\n  function updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n  }\n\n  function createInstance(type, {\n    args = [],\n    ...props\n  }, root, hostContext, internalInstanceHandle) {\n    let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n    let instance; // https://github.com/facebook/react/issues/17147\n    // Portals do not give us a root, they are themselves treated as a root by the reconciler\n    // In order to figure out the actual root we have to climb through fiber internals :(\n\n    if (!isStore(root) && internalInstanceHandle) {\n      const fn = node => {\n        if (!node.return) return node.stateNode && node.stateNode.containerInfo;else return fn(node.return);\n      };\n\n      root = fn(internalInstanceHandle);\n    } // Assert that by now we have a valid root\n\n\n    if (!root || !isStore(root)) throw `No valid root for ${name}!`;\n\n    if (type === 'primitive') {\n      if (props.object === undefined) throw `Primitives without 'object' are invalid!`;\n      const object = props.object;\n      instance = prepare(object, {\n        root,\n        instance: true\n      });\n    } else {\n      const target = catalogue[name] || THREE__namespace[name];\n      if (!target) throw `${name} is not part of the THREE namespace! Did you forget to extend? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively`;\n      const isArgsArr = is.arr(args); // Instanciate new object, link it to the root\n\n      instance = prepare(isArgsArr ? new target(...args) : new target(args), {\n        root,\n        // append memoized props with args so it's not forgotten\n        memoizedProps: {\n          args: isArgsArr && args.length === 0 ? null : args\n        }\n      });\n    } // Auto-attach geometries and materials\n\n\n    if (!('attachFns' in props)) {\n      if (name.endsWith('Geometry')) {\n        props = {\n          attach: 'geometry',\n          ...props\n        };\n      } else if (name.endsWith('Material')) {\n        props = {\n          attach: 'material',\n          ...props\n        };\n      }\n    } // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n    // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n    // why it passes \"true\" here\n\n\n    applyProps(instance, props, {});\n    return instance;\n  }\n\n  function appendChild(parentInstance, child) {\n    let addedAsChild = false;\n\n    if (child) {\n      // The attach attribute implies that the object attaches itself on the parent\n      if (child.attachArray) {\n        if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];\n        parentInstance[child.attachArray].push(child);\n      } else if (child.attachObject) {\n        if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};\n        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;\n      } else if (child.attach && !is.fun(child.attach)) {\n        parentInstance[child.attach] = child;\n      } else if (is.arr(child.attachFns)) {\n        const [attachFn] = child.attachFns;\n\n        if (is.str(attachFn) && is.fun(parentInstance[attachFn])) {\n          parentInstance[attachFn](child);\n        } else if (is.fun(attachFn)) {\n          attachFn(child, parentInstance);\n        }\n      } else if (child.isObject3D) {\n        // add in the usual parent-child way\n        parentInstance.add(child);\n        addedAsChild = true;\n      }\n\n      if (!addedAsChild) {\n        // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n        // that is, anything that's a child in React but not a child in the scenegraph.\n        parentInstance.__r3f.objects.push(child);\n\n        child.parent = parentInstance;\n      }\n\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n\n  function insertBefore(parentInstance, child, beforeChild) {\n    let added = false;\n\n    if (child) {\n      if (child.attachArray) {\n        const array = parentInstance[child.attachArray];\n        if (!is.arr(array)) parentInstance[child.attachArray] = [];\n        array.splice(array.indexOf(beforeChild), 0, child);\n      } else if (child.attachObject || child.attach && !is.fun(child.attach)) {\n        // attach and attachObject don't have an order anyway, so just append\n        return appendChild(parentInstance, child);\n      } else if (child.isObject3D) {\n        child.parent = parentInstance;\n        child.dispatchEvent({\n          type: 'added'\n        });\n        const restSiblings = parentInstance.children.filter(sibling => sibling !== child);\n        const index = restSiblings.indexOf(beforeChild);\n        parentInstance.children = [...restSiblings.slice(0, index), child, ...restSiblings.slice(index)];\n        added = true;\n      }\n\n      if (!added) {\n        parentInstance.__r3f.objects.push(child);\n\n        child.parent = parentInstance;\n      }\n\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n\n  function removeRecursive(array, parent, dispose = false) {\n    if (array) [...array].forEach(child => removeChild(parent, child, dispose));\n  }\n\n  function removeChild(parentInstance, child, dispose) {\n    if (child) {\n      var _child$__r3f2;\n\n      if (parentInstance.__r3f.objects) {\n        const oldLength = parentInstance.__r3f.objects.length;\n        parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(x => x !== child);\n        const newLength = parentInstance.__r3f.objects.length; // was it in the list?\n\n        if (newLength < oldLength) {\n          // we had also set this, so we must clear it now\n          child.parent = null;\n        }\n      } // Remove attachment\n\n\n      if (child.attachArray) {\n        parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(x => x !== child);\n      } else if (child.attachObject) {\n        delete parentInstance[child.attachObject[0]][child.attachObject[1]];\n      } else if (child.attach && !is.fun(child.attach)) {\n        parentInstance[child.attach] = null;\n      } else if (is.arr(child.attachFns)) {\n        const [, detachFn] = child.attachFns;\n\n        if (is.str(detachFn) && is.fun(parentInstance[detachFn])) {\n          parentInstance[detachFn](child);\n        } else if (is.fun(detachFn)) {\n          detachFn(child, parentInstance);\n        }\n      } else if (child.isObject3D) {\n        var _child$__r3f;\n\n        parentInstance.remove(child); // Remove interactivity\n\n        if ((_child$__r3f = child.__r3f) != null && _child$__r3f.root) {\n          removeInteractivity(child.__r3f.root, child);\n        }\n      } // Allow objects to bail out of recursive dispose alltogether by passing dispose={null}\n      // Never dispose of primitives because their state may be kept outside of React!\n      // In order for an object to be able to dispose it has to have\n      //   - a dispose method,\n      //   - it cannot be an <instance object={...} />\n      //   - it cannot be a THREE.Scene, because three has broken it's own api\n      //\n      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n      // when the reconciler calls it, but then carry our own check recursively\n\n\n      const isInstance = (_child$__r3f2 = child.__r3f) == null ? void 0 : _child$__r3f2.instance;\n      const shouldDispose = dispose === undefined ? child.dispose !== null && !isInstance : dispose; // Remove nested child objects. Primitives should not have objects and children that are\n      // attached to them declaratively ...\n\n      if (!isInstance) {\n        var _child$__r3f3;\n\n        removeRecursive((_child$__r3f3 = child.__r3f) == null ? void 0 : _child$__r3f3.objects, child, shouldDispose);\n        removeRecursive(child.children, child, shouldDispose);\n      } // Remove references\n\n\n      if (child.__r3f) {\n        delete child.__r3f.root;\n        delete child.__r3f.objects;\n        delete child.__r3f.handlers;\n        delete child.__r3f.memoizedProps;\n        if (!isInstance) delete child.__r3f;\n      } // Dispose item whenever the reconciler feels like it\n\n\n      if (shouldDispose && child.dispose && child.type !== 'Scene') {\n        scheduler.unstable_runWithPriority(scheduler.unstable_IdlePriority, () => child.dispose());\n      }\n\n      invalidateInstance(parentInstance);\n    }\n  }\n\n  function switchInstance(instance, type, newProps, fiber) {\n    const parent = instance.parent;\n    if (!parent) return;\n    const newInstance = createInstance(type, newProps, instance.__r3f.root); // https://github.com/pmndrs/react-three-fiber/issues/1348\n    // When args change the instance has to be re-constructed, which then\n    // forces r3f to re-parent the children and non-scene objects\n\n    if (instance.children) {\n      instance.children.forEach(child => appendChild(newInstance, child));\n      instance.children = [];\n    }\n\n    instance.__r3f.objects.forEach(child => appendChild(newInstance, child));\n\n    instance.__r3f.objects = [];\n    removeChild(parent, instance);\n    appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node\n    // https://github.com/facebook/react/issues/14983\n    // https://github.com/facebook/react/pull/15021\n    ;\n    [fiber, fiber.alternate].forEach(fiber => {\n      if (fiber !== null) {\n        fiber.stateNode = newInstance;\n\n        if (fiber.ref) {\n          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n        }\n      }\n    });\n  }\n\n  const reconciler = Reconciler__default['default']({\n    now: scheduler.unstable_now,\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    warnsIfNotActing: true,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    // @ts-ignore\n    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    // @ts-ignore\n    setTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    // @ts-ignore\n    clearTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\n    noTimeout: -1,\n    appendChildToContainer: (parentInstance, child) => {\n      const {\n        container,\n        root\n      } = getContainer(parentInstance, child); // Link current root to the default scene\n\n      container.__r3f.root = root;\n      appendChild(container, child);\n    },\n    removeChildFromContainer: (parentInstance, child) => {\n      const {\n        container\n      } = getContainer(parentInstance, child);\n      removeChild(container, child);\n    },\n    insertInContainerBefore: (parentInstance, child, beforeChild) => {\n      const {\n        container\n      } = getContainer(parentInstance, child);\n      insertBefore(container, child, beforeChild);\n    },\n\n    commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {\n      if (instance.__r3f.instance && newProps.object && newProps.object !== instance) {\n        // <instance object={...} /> where the object reference has changed\n        switchInstance(instance, type, newProps, fiber);\n      } else {\n        // This is a data object, let's extract critical information about it\n        const {\n          args: argsNew = [],\n          ...restNew\n        } = newProps;\n        const {\n          args: argsOld = [],\n          ...restOld\n        } = oldProps; // If it has new props or arguments, then it needs to be re-instanciated\n\n        const hasNewArgs = argsNew.some((value, index) => is.obj(value) ? Object.entries(value).some(([key, val]) => val !== argsOld[index][key]) : value !== argsOld[index]);\n\n        if (hasNewArgs) {\n          // Next we create a new instance and append it again\n          switchInstance(instance, type, newProps, fiber);\n        } else {\n          // Otherwise just overwrite props\n          applyProps(instance, restNew, restOld, true);\n        }\n      }\n    },\n\n    hideInstance(instance) {\n      if (instance.isObject3D) {\n        instance.visible = false;\n        invalidateInstance(instance);\n      }\n    },\n\n    unhideInstance(instance, props) {\n      if (instance.isObject3D && props.visible == null || props.visible) {\n        instance.visible = true;\n        invalidateInstance(instance);\n      }\n    },\n\n    hideTextInstance() {\n      throw new Error('Text is not allowed in the R3F tree.');\n    },\n\n    getPublicInstance(instance) {\n      // TODO: might fix switchInstance (?)\n      return instance;\n    },\n\n    getRootHostContext(rootContainer) {\n      return EMPTY;\n    },\n\n    getChildHostContext(parentHostContext) {\n      return EMPTY;\n    },\n\n    createTextInstance() {},\n\n    finalizeInitialChildren(instance) {\n      // https://github.com/facebook/react/issues/20271\n      // Returning true will trigger commitMount\n      return !!instance.__r3f.handlers;\n    },\n\n    commitMount(instance)\n    /*, type, props*/\n    {\n      // https://github.com/facebook/react/issues/20271\n      // This will make sure events are only added once to the central container\n      if (instance.raycast && instance.__r3f.handlers) instance.__r3f.root.getState().internal.interaction.push(instance);\n    },\n\n    prepareUpdate() {\n      return EMPTY;\n    },\n\n    shouldDeprioritizeSubtree() {\n      return false;\n    },\n\n    prepareForCommit() {\n      return null;\n    },\n\n    preparePortalMount(...args) {// noop\n    },\n\n    resetAfterCommit() {// noop\n    },\n\n    shouldSetTextContent() {\n      return false;\n    },\n\n    clearContainer() {\n      return false;\n    }\n\n  });\n  return {\n    reconciler,\n    applyProps\n  };\n}\n\nconst isRenderer = def => def && !!def.render;\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst context = /*#__PURE__*/React__namespace.createContext(null);\n\nconst createStore = (applyProps, invalidate, advance, props) => {\n  const {\n    gl,\n    size,\n    shadows = false,\n    linear = false,\n    flat = false,\n    vr = false,\n    orthographic = false,\n    frameloop = 'always',\n    dpr = 1,\n    performance,\n    clock = new THREE__namespace.Clock(),\n    raycaster: raycastOptions,\n    camera: cameraOptions,\n    onPointerMissed\n  } = props; // Set shadowmap\n\n  if (shadows) {\n    gl.shadowMap.enabled = true;\n    if (typeof shadows === 'object') Object.assign(gl.shadowMap, shadows);else gl.shadowMap.type = THREE__namespace.PCFSoftShadowMap;\n  } // Set color management\n\n\n  if (!linear) {\n    if (!flat) gl.toneMapping = THREE__namespace.ACESFilmicToneMapping;\n    gl.outputEncoding = THREE__namespace.sRGBEncoding;\n  } // clock.elapsedTime is updated using advance(timestamp)\n\n\n  if (frameloop === 'never') {\n    clock.stop();\n    clock.elapsedTime = 0;\n  }\n\n  const rootState = create__default['default']((set, get) => {\n    // Create custom raycaster\n    const raycaster = new THREE__namespace.Raycaster();\n    const {\n      params,\n      ...options\n    } = raycastOptions || {};\n    applyProps(raycaster, {\n      enabled: true,\n      ...options,\n      params: { ...raycaster.params,\n        ...params\n      }\n    }, {}); // Create default camera\n\n    const isCamera = cameraOptions instanceof THREE__namespace.Camera;\n    const camera = isCamera ? cameraOptions : orthographic ? new THREE__namespace.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE__namespace.PerspectiveCamera(75, 0, 0.1, 1000);\n\n    if (!isCamera) {\n      camera.position.z = 5;\n      if (cameraOptions) applyProps(camera, cameraOptions, {}); // Always look at center by default\n\n      camera.lookAt(0, 0, 0);\n    }\n\n    function setDpr(dpr) {\n      return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], window.devicePixelRatio), dpr[1]) : dpr;\n    }\n\n    const initialDpr = setDpr(dpr);\n    const position = new THREE__namespace.Vector3();\n    const defaultTarget = new THREE__namespace.Vector3();\n\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n      const {\n        width,\n        height\n      } = size;\n      const aspect = width / height;\n      const distance = camera.getWorldPosition(position).distanceTo(target);\n\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n\n    let performanceTimeout = undefined;\n\n    const setPerformanceCurrent = current => set(state => ({\n      performance: { ...state.performance,\n        current\n      }\n    }));\n\n    return {\n      gl,\n      set,\n      get,\n      invalidate: () => invalidate(get()),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      linear,\n      flat,\n      scene: prepare(new THREE__namespace.Scene()),\n      camera,\n      controls: null,\n      raycaster,\n      clock,\n      mouse: new THREE__namespace.Vector2(),\n      vr,\n      frameloop,\n      onPointerMissed,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        ...performance,\n        regress: () => {\n          const state = get(); // Clear timeout\n\n          if (performanceTimeout) clearTimeout(performanceTimeout); // Set lower bound performance\n\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min); // Go back to upper bound performance after a while unless something regresses meanwhile\n\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0\n      },\n      viewport: {\n        initialDpr,\n        dpr: initialDpr,\n        width: 0,\n        height: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setSize: (width, height) => {\n        const size = {\n          width,\n          height\n        };\n        set(state => ({\n          size,\n          viewport: { ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => ({\n        viewport: { ...state.viewport,\n          dpr: setDpr(dpr)\n        }\n      })),\n      events: {\n        connected: false\n      },\n      internal: {\n        active: false,\n        priority: 0,\n        frames: 0,\n        lastProps: props,\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        subscribe: (ref, priority = 0) => {\n          set(({\n            internal\n          }) => ({\n            internal: { ...internal,\n              // If this subscription was given a priority, it takes rendering into its own hands\n              // For that reason we switch off automatic rendering and increase the manual flag\n              // As long as this flag is positive (there could be multiple render subscription)\n              // ..there can be no internal rendering at all\n              priority: internal.priority + (priority > 0 ? 1 : 0),\n              // Register subscriber and sort layers from lowest to highest, meaning,\n              // highest priority renders last (on top of the other frames)\n              subscribers: [...internal.subscribers, {\n                ref,\n                priority\n              }].sort((a, b) => a.priority - b.priority)\n            }\n          }));\n          return () => {\n            set(({\n              internal\n            }) => ({\n              internal: { ...internal,\n                // Decrease manual flag if this subscription had a priority\n                priority: internal.priority - (priority > 0 ? 1 : 0),\n                // Remove subscriber from list\n                subscribers: internal.subscribers.filter(s => s.ref !== ref)\n              }\n            }));\n          };\n        }\n      }\n    };\n  }); // Resize camera and renderer on changes to size and pixelratio\n\n  rootState.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      internal\n    } = rootState.getState(); // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n\n    if (!(internal.lastProps.camera instanceof THREE__namespace.Camera)) {\n      if (isOrthographicCamera(camera)) {\n        camera.left = size.width / -2;\n        camera.right = size.width / 2;\n        camera.top = size.height / 2;\n        camera.bottom = size.height / -2;\n      } else {\n        camera.aspect = size.width / size.height;\n      }\n\n      camera.updateProjectionMatrix(); // https://github.com/pmndrs/react-three-fiber/issues/178\n      // Update matrix world since the renderer is a frame late\n\n      camera.updateMatrixWorld();\n    } // Update renderer\n\n\n    gl.setPixelRatio(viewport.dpr);\n    gl.setSize(size.width, size.height);\n  }, state => [state.viewport.dpr, state.size], shallow__default['default']);\n  const state = rootState.getState(); // Update size\n\n  if (size) state.setSize(size.width, size.height); // Invalidate on any change\n\n  rootState.subscribe(state => invalidate(state)); // Return root state\n\n  return rootState;\n};\n\nfunction createSubs(callback, subs) {\n  const index = subs.length;\n  subs.push(callback);\n  return () => void subs.splice(index, 1);\n}\n\nlet i;\nlet globalEffects = [];\nlet globalAfterEffects = [];\nlet globalTailEffects = [];\nconst addEffect = callback => createSubs(callback, globalEffects);\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\nconst addTail = callback => createSubs(callback, globalTailEffects);\n\nfunction run(effects, timestamp) {\n  for (i = 0; i < effects.length; i++) effects[i](timestamp);\n}\n\nfunction render$1(timestamp, state) {\n  // Run local effects\n  let delta = state.clock.getDelta(); // In frameloop='never' mode, clock times are updated using the provided timestamp\n\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  } // Call subscribers (useFrame)\n\n\n  for (i = 0; i < state.internal.subscribers.length; i++) state.internal.subscribers[i].ref.current(state, delta); // Render content\n\n\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera); // Decrease frame count\n\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\n\nfunction createLoop(roots) {\n  let running = false;\n  let repeat;\n\n  function loop(timestamp) {\n    running = true;\n    repeat = 0; // Run effects\n\n    run(globalEffects, timestamp); // Render all roots\n\n    roots.forEach(root => {\n      const state = root.store.getState(); // If the frameloop is invalidated, do not run another frame\n\n      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0)) repeat += render$1(timestamp, state);\n    }); // Run after-effects\n\n    run(globalAfterEffects, timestamp); // Keep on looping if anything invalidates the frameloop\n\n    if (repeat > 0) return requestAnimationFrame(loop); // Tail call effects, they are called when rendering stops\n    else run(globalTailEffects, timestamp); // Flag end of operation\n\n    running = false;\n  }\n\n  function invalidate(state) {\n    if (!state) return roots.forEach(root => invalidate(root.store.getState()));\n    if (state.vr || !state.internal.active || state.frameloop === 'never') return; // Increase frames, do not go higher than 60\n\n    state.internal.frames = Math.min(60, state.internal.frames + 1); // If the render-loop isn't active, start it\n\n    if (!running) {\n      running = true;\n      requestAnimationFrame(loop);\n    }\n  }\n\n  function advance(timestamp, runGlobalEffects = true, state) {\n    if (runGlobalEffects) run(globalEffects, timestamp);\n    if (!state) roots.forEach(root => render$1(timestamp, root.store.getState()));else render$1(timestamp, state);\n    if (runGlobalEffects) run(globalAfterEffects, timestamp);\n  }\n\n  return {\n    loop,\n    invalidate,\n    advance\n  };\n}\n\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = createEvents(store);\n  const names = {\n    onClick: ['click', false],\n    onContextMenu: ['contextmenu', false],\n    onDoubleClick: ['dblclick', false],\n    onWheel: ['wheel', true],\n    onPointerDown: ['pointerdown', true],\n    onPointerUp: ['pointerup', true],\n    onPointerLeave: ['pointerleave', true],\n    onPointerMove: ['pointermove', true],\n    onPointerCancel: ['pointercancel', true],\n    onLostPointerCapture: ['lostpointercapture', true]\n  };\n  return {\n    connected: false,\n    handlers: Object.keys(names).reduce((acc, key) => ({ ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    connect: target => {\n      var _events$handlers;\n\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: { ...state.events,\n          connected: target\n        }\n      }));\n      Object.entries((_events$handlers = events == null ? void 0 : events.handlers) != null ? _events$handlers : []).forEach(([name, event]) => {\n        const [eventName, passive] = names[name];\n        target.addEventListener(eventName, event, {\n          passive\n        });\n      });\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n\n      if (events.connected) {\n        var _events$handlers2;\n\n        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event]) => {\n          if (events && events.connected instanceof HTMLElement) {\n            const [eventName] = names[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        });\n        set(state => ({\n          events: { ...state.events,\n            connected: false\n          }\n        }));\n      }\n    }\n  };\n}\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;\n\nfunction Block({\n  set\n}) {\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, []);\n  return null;\n}\n\nclass ErrorBoundary extends React__namespace.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false\n    };\n  }\n\n  componentDidCatch(error) {\n    this.props.set(error);\n  }\n\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n\n}\n\nErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n});\n\nconst Canvas = /*#__PURE__*/React__namespace.forwardRef(function Canvas({\n  children,\n  fallback,\n  tabIndex,\n  resize,\n  id,\n  style,\n  className,\n  events,\n  ...props\n}, forwardedRef) {\n  const [containerRef, size] = useMeasure__default['default']({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = React__namespace.useRef(null);\n  const [block, setBlock] = React__namespace.useState(false);\n  const [error, setError] = React__namespace.useState(false); // Suspend this component if block is a promise (2nd run)\n\n  if (block) throw block; // Throw exception outwards if anything within canvas throws\n\n  if (error) throw error; // Execute JSX in the reconciler as a layout-effect\n\n  useIsomorphicLayoutEffect(() => {\n    if (size.width > 0 && size.height > 0) {\n      render( /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {\n        set: setError\n      }, /*#__PURE__*/React__namespace.createElement(React__namespace.Suspense, {\n        fallback: /*#__PURE__*/React__namespace.createElement(Block, {\n          set: setBlock\n        })\n      }, children)), canvasRef.current, { ...props,\n        size,\n        events: events || createPointerEvents\n      });\n    }\n  }, [size, children]);\n  useIsomorphicLayoutEffect(() => {\n    const container = canvasRef.current;\n    return () => unmountComponentAtNode(container);\n  }, []);\n  return /*#__PURE__*/React__namespace.createElement(\"div\", {\n    ref: containerRef,\n    id: id,\n    className: className,\n    tabIndex: tabIndex,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      ...style\n    }\n  }, /*#__PURE__*/React__namespace.createElement(\"canvas\", {\n    ref: mergeRefs__default['default']([canvasRef, forwardedRef]),\n    style: {\n      display: 'block'\n    }\n  }, fallback));\n});\n\nfunction useThree(selector = state => state, equalityFn) {\n  const useStore = React__namespace.useContext(context);\n  if (!useStore) throw `R3F hooks can only be used within the Canvas component!`;\n  return useStore(selector, equalityFn);\n}\nfunction useFrame(callback, renderPriority = 0) {\n  const {\n    subscribe\n  } = React__namespace.useContext(context).getState().internal; // Update ref\n\n  const ref = React__namespace.useRef(callback);\n  React__namespace.useLayoutEffect(() => void (ref.current = callback), [callback]); // Subscribe/unsub\n\n  React__namespace.useLayoutEffect(() => {\n    const unsubscribe = subscribe(ref, renderPriority);\n    return () => unsubscribe();\n  }, [renderPriority, subscribe]);\n  return null;\n}\n\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {}\n  };\n\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) {\n        data.nodes[obj.name] = obj;\n      }\n\n      if (obj.material && !data.materials[obj.material.name]) {\n        data.materials[obj.material.name] = obj.material;\n      }\n    });\n  }\n\n  return data;\n}\n\nfunction useGraph(object) {\n  return React__namespace.useMemo(() => buildGraph(object), [object]);\n}\n\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto, ...input) {\n    // Construct new loader and run extensions\n    const loader = new Proto();\n    if (extensions) extensions(loader); // Go through the urls and load them\n\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (data.scene) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(`Could not load ${input}: ${error.message}`)))));\n  };\n}\n\nfunction useLoader(Proto, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = useAsset.useAsset(loadingFn(extensions, onProgress), Proto, ...keys); // Return the object/s\n\n  return Array.isArray(input) ? results : results[0];\n}\n\nuseLoader.preload = function (Proto, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return useAsset.useAsset.preload(loadingFn(extensions), Proto, ...keys);\n};\n\nuseLoader.clear = function (Proto, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return useAsset.useAsset.clear(Proto, ...keys);\n};\n\nconst roots = new Map();\nconst modes = ['legacy', 'blocking', 'concurrent'];\nconst {\n  invalidate,\n  advance\n} = createLoop(roots);\nconst {\n  reconciler,\n  applyProps\n} = createRenderer();\n\nconst createRendererInstance = (gl, canvas) => isRenderer(gl) ? gl : new THREE__namespace.WebGLRenderer({\n  powerPreference: 'high-performance',\n  canvas: canvas,\n  antialias: true,\n  alpha: true,\n  ...gl\n});\n\nfunction render(element, canvas, {\n  gl,\n  size,\n  mode = modes[1],\n  events,\n  onCreated,\n  ...props\n} = {}) {\n  var _store;\n\n  // Allow size to take on container bounds initially\n  if (!size) {\n    var _canvas$parentElement, _canvas$parentElement2, _canvas$parentElement3, _canvas$parentElement4;\n\n    size = {\n      width: (_canvas$parentElement = (_canvas$parentElement2 = canvas.parentElement) == null ? void 0 : _canvas$parentElement2.clientWidth) != null ? _canvas$parentElement : 0,\n      height: (_canvas$parentElement3 = (_canvas$parentElement4 = canvas.parentElement) == null ? void 0 : _canvas$parentElement4.clientHeight) != null ? _canvas$parentElement3 : 0\n    };\n  }\n\n  let root = roots.get(canvas);\n  let fiber = root == null ? void 0 : root.fiber;\n  let store = root == null ? void 0 : root.store;\n  let state = (_store = store) == null ? void 0 : _store.getState();\n\n  if (fiber && state) {\n    const lastProps = state.internal.lastProps; // When a root was found, see if any fundamental props must be changed or exchanged\n    // Check pixelratio\n\n    if (props.dpr !== undefined && !is.equ(lastProps.dpr, props.dpr)) state.setDpr(props.dpr); // Check size\n\n    if (!is.equ(lastProps.size, size)) state.setSize(size.width, size.height); // For some props we want to reset the entire root\n    // Changes to the color-space\n\n    const linearChanged = props.linear !== lastProps.linear;\n\n    if (linearChanged) {\n      unmountComponentAtNode(canvas);\n      fiber = undefined;\n    }\n  }\n\n  if (!fiber) {\n    // If no root has been found, make one\n    // Create gl\n    const glRenderer = createRendererInstance(gl, canvas); // Enable VR if requested\n\n    if (props.vr) {\n      glRenderer.xr.enabled = true;\n      glRenderer.setAnimationLoop(timestamp => advance(timestamp, true));\n    } // Create store\n\n\n    store = createStore(applyProps, invalidate, advance, {\n      gl: glRenderer,\n      size,\n      ...props\n    });\n    const state = store.getState(); // Create renderer\n\n    fiber = reconciler.createContainer(store, modes.indexOf(mode), false, null); // Map it\n\n    roots.set(canvas, {\n      fiber,\n      store\n    }); // Store events internally\n\n    if (events) state.set({\n      events: events(store)\n    });\n  }\n\n  if (store && fiber) {\n    reconciler.updateContainer( /*#__PURE__*/React__namespace.createElement(Provider, {\n      store: store,\n      element: element,\n      onCreated: onCreated,\n      target: canvas\n    }), fiber, null, () => undefined);\n    return store;\n  } else {\n    throw 'Error creating root!';\n  }\n}\n\nfunction Provider({\n  store,\n  element,\n  onCreated,\n  target\n}) {\n  React__namespace.useEffect(() => {\n    const state = store.getState(); // Flag the canvas active, rendering will now begin\n\n    state.set(state => ({\n      internal: { ...state.internal,\n        active: true\n      }\n    })); // Connect events\n\n    state.events.connect == null ? void 0 : state.events.connect(target); // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n\n    if (onCreated) onCreated(state);\n  }, []);\n  return /*#__PURE__*/React__namespace.createElement(context.Provider, {\n    value: store\n  }, element);\n}\n\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          var _state$gl, _state$gl$renderLists, _state$gl2;\n\n          state.events.disconnect == null ? void 0 : state.events.disconnect();\n          (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n          (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n          dispose(state);\n          roots.delete(canvas);\n          if (callback) callback(canvas);\n        }, 500);\n      }\n    });\n  }\n}\n\nfunction dispose(obj) {\n  if (obj.dispose && obj.type !== 'Scene') obj.dispose();\n\n  for (const p in obj) {\n    var _dispose, _ref;\n    (_dispose = (_ref = p).dispose) == null ? void 0 : _dispose.call(_ref);\n    delete obj[p];\n  }\n}\n\nconst act = reconciler.act;\nconst hasSymbol = is.fun(Symbol) && Symbol.for;\nconst REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\n\nfunction createPortal(children, container, implementation, key = null) {\n  return {\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children,\n    containerInfo: prepare(container),\n    implementation\n  };\n}\n\nreconciler.injectIntoDevTools({\n  bundleType: process.env.NODE_ENV === 'production' ? 0 : 1,\n  rendererPackageName: '@react-three/fiber',\n  version: '17.0.2'\n});\n\nexports.Canvas = Canvas;\nexports.ReactThreeFiber = threeTypes;\nexports._roots = roots;\nexports.act = act;\nexports.addAfterEffect = addAfterEffect;\nexports.addEffect = addEffect;\nexports.addTail = addTail;\nexports.advance = advance;\nexports.applyProps = applyProps;\nexports.context = context;\nexports.createPortal = createPortal;\nexports.dispose = dispose;\nexports.events = createPointerEvents;\nexports.extend = extend;\nexports.invalidate = invalidate;\nexports.reconciler = reconciler;\nexports.render = render;\nexports.unmountComponentAtNode = unmountComponentAtNode;\nexports.useFrame = useFrame;\nexports.useGraph = useGraph;\nexports.useLoader = useLoader;\nexports.useThree = useThree;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$zustand$index","~$module$node_modules$react$index","~$module$node_modules$react_reconciler$index","~$shadow.js","~$module$node_modules$use_asset$dist$index_cjs","~$module$node_modules$scheduler$index","~$module$node_modules$zustand$shallow","~$module$node_modules$three$build$three","~$module$node_modules$react_merge_refs$dist$index","~$module$node_modules$react_use_measure$dist$web_cjs"]],"~:properties",["^5",["addEffect","onDoubleClick","z","und","spaceX","handlePointer","canvas","warnsIfNotActing","loop","min","width","insertInContainerBefore","mouse","removeChildFromContainer","debounce","right","dpr","passive","internal","priority","top","interaction","scheduleTimeout","Canvas","cancelTimeout","currentTarget","act","noTimeout","obj","viewport","advance","params","height","onWheel","createInstance","tabIndex","args","appendChild","handlers","supportsMutation","toneMapping","disconnect","className","str","scroll","ReactThreeFiber","releasePointerCapture","factor","delta","key","parent","children","__esModule","flat","max","frames","dispose","useLoader","error","setDpr","encoding","enabled","id","hovered","camera","root","objects","stateNode","fun","_roots","materials","onPointerCancel","arr","initialHits","containerInfo","ray","useGraph","memoizedProps","onPointerUp","rendererPackageName","element","useFrame","position","onContextMenu","insertBefore","elapsedTime","style","attach","regress","value","antialias","visible","createPortal","connect","implementation","preload","enumerable","clearTimeout","linear","nativeEvent","context","__r3f","onCreated","stopPropagation","setPointerCapture","hasPointerCapture","onLostPointerCapture","distance","current","fiber","getDerivedStateFromError","invalidate","instance","applyProps","$$typeof","stopped","intersections","vr","clock","events","onClick","nodes","connected","addAfterEffect","fallback","type","overflow","render","powerPreference","gl","capturedMap","onPointerMove","state","ref","version","__proto__","setSize","controls","raycaster","target","appendChildToContainer","addTail","sourceEvent","extend","bundleType","alpha","frameloop","unmountComponentAtNode","display","subscribers","initialDpr","bottom","now","set","num","onPointerMissed","onPointerDown","appendInitialChild","setTimeout","resize","size","onPointerLeave","clear","active","performance","useThree","outputEncoding","removeChild","unprojectedPoint","aspect","subscribe","get","store","eventObject","mask","left","reconciler","lastProps","oldTime","container","initialClick","scene","getCurrentViewport","isPrimaryRenderer","spaceY"]],"~:compiled-at",1630676380070,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$react_three$fiber$dist$react_three_fiber_cjs_dev.js\",\n\"lineCount\":81,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$react_three$fiber$dist$react_three_fiber_cjs_dev\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nvar THREE = require('three');\\nvar React = require('react');\\nvar create = require('zustand');\\nvar shallow = require('zustand/shallow');\\nvar Reconciler = require('react-reconciler');\\nvar scheduler = require('scheduler');\\nvar useAsset = require('use-asset');\\nvar mergeRefs = require('react-merge-refs');\\nvar useMeasure = require('react-use-measure');\\n\\nfunction _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }\\n\\nfunction _interopNamespace(e) {\\n  if (e && e.__esModule) return e;\\n  var n = Object.create(null);\\n  if (e) {\\n    Object.keys(e).forEach(function (k) {\\n      if (k !== 'default') {\\n        var d = Object.getOwnPropertyDescriptor(e, k);\\n        Object.defineProperty(n, k, d.get ? d : {\\n          enumerable: true,\\n          get: function () {\\n            return e[k];\\n          }\\n        });\\n      }\\n    });\\n  }\\n  n['default'] = e;\\n  return Object.freeze(n);\\n}\\n\\nvar THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\\nvar create__default = /*#__PURE__*/_interopDefault(create);\\nvar shallow__default = /*#__PURE__*/_interopDefault(shallow);\\nvar Reconciler__default = /*#__PURE__*/_interopDefault(Reconciler);\\nvar mergeRefs__default = /*#__PURE__*/_interopDefault(mergeRefs);\\nvar useMeasure__default = /*#__PURE__*/_interopDefault(useMeasure);\\n\\nvar threeTypes = /*#__PURE__*/Object.freeze({\\n  __proto__: null\\n});\\n\\nconst is = {\\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\\n  fun: a => typeof a === 'function',\\n  str: a => typeof a === 'string',\\n  num: a => typeof a === 'number',\\n  und: a => a === void 0,\\n  arr: a => Array.isArray(a),\\n\\n  equ(a, b) {\\n    // Wrong type or one of the two undefined, doesn't match\\n    if (typeof a !== typeof b || !!a !== !!b) return false; // Atomic, just compare a against b\\n\\n    if (is.str(a) || is.num(a) || is.obj(a)) return a === b; // Array, shallow compare first to see if it's a match\\n\\n    if (is.arr(a) && a == b) return true; // Last resort, go through keys\\n\\n    let i;\\n\\n    for (i in a) if (!(i in b)) return false;\\n\\n    for (i in b) if (a[i] !== b[i]) return false;\\n\\n    return is.und(i) ? a === b : true;\\n  }\\n\\n};\\n\\nfunction makeId(event) {\\n  return (event.eventObject || event.object).uuid + '/' + event.index;\\n}\\n\\nfunction removeInteractivity(store, object) {\\n  const {\\n    internal\\n  } = store.getState(); // Removes every trace of an object from the data store\\n\\n  internal.interaction = internal.interaction.filter(o => o !== object);\\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\\n  internal.hovered.forEach((value, key) => {\\n    if (value.eventObject === object || value.object === object) {\\n      internal.hovered.delete(key);\\n    }\\n  });\\n}\\nfunction createEvents(store) {\\n  const temp = new THREE__namespace.Vector3();\\n  /** Sets up defaultRaycaster */\\n\\n  function prepareRay(event) {\\n    var _raycaster$computeOff;\\n\\n    const state = store.getState();\\n    const {\\n      raycaster,\\n      mouse,\\n      camera,\\n      size\\n    } = state; // https://github.com/pmndrs/react-three-fiber/pull/782\\n    // Events trigger outside of canvas when moved\\n\\n    const {\\n      offsetX,\\n      offsetY\\n    } = (_raycaster$computeOff = raycaster.computeOffsets == null ? void 0 : raycaster.computeOffsets(event, state)) != null ? _raycaster$computeOff : event;\\n    const {\\n      width,\\n      height\\n    } = size;\\n    mouse.set(offsetX / width * 2 - 1, -(offsetY / height) * 2 + 1);\\n    raycaster.setFromCamera(mouse, camera);\\n  }\\n  /** Calculates delta */\\n\\n\\n  function calculateDistance(event) {\\n    const {\\n      internal\\n    } = store.getState();\\n    const dx = event.offsetX - internal.initialClick[0];\\n    const dy = event.offsetY - internal.initialClick[1];\\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\\n  }\\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\\n\\n\\n  function filterPointerEvents(objects) {\\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\\n      var _r3f$handlers;\\n\\n      return (_r3f$handlers = obj.__r3f.handlers) == null ? void 0 : _r3f$handlers['onPointer' + name];\\n    }));\\n  }\\n\\n  function intersect(filter) {\\n    const state = store.getState();\\n    const {\\n      raycaster,\\n      internal\\n    } = state; // Skip event handling when noEvents is set\\n\\n    if (!raycaster.enabled) return [];\\n    const seen = new Set();\\n    const intersections = []; // Allow callers to eliminate event objects\\n\\n    const eventsObjects = filter ? filter(internal.interaction) : internal.interaction; // Intersect known handler objects and filter against duplicates\\n\\n    let intersects = raycaster.intersectObjects(eventsObjects, true).filter(item => {\\n      const id = makeId(item);\\n      if (seen.has(id)) return false;\\n      seen.add(id);\\n      return true;\\n    }); // https://github.com/mrdoob/three.js/issues/16031\\n    // Allow custom userland intersect sort order\\n\\n    if (raycaster.filter) intersects = raycaster.filter(intersects, state);\\n\\n    for (const intersect of intersects) {\\n      let eventObject = intersect.object; // Bubble event up\\n\\n      while (eventObject) {\\n        var _r3f;\\n\\n        const handlers = (_r3f = eventObject.__r3f) == null ? void 0 : _r3f.handlers;\\n        if (handlers) intersections.push({ ...intersect,\\n          eventObject\\n        });\\n        eventObject = eventObject.parent;\\n      }\\n    }\\n\\n    return intersections;\\n  }\\n  /**  Creates filtered intersects and returns an array of positive hits */\\n\\n\\n  function patchIntersects(intersections, event) {\\n    const {\\n      internal\\n    } = store.getState(); // If the interaction is captured, make all capturing targets  part of the\\n    // intersect.\\n\\n    if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\\n      intersections.push(...internal.capturedMap.get(event.pointerId).values());\\n    }\\n\\n    return intersections;\\n  }\\n  /**  Handles intersections by forwarding them to handlers */\\n\\n\\n  function handleIntersects(intersections, event, callback) {\\n    const {\\n      raycaster,\\n      mouse,\\n      camera,\\n      internal\\n    } = store.getState(); // If anything has been found, forward it to the event listeners\\n\\n    if (intersections.length) {\\n      const unprojectedPoint = temp.set(mouse.x, mouse.y, 0).unproject(camera);\\n      const delta = event.type === 'click' ? calculateDistance(event) : 0;\\n\\n      const releasePointerCapture = id => event.target.releasePointerCapture(id);\\n\\n      const localState = {\\n        stopped: false\\n      };\\n\\n      for (const hit of intersections) {\\n        const hasPointerCapture = id => {\\n          var _internal$capturedMap, _internal$capturedMap2;\\n\\n          return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\\n        };\\n\\n        const setPointerCapture = id => {\\n          if (internal.capturedMap.has(id)) {\\n            // if the pointerId was previously captured, we add the hit to the\\n            // event capturedMap.\\n            internal.capturedMap.get(id).set(hit.eventObject, hit);\\n          } else {\\n            // if the pointerId was not previously captured, we create a map\\n            // containing the hitObject, and the hit. hitObject is used for\\n            // faster access.\\n            internal.capturedMap.set(id, new Map([[hit.eventObject, hit]]));\\n          } // Call the original event now\\n          event.target.setPointerCapture(id);\\n        }; // Add native event props\\n\\n\\n        let extractEventProps = {};\\n\\n        for (let prop in Object.getPrototypeOf(event)) {\\n          let property = event[prop]; // Only copy over atomics, leave functions alone as these should be\\n          // called as event.nativeEvent.fn()\\n\\n          if (typeof property !== 'function') extractEventProps[prop] = property;\\n        }\\n\\n        let raycastEvent = { ...hit,\\n          ...extractEventProps,\\n          spaceX: mouse.x,\\n          spaceY: mouse.y,\\n          intersections,\\n          stopped: localState.stopped,\\n          delta,\\n          unprojectedPoint,\\n          ray: raycaster.ray,\\n          camera: camera,\\n          // Hijack stopPropagation, which just sets a flag\\n          stopPropagation: () => {\\n            // https://github.com/pmndrs/react-three-fiber/issues/596\\n            // Events are not allowed to stop propagation if the pointer has been captured\\n            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId); // We only authorize stopPropagation...\\n\\n            if ( // ...if this pointer hasn't been captured\\n            !capturesForPointer || // ... or if the hit object is capturing the pointer\\n            capturesForPointer.has(hit.eventObject)) {\\n              raycastEvent.stopped = localState.stopped = true; // Propagation is stopped, remove all other hover records\\n              // An event handler is only allowed to flush other handlers if it is hovered itself\\n\\n              if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\\n                // Objects cannot flush out higher up objects that have already caught the event\\n                const higher = intersections.slice(0, intersections.indexOf(hit));\\n                cancelPointer([...higher, hit]);\\n              }\\n            }\\n          },\\n          // there should be a distinction between target and currentTarget\\n          target: {\\n            hasPointerCapture,\\n            setPointerCapture,\\n            releasePointerCapture\\n          },\\n          currentTarget: {\\n            hasPointerCapture,\\n            setPointerCapture,\\n            releasePointerCapture\\n          },\\n          sourceEvent: event,\\n          // deprecated\\n          nativeEvent: event\\n        }; // Call subscribers\\n\\n        callback(raycastEvent); // Event bubbling may be interrupted by stopPropagation\\n\\n        if (localState.stopped === true) break;\\n      }\\n    }\\n\\n    return intersections;\\n  }\\n\\n  function cancelPointer(hits) {\\n    const {\\n      internal\\n    } = store.getState();\\n    Array.from(internal.hovered.values()).forEach(hoveredObj => {\\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\\n      // we call onPointerOut and delete the object from the hovered-elements map\\n      if (!hits.length || !hits.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index)) {\\n        const eventObject = hoveredObj.eventObject;\\n        const handlers = eventObject.__r3f.handlers;\\n        internal.hovered.delete(makeId(hoveredObj));\\n\\n        if (handlers) {\\n          // Clear out intersects, they are outdated by now\\n          const data = { ...hoveredObj,\\n            intersections: hits || []\\n          };\\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\\n        }\\n      }\\n    });\\n  }\\n\\n  const handlePointer = name => {\\n    // Deal with cancelation\\n    switch (name) {\\n      case 'onPointerLeave':\\n      case 'onPointerCancel':\\n        return () => cancelPointer([]);\\n\\n      case 'onLostPointerCapture':\\n        return event => {\\n          if ('pointerId' in event) {\\n            // this will be a problem if one target releases the pointerId\\n            // and another one is still keeping it, as the line below\\n            // indifferently deletes all capturing references.\\n            store.getState().internal.capturedMap.delete(event.pointerId);\\n          }\\n\\n          cancelPointer([]);\\n        };\\n    } // Any other pointer goes here ...\\n\\n\\n    return event => {\\n      const {\\n        onPointerMissed,\\n        internal\\n      } = store.getState();\\n      prepareRay(event); // Get fresh intersects\\n\\n      const isPointerMove = name === 'onPointerMove';\\n      const filter = isPointerMove ? filterPointerEvents : undefined;\\n      const hits = patchIntersects(intersect(filter), event); // Take care of unhover\\n\\n      if (isPointerMove) cancelPointer(hits);\\n      handleIntersects(hits, event, data => {\\n        const eventObject = data.eventObject;\\n        const handlers = eventObject.__r3f.handlers; // Check presence of handlers\\n\\n        if (!handlers) return;\\n\\n        if (isPointerMove) {\\n          // Move event ...\\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\\n            // When enter or out is present take care of hover-state\\n            const id = makeId(data);\\n            const hoveredItem = internal.hovered.get(id);\\n\\n            if (!hoveredItem) {\\n              // If the object wasn't previously hovered, book it and call its handler\\n              internal.hovered.set(id, data);\\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\\n            } else if (hoveredItem.stopped) {\\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\\n              data.stopPropagation();\\n            }\\n          } // Call mouse move\\n\\n\\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\\n        } else {\\n          // All other events ...\\n          const handler = handlers == null ? void 0 : handlers[name];\\n\\n          if (handler) {\\n            // Forward all events back to their respective handlers with the exception of click events,\\n            // which must use the initial target\\n            if (name !== 'onClick' && name !== 'onContextMenu' && name !== 'onDoubleClick' || internal.initialHits.includes(eventObject)) {\\n              handler(data);\\n              pointerMissed(event, internal.interaction.filter(object => object !== eventObject));\\n            }\\n          }\\n        }\\n      }); // Save initial coordinates on pointer-down\\n\\n      if (name === 'onPointerDown') {\\n        internal.initialClick = [event.offsetX, event.offsetY];\\n        internal.initialHits = hits.map(hit => hit.eventObject);\\n      } // If a click yields no results, pass it back to the user as a miss\\n\\n\\n      if ((name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick') && !hits.length) {\\n        if (calculateDistance(event) <= 2) {\\n          pointerMissed(event, internal.interaction);\\n          if (onPointerMissed) onPointerMissed(event);\\n        }\\n      }\\n    };\\n  };\\n\\n  function pointerMissed(event, objects) {\\n    objects.forEach(object => {\\n      var _r3f$handlers2;\\n\\n      return (_r3f$handlers2 = object.__r3f.handlers) == null ? void 0 : _r3f$handlers2.onPointerMissed == null ? void 0 : _r3f$handlers2.onPointerMissed(event);\\n    });\\n  }\\n\\n  return {\\n    handlePointer\\n  };\\n}\\n\\n// Type guard to tell a store from a portal\\nconst isStore = def => def && !!def.getState;\\n\\nconst getContainer = (container, child) => {\\n  var _container$__r3f$root, _container$__r3f;\\n\\n  return {\\n    // If the container is not a root-store then it must be a THREE.Object3D into which part of the\\n    // scene is portalled into. Now there can be two variants of this, either that object is part of\\n    // the regular jsx tree, in which case it already has __r3f with a valid root attached, or it lies\\n    // outside react, in which case we must take the root of the child that is about to be attached to it.\\n    root: isStore(container) ? container : (_container$__r3f$root = (_container$__r3f = container.__r3f) == null ? void 0 : _container$__r3f.root) != null ? _container$__r3f$root : child.__r3f.root,\\n    // The container is the eventual target into which objects are mounted, it has to be a THREE.Object3D\\n    container: isStore(container) ? container.getState().scene : container\\n  };\\n};\\n\\nconst DEFAULT = '__default';\\nconst EMPTY = {};\\nconst FILTER = ['children', 'key', 'ref'];\\nlet catalogue = {};\\n\\nlet extend = objects => void (catalogue = { ...catalogue,\\n  ...objects\\n}); // Each object in the scene carries a small LocalState descriptor\\n\\n\\nfunction prepare(object, state) {\\n  const instance = object;\\n\\n  if (state != null && state.instance || !instance.__r3f) {\\n    instance.__r3f = {\\n      root: null,\\n      memoizedProps: {},\\n      objects: [],\\n      ...state\\n    };\\n  }\\n\\n  return object;\\n}\\n\\nfunction createRenderer(roots) {\\n  function applyProps(instance, newProps, oldProps = {}, accumulative = false) {\\n    var _instance$__r3f, _root$getState, _instance$__r3f2;\\n\\n    // Filter equals, events and reserved props\\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\\n    const root = localState.root;\\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\\n    const sameProps = [];\\n    const handlers = [];\\n    const newMemoizedProps = {};\\n    let i = 0;\\n    Object.entries(newProps).forEach(([key, entry]) => {\\n      // we don't want children, ref or key in the memoized props\\n      if (FILTER.indexOf(key) === -1) {\\n        newMemoizedProps[key] = entry;\\n      }\\n    });\\n\\n    if (localState.memoizedProps && localState.memoizedProps.args) {\\n      newMemoizedProps.args = localState.memoizedProps.args;\\n    }\\n\\n    if (localState.memoizedProps && localState.memoizedProps.attach) {\\n      newMemoizedProps.attach = localState.memoizedProps.attach;\\n    }\\n\\n    if (instance.__r3f) {\\n      instance.__r3f.memoizedProps = newMemoizedProps;\\n    }\\n\\n    let objectKeys = Object.keys(newProps);\\n\\n    for (i = 0; i < objectKeys.length; i++) {\\n      if (is.equ(newProps[objectKeys[i]], oldProps[objectKeys[i]])) {\\n        sameProps.push(objectKeys[i]);\\n      } // Event-handlers ...\\n      //   are functions, that\\n      //   start with \\\"on\\\", and\\n      //   contain the name \\\"Pointer\\\", \\\"Click\\\", \\\"DoubleClick\\\", \\\"ContextMenu\\\", or \\\"Wheel\\\"\\n\\n\\n      if (is.fun(newProps[objectKeys[i]]) && /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(objectKeys[i])) {\\n        handlers.push(objectKeys[i]);\\n      }\\n    } // Catch props that existed, but now exist no more ...\\n\\n\\n    const leftOvers = [];\\n\\n    if (accumulative) {\\n      objectKeys = Object.keys(oldProps);\\n\\n      for (i = 0; i < objectKeys.length; i++) {\\n        if (!newProps.hasOwnProperty(objectKeys[i])) {\\n          leftOvers.push(objectKeys[i]);\\n        }\\n      }\\n    }\\n\\n    const toFilter = [...sameProps, ...FILTER]; // Instances use \\\"object\\\" as a reserved identifier\\n\\n    if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.instance) toFilter.push('object');\\n    const filteredProps = { ...newProps\\n    }; // Removes sameProps and reserved props from newProps\\n\\n    objectKeys = Object.keys(filteredProps);\\n\\n    for (i = 0; i < objectKeys.length; i++) {\\n      if (toFilter.indexOf(objectKeys[i]) > -1) {\\n        delete filteredProps[objectKeys[i]];\\n      }\\n    } // Collect all new props\\n\\n\\n    const filteredPropsEntries = Object.entries(filteredProps); // Prepend left-overs so they can be reset or removed\\n    // Left-overs must come first!\\n\\n    for (i = 0; i < leftOvers.length; i++) {\\n      if (leftOvers[i] !== 'children') {\\n        filteredPropsEntries.unshift([leftOvers[i], DEFAULT + 'remove']);\\n      }\\n    }\\n\\n    if (filteredPropsEntries.length > 0) {\\n      filteredPropsEntries.forEach(([key, value]) => {\\n        if (!handlers.includes(key)) {\\n          let currentInstance = instance;\\n          let targetProp = currentInstance[key];\\n\\n          if (key.includes('-')) {\\n            const entries = key.split('-');\\n            targetProp = entries.reduce((acc, key) => acc[key], instance); // If the target is atomic, it forces us to switch the root\\n\\n            if (!(targetProp && targetProp.set)) {\\n              const [name, ...reverseEntries] = entries.reverse();\\n              currentInstance = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\\n              key = name;\\n            }\\n          } // https://github.com/mrdoob/three.js/issues/21209\\n          // HMR/fast-refresh relies on the ability to cancel out props, but threejs\\n          // has no means to do this. Hence we curate a small collection of value-classes\\n          // with their respective constructor/set arguments\\n          // For removed props, try to set default values, if possible\\n\\n\\n          if (value === DEFAULT + 'remove') {\\n            if (targetProp && targetProp.constructor) {\\n              // use the prop constructor to find the default it should be\\n              value = new targetProp.constructor(newMemoizedProps.args);\\n            } else if (currentInstance.constructor) {\\n              // create a blank slate of the instance and copy the particular parameter.\\n              // @ts-ignore\\n              const defaultClassCall = new currentInstance.constructor(currentInstance.__r3f.memoizedProps.args);\\n              value = defaultClassCall[targetProp]; // destory the instance\\n\\n              if (defaultClassCall.dispose) {\\n                defaultClassCall.dispose();\\n              }\\n            } else {\\n              // instance does not have constructor, just set it to 0\\n              value = 0;\\n            }\\n          } // Special treatment for objects with support for set/copy, and layers\\n\\n\\n          if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof THREE__namespace.Layers)) {\\n            // If value is an array\\n            if (Array.isArray(value)) {\\n              if (targetProp.fromArray) {\\n                targetProp.fromArray(value);\\n              } else {\\n                targetProp.set(...value);\\n              }\\n            } // Test again target.copy(class) next ...\\n            else if (targetProp.copy && value && value.constructor && targetProp.constructor.name === value.constructor.name) {\\n                targetProp.copy(value);\\n              } // If nothing else fits, just set the single value, ignore undefined\\n              // https://github.com/react-spring/react-three-fiber/issues/274\\n              else if (value !== undefined) {\\n                  const isColor = targetProp instanceof THREE__namespace.Color; // Allow setting array scalars\\n\\n                  if (!isColor && targetProp.setScalar) targetProp.setScalar(value); // Layers have no copy function, we must therefore copy the mask property\\n                  else if (targetProp instanceof THREE__namespace.Layers && value instanceof THREE__namespace.Layers) targetProp.mask = value.mask; // Otherwise just set ...\\n                    else targetProp.set(value); // Auto-convert sRGB colors, for now ...\\n                  // https://github.com/react-spring/react-three-fiber/issues/344\\n\\n                  if (!rootState.linear && isColor) targetProp.convertSRGBToLinear();\\n                } // Else, just overwrite the value\\n\\n          } else {\\n            currentInstance[key] = value; // Auto-convert sRGB textures, for now ...\\n            // https://github.com/react-spring/react-three-fiber/issues/344\\n\\n            if (!rootState.linear && currentInstance[key] instanceof THREE__namespace.Texture) currentInstance[key].encoding = THREE__namespace.sRGBEncoding;\\n          }\\n\\n          invalidateInstance(instance);\\n        }\\n      }); // Preemptively delete the instance from the containers interaction\\n\\n      if (accumulative && root && instance.raycast && localState.handlers) {\\n        localState.handlers = undefined;\\n        const index = rootState.internal.interaction.indexOf(instance);\\n        if (index > -1) rootState.internal.interaction.splice(index, 1);\\n      } // Prep interaction handlers\\n\\n\\n      if (handlers.length) {\\n        if (accumulative && root && instance.raycast) {\\n          rootState.internal.interaction.push(instance);\\n        } // Add handlers to the instances handler-map\\n\\n\\n        localState.handlers = handlers.reduce((acc, key) => ({ ...acc,\\n          [key]: newProps[key]\\n        }), {});\\n      } // Call the update lifecycle when it is being updated, but only when it is part of the scene\\n\\n\\n      if (instance.parent) updateInstance(instance);\\n    }\\n  }\\n\\n  function invalidateInstance(instance) {\\n    var _instance$__r3f3, _instance$__r3f3$root;\\n\\n    const state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();\\n    if (state && state.internal.frames === 0) state.invalidate();\\n  }\\n\\n  function updateInstance(instance) {\\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\\n  }\\n\\n  function createInstance(type, {\\n    args = [],\\n    ...props\\n  }, root, hostContext, internalInstanceHandle) {\\n    let name = `${type[0].toUpperCase()}${type.slice(1)}`;\\n    let instance; // https://github.com/facebook/react/issues/17147\\n    // Portals do not give us a root, they are themselves treated as a root by the reconciler\\n    // In order to figure out the actual root we have to climb through fiber internals :(\\n\\n    if (!isStore(root) && internalInstanceHandle) {\\n      const fn = node => {\\n        if (!node.return) return node.stateNode && node.stateNode.containerInfo;else return fn(node.return);\\n      };\\n\\n      root = fn(internalInstanceHandle);\\n    } // Assert that by now we have a valid root\\n\\n\\n    if (!root || !isStore(root)) throw `No valid root for ${name}!`;\\n\\n    if (type === 'primitive') {\\n      if (props.object === undefined) throw `Primitives without 'object' are invalid!`;\\n      const object = props.object;\\n      instance = prepare(object, {\\n        root,\\n        instance: true\\n      });\\n    } else {\\n      const target = catalogue[name] || THREE__namespace[name];\\n      if (!target) throw `${name} is not part of the THREE namespace! Did you forget to extend? See: https://github.com/pmndrs/react-three-fiber/blob/master/markdown/api.md#using-3rd-party-objects-declaratively`;\\n      const isArgsArr = is.arr(args); // Instanciate new object, link it to the root\\n\\n      instance = prepare(isArgsArr ? new target(...args) : new target(args), {\\n        root,\\n        // append memoized props with args so it's not forgotten\\n        memoizedProps: {\\n          args: isArgsArr && args.length === 0 ? null : args\\n        }\\n      });\\n    } // Auto-attach geometries and materials\\n\\n\\n    if (!('attachFns' in props)) {\\n      if (name.endsWith('Geometry')) {\\n        props = {\\n          attach: 'geometry',\\n          ...props\\n        };\\n      } else if (name.endsWith('Material')) {\\n        props = {\\n          attach: 'material',\\n          ...props\\n        };\\n      }\\n    } // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\\n    // view yet. If the callback relies on references for instance, they won't be ready yet, this is\\n    // why it passes \\\"true\\\" here\\n\\n\\n    applyProps(instance, props, {});\\n    return instance;\\n  }\\n\\n  function appendChild(parentInstance, child) {\\n    let addedAsChild = false;\\n\\n    if (child) {\\n      // The attach attribute implies that the object attaches itself on the parent\\n      if (child.attachArray) {\\n        if (!is.arr(parentInstance[child.attachArray])) parentInstance[child.attachArray] = [];\\n        parentInstance[child.attachArray].push(child);\\n      } else if (child.attachObject) {\\n        if (!is.obj(parentInstance[child.attachObject[0]])) parentInstance[child.attachObject[0]] = {};\\n        parentInstance[child.attachObject[0]][child.attachObject[1]] = child;\\n      } else if (child.attach && !is.fun(child.attach)) {\\n        parentInstance[child.attach] = child;\\n      } else if (is.arr(child.attachFns)) {\\n        const [attachFn] = child.attachFns;\\n\\n        if (is.str(attachFn) && is.fun(parentInstance[attachFn])) {\\n          parentInstance[attachFn](child);\\n        } else if (is.fun(attachFn)) {\\n          attachFn(child, parentInstance);\\n        }\\n      } else if (child.isObject3D) {\\n        // add in the usual parent-child way\\n        parentInstance.add(child);\\n        addedAsChild = true;\\n      }\\n\\n      if (!addedAsChild) {\\n        // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\\n        // that is, anything that's a child in React but not a child in the scenegraph.\\n        parentInstance.__r3f.objects.push(child);\\n\\n        child.parent = parentInstance;\\n      }\\n\\n      updateInstance(child);\\n      invalidateInstance(child);\\n    }\\n  }\\n\\n  function insertBefore(parentInstance, child, beforeChild) {\\n    let added = false;\\n\\n    if (child) {\\n      if (child.attachArray) {\\n        const array = parentInstance[child.attachArray];\\n        if (!is.arr(array)) parentInstance[child.attachArray] = [];\\n        array.splice(array.indexOf(beforeChild), 0, child);\\n      } else if (child.attachObject || child.attach && !is.fun(child.attach)) {\\n        // attach and attachObject don't have an order anyway, so just append\\n        return appendChild(parentInstance, child);\\n      } else if (child.isObject3D) {\\n        child.parent = parentInstance;\\n        child.dispatchEvent({\\n          type: 'added'\\n        });\\n        const restSiblings = parentInstance.children.filter(sibling => sibling !== child);\\n        const index = restSiblings.indexOf(beforeChild);\\n        parentInstance.children = [...restSiblings.slice(0, index), child, ...restSiblings.slice(index)];\\n        added = true;\\n      }\\n\\n      if (!added) {\\n        parentInstance.__r3f.objects.push(child);\\n\\n        child.parent = parentInstance;\\n      }\\n\\n      updateInstance(child);\\n      invalidateInstance(child);\\n    }\\n  }\\n\\n  function removeRecursive(array, parent, dispose = false) {\\n    if (array) [...array].forEach(child => removeChild(parent, child, dispose));\\n  }\\n\\n  function removeChild(parentInstance, child, dispose) {\\n    if (child) {\\n      var _child$__r3f2;\\n\\n      if (parentInstance.__r3f.objects) {\\n        const oldLength = parentInstance.__r3f.objects.length;\\n        parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(x => x !== child);\\n        const newLength = parentInstance.__r3f.objects.length; // was it in the list?\\n\\n        if (newLength < oldLength) {\\n          // we had also set this, so we must clear it now\\n          child.parent = null;\\n        }\\n      } // Remove attachment\\n\\n\\n      if (child.attachArray) {\\n        parentInstance[child.attachArray] = parentInstance[child.attachArray].filter(x => x !== child);\\n      } else if (child.attachObject) {\\n        delete parentInstance[child.attachObject[0]][child.attachObject[1]];\\n      } else if (child.attach && !is.fun(child.attach)) {\\n        parentInstance[child.attach] = null;\\n      } else if (is.arr(child.attachFns)) {\\n        const [, detachFn] = child.attachFns;\\n\\n        if (is.str(detachFn) && is.fun(parentInstance[detachFn])) {\\n          parentInstance[detachFn](child);\\n        } else if (is.fun(detachFn)) {\\n          detachFn(child, parentInstance);\\n        }\\n      } else if (child.isObject3D) {\\n        var _child$__r3f;\\n\\n        parentInstance.remove(child); // Remove interactivity\\n\\n        if ((_child$__r3f = child.__r3f) != null && _child$__r3f.root) {\\n          removeInteractivity(child.__r3f.root, child);\\n        }\\n      } // Allow objects to bail out of recursive dispose alltogether by passing dispose={null}\\n      // Never dispose of primitives because their state may be kept outside of React!\\n      // In order for an object to be able to dispose it has to have\\n      //   - a dispose method,\\n      //   - it cannot be an <instance object={...} />\\n      //   - it cannot be a THREE.Scene, because three has broken it's own api\\n      //\\n      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\\n      // when the reconciler calls it, but then carry our own check recursively\\n\\n\\n      const isInstance = (_child$__r3f2 = child.__r3f) == null ? void 0 : _child$__r3f2.instance;\\n      const shouldDispose = dispose === undefined ? child.dispose !== null && !isInstance : dispose; // Remove nested child objects. Primitives should not have objects and children that are\\n      // attached to them declaratively ...\\n\\n      if (!isInstance) {\\n        var _child$__r3f3;\\n\\n        removeRecursive((_child$__r3f3 = child.__r3f) == null ? void 0 : _child$__r3f3.objects, child, shouldDispose);\\n        removeRecursive(child.children, child, shouldDispose);\\n      } // Remove references\\n\\n\\n      if (child.__r3f) {\\n        delete child.__r3f.root;\\n        delete child.__r3f.objects;\\n        delete child.__r3f.handlers;\\n        delete child.__r3f.memoizedProps;\\n        if (!isInstance) delete child.__r3f;\\n      } // Dispose item whenever the reconciler feels like it\\n\\n\\n      if (shouldDispose && child.dispose && child.type !== 'Scene') {\\n        scheduler.unstable_runWithPriority(scheduler.unstable_IdlePriority, () => child.dispose());\\n      }\\n\\n      invalidateInstance(parentInstance);\\n    }\\n  }\\n\\n  function switchInstance(instance, type, newProps, fiber) {\\n    const parent = instance.parent;\\n    if (!parent) return;\\n    const newInstance = createInstance(type, newProps, instance.__r3f.root); // https://github.com/pmndrs/react-three-fiber/issues/1348\\n    // When args change the instance has to be re-constructed, which then\\n    // forces r3f to re-parent the children and non-scene objects\\n\\n    if (instance.children) {\\n      instance.children.forEach(child => appendChild(newInstance, child));\\n      instance.children = [];\\n    }\\n\\n    instance.__r3f.objects.forEach(child => appendChild(newInstance, child));\\n\\n    instance.__r3f.objects = [];\\n    removeChild(parent, instance);\\n    appendChild(parent, newInstance) // This evil hack switches the react-internal fiber node\\n    // https://github.com/facebook/react/issues/14983\\n    // https://github.com/facebook/react/pull/15021\\n    ;\\n    [fiber, fiber.alternate].forEach(fiber => {\\n      if (fiber !== null) {\\n        fiber.stateNode = newInstance;\\n\\n        if (fiber.ref) {\\n          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\\n        }\\n      }\\n    });\\n  }\\n\\n  const reconciler = Reconciler__default['default']({\\n    now: scheduler.unstable_now,\\n    createInstance,\\n    removeChild,\\n    appendChild,\\n    appendInitialChild: appendChild,\\n    insertBefore,\\n    warnsIfNotActing: true,\\n    supportsMutation: true,\\n    isPrimaryRenderer: false,\\n    // @ts-ignore\\n    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\\n    // @ts-ignore\\n    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\\n    // @ts-ignore\\n    setTimeout: is.fun(setTimeout) ? setTimeout : undefined,\\n    // @ts-ignore\\n    clearTimeout: is.fun(clearTimeout) ? clearTimeout : undefined,\\n    noTimeout: -1,\\n    appendChildToContainer: (parentInstance, child) => {\\n      const {\\n        container,\\n        root\\n      } = getContainer(parentInstance, child); // Link current root to the default scene\\n\\n      container.__r3f.root = root;\\n      appendChild(container, child);\\n    },\\n    removeChildFromContainer: (parentInstance, child) => {\\n      const {\\n        container\\n      } = getContainer(parentInstance, child);\\n      removeChild(container, child);\\n    },\\n    insertInContainerBefore: (parentInstance, child, beforeChild) => {\\n      const {\\n        container\\n      } = getContainer(parentInstance, child);\\n      insertBefore(container, child, beforeChild);\\n    },\\n\\n    commitUpdate(instance, updatePayload, type, oldProps, newProps, fiber) {\\n      if (instance.__r3f.instance && newProps.object && newProps.object !== instance) {\\n        // <instance object={...} /> where the object reference has changed\\n        switchInstance(instance, type, newProps, fiber);\\n      } else {\\n        // This is a data object, let's extract critical information about it\\n        const {\\n          args: argsNew = [],\\n          ...restNew\\n        } = newProps;\\n        const {\\n          args: argsOld = [],\\n          ...restOld\\n        } = oldProps; // If it has new props or arguments, then it needs to be re-instanciated\\n\\n        const hasNewArgs = argsNew.some((value, index) => is.obj(value) ? Object.entries(value).some(([key, val]) => val !== argsOld[index][key]) : value !== argsOld[index]);\\n\\n        if (hasNewArgs) {\\n          // Next we create a new instance and append it again\\n          switchInstance(instance, type, newProps, fiber);\\n        } else {\\n          // Otherwise just overwrite props\\n          applyProps(instance, restNew, restOld, true);\\n        }\\n      }\\n    },\\n\\n    hideInstance(instance) {\\n      if (instance.isObject3D) {\\n        instance.visible = false;\\n        invalidateInstance(instance);\\n      }\\n    },\\n\\n    unhideInstance(instance, props) {\\n      if (instance.isObject3D && props.visible == null || props.visible) {\\n        instance.visible = true;\\n        invalidateInstance(instance);\\n      }\\n    },\\n\\n    hideTextInstance() {\\n      throw new Error('Text is not allowed in the R3F tree.');\\n    },\\n\\n    getPublicInstance(instance) {\\n      // TODO: might fix switchInstance (?)\\n      return instance;\\n    },\\n\\n    getRootHostContext(rootContainer) {\\n      return EMPTY;\\n    },\\n\\n    getChildHostContext(parentHostContext) {\\n      return EMPTY;\\n    },\\n\\n    createTextInstance() {},\\n\\n    finalizeInitialChildren(instance) {\\n      // https://github.com/facebook/react/issues/20271\\n      // Returning true will trigger commitMount\\n      return !!instance.__r3f.handlers;\\n    },\\n\\n    commitMount(instance)\\n    /*, type, props*/\\n    {\\n      // https://github.com/facebook/react/issues/20271\\n      // This will make sure events are only added once to the central container\\n      if (instance.raycast && instance.__r3f.handlers) instance.__r3f.root.getState().internal.interaction.push(instance);\\n    },\\n\\n    prepareUpdate() {\\n      return EMPTY;\\n    },\\n\\n    shouldDeprioritizeSubtree() {\\n      return false;\\n    },\\n\\n    prepareForCommit() {\\n      return null;\\n    },\\n\\n    preparePortalMount(...args) {// noop\\n    },\\n\\n    resetAfterCommit() {// noop\\n    },\\n\\n    shouldSetTextContent() {\\n      return false;\\n    },\\n\\n    clearContainer() {\\n      return false;\\n    }\\n\\n  });\\n  return {\\n    reconciler,\\n    applyProps\\n  };\\n}\\n\\nconst isRenderer = def => def && !!def.render;\\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\\nconst context = /*#__PURE__*/React__namespace.createContext(null);\\n\\nconst createStore = (applyProps, invalidate, advance, props) => {\\n  const {\\n    gl,\\n    size,\\n    shadows = false,\\n    linear = false,\\n    flat = false,\\n    vr = false,\\n    orthographic = false,\\n    frameloop = 'always',\\n    dpr = 1,\\n    performance,\\n    clock = new THREE__namespace.Clock(),\\n    raycaster: raycastOptions,\\n    camera: cameraOptions,\\n    onPointerMissed\\n  } = props; // Set shadowmap\\n\\n  if (shadows) {\\n    gl.shadowMap.enabled = true;\\n    if (typeof shadows === 'object') Object.assign(gl.shadowMap, shadows);else gl.shadowMap.type = THREE__namespace.PCFSoftShadowMap;\\n  } // Set color management\\n\\n\\n  if (!linear) {\\n    if (!flat) gl.toneMapping = THREE__namespace.ACESFilmicToneMapping;\\n    gl.outputEncoding = THREE__namespace.sRGBEncoding;\\n  } // clock.elapsedTime is updated using advance(timestamp)\\n\\n\\n  if (frameloop === 'never') {\\n    clock.stop();\\n    clock.elapsedTime = 0;\\n  }\\n\\n  const rootState = create__default['default']((set, get) => {\\n    // Create custom raycaster\\n    const raycaster = new THREE__namespace.Raycaster();\\n    const {\\n      params,\\n      ...options\\n    } = raycastOptions || {};\\n    applyProps(raycaster, {\\n      enabled: true,\\n      ...options,\\n      params: { ...raycaster.params,\\n        ...params\\n      }\\n    }, {}); // Create default camera\\n\\n    const isCamera = cameraOptions instanceof THREE__namespace.Camera;\\n    const camera = isCamera ? cameraOptions : orthographic ? new THREE__namespace.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE__namespace.PerspectiveCamera(75, 0, 0.1, 1000);\\n\\n    if (!isCamera) {\\n      camera.position.z = 5;\\n      if (cameraOptions) applyProps(camera, cameraOptions, {}); // Always look at center by default\\n\\n      camera.lookAt(0, 0, 0);\\n    }\\n\\n    function setDpr(dpr) {\\n      return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], window.devicePixelRatio), dpr[1]) : dpr;\\n    }\\n\\n    const initialDpr = setDpr(dpr);\\n    const position = new THREE__namespace.Vector3();\\n    const defaultTarget = new THREE__namespace.Vector3();\\n\\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\\n      const {\\n        width,\\n        height\\n      } = size;\\n      const aspect = width / height;\\n      const distance = camera.getWorldPosition(position).distanceTo(target);\\n\\n      if (isOrthographicCamera(camera)) {\\n        return {\\n          width: width / camera.zoom,\\n          height: height / camera.zoom,\\n          factor: 1,\\n          distance,\\n          aspect\\n        };\\n      } else {\\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\\n\\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\\n\\n        const w = h * (width / height);\\n        return {\\n          width: w,\\n          height: h,\\n          factor: width / w,\\n          distance,\\n          aspect\\n        };\\n      }\\n    }\\n\\n    let performanceTimeout = undefined;\\n\\n    const setPerformanceCurrent = current => set(state => ({\\n      performance: { ...state.performance,\\n        current\\n      }\\n    }));\\n\\n    return {\\n      gl,\\n      set,\\n      get,\\n      invalidate: () => invalidate(get()),\\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\\n      linear,\\n      flat,\\n      scene: prepare(new THREE__namespace.Scene()),\\n      camera,\\n      controls: null,\\n      raycaster,\\n      clock,\\n      mouse: new THREE__namespace.Vector2(),\\n      vr,\\n      frameloop,\\n      onPointerMissed,\\n      performance: {\\n        current: 1,\\n        min: 0.5,\\n        max: 1,\\n        debounce: 200,\\n        ...performance,\\n        regress: () => {\\n          const state = get(); // Clear timeout\\n\\n          if (performanceTimeout) clearTimeout(performanceTimeout); // Set lower bound performance\\n\\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min); // Go back to upper bound performance after a while unless something regresses meanwhile\\n\\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\\n        }\\n      },\\n      size: {\\n        width: 0,\\n        height: 0\\n      },\\n      viewport: {\\n        initialDpr,\\n        dpr: initialDpr,\\n        width: 0,\\n        height: 0,\\n        aspect: 0,\\n        distance: 0,\\n        factor: 0,\\n        getCurrentViewport\\n      },\\n      setSize: (width, height) => {\\n        const size = {\\n          width,\\n          height\\n        };\\n        set(state => ({\\n          size,\\n          viewport: { ...state.viewport,\\n            ...getCurrentViewport(camera, defaultTarget, size)\\n          }\\n        }));\\n      },\\n      setDpr: dpr => set(state => ({\\n        viewport: { ...state.viewport,\\n          dpr: setDpr(dpr)\\n        }\\n      })),\\n      events: {\\n        connected: false\\n      },\\n      internal: {\\n        active: false,\\n        priority: 0,\\n        frames: 0,\\n        lastProps: props,\\n        interaction: [],\\n        hovered: new Map(),\\n        subscribers: [],\\n        initialClick: [0, 0],\\n        initialHits: [],\\n        capturedMap: new Map(),\\n        subscribe: (ref, priority = 0) => {\\n          set(({\\n            internal\\n          }) => ({\\n            internal: { ...internal,\\n              // If this subscription was given a priority, it takes rendering into its own hands\\n              // For that reason we switch off automatic rendering and increase the manual flag\\n              // As long as this flag is positive (there could be multiple render subscription)\\n              // ..there can be no internal rendering at all\\n              priority: internal.priority + (priority > 0 ? 1 : 0),\\n              // Register subscriber and sort layers from lowest to highest, meaning,\\n              // highest priority renders last (on top of the other frames)\\n              subscribers: [...internal.subscribers, {\\n                ref,\\n                priority\\n              }].sort((a, b) => a.priority - b.priority)\\n            }\\n          }));\\n          return () => {\\n            set(({\\n              internal\\n            }) => ({\\n              internal: { ...internal,\\n                // Decrease manual flag if this subscription had a priority\\n                priority: internal.priority - (priority > 0 ? 1 : 0),\\n                // Remove subscriber from list\\n                subscribers: internal.subscribers.filter(s => s.ref !== ref)\\n              }\\n            }));\\n          };\\n        }\\n      }\\n    };\\n  }); // Resize camera and renderer on changes to size and pixelratio\\n\\n  rootState.subscribe(() => {\\n    const {\\n      camera,\\n      size,\\n      viewport,\\n      internal\\n    } = rootState.getState(); // https://github.com/pmndrs/react-three-fiber/issues/92\\n    // Do not mess with the camera if it belongs to the user\\n\\n    if (!(internal.lastProps.camera instanceof THREE__namespace.Camera)) {\\n      if (isOrthographicCamera(camera)) {\\n        camera.left = size.width / -2;\\n        camera.right = size.width / 2;\\n        camera.top = size.height / 2;\\n        camera.bottom = size.height / -2;\\n      } else {\\n        camera.aspect = size.width / size.height;\\n      }\\n\\n      camera.updateProjectionMatrix(); // https://github.com/pmndrs/react-three-fiber/issues/178\\n      // Update matrix world since the renderer is a frame late\\n\\n      camera.updateMatrixWorld();\\n    } // Update renderer\\n\\n\\n    gl.setPixelRatio(viewport.dpr);\\n    gl.setSize(size.width, size.height);\\n  }, state => [state.viewport.dpr, state.size], shallow__default['default']);\\n  const state = rootState.getState(); // Update size\\n\\n  if (size) state.setSize(size.width, size.height); // Invalidate on any change\\n\\n  rootState.subscribe(state => invalidate(state)); // Return root state\\n\\n  return rootState;\\n};\\n\\nfunction createSubs(callback, subs) {\\n  const index = subs.length;\\n  subs.push(callback);\\n  return () => void subs.splice(index, 1);\\n}\\n\\nlet i;\\nlet globalEffects = [];\\nlet globalAfterEffects = [];\\nlet globalTailEffects = [];\\nconst addEffect = callback => createSubs(callback, globalEffects);\\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\\nconst addTail = callback => createSubs(callback, globalTailEffects);\\n\\nfunction run(effects, timestamp) {\\n  for (i = 0; i < effects.length; i++) effects[i](timestamp);\\n}\\n\\nfunction render$1(timestamp, state) {\\n  // Run local effects\\n  let delta = state.clock.getDelta(); // In frameloop='never' mode, clock times are updated using the provided timestamp\\n\\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\\n    delta = timestamp - state.clock.elapsedTime;\\n    state.clock.oldTime = state.clock.elapsedTime;\\n    state.clock.elapsedTime = timestamp;\\n  } // Call subscribers (useFrame)\\n\\n\\n  for (i = 0; i < state.internal.subscribers.length; i++) state.internal.subscribers[i].ref.current(state, delta); // Render content\\n\\n\\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera); // Decrease frame count\\n\\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\\n}\\n\\nfunction createLoop(roots) {\\n  let running = false;\\n  let repeat;\\n\\n  function loop(timestamp) {\\n    running = true;\\n    repeat = 0; // Run effects\\n\\n    run(globalEffects, timestamp); // Render all roots\\n\\n    roots.forEach(root => {\\n      const state = root.store.getState(); // If the frameloop is invalidated, do not run another frame\\n\\n      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0)) repeat += render$1(timestamp, state);\\n    }); // Run after-effects\\n\\n    run(globalAfterEffects, timestamp); // Keep on looping if anything invalidates the frameloop\\n\\n    if (repeat > 0) return requestAnimationFrame(loop); // Tail call effects, they are called when rendering stops\\n    else run(globalTailEffects, timestamp); // Flag end of operation\\n\\n    running = false;\\n  }\\n\\n  function invalidate(state) {\\n    if (!state) return roots.forEach(root => invalidate(root.store.getState()));\\n    if (state.vr || !state.internal.active || state.frameloop === 'never') return; // Increase frames, do not go higher than 60\\n\\n    state.internal.frames = Math.min(60, state.internal.frames + 1); // If the render-loop isn't active, start it\\n\\n    if (!running) {\\n      running = true;\\n      requestAnimationFrame(loop);\\n    }\\n  }\\n\\n  function advance(timestamp, runGlobalEffects = true, state) {\\n    if (runGlobalEffects) run(globalEffects, timestamp);\\n    if (!state) roots.forEach(root => render$1(timestamp, root.store.getState()));else render$1(timestamp, state);\\n    if (runGlobalEffects) run(globalAfterEffects, timestamp);\\n  }\\n\\n  return {\\n    loop,\\n    invalidate,\\n    advance\\n  };\\n}\\n\\nfunction createPointerEvents(store) {\\n  const {\\n    handlePointer\\n  } = createEvents(store);\\n  const names = {\\n    onClick: ['click', false],\\n    onContextMenu: ['contextmenu', false],\\n    onDoubleClick: ['dblclick', false],\\n    onWheel: ['wheel', true],\\n    onPointerDown: ['pointerdown', true],\\n    onPointerUp: ['pointerup', true],\\n    onPointerLeave: ['pointerleave', true],\\n    onPointerMove: ['pointermove', true],\\n    onPointerCancel: ['pointercancel', true],\\n    onLostPointerCapture: ['lostpointercapture', true]\\n  };\\n  return {\\n    connected: false,\\n    handlers: Object.keys(names).reduce((acc, key) => ({ ...acc,\\n      [key]: handlePointer(key)\\n    }), {}),\\n    connect: target => {\\n      var _events$handlers;\\n\\n      const {\\n        set,\\n        events\\n      } = store.getState();\\n      events.disconnect == null ? void 0 : events.disconnect();\\n      set(state => ({\\n        events: { ...state.events,\\n          connected: target\\n        }\\n      }));\\n      Object.entries((_events$handlers = events == null ? void 0 : events.handlers) != null ? _events$handlers : []).forEach(([name, event]) => {\\n        const [eventName, passive] = names[name];\\n        target.addEventListener(eventName, event, {\\n          passive\\n        });\\n      });\\n    },\\n    disconnect: () => {\\n      const {\\n        set,\\n        events\\n      } = store.getState();\\n\\n      if (events.connected) {\\n        var _events$handlers2;\\n\\n        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event]) => {\\n          if (events && events.connected instanceof HTMLElement) {\\n            const [eventName] = names[name];\\n            events.connected.removeEventListener(eventName, event);\\n          }\\n        });\\n        set(state => ({\\n          events: { ...state.events,\\n            connected: false\\n          }\\n        }));\\n      }\\n    }\\n  };\\n}\\n\\n// React currently throws a warning when using useLayoutEffect on the server.\\n// To get around it, we can conditionally useEffect on the server (no-op) and\\n// useLayoutEffect in the browser.\\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;\\n\\nfunction Block({\\n  set\\n}) {\\n  useIsomorphicLayoutEffect(() => {\\n    set(new Promise(() => null));\\n    return () => set(false);\\n  }, []);\\n  return null;\\n}\\n\\nclass ErrorBoundary extends React__namespace.Component {\\n  constructor(...args) {\\n    super(...args);\\n    this.state = {\\n      error: false\\n    };\\n  }\\n\\n  componentDidCatch(error) {\\n    this.props.set(error);\\n  }\\n\\n  render() {\\n    return this.state.error ? null : this.props.children;\\n  }\\n\\n}\\n\\nErrorBoundary.getDerivedStateFromError = () => ({\\n  error: true\\n});\\n\\nconst Canvas = /*#__PURE__*/React__namespace.forwardRef(function Canvas({\\n  children,\\n  fallback,\\n  tabIndex,\\n  resize,\\n  id,\\n  style,\\n  className,\\n  events,\\n  ...props\\n}, forwardedRef) {\\n  const [containerRef, size] = useMeasure__default['default']({\\n    scroll: true,\\n    debounce: {\\n      scroll: 50,\\n      resize: 0\\n    },\\n    ...resize\\n  });\\n  const canvasRef = React__namespace.useRef(null);\\n  const [block, setBlock] = React__namespace.useState(false);\\n  const [error, setError] = React__namespace.useState(false); // Suspend this component if block is a promise (2nd run)\\n\\n  if (block) throw block; // Throw exception outwards if anything within canvas throws\\n\\n  if (error) throw error; // Execute JSX in the reconciler as a layout-effect\\n\\n  useIsomorphicLayoutEffect(() => {\\n    if (size.width > 0 && size.height > 0) {\\n      render( /*#__PURE__*/React__namespace.createElement(ErrorBoundary, {\\n        set: setError\\n      }, /*#__PURE__*/React__namespace.createElement(React__namespace.Suspense, {\\n        fallback: /*#__PURE__*/React__namespace.createElement(Block, {\\n          set: setBlock\\n        })\\n      }, children)), canvasRef.current, { ...props,\\n        size,\\n        events: events || createPointerEvents\\n      });\\n    }\\n  }, [size, children]);\\n  useIsomorphicLayoutEffect(() => {\\n    const container = canvasRef.current;\\n    return () => unmountComponentAtNode(container);\\n  }, []);\\n  return /*#__PURE__*/React__namespace.createElement(\\\"div\\\", {\\n    ref: containerRef,\\n    id: id,\\n    className: className,\\n    tabIndex: tabIndex,\\n    style: {\\n      position: 'relative',\\n      width: '100%',\\n      height: '100%',\\n      overflow: 'hidden',\\n      ...style\\n    }\\n  }, /*#__PURE__*/React__namespace.createElement(\\\"canvas\\\", {\\n    ref: mergeRefs__default['default']([canvasRef, forwardedRef]),\\n    style: {\\n      display: 'block'\\n    }\\n  }, fallback));\\n});\\n\\nfunction useThree(selector = state => state, equalityFn) {\\n  const useStore = React__namespace.useContext(context);\\n  if (!useStore) throw `R3F hooks can only be used within the Canvas component!`;\\n  return useStore(selector, equalityFn);\\n}\\nfunction useFrame(callback, renderPriority = 0) {\\n  const {\\n    subscribe\\n  } = React__namespace.useContext(context).getState().internal; // Update ref\\n\\n  const ref = React__namespace.useRef(callback);\\n  React__namespace.useLayoutEffect(() => void (ref.current = callback), [callback]); // Subscribe/unsub\\n\\n  React__namespace.useLayoutEffect(() => {\\n    const unsubscribe = subscribe(ref, renderPriority);\\n    return () => unsubscribe();\\n  }, [renderPriority, subscribe]);\\n  return null;\\n}\\n\\nfunction buildGraph(object) {\\n  const data = {\\n    nodes: {},\\n    materials: {}\\n  };\\n\\n  if (object) {\\n    object.traverse(obj => {\\n      if (obj.name) {\\n        data.nodes[obj.name] = obj;\\n      }\\n\\n      if (obj.material && !data.materials[obj.material.name]) {\\n        data.materials[obj.material.name] = obj.material;\\n      }\\n    });\\n  }\\n\\n  return data;\\n}\\n\\nfunction useGraph(object) {\\n  return React__namespace.useMemo(() => buildGraph(object), [object]);\\n}\\n\\nfunction loadingFn(extensions, onProgress) {\\n  return function (Proto, ...input) {\\n    // Construct new loader and run extensions\\n    const loader = new Proto();\\n    if (extensions) extensions(loader); // Go through the urls and load them\\n\\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\\n      if (data.scene) Object.assign(data, buildGraph(data.scene));\\n      res(data);\\n    }, onProgress, error => reject(`Could not load ${input}: ${error.message}`)))));\\n  };\\n}\\n\\nfunction useLoader(Proto, input, extensions, onProgress) {\\n  // Use suspense to load async assets\\n  const keys = Array.isArray(input) ? input : [input];\\n  const results = useAsset.useAsset(loadingFn(extensions, onProgress), Proto, ...keys); // Return the object/s\\n\\n  return Array.isArray(input) ? results : results[0];\\n}\\n\\nuseLoader.preload = function (Proto, input, extensions) {\\n  const keys = Array.isArray(input) ? input : [input];\\n  return useAsset.useAsset.preload(loadingFn(extensions), Proto, ...keys);\\n};\\n\\nuseLoader.clear = function (Proto, input) {\\n  const keys = Array.isArray(input) ? input : [input];\\n  return useAsset.useAsset.clear(Proto, ...keys);\\n};\\n\\nconst roots = new Map();\\nconst modes = ['legacy', 'blocking', 'concurrent'];\\nconst {\\n  invalidate,\\n  advance\\n} = createLoop(roots);\\nconst {\\n  reconciler,\\n  applyProps\\n} = createRenderer();\\n\\nconst createRendererInstance = (gl, canvas) => isRenderer(gl) ? gl : new THREE__namespace.WebGLRenderer({\\n  powerPreference: 'high-performance',\\n  canvas: canvas,\\n  antialias: true,\\n  alpha: true,\\n  ...gl\\n});\\n\\nfunction render(element, canvas, {\\n  gl,\\n  size,\\n  mode = modes[1],\\n  events,\\n  onCreated,\\n  ...props\\n} = {}) {\\n  var _store;\\n\\n  // Allow size to take on container bounds initially\\n  if (!size) {\\n    var _canvas$parentElement, _canvas$parentElement2, _canvas$parentElement3, _canvas$parentElement4;\\n\\n    size = {\\n      width: (_canvas$parentElement = (_canvas$parentElement2 = canvas.parentElement) == null ? void 0 : _canvas$parentElement2.clientWidth) != null ? _canvas$parentElement : 0,\\n      height: (_canvas$parentElement3 = (_canvas$parentElement4 = canvas.parentElement) == null ? void 0 : _canvas$parentElement4.clientHeight) != null ? _canvas$parentElement3 : 0\\n    };\\n  }\\n\\n  let root = roots.get(canvas);\\n  let fiber = root == null ? void 0 : root.fiber;\\n  let store = root == null ? void 0 : root.store;\\n  let state = (_store = store) == null ? void 0 : _store.getState();\\n\\n  if (fiber && state) {\\n    const lastProps = state.internal.lastProps; // When a root was found, see if any fundamental props must be changed or exchanged\\n    // Check pixelratio\\n\\n    if (props.dpr !== undefined && !is.equ(lastProps.dpr, props.dpr)) state.setDpr(props.dpr); // Check size\\n\\n    if (!is.equ(lastProps.size, size)) state.setSize(size.width, size.height); // For some props we want to reset the entire root\\n    // Changes to the color-space\\n\\n    const linearChanged = props.linear !== lastProps.linear;\\n\\n    if (linearChanged) {\\n      unmountComponentAtNode(canvas);\\n      fiber = undefined;\\n    }\\n  }\\n\\n  if (!fiber) {\\n    // If no root has been found, make one\\n    // Create gl\\n    const glRenderer = createRendererInstance(gl, canvas); // Enable VR if requested\\n\\n    if (props.vr) {\\n      glRenderer.xr.enabled = true;\\n      glRenderer.setAnimationLoop(timestamp => advance(timestamp, true));\\n    } // Create store\\n\\n\\n    store = createStore(applyProps, invalidate, advance, {\\n      gl: glRenderer,\\n      size,\\n      ...props\\n    });\\n    const state = store.getState(); // Create renderer\\n\\n    fiber = reconciler.createContainer(store, modes.indexOf(mode), false, null); // Map it\\n\\n    roots.set(canvas, {\\n      fiber,\\n      store\\n    }); // Store events internally\\n\\n    if (events) state.set({\\n      events: events(store)\\n    });\\n  }\\n\\n  if (store && fiber) {\\n    reconciler.updateContainer( /*#__PURE__*/React__namespace.createElement(Provider, {\\n      store: store,\\n      element: element,\\n      onCreated: onCreated,\\n      target: canvas\\n    }), fiber, null, () => undefined);\\n    return store;\\n  } else {\\n    throw 'Error creating root!';\\n  }\\n}\\n\\nfunction Provider({\\n  store,\\n  element,\\n  onCreated,\\n  target\\n}) {\\n  React__namespace.useEffect(() => {\\n    const state = store.getState(); // Flag the canvas active, rendering will now begin\\n\\n    state.set(state => ({\\n      internal: { ...state.internal,\\n        active: true\\n      }\\n    })); // Connect events\\n\\n    state.events.connect == null ? void 0 : state.events.connect(target); // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\\n\\n    if (onCreated) onCreated(state);\\n  }, []);\\n  return /*#__PURE__*/React__namespace.createElement(context.Provider, {\\n    value: store\\n  }, element);\\n}\\n\\nfunction unmountComponentAtNode(canvas, callback) {\\n  const root = roots.get(canvas);\\n  const fiber = root == null ? void 0 : root.fiber;\\n\\n  if (fiber) {\\n    const state = root == null ? void 0 : root.store.getState();\\n    if (state) state.internal.active = false;\\n    reconciler.updateContainer(null, fiber, null, () => {\\n      if (state) {\\n        setTimeout(() => {\\n          var _state$gl, _state$gl$renderLists, _state$gl2;\\n\\n          state.events.disconnect == null ? void 0 : state.events.disconnect();\\n          (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\\n          (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\\n          dispose(state);\\n          roots.delete(canvas);\\n          if (callback) callback(canvas);\\n        }, 500);\\n      }\\n    });\\n  }\\n}\\n\\nfunction dispose(obj) {\\n  if (obj.dispose && obj.type !== 'Scene') obj.dispose();\\n\\n  for (const p in obj) {\\n    var _dispose, _ref;\\n    (_dispose = (_ref = p).dispose) == null ? void 0 : _dispose.call(_ref);\\n    delete obj[p];\\n  }\\n}\\n\\nconst act = reconciler.act;\\nconst hasSymbol = is.fun(Symbol) && Symbol.for;\\nconst REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\\n\\nfunction createPortal(children, container, implementation, key = null) {\\n  return {\\n    $$typeof: REACT_PORTAL_TYPE,\\n    key: key == null ? null : '' + key,\\n    children,\\n    containerInfo: prepare(container),\\n    implementation\\n  };\\n}\\n\\nreconciler.injectIntoDevTools({\\n  bundleType: process.env.NODE_ENV === 'production' ? 0 : 1,\\n  rendererPackageName: '@react-three/fiber',\\n  version: '17.0.2'\\n});\\n\\nexports.Canvas = Canvas;\\nexports.ReactThreeFiber = threeTypes;\\nexports._roots = roots;\\nexports.act = act;\\nexports.addAfterEffect = addAfterEffect;\\nexports.addEffect = addEffect;\\nexports.addTail = addTail;\\nexports.advance = advance;\\nexports.applyProps = applyProps;\\nexports.context = context;\\nexports.createPortal = createPortal;\\nexports.dispose = dispose;\\nexports.events = createPointerEvents;\\nexports.extend = extend;\\nexports.invalidate = invalidate;\\nexports.reconciler = reconciler;\\nexports.render = render;\\nexports.unmountComponentAtNode = unmountComponentAtNode;\\nexports.useFrame = useFrame;\\nexports.useGraph = useGraph;\\nexports.useLoader = useLoader;\\nexports.useThree = useThree;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopDefault\",\"e\",\"__esModule\",\"_interopNamespace\",\"n\",\"Object\",\"create\",\"keys\",\"forEach\",\"k\",\"d\",\"getOwnPropertyDescriptor\",\"defineProperty\",\"get\",\"enumerable\",\"freeze\",\"makeId\",\"event\",\"uuid\",\"eventObject\",\"object\",\"index\",\"removeInteractivity\",\"store\",\"internal\",\"getState\",\"interaction\",\"filter\",\"o\",\"initialHits\",\"hovered\",\"value\",\"key\",\"delete\",\"createEvents\",\"prepareRay\",\"_raycaster$computeOff\",\"state\",\"raycaster\",\"mouse\",\"camera\",\"size\",\"offsetX\",\"offsetY\",\"computeOffsets\",\"width\",\"height\",\"set\",\"setFromCamera\",\"calculateDistance\",\"dx\",\"initialClick\",\"dy\",\"Math\",\"round\",\"sqrt\",\"filterPointerEvents\",\"objects\",\"obj\",\"some\",\"name\",\"_r3f$handlers\",\"__r3f\",\"handlers\",\"intersect\",\"enabled\",\"seen\",\"Set\",\"intersections\",\"eventsObjects\",\"intersects\",\"intersectObjects\",\"item\",\"id\",\"has\",\"add\",\"_r3f\",\"push\",\"parent\",\"patchIntersects\",\"capturedMap\",\"pointerId\",\"values\",\"handleIntersects\",\"callback\",\"length\",\"unprojectedPoint\",\"temp\",\"x\",\"y\",\"unproject\",\"delta\",\"type\",\"releasePointerCapture\",\"target\",\"hit\",\"hasPointerCapture\",\"_internal$capturedMap\",\"_internal$capturedMap2\",\"setPointerCapture\",\"Map\",\"extractEventProps\",\"prop\",\"getPrototypeOf\",\"property\",\"raycastEvent\",\"spaceX\",\"spaceY\",\"stopped\",\"ray\",\"stopPropagation\",\"capturesForPointer\",\"Array\",\"from\",\"find\",\"i\",\"higher\",\"slice\",\"indexOf\",\"cancelPointer\",\"currentTarget\",\"sourceEvent\",\"nativeEvent\",\"hits\",\"hoveredObj\",\"data\",\"onPointerOut\",\"onPointerLeave\",\"pointerMissed\",\"_r3f$handlers2\",\"onPointerMissed\",\"THREE__namespace\",\"Vector3\",\"handlePointer\",\"isPointerMove\",\"undefined\",\"onPointerOver\",\"onPointerEnter\",\"hoveredItem\",\"onPointerMove\",\"handler\",\"includes\",\"map\",\"prepare\",\"instance\",\"root\",\"memoizedProps\",\"createSubs\",\"subs\",\"splice\",\"run\",\"effects\",\"timestamp\",\"render$1\",\"clock\",\"getDelta\",\"frameloop\",\"elapsedTime\",\"oldTime\",\"subscribers\",\"ref\",\"current\",\"priority\",\"gl\",\"render\",\"scene\",\"frames\",\"max\",\"createPointerEvents\",\"names\",\"onClick\",\"onContextMenu\",\"onDoubleClick\",\"onWheel\",\"onPointerDown\",\"onPointerUp\",\"onPointerCancel\",\"onLostPointerCapture\",\"connected\",\"reduce\",\"acc\",\"connect\",\"_events$handlers\",\"events\",\"disconnect\",\"entries\",\"eventName\",\"passive\",\"addEventListener\",\"_events$handlers2\",\"HTMLElement\",\"removeEventListener\",\"Block\",\"useIsomorphicLayoutEffect\",\"Promise\",\"buildGraph\",\"nodes\",\"materials\",\"traverse\",\"material\",\"loadingFn\",\"extensions\",\"onProgress\",\"Proto\",\"input\",\"loader\",\"all\",\"res\",\"reject\",\"load\",\"assign\",\"error\",\"message\",\"useLoader\",\"isArray\",\"results\",\"useAsset\",\"element\",\"canvas\",\"mode\",\"modes\",\"onCreated\",\"_store\",\"_canvas$parentElement\",\"_canvas$parentElement2\",\"_canvas$parentElement3\",\"_canvas$parentElement4\",\"parentElement\",\"clientWidth\",\"clientHeight\",\"roots\",\"fiber\",\"lastProps\",\"props\",\"dpr\",\"is\",\"equ\",\"setDpr\",\"setSize\",\"linear\",\"unmountComponentAtNode\",\"glRenderer\",\"WebGLRenderer\",\"powerPreference\",\"antialias\",\"alpha\",\"vr\",\"xr\",\"setAnimationLoop\",\"advance\",\"createStore\",\"applyProps\",\"invalidate\",\"reconciler\",\"createContainer\",\"updateContainer\",\"React__namespace\",\"createElement\",\"Provider\",\"useEffect\",\"active\",\"context\",\"setTimeout\",\"_state$gl\",\"_state$gl$renderLists\",\"_state$gl2\",\"renderLists\",\"dispose\",\"forceContextLoss\",\"p\",\"_dispose\",\"_ref\",\"call\",\"THREE\",\"React\",\"shallow\",\"Reconciler\",\"scheduler\",\"mergeRefs\",\"useMeasure\",\"create__default\",\"shallow__default\",\"Reconciler__default\",\"mergeRefs__default\",\"useMeasure__default\",\"threeTypes\",\"__proto__\",\"a\",\"arr\",\"fun\",\"str\",\"num\",\"und\",\"b\",\"getContainer\",\"container\",\"child\",\"_container$__r3f$root\",\"_container$__r3f\",\"EMPTY\",\"FILTER\",\"catalogue\",\"createContext\",\"shadows\",\"flat\",\"orthographic\",\"performance\",\"Clock\",\"raycastOptions\",\"cameraOptions\",\"shadowMap\",\"PCFSoftShadowMap\",\"toneMapping\",\"ACESFilmicToneMapping\",\"outputEncoding\",\"sRGBEncoding\",\"stop\",\"rootState\",\"min\",\"window\",\"devicePixelRatio\",\"getCurrentViewport\",\"defaultTarget\",\"aspect\",\"distance\",\"getWorldPosition\",\"position\",\"distanceTo\",\"isOrthographicCamera\",\"zoom\",\"factor\",\"h\",\"tan\",\"fov\",\"PI\",\"w\",\"Raycaster\",\"params\",\"options\",\"isCamera\",\"Camera\",\"OrthographicCamera\",\"PerspectiveCamera\",\"z\",\"lookAt\",\"initialDpr\",\"performanceTimeout\",\"setPerformanceCurrent\",\"runGlobalEffects\",\"Scene\",\"controls\",\"Vector2\",\"debounce\",\"regress\",\"clearTimeout\",\"viewport\",\"subscribe\",\"sort\",\"s\",\"left\",\"right\",\"top\",\"bottom\",\"updateProjectionMatrix\",\"updateMatrixWorld\",\"setPixelRatio\",\"globalEffects\",\"globalAfterEffects\",\"globalTailEffects\",\"useLayoutEffect\",\"ErrorBoundary\",\"Component\",\"constructor\",\"args\",\"componentDidCatch\",\"children\",\"getDerivedStateFromError\",\"ErrorBoundary.getDerivedStateFromError\",\"Canvas\",\"forwardRef\",\"forwardedRef\",\"fallback\",\"tabIndex\",\"resize\",\"style\",\"className\",\"containerRef\",\"scroll\",\"canvasRef\",\"useRef\",\"block\",\"setBlock\",\"useState\",\"setError\",\"Suspense\",\"overflow\",\"display\",\"preload\",\"useLoader.preload\",\"clear\",\"useLoader.clear\",\"createLoop\",\"loop\",\"running\",\"repeat\",\"requestAnimationFrame\",\"createRenderer\",\"newProps\",\"oldProps\",\"accumulative\",\"_instance$__r3f\",\"_root$getState\",\"_instance$__r3f2\",\"localState\",\"sameProps\",\"newMemoizedProps\",\"entry\",\"attach\",\"objectKeys\",\"test\",\"leftOvers\",\"hasOwnProperty\",\"toFilter\",\"filteredProps\",\"filteredPropsEntries\",\"unshift\",\"currentInstance\",\"targetProp\",\"split\",\"reverseEntries\",\"reverse\",\"defaultClassCall\",\"copy\",\"Layers\",\"fromArray\",\"isColor\",\"Color\",\"setScalar\",\"mask\",\"convertSRGBToLinear\",\"Texture\",\"encoding\",\"invalidateInstance\",\"raycast\",\"updateInstance\",\"_instance$__r3f3\",\"_instance$__r3f3$root\",\"onUpdate\",\"createInstance\",\"hostContext\",\"internalInstanceHandle\",\"toUpperCase\",\"fn\",\"node\",\"return\",\"stateNode\",\"containerInfo\",\"isArgsArr\",\"endsWith\",\"appendChild\",\"parentInstance\",\"addedAsChild\",\"attachArray\",\"attachObject\",\"attachFns\",\"attachFn\",\"isObject3D\",\"insertBefore\",\"beforeChild\",\"added\",\"array\",\"dispatchEvent\",\"restSiblings\",\"sibling\",\"removeRecursive\",\"removeChild\",\"_child$__r3f2\",\"oldLength\",\"detachFn\",\"remove\",\"_child$__r3f\",\"isInstance\",\"shouldDispose\",\"_child$__r3f3\",\"unstable_runWithPriority\",\"unstable_IdlePriority\",\"switchInstance\",\"newInstance\",\"alternate\",\"now\",\"unstable_now\",\"appendInitialChild\",\"warnsIfNotActing\",\"supportsMutation\",\"isPrimaryRenderer\",\"scheduleTimeout\",\"cancelTimeout\",\"noTimeout\",\"appendChildToContainer\",\"removeChildFromContainer\",\"insertInContainerBefore\",\"commitUpdate\",\"updatePayload\",\"argsNew\",\"argsOld\",\"hasNewArgs\",\"val\",\"restNew\",\"restOld\",\"hideInstance\",\"visible\",\"unhideInstance\",\"hideTextInstance\",\"Error\",\"getPublicInstance\",\"getRootHostContext\",\"rootContainer\",\"getChildHostContext\",\"parentHostContext\",\"createTextInstance\",\"finalizeInitialChildren\",\"commitMount\",\"prepareUpdate\",\"shouldDeprioritizeSubtree\",\"prepareForCommit\",\"preparePortalMount\",\"resetAfterCommit\",\"shouldSetTextContent\",\"clearContainer\",\"act\",\"REACT_PORTAL_TYPE\",\"Symbol\",\"for\",\"injectIntoDevTools\",\"bundleType\",\"rendererPackageName\",\"version\",\"ReactThreeFiber\",\"_roots\",\"addAfterEffect\",\"addEffect\",\"addTail\",\"createPortal\",\"implementation\",\"$$typeof\",\"extend\",\"useFrame\",\"renderPriority\",\"useContext\",\"unsubscribe\",\"useGraph\",\"useMemo\",\"useThree\",\"selector\",\"equalityFn\",\"useStore\"]\n}\n"]