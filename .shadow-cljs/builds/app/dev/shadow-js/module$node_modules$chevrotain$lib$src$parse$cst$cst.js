["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/parse/cst/cst.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$parse$cst$cst=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.addNoneTerminalToCst=exports.addTerminalToCst=exports.setNodeLocationFull=exports.setNodeLocationOnlyOffset=void 0;exports.setNodeLocationOnlyOffset=function(currNodeLocation,newLocationInfo){!0===isNaN(currNodeLocation.startOffset)?(currNodeLocation.startOffset=newLocationInfo.startOffset,currNodeLocation.endOffset=newLocationInfo.endOffset):\n!0===currNodeLocation.endOffset<newLocationInfo.endOffset&&(currNodeLocation.endOffset=newLocationInfo.endOffset)};exports.setNodeLocationFull=function(currNodeLocation,newLocationInfo){!0===isNaN(currNodeLocation.startOffset)?(currNodeLocation.startOffset=newLocationInfo.startOffset,currNodeLocation.startColumn=newLocationInfo.startColumn,currNodeLocation.startLine=newLocationInfo.startLine,currNodeLocation.endOffset=newLocationInfo.endOffset,currNodeLocation.endColumn=newLocationInfo.endColumn,\ncurrNodeLocation.endLine=newLocationInfo.endLine):!0===currNodeLocation.endOffset<newLocationInfo.endOffset&&(currNodeLocation.endOffset=newLocationInfo.endOffset,currNodeLocation.endColumn=newLocationInfo.endColumn,currNodeLocation.endLine=newLocationInfo.endLine)};exports.addTerminalToCst=function(node,token,tokenTypeName){void 0===node.children[tokenTypeName]?node.children[tokenTypeName]=[token]:node.children[tokenTypeName].push(token)};exports.addNoneTerminalToCst=function(node,ruleName,ruleResult){void 0===\nnode.children[ruleName]?node.children[ruleName]=[ruleResult]:node.children[ruleName].push(ruleResult)}}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$parse$cst$cst\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addNoneTerminalToCst = exports.addTerminalToCst = exports.setNodeLocationFull = exports.setNodeLocationOnlyOffset = void 0;\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\nexports.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nexports.setNodeLocationFull = setNodeLocationFull;\nfunction addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nexports.addTerminalToCst = addTerminalToCst;\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\nexports.addNoneTerminalToCst = addNoneTerminalToCst;\n//# sourceMappingURL=cst.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["addTerminalToCst","setNodeLocationOnlyOffset","endColumn","setNodeLocationFull","endLine","__esModule","endOffset","value","startOffset","startLine","startColumn","addNoneTerminalToCst"]],"~:compiled-at",1630917515702,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$parse$cst$cst.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,oDAAA,CAAyE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAEjHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CACAH,QAAQI,CAAAA,oBAAR,CAA+BJ,OAAQK,CAAAA,gBAAvC,CAA0DL,OAAQM,CAAAA,mBAAlE,CAAwFN,OAAQO,CAAAA,yBAAhG,CAA4H,IAAK,EAyBjIP,QAAQO,CAAAA,yBAAR,CAjBAA,QAAkC,CAACC,gBAAD,CAAmBC,eAAnB,CAAoC,CAEtB,CAAA,CAA5C,GAAIC,KAAA,CAAMF,gBAAiBG,CAAAA,WAAvB,CAAJ,EAIIH,gBAAiBG,CAAAA,WACjB,CAD+BF,eAAgBE,CAAAA,WAC/C,CAAAH,gBAAiBI,CAAAA,SAAjB,CAA6BH,eAAgBG,CAAAA,SALjD;AAWoE,CAAA,CAXpE,GAWSJ,gBAAiBI,CAAAA,SAX1B,CAWsCH,eAAgBG,CAAAA,SAXtD,GAYIJ,gBAAiBI,CAAAA,SAZrB,CAYiCH,eAAgBG,CAAAA,SAZjD,CAFkE,CAgDtEZ,QAAQM,CAAAA,mBAAR,CAvBAA,QAA4B,CAACE,gBAAD,CAAmBC,eAAnB,CAAoC,CAEhB,CAAA,CAA5C,GAAIC,KAAA,CAAMF,gBAAiBG,CAAAA,WAAvB,CAAJ,EAIIH,gBAAiBG,CAAAA,WAKjB,CAL+BF,eAAgBE,CAAAA,WAK/C,CAJAH,gBAAiBK,CAAAA,WAIjB,CAJ+BJ,eAAgBI,CAAAA,WAI/C,CAHAL,gBAAiBM,CAAAA,SAGjB,CAH6BL,eAAgBK,CAAAA,SAG7C,CAFAN,gBAAiBI,CAAAA,SAEjB,CAF6BH,eAAgBG,CAAAA,SAE7C,CADAJ,gBAAiBO,CAAAA,SACjB,CAD6BN,eAAgBM,CAAAA,SAC7C;AAAAP,gBAAiBQ,CAAAA,OAAjB,CAA2BP,eAAgBO,CAAAA,OAT/C,EAeoE,CAAA,CAfpE,GAeSR,gBAAiBI,CAAAA,SAf1B,CAesCH,eAAgBG,CAAAA,SAftD,GAgBIJ,gBAAiBI,CAAAA,SAEjB,CAF6BH,eAAgBG,CAAAA,SAE7C,CADAJ,gBAAiBO,CAAAA,SACjB,CAD6BN,eAAgBM,CAAAA,SAC7C,CAAAP,gBAAiBQ,CAAAA,OAAjB,CAA2BP,eAAgBO,CAAAA,OAlB/C,CAF4D,CAgChEhB,QAAQK,CAAAA,gBAAR,CARAA,QAAyB,CAACY,IAAD,CAAOC,KAAP,CAAcC,aAAd,CAA6B,CACbC,IAAAA,EAArC,GAAIH,IAAKI,CAAAA,QAAL,CAAcF,aAAd,CAAJ,CACIF,IAAKI,CAAAA,QAAL,CAAcF,aAAd,CADJ,CACmC,CAACD,KAAD,CADnC,CAIID,IAAKI,CAAAA,QAAL,CAAcF,aAAd,CAA6BG,CAAAA,IAA7B,CAAkCJ,KAAlC,CAL8C,CAiBtDlB,QAAQI,CAAAA,oBAAR,CARAA,QAA6B,CAACa,IAAD,CAAOM,QAAP,CAAiBC,UAAjB,CAA6B,CACtBJ,IAAAA,EAAhC;AAAIH,IAAKI,CAAAA,QAAL,CAAcE,QAAd,CAAJ,CACIN,IAAKI,CAAAA,QAAL,CAAcE,QAAd,CADJ,CAC8B,CAACC,UAAD,CAD9B,CAIIP,IAAKI,CAAAA,QAAL,CAAcE,QAAd,CAAwBD,CAAAA,IAAxB,CAA6BE,UAA7B,CALkD,CArEuD;\",\n\"sources\":[\"node_modules/chevrotain/lib/src/parse/cst/cst.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$parse$cst$cst\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.addNoneTerminalToCst = exports.addTerminalToCst = exports.setNodeLocationFull = exports.setNodeLocationOnlyOffset = void 0;\\n/**\\n * This nodeLocation tracking is not efficient and should only be used\\n * when error recovery is enabled or the Token Vector contains virtual Tokens\\n * (e.g, Python Indent/Outdent)\\n * As it executes the calculation for every single terminal/nonTerminal\\n * and does not rely on the fact the token vector is **sorted**\\n */\\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\\n    // First (valid) update for this cst node\\n    if (isNaN(currNodeLocation.startOffset) === true) {\\n        // assumption1: Token location information is either NaN or a valid number\\n        // assumption2: Token location information is fully valid if it exist\\n        // (both start/end offsets exist and are numbers).\\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\\n    }\\n    // Once the startOffset has been updated with a valid number it should never receive\\n    // any farther updates as the Token vector is sorted.\\n    // We still have to check this this condition for every new possible location info\\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\\n    }\\n}\\nexports.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;\\n/**\\n * This nodeLocation tracking is not efficient and should only be used\\n * when error recovery is enabled or the Token Vector contains virtual Tokens\\n * (e.g, Python Indent/Outdent)\\n * As it executes the calculation for every single terminal/nonTerminal\\n * and does not rely on the fact the token vector is **sorted**\\n */\\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\\n    // First (valid) update for this cst node\\n    if (isNaN(currNodeLocation.startOffset) === true) {\\n        // assumption1: Token location information is either NaN or a valid number\\n        // assumption2: Token location information is fully valid if it exist\\n        // (all start/end props exist and are numbers).\\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\\n        currNodeLocation.startLine = newLocationInfo.startLine;\\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\\n        currNodeLocation.endLine = newLocationInfo.endLine;\\n    }\\n    // Once the start props has been updated with a valid number it should never receive\\n    // any farther updates as the Token vector is sorted.\\n    // We still have to check this this condition for every new possible location info\\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\\n        currNodeLocation.endLine = newLocationInfo.endLine;\\n    }\\n}\\nexports.setNodeLocationFull = setNodeLocationFull;\\nfunction addTerminalToCst(node, token, tokenTypeName) {\\n    if (node.children[tokenTypeName] === undefined) {\\n        node.children[tokenTypeName] = [token];\\n    }\\n    else {\\n        node.children[tokenTypeName].push(token);\\n    }\\n}\\nexports.addTerminalToCst = addTerminalToCst;\\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\\n    if (node.children[ruleName] === undefined) {\\n        node.children[ruleName] = [ruleResult];\\n    }\\n    else {\\n        node.children[ruleName].push(ruleResult);\\n    }\\n}\\nexports.addNoneTerminalToCst = addNoneTerminalToCst;\\n//# sourceMappingURL=cst.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"addNoneTerminalToCst\",\"addTerminalToCst\",\"setNodeLocationFull\",\"setNodeLocationOnlyOffset\",\"currNodeLocation\",\"newLocationInfo\",\"isNaN\",\"startOffset\",\"endOffset\",\"startColumn\",\"startLine\",\"endColumn\",\"endLine\",\"node\",\"token\",\"tokenTypeName\",\"undefined\",\"children\",\"push\",\"ruleName\",\"ruleResult\"]\n}\n"]