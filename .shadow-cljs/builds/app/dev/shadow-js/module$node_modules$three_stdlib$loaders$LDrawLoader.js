["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/LDrawLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$LDrawLoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||\nObject.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,\np){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,\nprotoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function smoothNormals(triangles,lineSegments){function hashVertex(v){var y=~~(100*v.y),z=~~(100*v.z);return\"\".concat(~~(100*v.x),\",\").concat(y,\",\").concat(z)}function hashEdge(v0,v1){return\"\".concat(hashVertex(v0),\"_\").concat(hashVertex(v1))}for(var hardEdges=new Set,halfEdgeList={},fullHalfEdgeList={},normals=[],i=0,l=lineSegments.length;i<\nl;i++){var ls=lineSegments[i],v0$jscomp$0=ls.v0;ls=ls.v1;hardEdges.add(hashEdge(v0$jscomp$0,ls));hardEdges.add(hashEdge(ls,v0$jscomp$0))}lineSegments=0;for(i=triangles.length;lineSegments<i;lineSegments++)for(l=triangles[lineSegments],v0$jscomp$0=0;3>v0$jscomp$0;v0$jscomp$0++){var next=(v0$jscomp$0+1)%3;ls=l[\"v\".concat(v0$jscomp$0)];next=l[\"v\".concat(next)];ls=hashEdge(ls,next);hardEdges.has(ls)||(halfEdgeList[ls]=l,fullHalfEdgeList[ls]=l)}for(;;){hardEdges=Object.keys(halfEdgeList);if(0===hardEdges.length)break;\ntriangles=0;for(hardEdges=[fullHalfEdgeList[hardEdges[0]]];triangles<hardEdges.length;)for(lineSegments=hardEdges[triangles],triangles++,i=lineSegments.faceNormal,null===lineSegments.n0&&(lineSegments.n0=i.clone(),normals.push(lineSegments.n0)),null===lineSegments.n1&&(lineSegments.n1=i.clone(),normals.push(lineSegments.n1)),null===lineSegments.n2&&(lineSegments.n2=i.clone(),normals.push(lineSegments.n2)),i=0;3>i;i++){l=i;v0$jscomp$0=(i+1)%3;ls=lineSegments[\"v\".concat(l)];next=lineSegments[\"v\".concat(v0$jscomp$0)];\nvar _hash=hashEdge(ls,next);delete halfEdgeList[_hash];var reverseHash=hashEdge(next,ls);if((ls=fullHalfEdgeList[reverseHash])&&!(.25>Math.abs(ls.faceNormal.dot(lineSegments.faceNormal)))){reverseHash in halfEdgeList&&(hardEdges.push(ls),delete halfEdgeList[reverseHash]);for(var i3=0;3>i3;i3++){_hash=i3;next=(i3+1)%3;var otherV0=ls[\"v\".concat(_hash)],otherV1=ls[\"v\".concat(next)];if(hashEdge(otherV0,otherV1)===reverseHash){null===ls[\"n\".concat(_hash)]&&(v0$jscomp$0=lineSegments[\"n\".concat(v0$jscomp$0)],\nls[\"n\".concat(_hash)]=v0$jscomp$0,v0$jscomp$0.add(ls.faceNormal));null===ls[\"n\".concat(next)]&&(l=lineSegments[\"n\".concat(l)],ls[\"n\".concat(next)]=l,l.add(ls.faceNormal));break}}}}}halfEdgeList=0;for(fullHalfEdgeList=normals.length;halfEdgeList<fullHalfEdgeList;halfEdgeList++)normals[halfEdgeList].normalize()}function isPrimitiveType(type){return/primitive/i.test(type)||\"Subpart\"===type}function sortByMaterial(a,b){return a.colourCode===b.colourCode?0:a.colourCode<b.colourCode?-1:1}function createObject(elements,\nelementSize,isConditionalSegments){elements.sort(sortByMaterial);for(var positions=[],normals=[],materials=[],bufferGeometry=new _three.BufferGeometry,prevMaterial=null,index0=0,numGroupVerts=0,iElem=0,nElem=elements.length;iElem<nElem;iElem++){var elem=elements[iElem],v0=elem.v0,v1=elem.v1;positions.push(v0.x,v0.y,v0.z,v1.x,v1.y,v1.z);if(3===elementSize){positions.push(elem.v2.x,elem.v2.y,elem.v2.z);v0=elem.n0||elem.faceNormal;v1=elem.n1||elem.faceNormal;var n2=elem.n2||elem.faceNormal;normals.push(v0.x,\nv0.y,v0.z);normals.push(v1.x,v1.y,v1.z);normals.push(n2.x,n2.y,n2.z)}prevMaterial!==elem.material?(null!==prevMaterial&&bufferGeometry.addGroup(index0,numGroupVerts,materials.length-1),materials.push(elem.material),prevMaterial=elem.material,index0=iElem*elementSize,numGroupVerts=elementSize):numGroupVerts+=elementSize}0<numGroupVerts&&bufferGeometry.addGroup(index0,Infinity,materials.length-1);bufferGeometry.setAttribute(\"position\",new _three.Float32BufferAttribute(positions,3));3===elementSize&&\nbufferGeometry.setAttribute(\"normal\",new _three.Float32BufferAttribute(normals,3));positions=null;2===elementSize?positions=new _three.LineSegments(bufferGeometry,materials):3===elementSize&&(positions=new _three.Mesh(bufferGeometry,materials));if(isConditionalSegments){positions.isConditionalLine=!0;elementSize=new Float32Array(6*elements.length);isConditionalSegments=new Float32Array(6*elements.length);materials=new Float32Array(6*elements.length);normals=0;for(prevMaterial=elements.length;normals<\nprevMaterial;normals++)nElem=elements[normals],index0=nElem.c0,numGroupVerts=nElem.c1,iElem=nElem.v0,nElem=nElem.v1,elem=6*normals,elementSize[elem+0]=index0.x,elementSize[elem+1]=index0.y,elementSize[elem+2]=index0.z,elementSize[elem+3]=index0.x,elementSize[elem+4]=index0.y,elementSize[elem+5]=index0.z,isConditionalSegments[elem+0]=numGroupVerts.x,isConditionalSegments[elem+1]=numGroupVerts.y,isConditionalSegments[elem+2]=numGroupVerts.z,isConditionalSegments[elem+3]=numGroupVerts.x,isConditionalSegments[elem+\n4]=numGroupVerts.y,isConditionalSegments[elem+5]=numGroupVerts.z,materials[elem+0]=nElem.x-iElem.x,materials[elem+1]=nElem.y-iElem.y,materials[elem+2]=nElem.z-iElem.z,materials[elem+3]=nElem.x-iElem.x,materials[elem+4]=nElem.y-iElem.y,materials[elem+5]=nElem.z-iElem.z;bufferGeometry.setAttribute(\"control0\",new _three.BufferAttribute(elementSize,3,!1));bufferGeometry.setAttribute(\"control1\",new _three.BufferAttribute(isConditionalSegments,3,!1));bufferGeometry.setAttribute(\"direction\",new _three.BufferAttribute(materials,\n3,!1))}return positions}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.LDrawLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_tempVec0=new _three.Vector3,_tempVec1=new _three.Vector3,LineParser=function(){function LineParser(line,lineNumber){_classCallCheck(this,LineParser);this.line=line;this.lineLength=line.length;this.currentCharIndex=0;this.currentChar=\" \";this.lineNumber=lineNumber}_createClass(LineParser,[{key:\"seekNonSpace\",value:function(){for(;this.currentCharIndex<\nthis.lineLength;){this.currentChar=this.line.charAt(this.currentCharIndex);if(\" \"!==this.currentChar&&\"\\t\"!==this.currentChar)break;this.currentCharIndex++}}},{key:\"getToken\",value:function(){for(var pos0=this.currentCharIndex++;this.currentCharIndex<this.lineLength;){this.currentChar=this.line.charAt(this.currentCharIndex);if(\" \"===this.currentChar||\"\\t\"===this.currentChar)break;this.currentCharIndex++}var pos1=this.currentCharIndex;this.seekNonSpace();return this.line.substring(pos0,pos1)}},{key:\"getRemainingString\",\nvalue:function(){return this.line.substring(this.currentCharIndex,this.lineLength)}},{key:\"isAtTheEnd\",value:function(){return this.currentCharIndex>=this.lineLength}},{key:\"setToEnd\",value:function(){this.currentCharIndex=this.lineLength}},{key:\"getLineNumberString\",value:function(){return 0<=this.lineNumber?\" at line \"+this.lineNumber:\"\"}}]);return LineParser}();global=function(_Loader){function LDrawLoader(manager){_classCallCheck(this,LDrawLoader);manager=_getPrototypeOf(LDrawLoader).call(this,\nmanager);if(!manager||\"object\"!==_typeof(manager)&&\"function\"!==typeof manager){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");manager=this}manager.parseScopesStack=null;manager.materials=[];manager.subobjectCache={};manager.fileMap=null;manager.setMaterials([manager.parseColourMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")),manager.parseColourMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\"))]);\nmanager.separateObjects=!1;manager.smoothNormals=!0;return manager}_inherits(LDrawLoader,_Loader);_createClass(LDrawLoader,[{key:\"load\",value:function(url,onLoad,onProgress,onError){this.fileMap||(this.fileMap={});var scope=this,fileLoader=new _three.FileLoader(this.manager);fileLoader.setPath(this.path);fileLoader.setRequestHeader(this.requestHeader);fileLoader.setWithCredentials(this.withCredentials);fileLoader.load(url,function(text){scope.processObject(text,onLoad,null,url)},onProgress,onError)}},\n{key:\"parse\",value:function(text,path,onLoad){this.processObject(text,onLoad,null,path)}},{key:\"setMaterials\",value:function(materials){this.parseScopesStack=[];this.newParseScopeLevel(materials);this.getCurrentParseScope().isFromParse=!1;this.materials=materials;return this}},{key:\"setFileMap\",value:function(fileMap){this.fileMap=fileMap;return this}},{key:\"newParseScopeLevel\",value:function(materials){var matLib={};if(materials)for(var i=0,n=materials.length;i<n;i++){var material=materials[i];matLib[material.userData.code]=\nmaterial}materials=this.getCurrentParseScope();matLib={lib:matLib,url:null,subobjects:null,numSubobjects:0,subobjectIndex:0,inverted:!1,category:null,keywords:null,currentFileName:null,mainColourCode:materials?materials.mainColourCode:\"16\",mainEdgeColourCode:materials?materials.mainEdgeColourCode:\"24\",currentMatrix:new _three.Matrix4,matrix:new _three.Matrix4,isFromParse:!0,triangles:null,lineSegments:null,conditionalSegments:null,startingConstructionStep:!1};this.parseScopesStack.push(matLib);return matLib}},\n{key:\"removeScopeLevel\",value:function(){this.parseScopesStack.pop();return this}},{key:\"addMaterial\",value:function(material){var matLib=this.getCurrentParseScope().lib;matLib[material.userData.code]||this.materials.push(material);matLib[material.userData.code]=material;return this}},{key:\"getMaterial\",value:function(colourCode){if(colourCode.startsWith(\"0x2\"))return colourCode=colourCode.substring(3),this.parseColourMetaDirective(new LineParser(\"Direct_Color_\"+colourCode+\" CODE -1 VALUE #\"+colourCode+\n\" EDGE #\"+colourCode));for(var i=this.parseScopesStack.length-1;0<=i;i--){var material=this.parseScopesStack[i].lib[colourCode];if(material)return material}return null}},{key:\"getParentParseScope\",value:function(){return 1<this.parseScopesStack.length?this.parseScopesStack[this.parseScopesStack.length-2]:null}},{key:\"getCurrentParseScope\",value:function(){return 0<this.parseScopesStack.length?this.parseScopesStack[this.parseScopesStack.length-1]:null}},{key:\"parseColourMetaDirective\",value:function(lineParser){var code=\nnull,colour=16711935,edgeColour=16711935,alpha=1,isTransparent=!1,luminance=0,finishType=0,canHaveEnvMap=!0,edgeMaterial=null,name=lineParser.getToken();if(!name)throw'LDrawLoader: Material name was expected after \"!COLOUR tag'+lineParser.getLineNumberString()+\".\";for(var token;;){token=lineParser.getToken();if(!token)break;switch(token.toUpperCase()){case \"CODE\":code=lineParser.getToken();break;case \"VALUE\":colour=lineParser.getToken();if(colour.startsWith(\"0x\"))colour=\"#\"+colour.substring(2);else if(!colour.startsWith(\"#\"))throw\"LDrawLoader: Invalid colour while parsing material\"+\nlineParser.getLineNumberString()+\".\";break;case \"EDGE\":edgeColour=lineParser.getToken();if(edgeColour.startsWith(\"0x\"))edgeColour=\"#\"+edgeColour.substring(2);else if(!edgeColour.startsWith(\"#\")){edgeMaterial=this.getMaterial(edgeColour);if(!edgeMaterial)throw\"LDrawLoader: Invalid edge colour while parsing material\"+lineParser.getLineNumberString()+\".\";edgeMaterial=edgeMaterial.userData.edgeMaterial}break;case \"ALPHA\":alpha=parseInt(lineParser.getToken());if(isNaN(alpha))throw\"LDrawLoader: Invalid alpha value in material definition\"+\nlineParser.getLineNumberString()+\".\";alpha=Math.max(0,Math.min(1,alpha/255));1>alpha&&(isTransparent=!0);break;case \"LUMINANCE\":luminance=parseInt(lineParser.getToken());if(isNaN(luminance))throw\"LDrawLoader: Invalid luminance value in material definition\"+LineParser.getLineNumberString()+\".\";luminance=Math.max(0,Math.min(1,luminance/255));break;case \"CHROME\":finishType=1;break;case \"PEARLESCENT\":finishType=2;break;case \"RUBBER\":finishType=3;break;case \"MATTE_METALLIC\":finishType=4;break;case \"METAL\":finishType=\n5;break;case \"MATERIAL\":lineParser.setToEnd();break;default:throw'LDrawLoader: Unknown token \"'+token+'\" while parsing material'+lineParser.getLineNumberString()+\".\";}}lineParser=null;switch(finishType){case 0:lineParser=new _three.MeshStandardMaterial({color:colour,roughness:.3,envMapIntensity:.3,metalness:0});break;case 2:finishType=new _three.Color(colour);lineParser=finishType.getHSL({h:0,s:0,l:0});lineParser.h=(lineParser.h+.5)%1;lineParser.l=Math.min(1,lineParser.l+.7*(1-lineParser.l));finishType.setHSL(lineParser.h,\nlineParser.s,lineParser.l);lineParser=new _three.MeshPhongMaterial({color:colour,specular:finishType,shininess:10,reflectivity:.3});break;case 1:lineParser=new _three.MeshStandardMaterial({color:colour,roughness:0,metalness:1});break;case 3:lineParser=new _three.MeshStandardMaterial({color:colour,roughness:.9,metalness:0});canHaveEnvMap=!1;break;case 4:lineParser=new _three.MeshStandardMaterial({color:colour,roughness:.8,metalness:.4});break;case 5:lineParser=new _three.MeshStandardMaterial({color:colour,\nroughness:.2,metalness:.85})}lineParser.transparent=isTransparent;lineParser.premultipliedAlpha=!0;lineParser.opacity=alpha;lineParser.depthWrite=!isTransparent;lineParser.polygonOffset=!0;lineParser.polygonOffsetFactor=1;lineParser.userData.canHaveEnvMap=canHaveEnvMap;0!==luminance&&lineParser.emissive.set(lineParser.color).multiplyScalar(luminance);edgeMaterial||(edgeMaterial=new _three.LineBasicMaterial({color:edgeColour,transparent:isTransparent,opacity:alpha,depthWrite:!isTransparent}),edgeMaterial.userData.code=\ncode,edgeMaterial.name=name+\" - Edge\",edgeMaterial.userData.canHaveEnvMap=!1,edgeMaterial.userData.conditionalEdgeMaterial=new _three.ShaderMaterial({vertexShader:\"\\n\\tattribute vec3 control0;\\n\\tattribute vec3 control1;\\n\\tattribute vec3 direction;\\n\\tvarying float discardFlag;\\n\\n\\t#include \\x3ccommon\\x3e\\n\\t#include \\x3ccolor_pars_vertex\\x3e\\n\\t#include \\x3cfog_pars_vertex\\x3e\\n\\t#include \\x3clogdepthbuf_pars_vertex\\x3e\\n\\t#include \\x3cclipping_planes_pars_vertex\\x3e\\n\\tvoid main() {\\n\\t\\t#include \\x3ccolor_vertex\\x3e\\n\\n\\t\\tvec4 mvPosition \\x3d modelViewMatrix * vec4( position, 1.0 );\\n\\t\\tgl_Position \\x3d projectionMatrix * mvPosition;\\n\\n\\t\\t// Transform the line segment ends and control points into camera clip space\\n\\t\\tvec4 c0 \\x3d projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\\n\\t\\tvec4 c1 \\x3d projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\\n\\t\\tvec4 p0 \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\tvec4 p1 \\x3d projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\\n\\n\\t\\tc0.xy /\\x3d c0.w;\\n\\t\\tc1.xy /\\x3d c1.w;\\n\\t\\tp0.xy /\\x3d p0.w;\\n\\t\\tp1.xy /\\x3d p1.w;\\n\\n\\t\\t// Get the direction of the segment and an orthogonal vector\\n\\t\\tvec2 dir \\x3d p1.xy - p0.xy;\\n\\t\\tvec2 norm \\x3d vec2( -dir.y, dir.x );\\n\\n\\t\\t// Get control point directions from the line\\n\\t\\tvec2 c0dir \\x3d c0.xy - p1.xy;\\n\\t\\tvec2 c1dir \\x3d c1.xy - p1.xy;\\n\\n\\t\\t// If the vectors to the controls points are pointed in different directions away\\n\\t\\t// from the line segment then the line should not be drawn.\\n\\t\\tfloat d0 \\x3d dot( normalize( norm ), normalize( c0dir ) );\\n\\t\\tfloat d1 \\x3d dot( normalize( norm ), normalize( c1dir ) );\\n\\t\\tdiscardFlag \\x3d float( sign( d0 ) !\\x3d sign( d1 ) );\\n\\n\\t\\t#include \\x3clogdepthbuf_vertex\\x3e\\n\\t\\t#include \\x3cclipping_planes_vertex\\x3e\\n\\t\\t#include \\x3cfog_vertex\\x3e\\n\\t}\\n\\t\",\nfragmentShader:\"\\n\\tuniform vec3 diffuse;\\n\\tuniform float opacity;\\n\\tvarying float discardFlag;\\n\\n\\t#include \\x3ccommon\\x3e\\n\\t#include \\x3ccolor_pars_fragment\\x3e\\n\\t#include \\x3cfog_pars_fragment\\x3e\\n\\t#include \\x3clogdepthbuf_pars_fragment\\x3e\\n\\t#include \\x3cclipping_planes_pars_fragment\\x3e\\n\\tvoid main() {\\n\\n\\t\\tif ( discardFlag \\x3e 0.5 ) discard;\\n\\n\\t\\t#include \\x3cclipping_planes_fragment\\x3e\\n\\t\\tvec3 outgoingLight \\x3d vec3( 0.0 );\\n\\t\\tvec4 diffuseColor \\x3d vec4( diffuse, opacity );\\n\\t\\t#include \\x3clogdepthbuf_fragment\\x3e\\n\\t\\t#include \\x3ccolor_fragment\\x3e\\n\\t\\toutgoingLight \\x3d diffuseColor.rgb; // simple shader\\n\\t\\tgl_FragColor \\x3d vec4( outgoingLight, diffuseColor.a );\\n\\t\\t#include \\x3ctonemapping_fragment\\x3e\\n\\t\\t#include \\x3cencodings_fragment\\x3e\\n\\t\\t#include \\x3cfog_fragment\\x3e\\n\\t\\t#include \\x3cpremultiplied_alpha_fragment\\x3e\\n\\t}\\n\\t\",\nuniforms:_three.UniformsUtils.merge([_three.UniformsLib.fog,{diffuse:{value:new _three.Color(edgeColour)},opacity:{value:alpha}}]),fog:!0,transparent:isTransparent,depthWrite:!isTransparent}),edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap=!1);lineParser.userData.code=code;lineParser.name=name;lineParser.userData.edgeMaterial=edgeMaterial;return lineParser}},{key:\"objectParse\",value:function(text){function parseColourCode(lineParser,forEdge){var colourCode=lineParser.getToken();\nforEdge||\"16\"!==colourCode||(colourCode=mainColourCode);forEdge&&\"24\"===colourCode&&(colourCode=mainEdgeColourCode);forEdge=scope.getMaterial(colourCode);if(!forEdge)throw'LDrawLoader: Unknown colour code \"'+colourCode+'\" is used'+lineParser.getLineNumberString()+\" but it was not defined previously.\";return forEdge}function parseVector(lp){lp=new _three.Vector3(parseFloat(lp.getToken()),parseFloat(lp.getToken()),parseFloat(lp.getToken()));scope.separateObjects||lp.applyMatrix4(currentParseScope.currentMatrix);\nreturn lp}var parentParseScope=this.getParentParseScope(),mainColourCode=parentParseScope.mainColourCode,mainEdgeColourCode=parentParseScope.mainEdgeColourCode,currentParseScope=this.getCurrentParseScope(),subobjects=[],category=null,keywords=null;-1!==text.indexOf(\"\\r\\n\")&&(text=text.replace(/\\r\\n/g,\"\\n\"));text=text.split(\"\\n\");for(var numLines=text.length,parsingEmbeddedFiles=!1,currentEmbeddedFileName=null,currentEmbeddedText=null,bfcCertified=!1,bfcCCW=!0,bfcInverted=!1,bfcCull=!0,type=\"\",startingConstructionStep=\n!1,scope=this,lineIndex=0;lineIndex<numLines;lineIndex++)if(type=text[lineIndex],0!==type.length)if(parsingEmbeddedFiles)type.startsWith(\"0 FILE \")?(this.subobjectCache[currentEmbeddedFileName.toLowerCase()]=currentEmbeddedText,currentEmbeddedFileName=type.substring(7),currentEmbeddedText=\"\"):currentEmbeddedText+=type+\"\\n\";else if(type=new LineParser(type,lineIndex+1),type.seekNonSpace(),!type.isAtTheEnd()){var lineType=type.getToken(),material=void 0,inverted=material=void 0,ccw=void 0,v1=ccw=inverted=\nvoid 0,v2=void 0,v3=void 0,faceNormal=void 0;switch(lineType){case \"0\":if(material=type.getToken())switch(material){case \"!LDRAW_ORG\":type=type.getToken();currentParseScope.triangles=[];currentParseScope.lineSegments=[];currentParseScope.conditionalSegments=[];currentParseScope.type=type;if(!parentParseScope.isFromParse||scope.separateObjects&&!isPrimitiveType(type))currentParseScope.groupObject=new _three.Group,currentParseScope.groupObject.userData.startingConstructionStep=currentParseScope.startingConstructionStep;\n0>currentParseScope.matrix.determinant()&&(scope.separateObjects&&isPrimitiveType(type)||!scope.separateObjects)&&(currentParseScope.inverted=!currentParseScope.inverted);var triangles=currentParseScope.triangles;var lineSegments=currentParseScope.lineSegments;var conditionalSegments=currentParseScope.conditionalSegments;break;case \"!COLOUR\":(material=this.parseColourMetaDirective(type))?this.addMaterial(material):console.warn(\"LDrawLoader: Error parsing material\"+type.getLineNumberString());break;\ncase \"!CATEGORY\":category=type.getToken();break;case \"!KEYWORDS\":type=type.getRemainingString().split(\",\");0<type.length&&(keywords||(keywords=[]),type.forEach(function(keyword){keywords.push(keyword.trim())}));break;case \"FILE\":0<lineIndex&&(parsingEmbeddedFiles=!0,currentEmbeddedFileName=type.getRemainingString(),currentEmbeddedText=\"\",bfcCertified=!1,bfcCCW=!0);break;case \"BFC\":for(;!type.isAtTheEnd();)switch(material=type.getToken(),material){case \"CERTIFY\":case \"NOCERTIFY\":bfcCertified=\"CERTIFY\"===\nmaterial;bfcCCW=!0;break;case \"CW\":case \"CCW\":bfcCCW=\"CCW\"===material;break;case \"INVERTNEXT\":bfcInverted=!0;break;case \"CLIP\":case \"NOCLIP\":bfcCull=\"CLIP\"===material;break;default:console.warn('THREE.LDrawLoader: BFC directive \"'+material+'\" is unknown.')}break;case \"STEP\":startingConstructionStep=!0}break;case \"1\":material=parseColourCode(type);lineType=parseFloat(type.getToken());inverted=parseFloat(type.getToken());ccw=parseFloat(type.getToken());v1=parseFloat(type.getToken());v2=parseFloat(type.getToken());\nv3=parseFloat(type.getToken());faceNormal=parseFloat(type.getToken());var m4=parseFloat(type.getToken()),m5=parseFloat(type.getToken()),m6=parseFloat(type.getToken()),m7=parseFloat(type.getToken()),m8=parseFloat(type.getToken());lineType=(new _three.Matrix4).set(v1,v2,v3,lineType,faceNormal,m4,m5,inverted,m6,m7,m8,ccw,0,0,0,1);type=type.getRemainingString().trim().replace(/\\\\/g,\"/\");scope.fileMap[type]?type=scope.fileMap[type]:type.startsWith(\"s/\")?type=\"parts/\"+type:type.startsWith(\"48/\")&&(type=\n\"p/\"+type);subobjects.push({material,matrix:lineType,fileName:type,originalFileName:type,locationState:0,url:null,triedLowerCase:!1,inverted:bfcInverted!==currentParseScope.inverted,startingConstructionStep});bfcInverted=!1;break;case \"2\":material=parseColourCode(type,!0);material={material:material.userData.edgeMaterial,colourCode:material.userData.code,v0:parseVector(type),v1:parseVector(type)};lineSegments.push(material);break;case \"5\":material=parseColourCode(type,!0);material={material:material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\ncolourCode:material.userData.code,v0:parseVector(type),v1:parseVector(type),c0:parseVector(type),c1:parseVector(type)};conditionalSegments.push(material);break;case \"3\":material=parseColourCode(type);inverted=currentParseScope.inverted;ccw=bfcCCW!==inverted;inverted=!bfcCertified||!bfcCull;!0===ccw?(ccw=parseVector(type),v1=parseVector(type),v2=parseVector(type)):(v2=parseVector(type),v1=parseVector(type),ccw=parseVector(type));_tempVec0.subVectors(v1,ccw);_tempVec1.subVectors(v2,v1);faceNormal=(new _three.Vector3).crossVectors(_tempVec0,\n_tempVec1).normalize();triangles.push({material,colourCode:material.userData.code,v0:ccw,v1,v2,faceNormal,n0:null,n1:null,n2:null});!0===inverted&&triangles.push({material,colourCode:material.userData.code,v0:ccw,v1:v2,v2:v1,faceNormal,n0:null,n1:null,n2:null});break;case \"4\":material=parseColourCode(type);inverted=currentParseScope.inverted;ccw=bfcCCW!==inverted;inverted=!bfcCertified||!bfcCull;!0===ccw?(ccw=parseVector(type),v1=parseVector(type),v2=parseVector(type),v3=parseVector(type)):(v3=parseVector(type),\nv2=parseVector(type),v1=parseVector(type),ccw=parseVector(type));_tempVec0.subVectors(v1,ccw);_tempVec1.subVectors(v2,v1);faceNormal=(new _three.Vector3).crossVectors(_tempVec0,_tempVec1).normalize();triangles.push({material,colourCode:material.userData.code,v0:ccw,v1,v2,faceNormal,n0:null,n1:null,n2:null});triangles.push({material,colourCode:material.userData.code,v0:ccw,v1:v2,v2:v3,faceNormal,n0:null,n1:null,n2:null});!0===inverted&&(triangles.push({material,colourCode:material.userData.code,v0:ccw,\nv1:v2,v2:v1,faceNormal,n0:null,n1:null,n2:null}),triangles.push({material,colourCode:material.userData.code,v0:ccw,v1:v3,v2,faceNormal,n0:null,n1:null,n2:null}));break;default:throw'LDrawLoader: Unknown line type \"'+lineType+'\"'+type.getLineNumberString()+\".\";}}parsingEmbeddedFiles&&(this.subobjectCache[currentEmbeddedFileName.toLowerCase()]=currentEmbeddedText);currentParseScope.category=category;currentParseScope.keywords=keywords;currentParseScope.subobjects=subobjects;currentParseScope.numSubobjects=\nsubobjects.length;currentParseScope.subobjectIndex=0}},{key:\"computeConstructionSteps\",value:function(model){var stepNumber=0;model.traverse(function(c){c.isGroup&&(c.userData.startingConstructionStep&&stepNumber++,c.userData.constructionStep=stepNumber)});model.userData.numConstructionSteps=stepNumber+1}},{key:\"processObject\",value:function(text$jscomp$0,onProcessed,subobject,url){function onSubobjectFinish(){finishedCount++;if(finishedCount===parseScope.subobjects.length+1)finalizeObject();else{var _subobject=\nparseScope.subobjects[parseScope.subobjectIndex];Promise.resolve().then(function(){loadSubobject(_subobject)});parseScope.subobjectIndex++}}function finalizeObject(){scope.smoothNormals&&\"Part\"===parseScope.type&&smoothNormals(parseScope.triangles,parseScope.lineSegments);var isRoot=!parentParseScope.isFromParse;if(scope.separateObjects&&!isPrimitiveType(parseScope.type)||isRoot)isRoot=parseScope.groupObject,0<parseScope.triangles.length&&isRoot.add(createObject(parseScope.triangles,3)),0<parseScope.lineSegments.length&&\nisRoot.add(createObject(parseScope.lineSegments,2)),0<parseScope.conditionalSegments.length&&isRoot.add(createObject(parseScope.conditionalSegments,2,!0)),parentParseScope.groupObject&&(isRoot.name=parseScope.fileName,isRoot.userData.category=parseScope.category,isRoot.userData.keywords=parseScope.keywords,parseScope.matrix.decompose(isRoot.position,isRoot.quaternion,isRoot.scale),parentParseScope.groupObject.add(isRoot));else{isRoot=scope.separateObjects;for(var parentLineSegments=parentParseScope.lineSegments,\nparentConditionalSegments=parentParseScope.conditionalSegments,parentTriangles=parentParseScope.triangles,lineSegments=parseScope.lineSegments,conditionalSegments=parseScope.conditionalSegments,triangles=parseScope.triangles,i=0,l=lineSegments.length;i<l;i++){var ls=lineSegments[i];isRoot&&(ls.v0.applyMatrix4(parseScope.matrix),ls.v1.applyMatrix4(parseScope.matrix));parentLineSegments.push(ls)}parentLineSegments=0;for(lineSegments=conditionalSegments.length;parentLineSegments<lineSegments;parentLineSegments++)i=\nconditionalSegments[parentLineSegments],isRoot&&(i.v0.applyMatrix4(parseScope.matrix),i.v1.applyMatrix4(parseScope.matrix),i.c0.applyMatrix4(parseScope.matrix),i.c1.applyMatrix4(parseScope.matrix)),parentConditionalSegments.push(i);parentConditionalSegments=0;for(conditionalSegments=triangles.length;parentConditionalSegments<conditionalSegments;parentConditionalSegments++)parentLineSegments=triangles[parentConditionalSegments],isRoot&&(parentLineSegments.v0=parentLineSegments.v0.clone().applyMatrix4(parseScope.matrix),\nparentLineSegments.v1=parentLineSegments.v1.clone().applyMatrix4(parseScope.matrix),parentLineSegments.v2=parentLineSegments.v2.clone().applyMatrix4(parseScope.matrix),_tempVec0.subVectors(parentLineSegments.v1,parentLineSegments.v0),_tempVec1.subVectors(parentLineSegments.v2,parentLineSegments.v1),parentLineSegments.faceNormal.crossVectors(_tempVec0,_tempVec1).normalize()),parentTriangles.push(parentLineSegments)}scope.removeScopeLevel();parentParseScope.isFromParse||scope.computeConstructionSteps(parseScope.groupObject);\nonProcessed&&onProcessed(parseScope.groupObject)}function loadSubobject(subobject){parseScope.mainColourCode=subobject.material.userData.code;parseScope.mainEdgeColourCode=subobject.material.userData.edgeMaterial.userData.code;parseScope.currentFileName=subobject.originalFileName;var cached=scope.subobjectCache[subobject.originalFileName.toLowerCase()];if(cached)scope.processObject(cached,function(subobjectGroup){null===subobjectGroup?loadSubobject(subobject):scope.fileMap[subobject.originalFileName]=\nsubobject.url;onSubobjectFinish()},subobject,url);else{cached=subobject.fileName;var newLocationState=6;switch(subobject.locationState){case 0:newLocationState=subobject.locationState+1;break;case 1:cached=\"parts/\"+cached;newLocationState=subobject.locationState+1;break;case 2:cached=\"p/\"+cached;newLocationState=subobject.locationState+1;break;case 3:cached=\"models/\"+cached;newLocationState=subobject.locationState+1;break;case 4:cached=url.substring(0,url.lastIndexOf(\"/\")+1)+cached;newLocationState=\nsubobject.locationState+1;break;case 5:subobject.triedLowerCase?newLocationState=6:(subobject.fileName=subobject.fileName.toLowerCase(),cached=subobject.fileName,subobject.triedLowerCase=!0,newLocationState=0);break;case 6:console.warn('LDrawLoader: Subobject \"'+subobject.originalFileName+'\" could not be found.');return}subobject.locationState=newLocationState;subobject.url=cached;newLocationState=new _three.FileLoader(scope.manager);newLocationState.setPath(scope.path);newLocationState.setRequestHeader(scope.requestHeader);\nnewLocationState.setWithCredentials(scope.withCredentials);newLocationState.load(cached,function(text){scope.processObject(text,function(subobjectGroup){null===subobjectGroup?loadSubobject(subobject):scope.fileMap[subobject.originalFileName]=subobject.url;onSubobjectFinish()},subobject,url)},void 0,function(err){loadSubobject(subobject)},subobject)}}var scope=this,parseScope=scope.newParseScopeLevel();parseScope.url=url;var parentParseScope=scope.getParentParseScope();subobject&&(parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix,\nsubobject.matrix),parseScope.matrix.copy(subobject.matrix),parseScope.inverted=subobject.inverted,parseScope.startingConstructionStep=subobject.startingConstructionStep);subobject=parentParseScope.currentFileName;null!==subobject&&(subobject=parentParseScope.currentFileName.toLowerCase());void 0===scope.subobjectCache[subobject]&&(scope.subobjectCache[subobject]=text$jscomp$0);scope.objectParse(text$jscomp$0);var finishedCount=0;onSubobjectFinish()}}]);return LDrawLoader}(_three.Loader);exports.LDrawLoader=\nglobal}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$LDrawLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LDrawLoader = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nvar FINISH_TYPE_DEFAULT = 0;\nvar FINISH_TYPE_CHROME = 1;\nvar FINISH_TYPE_PEARLESCENT = 2;\nvar FINISH_TYPE_RUBBER = 3;\nvar FINISH_TYPE_MATTE_METALLIC = 4;\nvar FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nvar FILE_LOCATION_AS_IS = 0;\nvar FILE_LOCATION_TRY_PARTS = 1;\nvar FILE_LOCATION_TRY_P = 2;\nvar FILE_LOCATION_TRY_MODELS = 3;\nvar FILE_LOCATION_TRY_RELATIVE = 4;\nvar FILE_LOCATION_TRY_ABSOLUTE = 5;\nvar FILE_LOCATION_NOT_FOUND = 6;\nvar conditionalLineVertShader =\n/* glsl */\n\"\\n\\tattribute vec3 control0;\\n\\tattribute vec3 control1;\\n\\tattribute vec3 direction;\\n\\tvarying float discardFlag;\\n\\n\\t#include <common>\\n\\t#include <color_pars_vertex>\\n\\t#include <fog_pars_vertex>\\n\\t#include <logdepthbuf_pars_vertex>\\n\\t#include <clipping_planes_pars_vertex>\\n\\tvoid main() {\\n\\t\\t#include <color_vertex>\\n\\n\\t\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\t\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t\\t// Transform the line segment ends and control points into camera clip space\\n\\t\\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\\n\\t\\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\\n\\t\\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\\n\\n\\t\\tc0.xy /= c0.w;\\n\\t\\tc1.xy /= c1.w;\\n\\t\\tp0.xy /= p0.w;\\n\\t\\tp1.xy /= p1.w;\\n\\n\\t\\t// Get the direction of the segment and an orthogonal vector\\n\\t\\tvec2 dir = p1.xy - p0.xy;\\n\\t\\tvec2 norm = vec2( -dir.y, dir.x );\\n\\n\\t\\t// Get control point directions from the line\\n\\t\\tvec2 c0dir = c0.xy - p1.xy;\\n\\t\\tvec2 c1dir = c1.xy - p1.xy;\\n\\n\\t\\t// If the vectors to the controls points are pointed in different directions away\\n\\t\\t// from the line segment then the line should not be drawn.\\n\\t\\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\\n\\t\\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\\n\\t\\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\\n\\n\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t#include <clipping_planes_vertex>\\n\\t\\t#include <fog_vertex>\\n\\t}\\n\\t\";\nvar conditionalLineFragShader =\n/* glsl */\n\"\\n\\tuniform vec3 diffuse;\\n\\tuniform float opacity;\\n\\tvarying float discardFlag;\\n\\n\\t#include <common>\\n\\t#include <color_pars_fragment>\\n\\t#include <fog_pars_fragment>\\n\\t#include <logdepthbuf_pars_fragment>\\n\\t#include <clipping_planes_pars_fragment>\\n\\tvoid main() {\\n\\n\\t\\tif ( discardFlag > 0.5 ) discard;\\n\\n\\t\\t#include <clipping_planes_fragment>\\n\\t\\tvec3 outgoingLight = vec3( 0.0 );\\n\\t\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t\\t#include <logdepthbuf_fragment>\\n\\t\\t#include <color_fragment>\\n\\t\\toutgoingLight = diffuseColor.rgb; // simple shader\\n\\t\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t\\t#include <tonemapping_fragment>\\n\\t\\t#include <encodings_fragment>\\n\\t\\t#include <fog_fragment>\\n\\t\\t#include <premultiplied_alpha_fragment>\\n\\t}\\n\\t\";\n\nvar _tempVec0 = new _three.Vector3();\n\nvar _tempVec1 = new _three.Vector3();\n\nfunction smoothNormals(triangles, lineSegments) {\n  function hashVertex(v) {\n    // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n    // to be smoothed as expected (see minifig arms). The errors between edges\n    // could be due to matrix multiplication.\n    var x = ~~(v.x * 1e2);\n    var y = ~~(v.y * 1e2);\n    var z = ~~(v.z * 1e2);\n    return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n  }\n\n  function hashEdge(v0, v1) {\n    return \"\".concat(hashVertex(v0), \"_\").concat(hashVertex(v1));\n  }\n\n  var hardEdges = new Set();\n  var halfEdgeList = {};\n  var fullHalfEdgeList = {};\n  var normals = []; // Save the list of hard edges by hash\n\n  for (var i = 0, l = lineSegments.length; i < l; i++) {\n    var ls = lineSegments[i];\n    var v0 = ls.v0;\n    var v1 = ls.v1;\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n  } // track the half edges associated with each triangle\n\n\n  for (var _i = 0, _l = triangles.length; _i < _l; _i++) {\n    var tri = triangles[_i];\n\n    for (var i2 = 0, l2 = 3; i2 < l2; i2++) {\n      var index = i2;\n      var next = (i2 + 1) % 3;\n      var _v = tri[\"v\".concat(index)];\n      var _v2 = tri[\"v\".concat(next)];\n      var hash = hashEdge(_v, _v2); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) continue;\n      halfEdgeList[hash] = tri;\n      fullHalfEdgeList[hash] = tri;\n    }\n  } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n  // quads provide more \"influence\" to some vertex normals than a triangle due to\n  // the fact that a quad is made up of two triangles and all triangles are weighted\n  // equally. To fix this quads could be tracked separately so their vertex normals\n  // are weighted appropriately or we could try only adding a normal direction\n  // once per normal.\n  // Iterate until we've tried to connect all triangles to share normals\n\n\n  while (true) {\n    // Stop if there are no more triangles left\n    var halfEdges = Object.keys(halfEdgeList);\n    if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n    var _i2 = 0;\n    var queue = [fullHalfEdgeList[halfEdges[0]]];\n\n    while (_i2 < queue.length) {\n      // initialize all vertex normals in this triangle\n      var _tri = queue[_i2];\n      _i2++;\n      var faceNormal = _tri.faceNormal;\n\n      if (_tri.n0 === null) {\n        _tri.n0 = faceNormal.clone();\n        normals.push(_tri.n0);\n      }\n\n      if (_tri.n1 === null) {\n        _tri.n1 = faceNormal.clone();\n        normals.push(_tri.n1);\n      }\n\n      if (_tri.n2 === null) {\n        _tri.n2 = faceNormal.clone();\n        normals.push(_tri.n2);\n      } // Check if any edge is connected to another triangle edge\n\n\n      for (var _i3 = 0, _l2 = 3; _i3 < _l2; _i3++) {\n        var _index = _i3;\n\n        var _next = (_i3 + 1) % 3;\n\n        var _v3 = _tri[\"v\".concat(_index)];\n\n        var _v4 = _tri[\"v\".concat(_next)]; // delete this triangle from the list so it won't be found again\n\n\n        var _hash = hashEdge(_v3, _v4);\n\n        delete halfEdgeList[_hash];\n        var reverseHash = hashEdge(_v4, _v3);\n        var otherTri = fullHalfEdgeList[reverseHash];\n\n        if (otherTri) {\n          // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(_tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherTri);\n            delete halfEdgeList[reverseHash];\n          } // Find the matching edge in this triangle and copy the normal vector over\n\n\n          for (var i3 = 0, l3 = 3; i3 < l3; i3++) {\n            var otherIndex = i3;\n            var otherNext = (i3 + 1) % 3;\n            var otherV0 = otherTri[\"v\".concat(otherIndex)];\n            var otherV1 = otherTri[\"v\".concat(otherNext)];\n            var otherHash = hashEdge(otherV0, otherV1);\n\n            if (otherHash === reverseHash) {\n              if (otherTri[\"n\".concat(otherIndex)] === null) {\n                var norm = _tri[\"n\".concat(_next)];\n\n                otherTri[\"n\".concat(otherIndex)] = norm;\n                norm.add(otherTri.faceNormal);\n              }\n\n              if (otherTri[\"n\".concat(otherNext)] === null) {\n                var _norm = _tri[\"n\".concat(_index)];\n\n                otherTri[\"n\".concat(otherNext)] = _norm;\n\n                _norm.add(otherTri.faceNormal);\n              }\n\n              break;\n            }\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (var _i4 = 0, _l3 = normals.length; _i4 < _l3; _i4++) {\n    normals[_i4].normalize();\n  }\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nvar LineParser =\n/*#__PURE__*/\nfunction () {\n  function LineParser(line, lineNumber) {\n    _classCallCheck(this, LineParser);\n\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  _createClass(LineParser, [{\n    key: \"seekNonSpace\",\n    value: function seekNonSpace() {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n          return;\n        }\n\n        this.currentCharIndex++;\n      }\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken() {\n      var pos0 = this.currentCharIndex++; // Seek space\n\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar === ' ' || this.currentChar === '\\t') {\n          break;\n        }\n\n        this.currentCharIndex++;\n      }\n\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    }\n  }, {\n    key: \"getRemainingString\",\n    value: function getRemainingString() {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    }\n  }, {\n    key: \"isAtTheEnd\",\n    value: function isAtTheEnd() {\n      return this.currentCharIndex >= this.lineLength;\n    }\n  }, {\n    key: \"setToEnd\",\n    value: function setToEnd() {\n      this.currentCharIndex = this.lineLength;\n    }\n  }, {\n    key: \"getLineNumberString\",\n    value: function getLineNumberString() {\n      return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n    }\n  }]);\n\n  return LineParser;\n}();\n\nfunction sortByMaterial(a, b) {\n  if (a.colourCode === b.colourCode) {\n    return 0;\n  }\n\n  if (a.colourCode < b.colourCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the triangles or line segments by colour code to make later the mesh groups\n  elements.sort(sortByMaterial);\n  var positions = [];\n  var normals = [];\n  var materials = [];\n  var bufferGeometry = new _three.BufferGeometry();\n  var prevMaterial = null;\n  var index0 = 0;\n  var numGroupVerts = 0;\n\n  for (var iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    var elem = elements[iElem];\n    var v0 = elem.v0;\n    var v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n    positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n\n    if (elementSize === 3) {\n      positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n      var n0 = elem.n0 || elem.faceNormal;\n      var n1 = elem.n1 || elem.faceNormal;\n      var n2 = elem.n2 || elem.faceNormal;\n      normals.push(n0.x, n0.y, n0.z);\n      normals.push(n1.x, n1.y, n1.z);\n      normals.push(n2.x, n2.y, n2.z);\n    }\n\n    if (prevMaterial !== elem.material) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      materials.push(elem.material);\n      prevMaterial = elem.material;\n      index0 = iElem * elementSize;\n      numGroupVerts = elementSize;\n    } else {\n      numGroupVerts += elementSize;\n    }\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new _three.Float32BufferAttribute(positions, 3));\n\n  if (elementSize === 3) {\n    bufferGeometry.setAttribute('normal', new _three.Float32BufferAttribute(normals, 3));\n  }\n\n  var object3d = null;\n\n  if (elementSize === 2) {\n    object3d = new _three.LineSegments(bufferGeometry, materials);\n  } else if (elementSize === 3) {\n    object3d = new _three.Mesh(bufferGeometry, materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    var controlArray0 = new Float32Array(elements.length * 3 * 2);\n    var controlArray1 = new Float32Array(elements.length * 3 * 2);\n    var directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (var i = 0, l = elements.length; i < l; i++) {\n      var os = elements[i];\n      var c0 = os.c0;\n      var c1 = os.c1;\n      var _v5 = os.v0;\n      var _v6 = os.v1;\n      var index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = _v6.x - _v5.x;\n      directionArray[index + 1] = _v6.y - _v5.y;\n      directionArray[index + 2] = _v6.z - _v5.z;\n      directionArray[index + 3] = _v6.x - _v5.x;\n      directionArray[index + 4] = _v6.y - _v5.y;\n      directionArray[index + 5] = _v6.z - _v5.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new _three.BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new _three.BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new _three.BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nvar LDrawLoader =\n/*#__PURE__*/\nfunction (_Loader) {\n  _inherits(LDrawLoader, _Loader);\n\n  function LDrawLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, LDrawLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LDrawLoader).call(this, manager)); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    _this.parseScopesStack = null; // Array of THREE.Material\n\n    _this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    _this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    _this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    _this.setMaterials([_this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), _this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n\n    _this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    _this.smoothNormals = true;\n    return _this;\n  }\n\n  _createClass(LDrawLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      if (!this.fileMap) {\n        this.fileMap = {};\n      }\n\n      var scope = this;\n      var fileLoader = new _three.FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        scope.processObject(text, onLoad, null, url);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, path, onLoad) {\n      // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n      this.processObject(text, onLoad, null, path);\n    }\n  }, {\n    key: \"setMaterials\",\n    value: function setMaterials(materials) {\n      // Clears parse scopes stack, adds new scope with material library\n      this.parseScopesStack = [];\n      this.newParseScopeLevel(materials);\n      this.getCurrentParseScope().isFromParse = false;\n      this.materials = materials;\n      return this;\n    }\n  }, {\n    key: \"setFileMap\",\n    value: function setFileMap(fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    }\n  }, {\n    key: \"newParseScopeLevel\",\n    value: function newParseScopeLevel(materials) {\n      // Adds a new scope level, assign materials to it and returns it\n      var matLib = {};\n\n      if (materials) {\n        for (var i = 0, n = materials.length; i < n; i++) {\n          var material = materials[i];\n          matLib[material.userData.code] = material;\n        }\n      }\n\n      var topParseScope = this.getCurrentParseScope();\n      var newParseScope = {\n        lib: matLib,\n        url: null,\n        // Subobjects\n        subobjects: null,\n        numSubobjects: 0,\n        subobjectIndex: 0,\n        inverted: false,\n        category: null,\n        keywords: null,\n        // Current subobject\n        currentFileName: null,\n        mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n        mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n        currentMatrix: new _three.Matrix4(),\n        matrix: new _three.Matrix4(),\n        // If false, it is a root material scope previous to parse\n        isFromParse: true,\n        triangles: null,\n        lineSegments: null,\n        conditionalSegments: null,\n        // If true, this object is the start of a construction step\n        startingConstructionStep: false\n      };\n      this.parseScopesStack.push(newParseScope);\n      return newParseScope;\n    }\n  }, {\n    key: \"removeScopeLevel\",\n    value: function removeScopeLevel() {\n      this.parseScopesStack.pop();\n      return this;\n    }\n  }, {\n    key: \"addMaterial\",\n    value: function addMaterial(material) {\n      // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n      var matLib = this.getCurrentParseScope().lib;\n\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n      }\n\n      matLib[material.userData.code] = material;\n      return this;\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(colourCode) {\n      // Given a colour code search its material in the parse scopes stack\n      if (colourCode.startsWith('0x2')) {\n        // Special 'direct' material value (RGB colour)\n        var colour = colourCode.substring(3);\n        return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\n      }\n\n      for (var i = this.parseScopesStack.length - 1; i >= 0; i--) {\n        var material = this.parseScopesStack[i].lib[colourCode];\n\n        if (material) {\n          return material;\n        }\n      } // Material was not found\n\n\n      return null;\n    }\n  }, {\n    key: \"getParentParseScope\",\n    value: function getParentParseScope() {\n      if (this.parseScopesStack.length > 1) {\n        return this.parseScopesStack[this.parseScopesStack.length - 2];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getCurrentParseScope\",\n    value: function getCurrentParseScope() {\n      if (this.parseScopesStack.length > 0) {\n        return this.parseScopesStack[this.parseScopesStack.length - 1];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"parseColourMetaDirective\",\n    value: function parseColourMetaDirective(lineParser) {\n      // Parses a colour definition and returns a THREE.Material or null if error\n      var code = null; // Triangle and line colours\n\n      var colour = 0xff00ff;\n      var edgeColour = 0xff00ff; // Transparency\n\n      var alpha = 1;\n      var isTransparent = false; // Self-illumination:\n\n      var luminance = 0;\n      var finishType = FINISH_TYPE_DEFAULT;\n      var canHaveEnvMap = true;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n\n      if (!name) {\n        throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.';\n      } // Parse tag tokens and their parameters\n\n\n      var token = null;\n\n      while (true) {\n        token = lineParser.getToken();\n\n        if (!token) {\n          break;\n        }\n\n        switch (token.toUpperCase()) {\n          case 'CODE':\n            code = lineParser.getToken();\n            break;\n\n          case 'VALUE':\n            colour = lineParser.getToken();\n\n            if (colour.startsWith('0x')) {\n              colour = '#' + colour.substring(2);\n            } else if (!colour.startsWith('#')) {\n              throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\n            }\n\n            break;\n\n          case 'EDGE':\n            edgeColour = lineParser.getToken();\n\n            if (edgeColour.startsWith('0x')) {\n              edgeColour = '#' + edgeColour.substring(2);\n            } else if (!edgeColour.startsWith('#')) {\n              // Try to see if edge colour is a colour code\n              edgeMaterial = this.getMaterial(edgeColour);\n\n              if (!edgeMaterial) {\n                throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\n              } // Get the edge material for this triangle material\n\n\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n\n            break;\n\n          case 'ALPHA':\n            alpha = parseInt(lineParser.getToken());\n\n            if (isNaN(alpha)) {\n              throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\n            }\n\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n\n            break;\n\n          case 'LUMINANCE':\n            luminance = parseInt(lineParser.getToken());\n\n            if (isNaN(luminance)) {\n              throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\n            }\n\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n\n          case 'CHROME':\n            finishType = FINISH_TYPE_CHROME;\n            break;\n\n          case 'PEARLESCENT':\n            finishType = FINISH_TYPE_PEARLESCENT;\n            break;\n\n          case 'RUBBER':\n            finishType = FINISH_TYPE_RUBBER;\n            break;\n\n          case 'MATTE_METALLIC':\n            finishType = FINISH_TYPE_MATTE_METALLIC;\n            break;\n\n          case 'METAL':\n            finishType = FINISH_TYPE_METAL;\n            break;\n\n          case 'MATERIAL':\n            // Not implemented\n            lineParser.setToEnd();\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.';\n        }\n      }\n\n      var material = null;\n\n      switch (finishType) {\n        case FINISH_TYPE_DEFAULT:\n          material = new _three.MeshStandardMaterial({\n            color: colour,\n            roughness: 0.3,\n            envMapIntensity: 0.3,\n            metalness: 0\n          });\n          break;\n\n        case FINISH_TYPE_PEARLESCENT:\n          // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n          var specular = new _three.Color(colour);\n          var hsl = specular.getHSL({\n            h: 0,\n            s: 0,\n            l: 0\n          });\n          hsl.h = (hsl.h + 0.5) % 1;\n          hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n          specular.setHSL(hsl.h, hsl.s, hsl.l);\n          material = new _three.MeshPhongMaterial({\n            color: colour,\n            specular: specular,\n            shininess: 10,\n            reflectivity: 0.3\n          });\n          break;\n\n        case FINISH_TYPE_CHROME:\n          // Mirror finish surface\n          material = new _three.MeshStandardMaterial({\n            color: colour,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n\n        case FINISH_TYPE_RUBBER:\n          // Rubber finish\n          material = new _three.MeshStandardMaterial({\n            color: colour,\n            roughness: 0.9,\n            metalness: 0\n          });\n          canHaveEnvMap = false;\n          break;\n\n        case FINISH_TYPE_MATTE_METALLIC:\n          // Brushed metal finish\n          material = new _three.MeshStandardMaterial({\n            color: colour,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n\n        case FINISH_TYPE_METAL:\n          // Average metal finish\n          material = new _three.MeshStandardMaterial({\n            color: colour,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n      }\n\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n      material.userData.canHaveEnvMap = canHaveEnvMap;\n\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n\n      if (!edgeMaterial) {\n        // This is the material used for edges\n        edgeMaterial = new _three.LineBasicMaterial({\n          color: edgeColour,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + ' - Edge';\n        edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n        edgeMaterial.userData.conditionalEdgeMaterial = new _three.ShaderMaterial({\n          vertexShader: conditionalLineVertShader,\n          fragmentShader: conditionalLineFragShader,\n          uniforms: _three.UniformsUtils.merge([_three.UniformsLib.fog, {\n            diffuse: {\n              value: new _three.Color(edgeColour)\n            },\n            opacity: {\n              value: alpha\n            }\n          }]),\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n      }\n\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      return material;\n    } //\n\n  }, {\n    key: \"objectParse\",\n    value: function objectParse(text) {\n      // Retrieve data from the parent parse scope\n      var parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n      var mainColourCode = parentParseScope.mainColourCode;\n      var mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n      var currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n      var triangles;\n      var lineSegments;\n      var conditionalSegments;\n      var subobjects = [];\n      var category = null;\n      var keywords = null;\n\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n\n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var type = '';\n      var startingConstructionStep = false;\n      var scope = this;\n\n      function parseColourCode(lineParser, forEdge) {\n        // Parses next colour code and returns a THREE.Material\n        var colourCode = lineParser.getToken();\n\n        if (!forEdge && colourCode === '16') {\n          colourCode = mainColourCode;\n        }\n\n        if (forEdge && colourCode === '24') {\n          colourCode = mainEdgeColourCode;\n        }\n\n        var material = scope.getMaterial(colourCode);\n\n        if (!material) {\n          throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n        }\n\n        return material;\n      }\n\n      function parseVector(lp) {\n        var v = new _three.Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n\n        if (!scope.separateObjects) {\n          v.applyMatrix4(currentParseScope.currentMatrix);\n        }\n\n        return v;\n      } // Parse all line commands\n\n\n      for (var lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith('0 FILE ')) {\n            // Save previous embedded file in the cache\n            this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = '';\n          } else {\n            currentEmbeddedText += line + '\\n';\n          }\n\n          continue;\n        }\n\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n\n        if (lp.isAtTheEnd()) {\n          // Empty line\n          continue;\n        } // Parse the line type\n\n\n        var lineType = lp.getToken();\n        var material = void 0;\n        var segment = void 0;\n        var inverted = void 0;\n        var ccw = void 0;\n        var doubleSided = void 0;\n        var v0 = void 0,\n            v1 = void 0,\n            v2 = void 0,\n            v3 = void 0,\n            faceNormal = void 0;\n\n        switch (lineType) {\n          // Line type 0: Comment or META\n          case '0':\n            // Parse meta directive\n            var meta = lp.getToken();\n\n            if (meta) {\n              switch (meta) {\n                case '!LDRAW_ORG':\n                  type = lp.getToken();\n                  currentParseScope.triangles = [];\n                  currentParseScope.lineSegments = [];\n                  currentParseScope.conditionalSegments = [];\n                  currentParseScope.type = type;\n                  var isRoot = !parentParseScope.isFromParse;\n\n                  if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                    currentParseScope.groupObject = new _three.Group();\n                    currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                  } // If the scale of the object is negated then the triangle winding order\n                  // needs to be flipped.\n\n\n                  if (currentParseScope.matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                    currentParseScope.inverted = !currentParseScope.inverted;\n                  }\n\n                  triangles = currentParseScope.triangles;\n                  lineSegments = currentParseScope.lineSegments;\n                  conditionalSegments = currentParseScope.conditionalSegments;\n                  break;\n\n                case '!COLOUR':\n                  material = this.parseColourMetaDirective(lp);\n\n                  if (material) {\n                    this.addMaterial(material);\n                  } else {\n                    console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                  }\n\n                  break;\n\n                case '!CATEGORY':\n                  category = lp.getToken();\n                  break;\n\n                case '!KEYWORDS':\n                  var newKeywords = lp.getRemainingString().split(',');\n\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n\n                  break;\n\n                case 'FILE':\n                  if (lineIndex > 0) {\n                    // Start embedded text files parsing\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = '';\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n\n                  break;\n\n                case 'BFC':\n                  // Changes to the backface culling state\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n\n                    switch (token) {\n                      case 'CERTIFY':\n                      case 'NOCERTIFY':\n                        bfcCertified = token === 'CERTIFY';\n                        bfcCCW = true;\n                        break;\n\n                      case 'CW':\n                      case 'CCW':\n                        bfcCCW = token === 'CCW';\n                        break;\n\n                      case 'INVERTNEXT':\n                        bfcInverted = true;\n                        break;\n\n                      case 'CLIP':\n                      case 'NOCLIP':\n                        bfcCull = token === 'CLIP';\n                        break;\n\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n\n                  break;\n\n                case 'STEP':\n                  startingConstructionStep = true;\n                  break;\n              }\n            }\n\n            break;\n          // Line type 1: Sub-object file\n\n          case '1':\n            material = parseColourCode(lp);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new _three.Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n            if (scope.fileMap[fileName]) {\n              // Found the subobject path in the preloaded file path map\n              fileName = scope.fileMap[fileName];\n            } else {\n              // Standardized subfolders\n              if (fileName.startsWith('s/')) {\n                fileName = 'parts/' + fileName;\n              } else if (fileName.startsWith('48/')) {\n                fileName = 'p/' + fileName;\n              }\n            }\n\n            subobjects.push({\n              material: material,\n              matrix: matrix,\n              fileName: fileName,\n              originalFileName: fileName,\n              locationState: FILE_LOCATION_AS_IS,\n              url: null,\n              triedLowerCase: false,\n              inverted: bfcInverted !== currentParseScope.inverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          // Line type 2: Line segment\n\n          case '2':\n            material = parseColourCode(lp, true);\n            segment = {\n              material: material.userData.edgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp)\n            };\n            lineSegments.push(segment);\n            break;\n          // Line type 5: Conditional Line segment\n\n          case '5':\n            material = parseColourCode(lp, true);\n            segment = {\n              material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp),\n              c0: parseVector(lp),\n              c1: parseVector(lp)\n            };\n            conditionalSegments.push(segment);\n            break;\n          // Line type 3: Triangle\n\n          case '3':\n            material = parseColourCode(lp);\n            inverted = currentParseScope.inverted;\n            ccw = bfcCCW !== inverted;\n            doubleSided = !bfcCertified || !bfcCull;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n            } else {\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            _tempVec0.subVectors(v1, v0);\n\n            _tempVec1.subVectors(v2, v1);\n\n            faceNormal = new _three.Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n          // Line type 4: Quadrilateral\n\n          case '4':\n            material = parseColourCode(lp);\n            inverted = currentParseScope.inverted;\n            ccw = bfcCCW !== inverted;\n            doubleSided = !bfcCertified || !bfcCull;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n              v3 = parseVector(lp);\n            } else {\n              v3 = parseVector(lp);\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            _tempVec0.subVectors(v1, v0);\n\n            _tempVec1.subVectors(v2, v1);\n\n            faceNormal = new _three.Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v3,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v3,\n                v2: v2,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n        }\n      }\n\n      if (parsingEmbeddedFiles) {\n        this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n      }\n\n      currentParseScope.category = category;\n      currentParseScope.keywords = keywords;\n      currentParseScope.subobjects = subobjects;\n      currentParseScope.numSubobjects = subobjects.length;\n      currentParseScope.subobjectIndex = 0;\n    }\n  }, {\n    key: \"computeConstructionSteps\",\n    value: function computeConstructionSteps(model) {\n      // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n      var stepNumber = 0;\n      model.traverse(function (c) {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    }\n  }, {\n    key: \"processObject\",\n    value: function processObject(text, onProcessed, subobject, url) {\n      var scope = this;\n      var parseScope = scope.newParseScopeLevel();\n      parseScope.url = url;\n      var parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n      if (subobject) {\n        parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n        parseScope.matrix.copy(subobject.matrix);\n        parseScope.inverted = subobject.inverted;\n        parseScope.startingConstructionStep = subobject.startingConstructionStep;\n      } // Add to cache\n\n\n      var currentFileName = parentParseScope.currentFileName;\n\n      if (currentFileName !== null) {\n        currentFileName = parentParseScope.currentFileName.toLowerCase();\n      }\n\n      if (scope.subobjectCache[currentFileName] === undefined) {\n        scope.subobjectCache[currentFileName] = text;\n      } // Parse the object (returns a Group)\n\n\n      scope.objectParse(text);\n      var finishedCount = 0;\n      onSubobjectFinish();\n\n      function onSubobjectFinish() {\n        finishedCount++;\n\n        if (finishedCount === parseScope.subobjects.length + 1) {\n          finalizeObject();\n        } else {\n          // Once the previous subobject has finished we can start processing the next one in the list.\n          // The subobject processing shares scope in processing so it's important that they be loaded serially\n          // to avoid race conditions.\n          // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n          // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n          // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n          var _subobject = parseScope.subobjects[parseScope.subobjectIndex];\n          Promise.resolve().then(function () {\n            loadSubobject(_subobject);\n          });\n          parseScope.subobjectIndex++;\n        }\n      }\n\n      function finalizeObject() {\n        if (scope.smoothNormals && parseScope.type === 'Part') {\n          smoothNormals(parseScope.triangles, parseScope.lineSegments);\n        }\n\n        var isRoot = !parentParseScope.isFromParse;\n\n        if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n          var objGroup = parseScope.groupObject;\n\n          if (parseScope.triangles.length > 0) {\n            objGroup.add(createObject(parseScope.triangles, 3));\n          }\n\n          if (parseScope.lineSegments.length > 0) {\n            objGroup.add(createObject(parseScope.lineSegments, 2));\n          }\n\n          if (parseScope.conditionalSegments.length > 0) {\n            objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n          }\n\n          if (parentParseScope.groupObject) {\n            objGroup.name = parseScope.fileName;\n            objGroup.userData.category = parseScope.category;\n            objGroup.userData.keywords = parseScope.keywords;\n            parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n            parentParseScope.groupObject.add(objGroup);\n          }\n        } else {\n          var separateObjects = scope.separateObjects;\n          var parentLineSegments = parentParseScope.lineSegments;\n          var parentConditionalSegments = parentParseScope.conditionalSegments;\n          var parentTriangles = parentParseScope.triangles;\n          var lineSegments = parseScope.lineSegments;\n          var conditionalSegments = parseScope.conditionalSegments;\n          var triangles = parseScope.triangles;\n\n          for (var i = 0, l = lineSegments.length; i < l; i++) {\n            var ls = lineSegments[i];\n\n            if (separateObjects) {\n              ls.v0.applyMatrix4(parseScope.matrix);\n              ls.v1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentLineSegments.push(ls);\n          }\n\n          for (var _i5 = 0, _l4 = conditionalSegments.length; _i5 < _l4; _i5++) {\n            var os = conditionalSegments[_i5];\n\n            if (separateObjects) {\n              os.v0.applyMatrix4(parseScope.matrix);\n              os.v1.applyMatrix4(parseScope.matrix);\n              os.c0.applyMatrix4(parseScope.matrix);\n              os.c1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentConditionalSegments.push(os);\n          }\n\n          for (var _i6 = 0, _l5 = triangles.length; _i6 < _l5; _i6++) {\n            var tri = triangles[_i6];\n\n            if (separateObjects) {\n              tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n              tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n              tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n\n              _tempVec0.subVectors(tri.v1, tri.v0);\n\n              _tempVec1.subVectors(tri.v2, tri.v1);\n\n              tri.faceNormal.crossVectors(_tempVec0, _tempVec1).normalize();\n            }\n\n            parentTriangles.push(tri);\n          }\n        }\n\n        scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n        if (!parentParseScope.isFromParse) {\n          scope.computeConstructionSteps(parseScope.groupObject);\n        }\n\n        if (onProcessed) {\n          onProcessed(parseScope.groupObject);\n        }\n      }\n\n      function loadSubobject(subobject) {\n        parseScope.mainColourCode = subobject.material.userData.code;\n        parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n        parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n        var cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n\n        if (cached) {\n          scope.processObject(cached, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n          return;\n        } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n        // Update also subobject.locationState for the next try if this load fails.\n\n\n        var subobjectURL = subobject.fileName;\n        var newLocationState = FILE_LOCATION_NOT_FOUND;\n\n        switch (subobject.locationState) {\n          case FILE_LOCATION_AS_IS:\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case FILE_LOCATION_TRY_PARTS:\n            subobjectURL = 'parts/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case FILE_LOCATION_TRY_P:\n            subobjectURL = 'p/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case FILE_LOCATION_TRY_MODELS:\n            subobjectURL = 'models/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case FILE_LOCATION_TRY_RELATIVE:\n            subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case FILE_LOCATION_TRY_ABSOLUTE:\n            if (subobject.triedLowerCase) {\n              // Try absolute path\n              newLocationState = FILE_LOCATION_NOT_FOUND;\n            } else {\n              // Next attempt is lower case\n              subobject.fileName = subobject.fileName.toLowerCase();\n              subobjectURL = subobject.fileName;\n              subobject.triedLowerCase = true;\n              newLocationState = FILE_LOCATION_AS_IS;\n            }\n\n            break;\n\n          case FILE_LOCATION_NOT_FOUND:\n            // All location possibilities have been tried, give up loading this object\n            console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n            return;\n        }\n\n        subobject.locationState = newLocationState;\n        subobject.url = subobjectURL; // Load the subobject\n        // Use another file loader here so we can keep track of the subobject information\n        // and use it when processing the next model.\n\n        var fileLoader = new _three.FileLoader(scope.manager);\n        fileLoader.setPath(scope.path);\n        fileLoader.setRequestHeader(scope.requestHeader);\n        fileLoader.setWithCredentials(scope.withCredentials);\n        fileLoader.load(subobjectURL, function (text) {\n          scope.processObject(text, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n        }, undefined, function (err) {\n          onSubobjectError(err, subobject);\n        }, subobject);\n      }\n\n      function onSubobjectLoaded(subobjectGroup, subobject) {\n        if (subobjectGroup === null) {\n          // Try to reload\n          loadSubobject(subobject);\n          return;\n        }\n\n        scope.fileMap[subobject.originalFileName] = subobject.url;\n      }\n\n      function onSubobjectError(err, subobject) {\n        // Retry download from a different default possible location\n        loadSubobject(subobject);\n      }\n    }\n  }]);\n\n  return LDrawLoader;\n}(_three.Loader);\n\nexports.LDrawLoader = LDrawLoader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","startingConstructionStep","conditionalSegments","subobjects","n2","LDrawLoader","reflectivity","s","url","numConstructionSteps","canHaveEnvMap","separateObjects","prototype","transparent","fog","mainEdgeColourCode","n1","key","matrix","subobjectCache","__esModule","currentFileName","lineNumber","inverted","premultipliedAlpha","faceNormal","materials","triedLowerCase","n0","specular","vertexShader","name","configurable","currentMatrix","value","isConditionalLine","locationState","polygonOffset","enumerable","diffuse","c0","v0","constructionStep","writable","shininess","smoothNormals","fileName","keywords","line","envMapIntensity","numSubobjects","polygonOffsetFactor","lib","type","groupObject","triangles","__proto__","l","depthWrite","colourCode","mainColourCode","currentCharIndex","category","lineSegments","originalFileName","uniforms","h","metalness","parseScopesStack","fileMap","edgeMaterial","subobjectIndex","v1","roughness","isFromParse","color","code","opacity","currentChar","conditionalEdgeMaterial","c1","v2","constructor","lineLength","material"]],"~:compiled-at",1630917515895,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$LDrawLoader.js\",\n\"lineCount\":56,\n\"mappings\":\"AAAAA,cAAA,CAAA,oDAAA,CAAyE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAUjHC,QAASA,QAAO,CAACC,YAAD,CAAM,CAA6ED,OAAA,CAArD,UAAtB,GAAI,MAAOE,OAAX,EAA+D,QAA/D,GAAoC,MAAOA,OAAOC,CAAAA,QAAlD,CAAqFH,QAAgB,CAACC,GAAD,CAAM,CAAE,MAAO,OAAOA,IAAhB,CAA3G,CAAsJD,QAAgB,CAACC,GAAD,CAAM,CAAE,MAAOA,IAAA,EAAyB,UAAzB,GAAO,MAAOC,OAAd,EAAuCD,GAAIG,CAAAA,WAA3C,GAA2DF,MAA3D,EAAqED,GAArE,GAA6EC,MAAOG,CAAAA,SAApF,CAAgG,QAAhG,CAA2G,MAAOJ,IAA3H,CAAqI,OAAOD,QAAA,CAAQC,YAAR,CAA1T,CAMtBK,QAASA,gBAAe,CAACC,UAAD,CAAI,CAAED,eAAA,CAAkBE,MAAOC,CAAAA,cAAP,CAAwBD,MAAOE,CAAAA,cAA/B,CAAgDJ,QAAwB,CAACC,CAAD,CAAI,CAAE,MAAOA,EAAEI,CAAAA,SAAT;AAAsBH,MAAOE,CAAAA,cAAP,CAAsBH,CAAtB,CAAxB,CAAqD,OAAOD,gBAAA,CAAgBC,UAAhB,CAA5J,CAE5BK,QAASA,UAAS,CAACC,QAAD,CAAWC,UAAX,CAAuB,CAAE,GAA0B,UAA1B,GAAI,MAAOA,WAAX,EAAuD,IAAvD,GAAwCA,UAAxC,CAA+D,KAAM,KAAIC,SAAJ,CAAc,oDAAd,CAAN,CAA6EF,QAASR,CAAAA,SAAT,CAAqBG,MAAOQ,CAAAA,MAAP,CAAcF,UAAd,EAA4BA,UAAWT,CAAAA,SAAvC,CAAkD,CAAED,YAAa,CAAEa,MAAOJ,QAAT,CAAmBK,SAAU,CAAA,CAA7B,CAAmCC,aAAc,CAAA,CAAjD,CAAf,CAAlD,CAAiIL,WAAJ,EAAgBM,eAAA,CAAgBP,QAAhB,CAA0BC,UAA1B,CAAhT,CAEzCM,QAASA,gBAAe,CAACb,UAAD,CAAIc,UAAJ,CAAO,CAAED,eAAA,CAAkBZ,MAAOC,CAAAA,cAAzB,EAA2CW,QAAwB,CAACb,CAAD;AAAIc,CAAJ,CAAO,CAAEd,CAAEI,CAAAA,SAAF,CAAcU,CAAG,OAAOd,EAA1B,CAAgC,OAAOa,gBAAA,CAAgBb,UAAhB,CAAmBc,UAAnB,CAAnH,CAE/BC,QAASA,gBAAe,CAACC,QAAD,CAAWC,WAAX,CAAwB,CAAE,GAAI,EAAED,QAAF,WAAsBC,YAAtB,CAAJ,CAA0C,KAAM,KAAIT,SAAJ,CAAc,mCAAd,CAAN,CAA5C,CAEhDU,QAASA,kBAAiB,CAACC,MAAD,CAASC,KAAT,CAAgB,CAAE,IAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBD,KAAME,CAAAA,MAA1B,CAAkCD,CAAA,EAAlC,CAAuC,CAAE,IAAIE,WAAaH,KAAA,CAAMC,CAAN,CAAUE,WAAWC,CAAAA,UAAX,CAAwBD,UAAWC,CAAAA,UAAnC,EAAiD,CAAA,CAAOD,WAAWX,CAAAA,YAAX,CAA0B,CAAA,CAAU,QAAJ,EAAeW,WAAf,GAA2BA,UAAWZ,CAAAA,QAAtC,CAAiD,CAAA,CAAjD,CAAuDV,OAAOwB,CAAAA,cAAP,CAAsBN,MAAtB,CAA8BI,UAAWG,CAAAA,GAAzC,CAA8CH,UAA9C,CAA5K,CAAzC,CAE1CI,QAASA,aAAY,CAACV,WAAD;AAAcW,UAAd,CAA0BC,WAA1B,CAAuC,CAAMD,UAAJ,EAAgBV,iBAAA,CAAkBD,WAAYnB,CAAAA,SAA9B,CAAyC8B,UAAzC,CAA0DC,YAAJ,EAAiBX,iBAAA,CAAkBD,WAAlB,CAA+BY,WAA/B,CAA6C,OAAOZ,YAA7I,CA6B5Da,QAASA,cAAa,CAACC,SAAD,CAAYC,YAAZ,CAA0B,CAC9CC,QAASA,WAAU,CAACC,CAAD,CAAI,CAKrB,IAAIC,EAAI,CAAC,EAAQ,GAAR,CAAED,CAAEC,CAAAA,CAAJ,CAAT,CACIC,EAAI,CAAC,EAAQ,GAAR,CAAEF,CAAEE,CAAAA,CAAJ,CACT,OAAO,EAAGC,CAAAA,MAAH,CAHCC,CAAC,EAAQ,GAAR,CAAEJ,CAAEI,CAAAA,CAAJ,CAGF,CAAa,GAAb,CAAkBD,CAAAA,MAAlB,CAAyBF,CAAzB,CAA4B,GAA5B,CAAiCE,CAAAA,MAAjC,CAAwCD,CAAxC,CAPc,CAUvBG,QAASA,SAAQ,CAACC,EAAD,CAAKC,EAAL,CAAS,CACxB,MAAO,EAAGJ,CAAAA,MAAH,CAAUJ,UAAA,CAAWO,EAAX,CAAV,CAA0B,GAA1B,CAA+BH,CAAAA,MAA/B,CAAsCJ,UAAA,CAAWQ,EAAX,CAAtC,CADiB,CAS1B,IALA,IAAIC,UAAY,IAAIC,GAApB,CACIC,aAAe,EADnB,CAEIC,iBAAmB,EAFvB,CAGIC,QAAU,EAHd,CAKSzB,EAAI,CALb,CAKgB0B,EAAIf,YAAaV,CAAAA,MAAjC,CAAyCD,CAAzC;AAA6C0B,CAA7C,CAAgD1B,CAAA,EAAhD,CAAqD,CACnD,IAAI2B,GAAKhB,YAAA,CAAaX,CAAb,CAAT,CACImB,YAAKQ,EAAGR,CAAAA,EACRC,GAAAA,CAAKO,EAAGP,CAAAA,EACZC,UAAUO,CAAAA,GAAV,CAAcV,QAAA,CAASC,WAAT,CAAaC,EAAb,CAAd,CACAC,UAAUO,CAAAA,GAAV,CAAcV,QAAA,CAASE,EAAT,CAAaD,WAAb,CAAd,CALmD,CAS5CU,YAAAA,CAAK,CAAd,KAAiBC,CAAjB,CAAsBpB,SAAUT,CAAAA,MAAhC,CAAwC4B,YAAxC,CAA6CC,CAA7C,CAAiDD,YAAA,EAAjD,CAGE,IAFIE,CAEKC,CAFCtB,SAAA,CAAUmB,YAAV,CAEDG,CAAAA,WAAAA,CAAK,CAAd,CAAsBC,CAAtB,CAAyBD,WAAzB,CAAkCA,WAAA,EAAlC,CAAwC,CAEtC,IAAIE,MAAQF,WAARE,CAAa,CAAbA,EAAkB,CAClBC,GAAAA,CAAKJ,CAAA,CAAI,GAAIf,CAAAA,MAAJ,CAFDgB,WAEC,CAAJ,CACLI,KAAAA,CAAML,CAAA,CAAI,GAAIf,CAAAA,MAAJ,CAAWkB,IAAX,CAAJ,CACNG,GAAAA,CAAOnB,QAAA,CAASiB,EAAT,CAAaC,IAAb,CAEPf,UAAUiB,CAAAA,GAAV,CAAcD,EAAd,CAAJ,GACAd,YAAA,CAAac,EAAb,CACA,CADqBN,CACrB,CAAAP,gBAAA,CAAiBa,EAAjB,CAAA,CAAyBN,CAFzB,CAPsC,CAoB1C,IAAA,CAAA,CAAA,CAAa,CAEPQ,SAAAA,CAAY3D,MAAO4D,CAAAA,IAAP,CAAYjB,YAAZ,CAChB,IAAyB,CAAzB,GAAIgB,SAAUtC,CAAAA,MAAd,CAA4B,KAExBwC;SAAAA,CAAM,CAGV,KAFIC,SAEJ,CAFY,CAAClB,gBAAA,CAAiBe,SAAA,CAAU,CAAV,CAAjB,CAAD,CAEZ,CAAOE,SAAP,CAAaC,SAAMzC,CAAAA,MAAnB,CAAA,CAsBE,IApBI0C,YAoBKC,CApBEF,SAAA,CAAMD,SAAN,CAoBFG,CAnBTH,SAAA,EAmBSG,CAlBLC,CAkBKD,CAlBQD,YAAKE,CAAAA,UAkBbD,CAhBO,IAgBPA,GAhBLD,YAAKG,CAAAA,EAgBAF,GAfPD,YAAKG,CAAAA,EACL,CADUD,CAAWE,CAAAA,KAAX,EACV,CAAAtB,OAAQuB,CAAAA,IAAR,CAAaL,YAAKG,CAAAA,EAAlB,CAcOF,EAXO,IAWPA,GAXLD,YAAKM,CAAAA,EAWAL,GAVPD,YAAKM,CAAAA,EACL,CADUJ,CAAWE,CAAAA,KAAX,EACV,CAAAtB,OAAQuB,CAAAA,IAAR,CAAaL,YAAKM,CAAAA,EAAlB,CASOL,EANO,IAMPA,GANLD,YAAKO,CAAAA,EAMAN,GALPD,YAAKO,CAAAA,EACL,CADUL,CAAWE,CAAAA,KAAX,EACV,CAAAtB,OAAQuB,CAAAA,IAAR,CAAaL,YAAKO,CAAAA,EAAlB,CAION,EAAAA,CAAAA,CAAM,CAAf,CAAwBO,CAAxB,CAA2BP,CAA3B,CAAsCA,CAAA,EAAtC,CAA6C,CACvCQ,CAAAA,CAASR,CAETS,YAAAA,EAAST,CAATS,CAAe,CAAfA,EAAoB,CAEpBC,GAAAA,CAAMX,YAAA,CAAK,GAAI3B,CAAAA,MAAJ,CAAWoC,CAAX,CAAL,CAENG,KAAAA,CAAMZ,YAAA,CAAK,GAAI3B,CAAAA,MAAJ,CAAWqC,WAAX,CAAL,CAGV;IAAIG,MAAQtC,QAAA,CAASoC,EAAT,CAAcC,IAAd,CAEZ,QAAOhC,YAAA,CAAaiC,KAAb,CACP,KAAIC,YAAcvC,QAAA,CAASqC,IAAT,CAAcD,EAAd,CAGlB,KAFII,EAEJ,CAFelC,gBAAA,CAAiBiC,WAAjB,CAEf,GAIM,EAAqD,GAArD,CAAAE,IAAKC,CAAAA,GAAL,CAASF,EAASb,CAAAA,UAAWgB,CAAAA,GAApB,CAAwBlB,YAAKE,CAAAA,UAA7B,CAAT,CAAA,CAJN,CAIE,CAOIY,WAAJ,GAAmBlC,aAAnB,GACEmB,SAAMM,CAAAA,IAAN,CAAWU,EAAX,CACA,CAAA,OAAOnC,YAAA,CAAakC,WAAb,CAFT,CAMA,KAjBY,IAiBHK,GAAK,CAAd,CAAsBC,CAAtB,CAAyBD,EAAzB,CAAkCA,EAAA,EAAlC,CAAwC,CAClCE,KAAAA,CAAaF,EACbG,KAAAA,EAAaH,EAAbG,CAAkB,CAAlBA,EAAuB,CAC3B,KAAIC,QAAUR,EAAA,CAAS,GAAI1C,CAAAA,MAAJ,CAAWgD,KAAX,CAAT,CAAd,CACIG,QAAUT,EAAA,CAAS,GAAI1C,CAAAA,MAAJ,CAAWiD,IAAX,CAAT,CAGd,IAFgB/C,QAAAkD,CAASF,OAATE,CAAkBD,OAAlBC,CAEhB,GAAkBX,WAAlB,CAA+B,CACY,IAAzC,GAAIC,EAAA,CAAS,GAAI1C,CAAAA,MAAJ,CAAWgD,KAAX,CAAT,CAAJ,GACMK,WAGJ,CAHW1B,YAAA,CAAK,GAAI3B,CAAAA,MAAJ,CAAWqC,WAAX,CAAL,CAGX;AADAK,EAAA,CAAS,GAAI1C,CAAAA,MAAJ,CAAWgD,KAAX,CAAT,CACA,CADmCK,WACnC,CAAAA,WAAKzC,CAAAA,GAAL,CAAS8B,EAASb,CAAAA,UAAlB,CAJF,CAOwC,KAAxC,GAAIa,EAAA,CAAS,GAAI1C,CAAAA,MAAJ,CAAWiD,IAAX,CAAT,CAAJ,GACMK,CAIJ,CAJY3B,YAAA,CAAK,GAAI3B,CAAAA,MAAJ,CAAWoC,CAAX,CAAL,CAIZ,CAFAM,EAAA,CAAS,GAAI1C,CAAAA,MAAJ,CAAWiD,IAAX,CAAT,CAEA,CAFkCK,CAElC,CAAAA,CAAM1C,CAAAA,GAAN,CAAU8B,EAASb,CAAAA,UAAnB,CALF,CAQA,MAhB6B,CAPO,CAbxC,CApByC,CA9BpC,CA+FJ0B,YAAAA,CAAM,CAAf,KAAkBC,gBAAlB,CAAwB/C,OAAQxB,CAAAA,MAAhC,CAAwCsE,YAAxC,CAA8CC,gBAA9C,CAAmDD,YAAA,EAAnD,CACE9C,OAAA,CAAQ8C,YAAR,CAAaE,CAAAA,SAAb,EApJ4C,CAwJhDC,QAASA,gBAAe,CAACC,IAAD,CAAO,CAC7B,MAAO,YAAaC,CAAAA,IAAb,CAAkBD,IAAlB,CAAP,EAA2C,SAA3C,GAAkCA,IADL,CA0E/BE,QAASA,eAAc,CAACC,CAAD,CAAIC,CAAJ,CAAO,CAC5B,MAAID,EAAEE,CAAAA,UAAN,GAAqBD,CAAEC,CAAAA,UAAvB,CACS,CADT,CAIIF,CAAEE,CAAAA,UAAN,CAAmBD,CAAEC,CAAAA,UAArB,CACS,EADT,CAIO,CATqB,CAY9BC,QAASA,aAAY,CAACC,QAAD;AAAWC,WAAX,CAAwBC,qBAAxB,CAA+C,CAIlEF,QAASG,CAAAA,IAAT,CAAcR,cAAd,CASA,KARA,IAAIS,UAAY,EAAhB,CACI7D,QAAU,EADd,CAEI8D,UAAY,EAFhB,CAGIC,eAAiB,IAAIC,MAAOC,CAAAA,cAHhC,CAIIC,aAAe,IAJnB,CAKIC,OAAS,CALb,CAMIC,cAAgB,CANpB,CAQSC,MAAQ,CARjB,CAQoBC,MAAQb,QAASjF,CAAAA,MAArC,CAA6C6F,KAA7C,CAAqDC,KAArD,CAA4DD,KAAA,EAA5D,CAAqE,CACnE,IAAIE,KAAOd,QAAA,CAASY,KAAT,CAAX,CACI3E,GAAK6E,IAAK7E,CAAAA,EADd,CAEIC,GAAK4E,IAAK5E,CAAAA,EAEdkE,UAAUtC,CAAAA,IAAV,CAAe7B,EAAGF,CAAAA,CAAlB,CAAqBE,EAAGL,CAAAA,CAAxB,CAA2BK,EAAGJ,CAAAA,CAA9B,CAAiCK,EAAGH,CAAAA,CAApC,CAAuCG,EAAGN,CAAAA,CAA1C,CAA6CM,EAAGL,CAAAA,CAAhD,CAEA,IAAoB,CAApB,GAAIoE,WAAJ,CAAuB,CACrBG,SAAUtC,CAAAA,IAAV,CAAegD,IAAKC,CAAAA,EAAGhF,CAAAA,CAAvB,CAA0B+E,IAAKC,CAAAA,EAAGnF,CAAAA,CAAlC,CAAqCkF,IAAKC,CAAAA,EAAGlF,CAAAA,CAA7C,CACI+B,GAAAA,CAAKkD,IAAKlD,CAAAA,EAAVA,EAAgBkD,IAAKnD,CAAAA,UACrBI,GAAAA,CAAK+C,IAAK/C,CAAAA,EAAVA,EAAgB+C,IAAKnD,CAAAA,UACzB,KAAIK,GAAK8C,IAAK9C,CAAAA,EAAVA,EAAgB8C,IAAKnD,CAAAA,UACzBpB,QAAQuB,CAAAA,IAAR,CAAaF,EAAG7B,CAAAA,CAAhB;AAAmB6B,EAAGhC,CAAAA,CAAtB,CAAyBgC,EAAG/B,CAAAA,CAA5B,CACAU,QAAQuB,CAAAA,IAAR,CAAaC,EAAGhC,CAAAA,CAAhB,CAAmBgC,EAAGnC,CAAAA,CAAtB,CAAyBmC,EAAGlC,CAAAA,CAA5B,CACAU,QAAQuB,CAAAA,IAAR,CAAaE,EAAGjC,CAAAA,CAAhB,CAAmBiC,EAAGpC,CAAAA,CAAtB,CAAyBoC,EAAGnC,CAAAA,CAA5B,CAPqB,CAUnB4E,YAAJ,GAAqBK,IAAKE,CAAAA,QAA1B,EACuB,IAOrB,GAPIP,YAOJ,EANEH,cAAeW,CAAAA,QAAf,CAAwBP,MAAxB,CAAgCC,aAAhC,CAA+CN,SAAUtF,CAAAA,MAAzD,CAAkE,CAAlE,CAMF,CAHAsF,SAAUvC,CAAAA,IAAV,CAAegD,IAAKE,CAAAA,QAApB,CAGA,CAFAP,YAEA,CAFeK,IAAKE,CAAAA,QAEpB,CADAN,MACA,CADSE,KACT,CADiBX,WACjB,CAAAU,aAAA,CAAgBV,WARlB,EAUEU,aAVF,EAUmBV,WA3BgD,CA+BjD,CAApB,CAAIU,aAAJ,EACEL,cAAeW,CAAAA,QAAf,CAAwBP,MAAxB,CAAgCQ,QAAhC,CAA0Cb,SAAUtF,CAAAA,MAApD,CAA6D,CAA7D,CAGFuF,eAAea,CAAAA,YAAf,CAA4B,UAA5B,CAAwC,IAAIZ,MAAOa,CAAAA,sBAAX,CAAkChB,SAAlC,CAA6C,CAA7C,CAAxC,CAEoB,EAApB,GAAIH,WAAJ;AACEK,cAAea,CAAAA,YAAf,CAA4B,QAA5B,CAAsC,IAAIZ,MAAOa,CAAAA,sBAAX,CAAkC7E,OAAlC,CAA2C,CAA3C,CAAtC,CAGE8E,UAAAA,CAAW,IAEK,EAApB,GAAIpB,WAAJ,CACEoB,SADF,CACa,IAAId,MAAOe,CAAAA,YAAX,CAAwBhB,cAAxB,CAAwCD,SAAxC,CADb,CAE2B,CAF3B,GAEWJ,WAFX,GAGEoB,SAHF,CAGa,IAAId,MAAOgB,CAAAA,IAAX,CAAgBjB,cAAhB,CAAgCD,SAAhC,CAHb,CAMA,IAAIH,qBAAJ,CAA2B,CACzBmB,SAASG,CAAAA,iBAAT,CAA6B,CAAA,CACzBC,YAAAA,CAAgB,IAAIC,YAAJ,CAAuC,CAAvC,CAAiB1B,QAASjF,CAAAA,MAA1B,CAChB4G,sBAAAA,CAAgB,IAAID,YAAJ,CAAuC,CAAvC,CAAiB1B,QAASjF,CAAAA,MAA1B,CAChB6G,UAAAA,CAAiB,IAAIF,YAAJ,CAAuC,CAAvC,CAAiB1B,QAASjF,CAAAA,MAA1B,CAEZD,QAAAA,CAAI,CAAb,KAAgB0B,YAAhB,CAAoBwD,QAASjF,CAAAA,MAA7B,CAAqCD,OAArC;AAAyC0B,YAAzC,CAA4C1B,OAAA,EAA5C,CACM+G,KAuBJ,CAvBS7B,QAAA,CAASlF,OAAT,CAuBT,CAtBIgH,MAsBJ,CAtBSD,KAAGC,CAAAA,EAsBZ,CArBIC,aAqBJ,CArBSF,KAAGE,CAAAA,EAqBZ,CApBIC,KAoBJ,CApBUH,KAAG5F,CAAAA,EAoBb,CAnBIgG,KAmBJ,CAnBUJ,KAAG3F,CAAAA,EAmBb,CAlBIgG,IAkBJ,CAlBoB,CAkBpB,CAlBYpH,OAkBZ,CAjBA2G,WAAA,CAAcS,IAAd,CAAsB,CAAtB,CAiBA,CAjB2BJ,MAAG/F,CAAAA,CAiB9B,CAhBA0F,WAAA,CAAcS,IAAd,CAAsB,CAAtB,CAgBA,CAhB2BJ,MAAGlG,CAAAA,CAgB9B,CAfA6F,WAAA,CAAcS,IAAd,CAAsB,CAAtB,CAeA,CAf2BJ,MAAGjG,CAAAA,CAe9B,CAdA4F,WAAA,CAAcS,IAAd,CAAsB,CAAtB,CAcA,CAd2BJ,MAAG/F,CAAAA,CAc9B,CAbA0F,WAAA,CAAcS,IAAd,CAAsB,CAAtB,CAaA,CAb2BJ,MAAGlG,CAAAA,CAa9B,CAZA6F,WAAA,CAAcS,IAAd,CAAsB,CAAtB,CAYA,CAZ2BJ,MAAGjG,CAAAA,CAY9B,CAXA8F,qBAAA,CAAcO,IAAd,CAAsB,CAAtB,CAWA,CAX2BH,aAAGhG,CAAAA,CAW9B,CAVA4F,qBAAA,CAAcO,IAAd,CAAsB,CAAtB,CAUA,CAV2BH,aAAGnG,CAAAA,CAU9B,CATA+F,qBAAA,CAAcO,IAAd,CAAsB,CAAtB,CASA,CAT2BH,aAAGlG,CAAAA,CAS9B,CARA8F,qBAAA,CAAcO,IAAd,CAAsB,CAAtB,CAQA,CAR2BH,aAAGhG,CAAAA,CAQ9B,CAPA4F,qBAAA,CAAcO,IAAd;AAAsB,CAAtB,CAOA,CAP2BH,aAAGnG,CAAAA,CAO9B,CANA+F,qBAAA,CAAcO,IAAd,CAAsB,CAAtB,CAMA,CAN2BH,aAAGlG,CAAAA,CAM9B,CALA+F,SAAA,CAAeM,IAAf,CAAuB,CAAvB,CAKA,CAL4BD,KAAIlG,CAAAA,CAKhC,CALoCiG,KAAIjG,CAAAA,CAKxC,CAJA6F,SAAA,CAAeM,IAAf,CAAuB,CAAvB,CAIA,CAJ4BD,KAAIrG,CAAAA,CAIhC,CAJoCoG,KAAIpG,CAAAA,CAIxC,CAHAgG,SAAA,CAAeM,IAAf,CAAuB,CAAvB,CAGA,CAH4BD,KAAIpG,CAAAA,CAGhC,CAHoCmG,KAAInG,CAAAA,CAGxC,CAFA+F,SAAA,CAAeM,IAAf,CAAuB,CAAvB,CAEA,CAF4BD,KAAIlG,CAAAA,CAEhC,CAFoCiG,KAAIjG,CAAAA,CAExC,CADA6F,SAAA,CAAeM,IAAf,CAAuB,CAAvB,CACA,CAD4BD,KAAIrG,CAAAA,CAChC,CADoCoG,KAAIpG,CAAAA,CACxC,CAAAgG,SAAA,CAAeM,IAAf,CAAuB,CAAvB,CAAA,CAA4BD,KAAIpG,CAAAA,CAAhC,CAAoCmG,KAAInG,CAAAA,CAG1CyE,eAAea,CAAAA,YAAf,CAA4B,UAA5B,CAAwC,IAAIZ,MAAO4B,CAAAA,eAAX,CAA2BV,WAA3B,CAA0C,CAA1C,CAA6C,CAAA,CAA7C,CAAxC,CACAnB,eAAea,CAAAA,YAAf,CAA4B,UAA5B,CAAwC,IAAIZ,MAAO4B,CAAAA,eAAX,CAA2BR,qBAA3B,CAA0C,CAA1C,CAA6C,CAAA,CAA7C,CAAxC,CACArB,eAAea,CAAAA,YAAf,CAA4B,WAA5B,CAAyC,IAAIZ,MAAO4B,CAAAA,eAAX,CAA2BP,SAA3B;AAA2C,CAA3C,CAA8C,CAAA,CAA9C,CAAzC,CAnCyB,CAsC3B,MAAOP,UApG2D,CAlSpE3H,MAAOwB,CAAAA,cAAP,CAAsBjC,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CkB,MAAO,CAAA,CADoC,CAA7C,CAGAlB,QAAQmJ,CAAAA,WAAR,CAAsB,IAAK,EAE3B,KAAI7B,OAASxH,OAAA,CAAQ,8CAAR,CAAb,CA2CIsJ,UAAY,IAAI9B,MAAO+B,CAAAA,OA3C3B,CA6CIC,UAAY,IAAIhC,MAAO+B,CAAAA,OA7C3B,CA2MIE,WAEJ,QAAS,EAAG,CACVA,QAASA,WAAU,CAACC,IAAD,CAAOC,UAAP,CAAmB,CACpClI,eAAA,CAAgB,IAAhB,CAAsBgI,UAAtB,CAEA,KAAKC,CAAAA,IAAL,CAAYA,IACZ,KAAKE,CAAAA,UAAL,CAAkBF,IAAK1H,CAAAA,MACvB,KAAK6H,CAAAA,gBAAL,CAAwB,CACxB,KAAKC,CAAAA,WAAL,CAAmB,GACnB,KAAKH,CAAAA,UAAL,CAAkBA,UAPkB,CAUtCtH,YAAA,CAAaoH,UAAb,CAAyB,CAAC,CACxBrH,IAAK,cADmB,CAExBhB,MAAO2I,QAAqB,EAAG,CAC7B,IAAA,CAAO,IAAKF,CAAAA,gBAAZ;AAA+B,IAAKD,CAAAA,UAApC,CAAA,CAAgD,CAC9C,IAAKE,CAAAA,WAAL,CAAmB,IAAKJ,CAAAA,IAAKM,CAAAA,MAAV,CAAiB,IAAKH,CAAAA,gBAAtB,CAEnB,IAAyB,GAAzB,GAAI,IAAKC,CAAAA,WAAT,EAAqD,IAArD,GAAgC,IAAKA,CAAAA,WAArC,CACE,KAGF,KAAKD,CAAAA,gBAAL,EAP8C,CADnB,CAFP,CAAD,CAatB,CACDzH,IAAK,UADJ,CAEDhB,MAAO6I,QAAiB,EAAG,CAGzB,IAFA,IAAIC,KAAO,IAAKL,CAAAA,gBAAL,EAEX,CAAO,IAAKA,CAAAA,gBAAZ,CAA+B,IAAKD,CAAAA,UAApC,CAAA,CAAgD,CAC9C,IAAKE,CAAAA,WAAL,CAAmB,IAAKJ,CAAAA,IAAKM,CAAAA,MAAV,CAAiB,IAAKH,CAAAA,gBAAtB,CAEnB,IAAyB,GAAzB,GAAI,IAAKC,CAAAA,WAAT,EAAqD,IAArD,GAAgC,IAAKA,CAAAA,WAArC,CACE,KAGF,KAAKD,CAAAA,gBAAL,EAP8C,CAUhD,IAAIM,KAAO,IAAKN,CAAAA,gBAChB,KAAKE,CAAAA,YAAL,EACA,OAAO,KAAKL,CAAAA,IAAKU,CAAAA,SAAV,CAAoBF,IAApB,CAA0BC,IAA1B,CAfkB,CAF1B,CAbsB,CAgCtB,CACD/H,IAAK,oBADJ;AAEDhB,MAAOiJ,QAA2B,EAAG,CACnC,MAAO,KAAKX,CAAAA,IAAKU,CAAAA,SAAV,CAAoB,IAAKP,CAAAA,gBAAzB,CAA2C,IAAKD,CAAAA,UAAhD,CAD4B,CAFpC,CAhCsB,CAqCtB,CACDxH,IAAK,YADJ,CAEDhB,MAAOkJ,QAAmB,EAAG,CAC3B,MAAO,KAAKT,CAAAA,gBAAZ,EAAgC,IAAKD,CAAAA,UADV,CAF5B,CArCsB,CA0CtB,CACDxH,IAAK,UADJ,CAEDhB,MAAOmJ,QAAiB,EAAG,CACzB,IAAKV,CAAAA,gBAAL,CAAwB,IAAKD,CAAAA,UADJ,CAF1B,CA1CsB,CA+CtB,CACDxH,IAAK,qBADJ,CAEDhB,MAAOoJ,QAA4B,EAAG,CACpC,MAA0B,EAAnB,EAAA,IAAKb,CAAAA,UAAL,CAAuB,WAAvB,CAAqC,IAAKA,CAAAA,UAA1C,CAAuD,EAD1B,CAFrC,CA/CsB,CAAzB,CAsDA,OAAOF,WAjEG,CAAZ,EAwLIJ,OAAAA,CAEJ,QAAS,CAACoB,OAAD,CAAU,CAGjBpB,QAASA,YAAW,CAACqB,OAAD,CAAU,CAG5BjJ,eAAA,CAAgB,IAAhB,CAAsB4H,WAAtB,CAEyC,QAAA,CAAA5I,eAAA,CAAgB4I,WAAhB,CAA6BsB,CAAAA,IAA7B,CAAkC,IAAlC;AAAwCD,OAAxC,CA3YK,IAAIC,CAAAA,OAAJ,EAA+B,QAA/B,GAAaxK,OAAA,CAAQwK,OAAR,CAAb,EAA2D,UAA3D,GAA2C,MAAOA,QAAlD,CAAA,CAEV,GAAa,IAAK,EAAlB,GAF0GC,IAE1G,CAAuB,KAAM,KAAIC,cAAJ,CAAmB,2DAAnB,CAAN,CAAyF,OAAA,CAFND,IAAhG,CAgZ9CE,OAAMC,CAAAA,gBAAN,CAAyB,IAEzBD,QAAMxD,CAAAA,SAAN,CAAkB,EAGlBwD,QAAME,CAAAA,cAAN,CAAuB,EAEvBF,QAAMG,CAAAA,OAAN,CAAgB,IAEhBH,QAAMI,CAAAA,YAAN,CAAmB,CAACJ,OAAMK,CAAAA,wBAAN,CAA+B,IAAI1B,UAAJ,CAAe,gDAAf,CAA/B,CAAD,CAAmGqB,OAAMK,CAAAA,wBAAN,CAA+B,IAAI1B,UAAJ,CAAe,gDAAf,CAA/B,CAAnG,CAAnB,CAIAqB;OAAMM,CAAAA,eAAN,CAAwB,CAAA,CAExBN,QAAMtI,CAAAA,aAAN,CAAsB,CAAA,CACtB,OAAOsI,QA1BqB,CAF9B/J,SAAA,CAAUsI,WAAV,CAAuBoB,OAAvB,CA+BApI,aAAA,CAAagH,WAAb,CAA0B,CAAC,CACzBjH,IAAK,MADoB,CAEzBhB,MAAOiK,QAAa,CAACC,GAAD,CAAMC,MAAN,CAAcC,UAAd,CAA0BC,OAA1B,CAAmC,CAChD,IAAKR,CAAAA,OAAV,GACE,IAAKA,CAAAA,OADP,CACiB,EADjB,CAIA,KAAIS,MAAQ,IAAZ,CACIC,WAAa,IAAInE,MAAOoE,CAAAA,UAAX,CAAsB,IAAKlB,CAAAA,OAA3B,CACjBiB,WAAWE,CAAAA,OAAX,CAAmB,IAAKC,CAAAA,IAAxB,CACAH,WAAWI,CAAAA,gBAAX,CAA4B,IAAKC,CAAAA,aAAjC,CACAL,WAAWM,CAAAA,kBAAX,CAA8B,IAAKC,CAAAA,eAAnC,CACAP,WAAWN,CAAAA,IAAX,CAAgBC,GAAhB,CAAqB,QAAS,CAACa,IAAD,CAAO,CACnCT,KAAMU,CAAAA,aAAN,CAAoBD,IAApB,CAA0BZ,MAA1B,CAAkC,IAAlC,CAAwCD,GAAxC,CADmC,CAArC,CAEGE,UAFH,CAEeC,OAFf,CAVqD,CAF9B,CAAD;AAgBvB,CACDrJ,IAAK,OADJ,CAEDhB,MAAOiL,QAAc,CAACF,IAAD,CAAOL,IAAP,CAAaP,MAAb,CAAqB,CAExC,IAAKa,CAAAA,aAAL,CAAmBD,IAAnB,CAAyBZ,MAAzB,CAAiC,IAAjC,CAAuCO,IAAvC,CAFwC,CAFzC,CAhBuB,CAsBvB,CACD1J,IAAK,cADJ,CAEDhB,MAAO8J,QAAqB,CAAC5D,SAAD,CAAY,CAEtC,IAAKyD,CAAAA,gBAAL,CAAwB,EACxB,KAAKuB,CAAAA,kBAAL,CAAwBhF,SAAxB,CACA,KAAKiF,CAAAA,oBAAL,EAA4BC,CAAAA,WAA5B,CAA0C,CAAA,CAC1C,KAAKlF,CAAAA,SAAL,CAAiBA,SACjB,OAAO,KAN+B,CAFvC,CAtBuB,CAgCvB,CACDlF,IAAK,YADJ,CAEDhB,MAAOqL,QAAmB,CAACxB,OAAD,CAAU,CAClC,IAAKA,CAAAA,OAAL,CAAeA,OACf,OAAO,KAF2B,CAFnC,CAhCuB,CAsCvB,CACD7I,IAAK,oBADJ,CAEDhB,MAAOkL,QAA2B,CAAChF,SAAD,CAAY,CAE5C,IAAIoF,OAAS,EAEb,IAAIpF,SAAJ,CACE,IADa,IACJvF,EAAI,CADA,CACG4K,EAAIrF,SAAUtF,CAAAA,MAA9B,CAAsCD,CAAtC,CAA0C4K,CAA1C,CAA6C5K,CAAA,EAA7C,CAAkD,CAChD,IAAIkG,SAAWX,SAAA,CAAUvF,CAAV,CACf2K,OAAA,CAAOzE,QAAS2E,CAAAA,QAASC,CAAAA,IAAzB,CAAA;AAAiC5E,QAFe,CAMhD6E,SAAAA,CAAgB,IAAKP,CAAAA,oBAAL,EAChBQ,OAAAA,CAAgB,CAClBC,IAAKN,MADa,CAElBpB,IAAK,IAFa,CAIlB2B,WAAY,IAJM,CAKlBC,cAAe,CALG,CAMlBC,eAAgB,CANE,CAOlBC,SAAU,CAAA,CAPQ,CAQlBC,SAAU,IARQ,CASlBC,SAAU,IATQ,CAWlBC,gBAAiB,IAXC,CAYlBC,eAAgBV,SAAA,CAAgBA,SAAcU,CAAAA,cAA9B,CAA+C,IAZ7C,CAalBC,mBAAoBX,SAAA,CAAgBA,SAAcW,CAAAA,kBAA9B,CAAmD,IAbrD,CAclBC,cAAe,IAAIlG,MAAOmG,CAAAA,OAdR,CAelBC,OAAQ,IAAIpG,MAAOmG,CAAAA,OAfD,CAiBlBnB,YAAa,CAAA,CAjBK,CAkBlB/J,UAAW,IAlBO,CAmBlBC,aAAc,IAnBI,CAoBlBmL,oBAAqB,IApBH,CAsBlBC,yBAA0B,CAAA,CAtBR,CAwBpB,KAAK/C,CAAAA,gBAAiBhG,CAAAA,IAAtB,CAA2BgI,MAA3B,CACA,OAAOA,OArCqC,CAF7C,CAtCuB;AA+EvB,CACD3K,IAAK,kBADJ,CAEDhB,MAAO2M,QAAyB,EAAG,CACjC,IAAKhD,CAAAA,gBAAiBiD,CAAAA,GAAtB,EACA,OAAO,KAF0B,CAFlC,CA/EuB,CAqFvB,CACD5L,IAAK,aADJ,CAEDhB,MAAO6M,QAAoB,CAAChG,QAAD,CAAW,CAEpC,IAAIyE,OAAS,IAAKH,CAAAA,oBAAL,EAA4BS,CAAAA,GAEpCN,OAAA,CAAOzE,QAAS2E,CAAAA,QAASC,CAAAA,IAAzB,CAAL,EACE,IAAKvF,CAAAA,SAAUvC,CAAAA,IAAf,CAAoBkD,QAApB,CAGFyE,OAAA,CAAOzE,QAAS2E,CAAAA,QAASC,CAAAA,IAAzB,CAAA,CAAiC5E,QACjC,OAAO,KAT6B,CAFrC,CArFuB,CAkGvB,CACD7F,IAAK,aADJ,CAEDhB,MAAO8M,QAAoB,CAACnH,UAAD,CAAa,CAEtC,GAAIA,UAAWoH,CAAAA,UAAX,CAAsB,KAAtB,CAAJ,CAGE,MADIC,WACG,CADMrH,UAAWqD,CAAAA,SAAX,CAAqB,CAArB,CACN,CAAA,IAAKe,CAAAA,wBAAL,CAA8B,IAAI1B,UAAJ,CAAe,eAAf,CAAiC2E,UAAjC,CAA0C,kBAA1C,CAA+DA,UAA/D;AAAwE,SAAxE,CAAoFA,UAApF,CAA9B,CAGT,KAAK,IAAIrM,EAAI,IAAKgJ,CAAAA,gBAAiB/I,CAAAA,MAA1BD,CAAmC,CAA5C,CAAoD,CAApD,EAA+CA,CAA/C,CAAuDA,CAAA,EAAvD,CAA4D,CAC1D,IAAIkG,SAAW,IAAK8C,CAAAA,gBAAL,CAAsBhJ,CAAtB,CAAyBiL,CAAAA,GAAzB,CAA6BjG,UAA7B,CAEf,IAAIkB,QAAJ,CACE,MAAOA,SAJiD,CAS5D,MAAO,KAjB+B,CAFvC,CAlGuB,CAuHvB,CACD7F,IAAK,qBADJ,CAEDhB,MAAOiN,QAA4B,EAAG,CACpC,MAAmC,EAAnC,CAAI,IAAKtD,CAAAA,gBAAiB/I,CAAAA,MAA1B,CACS,IAAK+I,CAAAA,gBAAL,CAAsB,IAAKA,CAAAA,gBAAiB/I,CAAAA,MAA5C,CAAqD,CAArD,CADT,CAIO,IAL6B,CAFrC,CAvHuB,CAgIvB,CACDI,IAAK,sBADJ,CAEDhB,MAAOmL,QAA6B,EAAG,CACrC,MAAmC,EAAnC,CAAI,IAAKxB,CAAAA,gBAAiB/I,CAAAA,MAA1B,CACS,IAAK+I,CAAAA,gBAAL,CAAsB,IAAKA,CAAAA,gBAAiB/I,CAAAA,MAA5C,CAAqD,CAArD,CADT,CAIO,IAL8B,CAFtC,CAhIuB,CAyIvB,CACDI,IAAK,0BADJ,CAEDhB,MAAO+J,QAAiC,CAACmD,UAAD,CAAa,CAEnD,IAAIzB;AAAO,IAAX,CAEIuB,OAAS,QAFb,CAGIG,WAAa,QAHjB,CAKIC,MAAQ,CALZ,CAMIC,cAAgB,CAAA,CANpB,CAQIC,UAAY,CARhB,CASIC,WAxiBgBC,CA+hBpB,CAUIC,cAAgB,CAAA,CAVpB,CAWIC,aAAe,IAXnB,CAYIC,KAAOT,UAAWrE,CAAAA,QAAX,EAEX,IAAI,CAAC8E,IAAL,CACE,KAAM,4DAAN,CAAqET,UAAW9D,CAAAA,mBAAX,EAArE,CAAwG,GAAxG,CAMF,IAFA,IAAIwE,KAEJ,CAAA,CAAA,CAAa,CACXA,KAAA,CAAQV,UAAWrE,CAAAA,QAAX,EAER,IAAI,CAAC+E,KAAL,CACE,KAGF,QAAQA,KAAMC,CAAAA,WAAN,EAAR,EACE,KAAK,MAAL,CACEpC,IAAA,CAAOyB,UAAWrE,CAAAA,QAAX,EACP,MAEF,MAAK,OAAL,CACEmE,MAAA,CAASE,UAAWrE,CAAAA,QAAX,EAET,IAAImE,MAAOD,CAAAA,UAAP,CAAkB,IAAlB,CAAJ,CACEC,MAAA,CAAS,GAAT,CAAeA,MAAOhE,CAAAA,SAAP,CAAiB,CAAjB,CADjB,KAEO,IAAI,CAACgE,MAAOD,CAAAA,UAAP,CAAkB,GAAlB,CAAL,CACL,KAAM,oDAAN;AAA6DG,UAAW9D,CAAAA,mBAAX,EAA7D,CAAgG,GAAhG,CAGF,KAEF,MAAK,MAAL,CACE+D,UAAA,CAAaD,UAAWrE,CAAAA,QAAX,EAEb,IAAIsE,UAAWJ,CAAAA,UAAX,CAAsB,IAAtB,CAAJ,CACEI,UAAA,CAAa,GAAb,CAAmBA,UAAWnE,CAAAA,SAAX,CAAqB,CAArB,CADrB,KAEO,IAAI,CAACmE,UAAWJ,CAAAA,UAAX,CAAsB,GAAtB,CAAL,CAAiC,CAEtCW,YAAA,CAAe,IAAKZ,CAAAA,WAAL,CAAiBK,UAAjB,CAEf,IAAI,CAACO,YAAL,CACE,KAAM,yDAAN,CAAkER,UAAW9D,CAAAA,mBAAX,EAAlE,CAAqG,GAArG,CAIFsE,YAAA,CAAeA,YAAalC,CAAAA,QAASkC,CAAAA,YATC,CAYxC,KAEF,MAAK,OAAL,CACEN,KAAA,CAAQU,QAAA,CAASZ,UAAWrE,CAAAA,QAAX,EAAT,CAER,IAAIkF,KAAA,CAAMX,KAAN,CAAJ,CACE,KAAM,yDAAN;AAAkEF,UAAW9D,CAAAA,mBAAX,EAAlE,CAAqG,GAArG,CAGFgE,KAAA,CAAQ9I,IAAK0J,CAAAA,GAAL,CAAS,CAAT,CAAY1J,IAAK2J,CAAAA,GAAL,CAAS,CAAT,CAAYb,KAAZ,CAAoB,GAApB,CAAZ,CAEI,EAAZ,CAAIA,KAAJ,GACEC,aADF,CACkB,CAAA,CADlB,CAIA,MAEF,MAAK,WAAL,CACEC,SAAA,CAAYQ,QAAA,CAASZ,UAAWrE,CAAAA,QAAX,EAAT,CAEZ,IAAIkF,KAAA,CAAMT,SAAN,CAAJ,CACE,KAAM,6DAAN,CAAsEjF,UAAWe,CAAAA,mBAAX,EAAtE,CAAyG,GAAzG,CAGFkE,SAAA,CAAYhJ,IAAK0J,CAAAA,GAAL,CAAS,CAAT,CAAY1J,IAAK2J,CAAAA,GAAL,CAAS,CAAT,CAAYX,SAAZ,CAAwB,GAAxB,CAAZ,CACZ,MAEF,MAAK,QAAL,CACEC,UAAA,CAvnBaW,CAwnBb,MAEF,MAAK,aAAL,CACEX,UAAA,CA1nBkBY,CA2nBlB,MAEF,MAAK,QAAL,CACEZ,UAAA,CA7nBaa,CA8nBb,MAEF,MAAK,gBAAL,CACEb,UAAA,CAhoBqBc,CAioBrB,MAEF,MAAK,OAAL,CACEd,UAAA;AAnoBYe,CAooBZ,MAEF,MAAK,UAAL,CAEEpB,UAAW/D,CAAAA,QAAX,EACA,MAEF,SACE,KAAM,8BAAN,CAAuCyE,KAAvC,CAA+C,0BAA/C,CAA4EV,UAAW9D,CAAAA,mBAAX,EAA5E,CAA+G,GAA/G,CAtFJ,CAPW,CAiGTvC,UAAAA,CAAW,IAEf,QAAQ0G,UAAR,EACE,KAxpBkBC,CAwpBlB,CACE3G,UAAA,CAAW,IAAIT,MAAOmI,CAAAA,oBAAX,CAAgC,CACzCC,MAAOxB,MADkC,CAEzCyB,UAAW,EAF8B,CAGzCC,gBAAiB,EAHwB,CAIzCC,UAAW,CAJ8B,CAAhC,CAMX,MAEF,MA/pBsBR,CA+pBtB,CAEMS,UAAAA,CAAW,IAAIxI,MAAOyI,CAAAA,KAAX,CAAiB7B,MAAjB,CACX8B,WAAAA,CAAMF,UAASG,CAAAA,MAAT,CAAgB,CACxBC,EAAG,CADqB,CAExBC,EAAG,CAFqB,CAGxB5M,EAAG,CAHqB,CAAhB,CAKVyM,WAAIE,CAAAA,CAAJ,EAASF,UAAIE,CAAAA,CAAb,CAAiB,EAAjB,EAAwB,CACxBF,WAAIzM,CAAAA,CAAJ,CAAQiC,IAAK2J,CAAAA,GAAL,CAAS,CAAT,CAAYa,UAAIzM,CAAAA,CAAhB,CAAkC,EAAlC,EAAqB,CAArB,CAAyByM,UAAIzM,CAAAA,CAA7B,EACRuM,WAASM,CAAAA,MAAT,CAAgBJ,UAAIE,CAAAA,CAApB;AAAuBF,UAAIG,CAAAA,CAA3B,CAA8BH,UAAIzM,CAAAA,CAAlC,CACAwE,WAAA,CAAW,IAAIT,MAAO+I,CAAAA,iBAAX,CAA6B,CACtCX,MAAOxB,MAD+B,CAEtC4B,SAAUA,UAF4B,CAGtCQ,UAAW,EAH2B,CAItCC,aAAc,EAJwB,CAA7B,CAMX,MAEF,MAnrBiBnB,CAmrBjB,CAEErH,UAAA,CAAW,IAAIT,MAAOmI,CAAAA,oBAAX,CAAgC,CACzCC,MAAOxB,MADkC,CAEzCyB,UAAW,CAF8B,CAGzCE,UAAW,CAH8B,CAAhC,CAKX,MAEF,MA1rBiBP,CA0rBjB,CAEEvH,UAAA,CAAW,IAAIT,MAAOmI,CAAAA,oBAAX,CAAgC,CACzCC,MAAOxB,MADkC,CAEzCyB,UAAW,EAF8B,CAGzCE,UAAW,CAH8B,CAAhC,CAKXlB,cAAA,CAAgB,CAAA,CAChB,MAEF,MAnsByBY,CAmsBzB,CAEExH,UAAA,CAAW,IAAIT,MAAOmI,CAAAA,oBAAX,CAAgC,CACzCC,MAAOxB,MADkC,CAEzCyB,UAAW,EAF8B,CAGzCE,UAAW,EAH8B,CAAhC,CAKX,MAEF,MA3sBgBL,CA2sBhB,CAEEzH,UAAA,CAAW,IAAIT,MAAOmI,CAAAA,oBAAX,CAAgC,CACzCC,MAAOxB,MADkC;AAEzCyB,UAAW,EAF8B,CAGzCE,UAAW,GAH8B,CAAhC,CA3Df,CAmEA9H,UAASyI,CAAAA,WAAT,CAAuBjC,aACvBxG,WAAS0I,CAAAA,kBAAT,CAA8B,CAAA,CAC9B1I,WAAS2I,CAAAA,OAAT,CAAmBpC,KACnBvG,WAAS4I,CAAAA,UAAT,CAAsB,CAACpC,aACvBxG,WAAS6I,CAAAA,aAAT,CAAyB,CAAA,CACzB7I,WAAS8I,CAAAA,mBAAT,CAA+B,CAC/B9I,WAAS2E,CAAAA,QAASiC,CAAAA,aAAlB,CAAkCA,aAEhB,EAAlB,GAAIH,SAAJ,EACEzG,UAAS+I,CAAAA,QAASC,CAAAA,GAAlB,CAAsBhJ,UAAS2H,CAAAA,KAA/B,CAAsCsB,CAAAA,cAAtC,CAAqDxC,SAArD,CAGGI,aAAL,GAEEA,YAyBA,CAzBe,IAAItH,MAAO2J,CAAAA,iBAAX,CAA6B,CAC1CvB,MAAOrB,UADmC,CAE1CmC,YAAajC,aAF6B,CAG1CmC,QAASpC,KAHiC,CAI1CqC,WAAY,CAACpC,aAJ6B,CAA7B,CAyBf,CAnBAK,YAAalC,CAAAA,QAASC,CAAAA,IAmBtB;AAnB6BA,IAmB7B,CAlBAiC,YAAaC,CAAAA,IAkBb,CAlBoBA,IAkBpB,CAlB2B,SAkB3B,CAjBAD,YAAalC,CAAAA,QAASiC,CAAAA,aAiBtB,CAjBsC,CAAA,CAiBtC,CAfAC,YAAalC,CAAAA,QAASwE,CAAAA,uBAetB,CAfgD,IAAI5J,MAAO6J,CAAAA,cAAX,CAA0B,CACxEC,aAluBVC,osDAiuBkF;AAExEC,eAhuBVC,w2BA8tBkF;AAGxEC,SAAUlK,MAAOmK,CAAAA,aAAcC,CAAAA,KAArB,CAA2B,CAACpK,MAAOqK,CAAAA,WAAYC,CAAAA,GAApB,CAAyB,CAC5DC,QAAS,CACP3Q,MAAO,IAAIoG,MAAOyI,CAAAA,KAAX,CAAiB1B,UAAjB,CADA,CADmD,CAI5DqC,QAAS,CACPxP,MAAOoN,KADA,CAJmD,CAAzB,CAA3B,CAH8D,CAWxEsD,IAAK,CAAA,CAXmE,CAYxEpB,YAAajC,aAZ2D,CAaxEoC,WAAY,CAACpC,aAb2D,CAA1B,CAehD,CAAAK,YAAalC,CAAAA,QAASwE,CAAAA,uBAAwBxE,CAAAA,QAASiC,CAAAA,aAAvD,CAAuE,CAAA,CA3BzE,CA8BA5G,WAAS2E,CAAAA,QAASC,CAAAA,IAAlB,CAAyBA,IACzB5E,WAAS8G,CAAAA,IAAT,CAAgBA,IAChB9G,WAAS2E,CAAAA,QAASkC,CAAAA,YAAlB,CAAiCA,YACjC,OAAO7G,WA1O4C,CAFpD,CAzIuB,CAwXvB,CACD7F,IAAK,aADJ,CAEDhB,MAAO4Q,QAAoB,CAAC7F,IAAD,CAAO,CAiChC8F,QAASA,gBAAe,CAAC3D,UAAD,CAAa4D,OAAb,CAAsB,CAE5C,IAAInL,WAAauH,UAAWrE,CAAAA,QAAX,EAEZiI;OAAL,EAA+B,IAA/B,GAAgBnL,UAAhB,GACEA,UADF,CACeyG,cADf,CAII0E,QAAJ,EAA8B,IAA9B,GAAenL,UAAf,GACEA,UADF,CACe0G,kBADf,CAIIxF,QAAAA,CAAWyD,KAAMwC,CAAAA,WAAN,CAAkBnH,UAAlB,CAEf,IAAI,CAACkB,OAAL,CACE,KAAM,oCAAN,CAA6ClB,UAA7C,CAA0D,WAA1D,CAAwEuH,UAAW9D,CAAAA,mBAAX,EAAxE,CAA2G,qCAA3G,CAGF,MAAOvC,QAlBqC,CAqB9CkK,QAASA,YAAW,CAACC,EAAD,CAAK,CACnBxP,EAAAA,CAAI,IAAI4E,MAAO+B,CAAAA,OAAX,CAAmB8I,UAAA,CAAWD,EAAGnI,CAAAA,QAAH,EAAX,CAAnB,CAA8CoI,UAAA,CAAWD,EAAGnI,CAAAA,QAAH,EAAX,CAA9C,CAAyEoI,UAAA,CAAWD,EAAGnI,CAAAA,QAAH,EAAX,CAAzE,CAEHyB,MAAMN,CAAAA,eAAX,EACExI,EAAE0P,CAAAA,YAAF,CAAeC,iBAAkB7E,CAAAA,aAAjC,CAGF;MAAO9K,GAPgB,CApDzB,IAAI4P,iBAAmB,IAAKnE,CAAAA,mBAAL,EAAvB,CAEIb,eAAiBgF,gBAAiBhF,CAAAA,cAFtC,CAGIC,mBAAqB+E,gBAAiB/E,CAAAA,kBAH1C,CAII8E,kBAAoB,IAAKhG,CAAAA,oBAAL,EAJxB,CASIU,WAAa,EATjB,CAUII,SAAW,IAVf,CAWIC,SAAW,IAEc,GAA7B,GAAInB,IAAKsG,CAAAA,OAAL,CAAa,MAAb,CAAJ,GAEEtG,IAFF,CAESA,IAAKuG,CAAAA,OAAL,CAAa,OAAb,CAAsB,IAAtB,CAFT,CAKIC,KAAAA,CAAQxG,IAAKyG,CAAAA,KAAL,CAAW,IAAX,CA6CZ,KA5CA,IAAIC,SAAWF,IAAM3Q,CAAAA,MAArB,CACI8Q,qBAAuB,CAAA,CAD3B,CAEIC,wBAA0B,IAF9B,CAGIC,oBAAsB,IAH1B,CAIIC,aAAe,CAAA,CAJnB,CAKIC,OAAS,CAAA,CALb,CAMIC,YAAc,CAAA,CANlB,CAOIC,QAAU,CAAA,CAPd,CAQI1M,KAAO,EARX,CASIoH;AAA2B,CAAA,CAT/B,CAUIpC,MAAQ,IAVZ,CA4CS2H,UAAY,CAArB,CAAwBA,SAAxB,CAAoCR,QAApC,CAA8CQ,SAAA,EAA9C,CAEE,GADI3J,IACA,CADOiJ,IAAA,CAAMU,SAAN,CACP,CAAgB,CAAhB,GAAA3J,IAAK1H,CAAAA,MAAT,CAEA,GAAI8Q,oBAAJ,CACMpJ,IAAKyE,CAAAA,UAAL,CAAgB,SAAhB,CAAJ,EAEE,IAAKnD,CAAAA,cAAL,CAAoB+H,uBAAwBO,CAAAA,WAAxB,EAApB,CAGA,CAH6DN,mBAG7D,CADAD,uBACA,CAD0BrJ,IAAKU,CAAAA,SAAL,CAAe,CAAf,CAC1B,CAAA4I,mBAAA,CAAsB,EALxB,EAOEA,mBAPF,EAOyBtJ,IAPzB,CAOgC,IARlC,KAiBA,IAHI0I,IAGA,CAHK,IAAI3I,UAAJ,CAAeC,IAAf,CAAqB2J,SAArB,CAAiC,CAAjC,CAGL,CAFJjB,IAAGrI,CAAAA,YAAH,EAEI,CAAA,CAAAqI,IAAG9H,CAAAA,UAAH,EAAJ,CAAA,CAMA,IAAIiJ,SAAWnB,IAAGnI,CAAAA,QAAH,EAAf,CACIhC,SAAW,IAAK,EADpB,CAGImF,SADAoG,QACApG,CADU,IAAK,EAFnB,CAIIqG,IAAM,IAAK,EAJf,CAOItQ,GADAD,GACAC,CAFAuQ,QAEAvQ;AAFc,IAAK,EALvB,CAQI6E,GAAK,IAAK,EARd,CASI2L,GAAK,IAAK,EATd,CAUI/O,WAAa,IAAK,EAEtB,QAAQ2O,QAAR,EAEE,KAAK,GAAL,CAIE,GAFIK,QAEJ,CAFWxB,IAAGnI,CAAAA,QAAH,EAEX,CACE,OAAQ2J,QAAR,EACE,KAAK,YAAL,CACElN,IAAA,CAAO0L,IAAGnI,CAAAA,QAAH,EACPsI,kBAAkB9P,CAAAA,SAAlB,CAA8B,EAC9B8P,kBAAkB7P,CAAAA,YAAlB,CAAiC,EACjC6P,kBAAkB1E,CAAAA,mBAAlB,CAAwC,EACxC0E,kBAAkB7L,CAAAA,IAAlB,CAAyBA,IAGzB,IAFamN,CAACrB,gBAAiBhG,CAAAA,WAE/B,EAAcd,KAAMN,CAAAA,eAApB,EAAuC,CAAC3E,eAAA,CAAgBC,IAAhB,CAAxC,CACE6L,iBAAkBuB,CAAAA,WAClB,CADgC,IAAItM,MAAOuM,CAAAA,KAC3C,CAAAxB,iBAAkBuB,CAAAA,WAAYlH,CAAAA,QAASkB,CAAAA,wBAAvC,CAAkEyE,iBAAkBzE,CAAAA,wBAKzC;CAA7C,CAAIyE,iBAAkB3E,CAAAA,MAAOoG,CAAAA,WAAzB,EAAJ,GAAmDtI,KAAMN,CAAAA,eAAzD,EAA4E3E,eAAA,CAAgBC,IAAhB,CAA5E,EAAqG,CAACgF,KAAMN,CAAAA,eAA5G,IACEmH,iBAAkBnF,CAAAA,QADpB,CAC+B,CAACmF,iBAAkBnF,CAAAA,QADlD,CAIA,KAAA3K,UAAY8P,iBAAkB9P,CAAAA,SAC9B,KAAAC,aAAe6P,iBAAkB7P,CAAAA,YACjC,KAAAmL,oBAAsB0E,iBAAkB1E,CAAAA,mBACxC,MAEF,MAAK,SAAL,CAGE,CAFA5F,QAEA,CAFW,IAAKkD,CAAAA,wBAAL,CAA8BiH,IAA9B,CAEX,EACE,IAAKnE,CAAAA,WAAL,CAAiBhG,QAAjB,CADF,CAGEgM,OAAQC,CAAAA,IAAR,CAAa,qCAAb,CAAqD9B,IAAG5H,CAAAA,mBAAH,EAArD,CAGF,MAEF;KAAK,WAAL,CACE6C,QAAA,CAAW+E,IAAGnI,CAAAA,QAAH,EACX,MAEF,MAAK,WAAL,CACMkK,IAAAA,CAAc/B,IAAG/H,CAAAA,kBAAH,EAAwBuI,CAAAA,KAAxB,CAA8B,GAA9B,CAEO,EAAzB,CAAIuB,IAAYnS,CAAAA,MAAhB,GACOsL,QAIL,GAHEA,QAGF,CAHa,EAGb,EAAA6G,IAAYC,CAAAA,OAAZ,CAAoB,QAAS,CAACC,OAAD,CAAU,CACrC/G,QAASvI,CAAAA,IAAT,CAAcsP,OAAQC,CAAAA,IAAR,EAAd,CADqC,CAAvC,CALF,CAUA,MAEF,MAAK,MAAL,CACkB,CAAhB,CAAIjB,SAAJ,GAEEP,oBAIA,CAJuB,CAAA,CAIvB,CAHAC,uBAGA,CAH0BX,IAAG/H,CAAAA,kBAAH,EAG1B,CAFA2I,mBAEA,CAFsB,EAEtB,CADAC,YACA,CADe,CAAA,CACf,CAAAC,MAAA,CAAS,CAAA,CANX,CASA,MAEF,MAAK,KAAL,CAEE,IAAA,CAAO,CAACd,IAAG9H,CAAAA,UAAH,EAAR,CAAA,CAGE,OAFI0E,QAEIA,CAFIoD,IAAGnI,CAAAA,QAAH,EAEJ+E,CAAAA,QAAR,EACE,KAAK,SAAL,CACA,KAAK,WAAL,CACEiE,YAAA,CAAyB,SAAzB;AAAejE,QACfkE,OAAA,CAAS,CAAA,CACT,MAEF,MAAK,IAAL,CACA,KAAK,KAAL,CACEA,MAAA,CAAmB,KAAnB,GAASlE,QACT,MAEF,MAAK,YAAL,CACEmE,WAAA,CAAc,CAAA,CACd,MAEF,MAAK,MAAL,CACA,KAAK,QAAL,CACEC,OAAA,CAAoB,MAApB,GAAUpE,QACV,MAEF,SACEiF,OAAQC,CAAAA,IAAR,CAAa,oCAAb,CAAoDlF,QAApD,CAA4D,eAA5D,CAtBJ,CA2BF,KAEF,MAAK,MAAL,CACElB,wBAAA,CAA2B,CAAA,CAtG/B,CA2GF,KAGF,MAAK,GAAL,CACE7F,QAAA,CAAWgK,eAAA,CAAgBG,IAAhB,CACPmC,SAAAA,CAAOlC,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CACPuK,SAAAA,CAAOnC,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CACPwK,IAAAA,CAAOpC,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CACPyK,GAAAA,CAAKrC,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CACL0K,GAAAA,CAAKtC,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CACL2K;EAAAA,CAAKvC,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CACL4K,WAAAA,CAAKxC,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CACT,KAAI6K,GAAKzC,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CAAT,CACI8K,GAAK1C,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CADT,CAEI+K,GAAK3C,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CAFT,CAGIgL,GAAK5C,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CAHT,CAIIiL,GAAK7C,UAAA,CAAWD,IAAGnI,CAAAA,QAAH,EAAX,CACL2D,SAAAA,CAA8BqD,CAArB,IAAIzJ,MAAOmG,CAAAA,OAAUsD,EAAAA,GAArB,CAAyByD,EAAzB,CAA6BC,EAA7B,CAAiCC,EAAjC,CAAqCL,QAArC,CAA2CM,UAA3C,CAA+CC,EAA/C,CAAmDC,EAAnD,CAAuDP,QAAvD,CAA6DQ,EAA7D,CAAiEC,EAAjE,CAAqEC,EAArE,CAAyET,GAAzE,CAA+E,CAA/E,CAAkF,CAAlF,CAAqF,CAArF,CAAwF,CAAxF,CACTU,KAAAA,CAAW/C,IAAG/H,CAAAA,kBAAH,EAAwBiK,CAAAA,IAAxB,EAA+B5B,CAAAA,OAA/B,CAAuC,KAAvC,CAA8C,GAA9C,CAEXhH,MAAMT,CAAAA,OAAN,CAAckK,IAAd,CAAJ,CAEEA,IAFF,CAEazJ,KAAMT,CAAAA,OAAN,CAAckK,IAAd,CAFb,CAKMA,IAAShH,CAAAA,UAAT,CAAoB,IAApB,CAAJ,CACEgH,IADF,CACa,QADb,CACwBA,IADxB,CAEWA,IAAShH,CAAAA,UAAT,CAAoB,KAApB,CAFX,GAGEgH,IAHF;AAGa,IAHb,CAGoBA,IAHpB,CAOFlI,WAAWlI,CAAAA,IAAX,CAAgB,CACJkD,QADI,CAEd2F,OAAQA,QAFM,CAGduH,SAAUA,IAHI,CAIdC,iBAAkBD,IAJJ,CAKdE,cAngCYC,CA8/BE,CAMdhK,IAAK,IANS,CAOdiK,eAAgB,CAAA,CAPF,CAQdnI,SAAU+F,WAAV/F,GAA0BmF,iBAAkBnF,CAAAA,QAR9B,CASYU,wBATZ,CAAhB,CAWAqF,YAAA,CAAc,CAAA,CACd,MAGF,MAAK,GAAL,CACElL,QAAA,CAAWgK,eAAA,CAAgBG,IAAhB,CAAoB,CAAA,CAApB,CACXoB,SAAA,CAAU,CACRvL,SAAUA,QAAS2E,CAAAA,QAASkC,CAAAA,YADpB,CAER/H,WAAYkB,QAAS2E,CAAAA,QAASC,CAAAA,IAFtB,CAGR3J,GAAIiP,WAAA,CAAYC,IAAZ,CAHI,CAIRjP,GAAIgP,WAAA,CAAYC,IAAZ,CAJI,CAMV1P,aAAaqC,CAAAA,IAAb,CAAkByO,QAAlB,CACA,MAGF,MAAK,GAAL,CACEvL,QAAA,CAAWgK,eAAA,CAAgBG,IAAhB,CAAoB,CAAA,CAApB,CACXoB,SAAA,CAAU,CACRvL,SAAUA,QAAS2E,CAAAA,QAASkC,CAAAA,YAAalC,CAAAA,QAASwE,CAAAA,uBAD1C;AAERrK,WAAYkB,QAAS2E,CAAAA,QAASC,CAAAA,IAFtB,CAGR3J,GAAIiP,WAAA,CAAYC,IAAZ,CAHI,CAIRjP,GAAIgP,WAAA,CAAYC,IAAZ,CAJI,CAKRrJ,GAAIoJ,WAAA,CAAYC,IAAZ,CALI,CAMRpJ,GAAImJ,WAAA,CAAYC,IAAZ,CANI,CAQVvE,oBAAoB9I,CAAAA,IAApB,CAAyByO,QAAzB,CACA,MAGF,MAAK,GAAL,CACEvL,QAAA,CAAWgK,eAAA,CAAgBG,IAAhB,CACXhF,SAAA,CAAWmF,iBAAkBnF,CAAAA,QAC7BqG,IAAA,CAAMP,MAAN,GAAiB9F,QACjBsG,SAAA,CAAc,CAACT,YAAf,EAA+B,CAACG,OAEpB,EAAA,CAAZ,GAAIK,GAAJ,EACEvQ,GAEA,CAFKiP,WAAA,CAAYC,IAAZ,CAEL,CADAjP,EACA,CADKgP,WAAA,CAAYC,IAAZ,CACL,CAAApK,EAAA,CAAKmK,WAAA,CAAYC,IAAZ,CAHP,GAKEpK,EAEA,CAFKmK,WAAA,CAAYC,IAAZ,CAEL,CADAjP,EACA,CADKgP,WAAA,CAAYC,IAAZ,CACL,CAAAlP,GAAA,CAAKiP,WAAA,CAAYC,IAAZ,CAPP,CAUA9I,UAAUkM,CAAAA,UAAV,CAAqBrS,EAArB,CAAyBD,GAAzB,CAEAsG,UAAUgM,CAAAA,UAAV,CAAqBxN,EAArB,CAAyB7E,EAAzB,CAEAyB,WAAA,CAAkC6Q,CAArB,IAAIjO,MAAO+B,CAAAA,OAAUkM,EAAAA,YAArB,CAAkCnM,SAAlC;AAA6CE,SAA7C,CAAwDhD,CAAAA,SAAxD,EACb/D,UAAUsC,CAAAA,IAAV,CAAe,CACHkD,QADG,CAEblB,WAAYkB,QAAS2E,CAAAA,QAASC,CAAAA,IAFjB,CAGb3J,GAAIA,GAHS,CAITC,EAJS,CAKT6E,EALS,CAMDpD,UANC,CAObC,GAAI,IAPS,CAQbG,GAAI,IARS,CASbC,GAAI,IATS,CAAf,CAYoB,EAAA,CAApB,GAAIyO,QAAJ,EACEjR,SAAUsC,CAAAA,IAAV,CAAe,CACHkD,QADG,CAEblB,WAAYkB,QAAS2E,CAAAA,QAASC,CAAAA,IAFjB,CAGb3J,GAAIA,GAHS,CAIbC,GAAI6E,EAJS,CAKbA,GAAI7E,EALS,CAMDyB,UANC,CAObC,GAAI,IAPS,CAQbG,GAAI,IARS,CASbC,GAAI,IATS,CAAf,CAaF,MAGF,MAAK,GAAL,CACEgD,QAAA,CAAWgK,eAAA,CAAgBG,IAAhB,CACXhF,SAAA,CAAWmF,iBAAkBnF,CAAAA,QAC7BqG,IAAA,CAAMP,MAAN,GAAiB9F,QACjBsG,SAAA,CAAc,CAACT,YAAf,EAA+B,CAACG,OAEpB,EAAA,CAAZ,GAAIK,GAAJ,EACEvQ,GAGA,CAHKiP,WAAA,CAAYC,IAAZ,CAGL,CAFAjP,EAEA,CAFKgP,WAAA,CAAYC,IAAZ,CAEL,CADApK,EACA,CADKmK,WAAA,CAAYC,IAAZ,CACL,CAAAuB,EAAA,CAAKxB,WAAA,CAAYC,IAAZ,CAJP,GAMEuB,EAGA,CAHKxB,WAAA,CAAYC,IAAZ,CAGL;AAFApK,EAEA,CAFKmK,WAAA,CAAYC,IAAZ,CAEL,CADAjP,EACA,CADKgP,WAAA,CAAYC,IAAZ,CACL,CAAAlP,GAAA,CAAKiP,WAAA,CAAYC,IAAZ,CATP,CAYA9I,UAAUkM,CAAAA,UAAV,CAAqBrS,EAArB,CAAyBD,GAAzB,CAEAsG,UAAUgM,CAAAA,UAAV,CAAqBxN,EAArB,CAAyB7E,EAAzB,CAEAyB,WAAA,CAAkC6Q,CAArB,IAAIjO,MAAO+B,CAAAA,OAAUkM,EAAAA,YAArB,CAAkCnM,SAAlC,CAA6CE,SAA7C,CAAwDhD,CAAAA,SAAxD,EACb/D,UAAUsC,CAAAA,IAAV,CAAe,CACHkD,QADG,CAEblB,WAAYkB,QAAS2E,CAAAA,QAASC,CAAAA,IAFjB,CAGb3J,GAAIA,GAHS,CAITC,EAJS,CAKT6E,EALS,CAMDpD,UANC,CAObC,GAAI,IAPS,CAQbG,GAAI,IARS,CASbC,GAAI,IATS,CAAf,CAWAxC,UAAUsC,CAAAA,IAAV,CAAe,CACHkD,QADG,CAEblB,WAAYkB,QAAS2E,CAAAA,QAASC,CAAAA,IAFjB,CAGb3J,GAAIA,GAHS,CAIbC,GAAI6E,EAJS,CAKbA,GAAI2L,EALS,CAMD/O,UANC,CAObC,GAAI,IAPS,CAQbG,GAAI,IARS,CASbC,GAAI,IATS,CAAf,CAYoB,EAAA,CAApB,GAAIyO,QAAJ,GACEjR,SAAUsC,CAAAA,IAAV,CAAe,CACHkD,QADG,CAEblB,WAAYkB,QAAS2E,CAAAA,QAASC,CAAAA,IAFjB,CAGb3J,GAAIA,GAHS;AAIbC,GAAI6E,EAJS,CAKbA,GAAI7E,EALS,CAMDyB,UANC,CAObC,GAAI,IAPS,CAQbG,GAAI,IARS,CASbC,GAAI,IATS,CAAf,CAWA,CAAAxC,SAAUsC,CAAAA,IAAV,CAAe,CACHkD,QADG,CAEblB,WAAYkB,QAAS2E,CAAAA,QAASC,CAAAA,IAFjB,CAGb3J,GAAIA,GAHS,CAIbC,GAAIwQ,EAJS,CAKT3L,EALS,CAMDpD,UANC,CAObC,GAAI,IAPS,CAQbG,GAAI,IARS,CASbC,GAAI,IATS,CAAf,CAZF,CAyBA,MAEF,SACE,KAAM,kCAAN,CAA2CsO,QAA3C,CAAsD,GAAtD,CAA4DnB,IAAG5H,CAAAA,mBAAH,EAA5D,CAAuF,GAAvF,CAvTJ,CAlBA,CA6UEsI,oBAAJ,GACE,IAAK9H,CAAAA,cAAL,CAAoB+H,uBAAwBO,CAAAA,WAAxB,EAApB,CADF,CAC+DN,mBAD/D,CAIAT,kBAAkBlF,CAAAA,QAAlB,CAA6BA,QAC7BkF,kBAAkBjF,CAAAA,QAAlB,CAA6BA,QAC7BiF,kBAAkBtF,CAAAA,UAAlB,CAA+BA,UAC/BsF,kBAAkBrF,CAAAA,aAAlB;AAAkCD,UAAWjL,CAAAA,MAC7CuQ,kBAAkBpF,CAAAA,cAAlB,CAAmC,CA3aH,CAFjC,CAxXuB,CAuyBvB,CACD/K,IAAK,0BADJ,CAEDhB,MAAOsU,QAAiC,CAACC,KAAD,CAAQ,CAE9C,IAAIC,WAAa,CACjBD,MAAME,CAAAA,QAAN,CAAe,QAAS,CAACC,CAAD,CAAI,CACtBA,CAAEC,CAAAA,OAAN,GACMD,CAAElJ,CAAAA,QAASkB,CAAAA,wBAIf,EAHE8H,UAAA,EAGF,CAAAE,CAAElJ,CAAAA,QAASoJ,CAAAA,gBAAX,CAA8BJ,UALhC,CAD0B,CAA5B,CASAD,MAAM/I,CAAAA,QAASqJ,CAAAA,oBAAf,CAAsCL,UAAtC,CAAmD,CAZL,CAF/C,CAvyBuB,CAuzBvB,CACDxT,IAAK,eADJ,CAEDhB,MAAOgL,QAAsB,CAACD,aAAD,CAAO+J,WAAP,CAAoBC,SAApB,CAA+B7K,GAA/B,CAAoC,CA6B/D8K,QAASA,kBAAiB,EAAG,CAC3BC,aAAA,EAEA,IAAIA,aAAJ,GAAsBC,UAAWrJ,CAAAA,UAAWjL,CAAAA,MAA5C,CAAqD,CAArD,CACEuU,cAAA,EADF,KAEO,CAOL,IAAIC;AAAaF,UAAWrJ,CAAAA,UAAX,CAAsBqJ,UAAWnJ,CAAAA,cAAjC,CACjBsJ,QAAQC,CAAAA,OAAR,EAAkBC,CAAAA,IAAlB,CAAuB,QAAS,EAAG,CACjCC,aAAA,CAAcJ,UAAd,CADiC,CAAnC,CAGAF,WAAWnJ,CAAAA,cAAX,EAXK,CALoB,CAoB7BoJ,QAASA,eAAc,EAAG,CACpB7K,KAAMlJ,CAAAA,aAAV,EAA+C,MAA/C,GAA2B8T,UAAW5P,CAAAA,IAAtC,EACElE,aAAA,CAAc8T,UAAW7T,CAAAA,SAAzB,CAAoC6T,UAAW5T,CAAAA,YAA/C,CAGF,KAAImR,OAAS,CAACrB,gBAAiBhG,CAAAA,WAE/B,IAAId,KAAMN,CAAAA,eAAV,EAA6B,CAAC3E,eAAA,CAAgB6P,UAAW5P,CAAAA,IAA3B,CAA9B,EAAkEmN,MAAlE,CACMgD,MAcJ,CAdeP,UAAWxC,CAAAA,WAc1B,CAZkC,CAYlC,CAZIwC,UAAW7T,CAAAA,SAAUT,CAAAA,MAYzB,EAXE6U,MAASlT,CAAAA,GAAT,CAAaqD,YAAA,CAAasP,UAAW7T,CAAAA,SAAxB,CAAmC,CAAnC,CAAb,CAWF,CARqC,CAQrC,CARI6T,UAAW5T,CAAAA,YAAaV,CAAAA,MAQ5B;AAPE6U,MAASlT,CAAAA,GAAT,CAAaqD,YAAA,CAAasP,UAAW5T,CAAAA,YAAxB,CAAsC,CAAtC,CAAb,CAOF,CAJ4C,CAI5C,CAJI4T,UAAWzI,CAAAA,mBAAoB7L,CAAAA,MAInC,EAHE6U,MAASlT,CAAAA,GAAT,CAAaqD,YAAA,CAAasP,UAAWzI,CAAAA,mBAAxB,CAA6C,CAA7C,CAAgD,CAAA,CAAhD,CAAb,CAGF,CAAI2E,gBAAiBsB,CAAAA,WAArB,GACE+C,MAAS9H,CAAAA,IAIT,CAJgBuH,UAAWnB,CAAAA,QAI3B,CAHA0B,MAASjK,CAAAA,QAASS,CAAAA,QAGlB,CAH6BiJ,UAAWjJ,CAAAA,QAGxC,CAFAwJ,MAASjK,CAAAA,QAASU,CAAAA,QAElB,CAF6BgJ,UAAWhJ,CAAAA,QAExC,CADAgJ,UAAW1I,CAAAA,MAAOkJ,CAAAA,SAAlB,CAA4BD,MAASE,CAAAA,QAArC,CAA+CF,MAASG,CAAAA,UAAxD,CAAoEH,MAASI,CAAAA,KAA7E,CACA,CAAAzE,gBAAiBsB,CAAAA,WAAYnQ,CAAAA,GAA7B,CAAiCkT,MAAjC,CALF,CAfF,KAsBO,CACDzL,MAAAA,CAAkBM,KAAMN,CAAAA,eAQ5B,KAPA,IAAI8L,mBAAqB1E,gBAAiB9P,CAAAA,YAA1C;AACIyU,0BAA4B3E,gBAAiB3E,CAAAA,mBADjD,CAEIuJ,gBAAkB5E,gBAAiB/P,CAAAA,SAFvC,CAGIC,aAAe4T,UAAW5T,CAAAA,YAH9B,CAIImL,oBAAsByI,UAAWzI,CAAAA,mBAJrC,CAKIpL,UAAY6T,UAAW7T,CAAAA,SAL3B,CAOSV,EAAI,CAPb,CAOgB0B,EAAIf,YAAaV,CAAAA,MAAjC,CAAyCD,CAAzC,CAA6C0B,CAA7C,CAAgD1B,CAAA,EAAhD,CAAqD,CACnD,IAAI2B,GAAKhB,YAAA,CAAaX,CAAb,CAELqJ,OAAJ,GACE1H,EAAGR,CAAAA,EAAGoP,CAAAA,YAAN,CAAmBgE,UAAW1I,CAAAA,MAA9B,CACA,CAAAlK,EAAGP,CAAAA,EAAGmP,CAAAA,YAAN,CAAmBgE,UAAW1I,CAAAA,MAA9B,CAFF,CAKAsJ,mBAAmBnS,CAAAA,IAAnB,CAAwBrB,EAAxB,CARmD,CAW5C2T,kBAAAA,CAAM,CAAf,KAAkBC,YAAlB,CAAwBzJ,mBAAoB7L,CAAAA,MAA5C,CAAoDqV,kBAApD,CAA0DC,YAA1D,CAA+DD,kBAAA,EAA/D,CACMvO,CASJ;AATS+E,mBAAA,CAAoBwJ,kBAApB,CAST,CAPIjM,MAOJ,GANEtC,CAAG5F,CAAAA,EAAGoP,CAAAA,YAAN,CAAmBgE,UAAW1I,CAAAA,MAA9B,CAGA,CAFA9E,CAAG3F,CAAAA,EAAGmP,CAAAA,YAAN,CAAmBgE,UAAW1I,CAAAA,MAA9B,CAEA,CADA9E,CAAGC,CAAAA,EAAGuJ,CAAAA,YAAN,CAAmBgE,UAAW1I,CAAAA,MAA9B,CACA,CAAA9E,CAAGE,CAAAA,EAAGsJ,CAAAA,YAAN,CAAmBgE,UAAW1I,CAAAA,MAA9B,CAGF,EAAAuJ,yBAA0BpS,CAAAA,IAA1B,CAA+B+D,CAA/B,CAGOyO,0BAAAA,CAAM,CAAf,KAAkBC,mBAAlB,CAAwB/U,SAAUT,CAAAA,MAAlC,CAA0CuV,yBAA1C,CAAgDC,mBAAhD,CAAqDD,yBAAA,EAArD,CACMzT,kBAcJ,CAdUrB,SAAA,CAAU8U,yBAAV,CAcV,CAZInM,MAYJ,GAXEtH,kBAAIZ,CAAAA,EAQJ,CARSY,kBAAIZ,CAAAA,EAAG4B,CAAAA,KAAP,EAAewN,CAAAA,YAAf,CAA4BgE,UAAW1I,CAAAA,MAAvC,CAQT;AAPA9J,kBAAIX,CAAAA,EAOJ,CAPSW,kBAAIX,CAAAA,EAAG2B,CAAAA,KAAP,EAAewN,CAAAA,YAAf,CAA4BgE,UAAW1I,CAAAA,MAAvC,CAOT,CANA9J,kBAAIkE,CAAAA,EAMJ,CANSlE,kBAAIkE,CAAAA,EAAGlD,CAAAA,KAAP,EAAewN,CAAAA,YAAf,CAA4BgE,UAAW1I,CAAAA,MAAvC,CAMT,CAJAtE,SAAUkM,CAAAA,UAAV,CAAqB1R,kBAAIX,CAAAA,EAAzB,CAA6BW,kBAAIZ,CAAAA,EAAjC,CAIA,CAFAsG,SAAUgM,CAAAA,UAAV,CAAqB1R,kBAAIkE,CAAAA,EAAzB,CAA6BlE,kBAAIX,CAAAA,EAAjC,CAEA,CAAAW,kBAAIc,CAAAA,UAAW6Q,CAAAA,YAAf,CAA4BnM,SAA5B,CAAuCE,SAAvC,CAAkDhD,CAAAA,SAAlD,EAGF,EAAA4Q,eAAgBrS,CAAAA,IAAhB,CAAqBjB,kBAArB,CAhDG,CAoDP4H,KAAMqC,CAAAA,gBAAN,EAEKyE,iBAAiBhG,CAAAA,WAAtB,EACEd,KAAMgK,CAAAA,wBAAN,CAA+BY,UAAWxC,CAAAA,WAA1C,CAGEoC;WAAJ,EACEA,WAAA,CAAYI,UAAWxC,CAAAA,WAAvB,CAxFsB,CA4F1B8C,QAASA,cAAa,CAACT,SAAD,CAAY,CAChCG,UAAW9I,CAAAA,cAAX,CAA4B2I,SAAUlO,CAAAA,QAAS2E,CAAAA,QAASC,CAAAA,IACxDyJ,WAAW7I,CAAAA,kBAAX,CAAgC0I,SAAUlO,CAAAA,QAAS2E,CAAAA,QAASkC,CAAAA,YAAalC,CAAAA,QAASC,CAAAA,IAClFyJ,WAAW/I,CAAAA,eAAX,CAA6B4I,SAAUf,CAAAA,gBAEvC,KAAIqC,OAAS/L,KAAMV,CAAAA,cAAN,CAAqBmL,SAAUf,CAAAA,gBAAiB9B,CAAAA,WAA3B,EAArB,CAEb,IAAImE,MAAJ,CACE/L,KAAMU,CAAAA,aAAN,CAAoBqL,MAApB,CAA4B,QAAS,CAACC,cAAD,CAAiB,CA6EjC,IAAvB,GA5EsBA,cA4EtB,CAEEd,aAAA,CA9EoCT,SA8EpC,CAFF,CAMAzK,KAAMT,CAAAA,OAAN,CAlFsCkL,SAkFdf,CAAAA,gBAAxB,CANA;AA5EsCe,SAkFgB7K,CAAAA,GAjFlD8K,kBAAA,EAFoD,CAAtD,CAGGD,SAHH,CAGc7K,GAHd,CADF,KAAA,CAUIqM,MAAAA,CAAexB,SAAUhB,CAAAA,QAC7B,KAAIyC,iBA51CkBC,CA81CtB,QAAQ1B,SAAUd,CAAAA,aAAlB,EACE,KAr2CgBC,CAq2ChB,CACEsC,gBAAA,CAAmBzB,SAAUd,CAAAA,aAA7B,CAA6C,CAC7C,MAEF,MAx2CoByC,CAw2CpB,CACEH,MAAA,CAAe,QAAf,CAA0BA,MAC1BC,iBAAA,CAAmBzB,SAAUd,CAAAA,aAA7B,CAA6C,CAC7C,MAEF,MA52CgB0C,CA42ChB,CACEJ,MAAA,CAAe,IAAf,CAAsBA,MACtBC,iBAAA,CAAmBzB,SAAUd,CAAAA,aAA7B,CAA6C,CAC7C,MAEF,MAh3CqB2C,CAg3CrB,CACEL,MAAA,CAAe,SAAf,CAA2BA,MAC3BC,iBAAA,CAAmBzB,SAAUd,CAAAA,aAA7B,CAA6C,CAC7C,MAEF,MAp3CuB4C,CAo3CvB,CACEN,MAAA,CAAerM,GAAIlB,CAAAA,SAAJ,CAAc,CAAd,CAAiBkB,GAAI4M,CAAAA,WAAJ,CAAgB,GAAhB,CAAjB,CAAwC,CAAxC,CAAf,CAA4DP,MAC5DC,iBAAA;AAAmBzB,SAAUd,CAAAA,aAA7B,CAA6C,CAC7C,MAEF,MAx3CuB8C,CAw3CvB,CACMhC,SAAUZ,CAAAA,cAAd,CAEEqC,gBAFF,CAx3CkBC,CAw3ClB,EAKE1B,SAAUhB,CAAAA,QAGV,CAHqBgB,SAAUhB,CAAAA,QAAS7B,CAAAA,WAAnB,EAGrB,CAFAqE,MAEA,CAFexB,SAAUhB,CAAAA,QAEzB,CADAgB,SAAUZ,CAAAA,cACV,CAD2B,CAAA,CAC3B,CAAAqC,gBAAA,CAt4CYtC,CA83Cd,CAWA,MAEF,MAr4CoBuC,CAq4CpB,CAEE5D,OAAQC,CAAAA,IAAR,CAAa,0BAAb,CAA0CiC,SAAUf,CAAAA,gBAApD,CAAuE,uBAAvE,CACA,OA1CJ,CA6CAe,SAAUd,CAAAA,aAAV,CAA0BuC,gBAC1BzB,UAAU7K,CAAAA,GAAV,CAAgBqM,MAIZhM,iBAAAA,CAAa,IAAInE,MAAOoE,CAAAA,UAAX,CAAsBF,KAAMhB,CAAAA,OAA5B,CACjBiB,iBAAWE,CAAAA,OAAX,CAAmBH,KAAMI,CAAAA,IAAzB,CACAH,iBAAWI,CAAAA,gBAAX,CAA4BL,KAAMM,CAAAA,aAAlC,CACAL;gBAAWM,CAAAA,kBAAX,CAA8BP,KAAMQ,CAAAA,eAApC,CACAP,iBAAWN,CAAAA,IAAX,CAAgBsM,MAAhB,CAA8B,QAAS,CAACxL,IAAD,CAAO,CAC5CT,KAAMU,CAAAA,aAAN,CAAoBD,IAApB,CAA0B,QAAS,CAACuL,cAAD,CAAiB,CAU/B,IAAvB,GATsBA,cAStB,CAEEd,aAAA,CAXoCT,SAWpC,CAFF,CAMAzK,KAAMT,CAAAA,OAAN,CAfsCkL,SAedf,CAAAA,gBAAxB,CANA,CATsCe,SAegB7K,CAAAA,GAdlD8K,kBAAA,EAFkD,CAApD,CAGGD,SAHH,CAGc7K,GAHd,CAD4C,CAA9C,CAKG8M,IAAAA,EALH,CAKc,QAAS,CAACC,GAAD,CAAM,CAiB7BzB,aAAA,CAhBwBT,SAgBxB,CAjB6B,CAL7B,CAOGA,SAPH,CAnEA,CAPgC,CA5IlC,IAAIzK,MAAQ,IAAZ,CACI4K,WAAa5K,KAAMY,CAAAA,kBAAN,EACjBgK,WAAWhL,CAAAA,GAAX,CAAiBA,GACjB,KAAIkH,iBAAmB9G,KAAM2C,CAAAA,mBAAN,EAEnB8H,UAAJ,GACEG,UAAW5I,CAAAA,aAAc4K,CAAAA,gBAAzB,CAA0C9F,gBAAiB9E,CAAAA,aAA3D;AAA0EyI,SAAUvI,CAAAA,MAApF,CAGA,CAFA0I,UAAW1I,CAAAA,MAAO2K,CAAAA,IAAlB,CAAuBpC,SAAUvI,CAAAA,MAAjC,CAEA,CADA0I,UAAWlJ,CAAAA,QACX,CADsB+I,SAAU/I,CAAAA,QAChC,CAAAkJ,UAAWxI,CAAAA,wBAAX,CAAsCqI,SAAUrI,CAAAA,wBAJlD,CAQIP,UAAAA,CAAkBiF,gBAAiBjF,CAAAA,eAEf,KAAxB,GAAIA,SAAJ,GACEA,SADF,CACoBiF,gBAAiBjF,CAAAA,eAAgB+F,CAAAA,WAAjC,EADpB,CAI8C8E,KAAAA,EAA9C,GAAI1M,KAAMV,CAAAA,cAAN,CAAqBuC,SAArB,CAAJ,GACE7B,KAAMV,CAAAA,cAAN,CAAqBuC,SAArB,CADF,CAC0CpB,aAD1C,CAKAT,MAAMsG,CAAAA,WAAN,CAAkB7F,aAAlB,CACA,KAAIkK,cAAgB,CACpBD,kBAAA,EA3B+D,CAFhE,CAvzBuB,CAA1B,CA2iCA,OAAO/M,YA3kCU,CAAnB,CA4kCE7B,MAAOgR,CAAAA,MA5kCT,CA8kCAtY,QAAQmJ,CAAAA,WAAR;AAAsBA,MA79C2F;\",\n\"sources\":[\"node_modules/three-stdlib/loaders/LDrawLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$LDrawLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.LDrawLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n// Note: \\\"MATERIAL\\\" tag (e.g. GLITTER, SPECKLE) is not implemented\\nvar FINISH_TYPE_DEFAULT = 0;\\nvar FINISH_TYPE_CHROME = 1;\\nvar FINISH_TYPE_PEARLESCENT = 2;\\nvar FINISH_TYPE_RUBBER = 3;\\nvar FINISH_TYPE_MATTE_METALLIC = 4;\\nvar FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\\n// The LDraw standard establishes these various possible subfolders.\\n\\nvar FILE_LOCATION_AS_IS = 0;\\nvar FILE_LOCATION_TRY_PARTS = 1;\\nvar FILE_LOCATION_TRY_P = 2;\\nvar FILE_LOCATION_TRY_MODELS = 3;\\nvar FILE_LOCATION_TRY_RELATIVE = 4;\\nvar FILE_LOCATION_TRY_ABSOLUTE = 5;\\nvar FILE_LOCATION_NOT_FOUND = 6;\\nvar conditionalLineVertShader =\\n/* glsl */\\n\\\"\\\\n\\\\tattribute vec3 control0;\\\\n\\\\tattribute vec3 control1;\\\\n\\\\tattribute vec3 direction;\\\\n\\\\tvarying float discardFlag;\\\\n\\\\n\\\\t#include <common>\\\\n\\\\t#include <color_pars_vertex>\\\\n\\\\t#include <fog_pars_vertex>\\\\n\\\\t#include <logdepthbuf_pars_vertex>\\\\n\\\\t#include <clipping_planes_pars_vertex>\\\\n\\\\tvoid main() {\\\\n\\\\t\\\\t#include <color_vertex>\\\\n\\\\n\\\\t\\\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\t\\\\tgl_Position = projectionMatrix * mvPosition;\\\\n\\\\n\\\\t\\\\t// Transform the line segment ends and control points into camera clip space\\\\n\\\\t\\\\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\\\\n\\\\t\\\\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\\\\n\\\\t\\\\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\t\\\\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\\\\n\\\\n\\\\t\\\\tc0.xy /= c0.w;\\\\n\\\\t\\\\tc1.xy /= c1.w;\\\\n\\\\t\\\\tp0.xy /= p0.w;\\\\n\\\\t\\\\tp1.xy /= p1.w;\\\\n\\\\n\\\\t\\\\t// Get the direction of the segment and an orthogonal vector\\\\n\\\\t\\\\tvec2 dir = p1.xy - p0.xy;\\\\n\\\\t\\\\tvec2 norm = vec2( -dir.y, dir.x );\\\\n\\\\n\\\\t\\\\t// Get control point directions from the line\\\\n\\\\t\\\\tvec2 c0dir = c0.xy - p1.xy;\\\\n\\\\t\\\\tvec2 c1dir = c1.xy - p1.xy;\\\\n\\\\n\\\\t\\\\t// If the vectors to the controls points are pointed in different directions away\\\\n\\\\t\\\\t// from the line segment then the line should not be drawn.\\\\n\\\\t\\\\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\\\\n\\\\t\\\\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\\\\n\\\\t\\\\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\\\\n\\\\n\\\\t\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t\\\\t#include <clipping_planes_vertex>\\\\n\\\\t\\\\t#include <fog_vertex>\\\\n\\\\t}\\\\n\\\\t\\\";\\nvar conditionalLineFragShader =\\n/* glsl */\\n\\\"\\\\n\\\\tuniform vec3 diffuse;\\\\n\\\\tuniform float opacity;\\\\n\\\\tvarying float discardFlag;\\\\n\\\\n\\\\t#include <common>\\\\n\\\\t#include <color_pars_fragment>\\\\n\\\\t#include <fog_pars_fragment>\\\\n\\\\t#include <logdepthbuf_pars_fragment>\\\\n\\\\t#include <clipping_planes_pars_fragment>\\\\n\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\tif ( discardFlag > 0.5 ) discard;\\\\n\\\\n\\\\t\\\\t#include <clipping_planes_fragment>\\\\n\\\\t\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\t\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t\\\\t#include <color_fragment>\\\\n\\\\t\\\\toutgoingLight = diffuseColor.rgb; // simple shader\\\\n\\\\t\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t\\\\t#include <tonemapping_fragment>\\\\n\\\\t\\\\t#include <encodings_fragment>\\\\n\\\\t\\\\t#include <fog_fragment>\\\\n\\\\t\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t}\\\\n\\\\t\\\";\\n\\nvar _tempVec0 = new _three.Vector3();\\n\\nvar _tempVec1 = new _three.Vector3();\\n\\nfunction smoothNormals(triangles, lineSegments) {\\n  function hashVertex(v) {\\n    // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\\n    // to be smoothed as expected (see minifig arms). The errors between edges\\n    // could be due to matrix multiplication.\\n    var x = ~~(v.x * 1e2);\\n    var y = ~~(v.y * 1e2);\\n    var z = ~~(v.z * 1e2);\\n    return \\\"\\\".concat(x, \\\",\\\").concat(y, \\\",\\\").concat(z);\\n  }\\n\\n  function hashEdge(v0, v1) {\\n    return \\\"\\\".concat(hashVertex(v0), \\\"_\\\").concat(hashVertex(v1));\\n  }\\n\\n  var hardEdges = new Set();\\n  var halfEdgeList = {};\\n  var fullHalfEdgeList = {};\\n  var normals = []; // Save the list of hard edges by hash\\n\\n  for (var i = 0, l = lineSegments.length; i < l; i++) {\\n    var ls = lineSegments[i];\\n    var v0 = ls.v0;\\n    var v1 = ls.v1;\\n    hardEdges.add(hashEdge(v0, v1));\\n    hardEdges.add(hashEdge(v1, v0));\\n  } // track the half edges associated with each triangle\\n\\n\\n  for (var _i = 0, _l = triangles.length; _i < _l; _i++) {\\n    var tri = triangles[_i];\\n\\n    for (var i2 = 0, l2 = 3; i2 < l2; i2++) {\\n      var index = i2;\\n      var next = (i2 + 1) % 3;\\n      var _v = tri[\\\"v\\\".concat(index)];\\n      var _v2 = tri[\\\"v\\\".concat(next)];\\n      var hash = hashEdge(_v, _v2); // don't add the triangle if the edge is supposed to be hard\\n\\n      if (hardEdges.has(hash)) continue;\\n      halfEdgeList[hash] = tri;\\n      fullHalfEdgeList[hash] = tri;\\n    }\\n  } // NOTE: Some of the normals wind up being skewed in an unexpected way because\\n  // quads provide more \\\"influence\\\" to some vertex normals than a triangle due to\\n  // the fact that a quad is made up of two triangles and all triangles are weighted\\n  // equally. To fix this quads could be tracked separately so their vertex normals\\n  // are weighted appropriately or we could try only adding a normal direction\\n  // once per normal.\\n  // Iterate until we've tried to connect all triangles to share normals\\n\\n\\n  while (true) {\\n    // Stop if there are no more triangles left\\n    var halfEdges = Object.keys(halfEdgeList);\\n    if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\\n\\n    var _i2 = 0;\\n    var queue = [fullHalfEdgeList[halfEdges[0]]];\\n\\n    while (_i2 < queue.length) {\\n      // initialize all vertex normals in this triangle\\n      var _tri = queue[_i2];\\n      _i2++;\\n      var faceNormal = _tri.faceNormal;\\n\\n      if (_tri.n0 === null) {\\n        _tri.n0 = faceNormal.clone();\\n        normals.push(_tri.n0);\\n      }\\n\\n      if (_tri.n1 === null) {\\n        _tri.n1 = faceNormal.clone();\\n        normals.push(_tri.n1);\\n      }\\n\\n      if (_tri.n2 === null) {\\n        _tri.n2 = faceNormal.clone();\\n        normals.push(_tri.n2);\\n      } // Check if any edge is connected to another triangle edge\\n\\n\\n      for (var _i3 = 0, _l2 = 3; _i3 < _l2; _i3++) {\\n        var _index = _i3;\\n\\n        var _next = (_i3 + 1) % 3;\\n\\n        var _v3 = _tri[\\\"v\\\".concat(_index)];\\n\\n        var _v4 = _tri[\\\"v\\\".concat(_next)]; // delete this triangle from the list so it won't be found again\\n\\n\\n        var _hash = hashEdge(_v3, _v4);\\n\\n        delete halfEdgeList[_hash];\\n        var reverseHash = hashEdge(_v4, _v3);\\n        var otherTri = fullHalfEdgeList[reverseHash];\\n\\n        if (otherTri) {\\n          // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\\n          // hard edge. There are some cases where the line segments do not line up exactly\\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\\n          if (Math.abs(otherTri.faceNormal.dot(_tri.faceNormal)) < 0.25) {\\n            continue;\\n          } // if this triangle has already been traversed then it won't be in\\n          // the halfEdgeList. If it has not then add it to the queue and delete\\n          // it so it won't be found again.\\n\\n\\n          if (reverseHash in halfEdgeList) {\\n            queue.push(otherTri);\\n            delete halfEdgeList[reverseHash];\\n          } // Find the matching edge in this triangle and copy the normal vector over\\n\\n\\n          for (var i3 = 0, l3 = 3; i3 < l3; i3++) {\\n            var otherIndex = i3;\\n            var otherNext = (i3 + 1) % 3;\\n            var otherV0 = otherTri[\\\"v\\\".concat(otherIndex)];\\n            var otherV1 = otherTri[\\\"v\\\".concat(otherNext)];\\n            var otherHash = hashEdge(otherV0, otherV1);\\n\\n            if (otherHash === reverseHash) {\\n              if (otherTri[\\\"n\\\".concat(otherIndex)] === null) {\\n                var norm = _tri[\\\"n\\\".concat(_next)];\\n\\n                otherTri[\\\"n\\\".concat(otherIndex)] = norm;\\n                norm.add(otherTri.faceNormal);\\n              }\\n\\n              if (otherTri[\\\"n\\\".concat(otherNext)] === null) {\\n                var _norm = _tri[\\\"n\\\".concat(_index)];\\n\\n                otherTri[\\\"n\\\".concat(otherNext)] = _norm;\\n\\n                _norm.add(otherTri.faceNormal);\\n              }\\n\\n              break;\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\\n\\n\\n  for (var _i4 = 0, _l3 = normals.length; _i4 < _l3; _i4++) {\\n    normals[_i4].normalize();\\n  }\\n}\\n\\nfunction isPrimitiveType(type) {\\n  return /primitive/i.test(type) || type === 'Subpart';\\n}\\n\\nvar LineParser =\\n/*#__PURE__*/\\nfunction () {\\n  function LineParser(line, lineNumber) {\\n    _classCallCheck(this, LineParser);\\n\\n    this.line = line;\\n    this.lineLength = line.length;\\n    this.currentCharIndex = 0;\\n    this.currentChar = ' ';\\n    this.lineNumber = lineNumber;\\n  }\\n\\n  _createClass(LineParser, [{\\n    key: \\\"seekNonSpace\\\",\\n    value: function seekNonSpace() {\\n      while (this.currentCharIndex < this.lineLength) {\\n        this.currentChar = this.line.charAt(this.currentCharIndex);\\n\\n        if (this.currentChar !== ' ' && this.currentChar !== '\\\\t') {\\n          return;\\n        }\\n\\n        this.currentCharIndex++;\\n      }\\n    }\\n  }, {\\n    key: \\\"getToken\\\",\\n    value: function getToken() {\\n      var pos0 = this.currentCharIndex++; // Seek space\\n\\n      while (this.currentCharIndex < this.lineLength) {\\n        this.currentChar = this.line.charAt(this.currentCharIndex);\\n\\n        if (this.currentChar === ' ' || this.currentChar === '\\\\t') {\\n          break;\\n        }\\n\\n        this.currentCharIndex++;\\n      }\\n\\n      var pos1 = this.currentCharIndex;\\n      this.seekNonSpace();\\n      return this.line.substring(pos0, pos1);\\n    }\\n  }, {\\n    key: \\\"getRemainingString\\\",\\n    value: function getRemainingString() {\\n      return this.line.substring(this.currentCharIndex, this.lineLength);\\n    }\\n  }, {\\n    key: \\\"isAtTheEnd\\\",\\n    value: function isAtTheEnd() {\\n      return this.currentCharIndex >= this.lineLength;\\n    }\\n  }, {\\n    key: \\\"setToEnd\\\",\\n    value: function setToEnd() {\\n      this.currentCharIndex = this.lineLength;\\n    }\\n  }, {\\n    key: \\\"getLineNumberString\\\",\\n    value: function getLineNumberString() {\\n      return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\\n    }\\n  }]);\\n\\n  return LineParser;\\n}();\\n\\nfunction sortByMaterial(a, b) {\\n  if (a.colourCode === b.colourCode) {\\n    return 0;\\n  }\\n\\n  if (a.colourCode < b.colourCode) {\\n    return -1;\\n  }\\n\\n  return 1;\\n}\\n\\nfunction createObject(elements, elementSize, isConditionalSegments) {\\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\\n  // With per face / segment material, implemented with mesh groups and materials array\\n  // Sort the triangles or line segments by colour code to make later the mesh groups\\n  elements.sort(sortByMaterial);\\n  var positions = [];\\n  var normals = [];\\n  var materials = [];\\n  var bufferGeometry = new _three.BufferGeometry();\\n  var prevMaterial = null;\\n  var index0 = 0;\\n  var numGroupVerts = 0;\\n\\n  for (var iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\\n    var elem = elements[iElem];\\n    var v0 = elem.v0;\\n    var v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\\n\\n    positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\\n\\n    if (elementSize === 3) {\\n      positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\\n      var n0 = elem.n0 || elem.faceNormal;\\n      var n1 = elem.n1 || elem.faceNormal;\\n      var n2 = elem.n2 || elem.faceNormal;\\n      normals.push(n0.x, n0.y, n0.z);\\n      normals.push(n1.x, n1.y, n1.z);\\n      normals.push(n2.x, n2.y, n2.z);\\n    }\\n\\n    if (prevMaterial !== elem.material) {\\n      if (prevMaterial !== null) {\\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\\n      }\\n\\n      materials.push(elem.material);\\n      prevMaterial = elem.material;\\n      index0 = iElem * elementSize;\\n      numGroupVerts = elementSize;\\n    } else {\\n      numGroupVerts += elementSize;\\n    }\\n  }\\n\\n  if (numGroupVerts > 0) {\\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\\n  }\\n\\n  bufferGeometry.setAttribute('position', new _three.Float32BufferAttribute(positions, 3));\\n\\n  if (elementSize === 3) {\\n    bufferGeometry.setAttribute('normal', new _three.Float32BufferAttribute(normals, 3));\\n  }\\n\\n  var object3d = null;\\n\\n  if (elementSize === 2) {\\n    object3d = new _three.LineSegments(bufferGeometry, materials);\\n  } else if (elementSize === 3) {\\n    object3d = new _three.Mesh(bufferGeometry, materials);\\n  }\\n\\n  if (isConditionalSegments) {\\n    object3d.isConditionalLine = true;\\n    var controlArray0 = new Float32Array(elements.length * 3 * 2);\\n    var controlArray1 = new Float32Array(elements.length * 3 * 2);\\n    var directionArray = new Float32Array(elements.length * 3 * 2);\\n\\n    for (var i = 0, l = elements.length; i < l; i++) {\\n      var os = elements[i];\\n      var c0 = os.c0;\\n      var c1 = os.c1;\\n      var _v5 = os.v0;\\n      var _v6 = os.v1;\\n      var index = i * 3 * 2;\\n      controlArray0[index + 0] = c0.x;\\n      controlArray0[index + 1] = c0.y;\\n      controlArray0[index + 2] = c0.z;\\n      controlArray0[index + 3] = c0.x;\\n      controlArray0[index + 4] = c0.y;\\n      controlArray0[index + 5] = c0.z;\\n      controlArray1[index + 0] = c1.x;\\n      controlArray1[index + 1] = c1.y;\\n      controlArray1[index + 2] = c1.z;\\n      controlArray1[index + 3] = c1.x;\\n      controlArray1[index + 4] = c1.y;\\n      controlArray1[index + 5] = c1.z;\\n      directionArray[index + 0] = _v6.x - _v5.x;\\n      directionArray[index + 1] = _v6.y - _v5.y;\\n      directionArray[index + 2] = _v6.z - _v5.z;\\n      directionArray[index + 3] = _v6.x - _v5.x;\\n      directionArray[index + 4] = _v6.y - _v5.y;\\n      directionArray[index + 5] = _v6.z - _v5.z;\\n    }\\n\\n    bufferGeometry.setAttribute('control0', new _three.BufferAttribute(controlArray0, 3, false));\\n    bufferGeometry.setAttribute('control1', new _three.BufferAttribute(controlArray1, 3, false));\\n    bufferGeometry.setAttribute('direction', new _three.BufferAttribute(directionArray, 3, false));\\n  }\\n\\n  return object3d;\\n} //\\n\\n\\nvar LDrawLoader =\\n/*#__PURE__*/\\nfunction (_Loader) {\\n  _inherits(LDrawLoader, _Loader);\\n\\n  function LDrawLoader(manager) {\\n    var _this;\\n\\n    _classCallCheck(this, LDrawLoader);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LDrawLoader).call(this, manager)); // This is a stack of 'parse scopes' with one level per subobject loaded file.\\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\\n    // When searching for a material code, the stack is read from top of the stack to bottom\\n    // Each material library is an object map keyed by colour codes.\\n\\n    _this.parseScopesStack = null; // Array of THREE.Material\\n\\n    _this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\\n    // This also allows to handle the embedded text files (\\\"0 FILE\\\" lines)\\n\\n    _this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\\n\\n    _this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\\n\\n    _this.setMaterials([_this.parseColourMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')), _this.parseColourMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333'))]); // If this flag is set to true, each subobject will be a Object.\\n    // If not (the default), only one object which contains all the merged primitives will be created.\\n\\n\\n    _this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\\n\\n    _this.smoothNormals = true;\\n    return _this;\\n  }\\n\\n  _createClass(LDrawLoader, [{\\n    key: \\\"load\\\",\\n    value: function load(url, onLoad, onProgress, onError) {\\n      if (!this.fileMap) {\\n        this.fileMap = {};\\n      }\\n\\n      var scope = this;\\n      var fileLoader = new _three.FileLoader(this.manager);\\n      fileLoader.setPath(this.path);\\n      fileLoader.setRequestHeader(this.requestHeader);\\n      fileLoader.setWithCredentials(this.withCredentials);\\n      fileLoader.load(url, function (text) {\\n        scope.processObject(text, onLoad, null, url);\\n      }, onProgress, onError);\\n    }\\n  }, {\\n    key: \\\"parse\\\",\\n    value: function parse(text, path, onLoad) {\\n      // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\\n      this.processObject(text, onLoad, null, path);\\n    }\\n  }, {\\n    key: \\\"setMaterials\\\",\\n    value: function setMaterials(materials) {\\n      // Clears parse scopes stack, adds new scope with material library\\n      this.parseScopesStack = [];\\n      this.newParseScopeLevel(materials);\\n      this.getCurrentParseScope().isFromParse = false;\\n      this.materials = materials;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"setFileMap\\\",\\n    value: function setFileMap(fileMap) {\\n      this.fileMap = fileMap;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"newParseScopeLevel\\\",\\n    value: function newParseScopeLevel(materials) {\\n      // Adds a new scope level, assign materials to it and returns it\\n      var matLib = {};\\n\\n      if (materials) {\\n        for (var i = 0, n = materials.length; i < n; i++) {\\n          var material = materials[i];\\n          matLib[material.userData.code] = material;\\n        }\\n      }\\n\\n      var topParseScope = this.getCurrentParseScope();\\n      var newParseScope = {\\n        lib: matLib,\\n        url: null,\\n        // Subobjects\\n        subobjects: null,\\n        numSubobjects: 0,\\n        subobjectIndex: 0,\\n        inverted: false,\\n        category: null,\\n        keywords: null,\\n        // Current subobject\\n        currentFileName: null,\\n        mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\\n        mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\\n        currentMatrix: new _three.Matrix4(),\\n        matrix: new _three.Matrix4(),\\n        // If false, it is a root material scope previous to parse\\n        isFromParse: true,\\n        triangles: null,\\n        lineSegments: null,\\n        conditionalSegments: null,\\n        // If true, this object is the start of a construction step\\n        startingConstructionStep: false\\n      };\\n      this.parseScopesStack.push(newParseScope);\\n      return newParseScope;\\n    }\\n  }, {\\n    key: \\\"removeScopeLevel\\\",\\n    value: function removeScopeLevel() {\\n      this.parseScopesStack.pop();\\n      return this;\\n    }\\n  }, {\\n    key: \\\"addMaterial\\\",\\n    value: function addMaterial(material) {\\n      // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\\n      var matLib = this.getCurrentParseScope().lib;\\n\\n      if (!matLib[material.userData.code]) {\\n        this.materials.push(material);\\n      }\\n\\n      matLib[material.userData.code] = material;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"getMaterial\\\",\\n    value: function getMaterial(colourCode) {\\n      // Given a colour code search its material in the parse scopes stack\\n      if (colourCode.startsWith('0x2')) {\\n        // Special 'direct' material value (RGB colour)\\n        var colour = colourCode.substring(3);\\n        return this.parseColourMetaDirective(new LineParser('Direct_Color_' + colour + ' CODE -1 VALUE #' + colour + ' EDGE #' + colour + ''));\\n      }\\n\\n      for (var i = this.parseScopesStack.length - 1; i >= 0; i--) {\\n        var material = this.parseScopesStack[i].lib[colourCode];\\n\\n        if (material) {\\n          return material;\\n        }\\n      } // Material was not found\\n\\n\\n      return null;\\n    }\\n  }, {\\n    key: \\\"getParentParseScope\\\",\\n    value: function getParentParseScope() {\\n      if (this.parseScopesStack.length > 1) {\\n        return this.parseScopesStack[this.parseScopesStack.length - 2];\\n      }\\n\\n      return null;\\n    }\\n  }, {\\n    key: \\\"getCurrentParseScope\\\",\\n    value: function getCurrentParseScope() {\\n      if (this.parseScopesStack.length > 0) {\\n        return this.parseScopesStack[this.parseScopesStack.length - 1];\\n      }\\n\\n      return null;\\n    }\\n  }, {\\n    key: \\\"parseColourMetaDirective\\\",\\n    value: function parseColourMetaDirective(lineParser) {\\n      // Parses a colour definition and returns a THREE.Material or null if error\\n      var code = null; // Triangle and line colours\\n\\n      var colour = 0xff00ff;\\n      var edgeColour = 0xff00ff; // Transparency\\n\\n      var alpha = 1;\\n      var isTransparent = false; // Self-illumination:\\n\\n      var luminance = 0;\\n      var finishType = FINISH_TYPE_DEFAULT;\\n      var canHaveEnvMap = true;\\n      var edgeMaterial = null;\\n      var name = lineParser.getToken();\\n\\n      if (!name) {\\n        throw 'LDrawLoader: Material name was expected after \\\"!COLOUR tag' + lineParser.getLineNumberString() + '.';\\n      } // Parse tag tokens and their parameters\\n\\n\\n      var token = null;\\n\\n      while (true) {\\n        token = lineParser.getToken();\\n\\n        if (!token) {\\n          break;\\n        }\\n\\n        switch (token.toUpperCase()) {\\n          case 'CODE':\\n            code = lineParser.getToken();\\n            break;\\n\\n          case 'VALUE':\\n            colour = lineParser.getToken();\\n\\n            if (colour.startsWith('0x')) {\\n              colour = '#' + colour.substring(2);\\n            } else if (!colour.startsWith('#')) {\\n              throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + '.';\\n            }\\n\\n            break;\\n\\n          case 'EDGE':\\n            edgeColour = lineParser.getToken();\\n\\n            if (edgeColour.startsWith('0x')) {\\n              edgeColour = '#' + edgeColour.substring(2);\\n            } else if (!edgeColour.startsWith('#')) {\\n              // Try to see if edge colour is a colour code\\n              edgeMaterial = this.getMaterial(edgeColour);\\n\\n              if (!edgeMaterial) {\\n                throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + '.';\\n              } // Get the edge material for this triangle material\\n\\n\\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\\n            }\\n\\n            break;\\n\\n          case 'ALPHA':\\n            alpha = parseInt(lineParser.getToken());\\n\\n            if (isNaN(alpha)) {\\n              throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.';\\n            }\\n\\n            alpha = Math.max(0, Math.min(1, alpha / 255));\\n\\n            if (alpha < 1) {\\n              isTransparent = true;\\n            }\\n\\n            break;\\n\\n          case 'LUMINANCE':\\n            luminance = parseInt(lineParser.getToken());\\n\\n            if (isNaN(luminance)) {\\n              throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.';\\n            }\\n\\n            luminance = Math.max(0, Math.min(1, luminance / 255));\\n            break;\\n\\n          case 'CHROME':\\n            finishType = FINISH_TYPE_CHROME;\\n            break;\\n\\n          case 'PEARLESCENT':\\n            finishType = FINISH_TYPE_PEARLESCENT;\\n            break;\\n\\n          case 'RUBBER':\\n            finishType = FINISH_TYPE_RUBBER;\\n            break;\\n\\n          case 'MATTE_METALLIC':\\n            finishType = FINISH_TYPE_MATTE_METALLIC;\\n            break;\\n\\n          case 'METAL':\\n            finishType = FINISH_TYPE_METAL;\\n            break;\\n\\n          case 'MATERIAL':\\n            // Not implemented\\n            lineParser.setToEnd();\\n            break;\\n\\n          default:\\n            throw 'LDrawLoader: Unknown token \\\"' + token + '\\\" while parsing material' + lineParser.getLineNumberString() + '.';\\n        }\\n      }\\n\\n      var material = null;\\n\\n      switch (finishType) {\\n        case FINISH_TYPE_DEFAULT:\\n          material = new _three.MeshStandardMaterial({\\n            color: colour,\\n            roughness: 0.3,\\n            envMapIntensity: 0.3,\\n            metalness: 0\\n          });\\n          break;\\n\\n        case FINISH_TYPE_PEARLESCENT:\\n          // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\\n          var specular = new _three.Color(colour);\\n          var hsl = specular.getHSL({\\n            h: 0,\\n            s: 0,\\n            l: 0\\n          });\\n          hsl.h = (hsl.h + 0.5) % 1;\\n          hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\\n          specular.setHSL(hsl.h, hsl.s, hsl.l);\\n          material = new _three.MeshPhongMaterial({\\n            color: colour,\\n            specular: specular,\\n            shininess: 10,\\n            reflectivity: 0.3\\n          });\\n          break;\\n\\n        case FINISH_TYPE_CHROME:\\n          // Mirror finish surface\\n          material = new _three.MeshStandardMaterial({\\n            color: colour,\\n            roughness: 0,\\n            metalness: 1\\n          });\\n          break;\\n\\n        case FINISH_TYPE_RUBBER:\\n          // Rubber finish\\n          material = new _three.MeshStandardMaterial({\\n            color: colour,\\n            roughness: 0.9,\\n            metalness: 0\\n          });\\n          canHaveEnvMap = false;\\n          break;\\n\\n        case FINISH_TYPE_MATTE_METALLIC:\\n          // Brushed metal finish\\n          material = new _three.MeshStandardMaterial({\\n            color: colour,\\n            roughness: 0.8,\\n            metalness: 0.4\\n          });\\n          break;\\n\\n        case FINISH_TYPE_METAL:\\n          // Average metal finish\\n          material = new _three.MeshStandardMaterial({\\n            color: colour,\\n            roughness: 0.2,\\n            metalness: 0.85\\n          });\\n          break;\\n      }\\n\\n      material.transparent = isTransparent;\\n      material.premultipliedAlpha = true;\\n      material.opacity = alpha;\\n      material.depthWrite = !isTransparent;\\n      material.polygonOffset = true;\\n      material.polygonOffsetFactor = 1;\\n      material.userData.canHaveEnvMap = canHaveEnvMap;\\n\\n      if (luminance !== 0) {\\n        material.emissive.set(material.color).multiplyScalar(luminance);\\n      }\\n\\n      if (!edgeMaterial) {\\n        // This is the material used for edges\\n        edgeMaterial = new _three.LineBasicMaterial({\\n          color: edgeColour,\\n          transparent: isTransparent,\\n          opacity: alpha,\\n          depthWrite: !isTransparent\\n        });\\n        edgeMaterial.userData.code = code;\\n        edgeMaterial.name = name + ' - Edge';\\n        edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\\n\\n        edgeMaterial.userData.conditionalEdgeMaterial = new _three.ShaderMaterial({\\n          vertexShader: conditionalLineVertShader,\\n          fragmentShader: conditionalLineFragShader,\\n          uniforms: _three.UniformsUtils.merge([_three.UniformsLib.fog, {\\n            diffuse: {\\n              value: new _three.Color(edgeColour)\\n            },\\n            opacity: {\\n              value: alpha\\n            }\\n          }]),\\n          fog: true,\\n          transparent: isTransparent,\\n          depthWrite: !isTransparent\\n        });\\n        edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\\n      }\\n\\n      material.userData.code = code;\\n      material.name = name;\\n      material.userData.edgeMaterial = edgeMaterial;\\n      return material;\\n    } //\\n\\n  }, {\\n    key: \\\"objectParse\\\",\\n    value: function objectParse(text) {\\n      // Retrieve data from the parent parse scope\\n      var parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\\n\\n      var mainColourCode = parentParseScope.mainColourCode;\\n      var mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\\n      var currentParseScope = this.getCurrentParseScope(); // Parse result variables\\n\\n      var triangles;\\n      var lineSegments;\\n      var conditionalSegments;\\n      var subobjects = [];\\n      var category = null;\\n      var keywords = null;\\n\\n      if (text.indexOf('\\\\r\\\\n') !== -1) {\\n        // This is faster than String.split with regex that splits on both\\n        text = text.replace(/\\\\r\\\\n/g, '\\\\n');\\n      }\\n\\n      var lines = text.split('\\\\n');\\n      var numLines = lines.length;\\n      var parsingEmbeddedFiles = false;\\n      var currentEmbeddedFileName = null;\\n      var currentEmbeddedText = null;\\n      var bfcCertified = false;\\n      var bfcCCW = true;\\n      var bfcInverted = false;\\n      var bfcCull = true;\\n      var type = '';\\n      var startingConstructionStep = false;\\n      var scope = this;\\n\\n      function parseColourCode(lineParser, forEdge) {\\n        // Parses next colour code and returns a THREE.Material\\n        var colourCode = lineParser.getToken();\\n\\n        if (!forEdge && colourCode === '16') {\\n          colourCode = mainColourCode;\\n        }\\n\\n        if (forEdge && colourCode === '24') {\\n          colourCode = mainEdgeColourCode;\\n        }\\n\\n        var material = scope.getMaterial(colourCode);\\n\\n        if (!material) {\\n          throw 'LDrawLoader: Unknown colour code \\\"' + colourCode + '\\\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\\n        }\\n\\n        return material;\\n      }\\n\\n      function parseVector(lp) {\\n        var v = new _three.Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\\n\\n        if (!scope.separateObjects) {\\n          v.applyMatrix4(currentParseScope.currentMatrix);\\n        }\\n\\n        return v;\\n      } // Parse all line commands\\n\\n\\n      for (var lineIndex = 0; lineIndex < numLines; lineIndex++) {\\n        var line = lines[lineIndex];\\n        if (line.length === 0) continue;\\n\\n        if (parsingEmbeddedFiles) {\\n          if (line.startsWith('0 FILE ')) {\\n            // Save previous embedded file in the cache\\n            this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\\n\\n            currentEmbeddedFileName = line.substring(7);\\n            currentEmbeddedText = '';\\n          } else {\\n            currentEmbeddedText += line + '\\\\n';\\n          }\\n\\n          continue;\\n        }\\n\\n        var lp = new LineParser(line, lineIndex + 1);\\n        lp.seekNonSpace();\\n\\n        if (lp.isAtTheEnd()) {\\n          // Empty line\\n          continue;\\n        } // Parse the line type\\n\\n\\n        var lineType = lp.getToken();\\n        var material = void 0;\\n        var segment = void 0;\\n        var inverted = void 0;\\n        var ccw = void 0;\\n        var doubleSided = void 0;\\n        var v0 = void 0,\\n            v1 = void 0,\\n            v2 = void 0,\\n            v3 = void 0,\\n            faceNormal = void 0;\\n\\n        switch (lineType) {\\n          // Line type 0: Comment or META\\n          case '0':\\n            // Parse meta directive\\n            var meta = lp.getToken();\\n\\n            if (meta) {\\n              switch (meta) {\\n                case '!LDRAW_ORG':\\n                  type = lp.getToken();\\n                  currentParseScope.triangles = [];\\n                  currentParseScope.lineSegments = [];\\n                  currentParseScope.conditionalSegments = [];\\n                  currentParseScope.type = type;\\n                  var isRoot = !parentParseScope.isFromParse;\\n\\n                  if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\\n                    currentParseScope.groupObject = new _three.Group();\\n                    currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\\n                  } // If the scale of the object is negated then the triangle winding order\\n                  // needs to be flipped.\\n\\n\\n                  if (currentParseScope.matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\\n                    currentParseScope.inverted = !currentParseScope.inverted;\\n                  }\\n\\n                  triangles = currentParseScope.triangles;\\n                  lineSegments = currentParseScope.lineSegments;\\n                  conditionalSegments = currentParseScope.conditionalSegments;\\n                  break;\\n\\n                case '!COLOUR':\\n                  material = this.parseColourMetaDirective(lp);\\n\\n                  if (material) {\\n                    this.addMaterial(material);\\n                  } else {\\n                    console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\\n                  }\\n\\n                  break;\\n\\n                case '!CATEGORY':\\n                  category = lp.getToken();\\n                  break;\\n\\n                case '!KEYWORDS':\\n                  var newKeywords = lp.getRemainingString().split(',');\\n\\n                  if (newKeywords.length > 0) {\\n                    if (!keywords) {\\n                      keywords = [];\\n                    }\\n\\n                    newKeywords.forEach(function (keyword) {\\n                      keywords.push(keyword.trim());\\n                    });\\n                  }\\n\\n                  break;\\n\\n                case 'FILE':\\n                  if (lineIndex > 0) {\\n                    // Start embedded text files parsing\\n                    parsingEmbeddedFiles = true;\\n                    currentEmbeddedFileName = lp.getRemainingString();\\n                    currentEmbeddedText = '';\\n                    bfcCertified = false;\\n                    bfcCCW = true;\\n                  }\\n\\n                  break;\\n\\n                case 'BFC':\\n                  // Changes to the backface culling state\\n                  while (!lp.isAtTheEnd()) {\\n                    var token = lp.getToken();\\n\\n                    switch (token) {\\n                      case 'CERTIFY':\\n                      case 'NOCERTIFY':\\n                        bfcCertified = token === 'CERTIFY';\\n                        bfcCCW = true;\\n                        break;\\n\\n                      case 'CW':\\n                      case 'CCW':\\n                        bfcCCW = token === 'CCW';\\n                        break;\\n\\n                      case 'INVERTNEXT':\\n                        bfcInverted = true;\\n                        break;\\n\\n                      case 'CLIP':\\n                      case 'NOCLIP':\\n                        bfcCull = token === 'CLIP';\\n                        break;\\n\\n                      default:\\n                        console.warn('THREE.LDrawLoader: BFC directive \\\"' + token + '\\\" is unknown.');\\n                        break;\\n                    }\\n                  }\\n\\n                  break;\\n\\n                case 'STEP':\\n                  startingConstructionStep = true;\\n                  break;\\n              }\\n            }\\n\\n            break;\\n          // Line type 1: Sub-object file\\n\\n          case '1':\\n            material = parseColourCode(lp);\\n            var posX = parseFloat(lp.getToken());\\n            var posY = parseFloat(lp.getToken());\\n            var posZ = parseFloat(lp.getToken());\\n            var m0 = parseFloat(lp.getToken());\\n            var m1 = parseFloat(lp.getToken());\\n            var m2 = parseFloat(lp.getToken());\\n            var m3 = parseFloat(lp.getToken());\\n            var m4 = parseFloat(lp.getToken());\\n            var m5 = parseFloat(lp.getToken());\\n            var m6 = parseFloat(lp.getToken());\\n            var m7 = parseFloat(lp.getToken());\\n            var m8 = parseFloat(lp.getToken());\\n            var matrix = new _three.Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\\n            var fileName = lp.getRemainingString().trim().replace(/\\\\\\\\/g, '/');\\n\\n            if (scope.fileMap[fileName]) {\\n              // Found the subobject path in the preloaded file path map\\n              fileName = scope.fileMap[fileName];\\n            } else {\\n              // Standardized subfolders\\n              if (fileName.startsWith('s/')) {\\n                fileName = 'parts/' + fileName;\\n              } else if (fileName.startsWith('48/')) {\\n                fileName = 'p/' + fileName;\\n              }\\n            }\\n\\n            subobjects.push({\\n              material: material,\\n              matrix: matrix,\\n              fileName: fileName,\\n              originalFileName: fileName,\\n              locationState: FILE_LOCATION_AS_IS,\\n              url: null,\\n              triedLowerCase: false,\\n              inverted: bfcInverted !== currentParseScope.inverted,\\n              startingConstructionStep: startingConstructionStep\\n            });\\n            bfcInverted = false;\\n            break;\\n          // Line type 2: Line segment\\n\\n          case '2':\\n            material = parseColourCode(lp, true);\\n            segment = {\\n              material: material.userData.edgeMaterial,\\n              colourCode: material.userData.code,\\n              v0: parseVector(lp),\\n              v1: parseVector(lp)\\n            };\\n            lineSegments.push(segment);\\n            break;\\n          // Line type 5: Conditional Line segment\\n\\n          case '5':\\n            material = parseColourCode(lp, true);\\n            segment = {\\n              material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\\n              colourCode: material.userData.code,\\n              v0: parseVector(lp),\\n              v1: parseVector(lp),\\n              c0: parseVector(lp),\\n              c1: parseVector(lp)\\n            };\\n            conditionalSegments.push(segment);\\n            break;\\n          // Line type 3: Triangle\\n\\n          case '3':\\n            material = parseColourCode(lp);\\n            inverted = currentParseScope.inverted;\\n            ccw = bfcCCW !== inverted;\\n            doubleSided = !bfcCertified || !bfcCull;\\n\\n            if (ccw === true) {\\n              v0 = parseVector(lp);\\n              v1 = parseVector(lp);\\n              v2 = parseVector(lp);\\n            } else {\\n              v2 = parseVector(lp);\\n              v1 = parseVector(lp);\\n              v0 = parseVector(lp);\\n            }\\n\\n            _tempVec0.subVectors(v1, v0);\\n\\n            _tempVec1.subVectors(v2, v1);\\n\\n            faceNormal = new _three.Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\\n            triangles.push({\\n              material: material,\\n              colourCode: material.userData.code,\\n              v0: v0,\\n              v1: v1,\\n              v2: v2,\\n              faceNormal: faceNormal,\\n              n0: null,\\n              n1: null,\\n              n2: null\\n            });\\n\\n            if (doubleSided === true) {\\n              triangles.push({\\n                material: material,\\n                colourCode: material.userData.code,\\n                v0: v0,\\n                v1: v2,\\n                v2: v1,\\n                faceNormal: faceNormal,\\n                n0: null,\\n                n1: null,\\n                n2: null\\n              });\\n            }\\n\\n            break;\\n          // Line type 4: Quadrilateral\\n\\n          case '4':\\n            material = parseColourCode(lp);\\n            inverted = currentParseScope.inverted;\\n            ccw = bfcCCW !== inverted;\\n            doubleSided = !bfcCertified || !bfcCull;\\n\\n            if (ccw === true) {\\n              v0 = parseVector(lp);\\n              v1 = parseVector(lp);\\n              v2 = parseVector(lp);\\n              v3 = parseVector(lp);\\n            } else {\\n              v3 = parseVector(lp);\\n              v2 = parseVector(lp);\\n              v1 = parseVector(lp);\\n              v0 = parseVector(lp);\\n            }\\n\\n            _tempVec0.subVectors(v1, v0);\\n\\n            _tempVec1.subVectors(v2, v1);\\n\\n            faceNormal = new _three.Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\\n            triangles.push({\\n              material: material,\\n              colourCode: material.userData.code,\\n              v0: v0,\\n              v1: v1,\\n              v2: v2,\\n              faceNormal: faceNormal,\\n              n0: null,\\n              n1: null,\\n              n2: null\\n            });\\n            triangles.push({\\n              material: material,\\n              colourCode: material.userData.code,\\n              v0: v0,\\n              v1: v2,\\n              v2: v3,\\n              faceNormal: faceNormal,\\n              n0: null,\\n              n1: null,\\n              n2: null\\n            });\\n\\n            if (doubleSided === true) {\\n              triangles.push({\\n                material: material,\\n                colourCode: material.userData.code,\\n                v0: v0,\\n                v1: v2,\\n                v2: v1,\\n                faceNormal: faceNormal,\\n                n0: null,\\n                n1: null,\\n                n2: null\\n              });\\n              triangles.push({\\n                material: material,\\n                colourCode: material.userData.code,\\n                v0: v0,\\n                v1: v3,\\n                v2: v2,\\n                faceNormal: faceNormal,\\n                n0: null,\\n                n1: null,\\n                n2: null\\n              });\\n            }\\n\\n            break;\\n\\n          default:\\n            throw 'LDrawLoader: Unknown line type \\\"' + lineType + '\\\"' + lp.getLineNumberString() + '.';\\n        }\\n      }\\n\\n      if (parsingEmbeddedFiles) {\\n        this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\\n      }\\n\\n      currentParseScope.category = category;\\n      currentParseScope.keywords = keywords;\\n      currentParseScope.subobjects = subobjects;\\n      currentParseScope.numSubobjects = subobjects.length;\\n      currentParseScope.subobjectIndex = 0;\\n    }\\n  }, {\\n    key: \\\"computeConstructionSteps\\\",\\n    value: function computeConstructionSteps(model) {\\n      // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\\n      var stepNumber = 0;\\n      model.traverse(function (c) {\\n        if (c.isGroup) {\\n          if (c.userData.startingConstructionStep) {\\n            stepNumber++;\\n          }\\n\\n          c.userData.constructionStep = stepNumber;\\n        }\\n      });\\n      model.userData.numConstructionSteps = stepNumber + 1;\\n    }\\n  }, {\\n    key: \\\"processObject\\\",\\n    value: function processObject(text, onProcessed, subobject, url) {\\n      var scope = this;\\n      var parseScope = scope.newParseScopeLevel();\\n      parseScope.url = url;\\n      var parentParseScope = scope.getParentParseScope(); // Set current matrix\\n\\n      if (subobject) {\\n        parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\\n        parseScope.matrix.copy(subobject.matrix);\\n        parseScope.inverted = subobject.inverted;\\n        parseScope.startingConstructionStep = subobject.startingConstructionStep;\\n      } // Add to cache\\n\\n\\n      var currentFileName = parentParseScope.currentFileName;\\n\\n      if (currentFileName !== null) {\\n        currentFileName = parentParseScope.currentFileName.toLowerCase();\\n      }\\n\\n      if (scope.subobjectCache[currentFileName] === undefined) {\\n        scope.subobjectCache[currentFileName] = text;\\n      } // Parse the object (returns a Group)\\n\\n\\n      scope.objectParse(text);\\n      var finishedCount = 0;\\n      onSubobjectFinish();\\n\\n      function onSubobjectFinish() {\\n        finishedCount++;\\n\\n        if (finishedCount === parseScope.subobjects.length + 1) {\\n          finalizeObject();\\n        } else {\\n          // Once the previous subobject has finished we can start processing the next one in the list.\\n          // The subobject processing shares scope in processing so it's important that they be loaded serially\\n          // to avoid race conditions.\\n          // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\\n          // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\\n          // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\\n          var _subobject = parseScope.subobjects[parseScope.subobjectIndex];\\n          Promise.resolve().then(function () {\\n            loadSubobject(_subobject);\\n          });\\n          parseScope.subobjectIndex++;\\n        }\\n      }\\n\\n      function finalizeObject() {\\n        if (scope.smoothNormals && parseScope.type === 'Part') {\\n          smoothNormals(parseScope.triangles, parseScope.lineSegments);\\n        }\\n\\n        var isRoot = !parentParseScope.isFromParse;\\n\\n        if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\\n          var objGroup = parseScope.groupObject;\\n\\n          if (parseScope.triangles.length > 0) {\\n            objGroup.add(createObject(parseScope.triangles, 3));\\n          }\\n\\n          if (parseScope.lineSegments.length > 0) {\\n            objGroup.add(createObject(parseScope.lineSegments, 2));\\n          }\\n\\n          if (parseScope.conditionalSegments.length > 0) {\\n            objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\\n          }\\n\\n          if (parentParseScope.groupObject) {\\n            objGroup.name = parseScope.fileName;\\n            objGroup.userData.category = parseScope.category;\\n            objGroup.userData.keywords = parseScope.keywords;\\n            parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\\n            parentParseScope.groupObject.add(objGroup);\\n          }\\n        } else {\\n          var separateObjects = scope.separateObjects;\\n          var parentLineSegments = parentParseScope.lineSegments;\\n          var parentConditionalSegments = parentParseScope.conditionalSegments;\\n          var parentTriangles = parentParseScope.triangles;\\n          var lineSegments = parseScope.lineSegments;\\n          var conditionalSegments = parseScope.conditionalSegments;\\n          var triangles = parseScope.triangles;\\n\\n          for (var i = 0, l = lineSegments.length; i < l; i++) {\\n            var ls = lineSegments[i];\\n\\n            if (separateObjects) {\\n              ls.v0.applyMatrix4(parseScope.matrix);\\n              ls.v1.applyMatrix4(parseScope.matrix);\\n            }\\n\\n            parentLineSegments.push(ls);\\n          }\\n\\n          for (var _i5 = 0, _l4 = conditionalSegments.length; _i5 < _l4; _i5++) {\\n            var os = conditionalSegments[_i5];\\n\\n            if (separateObjects) {\\n              os.v0.applyMatrix4(parseScope.matrix);\\n              os.v1.applyMatrix4(parseScope.matrix);\\n              os.c0.applyMatrix4(parseScope.matrix);\\n              os.c1.applyMatrix4(parseScope.matrix);\\n            }\\n\\n            parentConditionalSegments.push(os);\\n          }\\n\\n          for (var _i6 = 0, _l5 = triangles.length; _i6 < _l5; _i6++) {\\n            var tri = triangles[_i6];\\n\\n            if (separateObjects) {\\n              tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\\n              tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\\n              tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\\n\\n              _tempVec0.subVectors(tri.v1, tri.v0);\\n\\n              _tempVec1.subVectors(tri.v2, tri.v1);\\n\\n              tri.faceNormal.crossVectors(_tempVec0, _tempVec1).normalize();\\n            }\\n\\n            parentTriangles.push(tri);\\n          }\\n        }\\n\\n        scope.removeScopeLevel(); // If it is root object, compute construction steps\\n\\n        if (!parentParseScope.isFromParse) {\\n          scope.computeConstructionSteps(parseScope.groupObject);\\n        }\\n\\n        if (onProcessed) {\\n          onProcessed(parseScope.groupObject);\\n        }\\n      }\\n\\n      function loadSubobject(subobject) {\\n        parseScope.mainColourCode = subobject.material.userData.code;\\n        parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\\n        parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\\n\\n        var cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\\n\\n        if (cached) {\\n          scope.processObject(cached, function (subobjectGroup) {\\n            onSubobjectLoaded(subobjectGroup, subobject);\\n            onSubobjectFinish();\\n          }, subobject, url);\\n          return;\\n        } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\\n        // Update also subobject.locationState for the next try if this load fails.\\n\\n\\n        var subobjectURL = subobject.fileName;\\n        var newLocationState = FILE_LOCATION_NOT_FOUND;\\n\\n        switch (subobject.locationState) {\\n          case FILE_LOCATION_AS_IS:\\n            newLocationState = subobject.locationState + 1;\\n            break;\\n\\n          case FILE_LOCATION_TRY_PARTS:\\n            subobjectURL = 'parts/' + subobjectURL;\\n            newLocationState = subobject.locationState + 1;\\n            break;\\n\\n          case FILE_LOCATION_TRY_P:\\n            subobjectURL = 'p/' + subobjectURL;\\n            newLocationState = subobject.locationState + 1;\\n            break;\\n\\n          case FILE_LOCATION_TRY_MODELS:\\n            subobjectURL = 'models/' + subobjectURL;\\n            newLocationState = subobject.locationState + 1;\\n            break;\\n\\n          case FILE_LOCATION_TRY_RELATIVE:\\n            subobjectURL = url.substring(0, url.lastIndexOf('/') + 1) + subobjectURL;\\n            newLocationState = subobject.locationState + 1;\\n            break;\\n\\n          case FILE_LOCATION_TRY_ABSOLUTE:\\n            if (subobject.triedLowerCase) {\\n              // Try absolute path\\n              newLocationState = FILE_LOCATION_NOT_FOUND;\\n            } else {\\n              // Next attempt is lower case\\n              subobject.fileName = subobject.fileName.toLowerCase();\\n              subobjectURL = subobject.fileName;\\n              subobject.triedLowerCase = true;\\n              newLocationState = FILE_LOCATION_AS_IS;\\n            }\\n\\n            break;\\n\\n          case FILE_LOCATION_NOT_FOUND:\\n            // All location possibilities have been tried, give up loading this object\\n            console.warn('LDrawLoader: Subobject \\\"' + subobject.originalFileName + '\\\" could not be found.');\\n            return;\\n        }\\n\\n        subobject.locationState = newLocationState;\\n        subobject.url = subobjectURL; // Load the subobject\\n        // Use another file loader here so we can keep track of the subobject information\\n        // and use it when processing the next model.\\n\\n        var fileLoader = new _three.FileLoader(scope.manager);\\n        fileLoader.setPath(scope.path);\\n        fileLoader.setRequestHeader(scope.requestHeader);\\n        fileLoader.setWithCredentials(scope.withCredentials);\\n        fileLoader.load(subobjectURL, function (text) {\\n          scope.processObject(text, function (subobjectGroup) {\\n            onSubobjectLoaded(subobjectGroup, subobject);\\n            onSubobjectFinish();\\n          }, subobject, url);\\n        }, undefined, function (err) {\\n          onSubobjectError(err, subobject);\\n        }, subobject);\\n      }\\n\\n      function onSubobjectLoaded(subobjectGroup, subobject) {\\n        if (subobjectGroup === null) {\\n          // Try to reload\\n          loadSubobject(subobject);\\n          return;\\n        }\\n\\n        scope.fileMap[subobject.originalFileName] = subobject.url;\\n      }\\n\\n      function onSubobjectError(err, subobject) {\\n        // Retry download from a different default possible location\\n        loadSubobject(subobject);\\n      }\\n    }\\n  }]);\\n\\n  return LDrawLoader;\\n}(_three.Loader);\\n\\nexports.LDrawLoader = LDrawLoader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"_classCallCheck\",\"instance\",\"Constructor\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"defineProperty\",\"key\",\"_createClass\",\"protoProps\",\"staticProps\",\"smoothNormals\",\"triangles\",\"lineSegments\",\"hashVertex\",\"v\",\"y\",\"z\",\"concat\",\"x\",\"hashEdge\",\"v0\",\"v1\",\"hardEdges\",\"Set\",\"halfEdgeList\",\"fullHalfEdgeList\",\"normals\",\"l\",\"ls\",\"add\",\"_i\",\"_l\",\"tri\",\"i2\",\"l2\",\"next\",\"_v\",\"_v2\",\"hash\",\"has\",\"halfEdges\",\"keys\",\"_i2\",\"queue\",\"_tri\",\"_i3\",\"faceNormal\",\"n0\",\"clone\",\"push\",\"n1\",\"n2\",\"_l2\",\"_index\",\"_next\",\"_v3\",\"_v4\",\"_hash\",\"reverseHash\",\"otherTri\",\"Math\",\"abs\",\"dot\",\"i3\",\"l3\",\"otherIndex\",\"otherNext\",\"otherV0\",\"otherV1\",\"otherHash\",\"norm\",\"_norm\",\"_i4\",\"_l3\",\"normalize\",\"isPrimitiveType\",\"type\",\"test\",\"sortByMaterial\",\"a\",\"b\",\"colourCode\",\"createObject\",\"elements\",\"elementSize\",\"isConditionalSegments\",\"sort\",\"positions\",\"materials\",\"bufferGeometry\",\"_three\",\"BufferGeometry\",\"prevMaterial\",\"index0\",\"numGroupVerts\",\"iElem\",\"nElem\",\"elem\",\"v2\",\"material\",\"addGroup\",\"Infinity\",\"setAttribute\",\"Float32BufferAttribute\",\"object3d\",\"LineSegments\",\"Mesh\",\"isConditionalLine\",\"controlArray0\",\"Float32Array\",\"controlArray1\",\"directionArray\",\"os\",\"c0\",\"c1\",\"_v5\",\"_v6\",\"index\",\"BufferAttribute\",\"LDrawLoader\",\"_tempVec0\",\"Vector3\",\"_tempVec1\",\"LineParser\",\"line\",\"lineNumber\",\"lineLength\",\"currentCharIndex\",\"currentChar\",\"seekNonSpace\",\"charAt\",\"getToken\",\"pos0\",\"pos1\",\"substring\",\"getRemainingString\",\"isAtTheEnd\",\"setToEnd\",\"getLineNumberString\",\"_Loader\",\"manager\",\"call\",\"self\",\"ReferenceError\",\"_this\",\"parseScopesStack\",\"subobjectCache\",\"fileMap\",\"setMaterials\",\"parseColourMetaDirective\",\"separateObjects\",\"load\",\"url\",\"onLoad\",\"onProgress\",\"onError\",\"scope\",\"fileLoader\",\"FileLoader\",\"setPath\",\"path\",\"setRequestHeader\",\"requestHeader\",\"setWithCredentials\",\"withCredentials\",\"text\",\"processObject\",\"parse\",\"newParseScopeLevel\",\"getCurrentParseScope\",\"isFromParse\",\"setFileMap\",\"matLib\",\"n\",\"userData\",\"code\",\"topParseScope\",\"newParseScope\",\"lib\",\"subobjects\",\"numSubobjects\",\"subobjectIndex\",\"inverted\",\"category\",\"keywords\",\"currentFileName\",\"mainColourCode\",\"mainEdgeColourCode\",\"currentMatrix\",\"Matrix4\",\"matrix\",\"conditionalSegments\",\"startingConstructionStep\",\"removeScopeLevel\",\"pop\",\"addMaterial\",\"getMaterial\",\"startsWith\",\"colour\",\"getParentParseScope\",\"lineParser\",\"edgeColour\",\"alpha\",\"isTransparent\",\"luminance\",\"finishType\",\"FINISH_TYPE_DEFAULT\",\"canHaveEnvMap\",\"edgeMaterial\",\"name\",\"token\",\"toUpperCase\",\"parseInt\",\"isNaN\",\"max\",\"min\",\"FINISH_TYPE_CHROME\",\"FINISH_TYPE_PEARLESCENT\",\"FINISH_TYPE_RUBBER\",\"FINISH_TYPE_MATTE_METALLIC\",\"FINISH_TYPE_METAL\",\"MeshStandardMaterial\",\"color\",\"roughness\",\"envMapIntensity\",\"metalness\",\"specular\",\"Color\",\"hsl\",\"getHSL\",\"h\",\"s\",\"setHSL\",\"MeshPhongMaterial\",\"shininess\",\"reflectivity\",\"transparent\",\"premultipliedAlpha\",\"opacity\",\"depthWrite\",\"polygonOffset\",\"polygonOffsetFactor\",\"emissive\",\"set\",\"multiplyScalar\",\"LineBasicMaterial\",\"conditionalEdgeMaterial\",\"ShaderMaterial\",\"vertexShader\",\"conditionalLineVertShader\",\"fragmentShader\",\"conditionalLineFragShader\",\"uniforms\",\"UniformsUtils\",\"merge\",\"UniformsLib\",\"fog\",\"diffuse\",\"objectParse\",\"parseColourCode\",\"forEdge\",\"parseVector\",\"lp\",\"parseFloat\",\"applyMatrix4\",\"currentParseScope\",\"parentParseScope\",\"indexOf\",\"replace\",\"lines\",\"split\",\"numLines\",\"parsingEmbeddedFiles\",\"currentEmbeddedFileName\",\"currentEmbeddedText\",\"bfcCertified\",\"bfcCCW\",\"bfcInverted\",\"bfcCull\",\"lineIndex\",\"toLowerCase\",\"lineType\",\"segment\",\"ccw\",\"doubleSided\",\"v3\",\"meta\",\"isRoot\",\"groupObject\",\"Group\",\"determinant\",\"console\",\"warn\",\"newKeywords\",\"forEach\",\"keyword\",\"trim\",\"posX\",\"posY\",\"posZ\",\"m0\",\"m1\",\"m2\",\"m3\",\"m4\",\"m5\",\"m6\",\"m7\",\"m8\",\"fileName\",\"originalFileName\",\"locationState\",\"FILE_LOCATION_AS_IS\",\"triedLowerCase\",\"subVectors\",\"crossVectors\",\"computeConstructionSteps\",\"model\",\"stepNumber\",\"traverse\",\"c\",\"isGroup\",\"constructionStep\",\"numConstructionSteps\",\"onProcessed\",\"subobject\",\"onSubobjectFinish\",\"finishedCount\",\"parseScope\",\"finalizeObject\",\"_subobject\",\"Promise\",\"resolve\",\"then\",\"loadSubobject\",\"objGroup\",\"decompose\",\"position\",\"quaternion\",\"scale\",\"parentLineSegments\",\"parentConditionalSegments\",\"parentTriangles\",\"_i5\",\"_l4\",\"_i6\",\"_l5\",\"cached\",\"subobjectGroup\",\"subobjectURL\",\"newLocationState\",\"FILE_LOCATION_NOT_FOUND\",\"FILE_LOCATION_TRY_PARTS\",\"FILE_LOCATION_TRY_P\",\"FILE_LOCATION_TRY_MODELS\",\"FILE_LOCATION_TRY_RELATIVE\",\"lastIndexOf\",\"FILE_LOCATION_TRY_ABSOLUTE\",\"undefined\",\"err\",\"multiplyMatrices\",\"copy\",\"Loader\"]\n}\n"]