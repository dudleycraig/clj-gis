["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/SobelOperatorShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$SobelOperatorShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.SobelOperatorShader=void 0;global={uniforms:{tDiffuse:{value:null},resolution:{value:new (require(\"module$node_modules$three$build$three_module\").Vector2)}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform sampler2D tDiffuse;\\nuniform vec2 resolution;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec2 texel \\x3d vec2( 1.0 / resolution.x, 1.0 / resolution.y );\\n\\tconst mat3 Gx \\x3d mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );\\n\\tconst mat3 Gy \\x3d mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );\\n\\tfloat tx0y0 \\x3d texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\\n\\tfloat tx0y1 \\x3d texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\\n\\tfloat tx0y2 \\x3d texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\\n\\tfloat tx1y0 \\x3d texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\\n\\tfloat tx1y1 \\x3d texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\\n\\tfloat tx1y2 \\x3d texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\\n\\tfloat tx2y0 \\x3d texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\\n\\tfloat tx2y1 \\x3d texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\\n\\tfloat tx2y2 \\x3d texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\\n\\tfloat valueGx \\x3d Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \\n\\t\\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \\n\\t\\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \\n\\tfloat valueGy \\x3d Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \\n\\t\\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \\n\\t\\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \\n\\tfloat G \\x3d sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\\n\\tgl_FragColor \\x3d vec4( vec3( G ), 1 );\\n}\"};\nexports.SobelOperatorShader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$SobelOperatorShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SobelOperatorShader = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n *\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\n *\n */\nvar SobelOperatorShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new _three.Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );', // kernel definition (in glsl matrices are filled in column-major order)\n  '\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );', // x direction kernel\n  '\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );', // y direction kernel\n  // fetch the 3x3 neighbourhood of a fragment\n  // first column\n  '\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;', '\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;', '\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;', // second column\n  '\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;', '\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;', '\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;', // third column\n  '\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;', '\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;', '\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;', // gradient value in x direction\n  '\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ', '\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ', '\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ', // gradient value in y direction\n  '\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ', '\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ', '\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ', // magnitute of the total gradient\n  '\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );', '\tgl_FragColor = vec4( vec3( G ), 1 );', '}'].join('\\n')\n};\nexports.SobelOperatorShader = SobelOperatorShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","__esModule","tDiffuse","vertexShader","value","uniforms","SobelOperatorShader","resolution"]],"~:compiled-at",1630917515590,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$SobelOperatorShader.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,4DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGzHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,mBAAR,CAA8B,IAAK,EAU/BA,OAAAA,CAAsB,CACxBC,SAAU,CACRC,SAAU,CACRH,MAAO,IADC,CADF,CAIRI,WAAY,CACVJ,MAAO,KAdAL,OAAAU,CAAQ,8CAARA,CAcWC,CAAAA,OAAX,CADG,CAJJ,CADc,CASxBC,aAAiJ,qIATzH,CAUxBC,eAU8G,s8CApBtF,CAsB1BX;OAAQI,CAAAA,mBAAR,CAA8BA,MAtC2F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/SobelOperatorShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$SobelOperatorShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.SobelOperatorShader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\\n *\\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\\n *\\n */\\nvar SobelOperatorShader = {\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    resolution: {\\n      value: new _three.Vector2()\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );', // kernel definition (in glsl matrices are filled in column-major order)\\n  '\\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );', // x direction kernel\\n  '\\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );', // y direction kernel\\n  // fetch the 3x3 neighbourhood of a fragment\\n  // first column\\n  '\\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;', '\\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;', '\\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;', // second column\\n  '\\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;', '\\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;', '\\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;', // third column\\n  '\\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;', '\\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;', '\\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;', // gradient value in x direction\\n  '\\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ', '\\t\\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ', '\\t\\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ', // gradient value in y direction\\n  '\\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ', '\\t\\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ', '\\t\\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ', // magnitute of the total gradient\\n  '\\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );', '\\tgl_FragColor = vec4( vec3( G ), 1 );', '}'].join('\\\\n')\\n};\\nexports.SobelOperatorShader = SobelOperatorShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"SobelOperatorShader\",\"uniforms\",\"tDiffuse\",\"resolution\",\"_three\",\"Vector2\",\"vertexShader\",\"fragmentShader\"]\n}\n"]