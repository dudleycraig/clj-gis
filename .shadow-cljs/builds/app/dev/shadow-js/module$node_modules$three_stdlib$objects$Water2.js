["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/objects/Water2.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$objects$Water2=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _possibleConstructorReturn(self,call){return!call||\"object\"!==_typeof(call)&&\"function\"!==typeof call?\n_assertThisInitialized(self):call}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");\nsubClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.Water2=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_Reflector=\nrequire(\"module$node_modules$three_stdlib$objects$Reflector\"),_Refractor=require(\"module$node_modules$three_stdlib$objects$Refractor\");global=function(_Mesh){function Water2(geometry){var options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!(this instanceof Water2))throw new TypeError(\"Cannot call a class as a function\");var _this=_possibleConstructorReturn(this,_getPrototypeOf(Water2).call(this,geometry));_this.type=\"Water\";var scope=_assertThisInitialized(_this),color=void 0!==\noptions.color?new _three.Color(options.color):new _three.Color(16777215),textureWidth=options.textureWidth||512,textureHeight=options.textureHeight||512,clipBias=options.clipBias||0,flowDirection=options.flowDirection||new _three.Vector2(1,0),flowSpeed=options.flowSpeed||.03,reflectivity=options.reflectivity||.02,scale=options.scale||1,shader=options.shader||Water.WaterShader,encoding=void 0!==options.encoding?options.encoding:_three.LinearEncoding,textureLoader=new _three.TextureLoader,flowMap=options.flowMap||\nvoid 0,normalMap0=options.normalMap0||textureLoader.load(\"textures/water/Water_1_M_Normal.jpg\");options=options.normalMap1||textureLoader.load(\"textures/water/Water_2_M_Normal.jpg\");var textureMatrix=new _three.Matrix4,clock=new _three.Clock;if(void 0===_Reflector.Reflector)return console.error(\"THREE.Water: Required component Reflector not found.\"),_possibleConstructorReturn(_this);if(void 0===_Refractor.Refractor)return console.error(\"THREE.Water: Required component Refractor not found.\"),_possibleConstructorReturn(_this);\nvar reflector=new _Reflector.Reflector(geometry,{textureWidth,textureHeight,clipBias,encoding}),refractor=new _Refractor.Refractor(geometry,{textureWidth,textureHeight,clipBias,encoding});reflector.matrixAutoUpdate=!1;refractor.matrixAutoUpdate=!1;_this.material=new _three.ShaderMaterial({uniforms:_three.UniformsUtils.merge([_three.UniformsLib.fog,shader.uniforms]),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader,transparent:!0,fog:!0});void 0!==flowMap?(_this.material.defines.USE_FLOWMAP=\n\"\",_this.material.uniforms.tFlowMap={type:\"t\",value:flowMap}):_this.material.uniforms.flowDirection={type:\"v2\",value:flowDirection};normalMap0.wrapS=normalMap0.wrapT=_three.RepeatWrapping;options.wrapS=options.wrapT=_three.RepeatWrapping;_this.material.uniforms.tReflectionMap.value=reflector.getRenderTarget().texture;_this.material.uniforms.tRefractionMap.value=refractor.getRenderTarget().texture;_this.material.uniforms.tNormalMap0.value=normalMap0;_this.material.uniforms.tNormalMap1.value=options;\n_this.material.uniforms.color.value=color;_this.material.uniforms.reflectivity.value=reflectivity;_this.material.uniforms.textureMatrix.value=textureMatrix;_this.material.uniforms.config.value.x=0;_this.material.uniforms.config.value.y=.075;_this.material.uniforms.config.value.z=.075;_this.material.uniforms.config.value.w=scale;_this.onBeforeRender=function(renderer,scene,camera){textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);textureMatrix.multiply(camera.projectionMatrix);textureMatrix.multiply(camera.matrixWorldInverse);\ntextureMatrix.multiply(scope.matrixWorld);var delta=clock.getDelta(),config=scope.material.uniforms.config;config.value.x+=flowSpeed*delta;config.value.y=config.value.x+.075;.15<=config.value.x?(config.value.x=0,config.value.y=.075):.15<=config.value.y&&(config.value.y-=.15);scope.visible=!1;reflector.matrixWorld.copy(scope.matrixWorld);refractor.matrixWorld.copy(scope.matrixWorld);reflector.onBeforeRender(renderer,scene,camera);refractor.onBeforeRender(renderer,scene,camera);scope.visible=!0};return _this}\n_inherits(Water2,_Mesh);return Water2}(_three.Mesh);exports.Water2=global;global.prototype.isWater=!0;global.WaterShader={uniforms:{color:{type:\"c\",value:null},reflectivity:{type:\"f\",value:0},tReflectionMap:{type:\"t\",value:null},tRefractionMap:{type:\"t\",value:null},tNormalMap0:{type:\"t\",value:null},tNormalMap1:{type:\"t\",value:null},textureMatrix:{type:\"m4\",value:null},config:{type:\"v4\",value:new _three.Vector4}},vertexShader:\"\\n\\n\\t\\t#include \\x3ccommon\\x3e\\n\\t\\t#include \\x3cfog_pars_vertex\\x3e\\n\\t\\t#include \\x3clogdepthbuf_pars_vertex\\x3e\\n\\n\\t\\tuniform mat4 textureMatrix;\\n\\n\\t\\tvarying vec4 vCoord;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tvarying vec3 vToEye;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv \\x3d uv;\\n\\t\\t\\tvCoord \\x3d textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tvec4 worldPosition \\x3d modelMatrix * vec4( position, 1.0 );\\n\\t\\t\\tvToEye \\x3d cameraPosition - worldPosition.xyz;\\n\\n\\t\\t\\tvec4 mvPosition \\x3d  viewMatrix * worldPosition; // used in fog_vertex\\n\\t\\t\\tgl_Position \\x3d projectionMatrix * mvPosition;\\n\\n\\t\\t\\t#include \\x3clogdepthbuf_vertex\\x3e\\n\\t\\t\\t#include \\x3cfog_vertex\\x3e\\n\\n\\t\\t}\",\nfragmentShader:\"\\n\\n\\t\\t#include \\x3ccommon\\x3e\\n\\t\\t#include \\x3cfog_pars_fragment\\x3e\\n\\t\\t#include \\x3clogdepthbuf_pars_fragment\\x3e\\n\\n\\t\\tuniform sampler2D tReflectionMap;\\n\\t\\tuniform sampler2D tRefractionMap;\\n\\t\\tuniform sampler2D tNormalMap0;\\n\\t\\tuniform sampler2D tNormalMap1;\\n\\n\\t\\t#ifdef USE_FLOWMAP\\n\\t\\t\\tuniform sampler2D tFlowMap;\\n\\t\\t#else\\n\\t\\t\\tuniform vec2 flowDirection;\\n\\t\\t#endif\\n\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform float reflectivity;\\n\\t\\tuniform vec4 config;\\n\\n\\t\\tvarying vec4 vCoord;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tvarying vec3 vToEye;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include \\x3clogdepthbuf_fragment\\x3e\\n\\n\\t\\t\\tfloat flowMapOffset0 \\x3d config.x;\\n\\t\\t\\tfloat flowMapOffset1 \\x3d config.y;\\n\\t\\t\\tfloat halfCycle \\x3d config.z;\\n\\t\\t\\tfloat scale \\x3d config.w;\\n\\n\\t\\t\\tvec3 toEye \\x3d normalize( vToEye );\\n\\n\\t\\t\\t// determine flow direction\\n\\t\\t\\tvec2 flow;\\n\\t\\t\\t#ifdef USE_FLOWMAP\\n\\t\\t\\t\\tflow \\x3d texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\\n\\t\\t\\t#else\\n\\t\\t\\t\\tflow \\x3d flowDirection;\\n\\t\\t\\t#endif\\n\\t\\t\\tflow.x *\\x3d - 1.0;\\n\\n\\t\\t\\t// sample normal maps (distort uvs with flowdata)\\n\\t\\t\\tvec4 normalColor0 \\x3d texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\\n\\t\\t\\tvec4 normalColor1 \\x3d texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\\n\\n\\t\\t\\t// linear interpolate to get the final normal color\\n\\t\\t\\tfloat flowLerp \\x3d abs( halfCycle - flowMapOffset0 ) / halfCycle;\\n\\t\\t\\tvec4 normalColor \\x3d mix( normalColor0, normalColor1, flowLerp );\\n\\n\\t\\t\\t// calculate normal vector\\n\\t\\t\\tvec3 normal \\x3d normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\\n\\n\\t\\t\\t// calculate the fresnel term to blend reflection and refraction maps\\n\\t\\t\\tfloat theta \\x3d max( dot( toEye, normal ), 0.0 );\\n\\t\\t\\tfloat reflectance \\x3d reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\\n\\n\\t\\t\\t// calculate final uv coords\\n\\t\\t\\tvec3 coord \\x3d vCoord.xyz / vCoord.w;\\n\\t\\t\\tvec2 uv \\x3d coord.xy + coord.z * normal.xz * 0.05;\\n\\n\\t\\t\\tvec4 reflectColor \\x3d texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\\n\\t\\t\\tvec4 refractColor \\x3d texture2D( tRefractionMap, uv );\\n\\n\\t\\t\\t// multiply water color with the mix of both textures\\n\\t\\t\\tgl_FragColor \\x3d vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\\n\\n\\t\\t\\t#include \\x3ctonemapping_fragment\\x3e\\n\\t\\t\\t#include \\x3cencodings_fragment\\x3e\\n\\t\\t\\t#include \\x3cfog_fragment\\x3e\\n\\n\\t\\t}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$objects$Water2\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Water2 = void 0;\n\nvar _three = require(\"three\");\n\nvar _Reflector = require(\"./Reflector.js\");\n\nvar _Refractor = require(\"./Refractor.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\nvar Water2 =\n/*#__PURE__*/\nfunction (_Mesh) {\n  _inherits(Water2, _Mesh);\n\n  function Water2(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Water2);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Water2).call(this, geometry));\n    _this.type = 'Water';\n\n    var scope = _assertThisInitialized(_this);\n\n    var color = options.color !== undefined ? new _three.Color(options.color) : new _three.Color(0xffffff);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var flowDirection = options.flowDirection || new _three.Vector2(1, 0);\n    var flowSpeed = options.flowSpeed || 0.03;\n    var reflectivity = options.reflectivity || 0.02;\n    var scale = options.scale || 1;\n    var shader = options.shader || Water.WaterShader;\n    var encoding = options.encoding !== undefined ? options.encoding : _three.LinearEncoding;\n    var textureLoader = new _three.TextureLoader();\n    var flowMap = options.flowMap || undefined;\n    var normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\n    var normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\n    var cycle = 0.15; // a cycle of a flow map phase\n\n    var halfCycle = cycle * 0.5;\n    var textureMatrix = new _three.Matrix4();\n    var clock = new _three.Clock(); // internal components\n\n    if (_Reflector.Reflector === undefined) {\n      console.error('THREE.Water: Required component Reflector not found.');\n      return _possibleConstructorReturn(_this);\n    }\n\n    if (_Refractor.Refractor === undefined) {\n      console.error('THREE.Water: Required component Refractor not found.');\n      return _possibleConstructorReturn(_this);\n    }\n\n    var reflector = new _Reflector.Reflector(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    var refractor = new _Refractor.Refractor(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false; // material\n\n    _this.material = new _three.ShaderMaterial({\n      uniforms: _three.UniformsUtils.merge([_three.UniformsLib['fog'], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n\n    if (flowMap !== undefined) {\n      _this.material.defines.USE_FLOWMAP = '';\n      _this.material.uniforms['tFlowMap'] = {\n        type: 't',\n        value: flowMap\n      };\n    } else {\n      _this.material.uniforms['flowDirection'] = {\n        type: 'v2',\n        value: flowDirection\n      };\n    } // maps\n\n\n    normalMap0.wrapS = normalMap0.wrapT = _three.RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = _three.RepeatWrapping;\n    _this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\n    _this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\n    _this.material.uniforms['tNormalMap0'].value = normalMap0;\n    _this.material.uniforms['tNormalMap1'].value = normalMap1; // water\n\n    _this.material.uniforms['color'].value = color;\n    _this.material.uniforms['reflectivity'].value = reflectivity;\n    _this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\n\n    _this.material.uniforms['config'].value.x = 0; // flowMapOffset0\n\n    _this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\n\n    _this.material.uniforms['config'].value.z = halfCycle; // halfCycle\n\n    _this.material.uniforms['config'].value.w = scale; // scale\n    // functions\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n\n    function updateFlow() {\n      var delta = clock.getDelta();\n      var config = scope.material.uniforms['config'];\n      config.value.x += flowSpeed * delta; // flowMapOffset0\n\n      config.value.y = config.value.x + halfCycle; // flowMapOffset1\n      // Important: The distance between offsets should be always the value of \"halfCycle\".\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\n      // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    } //\n\n\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n\n    return _this;\n  }\n\n  return Water2;\n}(_three.Mesh);\n\nexports.Water2 = Water2;\nWater2.prototype.isWater = true;\nWater2.WaterShader = {\n  uniforms: {\n    color: {\n      type: 'c',\n      value: null\n    },\n    reflectivity: {\n      type: 'f',\n      value: 0\n    },\n    tReflectionMap: {\n      type: 't',\n      value: null\n    },\n    tRefractionMap: {\n      type: 't',\n      value: null\n    },\n    tNormalMap0: {\n      type: 't',\n      value: null\n    },\n    tNormalMap1: {\n      type: 't',\n      value: null\n    },\n    textureMatrix: {\n      type: 'm4',\n      value: null\n    },\n    config: {\n      type: 'v4',\n      value: new _three.Vector4()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\n\\t\\t#include <common>\\n\\t\\t#include <fog_pars_vertex>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\tuniform mat4 textureMatrix;\\n\\n\\t\\tvarying vec4 vCoord;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tvarying vec3 vToEye;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = uv;\\n\\t\\t\\tvCoord = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n\\t\\t\\tvToEye = cameraPosition - worldPosition.xyz;\\n\\n\\t\\t\\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\\n\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t#include <fog_vertex>\\n\\n\\t\\t}\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\n\\t\\t#include <common>\\n\\t\\t#include <fog_pars_fragment>\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\n\\t\\tuniform sampler2D tReflectionMap;\\n\\t\\tuniform sampler2D tRefractionMap;\\n\\t\\tuniform sampler2D tNormalMap0;\\n\\t\\tuniform sampler2D tNormalMap1;\\n\\n\\t\\t#ifdef USE_FLOWMAP\\n\\t\\t\\tuniform sampler2D tFlowMap;\\n\\t\\t#else\\n\\t\\t\\tuniform vec2 flowDirection;\\n\\t\\t#endif\\n\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform float reflectivity;\\n\\t\\tuniform vec4 config;\\n\\n\\t\\tvarying vec4 vCoord;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tvarying vec3 vToEye;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\n\\t\\t\\tfloat flowMapOffset0 = config.x;\\n\\t\\t\\tfloat flowMapOffset1 = config.y;\\n\\t\\t\\tfloat halfCycle = config.z;\\n\\t\\t\\tfloat scale = config.w;\\n\\n\\t\\t\\tvec3 toEye = normalize( vToEye );\\n\\n\\t\\t\\t// determine flow direction\\n\\t\\t\\tvec2 flow;\\n\\t\\t\\t#ifdef USE_FLOWMAP\\n\\t\\t\\t\\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\\n\\t\\t\\t#else\\n\\t\\t\\t\\tflow = flowDirection;\\n\\t\\t\\t#endif\\n\\t\\t\\tflow.x *= - 1.0;\\n\\n\\t\\t\\t// sample normal maps (distort uvs with flowdata)\\n\\t\\t\\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\\n\\t\\t\\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\\n\\n\\t\\t\\t// linear interpolate to get the final normal color\\n\\t\\t\\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\\n\\t\\t\\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\\n\\n\\t\\t\\t// calculate normal vector\\n\\t\\t\\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\\n\\n\\t\\t\\t// calculate the fresnel term to blend reflection and refraction maps\\n\\t\\t\\tfloat theta = max( dot( toEye, normal ), 0.0 );\\n\\t\\t\\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\\n\\n\\t\\t\\t// calculate final uv coords\\n\\t\\t\\tvec3 coord = vCoord.xyz / vCoord.w;\\n\\t\\t\\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\\n\\n\\t\\t\\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\\n\\t\\t\\tvec4 refractColor = texture2D( tRefractionMap, uv );\\n\\n\\t\\t\\t// multiply water color with the mix of both textures\\n\\t\\t\\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <encodings_fragment>\\n\\t\\t\\t#include <fog_fragment>\\n\\n\\t\\t}\"\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$three_stdlib$objects$Refractor","~$module$node_modules$three_stdlib$objects$Reflector"]],"~:properties",["^5",["fragmentShader","USE_FLOWMAP","z","w","wrapS","reflectivity","config","tNormalMap1","textureMatrix","prototype","Water2","transparent","fog","x","__esModule","onBeforeRender","matrixAutoUpdate","encoding","vertexShader","configurable","value","tNormalMap0","visible","textureHeight","writable","type","y","wrapT","__proto__","WaterShader","isWater","textureWidth","clipBias","uniforms","tRefractionMap","tReflectionMap","color","constructor","material"]],"~:compiled-at",1630917515395,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$objects$Water2.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/objects/Water2.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$objects$Water2\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.Water2 = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _Reflector = require(\\\"./Reflector.js\\\");\\n\\nvar _Refractor = require(\\\"./Refractor.js\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * References:\\n *\\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\\n * \\thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\\n *\\n */\\nvar Water2 =\\n/*#__PURE__*/\\nfunction (_Mesh) {\\n  _inherits(Water2, _Mesh);\\n\\n  function Water2(geometry) {\\n    var _this;\\n\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n    _classCallCheck(this, Water2);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Water2).call(this, geometry));\\n    _this.type = 'Water';\\n\\n    var scope = _assertThisInitialized(_this);\\n\\n    var color = options.color !== undefined ? new _three.Color(options.color) : new _three.Color(0xffffff);\\n    var textureWidth = options.textureWidth || 512;\\n    var textureHeight = options.textureHeight || 512;\\n    var clipBias = options.clipBias || 0;\\n    var flowDirection = options.flowDirection || new _three.Vector2(1, 0);\\n    var flowSpeed = options.flowSpeed || 0.03;\\n    var reflectivity = options.reflectivity || 0.02;\\n    var scale = options.scale || 1;\\n    var shader = options.shader || Water.WaterShader;\\n    var encoding = options.encoding !== undefined ? options.encoding : _three.LinearEncoding;\\n    var textureLoader = new _three.TextureLoader();\\n    var flowMap = options.flowMap || undefined;\\n    var normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\\n    var normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\\n    var cycle = 0.15; // a cycle of a flow map phase\\n\\n    var halfCycle = cycle * 0.5;\\n    var textureMatrix = new _three.Matrix4();\\n    var clock = new _three.Clock(); // internal components\\n\\n    if (_Reflector.Reflector === undefined) {\\n      console.error('THREE.Water: Required component Reflector not found.');\\n      return _possibleConstructorReturn(_this);\\n    }\\n\\n    if (_Refractor.Refractor === undefined) {\\n      console.error('THREE.Water: Required component Refractor not found.');\\n      return _possibleConstructorReturn(_this);\\n    }\\n\\n    var reflector = new _Reflector.Reflector(geometry, {\\n      textureWidth: textureWidth,\\n      textureHeight: textureHeight,\\n      clipBias: clipBias,\\n      encoding: encoding\\n    });\\n    var refractor = new _Refractor.Refractor(geometry, {\\n      textureWidth: textureWidth,\\n      textureHeight: textureHeight,\\n      clipBias: clipBias,\\n      encoding: encoding\\n    });\\n    reflector.matrixAutoUpdate = false;\\n    refractor.matrixAutoUpdate = false; // material\\n\\n    _this.material = new _three.ShaderMaterial({\\n      uniforms: _three.UniformsUtils.merge([_three.UniformsLib['fog'], shader.uniforms]),\\n      vertexShader: shader.vertexShader,\\n      fragmentShader: shader.fragmentShader,\\n      transparent: true,\\n      fog: true\\n    });\\n\\n    if (flowMap !== undefined) {\\n      _this.material.defines.USE_FLOWMAP = '';\\n      _this.material.uniforms['tFlowMap'] = {\\n        type: 't',\\n        value: flowMap\\n      };\\n    } else {\\n      _this.material.uniforms['flowDirection'] = {\\n        type: 'v2',\\n        value: flowDirection\\n      };\\n    } // maps\\n\\n\\n    normalMap0.wrapS = normalMap0.wrapT = _three.RepeatWrapping;\\n    normalMap1.wrapS = normalMap1.wrapT = _three.RepeatWrapping;\\n    _this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\\n    _this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\\n    _this.material.uniforms['tNormalMap0'].value = normalMap0;\\n    _this.material.uniforms['tNormalMap1'].value = normalMap1; // water\\n\\n    _this.material.uniforms['color'].value = color;\\n    _this.material.uniforms['reflectivity'].value = reflectivity;\\n    _this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\\n\\n    _this.material.uniforms['config'].value.x = 0; // flowMapOffset0\\n\\n    _this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\\n\\n    _this.material.uniforms['config'].value.z = halfCycle; // halfCycle\\n\\n    _this.material.uniforms['config'].value.w = scale; // scale\\n    // functions\\n\\n    function updateTextureMatrix(camera) {\\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\\n      textureMatrix.multiply(camera.projectionMatrix);\\n      textureMatrix.multiply(camera.matrixWorldInverse);\\n      textureMatrix.multiply(scope.matrixWorld);\\n    }\\n\\n    function updateFlow() {\\n      var delta = clock.getDelta();\\n      var config = scope.material.uniforms['config'];\\n      config.value.x += flowSpeed * delta; // flowMapOffset0\\n\\n      config.value.y = config.value.x + halfCycle; // flowMapOffset1\\n      // Important: The distance between offsets should be always the value of \\\"halfCycle\\\".\\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\\n      // This approach ensures a smooth water flow and avoids \\\"reset\\\" effects.\\n\\n      if (config.value.x >= cycle) {\\n        config.value.x = 0;\\n        config.value.y = halfCycle;\\n      } else if (config.value.y >= cycle) {\\n        config.value.y = config.value.y - cycle;\\n      }\\n    } //\\n\\n\\n    _this.onBeforeRender = function (renderer, scene, camera) {\\n      updateTextureMatrix(camera);\\n      updateFlow();\\n      scope.visible = false;\\n      reflector.matrixWorld.copy(scope.matrixWorld);\\n      refractor.matrixWorld.copy(scope.matrixWorld);\\n      reflector.onBeforeRender(renderer, scene, camera);\\n      refractor.onBeforeRender(renderer, scene, camera);\\n      scope.visible = true;\\n    };\\n\\n    return _this;\\n  }\\n\\n  return Water2;\\n}(_three.Mesh);\\n\\nexports.Water2 = Water2;\\nWater2.prototype.isWater = true;\\nWater2.WaterShader = {\\n  uniforms: {\\n    color: {\\n      type: 'c',\\n      value: null\\n    },\\n    reflectivity: {\\n      type: 'f',\\n      value: 0\\n    },\\n    tReflectionMap: {\\n      type: 't',\\n      value: null\\n    },\\n    tRefractionMap: {\\n      type: 't',\\n      value: null\\n    },\\n    tNormalMap0: {\\n      type: 't',\\n      value: null\\n    },\\n    tNormalMap1: {\\n      type: 't',\\n      value: null\\n    },\\n    textureMatrix: {\\n      type: 'm4',\\n      value: null\\n    },\\n    config: {\\n      type: 'v4',\\n      value: new _three.Vector4()\\n    }\\n  },\\n  vertexShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\n\\\\t\\\\t#include <common>\\\\n\\\\t\\\\t#include <fog_pars_vertex>\\\\n\\\\t\\\\t#include <logdepthbuf_pars_vertex>\\\\n\\\\n\\\\t\\\\tuniform mat4 textureMatrix;\\\\n\\\\n\\\\t\\\\tvarying vec4 vCoord;\\\\n\\\\t\\\\tvarying vec2 vUv;\\\\n\\\\t\\\\tvarying vec3 vToEye;\\\\n\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\tvUv = uv;\\\\n\\\\t\\\\t\\\\tvCoord = textureMatrix * vec4( position, 1.0 );\\\\n\\\\n\\\\t\\\\t\\\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\\\n\\\\t\\\\t\\\\tvToEye = cameraPosition - worldPosition.xyz;\\\\n\\\\n\\\\t\\\\t\\\\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\\\\n\\\\t\\\\t\\\\tgl_Position = projectionMatrix * mvPosition;\\\\n\\\\n\\\\t\\\\t\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t\\\\t\\\\t#include <fog_vertex>\\\\n\\\\n\\\\t\\\\t}\\\",\\n  fragmentShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\n\\\\t\\\\t#include <common>\\\\n\\\\t\\\\t#include <fog_pars_fragment>\\\\n\\\\t\\\\t#include <logdepthbuf_pars_fragment>\\\\n\\\\n\\\\t\\\\tuniform sampler2D tReflectionMap;\\\\n\\\\t\\\\tuniform sampler2D tRefractionMap;\\\\n\\\\t\\\\tuniform sampler2D tNormalMap0;\\\\n\\\\t\\\\tuniform sampler2D tNormalMap1;\\\\n\\\\n\\\\t\\\\t#ifdef USE_FLOWMAP\\\\n\\\\t\\\\t\\\\tuniform sampler2D tFlowMap;\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tuniform vec2 flowDirection;\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tuniform vec3 color;\\\\n\\\\t\\\\tuniform float reflectivity;\\\\n\\\\t\\\\tuniform vec4 config;\\\\n\\\\n\\\\t\\\\tvarying vec4 vCoord;\\\\n\\\\t\\\\tvarying vec2 vUv;\\\\n\\\\t\\\\tvarying vec3 vToEye;\\\\n\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\t#include <logdepthbuf_fragment>\\\\n\\\\n\\\\t\\\\t\\\\tfloat flowMapOffset0 = config.x;\\\\n\\\\t\\\\t\\\\tfloat flowMapOffset1 = config.y;\\\\n\\\\t\\\\t\\\\tfloat halfCycle = config.z;\\\\n\\\\t\\\\t\\\\tfloat scale = config.w;\\\\n\\\\n\\\\t\\\\t\\\\tvec3 toEye = normalize( vToEye );\\\\n\\\\n\\\\t\\\\t\\\\t// determine flow direction\\\\n\\\\t\\\\t\\\\tvec2 flow;\\\\n\\\\t\\\\t\\\\t#ifdef USE_FLOWMAP\\\\n\\\\t\\\\t\\\\t\\\\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tflow = flowDirection;\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tflow.x *= - 1.0;\\\\n\\\\n\\\\t\\\\t\\\\t// sample normal maps (distort uvs with flowdata)\\\\n\\\\t\\\\t\\\\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\\\\n\\\\t\\\\t\\\\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\\\\n\\\\n\\\\t\\\\t\\\\t// linear interpolate to get the final normal color\\\\n\\\\t\\\\t\\\\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\\\\n\\\\t\\\\t\\\\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\\\\n\\\\n\\\\t\\\\t\\\\t// calculate normal vector\\\\n\\\\t\\\\t\\\\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\\\\n\\\\n\\\\t\\\\t\\\\t// calculate the fresnel term to blend reflection and refraction maps\\\\n\\\\t\\\\t\\\\tfloat theta = max( dot( toEye, normal ), 0.0 );\\\\n\\\\t\\\\t\\\\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\\\\n\\\\n\\\\t\\\\t\\\\t// calculate final uv coords\\\\n\\\\t\\\\t\\\\tvec3 coord = vCoord.xyz / vCoord.w;\\\\n\\\\t\\\\t\\\\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\\\\n\\\\n\\\\t\\\\t\\\\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\\\\n\\\\t\\\\t\\\\tvec4 refractColor = texture2D( tRefractionMap, uv );\\\\n\\\\n\\\\t\\\\t\\\\t// multiply water color with the mix of both textures\\\\n\\\\t\\\\t\\\\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\\\\n\\\\n\\\\t\\\\t\\\\t#include <tonemapping_fragment>\\\\n\\\\t\\\\t\\\\t#include <encodings_fragment>\\\\n\\\\t\\\\t\\\\t#include <fog_fragment>\\\\n\\\\n\\\\t\\\\t}\\\"\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_possibleConstructorReturn\",\"self\",\"call\",\"_assertThisInitialized\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"ReferenceError\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"defineProperty\",\"Water2\",\"_three\",\"_Reflector\",\"_Refractor\",\"_Mesh\",\"geometry\",\"options\",\"arguments\",\"length\",\"undefined\",\"instance\",\"_this\",\"type\",\"scope\",\"color\",\"Color\",\"textureWidth\",\"textureHeight\",\"clipBias\",\"flowDirection\",\"Vector2\",\"flowSpeed\",\"reflectivity\",\"scale\",\"shader\",\"Water\",\"WaterShader\",\"encoding\",\"LinearEncoding\",\"textureLoader\",\"TextureLoader\",\"flowMap\",\"normalMap0\",\"load\",\"normalMap1\",\"textureMatrix\",\"Matrix4\",\"clock\",\"Clock\",\"Reflector\",\"console\",\"error\",\"Refractor\",\"reflector\",\"refractor\",\"matrixAutoUpdate\",\"material\",\"ShaderMaterial\",\"uniforms\",\"UniformsUtils\",\"merge\",\"UniformsLib\",\"vertexShader\",\"fragmentShader\",\"transparent\",\"fog\",\"defines\",\"USE_FLOWMAP\",\"wrapS\",\"wrapT\",\"RepeatWrapping\",\"getRenderTarget\",\"texture\",\"x\",\"y\",\"halfCycle\",\"z\",\"w\",\"onBeforeRender\",\"_this.onBeforeRender\",\"renderer\",\"scene\",\"camera\",\"set\",\"multiply\",\"projectionMatrix\",\"matrixWorldInverse\",\"matrixWorld\",\"delta\",\"getDelta\",\"config\",\"cycle\",\"visible\",\"copy\",\"Mesh\",\"isWater\",\"tReflectionMap\",\"tRefractionMap\",\"tNormalMap0\",\"tNormalMap1\",\"Vector4\"]\n}\n"]