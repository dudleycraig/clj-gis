["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/FXAAShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$FXAAShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.FXAAShader=void 0;global={uniforms:{tDiffuse:{value:null},resolution:{value:new (require(\"module$node_modules$three$build$three_module\").Vector2)(1/1024,1/512)}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:'precision highp float;\\n\\nuniform sampler2D tDiffuse;\\n\\nuniform vec2 resolution;\\n\\nvarying vec2 vUv;\\n\\n// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\\n\\n//----------------------------------------------------------------------------------\\n// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\\n// SDK Version: v3.00\\n// Email:       gameworks@nvidia.com\\n// Site:        http://developer.nvidia.com/\\n//\\n// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\\n//\\n// Redistribution and use in source and binary forms, with or without\\n// modification, are permitted provided that the following conditions\\n// are met:\\n//  * Redistributions of source code must retain the above copyright\\n//    notice, this list of conditions and the following disclaimer.\\n//  * Redistributions in binary form must reproduce the above copyright\\n//    notice, this list of conditions and the following disclaimer in the\\n//    documentation and/or other materials provided with the distribution.\\n//  * Neither the name of NVIDIA CORPORATION nor the names of its\\n//    contributors may be used to endorse or promote products derived\\n//    from this software without specific prior written permission.\\n//\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS\\'\\' AND ANY\\n// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\\n// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\\n// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n//\\n//----------------------------------------------------------------------------------\\n\\n#define FXAA_PC 1\\n#define FXAA_GLSL_100 1\\n#define FXAA_QUALITY_PRESET 12\\n\\n#define FXAA_GREEN_AS_LUMA 1\\n\\n/*--------------------------------------------------------------------------*/\\n#ifndef FXAA_PC_CONSOLE\\n    //\\n    // The console algorithm for PC is included\\n    // for developers targeting really low spec machines.\\n    // Likely better to just run FXAA_PC, and use a really low preset.\\n    //\\n    #define FXAA_PC_CONSOLE 0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#ifndef FXAA_GLSL_120\\n    #define FXAA_GLSL_120 0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#ifndef FXAA_GLSL_130\\n    #define FXAA_GLSL_130 0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#ifndef FXAA_HLSL_3\\n    #define FXAA_HLSL_3 0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#ifndef FXAA_HLSL_4\\n    #define FXAA_HLSL_4 0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#ifndef FXAA_HLSL_5\\n    #define FXAA_HLSL_5 0\\n#endif\\n/*\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d*/\\n#ifndef FXAA_GREEN_AS_LUMA\\n    //\\n    // For those using non-linear color,\\n    // and either not able to get luma in alpha, or not wanting to,\\n    // this enables FXAA to run using green as a proxy for luma.\\n    // So with this enabled, no need to pack luma in alpha.\\n    //\\n    // This will turn off AA on anything which lacks some amount of green.\\n    // Pure red and blue or combination of only R and B, will get no AA.\\n    //\\n    // Might want to lower the settings for both,\\n    //    fxaaConsoleEdgeThresholdMin\\n    //    fxaaQualityEdgeThresholdMin\\n    // In order to insure AA does not get turned off on colors\\n    // which contain a minor amount of green.\\n    //\\n    // 1 \\x3d On.\\n    // 0 \\x3d Off.\\n    //\\n    #define FXAA_GREEN_AS_LUMA 0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#ifndef FXAA_EARLY_EXIT\\n    //\\n    // Controls algorithm\\'s early exit path.\\n    // On PS3 turning this ON adds 2 cycles to the shader.\\n    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\\n    // Turning this off on console will result in a more blurry image.\\n    // So this defaults to on.\\n    //\\n    // 1 \\x3d On.\\n    // 0 \\x3d Off.\\n    //\\n    #define FXAA_EARLY_EXIT 1\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#ifndef FXAA_DISCARD\\n    //\\n    // Only valid for PC OpenGL currently.\\n    // Probably will not work when FXAA_GREEN_AS_LUMA \\x3d 1.\\n    //\\n    // 1 \\x3d Use discard on pixels which don\\'t need AA.\\n    //     For APIs which enable concurrent TEX+ROP from same surface.\\n    // 0 \\x3d Return unchanged color on pixels which don\\'t need AA.\\n    //\\n    #define FXAA_DISCARD 0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#ifndef FXAA_FAST_PIXEL_OFFSET\\n    //\\n    // Used for GLSL 120 only.\\n    //\\n    // 1 \\x3d GL API supports fast pixel offsets\\n    // 0 \\x3d do not use fast pixel offsets\\n    //\\n    #ifdef GL_EXT_gpu_shader4\\n        #define FXAA_FAST_PIXEL_OFFSET 1\\n    #endif\\n    #ifdef GL_NV_gpu_shader5\\n        #define FXAA_FAST_PIXEL_OFFSET 1\\n    #endif\\n    #ifdef GL_ARB_gpu_shader5\\n        #define FXAA_FAST_PIXEL_OFFSET 1\\n    #endif\\n    #ifndef FXAA_FAST_PIXEL_OFFSET\\n        #define FXAA_FAST_PIXEL_OFFSET 0\\n    #endif\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#ifndef FXAA_GATHER4_ALPHA\\n    //\\n    // 1 \\x3d API supports gather4 on alpha channel.\\n    // 0 \\x3d API does not support gather4 on alpha channel.\\n    //\\n    #if (FXAA_HLSL_5 \\x3d\\x3d 1)\\n        #define FXAA_GATHER4_ALPHA 1\\n    #endif\\n    #ifdef GL_ARB_gpu_shader5\\n        #define FXAA_GATHER4_ALPHA 1\\n    #endif\\n    #ifdef GL_NV_gpu_shader5\\n        #define FXAA_GATHER4_ALPHA 1\\n    #endif\\n    #ifndef FXAA_GATHER4_ALPHA\\n        #define FXAA_GATHER4_ALPHA 0\\n    #endif\\n#endif\\n\\n\\n/*\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\n                        FXAA QUALITY - TUNING KNOBS\\n------------------------------------------------------------------------------\\nNOTE the other tuning knobs are now in the shader function inputs!\\n\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d*/\\n#ifndef FXAA_QUALITY_PRESET\\n    //\\n    // Choose the quality preset.\\n    // This needs to be compiled into the shader as it effects code.\\n    // Best option to include multiple presets is to\\n    // in each shader define the preset, then include this file.\\n    //\\n    // OPTIONS\\n    // -----------------------------------------------------------------------\\n    // 10 to 15 - default medium dither (10\\x3dfastest, 15\\x3dhighest quality)\\n    // 20 to 29 - less dither, more expensive (20\\x3dfastest, 29\\x3dhighest quality)\\n    // 39       - no dither, very expensive\\n    //\\n    // NOTES\\n    // -----------------------------------------------------------------------\\n    // 12 \\x3d slightly faster then FXAA 3.9 and higher edge quality (default)\\n    // 13 \\x3d about same speed as FXAA 3.9 and better than 12\\n    // 23 \\x3d closest to FXAA 3.9 visually and performance wise\\n    //  _ \\x3d the lowest digit is directly related to performance\\n    // _  \\x3d the highest digit is directly related to style\\n    //\\n    #define FXAA_QUALITY_PRESET 12\\n#endif\\n\\n\\n/*\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\n\\n                           FXAA QUALITY - PRESETS\\n\\n\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d*/\\n\\n/*\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\n                     FXAA QUALITY - MEDIUM DITHER PRESETS\\n\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 10)\\n    #define FXAA_QUALITY_PS 3\\n    #define FXAA_QUALITY_P0 1.5\\n    #define FXAA_QUALITY_P1 3.0\\n    #define FXAA_QUALITY_P2 12.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 11)\\n    #define FXAA_QUALITY_PS 4\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 3.0\\n    #define FXAA_QUALITY_P3 12.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 12)\\n    #define FXAA_QUALITY_PS 5\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 4.0\\n    #define FXAA_QUALITY_P4 12.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 13)\\n    #define FXAA_QUALITY_PS 6\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 4.0\\n    #define FXAA_QUALITY_P5 12.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 14)\\n    #define FXAA_QUALITY_PS 7\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 2.0\\n    #define FXAA_QUALITY_P5 4.0\\n    #define FXAA_QUALITY_P6 12.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 15)\\n    #define FXAA_QUALITY_PS 8\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 2.0\\n    #define FXAA_QUALITY_P5 2.0\\n    #define FXAA_QUALITY_P6 4.0\\n    #define FXAA_QUALITY_P7 12.0\\n#endif\\n\\n/*\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\n                     FXAA QUALITY - LOW DITHER PRESETS\\n\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 20)\\n    #define FXAA_QUALITY_PS 3\\n    #define FXAA_QUALITY_P0 1.5\\n    #define FXAA_QUALITY_P1 2.0\\n    #define FXAA_QUALITY_P2 8.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 21)\\n    #define FXAA_QUALITY_PS 4\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 8.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 22)\\n    #define FXAA_QUALITY_PS 5\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 8.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 23)\\n    #define FXAA_QUALITY_PS 6\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 2.0\\n    #define FXAA_QUALITY_P5 8.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 24)\\n    #define FXAA_QUALITY_PS 7\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 2.0\\n    #define FXAA_QUALITY_P5 3.0\\n    #define FXAA_QUALITY_P6 8.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 25)\\n    #define FXAA_QUALITY_PS 8\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 2.0\\n    #define FXAA_QUALITY_P5 2.0\\n    #define FXAA_QUALITY_P6 4.0\\n    #define FXAA_QUALITY_P7 8.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 26)\\n    #define FXAA_QUALITY_PS 9\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 2.0\\n    #define FXAA_QUALITY_P5 2.0\\n    #define FXAA_QUALITY_P6 2.0\\n    #define FXAA_QUALITY_P7 4.0\\n    #define FXAA_QUALITY_P8 8.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 27)\\n    #define FXAA_QUALITY_PS 10\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 2.0\\n    #define FXAA_QUALITY_P5 2.0\\n    #define FXAA_QUALITY_P6 2.0\\n    #define FXAA_QUALITY_P7 2.0\\n    #define FXAA_QUALITY_P8 4.0\\n    #define FXAA_QUALITY_P9 8.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 28)\\n    #define FXAA_QUALITY_PS 11\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 2.0\\n    #define FXAA_QUALITY_P5 2.0\\n    #define FXAA_QUALITY_P6 2.0\\n    #define FXAA_QUALITY_P7 2.0\\n    #define FXAA_QUALITY_P8 2.0\\n    #define FXAA_QUALITY_P9 4.0\\n    #define FXAA_QUALITY_P10 8.0\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 29)\\n    #define FXAA_QUALITY_PS 12\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.5\\n    #define FXAA_QUALITY_P2 2.0\\n    #define FXAA_QUALITY_P3 2.0\\n    #define FXAA_QUALITY_P4 2.0\\n    #define FXAA_QUALITY_P5 2.0\\n    #define FXAA_QUALITY_P6 2.0\\n    #define FXAA_QUALITY_P7 2.0\\n    #define FXAA_QUALITY_P8 2.0\\n    #define FXAA_QUALITY_P9 2.0\\n    #define FXAA_QUALITY_P10 4.0\\n    #define FXAA_QUALITY_P11 8.0\\n#endif\\n\\n/*\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\n                     FXAA QUALITY - EXTREME QUALITY\\n\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d*/\\n#if (FXAA_QUALITY_PRESET \\x3d\\x3d 39)\\n    #define FXAA_QUALITY_PS 12\\n    #define FXAA_QUALITY_P0 1.0\\n    #define FXAA_QUALITY_P1 1.0\\n    #define FXAA_QUALITY_P2 1.0\\n    #define FXAA_QUALITY_P3 1.0\\n    #define FXAA_QUALITY_P4 1.0\\n    #define FXAA_QUALITY_P5 1.5\\n    #define FXAA_QUALITY_P6 2.0\\n    #define FXAA_QUALITY_P7 2.0\\n    #define FXAA_QUALITY_P8 2.0\\n    #define FXAA_QUALITY_P9 2.0\\n    #define FXAA_QUALITY_P10 4.0\\n    #define FXAA_QUALITY_P11 8.0\\n#endif\\n\\n\\n\\n/*\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\n\\n                                API PORTING\\n\\n\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d*/\\n#if (FXAA_GLSL_100 \\x3d\\x3d 1) || (FXAA_GLSL_120 \\x3d\\x3d 1) || (FXAA_GLSL_130 \\x3d\\x3d 1)\\n    #define FxaaBool bool\\n    #define FxaaDiscard discard\\n    #define FxaaFloat float\\n    #define FxaaFloat2 vec2\\n    #define FxaaFloat3 vec3\\n    #define FxaaFloat4 vec4\\n    #define FxaaHalf float\\n    #define FxaaHalf2 vec2\\n    #define FxaaHalf3 vec3\\n    #define FxaaHalf4 vec4\\n    #define FxaaInt2 ivec2\\n    #define FxaaSat(x) clamp(x, 0.0, 1.0)\\n    #define FxaaTex sampler2D\\n#else\\n    #define FxaaBool bool\\n    #define FxaaDiscard clip(-1)\\n    #define FxaaFloat float\\n    #define FxaaFloat2 float2\\n    #define FxaaFloat3 float3\\n    #define FxaaFloat4 float4\\n    #define FxaaHalf half\\n    #define FxaaHalf2 half2\\n    #define FxaaHalf3 half3\\n    #define FxaaHalf4 half4\\n    #define FxaaSat(x) saturate(x)\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_GLSL_100 \\x3d\\x3d 1)\\n  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\\n  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_GLSL_120 \\x3d\\x3d 1)\\n    // Requires,\\n    //  #version 120\\n    // And at least,\\n    //  #extension GL_EXT_gpu_shader4 : enable\\n    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\\n    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\\n    #if (FXAA_FAST_PIXEL_OFFSET \\x3d\\x3d 1)\\n        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\\n    #else\\n        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\\n    #endif\\n    #if (FXAA_GATHER4_ALPHA \\x3d\\x3d 1)\\n        // use #extension GL_ARB_gpu_shader5 : enable\\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\\n    #endif\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_GLSL_130 \\x3d\\x3d 1)\\n    // Requires \"#version 130\" or better\\n    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\\n    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\\n    #if (FXAA_GATHER4_ALPHA \\x3d\\x3d 1)\\n        // use #extension GL_ARB_gpu_shader5 : enable\\n        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\\n        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\\n        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\\n        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\\n    #endif\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_HLSL_3 \\x3d\\x3d 1)\\n    #define FxaaInt2 float2\\n    #define FxaaTex sampler2D\\n    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\\n    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_HLSL_4 \\x3d\\x3d 1)\\n    #define FxaaInt2 int2\\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\\n#endif\\n/*--------------------------------------------------------------------------*/\\n#if (FXAA_HLSL_5 \\x3d\\x3d 1)\\n    #define FxaaInt2 int2\\n    struct FxaaTex { SamplerState smpl; Texture2D tex; };\\n    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\\n    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\\n    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\\n    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\\n    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\\n    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\\n#endif\\n\\n\\n/*\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\n                   GREEN AS LUMA OPTION SUPPORT FUNCTION\\n\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d*/\\n#if (FXAA_GREEN_AS_LUMA \\x3d\\x3d 0)\\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\\n#else\\n    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\\n#endif\\n\\n\\n\\n\\n/*\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\n\\n                             FXAA3 QUALITY - PC\\n\\n\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d*/\\n#if (FXAA_PC \\x3d\\x3d 1)\\n/*--------------------------------------------------------------------------*/\\nFxaaFloat4 FxaaPixelShader(\\n    //\\n    // Use noperspective interpolation here (turn off perspective interpolation).\\n    // {xy} \\x3d center of pixel\\n    FxaaFloat2 pos,\\n    //\\n    // Used only for FXAA Console, and not used on the 360 version.\\n    // Use noperspective interpolation here (turn off perspective interpolation).\\n    // {xy_} \\x3d upper left of pixel\\n    // {_zw} \\x3d lower right of pixel\\n    FxaaFloat4 fxaaConsolePosPos,\\n    //\\n    // Input color texture.\\n    // {rgb_} \\x3d color in linear or perceptual color space\\n    // if (FXAA_GREEN_AS_LUMA \\x3d\\x3d 0)\\n    //     {__a} \\x3d luma in perceptual color space (not linear)\\n    FxaaTex tex,\\n    //\\n    // Only used on the optimized 360 version of FXAA Console.\\n    // For everything but 360, just use the same input here as for \"tex\".\\n    // For 360, same texture, just alias with a 2nd sampler.\\n    // This sampler needs to have an exponent bias of -1.\\n    FxaaTex fxaaConsole360TexExpBiasNegOne,\\n    //\\n    // Only used on the optimized 360 version of FXAA Console.\\n    // For everything but 360, just use the same input here as for \"tex\".\\n    // For 360, same texture, just alias with a 3nd sampler.\\n    // This sampler needs to have an exponent bias of -2.\\n    FxaaTex fxaaConsole360TexExpBiasNegTwo,\\n    //\\n    // Only used on FXAA Quality.\\n    // This must be from a constant/uniform.\\n    // {x_} \\x3d 1.0/screenWidthInPixels\\n    // {_y} \\x3d 1.0/screenHeightInPixels\\n    FxaaFloat2 fxaaQualityRcpFrame,\\n    //\\n    // Only used on FXAA Console.\\n    // This must be from a constant/uniform.\\n    // This effects sub-pixel AA quality and inversely sharpness.\\n    //   Where N ranges between,\\n    //     N \\x3d 0.50 (default)\\n    //     N \\x3d 0.33 (sharper)\\n    // {x__} \\x3d -N/screenWidthInPixels\\n    // {_y_} \\x3d -N/screenHeightInPixels\\n    // {_z_} \\x3d  N/screenWidthInPixels\\n    // {__w} \\x3d  N/screenHeightInPixels\\n    FxaaFloat4 fxaaConsoleRcpFrameOpt,\\n    //\\n    // Only used on FXAA Console.\\n    // Not used on 360, but used on PS3 and PC.\\n    // This must be from a constant/uniform.\\n    // {x__} \\x3d -2.0/screenWidthInPixels\\n    // {_y_} \\x3d -2.0/screenHeightInPixels\\n    // {_z_} \\x3d  2.0/screenWidthInPixels\\n    // {__w} \\x3d  2.0/screenHeightInPixels\\n    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\\n    //\\n    // Only used on FXAA Console.\\n    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\\n    // This must be from a constant/uniform.\\n    // {x__} \\x3d  8.0/screenWidthInPixels\\n    // {_y_} \\x3d  8.0/screenHeightInPixels\\n    // {_z_} \\x3d -4.0/screenWidthInPixels\\n    // {__w} \\x3d -4.0/screenHeightInPixels\\n    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\\n    //\\n    // Only used on FXAA Quality.\\n    // This used to be the FXAA_QUALITY_SUBPIX define.\\n    // It is here now to allow easier tuning.\\n    // Choose the amount of sub-pixel aliasing removal.\\n    // This can effect sharpness.\\n    //   1.00 - upper limit (softer)\\n    //   0.75 - default amount of filtering\\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\\n    //   0.25 - almost off\\n    //   0.00 - completely off\\n    FxaaFloat fxaaQualitySubpix,\\n    //\\n    // Only used on FXAA Quality.\\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\\n    // It is here now to allow easier tuning.\\n    // The minimum amount of local contrast required to apply algorithm.\\n    //   0.333 - too little (faster)\\n    //   0.250 - low quality\\n    //   0.166 - default\\n    //   0.125 - high quality\\n    //   0.063 - overkill (slower)\\n    FxaaFloat fxaaQualityEdgeThreshold,\\n    //\\n    // Only used on FXAA Quality.\\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\\n    // It is here now to allow easier tuning.\\n    // Trims the algorithm from processing darks.\\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\\n    //   0.0625 - high quality (faster)\\n    //   0.0312 - visible limit (slower)\\n    // Special notes when using FXAA_GREEN_AS_LUMA,\\n    //   Likely want to set this to zero.\\n    //   As colors that are mostly not-green\\n    //   will appear very dark in the green channel!\\n    //   Tune by looking at mostly non-green content,\\n    //   then start at zero and increase until aliasing is a problem.\\n    FxaaFloat fxaaQualityEdgeThresholdMin,\\n    //\\n    // Only used on FXAA Console.\\n    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\\n    // It is here now to allow easier tuning.\\n    // This does not effect PS3, as this needs to be compiled in.\\n    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\\n    //   Due to the PS3 being ALU bound,\\n    //   there are only three safe values here: 2 and 4 and 8.\\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\\n    // For all other platforms can be a non-power of two.\\n    //   8.0 is sharper (default!!!)\\n    //   4.0 is softer\\n    //   2.0 is really soft (good only for vector graphics inputs)\\n    FxaaFloat fxaaConsoleEdgeSharpness,\\n    //\\n    // Only used on FXAA Console.\\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\\n    // It is here now to allow easier tuning.\\n    // This does not effect PS3, as this needs to be compiled in.\\n    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\\n    //   Due to the PS3 being ALU bound,\\n    //   there are only two safe values here: 1/4 and 1/8.\\n    //   These options use the shaders ability to a free *|/ by 2|4|8.\\n    // The console setting has a different mapping than the quality setting.\\n    // Other platforms can use other values.\\n    //   0.125 leaves less aliasing, but is softer (default!!!)\\n    //   0.25 leaves more aliasing, and is sharper\\n    FxaaFloat fxaaConsoleEdgeThreshold,\\n    //\\n    // Only used on FXAA Console.\\n    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\\n    // It is here now to allow easier tuning.\\n    // Trims the algorithm from processing darks.\\n    // The console setting has a different mapping than the quality setting.\\n    // This only applies when FXAA_EARLY_EXIT is 1.\\n    // This does not apply to PS3,\\n    // PS3 was simplified to avoid more shader instructions.\\n    //   0.06 - faster but more aliasing in darks\\n    //   0.05 - default\\n    //   0.04 - slower and less aliasing in darks\\n    // Special notes when using FXAA_GREEN_AS_LUMA,\\n    //   Likely want to set this to zero.\\n    //   As colors that are mostly not-green\\n    //   will appear very dark in the green channel!\\n    //   Tune by looking at mostly non-green content,\\n    //   then start at zero and increase until aliasing is a problem.\\n    FxaaFloat fxaaConsoleEdgeThresholdMin,\\n    //\\n    // Extra constants for 360 FXAA Console only.\\n    // Use zeros or anything else for other platforms.\\n    // These must be in physical constant registers and NOT immediates.\\n    // Immediates will result in compiler un-optimizing.\\n    // {xyzw} \\x3d float4(1.0, -1.0, 0.25, -0.25)\\n    FxaaFloat4 fxaaConsole360ConstDir\\n) {\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat2 posM;\\n    posM.x \\x3d pos.x;\\n    posM.y \\x3d pos.y;\\n    #if (FXAA_GATHER4_ALPHA \\x3d\\x3d 1)\\n        #if (FXAA_DISCARD \\x3d\\x3d 0)\\n            FxaaFloat4 rgbyM \\x3d FxaaTexTop(tex, posM);\\n            #if (FXAA_GREEN_AS_LUMA \\x3d\\x3d 0)\\n                #define lumaM rgbyM.w\\n            #else\\n                #define lumaM rgbyM.y\\n            #endif\\n        #endif\\n        #if (FXAA_GREEN_AS_LUMA \\x3d\\x3d 0)\\n            FxaaFloat4 luma4A \\x3d FxaaTexAlpha4(tex, posM);\\n            FxaaFloat4 luma4B \\x3d FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\\n        #else\\n            FxaaFloat4 luma4A \\x3d FxaaTexGreen4(tex, posM);\\n            FxaaFloat4 luma4B \\x3d FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\\n        #endif\\n        #if (FXAA_DISCARD \\x3d\\x3d 1)\\n            #define lumaM luma4A.w\\n        #endif\\n        #define lumaE luma4A.z\\n        #define lumaS luma4A.x\\n        #define lumaSE luma4A.y\\n        #define lumaNW luma4B.w\\n        #define lumaN luma4B.z\\n        #define lumaW luma4B.x\\n    #else\\n        FxaaFloat4 rgbyM \\x3d FxaaTexTop(tex, posM);\\n        #if (FXAA_GREEN_AS_LUMA \\x3d\\x3d 0)\\n            #define lumaM rgbyM.w\\n        #else\\n            #define lumaM rgbyM.y\\n        #endif\\n        #if (FXAA_GLSL_100 \\x3d\\x3d 1)\\n          FxaaFloat lumaS \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaE \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaN \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaW \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\\n        #else\\n          FxaaFloat lumaS \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaE \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaN \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaW \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\\n        #endif\\n    #endif\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat maxSM \\x3d max(lumaS, lumaM);\\n    FxaaFloat minSM \\x3d min(lumaS, lumaM);\\n    FxaaFloat maxESM \\x3d max(lumaE, maxSM);\\n    FxaaFloat minESM \\x3d min(lumaE, minSM);\\n    FxaaFloat maxWN \\x3d max(lumaN, lumaW);\\n    FxaaFloat minWN \\x3d min(lumaN, lumaW);\\n    FxaaFloat rangeMax \\x3d max(maxWN, maxESM);\\n    FxaaFloat rangeMin \\x3d min(minWN, minESM);\\n    FxaaFloat rangeMaxScaled \\x3d rangeMax * fxaaQualityEdgeThreshold;\\n    FxaaFloat range \\x3d rangeMax - rangeMin;\\n    FxaaFloat rangeMaxClamped \\x3d max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\\n    FxaaBool earlyExit \\x3d range \\x3c rangeMaxClamped;\\n/*--------------------------------------------------------------------------*/\\n    if(earlyExit)\\n        #if (FXAA_DISCARD \\x3d\\x3d 1)\\n            FxaaDiscard;\\n        #else\\n            return rgbyM;\\n        #endif\\n/*--------------------------------------------------------------------------*/\\n    #if (FXAA_GATHER4_ALPHA \\x3d\\x3d 0)\\n        #if (FXAA_GLSL_100 \\x3d\\x3d 1)\\n          FxaaFloat lumaNW \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaSE \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaNE \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaSW \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\\n        #else\\n          FxaaFloat lumaNW \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaSE \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaNE \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\\n          FxaaFloat lumaSW \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\\n        #endif\\n    #else\\n        FxaaFloat lumaNE \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\\n        FxaaFloat lumaSW \\x3d FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\\n    #endif\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat lumaNS \\x3d lumaN + lumaS;\\n    FxaaFloat lumaWE \\x3d lumaW + lumaE;\\n    FxaaFloat subpixRcpRange \\x3d 1.0/range;\\n    FxaaFloat subpixNSWE \\x3d lumaNS + lumaWE;\\n    FxaaFloat edgeHorz1 \\x3d (-2.0 * lumaM) + lumaNS;\\n    FxaaFloat edgeVert1 \\x3d (-2.0 * lumaM) + lumaWE;\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat lumaNESE \\x3d lumaNE + lumaSE;\\n    FxaaFloat lumaNWNE \\x3d lumaNW + lumaNE;\\n    FxaaFloat edgeHorz2 \\x3d (-2.0 * lumaE) + lumaNESE;\\n    FxaaFloat edgeVert2 \\x3d (-2.0 * lumaN) + lumaNWNE;\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat lumaNWSW \\x3d lumaNW + lumaSW;\\n    FxaaFloat lumaSWSE \\x3d lumaSW + lumaSE;\\n    FxaaFloat edgeHorz4 \\x3d (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\\n    FxaaFloat edgeVert4 \\x3d (abs(edgeVert1) * 2.0) + abs(edgeVert2);\\n    FxaaFloat edgeHorz3 \\x3d (-2.0 * lumaW) + lumaNWSW;\\n    FxaaFloat edgeVert3 \\x3d (-2.0 * lumaS) + lumaSWSE;\\n    FxaaFloat edgeHorz \\x3d abs(edgeHorz3) + edgeHorz4;\\n    FxaaFloat edgeVert \\x3d abs(edgeVert3) + edgeVert4;\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat subpixNWSWNESE \\x3d lumaNWSW + lumaNESE;\\n    FxaaFloat lengthSign \\x3d fxaaQualityRcpFrame.x;\\n    FxaaBool horzSpan \\x3d edgeHorz \\x3e\\x3d edgeVert;\\n    FxaaFloat subpixA \\x3d subpixNSWE * 2.0 + subpixNWSWNESE;\\n/*--------------------------------------------------------------------------*/\\n    if(!horzSpan) lumaN \\x3d lumaW;\\n    if(!horzSpan) lumaS \\x3d lumaE;\\n    if(horzSpan) lengthSign \\x3d fxaaQualityRcpFrame.y;\\n    FxaaFloat subpixB \\x3d (subpixA * (1.0/12.0)) - lumaM;\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat gradientN \\x3d lumaN - lumaM;\\n    FxaaFloat gradientS \\x3d lumaS - lumaM;\\n    FxaaFloat lumaNN \\x3d lumaN + lumaM;\\n    FxaaFloat lumaSS \\x3d lumaS + lumaM;\\n    FxaaBool pairN \\x3d abs(gradientN) \\x3e\\x3d abs(gradientS);\\n    FxaaFloat gradient \\x3d max(abs(gradientN), abs(gradientS));\\n    if(pairN) lengthSign \\x3d -lengthSign;\\n    FxaaFloat subpixC \\x3d FxaaSat(abs(subpixB) * subpixRcpRange);\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat2 posB;\\n    posB.x \\x3d posM.x;\\n    posB.y \\x3d posM.y;\\n    FxaaFloat2 offNP;\\n    offNP.x \\x3d (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\\n    offNP.y \\x3d ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\\n    if(!horzSpan) posB.x +\\x3d lengthSign * 0.5;\\n    if( horzSpan) posB.y +\\x3d lengthSign * 0.5;\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat2 posN;\\n    posN.x \\x3d posB.x - offNP.x * FXAA_QUALITY_P0;\\n    posN.y \\x3d posB.y - offNP.y * FXAA_QUALITY_P0;\\n    FxaaFloat2 posP;\\n    posP.x \\x3d posB.x + offNP.x * FXAA_QUALITY_P0;\\n    posP.y \\x3d posB.y + offNP.y * FXAA_QUALITY_P0;\\n    FxaaFloat subpixD \\x3d ((-2.0)*subpixC) + 3.0;\\n    FxaaFloat lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN));\\n    FxaaFloat subpixE \\x3d subpixC * subpixC;\\n    FxaaFloat lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP));\\n/*--------------------------------------------------------------------------*/\\n    if(!pairN) lumaNN \\x3d lumaSS;\\n    FxaaFloat gradientScaled \\x3d gradient * 1.0/4.0;\\n    FxaaFloat lumaMM \\x3d lumaM - lumaNN * 0.5;\\n    FxaaFloat subpixF \\x3d subpixD * subpixE;\\n    FxaaBool lumaMLTZero \\x3d lumaMM \\x3c 0.0;\\n/*--------------------------------------------------------------------------*/\\n    lumaEndN -\\x3d lumaNN * 0.5;\\n    lumaEndP -\\x3d lumaNN * 0.5;\\n    FxaaBool doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n    FxaaBool doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n    if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P1;\\n    if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P1;\\n    FxaaBool doneNP \\x3d (!doneN) || (!doneP);\\n    if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P1;\\n    if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P1;\\n/*--------------------------------------------------------------------------*/\\n    if(doneNP) {\\n        if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n        if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n        if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n        if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n        doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n        doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n        if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P2;\\n        if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P2;\\n        doneNP \\x3d (!doneN) || (!doneP);\\n        if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P2;\\n        if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P2;\\n/*--------------------------------------------------------------------------*/\\n        #if (FXAA_QUALITY_PS \\x3e 3)\\n        if(doneNP) {\\n            if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n            if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n            if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n            if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n            doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n            doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n            if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P3;\\n            if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P3;\\n            doneNP \\x3d (!doneN) || (!doneP);\\n            if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P3;\\n            if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P3;\\n/*--------------------------------------------------------------------------*/\\n            #if (FXAA_QUALITY_PS \\x3e 4)\\n            if(doneNP) {\\n                if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n                if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n                if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n                if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n                doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n                doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n                if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P4;\\n                if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P4;\\n                doneNP \\x3d (!doneN) || (!doneP);\\n                if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P4;\\n                if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P4;\\n/*--------------------------------------------------------------------------*/\\n                #if (FXAA_QUALITY_PS \\x3e 5)\\n                if(doneNP) {\\n                    if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n                    if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n                    if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n                    if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n                    doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n                    doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n                    if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P5;\\n                    if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P5;\\n                    doneNP \\x3d (!doneN) || (!doneP);\\n                    if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P5;\\n                    if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P5;\\n/*--------------------------------------------------------------------------*/\\n                    #if (FXAA_QUALITY_PS \\x3e 6)\\n                    if(doneNP) {\\n                        if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n                        if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n                        if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n                        if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n                        doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n                        doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n                        if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P6;\\n                        if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P6;\\n                        doneNP \\x3d (!doneN) || (!doneP);\\n                        if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P6;\\n                        if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P6;\\n/*--------------------------------------------------------------------------*/\\n                        #if (FXAA_QUALITY_PS \\x3e 7)\\n                        if(doneNP) {\\n                            if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n                            if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n                            if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n                            if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n                            doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n                            doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n                            if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P7;\\n                            if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P7;\\n                            doneNP \\x3d (!doneN) || (!doneP);\\n                            if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P7;\\n                            if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P7;\\n/*--------------------------------------------------------------------------*/\\n    #if (FXAA_QUALITY_PS \\x3e 8)\\n    if(doneNP) {\\n        if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n        if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n        if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n        if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n        doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n        doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n        if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P8;\\n        if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P8;\\n        doneNP \\x3d (!doneN) || (!doneP);\\n        if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P8;\\n        if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P8;\\n/*--------------------------------------------------------------------------*/\\n        #if (FXAA_QUALITY_PS \\x3e 9)\\n        if(doneNP) {\\n            if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n            if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n            if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n            if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n            doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n            doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n            if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P9;\\n            if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P9;\\n            doneNP \\x3d (!doneN) || (!doneP);\\n            if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P9;\\n            if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P9;\\n/*--------------------------------------------------------------------------*/\\n            #if (FXAA_QUALITY_PS \\x3e 10)\\n            if(doneNP) {\\n                if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n                if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n                if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n                if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n                doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n                doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n                if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P10;\\n                if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P10;\\n                doneNP \\x3d (!doneN) || (!doneP);\\n                if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P10;\\n                if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P10;\\n/*--------------------------------------------------------------------------*/\\n                #if (FXAA_QUALITY_PS \\x3e 11)\\n                if(doneNP) {\\n                    if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n                    if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n                    if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n                    if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n                    doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n                    doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n                    if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P11;\\n                    if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P11;\\n                    doneNP \\x3d (!doneN) || (!doneP);\\n                    if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P11;\\n                    if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P11;\\n/*--------------------------------------------------------------------------*/\\n                    #if (FXAA_QUALITY_PS \\x3e 12)\\n                    if(doneNP) {\\n                        if(!doneN) lumaEndN \\x3d FxaaLuma(FxaaTexTop(tex, posN.xy));\\n                        if(!doneP) lumaEndP \\x3d FxaaLuma(FxaaTexTop(tex, posP.xy));\\n                        if(!doneN) lumaEndN \\x3d lumaEndN - lumaNN * 0.5;\\n                        if(!doneP) lumaEndP \\x3d lumaEndP - lumaNN * 0.5;\\n                        doneN \\x3d abs(lumaEndN) \\x3e\\x3d gradientScaled;\\n                        doneP \\x3d abs(lumaEndP) \\x3e\\x3d gradientScaled;\\n                        if(!doneN) posN.x -\\x3d offNP.x * FXAA_QUALITY_P12;\\n                        if(!doneN) posN.y -\\x3d offNP.y * FXAA_QUALITY_P12;\\n                        doneNP \\x3d (!doneN) || (!doneP);\\n                        if(!doneP) posP.x +\\x3d offNP.x * FXAA_QUALITY_P12;\\n                        if(!doneP) posP.y +\\x3d offNP.y * FXAA_QUALITY_P12;\\n/*--------------------------------------------------------------------------*/\\n                    }\\n                    #endif\\n/*--------------------------------------------------------------------------*/\\n                }\\n                #endif\\n/*--------------------------------------------------------------------------*/\\n            }\\n            #endif\\n/*--------------------------------------------------------------------------*/\\n        }\\n        #endif\\n/*--------------------------------------------------------------------------*/\\n    }\\n    #endif\\n/*--------------------------------------------------------------------------*/\\n                        }\\n                        #endif\\n/*--------------------------------------------------------------------------*/\\n                    }\\n                    #endif\\n/*--------------------------------------------------------------------------*/\\n                }\\n                #endif\\n/*--------------------------------------------------------------------------*/\\n            }\\n            #endif\\n/*--------------------------------------------------------------------------*/\\n        }\\n        #endif\\n/*--------------------------------------------------------------------------*/\\n    }\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat dstN \\x3d posM.x - posN.x;\\n    FxaaFloat dstP \\x3d posP.x - posM.x;\\n    if(!horzSpan) dstN \\x3d posM.y - posN.y;\\n    if(!horzSpan) dstP \\x3d posP.y - posM.y;\\n/*--------------------------------------------------------------------------*/\\n    FxaaBool goodSpanN \\x3d (lumaEndN \\x3c 0.0) !\\x3d lumaMLTZero;\\n    FxaaFloat spanLength \\x3d (dstP + dstN);\\n    FxaaBool goodSpanP \\x3d (lumaEndP \\x3c 0.0) !\\x3d lumaMLTZero;\\n    FxaaFloat spanLengthRcp \\x3d 1.0/spanLength;\\n/*--------------------------------------------------------------------------*/\\n    FxaaBool directionN \\x3d dstN \\x3c dstP;\\n    FxaaFloat dst \\x3d min(dstN, dstP);\\n    FxaaBool goodSpan \\x3d directionN ? goodSpanN : goodSpanP;\\n    FxaaFloat subpixG \\x3d subpixF * subpixF;\\n    FxaaFloat pixelOffset \\x3d (dst * (-spanLengthRcp)) + 0.5;\\n    FxaaFloat subpixH \\x3d subpixG * fxaaQualitySubpix;\\n/*--------------------------------------------------------------------------*/\\n    FxaaFloat pixelOffsetGood \\x3d goodSpan ? pixelOffset : 0.0;\\n    FxaaFloat pixelOffsetSubpix \\x3d max(pixelOffsetGood, subpixH);\\n    if(!horzSpan) posM.x +\\x3d pixelOffsetSubpix * lengthSign;\\n    if( horzSpan) posM.y +\\x3d pixelOffsetSubpix * lengthSign;\\n    #if (FXAA_DISCARD \\x3d\\x3d 1)\\n        return FxaaTexTop(tex, posM);\\n    #else\\n        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\\n    #endif\\n}\\n/*\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d\\x3d*/\\n#endif\\n\\nvoid main() {\\n  gl_FragColor \\x3d FxaaPixelShader(\\n    vUv,\\n    vec4(0.0),\\n    tDiffuse,\\n    tDiffuse,\\n    tDiffuse,\\n    resolution,\\n    vec4(0.0),\\n    vec4(0.0),\\n    vec4(0.0),\\n    0.75,\\n    0.166,\\n    0.0833,\\n    0.0,\\n    0.0,\\n    0.0,\\n    vec4(0.0)\\n  );\\n\\n  // TODO avoid querying texture twice for same texel\\n  gl_FragColor.a \\x3d texture2D(tDiffuse, vUv).a;\\n}'};\nexports.FXAAShader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$FXAAShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FXAAShader = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * NVIDIA FXAA by Timothy Lottes\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n * - WebGL port by @supereggbert\n * http://www.glge.org/demos/fxaa/\n */\nvar FXAAShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new _three.Vector2(1 / 1024, 1 / 512)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['precision highp float;', '', 'uniform sampler2D tDiffuse;', '', 'uniform vec2 resolution;', '', 'varying vec2 vUv;', '', '// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)', '', '//----------------------------------------------------------------------------------', '// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag', '// SDK Version: v3.00', '// Email:       gameworks@nvidia.com', '// Site:        http://developer.nvidia.com/', '//', '// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.', '//', '// Redistribution and use in source and binary forms, with or without', '// modification, are permitted provided that the following conditions', '// are met:', '//  * Redistributions of source code must retain the above copyright', '//    notice, this list of conditions and the following disclaimer.', '//  * Redistributions in binary form must reproduce the above copyright', '//    notice, this list of conditions and the following disclaimer in the', '//    documentation and/or other materials provided with the distribution.', '//  * Neither the name of NVIDIA CORPORATION nor the names of its', '//    contributors may be used to endorse or promote products derived', '//    from this software without specific prior written permission.', '//', \"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\", '// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE', '// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR', '// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR', '// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,', '// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,', '// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR', '// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY', '// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT', '// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE', '// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.', '//', '//----------------------------------------------------------------------------------', '', '#define FXAA_PC 1', '#define FXAA_GLSL_100 1', '#define FXAA_QUALITY_PRESET 12', '', '#define FXAA_GREEN_AS_LUMA 1', '', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_PC_CONSOLE', '    //', '    // The console algorithm for PC is included', '    // for developers targeting really low spec machines.', '    // Likely better to just run FXAA_PC, and use a really low preset.', '    //', '    #define FXAA_PC_CONSOLE 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GLSL_120', '    #define FXAA_GLSL_120 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GLSL_130', '    #define FXAA_GLSL_130 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_3', '    #define FXAA_HLSL_3 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_4', '    #define FXAA_HLSL_4 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_5', '    #define FXAA_HLSL_5 0', '#endif', '/*==========================================================================*/', '#ifndef FXAA_GREEN_AS_LUMA', '    //', '    // For those using non-linear color,', '    // and either not able to get luma in alpha, or not wanting to,', '    // this enables FXAA to run using green as a proxy for luma.', '    // So with this enabled, no need to pack luma in alpha.', '    //', '    // This will turn off AA on anything which lacks some amount of green.', '    // Pure red and blue or combination of only R and B, will get no AA.', '    //', '    // Might want to lower the settings for both,', '    //    fxaaConsoleEdgeThresholdMin', '    //    fxaaQualityEdgeThresholdMin', '    // In order to insure AA does not get turned off on colors', '    // which contain a minor amount of green.', '    //', '    // 1 = On.', '    // 0 = Off.', '    //', '    #define FXAA_GREEN_AS_LUMA 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_EARLY_EXIT', '    //', \"    // Controls algorithm's early exit path.\", '    // On PS3 turning this ON adds 2 cycles to the shader.', '    // On 360 turning this OFF adds 10ths of a millisecond to the shader.', '    // Turning this off on console will result in a more blurry image.', '    // So this defaults to on.', '    //', '    // 1 = On.', '    // 0 = Off.', '    //', '    #define FXAA_EARLY_EXIT 1', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_DISCARD', '    //', '    // Only valid for PC OpenGL currently.', '    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.', '    //', \"    // 1 = Use discard on pixels which don't need AA.\", '    //     For APIs which enable concurrent TEX+ROP from same surface.', \"    // 0 = Return unchanged color on pixels which don't need AA.\", '    //', '    #define FXAA_DISCARD 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_FAST_PIXEL_OFFSET', '    //', '    // Used for GLSL 120 only.', '    //', '    // 1 = GL API supports fast pixel offsets', '    // 0 = do not use fast pixel offsets', '    //', '    #ifdef GL_EXT_gpu_shader4', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifdef GL_NV_gpu_shader5', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifdef GL_ARB_gpu_shader5', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifndef FXAA_FAST_PIXEL_OFFSET', '        #define FXAA_FAST_PIXEL_OFFSET 0', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GATHER4_ALPHA', '    //', '    // 1 = API supports gather4 on alpha channel.', '    // 0 = API does not support gather4 on alpha channel.', '    //', '    #if (FXAA_HLSL_5 == 1)', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifdef GL_ARB_gpu_shader5', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifdef GL_NV_gpu_shader5', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifndef FXAA_GATHER4_ALPHA', '        #define FXAA_GATHER4_ALPHA 0', '    #endif', '#endif', '', '', '/*============================================================================', '                        FXAA QUALITY - TUNING KNOBS', '------------------------------------------------------------------------------', 'NOTE the other tuning knobs are now in the shader function inputs!', '============================================================================*/', '#ifndef FXAA_QUALITY_PRESET', '    //', '    // Choose the quality preset.', '    // This needs to be compiled into the shader as it effects code.', '    // Best option to include multiple presets is to', '    // in each shader define the preset, then include this file.', '    //', '    // OPTIONS', '    // -----------------------------------------------------------------------', '    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)', '    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)', '    // 39       - no dither, very expensive', '    //', '    // NOTES', '    // -----------------------------------------------------------------------', '    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)', '    // 13 = about same speed as FXAA 3.9 and better than 12', '    // 23 = closest to FXAA 3.9 visually and performance wise', '    //  _ = the lowest digit is directly related to performance', '    // _  = the highest digit is directly related to style', '    //', '    #define FXAA_QUALITY_PRESET 12', '#endif', '', '', '/*============================================================================', '', '                           FXAA QUALITY - PRESETS', '', '============================================================================*/', '', '/*============================================================================', '                     FXAA QUALITY - MEDIUM DITHER PRESETS', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 10)', '    #define FXAA_QUALITY_PS 3', '    #define FXAA_QUALITY_P0 1.5', '    #define FXAA_QUALITY_P1 3.0', '    #define FXAA_QUALITY_P2 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 11)', '    #define FXAA_QUALITY_PS 4', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 3.0', '    #define FXAA_QUALITY_P3 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 12)', '    #define FXAA_QUALITY_PS 5', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 4.0', '    #define FXAA_QUALITY_P4 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 13)', '    #define FXAA_QUALITY_PS 6', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 4.0', '    #define FXAA_QUALITY_P5 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 14)', '    #define FXAA_QUALITY_PS 7', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 4.0', '    #define FXAA_QUALITY_P6 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 15)', '    #define FXAA_QUALITY_PS 8', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 4.0', '    #define FXAA_QUALITY_P7 12.0', '#endif', '', '/*============================================================================', '                     FXAA QUALITY - LOW DITHER PRESETS', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 20)', '    #define FXAA_QUALITY_PS 3', '    #define FXAA_QUALITY_P0 1.5', '    #define FXAA_QUALITY_P1 2.0', '    #define FXAA_QUALITY_P2 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 21)', '    #define FXAA_QUALITY_PS 4', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 22)', '    #define FXAA_QUALITY_PS 5', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 23)', '    #define FXAA_QUALITY_PS 6', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 24)', '    #define FXAA_QUALITY_PS 7', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 3.0', '    #define FXAA_QUALITY_P6 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 25)', '    #define FXAA_QUALITY_PS 8', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 4.0', '    #define FXAA_QUALITY_P7 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 26)', '    #define FXAA_QUALITY_PS 9', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 4.0', '    #define FXAA_QUALITY_P8 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 27)', '    #define FXAA_QUALITY_PS 10', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 4.0', '    #define FXAA_QUALITY_P9 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 28)', '    #define FXAA_QUALITY_PS 11', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 4.0', '    #define FXAA_QUALITY_P10 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 29)', '    #define FXAA_QUALITY_PS 12', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 2.0', '    #define FXAA_QUALITY_P10 4.0', '    #define FXAA_QUALITY_P11 8.0', '#endif', '', '/*============================================================================', '                     FXAA QUALITY - EXTREME QUALITY', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 39)', '    #define FXAA_QUALITY_PS 12', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.0', '    #define FXAA_QUALITY_P2 1.0', '    #define FXAA_QUALITY_P3 1.0', '    #define FXAA_QUALITY_P4 1.0', '    #define FXAA_QUALITY_P5 1.5', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 2.0', '    #define FXAA_QUALITY_P10 4.0', '    #define FXAA_QUALITY_P11 8.0', '#endif', '', '', '', '/*============================================================================', '', '                                API PORTING', '', '============================================================================*/', '#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)', '    #define FxaaBool bool', '    #define FxaaDiscard discard', '    #define FxaaFloat float', '    #define FxaaFloat2 vec2', '    #define FxaaFloat3 vec3', '    #define FxaaFloat4 vec4', '    #define FxaaHalf float', '    #define FxaaHalf2 vec2', '    #define FxaaHalf3 vec3', '    #define FxaaHalf4 vec4', '    #define FxaaInt2 ivec2', '    #define FxaaSat(x) clamp(x, 0.0, 1.0)', '    #define FxaaTex sampler2D', '#else', '    #define FxaaBool bool', '    #define FxaaDiscard clip(-1)', '    #define FxaaFloat float', '    #define FxaaFloat2 float2', '    #define FxaaFloat3 float3', '    #define FxaaFloat4 float4', '    #define FxaaHalf half', '    #define FxaaHalf2 half2', '    #define FxaaHalf3 half3', '    #define FxaaHalf4 half4', '    #define FxaaSat(x) saturate(x)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_100 == 1)', '  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)', '  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_120 == 1)', '    // Requires,', '    //  #version 120', '    // And at least,', '    //  #extension GL_EXT_gpu_shader4 : enable', '    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)', '    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)', '    #if (FXAA_FAST_PIXEL_OFFSET == 1)', '        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)', '    #else', '        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)', '    #endif', '    #if (FXAA_GATHER4_ALPHA == 1)', '        // use #extension GL_ARB_gpu_shader5 : enable', '        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)', '        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)', '        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)', '        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_130 == 1)', '    // Requires \"#version 130\" or better', '    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)', '    #if (FXAA_GATHER4_ALPHA == 1)', '        // use #extension GL_ARB_gpu_shader5 : enable', '        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)', '        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)', '        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)', '        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_3 == 1)', '    #define FxaaInt2 float2', '    #define FxaaTex sampler2D', '    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))', '    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_4 == 1)', '    #define FxaaInt2 int2', '    struct FxaaTex { SamplerState smpl; Texture2D tex; };', '    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_5 == 1)', '    #define FxaaInt2 int2', '    struct FxaaTex { SamplerState smpl; Texture2D tex; };', '    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)', '    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)', '    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)', '    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)', '    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)', '#endif', '', '', '/*============================================================================', '                   GREEN AS LUMA OPTION SUPPORT FUNCTION', '============================================================================*/', '#if (FXAA_GREEN_AS_LUMA == 0)', '    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }', '#else', '    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }', '#endif', '', '', '', '', '/*============================================================================', '', '                             FXAA3 QUALITY - PC', '', '============================================================================*/', '#if (FXAA_PC == 1)', '/*--------------------------------------------------------------------------*/', 'FxaaFloat4 FxaaPixelShader(', '    //', '    // Use noperspective interpolation here (turn off perspective interpolation).', '    // {xy} = center of pixel', '    FxaaFloat2 pos,', '    //', '    // Used only for FXAA Console, and not used on the 360 version.', '    // Use noperspective interpolation here (turn off perspective interpolation).', '    // {xy_} = upper left of pixel', '    // {_zw} = lower right of pixel', '    FxaaFloat4 fxaaConsolePosPos,', '    //', '    // Input color texture.', '    // {rgb_} = color in linear or perceptual color space', '    // if (FXAA_GREEN_AS_LUMA == 0)', '    //     {__a} = luma in perceptual color space (not linear)', '    FxaaTex tex,', '    //', '    // Only used on the optimized 360 version of FXAA Console.', '    // For everything but 360, just use the same input here as for \"tex\".', '    // For 360, same texture, just alias with a 2nd sampler.', '    // This sampler needs to have an exponent bias of -1.', '    FxaaTex fxaaConsole360TexExpBiasNegOne,', '    //', '    // Only used on the optimized 360 version of FXAA Console.', '    // For everything but 360, just use the same input here as for \"tex\".', '    // For 360, same texture, just alias with a 3nd sampler.', '    // This sampler needs to have an exponent bias of -2.', '    FxaaTex fxaaConsole360TexExpBiasNegTwo,', '    //', '    // Only used on FXAA Quality.', '    // This must be from a constant/uniform.', '    // {x_} = 1.0/screenWidthInPixels', '    // {_y} = 1.0/screenHeightInPixels', '    FxaaFloat2 fxaaQualityRcpFrame,', '    //', '    // Only used on FXAA Console.', '    // This must be from a constant/uniform.', '    // This effects sub-pixel AA quality and inversely sharpness.', '    //   Where N ranges between,', '    //     N = 0.50 (default)', '    //     N = 0.33 (sharper)', '    // {x__} = -N/screenWidthInPixels', '    // {_y_} = -N/screenHeightInPixels', '    // {_z_} =  N/screenWidthInPixels', '    // {__w} =  N/screenHeightInPixels', '    FxaaFloat4 fxaaConsoleRcpFrameOpt,', '    //', '    // Only used on FXAA Console.', '    // Not used on 360, but used on PS3 and PC.', '    // This must be from a constant/uniform.', '    // {x__} = -2.0/screenWidthInPixels', '    // {_y_} = -2.0/screenHeightInPixels', '    // {_z_} =  2.0/screenWidthInPixels', '    // {__w} =  2.0/screenHeightInPixels', '    FxaaFloat4 fxaaConsoleRcpFrameOpt2,', '    //', '    // Only used on FXAA Console.', '    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.', '    // This must be from a constant/uniform.', '    // {x__} =  8.0/screenWidthInPixels', '    // {_y_} =  8.0/screenHeightInPixels', '    // {_z_} = -4.0/screenWidthInPixels', '    // {__w} = -4.0/screenHeightInPixels', '    FxaaFloat4 fxaaConsole360RcpFrameOpt2,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_SUBPIX define.', '    // It is here now to allow easier tuning.', '    // Choose the amount of sub-pixel aliasing removal.', '    // This can effect sharpness.', '    //   1.00 - upper limit (softer)', '    //   0.75 - default amount of filtering', '    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)', '    //   0.25 - almost off', '    //   0.00 - completely off', '    FxaaFloat fxaaQualitySubpix,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.', '    // It is here now to allow easier tuning.', '    // The minimum amount of local contrast required to apply algorithm.', '    //   0.333 - too little (faster)', '    //   0.250 - low quality', '    //   0.166 - default', '    //   0.125 - high quality', '    //   0.063 - overkill (slower)', '    FxaaFloat fxaaQualityEdgeThreshold,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.', '    // It is here now to allow easier tuning.', '    // Trims the algorithm from processing darks.', '    //   0.0833 - upper limit (default, the start of visible unfiltered edges)', '    //   0.0625 - high quality (faster)', '    //   0.0312 - visible limit (slower)', '    // Special notes when using FXAA_GREEN_AS_LUMA,', '    //   Likely want to set this to zero.', '    //   As colors that are mostly not-green', '    //   will appear very dark in the green channel!', '    //   Tune by looking at mostly non-green content,', '    //   then start at zero and increase until aliasing is a problem.', '    FxaaFloat fxaaQualityEdgeThresholdMin,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.', '    // It is here now to allow easier tuning.', '    // This does not effect PS3, as this needs to be compiled in.', '    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.', '    //   Due to the PS3 being ALU bound,', '    //   there are only three safe values here: 2 and 4 and 8.', '    //   These options use the shaders ability to a free *|/ by 2|4|8.', '    // For all other platforms can be a non-power of two.', '    //   8.0 is sharper (default!!!)', '    //   4.0 is softer', '    //   2.0 is really soft (good only for vector graphics inputs)', '    FxaaFloat fxaaConsoleEdgeSharpness,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.', '    // It is here now to allow easier tuning.', '    // This does not effect PS3, as this needs to be compiled in.', '    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.', '    //   Due to the PS3 being ALU bound,', '    //   there are only two safe values here: 1/4 and 1/8.', '    //   These options use the shaders ability to a free *|/ by 2|4|8.', '    // The console setting has a different mapping than the quality setting.', '    // Other platforms can use other values.', '    //   0.125 leaves less aliasing, but is softer (default!!!)', '    //   0.25 leaves more aliasing, and is sharper', '    FxaaFloat fxaaConsoleEdgeThreshold,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.', '    // It is here now to allow easier tuning.', '    // Trims the algorithm from processing darks.', '    // The console setting has a different mapping than the quality setting.', '    // This only applies when FXAA_EARLY_EXIT is 1.', '    // This does not apply to PS3,', '    // PS3 was simplified to avoid more shader instructions.', '    //   0.06 - faster but more aliasing in darks', '    //   0.05 - default', '    //   0.04 - slower and less aliasing in darks', '    // Special notes when using FXAA_GREEN_AS_LUMA,', '    //   Likely want to set this to zero.', '    //   As colors that are mostly not-green', '    //   will appear very dark in the green channel!', '    //   Tune by looking at mostly non-green content,', '    //   then start at zero and increase until aliasing is a problem.', '    FxaaFloat fxaaConsoleEdgeThresholdMin,', '    //', '    // Extra constants for 360 FXAA Console only.', '    // Use zeros or anything else for other platforms.', '    // These must be in physical constant registers and NOT immediates.', '    // Immediates will result in compiler un-optimizing.', '    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)', '    FxaaFloat4 fxaaConsole360ConstDir', ') {', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posM;', '    posM.x = pos.x;', '    posM.y = pos.y;', '    #if (FXAA_GATHER4_ALPHA == 1)', '        #if (FXAA_DISCARD == 0)', '            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);', '            #if (FXAA_GREEN_AS_LUMA == 0)', '                #define lumaM rgbyM.w', '            #else', '                #define lumaM rgbyM.y', '            #endif', '        #endif', '        #if (FXAA_GREEN_AS_LUMA == 0)', '            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);', '            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));', '        #else', '            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);', '            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));', '        #endif', '        #if (FXAA_DISCARD == 1)', '            #define lumaM luma4A.w', '        #endif', '        #define lumaE luma4A.z', '        #define lumaS luma4A.x', '        #define lumaSE luma4A.y', '        #define lumaNW luma4B.w', '        #define lumaN luma4B.z', '        #define lumaW luma4B.x', '    #else', '        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);', '        #if (FXAA_GREEN_AS_LUMA == 0)', '            #define lumaM rgbyM.w', '        #else', '            #define lumaM rgbyM.y', '        #endif', '        #if (FXAA_GLSL_100 == 1)', '          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));', '        #else', '          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));', '        #endif', '    #endif', '/*--------------------------------------------------------------------------*/', '    FxaaFloat maxSM = max(lumaS, lumaM);', '    FxaaFloat minSM = min(lumaS, lumaM);', '    FxaaFloat maxESM = max(lumaE, maxSM);', '    FxaaFloat minESM = min(lumaE, minSM);', '    FxaaFloat maxWN = max(lumaN, lumaW);', '    FxaaFloat minWN = min(lumaN, lumaW);', '    FxaaFloat rangeMax = max(maxWN, maxESM);', '    FxaaFloat rangeMin = min(minWN, minESM);', '    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;', '    FxaaFloat range = rangeMax - rangeMin;', '    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);', '    FxaaBool earlyExit = range < rangeMaxClamped;', '/*--------------------------------------------------------------------------*/', '    if(earlyExit)', '        #if (FXAA_DISCARD == 1)', '            FxaaDiscard;', '        #else', '            return rgbyM;', '        #endif', '/*--------------------------------------------------------------------------*/', '    #if (FXAA_GATHER4_ALPHA == 0)', '        #if (FXAA_GLSL_100 == 1)', '          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));', '        #else', '          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));', '        #endif', '    #else', '        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));', '        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));', '    #endif', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNS = lumaN + lumaS;', '    FxaaFloat lumaWE = lumaW + lumaE;', '    FxaaFloat subpixRcpRange = 1.0/range;', '    FxaaFloat subpixNSWE = lumaNS + lumaWE;', '    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;', '    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNESE = lumaNE + lumaSE;', '    FxaaFloat lumaNWNE = lumaNW + lumaNE;', '    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;', '    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNWSW = lumaNW + lumaSW;', '    FxaaFloat lumaSWSE = lumaSW + lumaSE;', '    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);', '    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);', '    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;', '    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;', '    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;', '    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;', '    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;', '    FxaaBool horzSpan = edgeHorz >= edgeVert;', '    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;', '/*--------------------------------------------------------------------------*/', '    if(!horzSpan) lumaN = lumaW;', '    if(!horzSpan) lumaS = lumaE;', '    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;', '    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat gradientN = lumaN - lumaM;', '    FxaaFloat gradientS = lumaS - lumaM;', '    FxaaFloat lumaNN = lumaN + lumaM;', '    FxaaFloat lumaSS = lumaS + lumaM;', '    FxaaBool pairN = abs(gradientN) >= abs(gradientS);', '    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));', '    if(pairN) lengthSign = -lengthSign;', '    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posB;', '    posB.x = posM.x;', '    posB.y = posM.y;', '    FxaaFloat2 offNP;', '    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;', '    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;', '    if(!horzSpan) posB.x += lengthSign * 0.5;', '    if( horzSpan) posB.y += lengthSign * 0.5;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posN;', '    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;', '    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;', '    FxaaFloat2 posP;', '    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;', '    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;', '    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;', '    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));', '    FxaaFloat subpixE = subpixC * subpixC;', '    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));', '/*--------------------------------------------------------------------------*/', '    if(!pairN) lumaNN = lumaSS;', '    FxaaFloat gradientScaled = gradient * 1.0/4.0;', '    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;', '    FxaaFloat subpixF = subpixD * subpixE;', '    FxaaBool lumaMLTZero = lumaMM < 0.0;', '/*--------------------------------------------------------------------------*/', '    lumaEndN -= lumaNN * 0.5;', '    lumaEndP -= lumaNN * 0.5;', '    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;', '    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;', '    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;', '    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;', '    FxaaBool doneNP = (!doneN) || (!doneP);', '    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;', '    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;', '/*--------------------------------------------------------------------------*/', '    if(doneNP) {', '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '        doneN = abs(lumaEndN) >= gradientScaled;', '        doneP = abs(lumaEndP) >= gradientScaled;', '        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;', '        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;', '        doneNP = (!doneN) || (!doneP);', '        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;', '        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;', '/*--------------------------------------------------------------------------*/', '        #if (FXAA_QUALITY_PS > 3)', '        if(doneNP) {', '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '            doneN = abs(lumaEndN) >= gradientScaled;', '            doneP = abs(lumaEndP) >= gradientScaled;', '            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;', '            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;', '            doneNP = (!doneN) || (!doneP);', '            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;', '            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;', '/*--------------------------------------------------------------------------*/', '            #if (FXAA_QUALITY_PS > 4)', '            if(doneNP) {', '                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                doneN = abs(lumaEndN) >= gradientScaled;', '                doneP = abs(lumaEndP) >= gradientScaled;', '                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;', '                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;', '                doneNP = (!doneN) || (!doneP);', '                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;', '                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;', '/*--------------------------------------------------------------------------*/', '                #if (FXAA_QUALITY_PS > 5)', '                if(doneNP) {', '                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                    doneN = abs(lumaEndN) >= gradientScaled;', '                    doneP = abs(lumaEndP) >= gradientScaled;', '                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;', '                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;', '                    doneNP = (!doneN) || (!doneP);', '                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;', '                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;', '/*--------------------------------------------------------------------------*/', '                    #if (FXAA_QUALITY_PS > 6)', '                    if(doneNP) {', '                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                        doneN = abs(lumaEndN) >= gradientScaled;', '                        doneP = abs(lumaEndP) >= gradientScaled;', '                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;', '                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;', '                        doneNP = (!doneN) || (!doneP);', '                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;', '                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;', '/*--------------------------------------------------------------------------*/', '                        #if (FXAA_QUALITY_PS > 7)', '                        if(doneNP) {', '                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                            doneN = abs(lumaEndN) >= gradientScaled;', '                            doneP = abs(lumaEndP) >= gradientScaled;', '                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;', '                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;', '                            doneNP = (!doneN) || (!doneP);', '                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;', '                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;', '/*--------------------------------------------------------------------------*/', '    #if (FXAA_QUALITY_PS > 8)', '    if(doneNP) {', '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '        doneN = abs(lumaEndN) >= gradientScaled;', '        doneP = abs(lumaEndP) >= gradientScaled;', '        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;', '        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;', '        doneNP = (!doneN) || (!doneP);', '        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;', '        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;', '/*--------------------------------------------------------------------------*/', '        #if (FXAA_QUALITY_PS > 9)', '        if(doneNP) {', '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '            doneN = abs(lumaEndN) >= gradientScaled;', '            doneP = abs(lumaEndP) >= gradientScaled;', '            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;', '            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;', '            doneNP = (!doneN) || (!doneP);', '            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;', '            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;', '/*--------------------------------------------------------------------------*/', '            #if (FXAA_QUALITY_PS > 10)', '            if(doneNP) {', '                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                doneN = abs(lumaEndN) >= gradientScaled;', '                doneP = abs(lumaEndP) >= gradientScaled;', '                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;', '                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;', '                doneNP = (!doneN) || (!doneP);', '                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;', '                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;', '/*--------------------------------------------------------------------------*/', '                #if (FXAA_QUALITY_PS > 11)', '                if(doneNP) {', '                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                    doneN = abs(lumaEndN) >= gradientScaled;', '                    doneP = abs(lumaEndP) >= gradientScaled;', '                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;', '                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;', '                    doneNP = (!doneN) || (!doneP);', '                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;', '                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;', '/*--------------------------------------------------------------------------*/', '                    #if (FXAA_QUALITY_PS > 12)', '                    if(doneNP) {', '                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                        doneN = abs(lumaEndN) >= gradientScaled;', '                        doneP = abs(lumaEndP) >= gradientScaled;', '                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;', '                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;', '                        doneNP = (!doneN) || (!doneP);', '                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;', '                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;', '/*--------------------------------------------------------------------------*/', '                    }', '                    #endif', '/*--------------------------------------------------------------------------*/', '                }', '                #endif', '/*--------------------------------------------------------------------------*/', '            }', '            #endif', '/*--------------------------------------------------------------------------*/', '        }', '        #endif', '/*--------------------------------------------------------------------------*/', '    }', '    #endif', '/*--------------------------------------------------------------------------*/', '                        }', '                        #endif', '/*--------------------------------------------------------------------------*/', '                    }', '                    #endif', '/*--------------------------------------------------------------------------*/', '                }', '                #endif', '/*--------------------------------------------------------------------------*/', '            }', '            #endif', '/*--------------------------------------------------------------------------*/', '        }', '        #endif', '/*--------------------------------------------------------------------------*/', '    }', '/*--------------------------------------------------------------------------*/', '    FxaaFloat dstN = posM.x - posN.x;', '    FxaaFloat dstP = posP.x - posM.x;', '    if(!horzSpan) dstN = posM.y - posN.y;', '    if(!horzSpan) dstP = posP.y - posM.y;', '/*--------------------------------------------------------------------------*/', '    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;', '    FxaaFloat spanLength = (dstP + dstN);', '    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;', '    FxaaFloat spanLengthRcp = 1.0/spanLength;', '/*--------------------------------------------------------------------------*/', '    FxaaBool directionN = dstN < dstP;', '    FxaaFloat dst = min(dstN, dstP);', '    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;', '    FxaaFloat subpixG = subpixF * subpixF;', '    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;', '    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;', '    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);', '    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;', '    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;', '    #if (FXAA_DISCARD == 1)', '        return FxaaTexTop(tex, posM);', '    #else', '        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);', '    #endif', '}', '/*==========================================================================*/', '#endif', '', 'void main() {', '  gl_FragColor = FxaaPixelShader(', '    vUv,', '    vec4(0.0),', '    tDiffuse,', '    tDiffuse,', '    tDiffuse,', '    resolution,', '    vec4(0.0),', '    vec4(0.0),', '    vec4(0.0),', '    0.75,', '    0.166,', '    0.0833,', '    0.0,', '    0.0,', '    0.0,', '    vec4(0.0)', '  );', '', '  // TODO avoid querying texture twice for same texel', '  gl_FragColor.a = texture2D(tDiffuse, vUv).a;', '}'].join('\\n')\n};\nexports.FXAAShader = FXAAShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","FXAAShader","__esModule","tDiffuse","vertexShader","value","uniforms","resolution"]],"~:compiled-at",1630917515584,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$FXAAShader.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,mDAAA,CAAwE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGhHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,UAAR,CAAqB,IAAK,EAUtBA,OAAAA,CAAa,CACfC,SAAU,CACRC,SAAU,CACRH,MAAO,IADC,CADF,CAIRI,WAAY,CACVJ,MAAO,KAdAL,OAAAU,CAAQ,8CAARA,CAcWC,CAAAA,OAAX,EAAmB,CAAnB,CAAuB,IAAvB,CAA6B,CAA7B,CAAiC,GAAjC,CADG,CAJJ,CADK,CASfC,aAAiJ,qIATlI,CAUfC,eAA6/H,unnDAV9+H,CAYjBX;OAAQI,CAAAA,UAAR,CAAqBA,MA5B2F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/FXAAShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$FXAAShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.FXAAShader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * NVIDIA FXAA by Timothy Lottes\\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\\n * - WebGL port by @supereggbert\\n * http://www.glge.org/demos/fxaa/\\n */\\nvar FXAAShader = {\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    resolution: {\\n      value: new _three.Vector2(1 / 1024, 1 / 512)\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['precision highp float;', '', 'uniform sampler2D tDiffuse;', '', 'uniform vec2 resolution;', '', 'varying vec2 vUv;', '', '// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)', '', '//----------------------------------------------------------------------------------', '// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag', '// SDK Version: v3.00', '// Email:       gameworks@nvidia.com', '// Site:        http://developer.nvidia.com/', '//', '// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.', '//', '// Redistribution and use in source and binary forms, with or without', '// modification, are permitted provided that the following conditions', '// are met:', '//  * Redistributions of source code must retain the above copyright', '//    notice, this list of conditions and the following disclaimer.', '//  * Redistributions in binary form must reproduce the above copyright', '//    notice, this list of conditions and the following disclaimer in the', '//    documentation and/or other materials provided with the distribution.', '//  * Neither the name of NVIDIA CORPORATION nor the names of its', '//    contributors may be used to endorse or promote products derived', '//    from this software without specific prior written permission.', '//', \\\"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\\\", '// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE', '// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR', '// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR', '// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,', '// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,', '// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR', '// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY', '// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT', '// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE', '// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.', '//', '//----------------------------------------------------------------------------------', '', '#define FXAA_PC 1', '#define FXAA_GLSL_100 1', '#define FXAA_QUALITY_PRESET 12', '', '#define FXAA_GREEN_AS_LUMA 1', '', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_PC_CONSOLE', '    //', '    // The console algorithm for PC is included', '    // for developers targeting really low spec machines.', '    // Likely better to just run FXAA_PC, and use a really low preset.', '    //', '    #define FXAA_PC_CONSOLE 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GLSL_120', '    #define FXAA_GLSL_120 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GLSL_130', '    #define FXAA_GLSL_130 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_3', '    #define FXAA_HLSL_3 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_4', '    #define FXAA_HLSL_4 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_HLSL_5', '    #define FXAA_HLSL_5 0', '#endif', '/*==========================================================================*/', '#ifndef FXAA_GREEN_AS_LUMA', '    //', '    // For those using non-linear color,', '    // and either not able to get luma in alpha, or not wanting to,', '    // this enables FXAA to run using green as a proxy for luma.', '    // So with this enabled, no need to pack luma in alpha.', '    //', '    // This will turn off AA on anything which lacks some amount of green.', '    // Pure red and blue or combination of only R and B, will get no AA.', '    //', '    // Might want to lower the settings for both,', '    //    fxaaConsoleEdgeThresholdMin', '    //    fxaaQualityEdgeThresholdMin', '    // In order to insure AA does not get turned off on colors', '    // which contain a minor amount of green.', '    //', '    // 1 = On.', '    // 0 = Off.', '    //', '    #define FXAA_GREEN_AS_LUMA 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_EARLY_EXIT', '    //', \\\"    // Controls algorithm's early exit path.\\\", '    // On PS3 turning this ON adds 2 cycles to the shader.', '    // On 360 turning this OFF adds 10ths of a millisecond to the shader.', '    // Turning this off on console will result in a more blurry image.', '    // So this defaults to on.', '    //', '    // 1 = On.', '    // 0 = Off.', '    //', '    #define FXAA_EARLY_EXIT 1', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_DISCARD', '    //', '    // Only valid for PC OpenGL currently.', '    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.', '    //', \\\"    // 1 = Use discard on pixels which don't need AA.\\\", '    //     For APIs which enable concurrent TEX+ROP from same surface.', \\\"    // 0 = Return unchanged color on pixels which don't need AA.\\\", '    //', '    #define FXAA_DISCARD 0', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_FAST_PIXEL_OFFSET', '    //', '    // Used for GLSL 120 only.', '    //', '    // 1 = GL API supports fast pixel offsets', '    // 0 = do not use fast pixel offsets', '    //', '    #ifdef GL_EXT_gpu_shader4', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifdef GL_NV_gpu_shader5', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifdef GL_ARB_gpu_shader5', '        #define FXAA_FAST_PIXEL_OFFSET 1', '    #endif', '    #ifndef FXAA_FAST_PIXEL_OFFSET', '        #define FXAA_FAST_PIXEL_OFFSET 0', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#ifndef FXAA_GATHER4_ALPHA', '    //', '    // 1 = API supports gather4 on alpha channel.', '    // 0 = API does not support gather4 on alpha channel.', '    //', '    #if (FXAA_HLSL_5 == 1)', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifdef GL_ARB_gpu_shader5', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifdef GL_NV_gpu_shader5', '        #define FXAA_GATHER4_ALPHA 1', '    #endif', '    #ifndef FXAA_GATHER4_ALPHA', '        #define FXAA_GATHER4_ALPHA 0', '    #endif', '#endif', '', '', '/*============================================================================', '                        FXAA QUALITY - TUNING KNOBS', '------------------------------------------------------------------------------', 'NOTE the other tuning knobs are now in the shader function inputs!', '============================================================================*/', '#ifndef FXAA_QUALITY_PRESET', '    //', '    // Choose the quality preset.', '    // This needs to be compiled into the shader as it effects code.', '    // Best option to include multiple presets is to', '    // in each shader define the preset, then include this file.', '    //', '    // OPTIONS', '    // -----------------------------------------------------------------------', '    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)', '    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)', '    // 39       - no dither, very expensive', '    //', '    // NOTES', '    // -----------------------------------------------------------------------', '    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)', '    // 13 = about same speed as FXAA 3.9 and better than 12', '    // 23 = closest to FXAA 3.9 visually and performance wise', '    //  _ = the lowest digit is directly related to performance', '    // _  = the highest digit is directly related to style', '    //', '    #define FXAA_QUALITY_PRESET 12', '#endif', '', '', '/*============================================================================', '', '                           FXAA QUALITY - PRESETS', '', '============================================================================*/', '', '/*============================================================================', '                     FXAA QUALITY - MEDIUM DITHER PRESETS', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 10)', '    #define FXAA_QUALITY_PS 3', '    #define FXAA_QUALITY_P0 1.5', '    #define FXAA_QUALITY_P1 3.0', '    #define FXAA_QUALITY_P2 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 11)', '    #define FXAA_QUALITY_PS 4', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 3.0', '    #define FXAA_QUALITY_P3 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 12)', '    #define FXAA_QUALITY_PS 5', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 4.0', '    #define FXAA_QUALITY_P4 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 13)', '    #define FXAA_QUALITY_PS 6', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 4.0', '    #define FXAA_QUALITY_P5 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 14)', '    #define FXAA_QUALITY_PS 7', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 4.0', '    #define FXAA_QUALITY_P6 12.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 15)', '    #define FXAA_QUALITY_PS 8', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 4.0', '    #define FXAA_QUALITY_P7 12.0', '#endif', '', '/*============================================================================', '                     FXAA QUALITY - LOW DITHER PRESETS', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 20)', '    #define FXAA_QUALITY_PS 3', '    #define FXAA_QUALITY_P0 1.5', '    #define FXAA_QUALITY_P1 2.0', '    #define FXAA_QUALITY_P2 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 21)', '    #define FXAA_QUALITY_PS 4', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 22)', '    #define FXAA_QUALITY_PS 5', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 23)', '    #define FXAA_QUALITY_PS 6', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 24)', '    #define FXAA_QUALITY_PS 7', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 3.0', '    #define FXAA_QUALITY_P6 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 25)', '    #define FXAA_QUALITY_PS 8', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 4.0', '    #define FXAA_QUALITY_P7 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 26)', '    #define FXAA_QUALITY_PS 9', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 4.0', '    #define FXAA_QUALITY_P8 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 27)', '    #define FXAA_QUALITY_PS 10', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 4.0', '    #define FXAA_QUALITY_P9 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 28)', '    #define FXAA_QUALITY_PS 11', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 4.0', '    #define FXAA_QUALITY_P10 8.0', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_QUALITY_PRESET == 29)', '    #define FXAA_QUALITY_PS 12', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.5', '    #define FXAA_QUALITY_P2 2.0', '    #define FXAA_QUALITY_P3 2.0', '    #define FXAA_QUALITY_P4 2.0', '    #define FXAA_QUALITY_P5 2.0', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 2.0', '    #define FXAA_QUALITY_P10 4.0', '    #define FXAA_QUALITY_P11 8.0', '#endif', '', '/*============================================================================', '                     FXAA QUALITY - EXTREME QUALITY', '============================================================================*/', '#if (FXAA_QUALITY_PRESET == 39)', '    #define FXAA_QUALITY_PS 12', '    #define FXAA_QUALITY_P0 1.0', '    #define FXAA_QUALITY_P1 1.0', '    #define FXAA_QUALITY_P2 1.0', '    #define FXAA_QUALITY_P3 1.0', '    #define FXAA_QUALITY_P4 1.0', '    #define FXAA_QUALITY_P5 1.5', '    #define FXAA_QUALITY_P6 2.0', '    #define FXAA_QUALITY_P7 2.0', '    #define FXAA_QUALITY_P8 2.0', '    #define FXAA_QUALITY_P9 2.0', '    #define FXAA_QUALITY_P10 4.0', '    #define FXAA_QUALITY_P11 8.0', '#endif', '', '', '', '/*============================================================================', '', '                                API PORTING', '', '============================================================================*/', '#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)', '    #define FxaaBool bool', '    #define FxaaDiscard discard', '    #define FxaaFloat float', '    #define FxaaFloat2 vec2', '    #define FxaaFloat3 vec3', '    #define FxaaFloat4 vec4', '    #define FxaaHalf float', '    #define FxaaHalf2 vec2', '    #define FxaaHalf3 vec3', '    #define FxaaHalf4 vec4', '    #define FxaaInt2 ivec2', '    #define FxaaSat(x) clamp(x, 0.0, 1.0)', '    #define FxaaTex sampler2D', '#else', '    #define FxaaBool bool', '    #define FxaaDiscard clip(-1)', '    #define FxaaFloat float', '    #define FxaaFloat2 float2', '    #define FxaaFloat3 float3', '    #define FxaaFloat4 float4', '    #define FxaaHalf half', '    #define FxaaHalf2 half2', '    #define FxaaHalf3 half3', '    #define FxaaHalf4 half4', '    #define FxaaSat(x) saturate(x)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_100 == 1)', '  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)', '  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_120 == 1)', '    // Requires,', '    //  #version 120', '    // And at least,', '    //  #extension GL_EXT_gpu_shader4 : enable', '    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)', '    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)', '    #if (FXAA_FAST_PIXEL_OFFSET == 1)', '        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)', '    #else', '        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)', '    #endif', '    #if (FXAA_GATHER4_ALPHA == 1)', '        // use #extension GL_ARB_gpu_shader5 : enable', '        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)', '        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)', '        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)', '        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_GLSL_130 == 1)', '    // Requires \\\"#version 130\\\" or better', '    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)', '    #if (FXAA_GATHER4_ALPHA == 1)', '        // use #extension GL_ARB_gpu_shader5 : enable', '        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)', '        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)', '        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)', '        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)', '    #endif', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_3 == 1)', '    #define FxaaInt2 float2', '    #define FxaaTex sampler2D', '    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))', '    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_4 == 1)', '    #define FxaaInt2 int2', '    struct FxaaTex { SamplerState smpl; Texture2D tex; };', '    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)', '#endif', '/*--------------------------------------------------------------------------*/', '#if (FXAA_HLSL_5 == 1)', '    #define FxaaInt2 int2', '    struct FxaaTex { SamplerState smpl; Texture2D tex; };', '    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)', '    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)', '    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)', '    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)', '    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)', '    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)', '#endif', '', '', '/*============================================================================', '                   GREEN AS LUMA OPTION SUPPORT FUNCTION', '============================================================================*/', '#if (FXAA_GREEN_AS_LUMA == 0)', '    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }', '#else', '    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }', '#endif', '', '', '', '', '/*============================================================================', '', '                             FXAA3 QUALITY - PC', '', '============================================================================*/', '#if (FXAA_PC == 1)', '/*--------------------------------------------------------------------------*/', 'FxaaFloat4 FxaaPixelShader(', '    //', '    // Use noperspective interpolation here (turn off perspective interpolation).', '    // {xy} = center of pixel', '    FxaaFloat2 pos,', '    //', '    // Used only for FXAA Console, and not used on the 360 version.', '    // Use noperspective interpolation here (turn off perspective interpolation).', '    // {xy_} = upper left of pixel', '    // {_zw} = lower right of pixel', '    FxaaFloat4 fxaaConsolePosPos,', '    //', '    // Input color texture.', '    // {rgb_} = color in linear or perceptual color space', '    // if (FXAA_GREEN_AS_LUMA == 0)', '    //     {__a} = luma in perceptual color space (not linear)', '    FxaaTex tex,', '    //', '    // Only used on the optimized 360 version of FXAA Console.', '    // For everything but 360, just use the same input here as for \\\"tex\\\".', '    // For 360, same texture, just alias with a 2nd sampler.', '    // This sampler needs to have an exponent bias of -1.', '    FxaaTex fxaaConsole360TexExpBiasNegOne,', '    //', '    // Only used on the optimized 360 version of FXAA Console.', '    // For everything but 360, just use the same input here as for \\\"tex\\\".', '    // For 360, same texture, just alias with a 3nd sampler.', '    // This sampler needs to have an exponent bias of -2.', '    FxaaTex fxaaConsole360TexExpBiasNegTwo,', '    //', '    // Only used on FXAA Quality.', '    // This must be from a constant/uniform.', '    // {x_} = 1.0/screenWidthInPixels', '    // {_y} = 1.0/screenHeightInPixels', '    FxaaFloat2 fxaaQualityRcpFrame,', '    //', '    // Only used on FXAA Console.', '    // This must be from a constant/uniform.', '    // This effects sub-pixel AA quality and inversely sharpness.', '    //   Where N ranges between,', '    //     N = 0.50 (default)', '    //     N = 0.33 (sharper)', '    // {x__} = -N/screenWidthInPixels', '    // {_y_} = -N/screenHeightInPixels', '    // {_z_} =  N/screenWidthInPixels', '    // {__w} =  N/screenHeightInPixels', '    FxaaFloat4 fxaaConsoleRcpFrameOpt,', '    //', '    // Only used on FXAA Console.', '    // Not used on 360, but used on PS3 and PC.', '    // This must be from a constant/uniform.', '    // {x__} = -2.0/screenWidthInPixels', '    // {_y_} = -2.0/screenHeightInPixels', '    // {_z_} =  2.0/screenWidthInPixels', '    // {__w} =  2.0/screenHeightInPixels', '    FxaaFloat4 fxaaConsoleRcpFrameOpt2,', '    //', '    // Only used on FXAA Console.', '    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.', '    // This must be from a constant/uniform.', '    // {x__} =  8.0/screenWidthInPixels', '    // {_y_} =  8.0/screenHeightInPixels', '    // {_z_} = -4.0/screenWidthInPixels', '    // {__w} = -4.0/screenHeightInPixels', '    FxaaFloat4 fxaaConsole360RcpFrameOpt2,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_SUBPIX define.', '    // It is here now to allow easier tuning.', '    // Choose the amount of sub-pixel aliasing removal.', '    // This can effect sharpness.', '    //   1.00 - upper limit (softer)', '    //   0.75 - default amount of filtering', '    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)', '    //   0.25 - almost off', '    //   0.00 - completely off', '    FxaaFloat fxaaQualitySubpix,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.', '    // It is here now to allow easier tuning.', '    // The minimum amount of local contrast required to apply algorithm.', '    //   0.333 - too little (faster)', '    //   0.250 - low quality', '    //   0.166 - default', '    //   0.125 - high quality', '    //   0.063 - overkill (slower)', '    FxaaFloat fxaaQualityEdgeThreshold,', '    //', '    // Only used on FXAA Quality.', '    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.', '    // It is here now to allow easier tuning.', '    // Trims the algorithm from processing darks.', '    //   0.0833 - upper limit (default, the start of visible unfiltered edges)', '    //   0.0625 - high quality (faster)', '    //   0.0312 - visible limit (slower)', '    // Special notes when using FXAA_GREEN_AS_LUMA,', '    //   Likely want to set this to zero.', '    //   As colors that are mostly not-green', '    //   will appear very dark in the green channel!', '    //   Tune by looking at mostly non-green content,', '    //   then start at zero and increase until aliasing is a problem.', '    FxaaFloat fxaaQualityEdgeThresholdMin,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.', '    // It is here now to allow easier tuning.', '    // This does not effect PS3, as this needs to be compiled in.', '    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.', '    //   Due to the PS3 being ALU bound,', '    //   there are only three safe values here: 2 and 4 and 8.', '    //   These options use the shaders ability to a free *|/ by 2|4|8.', '    // For all other platforms can be a non-power of two.', '    //   8.0 is sharper (default!!!)', '    //   4.0 is softer', '    //   2.0 is really soft (good only for vector graphics inputs)', '    FxaaFloat fxaaConsoleEdgeSharpness,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.', '    // It is here now to allow easier tuning.', '    // This does not effect PS3, as this needs to be compiled in.', '    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.', '    //   Due to the PS3 being ALU bound,', '    //   there are only two safe values here: 1/4 and 1/8.', '    //   These options use the shaders ability to a free *|/ by 2|4|8.', '    // The console setting has a different mapping than the quality setting.', '    // Other platforms can use other values.', '    //   0.125 leaves less aliasing, but is softer (default!!!)', '    //   0.25 leaves more aliasing, and is sharper', '    FxaaFloat fxaaConsoleEdgeThreshold,', '    //', '    // Only used on FXAA Console.', '    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.', '    // It is here now to allow easier tuning.', '    // Trims the algorithm from processing darks.', '    // The console setting has a different mapping than the quality setting.', '    // This only applies when FXAA_EARLY_EXIT is 1.', '    // This does not apply to PS3,', '    // PS3 was simplified to avoid more shader instructions.', '    //   0.06 - faster but more aliasing in darks', '    //   0.05 - default', '    //   0.04 - slower and less aliasing in darks', '    // Special notes when using FXAA_GREEN_AS_LUMA,', '    //   Likely want to set this to zero.', '    //   As colors that are mostly not-green', '    //   will appear very dark in the green channel!', '    //   Tune by looking at mostly non-green content,', '    //   then start at zero and increase until aliasing is a problem.', '    FxaaFloat fxaaConsoleEdgeThresholdMin,', '    //', '    // Extra constants for 360 FXAA Console only.', '    // Use zeros or anything else for other platforms.', '    // These must be in physical constant registers and NOT immediates.', '    // Immediates will result in compiler un-optimizing.', '    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)', '    FxaaFloat4 fxaaConsole360ConstDir', ') {', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posM;', '    posM.x = pos.x;', '    posM.y = pos.y;', '    #if (FXAA_GATHER4_ALPHA == 1)', '        #if (FXAA_DISCARD == 0)', '            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);', '            #if (FXAA_GREEN_AS_LUMA == 0)', '                #define lumaM rgbyM.w', '            #else', '                #define lumaM rgbyM.y', '            #endif', '        #endif', '        #if (FXAA_GREEN_AS_LUMA == 0)', '            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);', '            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));', '        #else', '            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);', '            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));', '        #endif', '        #if (FXAA_DISCARD == 1)', '            #define lumaM luma4A.w', '        #endif', '        #define lumaE luma4A.z', '        #define lumaS luma4A.x', '        #define lumaSE luma4A.y', '        #define lumaNW luma4B.w', '        #define lumaN luma4B.z', '        #define lumaW luma4B.x', '    #else', '        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);', '        #if (FXAA_GREEN_AS_LUMA == 0)', '            #define lumaM rgbyM.w', '        #else', '            #define lumaM rgbyM.y', '        #endif', '        #if (FXAA_GLSL_100 == 1)', '          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));', '        #else', '          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));', '        #endif', '    #endif', '/*--------------------------------------------------------------------------*/', '    FxaaFloat maxSM = max(lumaS, lumaM);', '    FxaaFloat minSM = min(lumaS, lumaM);', '    FxaaFloat maxESM = max(lumaE, maxSM);', '    FxaaFloat minESM = min(lumaE, minSM);', '    FxaaFloat maxWN = max(lumaN, lumaW);', '    FxaaFloat minWN = min(lumaN, lumaW);', '    FxaaFloat rangeMax = max(maxWN, maxESM);', '    FxaaFloat rangeMin = min(minWN, minESM);', '    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;', '    FxaaFloat range = rangeMax - rangeMin;', '    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);', '    FxaaBool earlyExit = range < rangeMaxClamped;', '/*--------------------------------------------------------------------------*/', '    if(earlyExit)', '        #if (FXAA_DISCARD == 1)', '            FxaaDiscard;', '        #else', '            return rgbyM;', '        #endif', '/*--------------------------------------------------------------------------*/', '    #if (FXAA_GATHER4_ALPHA == 0)', '        #if (FXAA_GLSL_100 == 1)', '          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));', '        #else', '          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));', '          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));', '        #endif', '    #else', '        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));', '        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));', '    #endif', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNS = lumaN + lumaS;', '    FxaaFloat lumaWE = lumaW + lumaE;', '    FxaaFloat subpixRcpRange = 1.0/range;', '    FxaaFloat subpixNSWE = lumaNS + lumaWE;', '    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;', '    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNESE = lumaNE + lumaSE;', '    FxaaFloat lumaNWNE = lumaNW + lumaNE;', '    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;', '    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat lumaNWSW = lumaNW + lumaSW;', '    FxaaFloat lumaSWSE = lumaSW + lumaSE;', '    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);', '    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);', '    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;', '    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;', '    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;', '    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;', '    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;', '    FxaaBool horzSpan = edgeHorz >= edgeVert;', '    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;', '/*--------------------------------------------------------------------------*/', '    if(!horzSpan) lumaN = lumaW;', '    if(!horzSpan) lumaS = lumaE;', '    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;', '    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat gradientN = lumaN - lumaM;', '    FxaaFloat gradientS = lumaS - lumaM;', '    FxaaFloat lumaNN = lumaN + lumaM;', '    FxaaFloat lumaSS = lumaS + lumaM;', '    FxaaBool pairN = abs(gradientN) >= abs(gradientS);', '    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));', '    if(pairN) lengthSign = -lengthSign;', '    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posB;', '    posB.x = posM.x;', '    posB.y = posM.y;', '    FxaaFloat2 offNP;', '    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;', '    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;', '    if(!horzSpan) posB.x += lengthSign * 0.5;', '    if( horzSpan) posB.y += lengthSign * 0.5;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat2 posN;', '    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;', '    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;', '    FxaaFloat2 posP;', '    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;', '    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;', '    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;', '    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));', '    FxaaFloat subpixE = subpixC * subpixC;', '    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));', '/*--------------------------------------------------------------------------*/', '    if(!pairN) lumaNN = lumaSS;', '    FxaaFloat gradientScaled = gradient * 1.0/4.0;', '    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;', '    FxaaFloat subpixF = subpixD * subpixE;', '    FxaaBool lumaMLTZero = lumaMM < 0.0;', '/*--------------------------------------------------------------------------*/', '    lumaEndN -= lumaNN * 0.5;', '    lumaEndP -= lumaNN * 0.5;', '    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;', '    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;', '    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;', '    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;', '    FxaaBool doneNP = (!doneN) || (!doneP);', '    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;', '    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;', '/*--------------------------------------------------------------------------*/', '    if(doneNP) {', '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '        doneN = abs(lumaEndN) >= gradientScaled;', '        doneP = abs(lumaEndP) >= gradientScaled;', '        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;', '        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;', '        doneNP = (!doneN) || (!doneP);', '        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;', '        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;', '/*--------------------------------------------------------------------------*/', '        #if (FXAA_QUALITY_PS > 3)', '        if(doneNP) {', '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '            doneN = abs(lumaEndN) >= gradientScaled;', '            doneP = abs(lumaEndP) >= gradientScaled;', '            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;', '            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;', '            doneNP = (!doneN) || (!doneP);', '            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;', '            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;', '/*--------------------------------------------------------------------------*/', '            #if (FXAA_QUALITY_PS > 4)', '            if(doneNP) {', '                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                doneN = abs(lumaEndN) >= gradientScaled;', '                doneP = abs(lumaEndP) >= gradientScaled;', '                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;', '                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;', '                doneNP = (!doneN) || (!doneP);', '                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;', '                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;', '/*--------------------------------------------------------------------------*/', '                #if (FXAA_QUALITY_PS > 5)', '                if(doneNP) {', '                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                    doneN = abs(lumaEndN) >= gradientScaled;', '                    doneP = abs(lumaEndP) >= gradientScaled;', '                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;', '                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;', '                    doneNP = (!doneN) || (!doneP);', '                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;', '                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;', '/*--------------------------------------------------------------------------*/', '                    #if (FXAA_QUALITY_PS > 6)', '                    if(doneNP) {', '                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                        doneN = abs(lumaEndN) >= gradientScaled;', '                        doneP = abs(lumaEndP) >= gradientScaled;', '                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;', '                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;', '                        doneNP = (!doneN) || (!doneP);', '                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;', '                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;', '/*--------------------------------------------------------------------------*/', '                        #if (FXAA_QUALITY_PS > 7)', '                        if(doneNP) {', '                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                            doneN = abs(lumaEndN) >= gradientScaled;', '                            doneP = abs(lumaEndP) >= gradientScaled;', '                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;', '                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;', '                            doneNP = (!doneN) || (!doneP);', '                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;', '                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;', '/*--------------------------------------------------------------------------*/', '    #if (FXAA_QUALITY_PS > 8)', '    if(doneNP) {', '        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '        doneN = abs(lumaEndN) >= gradientScaled;', '        doneP = abs(lumaEndP) >= gradientScaled;', '        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;', '        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;', '        doneNP = (!doneN) || (!doneP);', '        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;', '        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;', '/*--------------------------------------------------------------------------*/', '        #if (FXAA_QUALITY_PS > 9)', '        if(doneNP) {', '            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '            doneN = abs(lumaEndN) >= gradientScaled;', '            doneP = abs(lumaEndP) >= gradientScaled;', '            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;', '            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;', '            doneNP = (!doneN) || (!doneP);', '            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;', '            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;', '/*--------------------------------------------------------------------------*/', '            #if (FXAA_QUALITY_PS > 10)', '            if(doneNP) {', '                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                doneN = abs(lumaEndN) >= gradientScaled;', '                doneP = abs(lumaEndP) >= gradientScaled;', '                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;', '                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;', '                doneNP = (!doneN) || (!doneP);', '                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;', '                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;', '/*--------------------------------------------------------------------------*/', '                #if (FXAA_QUALITY_PS > 11)', '                if(doneNP) {', '                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                    doneN = abs(lumaEndN) >= gradientScaled;', '                    doneP = abs(lumaEndP) >= gradientScaled;', '                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;', '                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;', '                    doneNP = (!doneN) || (!doneP);', '                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;', '                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;', '/*--------------------------------------------------------------------------*/', '                    #if (FXAA_QUALITY_PS > 12)', '                    if(doneNP) {', '                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));', '                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));', '                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;', '                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;', '                        doneN = abs(lumaEndN) >= gradientScaled;', '                        doneP = abs(lumaEndP) >= gradientScaled;', '                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;', '                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;', '                        doneNP = (!doneN) || (!doneP);', '                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;', '                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;', '/*--------------------------------------------------------------------------*/', '                    }', '                    #endif', '/*--------------------------------------------------------------------------*/', '                }', '                #endif', '/*--------------------------------------------------------------------------*/', '            }', '            #endif', '/*--------------------------------------------------------------------------*/', '        }', '        #endif', '/*--------------------------------------------------------------------------*/', '    }', '    #endif', '/*--------------------------------------------------------------------------*/', '                        }', '                        #endif', '/*--------------------------------------------------------------------------*/', '                    }', '                    #endif', '/*--------------------------------------------------------------------------*/', '                }', '                #endif', '/*--------------------------------------------------------------------------*/', '            }', '            #endif', '/*--------------------------------------------------------------------------*/', '        }', '        #endif', '/*--------------------------------------------------------------------------*/', '    }', '/*--------------------------------------------------------------------------*/', '    FxaaFloat dstN = posM.x - posN.x;', '    FxaaFloat dstP = posP.x - posM.x;', '    if(!horzSpan) dstN = posM.y - posN.y;', '    if(!horzSpan) dstP = posP.y - posM.y;', '/*--------------------------------------------------------------------------*/', '    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;', '    FxaaFloat spanLength = (dstP + dstN);', '    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;', '    FxaaFloat spanLengthRcp = 1.0/spanLength;', '/*--------------------------------------------------------------------------*/', '    FxaaBool directionN = dstN < dstP;', '    FxaaFloat dst = min(dstN, dstP);', '    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;', '    FxaaFloat subpixG = subpixF * subpixF;', '    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;', '    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;', '/*--------------------------------------------------------------------------*/', '    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;', '    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);', '    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;', '    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;', '    #if (FXAA_DISCARD == 1)', '        return FxaaTexTop(tex, posM);', '    #else', '        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);', '    #endif', '}', '/*==========================================================================*/', '#endif', '', 'void main() {', '  gl_FragColor = FxaaPixelShader(', '    vUv,', '    vec4(0.0),', '    tDiffuse,', '    tDiffuse,', '    tDiffuse,', '    resolution,', '    vec4(0.0),', '    vec4(0.0),', '    vec4(0.0),', '    0.75,', '    0.166,', '    0.0833,', '    0.0,', '    0.0,', '    0.0,', '    vec4(0.0)', '  );', '', '  // TODO avoid querying texture twice for same texel', '  gl_FragColor.a = texture2D(tDiffuse, vUv).a;', '}'].join('\\\\n')\\n};\\nexports.FXAAShader = FXAAShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"FXAAShader\",\"uniforms\",\"tDiffuse\",\"resolution\",\"_three\",\"Vector2\",\"vertexShader\",\"fragmentShader\"]\n}\n"]