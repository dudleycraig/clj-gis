["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/exporters/PLYExporter.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$exporters$PLYExporter=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.PLYExporter=void 0;var _three=require(\"module$node_modules$three$build$three_module\");\nglobal=function(){};exports.PLYExporter=global;global.prototype={constructor:global,parse:function(object,onDone,options){function traverseMeshes(cb){object.traverse(function(child){if(!0===child.isMesh){var geometry=child.geometry;if(!0!==geometry.isBufferGeometry)throw Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");!0===geometry.hasAttribute(\"position\")&&cb(child,geometry)}})}onDone&&\"object\"===_typeof(onDone)&&(console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.'),\noptions=onDone,onDone=void 0);options=Object.assign({binary:!1,excludeAttributes:[],littleEndian:!1},options);var excludeAttributes=options.excludeAttributes,includeNormals=!1,includeColors=!1,includeUVs=!1,vertexCount=0,faceCount=0;object.traverse(function(child){if(!0===child.isMesh){var geometry=child.geometry;if(!0!==geometry.isBufferGeometry)throw Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");child=geometry.getAttribute(\"position\");var normals=geometry.getAttribute(\"normal\"),\nuvs=geometry.getAttribute(\"uv\"),colors=geometry.getAttribute(\"color\");geometry=geometry.getIndex();void 0!==child&&(vertexCount+=child.count,faceCount+=geometry?geometry.count/3:child.count/3,void 0!==normals&&(includeNormals=!0),void 0!==uvs&&(includeUVs=!0),void 0!==colors&&(includeColors=!0))}});var includeIndices=-1===excludeAttributes.indexOf(\"index\");includeNormals=includeNormals&&-1===excludeAttributes.indexOf(\"normal\");includeColors=includeColors&&-1===excludeAttributes.indexOf(\"color\");includeUVs=\nincludeUVs&&-1===excludeAttributes.indexOf(\"uv\");if(includeIndices&&faceCount!==Math.floor(faceCount))return console.error(\"PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3.\"),null;excludeAttributes=\"ply\\n\".concat(\"format \".concat(options.binary?options.littleEndian?\"binary_little_endian\":\"binary_big_endian\":\"ascii\",\" 1.0\\n\"),\"element vertex \".concat(vertexCount,\"\\n\"),\"property float x\\nproperty float y\\nproperty float z\\n\");\n!0===includeNormals&&(excludeAttributes+=\"property float nx\\nproperty float ny\\nproperty float nz\\n\");!0===includeUVs&&(excludeAttributes+=\"property float s\\nproperty float t\\n\");!0===includeColors&&(excludeAttributes+=\"property uchar red\\nproperty uchar green\\nproperty uchar blue\\n\");!0===includeIndices&&(excludeAttributes+=\"\".concat(\"element face \".concat(faceCount,\"\\n\"),\"property list uchar int vertex_index\\n\"));excludeAttributes+=\"end_header\\n\";var vertex=new _three.Vector3,normalMatrixWorld=\nnew _three.Matrix3,result=null;if(!0===options.binary){excludeAttributes=(new TextEncoder).encode(excludeAttributes);var vertexListLength=vertexCount*(12+(includeNormals?12:0)+(includeColors?3:0)+(includeUVs?8:0)),output=new DataView(new ArrayBuffer(excludeAttributes.length+vertexListLength+(includeIndices?13*faceCount:0)));(new Uint8Array(output.buffer)).set(excludeAttributes,0);var vOffset=excludeAttributes.length,fOffset=excludeAttributes.length+vertexListLength,writtenVertices=0;traverseMeshes(function(mesh,\ngeometry){var vertices=geometry.getAttribute(\"position\"),normals=geometry.getAttribute(\"normal\"),uvs=geometry.getAttribute(\"uv\"),colors=geometry.getAttribute(\"color\");geometry=geometry.getIndex();normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);for(var i=0,l=vertices.count;i<l;i++)vertex.x=vertices.getX(i),vertex.y=vertices.getY(i),vertex.z=vertices.getZ(i),vertex.applyMatrix4(mesh.matrixWorld),output.setFloat32(vOffset,vertex.x,options.littleEndian),vOffset+=4,output.setFloat32(vOffset,vertex.y,\noptions.littleEndian),vOffset+=4,output.setFloat32(vOffset,vertex.z,options.littleEndian),vOffset+=4,!0===includeNormals&&(null!=normals?(vertex.x=normals.getX(i),vertex.y=normals.getY(i),vertex.z=normals.getZ(i),vertex.applyMatrix3(normalMatrixWorld).normalize(),output.setFloat32(vOffset,vertex.x,options.littleEndian),vOffset+=4,output.setFloat32(vOffset,vertex.y,options.littleEndian),vOffset+=4,output.setFloat32(vOffset,vertex.z,options.littleEndian)):(output.setFloat32(vOffset,0,options.littleEndian),\nvOffset+=4,output.setFloat32(vOffset,0,options.littleEndian),vOffset+=4,output.setFloat32(vOffset,0,options.littleEndian)),vOffset+=4),!0===includeUVs&&(null!=uvs?(output.setFloat32(vOffset,uvs.getX(i),options.littleEndian),vOffset+=4,output.setFloat32(vOffset,uvs.getY(i),options.littleEndian),vOffset+=4):!1!==includeUVs&&(output.setFloat32(vOffset,0,options.littleEndian),vOffset+=4,output.setFloat32(vOffset,0,options.littleEndian),vOffset+=4)),!0===includeColors&&(null!=colors?(output.setUint8(vOffset,\nMath.floor(255*colors.getX(i))),vOffset+=1,output.setUint8(vOffset,Math.floor(255*colors.getY(i))),vOffset+=1,output.setUint8(vOffset,Math.floor(255*colors.getZ(i)))):(output.setUint8(vOffset,255),vOffset+=1,output.setUint8(vOffset,255),vOffset+=1,output.setUint8(vOffset,255)),vOffset+=1);if(!0===includeIndices)if(null!==geometry)for(mesh=0,normals=geometry.count;mesh<normals;mesh+=3)output.setUint8(fOffset,3),fOffset+=1,output.setUint32(fOffset,geometry.getX(mesh+0)+writtenVertices,options.littleEndian),\nfOffset+=4,output.setUint32(fOffset,geometry.getX(mesh+1)+writtenVertices,options.littleEndian),fOffset+=4,output.setUint32(fOffset,geometry.getX(mesh+2)+writtenVertices,options.littleEndian),fOffset+=4;else for(geometry=0,mesh=vertices.count;geometry<mesh;geometry+=3)output.setUint8(fOffset,3),fOffset+=1,output.setUint32(fOffset,writtenVertices+geometry,options.littleEndian),fOffset+=4,output.setUint32(fOffset,writtenVertices+geometry+1,options.littleEndian),fOffset+=4,output.setUint32(fOffset,writtenVertices+\ngeometry+2,options.littleEndian),fOffset+=4;writtenVertices+=vertices.count});result=output.buffer}else{writtenVertices=0;var vertexList=\"\",faceList=\"\";traverseMeshes(function(mesh,geometry){var vertices=geometry.getAttribute(\"position\"),normals=geometry.getAttribute(\"normal\"),uvs=geometry.getAttribute(\"uv\"),colors=geometry.getAttribute(\"color\");geometry=geometry.getIndex();normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);for(var i=0,l=vertices.count;i<l;i++){vertex.x=vertices.getX(i);vertex.y=\nvertices.getY(i);vertex.z=vertices.getZ(i);vertex.applyMatrix4(mesh.matrixWorld);var line=\"\".concat(vertex.x,\" \").concat(vertex.y,\" \").concat(vertex.z);!0===includeNormals&&(null!=normals?(vertex.x=normals.getX(i),vertex.y=normals.getY(i),vertex.z=normals.getZ(i),vertex.applyMatrix3(normalMatrixWorld).normalize(),line+=\" \".concat(vertex.x,\" \").concat(vertex.y,\" \").concat(vertex.z)):line+=\" 0 0 0\");!0===includeUVs&&(null!=uvs?line+=\" \".concat(uvs.getX(i),\" \").concat(uvs.getY(i)):!1!==includeUVs&&(line+=\n\" 0 0\"));!0===includeColors&&(line=null!=colors?line+\" \".concat(Math.floor(255*colors.getX(i)),\" \").concat(Math.floor(255*colors.getY(i)),\" \").concat(Math.floor(255*colors.getZ(i))):line+\" 255 255 255\");vertexList+=\"\".concat(line,\"\\n\")}if(!0===includeIndices){if(null!==geometry)for(mesh=0,normals=geometry.count;mesh<normals;mesh+=3)faceList+=\"3 \".concat(geometry.getX(mesh+0)+writtenVertices),faceList+=\" \".concat(geometry.getX(mesh+1)+writtenVertices),faceList+=\" \".concat(geometry.getX(mesh+2)+writtenVertices,\n\"\\n\");else for(mesh=0,normals=vertices.count;mesh<normals;mesh+=3)faceList+=\"3 \".concat(writtenVertices+mesh,\" \").concat(writtenVertices+mesh+1,\" \").concat(writtenVertices+mesh+2,\"\\n\");faceCount+=geometry?geometry.count/3:vertices.count/3}writtenVertices+=vertices.count});result=\"\".concat(excludeAttributes).concat(vertexList).concat(includeIndices?\"\".concat(faceList,\"\\n\"):\"\\n\")}\"function\"===typeof onDone&&requestAnimationFrame(function(){return onDone(result)});return result}}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$exporters$PLYExporter\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PLYExporter = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  var exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\nvar PLYExporter = function PLYExporter() {};\n\nexports.PLYExporter = PLYExporter;\nPLYExporter.prototype = {\n  constructor: PLYExporter,\n  parse: function parse(object, onDone, options) {\n    if (onDone && _typeof(onDone) === 'object') {\n      console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n      options = onDone;\n      onDone = undefined;\n    } // Iterate over the valid meshes in the object\n\n\n    function traverseMeshes(cb) {\n      object.traverse(function (child) {\n        if (child.isMesh === true) {\n          var mesh = child;\n          var geometry = mesh.geometry;\n\n          if (geometry.isBufferGeometry !== true) {\n            throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n          }\n\n          if (geometry.hasAttribute('position') === true) {\n            cb(mesh, geometry);\n          }\n        }\n      });\n    } // Default options\n\n\n    var defaultOptions = {\n      binary: false,\n      excludeAttributes: [],\n      // normal, uv, color, index\n      littleEndian: false\n    };\n    options = Object.assign(defaultOptions, options);\n    var excludeAttributes = options.excludeAttributes;\n    var includeNormals = false;\n    var includeColors = false;\n    var includeUVs = false; // count the vertices, check which properties are used,\n    // and cache the BufferGeometry\n\n    var vertexCount = 0;\n    var faceCount = 0;\n    object.traverse(function (child) {\n      if (child.isMesh === true) {\n        var mesh = child;\n        var geometry = mesh.geometry;\n\n        if (geometry.isBufferGeometry !== true) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\n        }\n\n        var vertices = geometry.getAttribute('position');\n        var normals = geometry.getAttribute('normal');\n        var uvs = geometry.getAttribute('uv');\n        var colors = geometry.getAttribute('color');\n        var indices = geometry.getIndex();\n\n        if (vertices === undefined) {\n          return;\n        }\n\n        vertexCount += vertices.count;\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        if (normals !== undefined) includeNormals = true;\n        if (uvs !== undefined) includeUVs = true;\n        if (colors !== undefined) includeColors = true;\n      }\n    });\n    var includeIndices = excludeAttributes.indexOf('index') === -1;\n    includeNormals = includeNormals && excludeAttributes.indexOf('normal') === -1;\n    includeColors = includeColors && excludeAttributes.indexOf('color') === -1;\n    includeUVs = includeUVs && excludeAttributes.indexOf('uv') === -1;\n\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      // point cloud meshes will not have an index array and may not have a\n      // number of vertices that is divisble by 3 (and therefore representable\n      // as triangles)\n      console.error('PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' + 'number of indices is not divisible by 3.');\n      return null;\n    }\n\n    var indexByteCount = 4;\n    var header = // position\n    \"ply\\n\".concat(\"format \".concat(options.binary ? options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' : 'ascii', \" 1.0\\n\"), \"element vertex \".concat(vertexCount, \"\\n\"), \"property float x\\nproperty float y\\nproperty float z\\n\");\n\n    if (includeNormals === true) {\n      // normal\n      header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n    }\n\n    if (includeUVs === true) {\n      // uvs\n      header += 'property float s\\n' + 'property float t\\n';\n    }\n\n    if (includeColors === true) {\n      // colors\n      header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n    }\n\n    if (includeIndices === true) {\n      // faces\n      header += \"\".concat(\"element face \".concat(faceCount, \"\\n\"), \"property list uchar int vertex_index\\n\");\n    }\n\n    header += 'end_header\\n'; // Generate attribute data\n\n    var vertex = new _three.Vector3();\n    var normalMatrixWorld = new _three.Matrix3();\n    var result = null;\n\n    if (options.binary === true) {\n      // Binary File Generation\n      var headerBin = new TextEncoder().encode(header); // 3 position values at 4 bytes\n      // 3 normal values at 4 bytes\n      // 3 color channels with 1 byte\n      // 2 uv values at 4 bytes\n\n      var vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0)); // 1 byte shape desciptor\n      // 3 vertex indices at ${indexByteCount} bytes\n\n      var faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n      var output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n      new Uint8Array(output.buffer).set(headerBin, 0);\n      var vOffset = headerBin.length;\n      var fOffset = headerBin.length + vertexListLength;\n      var writtenVertices = 0;\n      traverseMeshes(function (mesh, geometry) {\n        var vertices = geometry.getAttribute('position');\n        var normals = geometry.getAttribute('normal');\n        var uvs = geometry.getAttribute('uv');\n        var colors = geometry.getAttribute('color');\n        var indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n        for (var i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\n          vOffset += 4;\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\n          vOffset += 4; // Normal information\n\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\n              vOffset += 4;\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // UV information\n\n\n          if (includeUVs === true) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n              vOffset += 4;\n            } else if (includeUVs !== false) {\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n              output.setFloat32(vOffset, 0, options.littleEndian);\n              vOffset += 4;\n            }\n          } // Color information\n\n\n          if (includeColors === true) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n              vOffset += 1;\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n              vOffset += 1;\n            } else {\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n              output.setUint8(vOffset, 255);\n              vOffset += 1;\n            }\n          }\n        }\n\n        if (includeIndices === true) {\n          // Create the face list\n          if (indices !== null) {\n            for (var _i = 0, _l = indices.count; _i < _l; _i += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, indices.getX(_i + 0) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(_i + 1) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, indices.getX(_i + 2) + writtenVertices, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          } else {\n            for (var _i2 = 0, _l2 = vertices.count; _i2 < _l2; _i2 += 3) {\n              output.setUint8(fOffset, 3);\n              fOffset += 1;\n              output.setUint32(fOffset, writtenVertices + _i2, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + _i2 + 1, options.littleEndian);\n              fOffset += indexByteCount;\n              output.setUint32(fOffset, writtenVertices + _i2 + 2, options.littleEndian);\n              fOffset += indexByteCount;\n            }\n          }\n        } // Save the amount of verts we've already written so we can offset\n        // the face index on the next mesh\n\n\n        writtenVertices += vertices.count;\n      });\n      result = output.buffer;\n    } else {\n      // Ascii File Generation\n      // count the number of vertices\n      var writtenVertices = 0;\n      var vertexList = '';\n      var faceList = '';\n      traverseMeshes(function (mesh, geometry) {\n        var vertices = geometry.getAttribute('position');\n        var normals = geometry.getAttribute('normal');\n        var uvs = geometry.getAttribute('uv');\n        var colors = geometry.getAttribute('color');\n        var indices = geometry.getIndex();\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld); // form each line\n\n        for (var i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i);\n          vertex.y = vertices.getY(i);\n          vertex.z = vertices.getZ(i);\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\n\n          var line = \"\".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z); // Normal information\n\n          if (includeNormals === true) {\n            if (normals != null) {\n              vertex.x = normals.getX(i);\n              vertex.y = normals.getY(i);\n              vertex.z = normals.getZ(i);\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\n              line += \" \".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z);\n            } else {\n              line += ' 0 0 0';\n            }\n          } // UV information\n\n\n          if (includeUVs === true) {\n            if (uvs != null) {\n              line += \" \".concat(uvs.getX(i), \" \").concat(uvs.getY(i));\n            } else if (includeUVs !== false) {\n              line += ' 0 0';\n            }\n          } // Color information\n\n\n          if (includeColors === true) {\n            if (colors != null) {\n              line += \" \".concat(Math.floor(colors.getX(i) * 255), \" \").concat(Math.floor(colors.getY(i) * 255), \" \").concat(Math.floor(colors.getZ(i) * 255));\n            } else {\n              line += ' 255 255 255';\n            }\n          }\n\n          vertexList += \"\".concat(line, \"\\n\");\n        } // Create the face list\n\n\n        if (includeIndices === true) {\n          if (indices !== null) {\n            for (var _i3 = 0, _l3 = indices.count; _i3 < _l3; _i3 += 3) {\n              faceList += \"3 \".concat(indices.getX(_i3 + 0) + writtenVertices);\n              faceList += \" \".concat(indices.getX(_i3 + 1) + writtenVertices);\n              faceList += \" \".concat(indices.getX(_i3 + 2) + writtenVertices, \"\\n\");\n            }\n          } else {\n            for (var _i4 = 0, _l4 = vertices.count; _i4 < _l4; _i4 += 3) {\n              faceList += \"3 \".concat(writtenVertices + _i4, \" \").concat(writtenVertices + _i4 + 1, \" \").concat(writtenVertices + _i4 + 2, \"\\n\");\n            }\n          }\n\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n        }\n\n        writtenVertices += vertices.count;\n      });\n      result = \"\".concat(header).concat(vertexList).concat(includeIndices ? \"\".concat(faceList, \"\\n\") : '\\n');\n    }\n\n    if (typeof onDone === 'function') requestAnimationFrame(function () {\n      return onDone(result);\n    });\n    return result;\n  }\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["z","prototype","littleEndian","x","__esModule","binary","value","excludeAttributes","y","PLYExporter","parse","constructor"]],"~:compiled-at",1630917515303,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$exporters$PLYExporter.js\",\n\"lineCount\":16,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/exporters/PLYExporter.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$exporters$PLYExporter\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.PLYExporter = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\n/**\\n * https://github.com/gkjohnson/ply-exporter-js\\n *\\n * Usage:\\n *  var exporter = new PLYExporter();\\n *\\n *  // second argument is a list of options\\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\\n *\\n * Format Definition:\\n * http://paulbourke.net/dataformats/ply/\\n */\\nvar PLYExporter = function PLYExporter() {};\\n\\nexports.PLYExporter = PLYExporter;\\nPLYExporter.prototype = {\\n  constructor: PLYExporter,\\n  parse: function parse(object, onDone, options) {\\n    if (onDone && _typeof(onDone) === 'object') {\\n      console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \\\"parse\\\" function. See the documentation for the new API.');\\n      options = onDone;\\n      onDone = undefined;\\n    } // Iterate over the valid meshes in the object\\n\\n\\n    function traverseMeshes(cb) {\\n      object.traverse(function (child) {\\n        if (child.isMesh === true) {\\n          var mesh = child;\\n          var geometry = mesh.geometry;\\n\\n          if (geometry.isBufferGeometry !== true) {\\n            throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\\n          }\\n\\n          if (geometry.hasAttribute('position') === true) {\\n            cb(mesh, geometry);\\n          }\\n        }\\n      });\\n    } // Default options\\n\\n\\n    var defaultOptions = {\\n      binary: false,\\n      excludeAttributes: [],\\n      // normal, uv, color, index\\n      littleEndian: false\\n    };\\n    options = Object.assign(defaultOptions, options);\\n    var excludeAttributes = options.excludeAttributes;\\n    var includeNormals = false;\\n    var includeColors = false;\\n    var includeUVs = false; // count the vertices, check which properties are used,\\n    // and cache the BufferGeometry\\n\\n    var vertexCount = 0;\\n    var faceCount = 0;\\n    object.traverse(function (child) {\\n      if (child.isMesh === true) {\\n        var mesh = child;\\n        var geometry = mesh.geometry;\\n\\n        if (geometry.isBufferGeometry !== true) {\\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.');\\n        }\\n\\n        var vertices = geometry.getAttribute('position');\\n        var normals = geometry.getAttribute('normal');\\n        var uvs = geometry.getAttribute('uv');\\n        var colors = geometry.getAttribute('color');\\n        var indices = geometry.getIndex();\\n\\n        if (vertices === undefined) {\\n          return;\\n        }\\n\\n        vertexCount += vertices.count;\\n        faceCount += indices ? indices.count / 3 : vertices.count / 3;\\n        if (normals !== undefined) includeNormals = true;\\n        if (uvs !== undefined) includeUVs = true;\\n        if (colors !== undefined) includeColors = true;\\n      }\\n    });\\n    var includeIndices = excludeAttributes.indexOf('index') === -1;\\n    includeNormals = includeNormals && excludeAttributes.indexOf('normal') === -1;\\n    includeColors = includeColors && excludeAttributes.indexOf('color') === -1;\\n    includeUVs = includeUVs && excludeAttributes.indexOf('uv') === -1;\\n\\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\\n      // point cloud meshes will not have an index array and may not have a\\n      // number of vertices that is divisble by 3 (and therefore representable\\n      // as triangles)\\n      console.error('PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' + 'number of indices is not divisible by 3.');\\n      return null;\\n    }\\n\\n    var indexByteCount = 4;\\n    var header = // position\\n    \\\"ply\\\\n\\\".concat(\\\"format \\\".concat(options.binary ? options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' : 'ascii', \\\" 1.0\\\\n\\\"), \\\"element vertex \\\".concat(vertexCount, \\\"\\\\n\\\"), \\\"property float x\\\\nproperty float y\\\\nproperty float z\\\\n\\\");\\n\\n    if (includeNormals === true) {\\n      // normal\\n      header += 'property float nx\\\\n' + 'property float ny\\\\n' + 'property float nz\\\\n';\\n    }\\n\\n    if (includeUVs === true) {\\n      // uvs\\n      header += 'property float s\\\\n' + 'property float t\\\\n';\\n    }\\n\\n    if (includeColors === true) {\\n      // colors\\n      header += 'property uchar red\\\\n' + 'property uchar green\\\\n' + 'property uchar blue\\\\n';\\n    }\\n\\n    if (includeIndices === true) {\\n      // faces\\n      header += \\\"\\\".concat(\\\"element face \\\".concat(faceCount, \\\"\\\\n\\\"), \\\"property list uchar int vertex_index\\\\n\\\");\\n    }\\n\\n    header += 'end_header\\\\n'; // Generate attribute data\\n\\n    var vertex = new _three.Vector3();\\n    var normalMatrixWorld = new _three.Matrix3();\\n    var result = null;\\n\\n    if (options.binary === true) {\\n      // Binary File Generation\\n      var headerBin = new TextEncoder().encode(header); // 3 position values at 4 bytes\\n      // 3 normal values at 4 bytes\\n      // 3 color channels with 1 byte\\n      // 2 uv values at 4 bytes\\n\\n      var vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0)); // 1 byte shape desciptor\\n      // 3 vertex indices at ${indexByteCount} bytes\\n\\n      var faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\\n      var output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\\n      new Uint8Array(output.buffer).set(headerBin, 0);\\n      var vOffset = headerBin.length;\\n      var fOffset = headerBin.length + vertexListLength;\\n      var writtenVertices = 0;\\n      traverseMeshes(function (mesh, geometry) {\\n        var vertices = geometry.getAttribute('position');\\n        var normals = geometry.getAttribute('normal');\\n        var uvs = geometry.getAttribute('uv');\\n        var colors = geometry.getAttribute('color');\\n        var indices = geometry.getIndex();\\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\\n\\n        for (var i = 0, l = vertices.count; i < l; i++) {\\n          vertex.x = vertices.getX(i);\\n          vertex.y = vertices.getY(i);\\n          vertex.z = vertices.getZ(i);\\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\\n\\n          output.setFloat32(vOffset, vertex.x, options.littleEndian);\\n          vOffset += 4;\\n          output.setFloat32(vOffset, vertex.y, options.littleEndian);\\n          vOffset += 4;\\n          output.setFloat32(vOffset, vertex.z, options.littleEndian);\\n          vOffset += 4; // Normal information\\n\\n          if (includeNormals === true) {\\n            if (normals != null) {\\n              vertex.x = normals.getX(i);\\n              vertex.y = normals.getY(i);\\n              vertex.z = normals.getZ(i);\\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\\n              output.setFloat32(vOffset, vertex.x, options.littleEndian);\\n              vOffset += 4;\\n              output.setFloat32(vOffset, vertex.y, options.littleEndian);\\n              vOffset += 4;\\n              output.setFloat32(vOffset, vertex.z, options.littleEndian);\\n              vOffset += 4;\\n            } else {\\n              output.setFloat32(vOffset, 0, options.littleEndian);\\n              vOffset += 4;\\n              output.setFloat32(vOffset, 0, options.littleEndian);\\n              vOffset += 4;\\n              output.setFloat32(vOffset, 0, options.littleEndian);\\n              vOffset += 4;\\n            }\\n          } // UV information\\n\\n\\n          if (includeUVs === true) {\\n            if (uvs != null) {\\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\\n              vOffset += 4;\\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\\n              vOffset += 4;\\n            } else if (includeUVs !== false) {\\n              output.setFloat32(vOffset, 0, options.littleEndian);\\n              vOffset += 4;\\n              output.setFloat32(vOffset, 0, options.littleEndian);\\n              vOffset += 4;\\n            }\\n          } // Color information\\n\\n\\n          if (includeColors === true) {\\n            if (colors != null) {\\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\\n              vOffset += 1;\\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\\n              vOffset += 1;\\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\\n              vOffset += 1;\\n            } else {\\n              output.setUint8(vOffset, 255);\\n              vOffset += 1;\\n              output.setUint8(vOffset, 255);\\n              vOffset += 1;\\n              output.setUint8(vOffset, 255);\\n              vOffset += 1;\\n            }\\n          }\\n        }\\n\\n        if (includeIndices === true) {\\n          // Create the face list\\n          if (indices !== null) {\\n            for (var _i = 0, _l = indices.count; _i < _l; _i += 3) {\\n              output.setUint8(fOffset, 3);\\n              fOffset += 1;\\n              output.setUint32(fOffset, indices.getX(_i + 0) + writtenVertices, options.littleEndian);\\n              fOffset += indexByteCount;\\n              output.setUint32(fOffset, indices.getX(_i + 1) + writtenVertices, options.littleEndian);\\n              fOffset += indexByteCount;\\n              output.setUint32(fOffset, indices.getX(_i + 2) + writtenVertices, options.littleEndian);\\n              fOffset += indexByteCount;\\n            }\\n          } else {\\n            for (var _i2 = 0, _l2 = vertices.count; _i2 < _l2; _i2 += 3) {\\n              output.setUint8(fOffset, 3);\\n              fOffset += 1;\\n              output.setUint32(fOffset, writtenVertices + _i2, options.littleEndian);\\n              fOffset += indexByteCount;\\n              output.setUint32(fOffset, writtenVertices + _i2 + 1, options.littleEndian);\\n              fOffset += indexByteCount;\\n              output.setUint32(fOffset, writtenVertices + _i2 + 2, options.littleEndian);\\n              fOffset += indexByteCount;\\n            }\\n          }\\n        } // Save the amount of verts we've already written so we can offset\\n        // the face index on the next mesh\\n\\n\\n        writtenVertices += vertices.count;\\n      });\\n      result = output.buffer;\\n    } else {\\n      // Ascii File Generation\\n      // count the number of vertices\\n      var writtenVertices = 0;\\n      var vertexList = '';\\n      var faceList = '';\\n      traverseMeshes(function (mesh, geometry) {\\n        var vertices = geometry.getAttribute('position');\\n        var normals = geometry.getAttribute('normal');\\n        var uvs = geometry.getAttribute('uv');\\n        var colors = geometry.getAttribute('color');\\n        var indices = geometry.getIndex();\\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld); // form each line\\n\\n        for (var i = 0, l = vertices.count; i < l; i++) {\\n          vertex.x = vertices.getX(i);\\n          vertex.y = vertices.getY(i);\\n          vertex.z = vertices.getZ(i);\\n          vertex.applyMatrix4(mesh.matrixWorld); // Position information\\n\\n          var line = \\\"\\\".concat(vertex.x, \\\" \\\").concat(vertex.y, \\\" \\\").concat(vertex.z); // Normal information\\n\\n          if (includeNormals === true) {\\n            if (normals != null) {\\n              vertex.x = normals.getX(i);\\n              vertex.y = normals.getY(i);\\n              vertex.z = normals.getZ(i);\\n              vertex.applyMatrix3(normalMatrixWorld).normalize();\\n              line += \\\" \\\".concat(vertex.x, \\\" \\\").concat(vertex.y, \\\" \\\").concat(vertex.z);\\n            } else {\\n              line += ' 0 0 0';\\n            }\\n          } // UV information\\n\\n\\n          if (includeUVs === true) {\\n            if (uvs != null) {\\n              line += \\\" \\\".concat(uvs.getX(i), \\\" \\\").concat(uvs.getY(i));\\n            } else if (includeUVs !== false) {\\n              line += ' 0 0';\\n            }\\n          } // Color information\\n\\n\\n          if (includeColors === true) {\\n            if (colors != null) {\\n              line += \\\" \\\".concat(Math.floor(colors.getX(i) * 255), \\\" \\\").concat(Math.floor(colors.getY(i) * 255), \\\" \\\").concat(Math.floor(colors.getZ(i) * 255));\\n            } else {\\n              line += ' 255 255 255';\\n            }\\n          }\\n\\n          vertexList += \\\"\\\".concat(line, \\\"\\\\n\\\");\\n        } // Create the face list\\n\\n\\n        if (includeIndices === true) {\\n          if (indices !== null) {\\n            for (var _i3 = 0, _l3 = indices.count; _i3 < _l3; _i3 += 3) {\\n              faceList += \\\"3 \\\".concat(indices.getX(_i3 + 0) + writtenVertices);\\n              faceList += \\\" \\\".concat(indices.getX(_i3 + 1) + writtenVertices);\\n              faceList += \\\" \\\".concat(indices.getX(_i3 + 2) + writtenVertices, \\\"\\\\n\\\");\\n            }\\n          } else {\\n            for (var _i4 = 0, _l4 = vertices.count; _i4 < _l4; _i4 += 3) {\\n              faceList += \\\"3 \\\".concat(writtenVertices + _i4, \\\" \\\").concat(writtenVertices + _i4 + 1, \\\" \\\").concat(writtenVertices + _i4 + 2, \\\"\\\\n\\\");\\n            }\\n          }\\n\\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\\n        }\\n\\n        writtenVertices += vertices.count;\\n      });\\n      result = \\\"\\\".concat(header).concat(vertexList).concat(includeIndices ? \\\"\\\".concat(faceList, \\\"\\\\n\\\") : '\\\\n');\\n    }\\n\\n    if (typeof onDone === 'function') requestAnimationFrame(function () {\\n      return onDone(result);\\n    });\\n    return result;\\n  }\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"Object\",\"defineProperty\",\"value\",\"PLYExporter\",\"_three\",\"parse\",\"object\",\"onDone\",\"options\",\"traverseMeshes\",\"cb\",\"traverse\",\"child\",\"isMesh\",\"geometry\",\"isBufferGeometry\",\"Error\",\"hasAttribute\",\"console\",\"warn\",\"undefined\",\"assign\",\"defaultOptions\",\"binary\",\"excludeAttributes\",\"littleEndian\",\"includeNormals\",\"includeColors\",\"includeUVs\",\"vertexCount\",\"faceCount\",\"vertices\",\"getAttribute\",\"normals\",\"uvs\",\"colors\",\"indices\",\"getIndex\",\"count\",\"includeIndices\",\"indexOf\",\"Math\",\"floor\",\"error\",\"header\",\"concat\",\"vertex\",\"Vector3\",\"normalMatrixWorld\",\"Matrix3\",\"result\",\"headerBin\",\"encode\",\"TextEncoder\",\"vertexListLength\",\"output\",\"DataView\",\"ArrayBuffer\",\"length\",\"faceListLength\",\"set\",\"Uint8Array\",\"buffer\",\"vOffset\",\"fOffset\",\"writtenVertices\",\"mesh\",\"getNormalMatrix\",\"matrixWorld\",\"i\",\"l\",\"x\",\"getX\",\"y\",\"getY\",\"z\",\"getZ\",\"applyMatrix4\",\"setFloat32\",\"applyMatrix3\",\"normalize\",\"setUint8\",\"_i\",\"_l\",\"setUint32\",\"indexByteCount\",\"_i2\",\"_l2\",\"vertexList\",\"faceList\",\"line\",\"_i3\",\"_l3\",\"_i4\",\"_l4\",\"requestAnimationFrame\"]\n}\n"]