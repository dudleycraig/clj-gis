["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/postprocessing/OutlinePass.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$postprocessing$OutlinePass=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.OutlinePass=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_Pass=require(\"module$node_modules$three_stdlib$postprocessing$Pass\"),_CopyShader=require(\"module$node_modules$three_stdlib$shaders$CopyShader\"),OutlinePass=function(resolution,scene,camera,selectedObjects){this.renderScene=scene;this.renderCamera=\ncamera;this.selectedObjects=void 0!==selectedObjects?selectedObjects:[];this.visibleEdgeColor=new _three.Color(1,1,1);this.hiddenEdgeColor=new _three.Color(.1,.04,.02);this.edgeGlow=0;this.usePatternTexture=!1;this.edgeThickness=1;this.edgeStrength=3;this.downSampleRatio=2;this.pulsePeriod=0;this._visibilityCache=new Map;this.resolution=void 0!==resolution?new _three.Vector2(resolution.x,resolution.y):new _three.Vector2(256,256);resolution={minFilter:_three.LinearFilter,magFilter:_three.LinearFilter,\nformat:_three.RGBAFormat};scene=Math.round(this.resolution.x/this.downSampleRatio);camera=Math.round(this.resolution.y/this.downSampleRatio);this.maskBufferMaterial=new _three.MeshBasicMaterial({color:16777215});this.maskBufferMaterial.side=_three.DoubleSide;this.renderTargetMaskBuffer=new _three.WebGLRenderTarget(this.resolution.x,this.resolution.y,resolution);this.renderTargetMaskBuffer.texture.name=\"OutlinePass.mask\";this.renderTargetMaskBuffer.texture.generateMipmaps=!1;this.depthMaterial=new _three.MeshDepthMaterial;\nthis.depthMaterial.side=_three.DoubleSide;this.depthMaterial.depthPacking=_three.RGBADepthPacking;this.depthMaterial.blending=_three.NoBlending;this.prepareMaskMaterial=this.getPrepareMaskMaterial();this.prepareMaskMaterial.side=_three.DoubleSide;selectedObjects=this.prepareMaskMaterial;var JSCompiler_inline_result=this.prepareMaskMaterial.fragmentShader.replace(/DEPTH_TO_VIEW_Z/g,(this.renderCamera.isPerspectiveCamera?\"perspective\":\"orthographic\")+\"DepthToViewZ\");selectedObjects.fragmentShader=JSCompiler_inline_result;\nthis.renderTargetDepthBuffer=new _three.WebGLRenderTarget(this.resolution.x,this.resolution.y,resolution);this.renderTargetDepthBuffer.texture.name=\"OutlinePass.depth\";this.renderTargetDepthBuffer.texture.generateMipmaps=!1;this.renderTargetMaskDownSampleBuffer=new _three.WebGLRenderTarget(scene,camera,resolution);this.renderTargetMaskDownSampleBuffer.texture.name=\"OutlinePass.depthDownSample\";this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1;this.renderTargetBlurBuffer1=new _three.WebGLRenderTarget(scene,\ncamera,resolution);this.renderTargetBlurBuffer1.texture.name=\"OutlinePass.blur1\";this.renderTargetBlurBuffer1.texture.generateMipmaps=!1;this.renderTargetBlurBuffer2=new _three.WebGLRenderTarget(Math.round(scene/2),Math.round(camera/2),resolution);this.renderTargetBlurBuffer2.texture.name=\"OutlinePass.blur2\";this.renderTargetBlurBuffer2.texture.generateMipmaps=!1;this.edgeDetectionMaterial=this.getEdgeDetectionMaterial();this.renderTargetEdgeBuffer1=new _three.WebGLRenderTarget(scene,camera,resolution);\nthis.renderTargetEdgeBuffer1.texture.name=\"OutlinePass.edge1\";this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1;this.renderTargetEdgeBuffer2=new _three.WebGLRenderTarget(Math.round(scene/2),Math.round(camera/2),resolution);this.renderTargetEdgeBuffer2.texture.name=\"OutlinePass.edge2\";this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;this.separableBlurMaterial1=this.getSeperableBlurMaterial(4);this.separableBlurMaterial1.uniforms.texSize.value.set(scene,camera);this.separableBlurMaterial1.uniforms.kernelRadius.value=\n1;this.separableBlurMaterial2=this.getSeperableBlurMaterial(4);this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(scene/2),Math.round(camera/2));this.separableBlurMaterial2.uniforms.kernelRadius.value=4;this.overlayMaterial=this.getOverlayMaterial();void 0===_CopyShader.CopyShader&&console.error(\"THREE.OutlinePass relies on CopyShader\");resolution=_CopyShader.CopyShader;this.copyUniforms=_three.UniformsUtils.clone(resolution.uniforms);this.copyUniforms.opacity.value=1;this.materialCopy=\nnew _three.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:resolution.vertexShader,fragmentShader:resolution.fragmentShader,blending:_three.NoBlending,depthTest:!1,depthWrite:!1,transparent:!0});this.enabled=!0;this.needsSwap=!1;this._oldClearColor=new _three.Color;this.oldClearAlpha=1;this.fsQuad=new _Pass.FullScreenQuad(null);this.tempPulseColor1=new _three.Color;this.tempPulseColor2=new _three.Color;this.textureMatrix=new _three.Matrix4};exports.OutlinePass=OutlinePass;OutlinePass.prototype=\nObject.assign(Object.create(_Pass.Pass.prototype),{constructor:OutlinePass,dispose:function(){this.renderTargetMaskBuffer.dispose();this.renderTargetDepthBuffer.dispose();this.renderTargetMaskDownSampleBuffer.dispose();this.renderTargetBlurBuffer1.dispose();this.renderTargetBlurBuffer2.dispose();this.renderTargetEdgeBuffer1.dispose();this.renderTargetEdgeBuffer2.dispose()},setSize:function(width,height){this.renderTargetMaskBuffer.setSize(width,height);width=Math.round(width/this.downSampleRatio);\nheight=Math.round(height/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(width,height);this.renderTargetBlurBuffer1.setSize(width,height);this.renderTargetEdgeBuffer1.setSize(width,height);this.separableBlurMaterial1.uniforms.texSize.value.set(width,height);width=Math.round(width/2);height=Math.round(height/2);this.renderTargetBlurBuffer2.setSize(width,height);this.renderTargetEdgeBuffer2.setSize(width,height);this.separableBlurMaterial2.uniforms.texSize.value.set(width,height)},\nchangeVisibilityOfSelectedObjects:function(bVisible){function gatherSelectedMeshesCallBack(object){object.isMesh&&(!0===bVisible?object.visible=cache.get(object):(cache.set(object,object.visible),object.visible=bVisible))}for(var cache=this._visibilityCache,i=0;i<this.selectedObjects.length;i++)this.selectedObjects[i].traverse(gatherSelectedMeshesCallBack)},changeVisibilityOfNonSelectedObjects:function(bVisible){function gatherSelectedMeshesCallBack(object){object.isMesh&&selectedMeshes.push(object)}\nfor(var cache=this._visibilityCache,selectedMeshes=[],i=0;i<this.selectedObjects.length;i++)this.selectedObjects[i].traverse(gatherSelectedMeshesCallBack);this.renderScene.traverse(function(object){if(object.isMesh||object.isSprite){for(var bFound=!1,_i=0;_i<selectedMeshes.length;_i++)if(selectedMeshes[_i].id===object.id){bFound=!0;break}if(!1===bFound){bFound=object.visible;if(!1===bVisible||!0===cache.get(object))object.visible=bVisible;cache.set(object,bFound)}}else if(object.isPoints||object.isLine)!0===\nbVisible?object.visible=cache.get(object):(cache.set(object,object.visible),object.visible=bVisible)})},updateTextureMatrix:function(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);this.textureMatrix.multiply(this.renderCamera.projectionMatrix);this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)},render:function(renderer,writeBuffer,readBuffer,deltaTime,maskActive){0<this.selectedObjects.length&&(renderer.getClearColor(this._oldClearColor),this.oldClearAlpha=renderer.getClearAlpha(),\nwriteBuffer=renderer.autoClear,renderer.autoClear=!1,maskActive&&renderer.state.buffers.stencil.setTest(!1),renderer.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1),deltaTime=this.renderScene.background,this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,renderer.setRenderTarget(this.renderTargetDepthBuffer),renderer.clear(),renderer.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this._visibilityCache.clear(),\nthis.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,renderer.setRenderTarget(this.renderTargetMaskBuffer),renderer.clear(),renderer.render(this.renderScene,\nthis.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this._visibilityCache.clear(),this.renderScene.background=deltaTime,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer),renderer.clear(),this.fsQuad.render(renderer),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),0<this.pulsePeriod&&\n(deltaTime=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2,this.tempPulseColor1.multiplyScalar(deltaTime),this.tempPulseColor2.multiplyScalar(deltaTime)),this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=\nthis.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,renderer.setRenderTarget(this.renderTargetEdgeBuffer1),renderer.clear(),this.fsQuad.render(renderer),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=OutlinePass.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,renderer.setRenderTarget(this.renderTargetBlurBuffer1),\nrenderer.clear(),this.fsQuad.render(renderer),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=OutlinePass.BlurDirectionY,renderer.setRenderTarget(this.renderTargetEdgeBuffer1),renderer.clear(),this.fsQuad.render(renderer),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=\nOutlinePass.BlurDirectionX,renderer.setRenderTarget(this.renderTargetBlurBuffer2),renderer.clear(),this.fsQuad.render(renderer),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=OutlinePass.BlurDirectionY,renderer.setRenderTarget(this.renderTargetEdgeBuffer2),renderer.clear(),this.fsQuad.render(renderer),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,\nthis.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,maskActive&&renderer.state.buffers.stencil.setTest(!0),\nrenderer.setRenderTarget(readBuffer),this.fsQuad.render(renderer),renderer.setClearColor(this._oldClearColor,this.oldClearAlpha),renderer.autoClear=writeBuffer);this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=readBuffer.texture,renderer.setRenderTarget(null),this.fsQuad.render(renderer))},getPrepareMaskMaterial:function(){return new _three.ShaderMaterial({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new _three.Vector2(.5,.5)},textureMatrix:{value:null}},\nvertexShader:\"#include \\x3cmorphtarget_pars_vertex\\x3e\\n#include \\x3cskinning_pars_vertex\\x3e\\nvarying vec4 projTexCoord;\\nvarying vec4 vPosition;\\nuniform mat4 textureMatrix;\\nvoid main() {\\n\\t#include \\x3cskinbase_vertex\\x3e\\n\\t#include \\x3cbegin_vertex\\x3e\\n\\t#include \\x3cmorphtarget_vertex\\x3e\\n\\t#include \\x3cskinning_vertex\\x3e\\n\\t#include \\x3cproject_vertex\\x3e\\n\\tvPosition \\x3d mvPosition;\\n\\tvec4 worldPosition \\x3d modelMatrix * vec4( position, 1.0 );\\n\\tprojTexCoord \\x3d textureMatrix * worldPosition;\\n}\",\nfragmentShader:\"#include \\x3cpacking\\x3e\\nvarying vec4 vPosition;\\nvarying vec4 projTexCoord;\\nuniform sampler2D depthTexture;\\nuniform vec2 cameraNearFar;\\nvoid main() {\\n\\tfloat depth \\x3d unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\\n\\tfloat viewZ \\x3d - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\\n\\tfloat depthTest \\x3d (-vPosition.z \\x3e viewZ) ? 1.0 : 0.0;\\n\\tgl_FragColor \\x3d vec4(0.0, depthTest, 1.0, 1.0);\\n}\"})},getEdgeDetectionMaterial:function(){return new _three.ShaderMaterial({uniforms:{maskTexture:{value:null},\ntexSize:{value:new _three.Vector2(.5,.5)},visibleEdgeColor:{value:new _three.Vector3(1,1,1)},hiddenEdgeColor:{value:new _three.Vector3(1,1,1)}},vertexShader:\"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv \\x3d uv;\\n\\t\\t\\t\\t\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",fragmentShader:\"varying vec2 vUv;\\t\\t\\t\\tuniform sampler2D maskTexture;\\t\\t\\t\\tuniform vec2 texSize;\\t\\t\\t\\tuniform vec3 visibleEdgeColor;\\t\\t\\t\\tuniform vec3 hiddenEdgeColor;\\t\\t\\t\\t\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize \\x3d 1.0 / texSize;\\t\\t\\t\\t\\tvec4 uvOffset \\x3d vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\t\\t\\t\\t\\tvec4 c1 \\x3d texture2D( maskTexture, vUv + uvOffset.xy);\\t\\t\\t\\t\\tvec4 c2 \\x3d texture2D( maskTexture, vUv - uvOffset.xy);\\t\\t\\t\\t\\tvec4 c3 \\x3d texture2D( maskTexture, vUv + uvOffset.yw);\\t\\t\\t\\t\\tvec4 c4 \\x3d texture2D( maskTexture, vUv - uvOffset.yw);\\t\\t\\t\\t\\tfloat diff1 \\x3d (c1.r - c2.r)*0.5;\\t\\t\\t\\t\\tfloat diff2 \\x3d (c3.r - c4.r)*0.5;\\t\\t\\t\\t\\tfloat d \\x3d length( vec2(diff1, diff2) );\\t\\t\\t\\t\\tfloat a1 \\x3d min(c1.g, c2.g);\\t\\t\\t\\t\\tfloat a2 \\x3d min(c3.g, c4.g);\\t\\t\\t\\t\\tfloat visibilityFactor \\x3d min(a1, a2);\\t\\t\\t\\t\\tvec3 edgeColor \\x3d 1.0 - visibilityFactor \\x3e 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\t\\t\\t\\t\\tgl_FragColor \\x3d vec4(edgeColor, 1.0) * vec4(d);\\t\\t\\t\\t}\"})},\ngetSeperableBlurMaterial:function(maxRadius){return new _three.ShaderMaterial({defines:{MAX_RADIUS:maxRadius},uniforms:{colorTexture:{value:null},texSize:{value:new _three.Vector2(.5,.5)},direction:{value:new _three.Vector2(.5,.5)},kernelRadius:{value:1}},vertexShader:\"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv \\x3d uv;\\n\\t\\t\\t\\t\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",fragmentShader:\"#include \\x3ccommon\\x3e\\t\\t\\t\\tvarying vec2 vUv;\\t\\t\\t\\tuniform sampler2D colorTexture;\\t\\t\\t\\tuniform vec2 texSize;\\t\\t\\t\\tuniform vec2 direction;\\t\\t\\t\\tuniform float kernelRadius;\\t\\t\\t\\t\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\t\\t\\t\\t}\\t\\t\\t\\tvoid main() {\\t\\t\\t\\t\\tvec2 invSize \\x3d 1.0 / texSize;\\t\\t\\t\\t\\tfloat weightSum \\x3d gaussianPdf(0.0, kernelRadius);\\t\\t\\t\\t\\tvec4 diffuseSum \\x3d texture2D( colorTexture, vUv) * weightSum;\\t\\t\\t\\t\\tvec2 delta \\x3d direction * invSize * kernelRadius/float(MAX_RADIUS);\\t\\t\\t\\t\\tvec2 uvOffset \\x3d delta;\\t\\t\\t\\t\\tfor( int i \\x3d 1; i \\x3c\\x3d MAX_RADIUS; i ++ ) {\\t\\t\\t\\t\\t\\tfloat w \\x3d gaussianPdf(uvOffset.x, kernelRadius);\\t\\t\\t\\t\\t\\tvec4 sample1 \\x3d texture2D( colorTexture, vUv + uvOffset);\\t\\t\\t\\t\\t\\tvec4 sample2 \\x3d texture2D( colorTexture, vUv - uvOffset);\\t\\t\\t\\t\\t\\tdiffuseSum +\\x3d ((sample1 + sample2) * w);\\t\\t\\t\\t\\t\\tweightSum +\\x3d (2.0 * w);\\t\\t\\t\\t\\t\\tuvOffset +\\x3d delta;\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\tgl_FragColor \\x3d diffuseSum/weightSum;\\t\\t\\t\\t}\"})},\ngetOverlayMaterial:function(){return new _three.ShaderMaterial({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:\"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv \\x3d uv;\\n\\t\\t\\t\\t\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",fragmentShader:\"varying vec2 vUv;\\t\\t\\t\\tuniform sampler2D maskTexture;\\t\\t\\t\\tuniform sampler2D edgeTexture1;\\t\\t\\t\\tuniform sampler2D edgeTexture2;\\t\\t\\t\\tuniform sampler2D patternTexture;\\t\\t\\t\\tuniform float edgeStrength;\\t\\t\\t\\tuniform float edgeGlow;\\t\\t\\t\\tuniform bool usePatternTexture;\\t\\t\\t\\t\\t\\t\\t\\tvoid main() {\\t\\t\\t\\t\\tvec4 edgeValue1 \\x3d texture2D(edgeTexture1, vUv);\\t\\t\\t\\t\\tvec4 edgeValue2 \\x3d texture2D(edgeTexture2, vUv);\\t\\t\\t\\t\\tvec4 maskColor \\x3d texture2D(maskTexture, vUv);\\t\\t\\t\\t\\tvec4 patternColor \\x3d texture2D(patternTexture, 6.0 * vUv);\\t\\t\\t\\t\\tfloat visibilityFactor \\x3d 1.0 - maskColor.g \\x3e 0.0 ? 1.0 : 0.5;\\t\\t\\t\\t\\tvec4 edgeValue \\x3d edgeValue1 + edgeValue2 * edgeGlow;\\t\\t\\t\\t\\tvec4 finalColor \\x3d edgeStrength * maskColor.r * edgeValue;\\t\\t\\t\\t\\tif(usePatternTexture)\\t\\t\\t\\t\\t\\tfinalColor +\\x3d + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\t\\t\\t\\t\\tgl_FragColor \\x3d finalColor;\\t\\t\\t\\t}\",\nblending:_three.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0})}});OutlinePass.BlurDirectionX=new _three.Vector2(1,0);OutlinePass.BlurDirectionY=new _three.Vector2(0,1)}","~:source","shadow$provide[\"module$node_modules$three_stdlib$postprocessing$OutlinePass\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OutlinePass = void 0;\n\nvar _three = require(\"three\");\n\nvar _Pass = require(\"./Pass.js\");\n\nvar _CopyShader = require(\"../shaders/CopyShader.js\");\n\nvar OutlinePass = function OutlinePass(resolution, scene, camera, selectedObjects) {\n  this.renderScene = scene;\n  this.renderCamera = camera;\n  this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n  this.visibleEdgeColor = new _three.Color(1, 1, 1);\n  this.hiddenEdgeColor = new _three.Color(0.1, 0.04, 0.02);\n  this.edgeGlow = 0.0;\n  this.usePatternTexture = false;\n  this.edgeThickness = 1.0;\n  this.edgeStrength = 3.0;\n  this.downSampleRatio = 2;\n  this.pulsePeriod = 0;\n  this._visibilityCache = new Map();\n  this.resolution = resolution !== undefined ? new _three.Vector2(resolution.x, resolution.y) : new _three.Vector2(256, 256);\n  var pars = {\n    minFilter: _three.LinearFilter,\n    magFilter: _three.LinearFilter,\n    format: _three.RGBAFormat\n  };\n  var resx = Math.round(this.resolution.x / this.downSampleRatio);\n  var resy = Math.round(this.resolution.y / this.downSampleRatio);\n  this.maskBufferMaterial = new _three.MeshBasicMaterial({\n    color: 0xffffff\n  });\n  this.maskBufferMaterial.side = _three.DoubleSide;\n  this.renderTargetMaskBuffer = new _three.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n  this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n  this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n  this.depthMaterial = new _three.MeshDepthMaterial();\n  this.depthMaterial.side = _three.DoubleSide;\n  this.depthMaterial.depthPacking = _three.RGBADepthPacking;\n  this.depthMaterial.blending = _three.NoBlending;\n  this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n  this.prepareMaskMaterial.side = _three.DoubleSide;\n  this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n  this.renderTargetDepthBuffer = new _three.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n  this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n  this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n  this.renderTargetMaskDownSampleBuffer = new _three.WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n  this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n  this.renderTargetBlurBuffer1 = new _three.WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n  this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n  this.renderTargetBlurBuffer2 = new _three.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n  this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n  this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n  this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n  this.renderTargetEdgeBuffer1 = new _three.WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n  this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n  this.renderTargetEdgeBuffer2 = new _three.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n  this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n  this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n  var MAX_EDGE_THICKNESS = 4;\n  var MAX_EDGE_GLOW = 4;\n  this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n  this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n  this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n  this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n  this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n  this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\n\n  this.overlayMaterial = this.getOverlayMaterial(); // copy material\n\n  if (_CopyShader.CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\n  var copyShader = _CopyShader.CopyShader;\n  this.copyUniforms = _three.UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new _three.ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: _three.NoBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new _three.Color();\n  this.oldClearAlpha = 1;\n  this.fsQuad = new _Pass.FullScreenQuad(null);\n  this.tempPulseColor1 = new _three.Color();\n  this.tempPulseColor2 = new _three.Color();\n  this.textureMatrix = new _three.Matrix4();\n\n  function replaceDepthToViewZ(string, camera) {\n    var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n    return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n  }\n};\n\nexports.OutlinePass = OutlinePass;\nOutlinePass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {\n  constructor: OutlinePass,\n  dispose: function dispose() {\n    this.renderTargetMaskBuffer.dispose();\n    this.renderTargetDepthBuffer.dispose();\n    this.renderTargetMaskDownSampleBuffer.dispose();\n    this.renderTargetBlurBuffer1.dispose();\n    this.renderTargetBlurBuffer2.dispose();\n    this.renderTargetEdgeBuffer1.dispose();\n    this.renderTargetEdgeBuffer2.dispose();\n  },\n  setSize: function setSize(width, height) {\n    this.renderTargetMaskBuffer.setSize(width, height);\n    var resx = Math.round(width / this.downSampleRatio);\n    var resy = Math.round(height / this.downSampleRatio);\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n  },\n  changeVisibilityOfSelectedObjects: function changeVisibilityOfSelectedObjects(bVisible) {\n    var cache = this._visibilityCache;\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object);\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    for (var i = 0; i < this.selectedObjects.length; i++) {\n      var selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n  },\n  changeVisibilityOfNonSelectedObjects: function changeVisibilityOfNonSelectedObjects(bVisible) {\n    var cache = this._visibilityCache;\n    var selectedMeshes = [];\n\n    function gatherSelectedMeshesCallBack(object) {\n      if (object.isMesh) selectedMeshes.push(object);\n    }\n\n    for (var i = 0; i < this.selectedObjects.length; i++) {\n      var selectedObject = this.selectedObjects[i];\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\n    }\n\n    function VisibilityChangeCallBack(object) {\n      if (object.isMesh || object.isSprite) {\n        // only meshes and sprites are supported by OutlinePass\n        var bFound = false;\n\n        for (var _i = 0; _i < selectedMeshes.length; _i++) {\n          var selectedObjectId = selectedMeshes[_i].id;\n\n          if (selectedObjectId === object.id) {\n            bFound = true;\n            break;\n          }\n        }\n\n        if (bFound === false) {\n          var visibility = object.visible;\n\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible;\n          }\n\n          cache.set(object, visibility);\n        }\n      } else if (object.isPoints || object.isLine) {\n        // the visibilty of points and lines is always set to false in order to\n        // not affect the outline computation\n        if (bVisible === true) {\n          object.visible = cache.get(object); // restore\n        } else {\n          cache.set(object, object.visible);\n          object.visible = bVisible;\n        }\n      }\n    }\n\n    this.renderScene.traverse(VisibilityChangeCallBack);\n  },\n  updateTextureMatrix: function updateTextureMatrix() {\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n  },\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      var oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\n\n      this.changeVisibilityOfSelectedObjects(false);\n      var currentBackground = this.renderScene.background;\n      this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\n\n      this.renderScene.overrideMaterial = this.depthMaterial;\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\n\n      this.changeVisibilityOfSelectedObjects(true);\n\n      this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\n\n\n      this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\n      this.changeVisibilityOfNonSelectedObjects(false);\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\n      renderer.clear();\n      renderer.render(this.renderScene, this.renderCamera);\n      this.renderScene.overrideMaterial = null;\n      this.changeVisibilityOfNonSelectedObjects(true);\n\n      this._visibilityCache.clear();\n\n      this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\n\n      if (this.pulsePeriod > 0) {\n        var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n        this.tempPulseColor1.multiplyScalar(scalar);\n        this.tempPulseColor2.multiplyScalar(scalar);\n      } // 3. Apply Edge Detection Pass\n\n\n      this.fsQuad.material = this.edgeDetectionMaterial;\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // 4. Apply Blur on Half res\n\n      this.fsQuad.material = this.separableBlurMaterial1;\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Apply Blur on quarter res\n\n      this.fsQuad.material = this.separableBlurMaterial2;\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n      renderer.clear();\n      this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n      this.fsQuad.material = this.overlayMaterial;\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    }\n  },\n  getPrepareMaskMaterial: function getPrepareMaskMaterial() {\n    return new _three.ShaderMaterial({\n      uniforms: {\n        depthTexture: {\n          value: null\n        },\n        cameraNearFar: {\n          value: new _three.Vector2(0.5, 0.5)\n        },\n        textureMatrix: {\n          value: null\n        }\n      },\n      vertexShader: ['#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', 'varying vec4 projTexCoord;', 'varying vec4 vPosition;', 'uniform mat4 textureMatrix;', 'void main() {', '\t#include <skinbase_vertex>', '\t#include <begin_vertex>', '\t#include <morphtarget_vertex>', '\t#include <skinning_vertex>', '\t#include <project_vertex>', '\tvPosition = mvPosition;', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tprojTexCoord = textureMatrix * worldPosition;', '}'].join('\\n'),\n      fragmentShader: ['#include <packing>', 'varying vec4 vPosition;', 'varying vec4 projTexCoord;', 'uniform sampler2D depthTexture;', 'uniform vec2 cameraNearFar;', 'void main() {', '\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));', '\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );', '\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;', '\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);', '}'].join('\\n')\n    });\n  },\n  getEdgeDetectionMaterial: function getEdgeDetectionMaterial() {\n    return new _three.ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        texSize: {\n          value: new _three.Vector2(0.5, 0.5)\n        },\n        visibleEdgeColor: {\n          value: new _three.Vector3(1.0, 1.0, 1.0)\n        },\n        hiddenEdgeColor: {\n          value: new _three.Vector3(1.0, 1.0, 1.0)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec3 visibleEdgeColor;\\\n\t\t\t\tuniform vec3 hiddenEdgeColor;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\\\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\\\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\\\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\\\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\\\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\\\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\n\t\t\t\t}'\n    });\n  },\n  getSeperableBlurMaterial: function getSeperableBlurMaterial(maxRadius) {\n    return new _three.ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new _three.Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new _three.Vector2(0.5, 0.5)\n        },\n        kernelRadius: {\n          value: 1.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: '#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\\n\t\t\t\tuniform sampler2D colorTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\tuniform float kernelRadius;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\n\t\t\t\t\tvec2 uvOffset = delta;\\\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\\\n\t\t\t\t\t\tweightSum += (2.0 * w);\\\n\t\t\t\t\t\tuvOffset += delta;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\\\n\t\t\t\t}'\n    });\n  },\n  getOverlayMaterial: function getOverlayMaterial() {\n    return new _three.ShaderMaterial({\n      uniforms: {\n        maskTexture: {\n          value: null\n        },\n        edgeTexture1: {\n          value: null\n        },\n        edgeTexture2: {\n          value: null\n        },\n        patternTexture: {\n          value: null\n        },\n        edgeStrength: {\n          value: 1.0\n        },\n        edgeGlow: {\n          value: 1.0\n        },\n        usePatternTexture: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform sampler2D edgeTexture1;\\\n\t\t\t\tuniform sampler2D edgeTexture2;\\\n\t\t\t\tuniform sampler2D patternTexture;\\\n\t\t\t\tuniform float edgeStrength;\\\n\t\t\t\tuniform float edgeGlow;\\\n\t\t\t\tuniform bool usePatternTexture;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\\\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\n\t\t\t\t\tif(usePatternTexture)\\\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\n\t\t\t\t\tgl_FragColor = finalColor;\\\n\t\t\t\t}',\n      blending: _three.AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n  }\n});\nOutlinePass.BlurDirectionX = new _three.Vector2(1.0, 0.0);\nOutlinePass.BlurDirectionY = new _three.Vector2(0.0, 1.0);\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_stdlib$shaders$CopyShader","~$shadow.js","~$module$node_modules$three_stdlib$postprocessing$Pass"]],"~:properties",["^5",["fragmentShader","tempPulseColor2","updateTextureMatrix","renderScene","downSampleRatio","renderTargetMaskBuffer","patternTexture","depthTest","renderTargetBlurBuffer1","blending","maskBufferMaterial","_visibilityCache","visibleEdgeColor","textureMatrix","prototype","transparent","texSize","edgeStrength","side","needsSwap","renderTargetEdgeBuffer1","materialCopy","prepareMaskMaterial","kernelRadius","__esModule","overrideMaterial","dispose","changeVisibilityOfNonSelectedObjects","renderTargetDepthBuffer","enabled","defines","tempPulseColor1","overlayMaterial","OutlinePass","hiddenEdgeColor","vertexShader","pulsePeriod","name","getEdgeDetectionMaterial","usePatternTexture","value","edgeTexture1","visible","fsQuad","oldClearAlpha","direction","edgeDetectionMaterial","getOverlayMaterial","cameraNearFar","magFilter","renderTargetBlurBuffer2","copyUniforms","changeVisibilityOfSelectedObjects","autoClear","edgeTexture2","BlurDirectionX","getPrepareMaskMaterial","render","_oldClearColor","setSize","depthPacking","BlurDirectionY","depthWrite","selectedObjects","maskTexture","depthMaterial","colorTexture","generateMipmaps","separableBlurMaterial2","edgeGlow","uniforms","minFilter","getSeperableBlurMaterial","background","color","MAX_RADIUS","renderTargetMaskDownSampleBuffer","separableBlurMaterial1","renderTargetEdgeBuffer2","renderCamera","format","constructor","resolution","depthTexture","material","edgeThickness"]],"~:compiled-at",1630917515498,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$postprocessing$OutlinePass.js\",\n\"lineCount\":29,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/postprocessing/OutlinePass.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$postprocessing$OutlinePass\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.OutlinePass = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _Pass = require(\\\"./Pass.js\\\");\\n\\nvar _CopyShader = require(\\\"../shaders/CopyShader.js\\\");\\n\\nvar OutlinePass = function OutlinePass(resolution, scene, camera, selectedObjects) {\\n  this.renderScene = scene;\\n  this.renderCamera = camera;\\n  this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\\n  this.visibleEdgeColor = new _three.Color(1, 1, 1);\\n  this.hiddenEdgeColor = new _three.Color(0.1, 0.04, 0.02);\\n  this.edgeGlow = 0.0;\\n  this.usePatternTexture = false;\\n  this.edgeThickness = 1.0;\\n  this.edgeStrength = 3.0;\\n  this.downSampleRatio = 2;\\n  this.pulsePeriod = 0;\\n  this._visibilityCache = new Map();\\n  this.resolution = resolution !== undefined ? new _three.Vector2(resolution.x, resolution.y) : new _three.Vector2(256, 256);\\n  var pars = {\\n    minFilter: _three.LinearFilter,\\n    magFilter: _three.LinearFilter,\\n    format: _three.RGBAFormat\\n  };\\n  var resx = Math.round(this.resolution.x / this.downSampleRatio);\\n  var resy = Math.round(this.resolution.y / this.downSampleRatio);\\n  this.maskBufferMaterial = new _three.MeshBasicMaterial({\\n    color: 0xffffff\\n  });\\n  this.maskBufferMaterial.side = _three.DoubleSide;\\n  this.renderTargetMaskBuffer = new _three.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\\n  this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\\n  this.renderTargetMaskBuffer.texture.generateMipmaps = false;\\n  this.depthMaterial = new _three.MeshDepthMaterial();\\n  this.depthMaterial.side = _three.DoubleSide;\\n  this.depthMaterial.depthPacking = _three.RGBADepthPacking;\\n  this.depthMaterial.blending = _three.NoBlending;\\n  this.prepareMaskMaterial = this.getPrepareMaskMaterial();\\n  this.prepareMaskMaterial.side = _three.DoubleSide;\\n  this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\\n  this.renderTargetDepthBuffer = new _three.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\\n  this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\\n  this.renderTargetDepthBuffer.texture.generateMipmaps = false;\\n  this.renderTargetMaskDownSampleBuffer = new _three.WebGLRenderTarget(resx, resy, pars);\\n  this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\\n  this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\\n  this.renderTargetBlurBuffer1 = new _three.WebGLRenderTarget(resx, resy, pars);\\n  this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\\n  this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\\n  this.renderTargetBlurBuffer2 = new _three.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\\n  this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\\n  this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\\n  this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\\n  this.renderTargetEdgeBuffer1 = new _three.WebGLRenderTarget(resx, resy, pars);\\n  this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\\n  this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\\n  this.renderTargetEdgeBuffer2 = new _three.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\\n  this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\\n  this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\\n  var MAX_EDGE_THICKNESS = 4;\\n  var MAX_EDGE_GLOW = 4;\\n  this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\\n  this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\\n  this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\\n  this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\\n  this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\\n  this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\\n\\n  this.overlayMaterial = this.getOverlayMaterial(); // copy material\\n\\n  if (_CopyShader.CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\\n  var copyShader = _CopyShader.CopyShader;\\n  this.copyUniforms = _three.UniformsUtils.clone(copyShader.uniforms);\\n  this.copyUniforms['opacity'].value = 1.0;\\n  this.materialCopy = new _three.ShaderMaterial({\\n    uniforms: this.copyUniforms,\\n    vertexShader: copyShader.vertexShader,\\n    fragmentShader: copyShader.fragmentShader,\\n    blending: _three.NoBlending,\\n    depthTest: false,\\n    depthWrite: false,\\n    transparent: true\\n  });\\n  this.enabled = true;\\n  this.needsSwap = false;\\n  this._oldClearColor = new _three.Color();\\n  this.oldClearAlpha = 1;\\n  this.fsQuad = new _Pass.FullScreenQuad(null);\\n  this.tempPulseColor1 = new _three.Color();\\n  this.tempPulseColor2 = new _three.Color();\\n  this.textureMatrix = new _three.Matrix4();\\n\\n  function replaceDepthToViewZ(string, camera) {\\n    var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\\n    return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\\n  }\\n};\\n\\nexports.OutlinePass = OutlinePass;\\nOutlinePass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {\\n  constructor: OutlinePass,\\n  dispose: function dispose() {\\n    this.renderTargetMaskBuffer.dispose();\\n    this.renderTargetDepthBuffer.dispose();\\n    this.renderTargetMaskDownSampleBuffer.dispose();\\n    this.renderTargetBlurBuffer1.dispose();\\n    this.renderTargetBlurBuffer2.dispose();\\n    this.renderTargetEdgeBuffer1.dispose();\\n    this.renderTargetEdgeBuffer2.dispose();\\n  },\\n  setSize: function setSize(width, height) {\\n    this.renderTargetMaskBuffer.setSize(width, height);\\n    var resx = Math.round(width / this.downSampleRatio);\\n    var resy = Math.round(height / this.downSampleRatio);\\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\\n    resx = Math.round(resx / 2);\\n    resy = Math.round(resy / 2);\\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\\n  },\\n  changeVisibilityOfSelectedObjects: function changeVisibilityOfSelectedObjects(bVisible) {\\n    var cache = this._visibilityCache;\\n\\n    function gatherSelectedMeshesCallBack(object) {\\n      if (object.isMesh) {\\n        if (bVisible === true) {\\n          object.visible = cache.get(object);\\n        } else {\\n          cache.set(object, object.visible);\\n          object.visible = bVisible;\\n        }\\n      }\\n    }\\n\\n    for (var i = 0; i < this.selectedObjects.length; i++) {\\n      var selectedObject = this.selectedObjects[i];\\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\\n    }\\n  },\\n  changeVisibilityOfNonSelectedObjects: function changeVisibilityOfNonSelectedObjects(bVisible) {\\n    var cache = this._visibilityCache;\\n    var selectedMeshes = [];\\n\\n    function gatherSelectedMeshesCallBack(object) {\\n      if (object.isMesh) selectedMeshes.push(object);\\n    }\\n\\n    for (var i = 0; i < this.selectedObjects.length; i++) {\\n      var selectedObject = this.selectedObjects[i];\\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\\n    }\\n\\n    function VisibilityChangeCallBack(object) {\\n      if (object.isMesh || object.isSprite) {\\n        // only meshes and sprites are supported by OutlinePass\\n        var bFound = false;\\n\\n        for (var _i = 0; _i < selectedMeshes.length; _i++) {\\n          var selectedObjectId = selectedMeshes[_i].id;\\n\\n          if (selectedObjectId === object.id) {\\n            bFound = true;\\n            break;\\n          }\\n        }\\n\\n        if (bFound === false) {\\n          var visibility = object.visible;\\n\\n          if (bVisible === false || cache.get(object) === true) {\\n            object.visible = bVisible;\\n          }\\n\\n          cache.set(object, visibility);\\n        }\\n      } else if (object.isPoints || object.isLine) {\\n        // the visibilty of points and lines is always set to false in order to\\n        // not affect the outline computation\\n        if (bVisible === true) {\\n          object.visible = cache.get(object); // restore\\n        } else {\\n          cache.set(object, object.visible);\\n          object.visible = bVisible;\\n        }\\n      }\\n    }\\n\\n    this.renderScene.traverse(VisibilityChangeCallBack);\\n  },\\n  updateTextureMatrix: function updateTextureMatrix() {\\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\\n  },\\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\\n    if (this.selectedObjects.length > 0) {\\n      renderer.getClearColor(this._oldClearColor);\\n      this.oldClearAlpha = renderer.getClearAlpha();\\n      var oldAutoClear = renderer.autoClear;\\n      renderer.autoClear = false;\\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\\n      renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\\n\\n      this.changeVisibilityOfSelectedObjects(false);\\n      var currentBackground = this.renderScene.background;\\n      this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\\n\\n      this.renderScene.overrideMaterial = this.depthMaterial;\\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\\n      renderer.clear();\\n      renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\\n\\n      this.changeVisibilityOfSelectedObjects(true);\\n\\n      this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\\n\\n\\n      this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\\n\\n      this.changeVisibilityOfNonSelectedObjects(false);\\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\\n      renderer.clear();\\n      renderer.render(this.renderScene, this.renderCamera);\\n      this.renderScene.overrideMaterial = null;\\n      this.changeVisibilityOfNonSelectedObjects(true);\\n\\n      this._visibilityCache.clear();\\n\\n      this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\\n\\n      this.fsQuad.material = this.materialCopy;\\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\\n      renderer.clear();\\n      this.fsQuad.render(renderer);\\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\\n\\n      if (this.pulsePeriod > 0) {\\n        var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\\n        this.tempPulseColor1.multiplyScalar(scalar);\\n        this.tempPulseColor2.multiplyScalar(scalar);\\n      } // 3. Apply Edge Detection Pass\\n\\n\\n      this.fsQuad.material = this.edgeDetectionMaterial;\\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\\n      renderer.clear();\\n      this.fsQuad.render(renderer); // 4. Apply Blur on Half res\\n\\n      this.fsQuad.material = this.separableBlurMaterial1;\\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionX;\\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\\n      renderer.clear();\\n      this.fsQuad.render(renderer);\\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\\n      this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionY;\\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\\n      renderer.clear();\\n      this.fsQuad.render(renderer); // Apply Blur on quarter res\\n\\n      this.fsQuad.material = this.separableBlurMaterial2;\\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionX;\\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\\n      renderer.clear();\\n      this.fsQuad.render(renderer);\\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\\n      this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionY;\\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\\n      renderer.clear();\\n      this.fsQuad.render(renderer); // Blend it additively over the input texture\\n\\n      this.fsQuad.material = this.overlayMaterial;\\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\\n      renderer.setRenderTarget(readBuffer);\\n      this.fsQuad.render(renderer);\\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\\n      renderer.autoClear = oldAutoClear;\\n    }\\n\\n    if (this.renderToScreen) {\\n      this.fsQuad.material = this.materialCopy;\\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture;\\n      renderer.setRenderTarget(null);\\n      this.fsQuad.render(renderer);\\n    }\\n  },\\n  getPrepareMaskMaterial: function getPrepareMaskMaterial() {\\n    return new _three.ShaderMaterial({\\n      uniforms: {\\n        depthTexture: {\\n          value: null\\n        },\\n        cameraNearFar: {\\n          value: new _three.Vector2(0.5, 0.5)\\n        },\\n        textureMatrix: {\\n          value: null\\n        }\\n      },\\n      vertexShader: ['#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', 'varying vec4 projTexCoord;', 'varying vec4 vPosition;', 'uniform mat4 textureMatrix;', 'void main() {', '\\t#include <skinbase_vertex>', '\\t#include <begin_vertex>', '\\t#include <morphtarget_vertex>', '\\t#include <skinning_vertex>', '\\t#include <project_vertex>', '\\tvPosition = mvPosition;', '\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\\tprojTexCoord = textureMatrix * worldPosition;', '}'].join('\\\\n'),\\n      fragmentShader: ['#include <packing>', 'varying vec4 vPosition;', 'varying vec4 projTexCoord;', 'uniform sampler2D depthTexture;', 'uniform vec2 cameraNearFar;', 'void main() {', '\\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));', '\\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );', '\\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;', '\\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);', '}'].join('\\\\n')\\n    });\\n  },\\n  getEdgeDetectionMaterial: function getEdgeDetectionMaterial() {\\n    return new _three.ShaderMaterial({\\n      uniforms: {\\n        maskTexture: {\\n          value: null\\n        },\\n        texSize: {\\n          value: new _three.Vector2(0.5, 0.5)\\n        },\\n        visibleEdgeColor: {\\n          value: new _three.Vector3(1.0, 1.0, 1.0)\\n        },\\n        hiddenEdgeColor: {\\n          value: new _three.Vector3(1.0, 1.0, 1.0)\\n        }\\n      },\\n      vertexShader: 'varying vec2 vUv;\\\\n\\\\\\n\\t\\t\\t\\tvoid main() {\\\\n\\\\\\n\\t\\t\\t\\t\\tvUv = uv;\\\\n\\\\\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\\\n\\t\\t\\t\\t}',\\n      fragmentShader: 'varying vec2 vUv;\\\\\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\\\\\n\\t\\t\\t\\tuniform vec2 texSize;\\\\\\n\\t\\t\\t\\tuniform vec3 visibleEdgeColor;\\\\\\n\\t\\t\\t\\tuniform vec3 hiddenEdgeColor;\\\\\\n\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\tvoid main() {\\\\n\\\\\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\\\\\n\\t\\t\\t\\t\\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\\\\n\\t\\t\\t\\t\\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\\\\n\\t\\t\\t\\t\\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\\\\n\\t\\t\\t\\t\\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\\\\n\\t\\t\\t\\t\\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\\\\n\\t\\t\\t\\t\\tfloat diff1 = (c1.r - c2.r)*0.5;\\\\\\n\\t\\t\\t\\t\\tfloat diff2 = (c3.r - c4.r)*0.5;\\\\\\n\\t\\t\\t\\t\\tfloat d = length( vec2(diff1, diff2) );\\\\\\n\\t\\t\\t\\t\\tfloat a1 = min(c1.g, c2.g);\\\\\\n\\t\\t\\t\\t\\tfloat a2 = min(c3.g, c4.g);\\\\\\n\\t\\t\\t\\t\\tfloat visibilityFactor = min(a1, a2);\\\\\\n\\t\\t\\t\\t\\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\\\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\\\\n\\t\\t\\t\\t}'\\n    });\\n  },\\n  getSeperableBlurMaterial: function getSeperableBlurMaterial(maxRadius) {\\n    return new _three.ShaderMaterial({\\n      defines: {\\n        MAX_RADIUS: maxRadius\\n      },\\n      uniforms: {\\n        colorTexture: {\\n          value: null\\n        },\\n        texSize: {\\n          value: new _three.Vector2(0.5, 0.5)\\n        },\\n        direction: {\\n          value: new _three.Vector2(0.5, 0.5)\\n        },\\n        kernelRadius: {\\n          value: 1.0\\n        }\\n      },\\n      vertexShader: 'varying vec2 vUv;\\\\n\\\\\\n\\t\\t\\t\\tvoid main() {\\\\n\\\\\\n\\t\\t\\t\\t\\tvUv = uv;\\\\n\\\\\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\\\n\\t\\t\\t\\t}',\\n      fragmentShader: '#include <common>\\\\\\n\\t\\t\\t\\tvarying vec2 vUv;\\\\\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\\\\\n\\t\\t\\t\\tuniform vec2 texSize;\\\\\\n\\t\\t\\t\\tuniform vec2 direction;\\\\\\n\\t\\t\\t\\tuniform float kernelRadius;\\\\\\n\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\\\\\n\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\\\\n\\t\\t\\t\\t}\\\\\\n\\t\\t\\t\\tvoid main() {\\\\\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\\\\\n\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\\\\n\\t\\t\\t\\t\\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\\\\\n\\t\\t\\t\\t\\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\\\\n\\t\\t\\t\\t\\tvec2 uvOffset = delta;\\\\\\n\\t\\t\\t\\t\\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\\\\n\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\\\\n\\t\\t\\t\\t\\t\\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\\\\\n\\t\\t\\t\\t\\t\\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\\\\\n\\t\\t\\t\\t\\t\\tdiffuseSum += ((sample1 + sample2) * w);\\\\\\n\\t\\t\\t\\t\\t\\tweightSum += (2.0 * w);\\\\\\n\\t\\t\\t\\t\\t\\tuvOffset += delta;\\\\\\n\\t\\t\\t\\t\\t}\\\\\\n\\t\\t\\t\\t\\tgl_FragColor = diffuseSum/weightSum;\\\\\\n\\t\\t\\t\\t}'\\n    });\\n  },\\n  getOverlayMaterial: function getOverlayMaterial() {\\n    return new _three.ShaderMaterial({\\n      uniforms: {\\n        maskTexture: {\\n          value: null\\n        },\\n        edgeTexture1: {\\n          value: null\\n        },\\n        edgeTexture2: {\\n          value: null\\n        },\\n        patternTexture: {\\n          value: null\\n        },\\n        edgeStrength: {\\n          value: 1.0\\n        },\\n        edgeGlow: {\\n          value: 1.0\\n        },\\n        usePatternTexture: {\\n          value: 0.0\\n        }\\n      },\\n      vertexShader: 'varying vec2 vUv;\\\\n\\\\\\n\\t\\t\\t\\tvoid main() {\\\\n\\\\\\n\\t\\t\\t\\t\\tvUv = uv;\\\\n\\\\\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\\\n\\t\\t\\t\\t}',\\n      fragmentShader: 'varying vec2 vUv;\\\\\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\\\\\n\\t\\t\\t\\tuniform sampler2D edgeTexture1;\\\\\\n\\t\\t\\t\\tuniform sampler2D edgeTexture2;\\\\\\n\\t\\t\\t\\tuniform sampler2D patternTexture;\\\\\\n\\t\\t\\t\\tuniform float edgeStrength;\\\\\\n\\t\\t\\t\\tuniform float edgeGlow;\\\\\\n\\t\\t\\t\\tuniform bool usePatternTexture;\\\\\\n\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\tvoid main() {\\\\\\n\\t\\t\\t\\t\\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\\\\n\\t\\t\\t\\t\\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\\\\n\\t\\t\\t\\t\\tvec4 maskColor = texture2D(maskTexture, vUv);\\\\\\n\\t\\t\\t\\t\\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\\\\n\\t\\t\\t\\t\\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\\\\n\\t\\t\\t\\t\\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\\\\n\\t\\t\\t\\t\\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\\\\n\\t\\t\\t\\t\\tif(usePatternTexture)\\\\\\n\\t\\t\\t\\t\\t\\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\\\\n\\t\\t\\t\\t\\tgl_FragColor = finalColor;\\\\\\n\\t\\t\\t\\t}',\\n      blending: _three.AdditiveBlending,\\n      depthTest: false,\\n      depthWrite: false,\\n      transparent: true\\n    });\\n  }\\n});\\nOutlinePass.BlurDirectionX = new _three.Vector2(1.0, 0.0);\\nOutlinePass.BlurDirectionY = new _three.Vector2(0.0, 1.0);\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"OutlinePass\",\"_three\",\"_Pass\",\"_CopyShader\",\"resolution\",\"scene\",\"camera\",\"selectedObjects\",\"renderScene\",\"renderCamera\",\"undefined\",\"visibleEdgeColor\",\"Color\",\"hiddenEdgeColor\",\"edgeGlow\",\"usePatternTexture\",\"edgeThickness\",\"edgeStrength\",\"downSampleRatio\",\"pulsePeriod\",\"_visibilityCache\",\"Map\",\"Vector2\",\"x\",\"y\",\"pars\",\"minFilter\",\"LinearFilter\",\"magFilter\",\"format\",\"RGBAFormat\",\"resx\",\"Math\",\"round\",\"resy\",\"maskBufferMaterial\",\"MeshBasicMaterial\",\"color\",\"side\",\"DoubleSide\",\"renderTargetMaskBuffer\",\"WebGLRenderTarget\",\"texture\",\"name\",\"generateMipmaps\",\"depthMaterial\",\"MeshDepthMaterial\",\"depthPacking\",\"RGBADepthPacking\",\"blending\",\"NoBlending\",\"prepareMaskMaterial\",\"getPrepareMaskMaterial\",\"fragmentShader\",\"replace\",\"isPerspectiveCamera\",\"type\",\"renderTargetDepthBuffer\",\"renderTargetMaskDownSampleBuffer\",\"renderTargetBlurBuffer1\",\"renderTargetBlurBuffer2\",\"edgeDetectionMaterial\",\"getEdgeDetectionMaterial\",\"renderTargetEdgeBuffer1\",\"renderTargetEdgeBuffer2\",\"separableBlurMaterial1\",\"getSeperableBlurMaterial\",\"MAX_EDGE_THICKNESS\",\"uniforms\",\"set\",\"separableBlurMaterial2\",\"MAX_EDGE_GLOW\",\"overlayMaterial\",\"getOverlayMaterial\",\"CopyShader\",\"console\",\"error\",\"copyShader\",\"copyUniforms\",\"UniformsUtils\",\"clone\",\"materialCopy\",\"ShaderMaterial\",\"vertexShader\",\"depthTest\",\"depthWrite\",\"transparent\",\"enabled\",\"needsSwap\",\"_oldClearColor\",\"oldClearAlpha\",\"fsQuad\",\"FullScreenQuad\",\"tempPulseColor1\",\"tempPulseColor2\",\"textureMatrix\",\"Matrix4\",\"prototype\",\"assign\",\"create\",\"Pass\",\"constructor\",\"dispose\",\"setSize\",\"width\",\"height\",\"changeVisibilityOfSelectedObjects\",\"bVisible\",\"gatherSelectedMeshesCallBack\",\"object\",\"isMesh\",\"visible\",\"cache\",\"get\",\"i\",\"length\",\"selectedObject\",\"traverse\",\"changeVisibilityOfNonSelectedObjects\",\"selectedMeshes\",\"push\",\"VisibilityChangeCallBack\",\"isSprite\",\"bFound\",\"_i\",\"id\",\"visibility\",\"isPoints\",\"isLine\",\"updateTextureMatrix\",\"multiply\",\"projectionMatrix\",\"matrixWorldInverse\",\"render\",\"renderer\",\"writeBuffer\",\"readBuffer\",\"deltaTime\",\"maskActive\",\"getClearColor\",\"getClearAlpha\",\"oldAutoClear\",\"autoClear\",\"state\",\"buffers\",\"stencil\",\"setTest\",\"setClearColor\",\"currentBackground\",\"background\",\"overrideMaterial\",\"setRenderTarget\",\"clear\",\"near\",\"far\",\"material\",\"copy\",\"scalar\",\"cos\",\"performance\",\"now\",\"multiplyScalar\",\"BlurDirectionX\",\"BlurDirectionY\",\"patternTexture\",\"renderToScreen\",\"depthTexture\",\"cameraNearFar\",\"maskTexture\",\"texSize\",\"Vector3\",\"maxRadius\",\"defines\",\"MAX_RADIUS\",\"colorTexture\",\"direction\",\"kernelRadius\",\"edgeTexture1\",\"edgeTexture2\",\"AdditiveBlending\"]\n}\n"]