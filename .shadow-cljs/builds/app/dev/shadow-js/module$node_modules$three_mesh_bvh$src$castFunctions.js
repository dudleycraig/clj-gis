["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-mesh-bvh/src/castFunctions.js"],"~:js","shadow$provide.module$node_modules$three_mesh_bvh$src$castFunctions=function(global,require,module,exports){function raycast(nodeIndex32,mesh,geometry,raycaster,ray,intersects){var nodeIndex16=2*nodeIndex32,float32Array=_float32Array,uint16Array=_uint16Array,uint32Array=_uint32Array;65535===uint16Array[nodeIndex16+15]?(float32Array=uint32Array[nodeIndex32+6],nodeIndex32=uint16Array[nodeIndex16+14],(0,_RayIntersectTriUtilities.intersectTris)(mesh,geometry,raycaster,ray,float32Array,nodeIndex32,intersects)):\n(nodeIndex16=nodeIndex32+8,intersectRay(nodeIndex16,float32Array,ray,boxIntersection)&&raycast(nodeIndex16,mesh,geometry,raycaster,ray,intersects),nodeIndex32=uint32Array[nodeIndex32+6],intersectRay(nodeIndex32,float32Array,ray,boxIntersection)&&raycast(nodeIndex32,mesh,geometry,raycaster,ray,intersects))}function raycastFirst(nodeIndex32,mesh,geometry,raycaster,ray){var nodeIndex16=2*nodeIndex32,float32Array=_float32Array,uint16Array=_uint16Array,uint32Array=_uint32Array;if(65535===uint16Array[nodeIndex16+\n15])return float32Array=uint32Array[nodeIndex32+6],nodeIndex16=uint16Array[nodeIndex16+14],(0,_RayIntersectTriUtilities.intersectClosestTri)(mesh,geometry,raycaster,ray,float32Array,nodeIndex16);nodeIndex16=uint32Array[nodeIndex32+7];var xyzAxis=xyzFields[nodeIndex16];uint16Array=0<=ray.direction[xyzAxis];if(uint16Array){var c1=nodeIndex32+8;nodeIndex32=uint32Array[nodeIndex32+6]}else c1=uint32Array[nodeIndex32+6],nodeIndex32+=8;if(uint32Array=intersectRay(c1,float32Array,ray,boxIntersection)?raycastFirst(c1,\nmesh,geometry,raycaster,ray):null)if(xyzAxis=uint32Array.localPoint[xyzAxis],uint16Array?xyzAxis<=float32Array[nodeIndex32+nodeIndex16]:xyzAxis>=float32Array[nodeIndex32+nodeIndex16+3])return uint32Array;mesh=intersectRay(nodeIndex32,float32Array,ray,boxIntersection)?raycastFirst(nodeIndex32,mesh,geometry,raycaster,ray):null;return uint32Array&&mesh?uint32Array.distance<=mesh.distance?uint32Array:mesh:uint32Array||mesh||null}function intersectRay(nodeIndex32,array,ray,target){(0,_BufferNodeUtils.arrayToBox)(nodeIndex32,\narray,boundingBox);return ray.intersectBox(boundingBox,target)}function setBuffer(buffer){_prevBuffer&&bufferStack.push(_prevBuffer);_prevBuffer=buffer;_float32Array=new Float32Array(buffer);_uint16Array=new Uint16Array(buffer);_uint32Array=new Uint32Array(buffer)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.raycast=raycast;exports.raycastFirst=raycastFirst;exports.setBuffer=setBuffer;exports.clearBuffer=function(){_uint32Array=_uint16Array=_float32Array=_prevBuffer=null;bufferStack.length&&\nsetBuffer(bufferStack.pop())};exports.intersectsGeometry=exports.shapecast=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_RayIntersectTriUtilities=require(\"module$node_modules$three_mesh_bvh$src$Utils$RayIntersectTriUtilities\"),_BufferNodeUtils=require(\"module$node_modules$three_mesh_bvh$src$Utils$BufferNodeUtils\"),_OrientedBox=require(\"module$node_modules$three_mesh_bvh$src$Utils$OrientedBox\"),_TriangleUtils=require(\"module$node_modules$three_mesh_bvh$src$Utils$TriangleUtils\"),\n_SeparatingAxisTriangle=require(\"module$node_modules$three_mesh_bvh$src$Utils$SeparatingAxisTriangle\"),_Constants=require(\"module$node_modules$three_mesh_bvh$src$Constants\"),boundingBox=new _three.Box3,boxIntersection=new _three.Vector3,xyzFields=[\"x\",\"y\",\"z\"];global=function(){var _box1=new _three.Box3,_box2=new _three.Box3;return function shapecast(nodeIndex32$jscomp$0,geometry,intersectsBoundsFunc,intersectsRangeFunc){function getLeftOffset(nodeIndex32){for(var nodeIndex16=2*nodeIndex32,uint16Array=\n_uint16Array,uint32Array=_uint32Array;65535!==uint16Array[nodeIndex16+15];)nodeIndex32+=8,nodeIndex16=2*nodeIndex32;return uint32Array[nodeIndex32+6]}function getRightEndOffset(nodeIndex32){for(var nodeIndex16=2*nodeIndex32,uint16Array=_uint16Array,uint32Array=_uint32Array;65535!==uint16Array[nodeIndex16+15];)nodeIndex32=uint32Array[nodeIndex32+6],nodeIndex16=2*nodeIndex32;return uint32Array[nodeIndex32+6]+uint16Array[nodeIndex16+14]}var nodeScoreFunc=4<arguments.length&&void 0!==arguments[4]?arguments[4]:\nnull,nodeIndexByteOffset=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0,depth=6<arguments.length&&void 0!==arguments[6]?arguments[6]:0,nodeIndex16$jscomp$0=2*nodeIndex32$jscomp$0,float32Array=_float32Array,uint16Array$jscomp$0=_uint16Array,uint32Array$jscomp$0=_uint32Array;if(65535===uint16Array$jscomp$0[nodeIndex16$jscomp$0+15])return intersectsRangeFunc(uint32Array$jscomp$0[nodeIndex32$jscomp$0+6],uint16Array$jscomp$0[nodeIndex16$jscomp$0+14],!1,depth,nodeIndexByteOffset+nodeIndex32$jscomp$0);\nvar left=nodeIndex32$jscomp$0+8,right=uint32Array$jscomp$0[nodeIndex32$jscomp$0+6];nodeIndex16$jscomp$0=left;uint32Array$jscomp$0=right;if(nodeScoreFunc){var box1=_box1;var box2=_box2;(0,_BufferNodeUtils.arrayToBox)(nodeIndex16$jscomp$0,float32Array,box1);(0,_BufferNodeUtils.arrayToBox)(uint32Array$jscomp$0,float32Array,box2);var score1=nodeScoreFunc(box1);var score2=nodeScoreFunc(box2);score2<score1&&(nodeIndex16$jscomp$0=right,uint32Array$jscomp$0=left,box1=score1,score1=score2,score2=box1,box1=\nbox2)}box1||(box1=_box1,(0,_BufferNodeUtils.arrayToBox)(nodeIndex16$jscomp$0,float32Array,box1));score1=intersectsBoundsFunc(box1,65535===uint16Array$jscomp$0[2*nodeIndex16$jscomp$0+15],score1,depth+1,nodeIndexByteOffset+nodeIndex16$jscomp$0);score1===_Constants.CONTAINED?(score1=getLeftOffset(nodeIndex16$jscomp$0),box1=getRightEndOffset(nodeIndex16$jscomp$0),nodeIndex16$jscomp$0=intersectsRangeFunc(score1,box1-score1,!0,depth+1,nodeIndexByteOffset+nodeIndex16$jscomp$0)):nodeIndex16$jscomp$0=score1&&\nshapecast(nodeIndex16$jscomp$0,geometry,intersectsBoundsFunc,intersectsRangeFunc,nodeScoreFunc,nodeIndexByteOffset,depth+1);if(nodeIndex16$jscomp$0)return!0;box2=_box2;(0,_BufferNodeUtils.arrayToBox)(uint32Array$jscomp$0,float32Array,box2);float32Array=intersectsBoundsFunc(box2,65535===uint16Array$jscomp$0[2*uint32Array$jscomp$0+15],score2,depth+1,nodeIndexByteOffset+uint32Array$jscomp$0);float32Array===_Constants.CONTAINED?(nodeScoreFunc=getLeftOffset(uint32Array$jscomp$0),float32Array=getRightEndOffset(uint32Array$jscomp$0),\nnodeIndexByteOffset=intersectsRangeFunc(nodeScoreFunc,float32Array-nodeScoreFunc,!0,depth+1,nodeIndexByteOffset+uint32Array$jscomp$0)):nodeIndexByteOffset=float32Array&&shapecast(uint32Array$jscomp$0,geometry,intersectsBoundsFunc,intersectsRangeFunc,nodeScoreFunc,nodeIndexByteOffset,depth+1);return nodeIndexByteOffset?!0:!1}}();exports.shapecast=global;global=function(){var triangle=new _SeparatingAxisTriangle.SeparatingAxisTriangle,triangle2=new _SeparatingAxisTriangle.SeparatingAxisTriangle,cachedMesh=\nnew _three.Mesh,invertedMat=new _three.Matrix4,obb=new _OrientedBox.OrientedBox,obb2=new _OrientedBox.OrientedBox;return function intersectsGeometry(nodeIndex32,mesh,geometry,otherGeometry,geometryToBvh){var cachedObb=5<arguments.length&&void 0!==arguments[5]?arguments[5]:null,nodeIndex16=2*nodeIndex32,float32Array=_float32Array,uint16Array=_uint16Array,uint32Array=_uint32Array;null===cachedObb&&(otherGeometry.boundingBox||otherGeometry.computeBoundingBox(),obb.set(otherGeometry.boundingBox.min,otherGeometry.boundingBox.max,\ngeometryToBvh),cachedObb=obb);if(65535===uint16Array[nodeIndex16+15]){var thisIndex=geometry.index,thisPos=geometry.attributes.position;cachedObb=otherGeometry.index;var pos=otherGeometry.attributes.position,offset=uint32Array[nodeIndex32+6],count=uint16Array[nodeIndex16+14];invertedMat.copy(geometryToBvh).invert();if(otherGeometry.boundsTree)return(0,_BufferNodeUtils.arrayToBox)(nodeIndex32,float32Array,obb2),obb2.matrix.copy(invertedMat),obb2.needsUpdate=!0,cachedMesh.geometry=otherGeometry,cachedObb=\notherGeometry.boundsTree.shapecast(cachedMesh,{intersectsBounds:function(box){return obb2.intersectsBox(box)},intersectsTriangle:function(tri){tri.a.applyMatrix4(geometryToBvh);tri.b.applyMatrix4(geometryToBvh);tri.c.applyMatrix4(geometryToBvh);tri.needsUpdate=!0;for(var i=3*offset,l=3*(count+offset);i<l;i+=3)if((0,_TriangleUtils.setTriangle)(triangle2,i,thisIndex,thisPos),triangle2.needsUpdate=!0,tri.intersectsTriangle(triangle2))return!0;return!1}}),cachedMesh.geometry=null,cachedObb;float32Array=\n3*offset;for(uint32Array=count+3*offset;float32Array<uint32Array;float32Array+=3)for((0,_TriangleUtils.setTriangle)(triangle,float32Array,thisIndex,thisPos),triangle.a.applyMatrix4(invertedMat),triangle.b.applyMatrix4(invertedMat),triangle.c.applyMatrix4(invertedMat),triangle.needsUpdate=!0,nodeIndex16=0,uint16Array=cachedObb.count;nodeIndex16<uint16Array;nodeIndex16+=3)if((0,_TriangleUtils.setTriangle)(triangle2,nodeIndex16,cachedObb,pos),triangle2.needsUpdate=!0,triangle.intersectsTriangle(triangle2))return!0}else{pos=\nnodeIndex32+8;uint32Array=uint32Array[nodeIndex32+6];(0,_BufferNodeUtils.arrayToBox)(pos,float32Array,boundingBox);if(cachedObb.intersectsBox(boundingBox)&&intersectsGeometry(pos,mesh,geometry,otherGeometry,geometryToBvh,cachedObb))return!0;(0,_BufferNodeUtils.arrayToBox)(uint32Array,float32Array,boundingBox);return cachedObb.intersectsBox(boundingBox)&&intersectsGeometry(uint32Array,mesh,geometry,otherGeometry,geometryToBvh,cachedObb)?!0:!1}}}();exports.intersectsGeometry=global;var bufferStack=\n[],_prevBuffer,_float32Array,_uint16Array,_uint32Array}","~:source","shadow$provide[\"module$node_modules$three_mesh_bvh$src$castFunctions\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.raycast = raycast;\nexports.raycastFirst = raycastFirst;\nexports.setBuffer = setBuffer;\nexports.clearBuffer = clearBuffer;\nexports.intersectsGeometry = exports.shapecast = void 0;\n\nvar _three = require(\"three\");\n\nvar _RayIntersectTriUtilities = require(\"./Utils/RayIntersectTriUtilities.js\");\n\nvar _BufferNodeUtils = require(\"./Utils/BufferNodeUtils.js\");\n\nvar _OrientedBox = require(\"./Utils/OrientedBox.js\");\n\nvar _TriangleUtils = require(\"./Utils/TriangleUtils.js\");\n\nvar _SeparatingAxisTriangle = require(\"./Utils/SeparatingAxisTriangle.js\");\n\nvar _Constants = require(\"./Constants.js\");\n\n// For speed and readability this script is processed to replace the macro-like calls\n// with inline buffer reads. See generate-cast-functions.js.\nvar boundingBox = new _three.Box3();\nvar boxIntersection = new _three.Vector3();\nvar xyzFields = ['x', 'y', 'z'];\n\nfunction IS_LEAF(n16, uint16Array) {\n  return uint16Array[n16 + 15] === 0xFFFF;\n}\n\nfunction OFFSET(n32, uint32Array) {\n  return uint32Array[n32 + 6];\n}\n\nfunction COUNT(n32, uint16Array) {\n  return uint16Array[n32 + 14];\n}\n\nfunction LEFT_NODE(n32) {\n  return n32 + 8;\n}\n\nfunction RIGHT_NODE(n32, uint32Array) {\n  return uint32Array[n32 + 6];\n}\n\nfunction SPLIT_AXIS(n32, uint32Array) {\n  return uint32Array[n32 + 7];\n}\n\nfunction BOUNDING_DATA_INDEX(n32) {\n  return n32;\n}\n\nfunction raycast(nodeIndex32, mesh, geometry, raycaster, ray, intersects) {\n  var nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n  if (isLeaf) {\n    var offset = OFFSET(nodeIndex32, uint32Array);\n    var count = COUNT(nodeIndex16, uint16Array);\n    (0, _RayIntersectTriUtilities.intersectTris)(mesh, geometry, raycaster, ray, offset, count, intersects);\n  } else {\n    var leftIndex = LEFT_NODE(nodeIndex32);\n\n    if (intersectRay(leftIndex, float32Array, ray, boxIntersection)) {\n      raycast(leftIndex, mesh, geometry, raycaster, ray, intersects);\n    }\n\n    var rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);\n\n    if (intersectRay(rightIndex, float32Array, ray, boxIntersection)) {\n      raycast(rightIndex, mesh, geometry, raycaster, ray, intersects);\n    }\n  }\n}\n\nfunction raycastFirst(nodeIndex32, mesh, geometry, raycaster, ray) {\n  var nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n  if (isLeaf) {\n    var offset = OFFSET(nodeIndex32, uint32Array);\n    var count = COUNT(nodeIndex16, uint16Array);\n    return (0, _RayIntersectTriUtilities.intersectClosestTri)(mesh, geometry, raycaster, ray, offset, count);\n  } else {\n    // consider the position of the split plane with respect to the oncoming ray; whichever direction\n    // the ray is coming from, look for an intersection among that side of the tree first\n    var splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n    var xyzAxis = xyzFields[splitAxis];\n    var rayDir = ray.direction[xyzAxis];\n    var leftToRight = rayDir >= 0; // c1 is the child to check first\n\n    var c1, c2;\n\n    if (leftToRight) {\n      c1 = LEFT_NODE(nodeIndex32);\n      c2 = RIGHT_NODE(nodeIndex32, uint32Array);\n    } else {\n      c1 = RIGHT_NODE(nodeIndex32, uint32Array);\n      c2 = LEFT_NODE(nodeIndex32);\n    }\n\n    var c1Intersection = intersectRay(c1, float32Array, ray, boxIntersection);\n    var c1Result = c1Intersection ? raycastFirst(c1, mesh, geometry, raycaster, ray) : null; // if we got an intersection in the first node and it's closer than the second node's bounding\n    // box, we don't need to consider the second node because it couldn't possibly be a better result\n\n    if (c1Result) {\n      // check if the point is within the second bounds\n      var point = c1Result.localPoint[xyzAxis];\n      var isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : // min bounding data\n      point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n\n      if (isOutside) {\n        return c1Result;\n      }\n    } // either there was no intersection in the first node, or there could still be a closer\n    // intersection in the second, so check the second node and then take the better of the two\n\n\n    var c2Intersection = intersectRay(c2, float32Array, ray, boxIntersection);\n    var c2Result = c2Intersection ? raycastFirst(c2, mesh, geometry, raycaster, ray) : null;\n\n    if (c1Result && c2Result) {\n      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n    } else {\n      return c1Result || c2Result || null;\n    }\n  }\n}\n\nvar shapecast = function () {\n  var _box1 = new _three.Box3();\n\n  var _box2 = new _three.Box3();\n\n  return function shapecast(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc) {\n    var nodeScoreFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var nodeIndexByteOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var depth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n    // Define these inside the function so it has access to the local variables needed\n    // when converting to the buffer equivalents\n    function getLeftOffset(nodeIndex32) {\n      var nodeIndex16 = nodeIndex32 * 2,\n          uint16Array = _uint16Array,\n          uint32Array = _uint32Array; // traverse until we find a leaf\n\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        nodeIndex32 = LEFT_NODE(nodeIndex32);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n\n      return OFFSET(nodeIndex32, uint32Array);\n    }\n\n    function getRightEndOffset(nodeIndex32) {\n      var nodeIndex16 = nodeIndex32 * 2,\n          uint16Array = _uint16Array,\n          uint32Array = _uint32Array; // traverse until we find a leaf\n\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        // adjust offset to point to the right node\n        nodeIndex32 = RIGHT_NODE(nodeIndex32, uint32Array);\n        nodeIndex16 = nodeIndex32 * 2;\n      } // return the end offset of the triangle range\n\n\n      return OFFSET(nodeIndex32, uint32Array) + COUNT(nodeIndex16, uint16Array);\n    }\n\n    var nodeIndex16 = nodeIndex32 * 2,\n        float32Array = _float32Array,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n    var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n    if (isLeaf) {\n      var offset = OFFSET(nodeIndex32, uint32Array);\n      var count = COUNT(nodeIndex16, uint16Array);\n      return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32);\n    } else {\n      var left = LEFT_NODE(nodeIndex32);\n      var right = RIGHT_NODE(nodeIndex32, uint32Array);\n      var c1 = left;\n      var c2 = right;\n      var score1, score2;\n      var box1, box2;\n\n      if (nodeScoreFunc) {\n        box1 = _box1;\n        box2 = _box2; // bounding data is not offset\n\n        (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n        (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n        score1 = nodeScoreFunc(box1);\n        score2 = nodeScoreFunc(box2);\n\n        if (score2 < score1) {\n          c1 = right;\n          c2 = left;\n          var temp = score1;\n          score1 = score2;\n          score2 = temp;\n          box1 = box2; // box2 is always set before use below\n        }\n      } // Check box 1 intersection\n\n\n      if (!box1) {\n        box1 = _box1;\n        (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n      }\n\n      var isC1Leaf = IS_LEAF(c1 * 2, uint16Array);\n      var c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n      var c1StopTraversal;\n\n      if (c1Intersection === _Constants.CONTAINED) {\n        var _offset = getLeftOffset(c1);\n\n        var end = getRightEndOffset(c1);\n\n        var _count = end - _offset;\n\n        c1StopTraversal = intersectsRangeFunc(_offset, _count, true, depth + 1, nodeIndexByteOffset + c1);\n      } else {\n        c1StopTraversal = c1Intersection && shapecast(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n\n      if (c1StopTraversal) return true; // Check box 2 intersection\n      // cached box2 will have been overwritten by previous traversal\n\n      box2 = _box2;\n      (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n      var isC2Leaf = IS_LEAF(c2 * 2, uint16Array);\n      var c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n      var c2StopTraversal;\n\n      if (c2Intersection === _Constants.CONTAINED) {\n        var _offset2 = getLeftOffset(c2);\n\n        var _end = getRightEndOffset(c2);\n\n        var _count2 = _end - _offset2;\n\n        c2StopTraversal = intersectsRangeFunc(_offset2, _count2, true, depth + 1, nodeIndexByteOffset + c2);\n      } else {\n        c2StopTraversal = c2Intersection && shapecast(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n\n      if (c2StopTraversal) return true;\n      return false;\n    }\n  };\n}();\n\nexports.shapecast = shapecast;\n\nvar intersectsGeometry = function () {\n  var triangle = new _SeparatingAxisTriangle.SeparatingAxisTriangle();\n  var triangle2 = new _SeparatingAxisTriangle.SeparatingAxisTriangle();\n  var cachedMesh = new _three.Mesh();\n  var invertedMat = new _three.Matrix4();\n  var obb = new _OrientedBox.OrientedBox();\n  var obb2 = new _OrientedBox.OrientedBox();\n  return function intersectsGeometry(nodeIndex32, mesh, geometry, otherGeometry, geometryToBvh) {\n    var cachedObb = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var nodeIndex16 = nodeIndex32 * 2,\n        float32Array = _float32Array,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n\n    if (cachedObb === null) {\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      cachedObb = obb;\n    }\n\n    var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n    if (isLeaf) {\n      var thisGeometry = geometry;\n      var thisIndex = thisGeometry.index;\n      var thisPos = thisGeometry.attributes.position;\n      var index = otherGeometry.index;\n      var pos = otherGeometry.attributes.position;\n      var offset = OFFSET(nodeIndex32, uint32Array);\n      var count = COUNT(nodeIndex16, uint16Array); // get the inverse of the geometry matrix so we can transform our triangles into the\n      // geometry space we're trying to test. We assume there are fewer triangles being checked\n      // here.\n\n      invertedMat.copy(geometryToBvh).invert();\n\n      if (otherGeometry.boundsTree) {\n        (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2);\n        obb2.matrix.copy(invertedMat);\n        obb2.needsUpdate = true;\n        cachedMesh.geometry = otherGeometry;\n        var res = otherGeometry.boundsTree.shapecast(cachedMesh, {\n          intersectsBounds: function intersectsBounds(box) {\n            return obb2.intersectsBox(box);\n          },\n          intersectsTriangle: function intersectsTriangle(tri) {\n            tri.a.applyMatrix4(geometryToBvh);\n            tri.b.applyMatrix4(geometryToBvh);\n            tri.c.applyMatrix4(geometryToBvh);\n            tri.needsUpdate = true;\n\n            for (var i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {\n              // this triangle needs to be transformed into the current BVH coordinate frame\n              (0, _TriangleUtils.setTriangle)(triangle2, i, thisIndex, thisPos);\n              triangle2.needsUpdate = true;\n\n              if (tri.intersectsTriangle(triangle2)) {\n                return true;\n              }\n            }\n\n            return false;\n          }\n        });\n        cachedMesh.geometry = null;\n        return res;\n      } else {\n        for (var i = offset * 3, l = count + offset * 3; i < l; i += 3) {\n          // this triangle needs to be transformed into the current BVH coordinate frame\n          (0, _TriangleUtils.setTriangle)(triangle, i, thisIndex, thisPos);\n          triangle.a.applyMatrix4(invertedMat);\n          triangle.b.applyMatrix4(invertedMat);\n          triangle.c.applyMatrix4(invertedMat);\n          triangle.needsUpdate = true;\n\n          for (var i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {\n            (0, _TriangleUtils.setTriangle)(triangle2, i2, index, pos);\n            triangle2.needsUpdate = true;\n\n            if (triangle.intersectsTriangle(triangle2)) {\n              return true;\n            }\n          }\n        }\n      }\n    } else {\n      var left = nodeIndex32 + 8;\n      var right = uint32Array[nodeIndex32 + 6];\n      (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);\n      var leftIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(left, mesh, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (leftIntersection) return true;\n      (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);\n      var rightIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(right, mesh, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (rightIntersection) return true;\n      return false;\n    }\n  };\n}();\n\nexports.intersectsGeometry = intersectsGeometry;\n\nfunction intersectRay(nodeIndex32, array, ray, target) {\n  (0, _BufferNodeUtils.arrayToBox)(nodeIndex32, array, boundingBox);\n  return ray.intersectBox(boundingBox, target);\n}\n\nvar bufferStack = [];\n\nvar _prevBuffer;\n\nvar _float32Array;\n\nvar _uint16Array;\n\nvar _uint32Array;\n\nfunction setBuffer(buffer) {\n  if (_prevBuffer) {\n    bufferStack.push(_prevBuffer);\n  }\n\n  _prevBuffer = buffer;\n  _float32Array = new Float32Array(buffer);\n  _uint16Array = new Uint16Array(buffer);\n  _uint32Array = new Uint32Array(buffer);\n}\n\nfunction clearBuffer() {\n  _prevBuffer = null;\n  _float32Array = null;\n  _uint16Array = null;\n  _uint32Array = null;\n\n  if (bufferStack.length) {\n    setBuffer(bufferStack.pop());\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_mesh_bvh$src$Utils$RayIntersectTriUtilities","~$shadow.js","~$module$node_modules$three_mesh_bvh$src$Utils$TriangleUtils","~$module$node_modules$three_mesh_bvh$src$Constants","~$module$node_modules$three_mesh_bvh$src$Utils$SeparatingAxisTriangle","~$module$node_modules$three_mesh_bvh$src$Utils$BufferNodeUtils","~$module$node_modules$three_mesh_bvh$src$Utils$OrientedBox"]],"~:properties",["^5",["raycastFirst","intersectsGeometry","intersectsTriangle","shapecast","needsUpdate","__esModule","clearBuffer","value","geometry","intersectsBounds","raycast","setBuffer"]],"~:compiled-at",1630917516182,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_mesh_bvh$src$castFunctions.js\",\n\"lineCount\":19,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-mesh-bvh/src/castFunctions.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_mesh_bvh$src$castFunctions\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.raycast = raycast;\\nexports.raycastFirst = raycastFirst;\\nexports.setBuffer = setBuffer;\\nexports.clearBuffer = clearBuffer;\\nexports.intersectsGeometry = exports.shapecast = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _RayIntersectTriUtilities = require(\\\"./Utils/RayIntersectTriUtilities.js\\\");\\n\\nvar _BufferNodeUtils = require(\\\"./Utils/BufferNodeUtils.js\\\");\\n\\nvar _OrientedBox = require(\\\"./Utils/OrientedBox.js\\\");\\n\\nvar _TriangleUtils = require(\\\"./Utils/TriangleUtils.js\\\");\\n\\nvar _SeparatingAxisTriangle = require(\\\"./Utils/SeparatingAxisTriangle.js\\\");\\n\\nvar _Constants = require(\\\"./Constants.js\\\");\\n\\n// For speed and readability this script is processed to replace the macro-like calls\\n// with inline buffer reads. See generate-cast-functions.js.\\nvar boundingBox = new _three.Box3();\\nvar boxIntersection = new _three.Vector3();\\nvar xyzFields = ['x', 'y', 'z'];\\n\\nfunction IS_LEAF(n16, uint16Array) {\\n  return uint16Array[n16 + 15] === 0xFFFF;\\n}\\n\\nfunction OFFSET(n32, uint32Array) {\\n  return uint32Array[n32 + 6];\\n}\\n\\nfunction COUNT(n32, uint16Array) {\\n  return uint16Array[n32 + 14];\\n}\\n\\nfunction LEFT_NODE(n32) {\\n  return n32 + 8;\\n}\\n\\nfunction RIGHT_NODE(n32, uint32Array) {\\n  return uint32Array[n32 + 6];\\n}\\n\\nfunction SPLIT_AXIS(n32, uint32Array) {\\n  return uint32Array[n32 + 7];\\n}\\n\\nfunction BOUNDING_DATA_INDEX(n32) {\\n  return n32;\\n}\\n\\nfunction raycast(nodeIndex32, mesh, geometry, raycaster, ray, intersects) {\\n  var nodeIndex16 = nodeIndex32 * 2,\\n      float32Array = _float32Array,\\n      uint16Array = _uint16Array,\\n      uint32Array = _uint32Array;\\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\\n\\n  if (isLeaf) {\\n    var offset = OFFSET(nodeIndex32, uint32Array);\\n    var count = COUNT(nodeIndex16, uint16Array);\\n    (0, _RayIntersectTriUtilities.intersectTris)(mesh, geometry, raycaster, ray, offset, count, intersects);\\n  } else {\\n    var leftIndex = LEFT_NODE(nodeIndex32);\\n\\n    if (intersectRay(leftIndex, float32Array, ray, boxIntersection)) {\\n      raycast(leftIndex, mesh, geometry, raycaster, ray, intersects);\\n    }\\n\\n    var rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);\\n\\n    if (intersectRay(rightIndex, float32Array, ray, boxIntersection)) {\\n      raycast(rightIndex, mesh, geometry, raycaster, ray, intersects);\\n    }\\n  }\\n}\\n\\nfunction raycastFirst(nodeIndex32, mesh, geometry, raycaster, ray) {\\n  var nodeIndex16 = nodeIndex32 * 2,\\n      float32Array = _float32Array,\\n      uint16Array = _uint16Array,\\n      uint32Array = _uint32Array;\\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\\n\\n  if (isLeaf) {\\n    var offset = OFFSET(nodeIndex32, uint32Array);\\n    var count = COUNT(nodeIndex16, uint16Array);\\n    return (0, _RayIntersectTriUtilities.intersectClosestTri)(mesh, geometry, raycaster, ray, offset, count);\\n  } else {\\n    // consider the position of the split plane with respect to the oncoming ray; whichever direction\\n    // the ray is coming from, look for an intersection among that side of the tree first\\n    var splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\\n    var xyzAxis = xyzFields[splitAxis];\\n    var rayDir = ray.direction[xyzAxis];\\n    var leftToRight = rayDir >= 0; // c1 is the child to check first\\n\\n    var c1, c2;\\n\\n    if (leftToRight) {\\n      c1 = LEFT_NODE(nodeIndex32);\\n      c2 = RIGHT_NODE(nodeIndex32, uint32Array);\\n    } else {\\n      c1 = RIGHT_NODE(nodeIndex32, uint32Array);\\n      c2 = LEFT_NODE(nodeIndex32);\\n    }\\n\\n    var c1Intersection = intersectRay(c1, float32Array, ray, boxIntersection);\\n    var c1Result = c1Intersection ? raycastFirst(c1, mesh, geometry, raycaster, ray) : null; // if we got an intersection in the first node and it's closer than the second node's bounding\\n    // box, we don't need to consider the second node because it couldn't possibly be a better result\\n\\n    if (c1Result) {\\n      // check if the point is within the second bounds\\n      var point = c1Result.localPoint[xyzAxis];\\n      var isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : // min bounding data\\n      point >= float32Array[c2 + splitAxis + 3]; // max bounding data\\n\\n      if (isOutside) {\\n        return c1Result;\\n      }\\n    } // either there was no intersection in the first node, or there could still be a closer\\n    // intersection in the second, so check the second node and then take the better of the two\\n\\n\\n    var c2Intersection = intersectRay(c2, float32Array, ray, boxIntersection);\\n    var c2Result = c2Intersection ? raycastFirst(c2, mesh, geometry, raycaster, ray) : null;\\n\\n    if (c1Result && c2Result) {\\n      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\\n    } else {\\n      return c1Result || c2Result || null;\\n    }\\n  }\\n}\\n\\nvar shapecast = function () {\\n  var _box1 = new _three.Box3();\\n\\n  var _box2 = new _three.Box3();\\n\\n  return function shapecast(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc) {\\n    var nodeScoreFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\\n    var nodeIndexByteOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\\n    var depth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\\n\\n    // Define these inside the function so it has access to the local variables needed\\n    // when converting to the buffer equivalents\\n    function getLeftOffset(nodeIndex32) {\\n      var nodeIndex16 = nodeIndex32 * 2,\\n          uint16Array = _uint16Array,\\n          uint32Array = _uint32Array; // traverse until we find a leaf\\n\\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\\n        nodeIndex32 = LEFT_NODE(nodeIndex32);\\n        nodeIndex16 = nodeIndex32 * 2;\\n      }\\n\\n      return OFFSET(nodeIndex32, uint32Array);\\n    }\\n\\n    function getRightEndOffset(nodeIndex32) {\\n      var nodeIndex16 = nodeIndex32 * 2,\\n          uint16Array = _uint16Array,\\n          uint32Array = _uint32Array; // traverse until we find a leaf\\n\\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\\n        // adjust offset to point to the right node\\n        nodeIndex32 = RIGHT_NODE(nodeIndex32, uint32Array);\\n        nodeIndex16 = nodeIndex32 * 2;\\n      } // return the end offset of the triangle range\\n\\n\\n      return OFFSET(nodeIndex32, uint32Array) + COUNT(nodeIndex16, uint16Array);\\n    }\\n\\n    var nodeIndex16 = nodeIndex32 * 2,\\n        float32Array = _float32Array,\\n        uint16Array = _uint16Array,\\n        uint32Array = _uint32Array;\\n    var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\\n\\n    if (isLeaf) {\\n      var offset = OFFSET(nodeIndex32, uint32Array);\\n      var count = COUNT(nodeIndex16, uint16Array);\\n      return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32);\\n    } else {\\n      var left = LEFT_NODE(nodeIndex32);\\n      var right = RIGHT_NODE(nodeIndex32, uint32Array);\\n      var c1 = left;\\n      var c2 = right;\\n      var score1, score2;\\n      var box1, box2;\\n\\n      if (nodeScoreFunc) {\\n        box1 = _box1;\\n        box2 = _box2; // bounding data is not offset\\n\\n        (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(c1), float32Array, box1);\\n        (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(c2), float32Array, box2);\\n        score1 = nodeScoreFunc(box1);\\n        score2 = nodeScoreFunc(box2);\\n\\n        if (score2 < score1) {\\n          c1 = right;\\n          c2 = left;\\n          var temp = score1;\\n          score1 = score2;\\n          score2 = temp;\\n          box1 = box2; // box2 is always set before use below\\n        }\\n      } // Check box 1 intersection\\n\\n\\n      if (!box1) {\\n        box1 = _box1;\\n        (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(c1), float32Array, box1);\\n      }\\n\\n      var isC1Leaf = IS_LEAF(c1 * 2, uint16Array);\\n      var c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\\n      var c1StopTraversal;\\n\\n      if (c1Intersection === _Constants.CONTAINED) {\\n        var _offset = getLeftOffset(c1);\\n\\n        var end = getRightEndOffset(c1);\\n\\n        var _count = end - _offset;\\n\\n        c1StopTraversal = intersectsRangeFunc(_offset, _count, true, depth + 1, nodeIndexByteOffset + c1);\\n      } else {\\n        c1StopTraversal = c1Intersection && shapecast(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\\n      }\\n\\n      if (c1StopTraversal) return true; // Check box 2 intersection\\n      // cached box2 will have been overwritten by previous traversal\\n\\n      box2 = _box2;\\n      (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(c2), float32Array, box2);\\n      var isC2Leaf = IS_LEAF(c2 * 2, uint16Array);\\n      var c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\\n      var c2StopTraversal;\\n\\n      if (c2Intersection === _Constants.CONTAINED) {\\n        var _offset2 = getLeftOffset(c2);\\n\\n        var _end = getRightEndOffset(c2);\\n\\n        var _count2 = _end - _offset2;\\n\\n        c2StopTraversal = intersectsRangeFunc(_offset2, _count2, true, depth + 1, nodeIndexByteOffset + c2);\\n      } else {\\n        c2StopTraversal = c2Intersection && shapecast(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\\n      }\\n\\n      if (c2StopTraversal) return true;\\n      return false;\\n    }\\n  };\\n}();\\n\\nexports.shapecast = shapecast;\\n\\nvar intersectsGeometry = function () {\\n  var triangle = new _SeparatingAxisTriangle.SeparatingAxisTriangle();\\n  var triangle2 = new _SeparatingAxisTriangle.SeparatingAxisTriangle();\\n  var cachedMesh = new _three.Mesh();\\n  var invertedMat = new _three.Matrix4();\\n  var obb = new _OrientedBox.OrientedBox();\\n  var obb2 = new _OrientedBox.OrientedBox();\\n  return function intersectsGeometry(nodeIndex32, mesh, geometry, otherGeometry, geometryToBvh) {\\n    var cachedObb = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\\n    var nodeIndex16 = nodeIndex32 * 2,\\n        float32Array = _float32Array,\\n        uint16Array = _uint16Array,\\n        uint32Array = _uint32Array;\\n\\n    if (cachedObb === null) {\\n      if (!otherGeometry.boundingBox) {\\n        otherGeometry.computeBoundingBox();\\n      }\\n\\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\\n      cachedObb = obb;\\n    }\\n\\n    var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\\n\\n    if (isLeaf) {\\n      var thisGeometry = geometry;\\n      var thisIndex = thisGeometry.index;\\n      var thisPos = thisGeometry.attributes.position;\\n      var index = otherGeometry.index;\\n      var pos = otherGeometry.attributes.position;\\n      var offset = OFFSET(nodeIndex32, uint32Array);\\n      var count = COUNT(nodeIndex16, uint16Array); // get the inverse of the geometry matrix so we can transform our triangles into the\\n      // geometry space we're trying to test. We assume there are fewer triangles being checked\\n      // here.\\n\\n      invertedMat.copy(geometryToBvh).invert();\\n\\n      if (otherGeometry.boundsTree) {\\n        (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2);\\n        obb2.matrix.copy(invertedMat);\\n        obb2.needsUpdate = true;\\n        cachedMesh.geometry = otherGeometry;\\n        var res = otherGeometry.boundsTree.shapecast(cachedMesh, {\\n          intersectsBounds: function intersectsBounds(box) {\\n            return obb2.intersectsBox(box);\\n          },\\n          intersectsTriangle: function intersectsTriangle(tri) {\\n            tri.a.applyMatrix4(geometryToBvh);\\n            tri.b.applyMatrix4(geometryToBvh);\\n            tri.c.applyMatrix4(geometryToBvh);\\n            tri.needsUpdate = true;\\n\\n            for (var i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {\\n              // this triangle needs to be transformed into the current BVH coordinate frame\\n              (0, _TriangleUtils.setTriangle)(triangle2, i, thisIndex, thisPos);\\n              triangle2.needsUpdate = true;\\n\\n              if (tri.intersectsTriangle(triangle2)) {\\n                return true;\\n              }\\n            }\\n\\n            return false;\\n          }\\n        });\\n        cachedMesh.geometry = null;\\n        return res;\\n      } else {\\n        for (var i = offset * 3, l = count + offset * 3; i < l; i += 3) {\\n          // this triangle needs to be transformed into the current BVH coordinate frame\\n          (0, _TriangleUtils.setTriangle)(triangle, i, thisIndex, thisPos);\\n          triangle.a.applyMatrix4(invertedMat);\\n          triangle.b.applyMatrix4(invertedMat);\\n          triangle.c.applyMatrix4(invertedMat);\\n          triangle.needsUpdate = true;\\n\\n          for (var i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {\\n            (0, _TriangleUtils.setTriangle)(triangle2, i2, index, pos);\\n            triangle2.needsUpdate = true;\\n\\n            if (triangle.intersectsTriangle(triangle2)) {\\n              return true;\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      var left = nodeIndex32 + 8;\\n      var right = uint32Array[nodeIndex32 + 6];\\n      (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);\\n      var leftIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(left, mesh, geometry, otherGeometry, geometryToBvh, cachedObb);\\n      if (leftIntersection) return true;\\n      (0, _BufferNodeUtils.arrayToBox)(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);\\n      var rightIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(right, mesh, geometry, otherGeometry, geometryToBvh, cachedObb);\\n      if (rightIntersection) return true;\\n      return false;\\n    }\\n  };\\n}();\\n\\nexports.intersectsGeometry = intersectsGeometry;\\n\\nfunction intersectRay(nodeIndex32, array, ray, target) {\\n  (0, _BufferNodeUtils.arrayToBox)(nodeIndex32, array, boundingBox);\\n  return ray.intersectBox(boundingBox, target);\\n}\\n\\nvar bufferStack = [];\\n\\nvar _prevBuffer;\\n\\nvar _float32Array;\\n\\nvar _uint16Array;\\n\\nvar _uint32Array;\\n\\nfunction setBuffer(buffer) {\\n  if (_prevBuffer) {\\n    bufferStack.push(_prevBuffer);\\n  }\\n\\n  _prevBuffer = buffer;\\n  _float32Array = new Float32Array(buffer);\\n  _uint16Array = new Uint16Array(buffer);\\n  _uint32Array = new Uint32Array(buffer);\\n}\\n\\nfunction clearBuffer() {\\n  _prevBuffer = null;\\n  _float32Array = null;\\n  _uint16Array = null;\\n  _uint32Array = null;\\n\\n  if (bufferStack.length) {\\n    setBuffer(bufferStack.pop());\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"raycast\",\"nodeIndex32\",\"mesh\",\"geometry\",\"raycaster\",\"ray\",\"intersects\",\"nodeIndex16\",\"float32Array\",\"_float32Array\",\"uint16Array\",\"_uint16Array\",\"uint32Array\",\"_uint32Array\",\"offset\",\"count\",\"_RayIntersectTriUtilities\",\"intersectTris\",\"leftIndex\",\"intersectRay\",\"boxIntersection\",\"rightIndex\",\"raycastFirst\",\"intersectClosestTri\",\"splitAxis\",\"xyzAxis\",\"xyzFields\",\"leftToRight\",\"direction\",\"rayDir\",\"c1\",\"c2\",\"c1Result\",\"c1Intersection\",\"point\",\"isOutside\",\"localPoint\",\"c2Result\",\"c2Intersection\",\"distance\",\"array\",\"target\",\"_BufferNodeUtils\",\"arrayToBox\",\"boundingBox\",\"intersectBox\",\"setBuffer\",\"buffer\",\"_prevBuffer\",\"bufferStack\",\"push\",\"Float32Array\",\"Uint16Array\",\"Uint32Array\",\"Object\",\"defineProperty\",\"value\",\"clearBuffer\",\"length\",\"pop\",\"intersectsGeometry\",\"shapecast\",\"_three\",\"_OrientedBox\",\"_TriangleUtils\",\"_SeparatingAxisTriangle\",\"_Constants\",\"Box3\",\"Vector3\",\"_box1\",\"_box2\",\"intersectsBoundsFunc\",\"intersectsRangeFunc\",\"getLeftOffset\",\"getRightEndOffset\",\"nodeScoreFunc\",\"arguments\",\"undefined\",\"nodeIndexByteOffset\",\"depth\",\"left\",\"right\",\"box1\",\"box2\",\"score1\",\"score2\",\"temp\",\"CONTAINED\",\"_offset\",\"end\",\"c1StopTraversal\",\"_offset2\",\"_end\",\"c2StopTraversal\",\"triangle\",\"SeparatingAxisTriangle\",\"triangle2\",\"cachedMesh\",\"Mesh\",\"invertedMat\",\"Matrix4\",\"obb\",\"OrientedBox\",\"obb2\",\"otherGeometry\",\"geometryToBvh\",\"cachedObb\",\"computeBoundingBox\",\"set\",\"min\",\"max\",\"thisIndex\",\"index\",\"thisPos\",\"attributes\",\"position\",\"pos\",\"copy\",\"invert\",\"boundsTree\",\"res\",\"matrix\",\"needsUpdate\",\"intersectsBounds\",\"box\",\"intersectsBox\",\"intersectsTriangle\",\"tri\",\"a\",\"applyMatrix4\",\"b\",\"c\",\"i\",\"l\",\"setTriangle\",\"l2\",\"i2\"]\n}\n"]