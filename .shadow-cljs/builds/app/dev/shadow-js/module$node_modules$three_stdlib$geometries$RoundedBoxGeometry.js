["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/geometries/RoundedBoxGeometry.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$geometries$RoundedBoxGeometry=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _possibleConstructorReturn(self,call){if(call&&(\"object\"===_typeof(call)||\"function\"===\ntypeof call))return call;if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=\nObject.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}function getUv(faceDirVector,normal,uvAxis,projectionAxis,radius,sideLength){var totArcLength=2*Math.PI*radius/4;radius=Math.max(sideLength-2*radius,0);sideLength=Math.PI/4;tempNormal.copy(normal);\ntempNormal[projectionAxis]=0;tempNormal.normalize();normal=.5*totArcLength/(totArcLength+radius);faceDirVector=1-tempNormal.angleTo(faceDirVector)/sideLength;return 1===Math.sign(tempNormal[uvAxis])?faceDirVector*normal:radius/(totArcLength+radius)+normal+normal*(1-faceDirVector)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.RoundedBoxGeometry=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),tempNormal=new _three.Vector3;global=function(_BoxGeometry){function RoundedBoxGeometry(){var width=\n0<arguments.length&&void 0!==arguments[0]?arguments[0]:1,height=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1,depth=2<arguments.length&&void 0!==arguments[2]?arguments[2]:1,segments=3<arguments.length&&void 0!==arguments[3]?arguments[3]:2,radius=4<arguments.length&&void 0!==arguments[4]?arguments[4]:.1;if(!(this instanceof RoundedBoxGeometry))throw new TypeError(\"Cannot call a class as a function\");segments=2*segments+1;radius=Math.min(width/2,height/2,depth/2,radius);var _this=_possibleConstructorReturn(this,\n_getPrototypeOf(RoundedBoxGeometry).call(this,1,1,1,segments,segments,segments));if(1===segments)return _possibleConstructorReturn(_this);var geometry2=_this.toNonIndexed();_this.index=null;_this.attributes.position=geometry2.attributes.position;_this.attributes.normal=geometry2.attributes.normal;_this.attributes.uv=geometry2.attributes.uv;geometry2=new _three.Vector3;var normal=new _three.Vector3,box=(new _three.Vector3(width,height,depth)).divideScalar(2).subScalar(radius),positions=_this.attributes.position.array,\nnormals=_this.attributes.normal.array,uvs=_this.attributes.uv.array,faceTris=positions.length/6,faceDirVector=new _three.Vector3;segments=.5/segments;for(var i=0,j=0;i<positions.length;i+=3,j+=2)switch(geometry2.fromArray(positions,i),normal.copy(geometry2),normal.x-=Math.sign(normal.x)*segments,normal.y-=Math.sign(normal.y)*segments,normal.z-=Math.sign(normal.z)*segments,normal.normalize(),positions[i+0]=box.x*Math.sign(geometry2.x)+normal.x*radius,positions[i+1]=box.y*Math.sign(geometry2.y)+normal.y*\nradius,positions[i+2]=box.z*Math.sign(geometry2.z)+normal.z*radius,normals[i+0]=normal.x,normals[i+1]=normal.y,normals[i+2]=normal.z,Math.floor(i/faceTris)){case 0:faceDirVector.set(1,0,0);uvs[j+0]=getUv(faceDirVector,normal,\"z\",\"y\",radius,depth);uvs[j+1]=1-getUv(faceDirVector,normal,\"y\",\"z\",radius,height);break;case 1:faceDirVector.set(-1,0,0);uvs[j+0]=1-getUv(faceDirVector,normal,\"z\",\"y\",radius,depth);uvs[j+1]=1-getUv(faceDirVector,normal,\"y\",\"z\",radius,height);break;case 2:faceDirVector.set(0,\n1,0);uvs[j+0]=1-getUv(faceDirVector,normal,\"x\",\"z\",radius,width);uvs[j+1]=getUv(faceDirVector,normal,\"z\",\"x\",radius,depth);break;case 3:faceDirVector.set(0,-1,0);uvs[j+0]=1-getUv(faceDirVector,normal,\"x\",\"z\",radius,width);uvs[j+1]=1-getUv(faceDirVector,normal,\"z\",\"x\",radius,depth);break;case 4:faceDirVector.set(0,0,1);uvs[j+0]=1-getUv(faceDirVector,normal,\"x\",\"y\",radius,width);uvs[j+1]=1-getUv(faceDirVector,normal,\"y\",\"x\",radius,height);break;case 5:faceDirVector.set(0,0,-1),uvs[j+0]=getUv(faceDirVector,\nnormal,\"x\",\"y\",radius,width),uvs[j+1]=1-getUv(faceDirVector,normal,\"y\",\"x\",radius,height)}return _this}_inherits(RoundedBoxGeometry,_BoxGeometry);return RoundedBoxGeometry}(_three.BoxGeometry);exports.RoundedBoxGeometry=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$geometries$RoundedBoxGeometry\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RoundedBoxGeometry = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar tempNormal = new _three.Vector3();\n\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  var totArcLength = 2 * Math.PI * radius / 4; // length of the planes between the arcs on each axis\n\n  var centerLength = Math.max(sideLength - 2 * radius, 0);\n  var halfArc = Math.PI / 4; // Get the vector projected onto the Y plane\n\n  tempNormal.copy(normal);\n  tempNormal[projectionAxis] = 0;\n  tempNormal.normalize(); // total amount of UV space alloted to a single arc\n\n  var arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength); // the distance along one arc the point is at\n\n  var arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc;\n\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    // total amount of UV space alloted to the plane between the arcs\n    var lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\n  }\n}\n\nvar RoundedBoxGeometry =\n/*#__PURE__*/\nfunction (_BoxGeometry) {\n  _inherits(RoundedBoxGeometry, _BoxGeometry);\n\n  function RoundedBoxGeometry() {\n    var _this;\n\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;\n\n    _classCallCheck(this, RoundedBoxGeometry);\n\n    // ensure segments is odd so we have a plane connecting the rounded corners\n    segments = segments * 2 + 1; // ensure radius isn't bigger than shortest side\n\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RoundedBoxGeometry).call(this, 1, 1, 1, segments, segments, segments)); // if we just have one segment we're the same as a regular box\n\n    if (segments === 1) return _possibleConstructorReturn(_this);\n\n    var geometry2 = _this.toNonIndexed();\n\n    _this.index = null;\n    _this.attributes.position = geometry2.attributes.position;\n    _this.attributes.normal = geometry2.attributes.normal;\n    _this.attributes.uv = geometry2.attributes.uv; //\n\n    var position = new _three.Vector3();\n    var normal = new _three.Vector3();\n    var box = new _three.Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    var positions = _this.attributes.position.array;\n    var normals = _this.attributes.normal.array;\n    var uvs = _this.attributes.uv.array;\n    var faceTris = positions.length / 6;\n    var faceDirVector = new _three.Vector3();\n    var halfSegmentSize = 0.5 / segments;\n\n    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      var side = Math.floor(i / faceTris);\n\n      switch (side) {\n        case 0:\n          // right\n          // generate UVs along Z then Y\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n\n        case 1:\n          // left\n          // generate UVs along Z then Y\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n\n        case 2:\n          // top\n          // generate UVs along X then Z\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n\n        case 3:\n          // bottom\n          // generate UVs along X then Z\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n\n        case 4:\n          // front\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n\n        case 5:\n          // back\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n      }\n    }\n\n    return _this;\n  }\n\n  return RoundedBoxGeometry;\n}(_three.BoxGeometry);\n\nexports.RoundedBoxGeometry = RoundedBoxGeometry;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["z","index","prototype","x","__esModule","RoundedBoxGeometry","normal","position","configurable","value","writable","uv","y","__proto__","constructor"]],"~:compiled-at",1630917515563,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$geometries$RoundedBoxGeometry.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/geometries/RoundedBoxGeometry.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$geometries$RoundedBoxGeometry\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.RoundedBoxGeometry = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar tempNormal = new _three.Vector3();\\n\\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\\n  var totArcLength = 2 * Math.PI * radius / 4; // length of the planes between the arcs on each axis\\n\\n  var centerLength = Math.max(sideLength - 2 * radius, 0);\\n  var halfArc = Math.PI / 4; // Get the vector projected onto the Y plane\\n\\n  tempNormal.copy(normal);\\n  tempNormal[projectionAxis] = 0;\\n  tempNormal.normalize(); // total amount of UV space alloted to a single arc\\n\\n  var arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength); // the distance along one arc the point is at\\n\\n  var arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc;\\n\\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\\n    return arcAngleRatio * arcUvRatio;\\n  } else {\\n    // total amount of UV space alloted to the plane between the arcs\\n    var lenUv = centerLength / (totArcLength + centerLength);\\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\\n  }\\n}\\n\\nvar RoundedBoxGeometry =\\n/*#__PURE__*/\\nfunction (_BoxGeometry) {\\n  _inherits(RoundedBoxGeometry, _BoxGeometry);\\n\\n  function RoundedBoxGeometry() {\\n    var _this;\\n\\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n    var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\\n    var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;\\n\\n    _classCallCheck(this, RoundedBoxGeometry);\\n\\n    // ensure segments is odd so we have a plane connecting the rounded corners\\n    segments = segments * 2 + 1; // ensure radius isn't bigger than shortest side\\n\\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RoundedBoxGeometry).call(this, 1, 1, 1, segments, segments, segments)); // if we just have one segment we're the same as a regular box\\n\\n    if (segments === 1) return _possibleConstructorReturn(_this);\\n\\n    var geometry2 = _this.toNonIndexed();\\n\\n    _this.index = null;\\n    _this.attributes.position = geometry2.attributes.position;\\n    _this.attributes.normal = geometry2.attributes.normal;\\n    _this.attributes.uv = geometry2.attributes.uv; //\\n\\n    var position = new _three.Vector3();\\n    var normal = new _three.Vector3();\\n    var box = new _three.Vector3(width, height, depth).divideScalar(2).subScalar(radius);\\n    var positions = _this.attributes.position.array;\\n    var normals = _this.attributes.normal.array;\\n    var uvs = _this.attributes.uv.array;\\n    var faceTris = positions.length / 6;\\n    var faceDirVector = new _three.Vector3();\\n    var halfSegmentSize = 0.5 / segments;\\n\\n    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {\\n      position.fromArray(positions, i);\\n      normal.copy(position);\\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\\n      normal.normalize();\\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\\n      normals[i + 0] = normal.x;\\n      normals[i + 1] = normal.y;\\n      normals[i + 2] = normal.z;\\n      var side = Math.floor(i / faceTris);\\n\\n      switch (side) {\\n        case 0:\\n          // right\\n          // generate UVs along Z then Y\\n          faceDirVector.set(1, 0, 0);\\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth);\\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\\n          break;\\n\\n        case 1:\\n          // left\\n          // generate UVs along Z then Y\\n          faceDirVector.set(-1, 0, 0);\\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth);\\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\\n          break;\\n\\n        case 2:\\n          // top\\n          // generate UVs along X then Z\\n          faceDirVector.set(0, 1, 0);\\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth);\\n          break;\\n\\n        case 3:\\n          // bottom\\n          // generate UVs along X then Z\\n          faceDirVector.set(0, -1, 0);\\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth);\\n          break;\\n\\n        case 4:\\n          // front\\n          // generate UVs along X then Y\\n          faceDirVector.set(0, 0, 1);\\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width);\\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\\n          break;\\n\\n        case 5:\\n          // back\\n          // generate UVs along X then Y\\n          faceDirVector.set(0, 0, -1);\\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width);\\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\\n          break;\\n      }\\n    }\\n\\n    return _this;\\n  }\\n\\n  return RoundedBoxGeometry;\\n}(_three.BoxGeometry);\\n\\nexports.RoundedBoxGeometry = RoundedBoxGeometry;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_possibleConstructorReturn\",\"self\",\"call\",\"ReferenceError\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"getUv\",\"faceDirVector\",\"normal\",\"uvAxis\",\"projectionAxis\",\"radius\",\"sideLength\",\"totArcLength\",\"Math\",\"PI\",\"centerLength\",\"max\",\"halfArc\",\"tempNormal\",\"copy\",\"normalize\",\"arcUvRatio\",\"arcAngleRatio\",\"angleTo\",\"sign\",\"defineProperty\",\"RoundedBoxGeometry\",\"_three\",\"Vector3\",\"_BoxGeometry\",\"width\",\"arguments\",\"length\",\"undefined\",\"height\",\"depth\",\"segments\",\"instance\",\"min\",\"_this\",\"geometry2\",\"toNonIndexed\",\"index\",\"attributes\",\"position\",\"uv\",\"box\",\"divideScalar\",\"subScalar\",\"positions\",\"array\",\"normals\",\"uvs\",\"faceTris\",\"halfSegmentSize\",\"i\",\"j\",\"fromArray\",\"side\",\"x\",\"y\",\"z\",\"floor\",\"set\",\"BoxGeometry\"]\n}\n"]