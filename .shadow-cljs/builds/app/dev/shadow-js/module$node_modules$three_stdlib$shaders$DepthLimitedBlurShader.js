["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$DepthLimitedBlurShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.DepthLimitedBlurShader=exports.BlurShaderUtils=void 0;global=require(\"module$node_modules$three$build$three_module\");global={defines:{KERNEL_RADIUS:4,DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tDiffuse:{value:null},size:{value:new global.Vector2(512,512)},sampleUvOffsets:{value:[new global.Vector2(0,0)]},sampleWeights:{value:[1]},\ntDepth:{value:null},cameraNear:{value:10},cameraFar:{value:1E3},depthCutoff:{value:10}},vertexShader:\"#include \\x3ccommon\\x3e\\nuniform vec2 size;\\nvarying vec2 vUv;\\nvarying vec2 vInvSize;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tvInvSize \\x3d 1.0 / size;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"#include \\x3ccommon\\x3e\\n#include \\x3cpacking\\x3e\\nuniform sampler2D tDiffuse;\\nuniform sampler2D tDepth;\\nuniform float cameraNear;\\nuniform float cameraFar;\\nuniform float depthCutoff;\\nuniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\\nuniform float sampleWeights[ KERNEL_RADIUS + 1 ];\\nvarying vec2 vUv;\\nvarying vec2 vInvSize;\\nfloat getDepth( const in vec2 screenPosition ) {\\n\\t#if DEPTH_PACKING \\x3d\\x3d 1\\n\\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\\n\\t#else\\n\\treturn texture2D( tDepth, screenPosition ).x;\\n\\t#endif\\n}\\nfloat getViewZ( const in float depth ) {\\n\\t#if PERSPECTIVE_CAMERA \\x3d\\x3d 1\\n\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\\n\\t#else\\n\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\\n\\t#endif\\n}\\nvoid main() {\\n\\tfloat depth \\x3d getDepth( vUv );\\n\\tif( depth \\x3e\\x3d ( 1.0 - EPSILON ) ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tfloat centerViewZ \\x3d -getViewZ( depth );\\n\\tbool rBreak \\x3d false, lBreak \\x3d false;\\n\\tfloat weightSum \\x3d sampleWeights[0];\\n\\tvec4 diffuseSum \\x3d texture2D( tDiffuse, vUv ) * weightSum;\\n\\tfor( int i \\x3d 1; i \\x3c\\x3d KERNEL_RADIUS; i ++ ) {\\n\\t\\tfloat sampleWeight \\x3d sampleWeights[i];\\n\\t\\tvec2 sampleUvOffset \\x3d sampleUvOffsets[i] * vInvSize;\\n\\t\\tvec2 sampleUv \\x3d vUv + sampleUvOffset;\\n\\t\\tfloat viewZ \\x3d -getViewZ( getDepth( sampleUv ) );\\n\\t\\tif( abs( viewZ - centerViewZ ) \\x3e depthCutoff ) rBreak \\x3d true;\\n\\t\\tif( ! rBreak ) {\\n\\t\\t\\tdiffuseSum +\\x3d texture2D( tDiffuse, sampleUv ) * sampleWeight;\\n\\t\\t\\tweightSum +\\x3d sampleWeight;\\n\\t\\t}\\n\\t\\tsampleUv \\x3d vUv - sampleUvOffset;\\n\\t\\tviewZ \\x3d -getViewZ( getDepth( sampleUv ) );\\n\\t\\tif( abs( viewZ - centerViewZ ) \\x3e depthCutoff ) lBreak \\x3d true;\\n\\t\\tif( ! lBreak ) {\\n\\t\\t\\tdiffuseSum +\\x3d texture2D( tDiffuse, sampleUv ) * sampleWeight;\\n\\t\\t\\tweightSum +\\x3d sampleWeight;\\n\\t\\t}\\n\\t}\\n\\tgl_FragColor \\x3d diffuseSum / weightSum;\\n}\"};\nexports.DepthLimitedBlurShader=global;var BlurShaderUtils={createSampleWeights:function(kernelRadius,stdDev){for(var weights=[],i=0;i<=kernelRadius;i++)weights.push(Math.exp(-(i*i)/(2*stdDev*stdDev))/(Math.sqrt(2*Math.PI)*stdDev));return weights},createSampleOffsets:function(kernelRadius,uvIncrement){for(var offsets=[],i=0;i<=kernelRadius;i++)offsets.push(uvIncrement.clone().multiplyScalar(i));return offsets},configure:function(material,kernelRadius,stdDev,uvIncrement){material.defines.KERNEL_RADIUS=\nkernelRadius;material.uniforms.sampleUvOffsets.value=BlurShaderUtils.createSampleOffsets(kernelRadius,uvIncrement);material.uniforms.sampleWeights.value=BlurShaderUtils.createSampleWeights(kernelRadius,stdDev);material.needsUpdate=!0}};exports.BlurShaderUtils=BlurShaderUtils}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$DepthLimitedBlurShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DepthLimitedBlurShader = exports.BlurShaderUtils = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * TODO\n */\nvar DepthLimitedBlurShader = {\n  defines: {\n    KERNEL_RADIUS: 4,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    size: {\n      value: new _three.Vector2(512, 512)\n    },\n    sampleUvOffsets: {\n      value: [new _three.Vector2(0, 0)]\n    },\n    sampleWeights: {\n      value: [1.0]\n    },\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: 10\n    },\n    cameraFar: {\n      value: 1000\n    },\n    depthCutoff: {\n      value: 10\n    }\n  },\n  vertexShader: ['#include <common>', 'uniform vec2 size;', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'void main() {', '\tvUv = uv;', '\tvInvSize = 1.0 / size;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#include <packing>', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform float depthCutoff;', 'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];', 'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tif( depth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = -getViewZ( depth );', '\tbool rBreak = false, lBreak = false;', '\tfloat weightSum = sampleWeights[0];', '\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;', '\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {', '\t\tfloat sampleWeight = sampleWeights[i];', '\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;', '\t\tvec2 sampleUv = vUv + sampleUvOffset;', '\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;', '\t\tif( ! rBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t\tsampleUv = vUv - sampleUvOffset;', '\t\tviewZ = -getViewZ( getDepth( sampleUv ) );', '\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;', '\t\tif( ! lBreak ) {', '\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\t\t\tweightSum += sampleWeight;', '\t\t}', '\t}', '\tgl_FragColor = diffuseSum / weightSum;', '}'].join('\\n')\n};\nexports.DepthLimitedBlurShader = DepthLimitedBlurShader;\nvar BlurShaderUtils = {\n  createSampleWeights: function createSampleWeights(kernelRadius, stdDev) {\n    var gaussian = function gaussian(x, stdDev) {\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\n    };\n\n    var weights = [];\n\n    for (var i = 0; i <= kernelRadius; i++) {\n      weights.push(gaussian(i, stdDev));\n    }\n\n    return weights;\n  },\n  createSampleOffsets: function createSampleOffsets(kernelRadius, uvIncrement) {\n    var offsets = [];\n\n    for (var i = 0; i <= kernelRadius; i++) {\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n\n    return offsets;\n  },\n  configure: function configure(material, kernelRadius, stdDev, uvIncrement) {\n    material.defines['KERNEL_RADIUS'] = kernelRadius;\n    material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    material.needsUpdate = true;\n  }\n};\nexports.BlurShaderUtils = BlurShaderUtils;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","createSampleWeights","PERSPECTIVE_CAMERA","needsUpdate","cameraFar","KERNEL_RADIUS","__esModule","depthCutoff","configure","sampleWeights","tDiffuse","defines","sampleUvOffsets","vertexShader","value","tDepth","DEPTH_PACKING","DepthLimitedBlurShader","cameraNear","size","uniforms","BlurShaderUtils","createSampleOffsets"]],"~:compiled-at",1630917515518,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$DepthLimitedBlurShader.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,+DAAA,CAAoF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG5HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,sBAAR,CAAiCJ,OAAQK,CAAAA,eAAzC,CAA2D,IAAK,EAE5DC,OAAAA,CAASR,OAAA,CAAQ,8CAAR,CAKTM,OAAAA,CAAyB,CAC3BG,QAAS,CACPC,cAAe,CADR,CAEPC,cAAe,CAFR,CAGPC,mBAAoB,CAHb,CADkB,CAM3BC,SAAU,CACRC,SAAU,CACRT,MAAO,IADC,CADF,CAIRU,KAAM,CACJV,MAAO,IAAIG,MAAOQ,CAAAA,OAAX,CAAmB,GAAnB,CAAwB,GAAxB,CADH,CAJE,CAORC,gBAAiB,CACfZ,MAAO,CAAC,IAAIG,MAAOQ,CAAAA,OAAX,CAAmB,CAAnB,CAAsB,CAAtB,CAAD,CADQ,CAPT,CAURE,cAAe,CACbb,MAAO,CAAC,CAAD,CADM,CAVP;AAaRc,OAAQ,CACNd,MAAO,IADD,CAbA,CAgBRe,WAAY,CACVf,MAAO,EADG,CAhBJ,CAmBRgB,UAAW,CACThB,MAAO,GADE,CAnBH,CAsBRiB,YAAa,CACXjB,MAAO,EADI,CAtBL,CANiB,CAgC3BkB,aAAiP,uOAhCtN,CAiC3BC,eAA22D,m5DAjCh1D,CAmC7BtB;OAAQI,CAAAA,sBAAR,CAAiCA,MACjC,KAAIC,gBAAkB,CACpBkB,oBAAqBA,QAA4B,CAACC,YAAD,CAAeC,MAAf,CAAuB,CAOtE,IAFA,IAAIC,QAAU,EAAd,CAESC,EAAI,CAAb,CAAgBA,CAAhB,EAAqBH,YAArB,CAAmCG,CAAA,EAAnC,CACED,OAAQE,CAAAA,IAAR,CANOC,IAAKC,CAAAA,GAAL,CAAS,EAMMH,CANN,CAMMA,CANN,CAAT,EAAqB,CAArB,CAMkBF,MANlB,CAMkBA,MANlB,EAMP,EANyDI,IAAKE,CAAAA,IAAL,CAAU,CAAV,CAAgBF,IAAKG,CAAAA,EAArB,CAMzD,CAAyBP,MAAzB,EAGF,OAAOC,QAX+D,CADpD,CAcpBO,oBAAqBA,QAA4B,CAACT,YAAD,CAAeU,WAAf,CAA4B,CAG3E,IAFA,IAAIC,QAAU,EAAd,CAESR,EAAI,CAAb,CAAgBA,CAAhB,EAAqBH,YAArB,CAAmCG,CAAA,EAAnC,CACEQ,OAAQP,CAAAA,IAAR,CAAaM,WAAYE,CAAAA,KAAZ,EAAoBC,CAAAA,cAApB,CAAmCV,CAAnC,CAAb,CAGF,OAAOQ,QAPoE,CAdzD,CAuBpBG,UAAWA,QAAkB,CAACC,QAAD,CAAWf,YAAX,CAAyBC,MAAzB,CAAiCS,WAAjC,CAA8C,CACzEK,QAAShC,CAAAA,OAAT,CAAA,aAAA;AAAoCiB,YACpCe,SAAS5B,CAAAA,QAAT,CAAA,eAAqCR,CAAAA,KAArC,CAA6CE,eAAgB4B,CAAAA,mBAAhB,CAAoCT,YAApC,CAAkDU,WAAlD,CAC7CK,SAAS5B,CAAAA,QAAT,CAAA,aAAmCR,CAAAA,KAAnC,CAA2CE,eAAgBkB,CAAAA,mBAAhB,CAAoCC,YAApC,CAAkDC,MAAlD,CAC3Cc,SAASC,CAAAA,WAAT,CAAuB,CAAA,CAJkD,CAvBvD,CA8BtBxC,QAAQK,CAAAA,eAAR,CAA0BA,eA/EkG;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/DepthLimitedBlurShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$DepthLimitedBlurShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.DepthLimitedBlurShader = exports.BlurShaderUtils = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * TODO\\n */\\nvar DepthLimitedBlurShader = {\\n  defines: {\\n    KERNEL_RADIUS: 4,\\n    DEPTH_PACKING: 1,\\n    PERSPECTIVE_CAMERA: 1\\n  },\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    size: {\\n      value: new _three.Vector2(512, 512)\\n    },\\n    sampleUvOffsets: {\\n      value: [new _three.Vector2(0, 0)]\\n    },\\n    sampleWeights: {\\n      value: [1.0]\\n    },\\n    tDepth: {\\n      value: null\\n    },\\n    cameraNear: {\\n      value: 10\\n    },\\n    cameraFar: {\\n      value: 1000\\n    },\\n    depthCutoff: {\\n      value: 10\\n    }\\n  },\\n  vertexShader: ['#include <common>', 'uniform vec2 size;', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'void main() {', '\\tvUv = uv;', '\\tvInvSize = 1.0 / size;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['#include <common>', '#include <packing>', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform float depthCutoff;', 'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];', 'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];', 'varying vec2 vUv;', 'varying vec2 vInvSize;', 'float getDepth( const in vec2 screenPosition ) {', '\\t#if DEPTH_PACKING == 1', '\\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\\t#else', '\\treturn texture2D( tDepth, screenPosition ).x;', '\\t#endif', '}', 'float getViewZ( const in float depth ) {', '\\t#if PERSPECTIVE_CAMERA == 1', '\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\\t#else', '\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\\t#endif', '}', 'void main() {', '\\tfloat depth = getDepth( vUv );', '\\tif( depth >= ( 1.0 - EPSILON ) ) {', '\\t\\tdiscard;', '\\t}', '\\tfloat centerViewZ = -getViewZ( depth );', '\\tbool rBreak = false, lBreak = false;', '\\tfloat weightSum = sampleWeights[0];', '\\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;', '\\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {', '\\t\\tfloat sampleWeight = sampleWeights[i];', '\\t\\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;', '\\t\\tvec2 sampleUv = vUv + sampleUvOffset;', '\\t\\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );', '\\t\\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;', '\\t\\tif( ! rBreak ) {', '\\t\\t\\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\\t\\t\\tweightSum += sampleWeight;', '\\t\\t}', '\\t\\tsampleUv = vUv - sampleUvOffset;', '\\t\\tviewZ = -getViewZ( getDepth( sampleUv ) );', '\\t\\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;', '\\t\\tif( ! lBreak ) {', '\\t\\t\\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;', '\\t\\t\\tweightSum += sampleWeight;', '\\t\\t}', '\\t}', '\\tgl_FragColor = diffuseSum / weightSum;', '}'].join('\\\\n')\\n};\\nexports.DepthLimitedBlurShader = DepthLimitedBlurShader;\\nvar BlurShaderUtils = {\\n  createSampleWeights: function createSampleWeights(kernelRadius, stdDev) {\\n    var gaussian = function gaussian(x, stdDev) {\\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\\n    };\\n\\n    var weights = [];\\n\\n    for (var i = 0; i <= kernelRadius; i++) {\\n      weights.push(gaussian(i, stdDev));\\n    }\\n\\n    return weights;\\n  },\\n  createSampleOffsets: function createSampleOffsets(kernelRadius, uvIncrement) {\\n    var offsets = [];\\n\\n    for (var i = 0; i <= kernelRadius; i++) {\\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\\n    }\\n\\n    return offsets;\\n  },\\n  configure: function configure(material, kernelRadius, stdDev, uvIncrement) {\\n    material.defines['KERNEL_RADIUS'] = kernelRadius;\\n    material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\\n    material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\\n    material.needsUpdate = true;\\n  }\\n};\\nexports.BlurShaderUtils = BlurShaderUtils;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"DepthLimitedBlurShader\",\"BlurShaderUtils\",\"_three\",\"defines\",\"KERNEL_RADIUS\",\"DEPTH_PACKING\",\"PERSPECTIVE_CAMERA\",\"uniforms\",\"tDiffuse\",\"size\",\"Vector2\",\"sampleUvOffsets\",\"sampleWeights\",\"tDepth\",\"cameraNear\",\"cameraFar\",\"depthCutoff\",\"vertexShader\",\"fragmentShader\",\"createSampleWeights\",\"kernelRadius\",\"stdDev\",\"weights\",\"i\",\"push\",\"Math\",\"exp\",\"sqrt\",\"PI\",\"createSampleOffsets\",\"uvIncrement\",\"offsets\",\"clone\",\"multiplyScalar\",\"configure\",\"material\",\"needsUpdate\"]\n}\n"]