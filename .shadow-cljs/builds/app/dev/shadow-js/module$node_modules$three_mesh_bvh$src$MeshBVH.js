["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-mesh-bvh/src/MeshBVH.js"],"~:js","shadow$provide.module$node_modules$three_mesh_bvh$src$MeshBVH=function(global,require,module,exports){function _defineProperty(obj,key,value){key in obj?Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value;return obj}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,\ndescriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}Object.defineProperty(exports,\"__esModule\",{value:!0});exports[\"default\"]=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_Constants=require(\"module$node_modules$three_mesh_bvh$src$Constants\"),_buildFunctions=require(\"module$node_modules$three_mesh_bvh$src$buildFunctions\");\nglobal=require(\"module$node_modules$three_mesh_bvh$src$Utils$OrientedBox\");module=require(\"module$node_modules$three_mesh_bvh$src$Utils$SeparatingAxisTriangle\");var _TriangleUtils=require(\"module$node_modules$three_mesh_bvh$src$Utils$TriangleUtils\"),_castFunctions=require(\"module$node_modules$three_mesh_bvh$src$castFunctions\"),_BufferNodeUtils=require(\"module$node_modules$three_mesh_bvh$src$Utils$BufferNodeUtils\"),SKIP_GENERATION=Symbol(\"skip tree generation\"),obb=new global.OrientedBox,obb2=new global.OrientedBox,\ntemp=new _three.Vector3,temp1=new _three.Vector3,temp2=new _three.Vector3,tempBox=new _three.Box3,triangle=new module.SeparatingAxisTriangle,triangle2=new module.SeparatingAxisTriangle;require=function(){function MeshBVH(geometry){var options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!(this instanceof MeshBVH))throw new TypeError(\"Cannot call a class as a function\");if(!geometry.isBufferGeometry)throw Error(\"MeshBVH: Only BufferGeometries are supported.\");if(geometry.index&&geometry.index.isInterleavedBufferAttribute)throw Error(\"MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.\");\noptions=Object.assign(_defineProperty({strategy:_Constants.CENTER,maxDepth:40,maxLeafTris:10,verbose:!0,setBoundingBox:!0},SKIP_GENERATION,!1),options);options.strategy=Math.max(0,Math.min(2,options.strategy));this._roots=null;options[SKIP_GENERATION]||(this._roots=(0,_buildFunctions.buildPackedTree)(geometry,options),!geometry.boundingBox&&options.setBoundingBox&&(geometry.boundingBox=this.getBoundingBox(new _three.Box3)));this.geometry=geometry}_createClass(MeshBVH,null,[{key:\"serialize\",value:function(bvh,\ngeometry){var copyIndexBuffer=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!0,rootData=bvh._roots,indexAttribute=geometry.getIndex();return{roots:rootData,index:copyIndexBuffer?indexAttribute.array.slice():indexAttribute.array}}},{key:\"deserialize\",value:function(data,geometry){var setIndex=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!0,index=data.index,roots=data.roots,bvh=new MeshBVH(geometry,_defineProperty({},SKIP_GENERATION,!0));bvh._roots=roots;setIndex&&(setIndex=geometry.getIndex(),\nnull===setIndex?(index=new _three.BufferAttribute(data.index,1,!1),geometry.setIndex(index)):setIndex.array!==index&&(setIndex.array.set(index),setIndex.needsUpdate=!0));return bvh}}]);_createClass(MeshBVH,[{key:\"refit\",value:function(){function _traverse(node32Index,byteOffset){var force=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!1,node16Index=2*node32Index;if(uint16Array[node16Index+15]===_buildFunctions.IS_LEAFNODE_FLAG){var offset=uint32Array[node32Index+6],minx=Infinity,miny=Infinity;\nforce=Infinity;var maxx=-Infinity,maxy=-Infinity,maxz=-Infinity,_i=3*offset;for(node16Index=3*(offset+uint16Array[node16Index+14]);_i<node16Index;_i++){var index=indexArr[_i]*stride+bufferOffset;offset=posArr[index+0];var y=posArr[index+1];index=posArr[index+2];offset<minx&&(minx=offset);offset>maxx&&(maxx=offset);y<miny&&(miny=y);y>maxy&&(maxy=y);index<force&&(force=index);index>maxz&&(maxz=index)}return float32Array[node32Index+0]!==minx||float32Array[node32Index+1]!==miny||float32Array[node32Index+\n2]!==force||float32Array[node32Index+3]!==maxx||float32Array[node32Index+4]!==maxy||float32Array[node32Index+5]!==maxz?(float32Array[node32Index+0]=minx,float32Array[node32Index+1]=miny,float32Array[node32Index+2]=force,float32Array[node32Index+3]=maxx,float32Array[node32Index+4]=maxy,float32Array[node32Index+5]=maxz,!0):!1}minx=node32Index+8;miny=uint32Array[node32Index+6];maxz=minx+byteOffset;maxx=miny+byteOffset;maxy=!1;if((_i=force||terminationIndices&&terminationIndices.has(maxz))||(nodeIndices?\nnodeIndices.has(maxz):1))maxy=_traverse(minx,byteOffset,_i);maxz=!1;if((force=force||terminationIndices&&terminationIndices.has(maxx))||(nodeIndices?nodeIndices.has(maxx):1))maxz=_traverse(miny,byteOffset,force);if(force=maxy||maxz)for(maxx=0;3>maxx;maxx++)_i=minx+maxx,maxz=miny+maxx,maxy=float32Array[_i],_i=float32Array[_i+3],node16Index=float32Array[maxz],maxz=float32Array[maxz+3],float32Array[node32Index+maxx]=maxy<node16Index?maxy:node16Index,float32Array[node32Index+maxx+3]=_i>maxz?_i:maxz;return force}\nvar nodeIndices=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,terminationIndices=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null;nodeIndices&&Array.isArray(nodeIndices)&&(nodeIndices=new Set(nodeIndices));terminationIndices&&Array.isArray(terminationIndices)&&(terminationIndices=new Set(terminationIndices));var geometry=this.geometry,indexArr=geometry.index.array;geometry=geometry.attributes.position;var posArr=geometry.array,bufferOffset=geometry.offset||0,stride=3;geometry.isInterleavedBufferAttribute&&\n(stride=geometry.data.stride);for(var uint32Array,uint16Array,float32Array,byteOffset$jscomp$0=0,roots=this._roots,i=0,l=roots.length;i<l;i++)geometry=roots[i],uint32Array=new Uint32Array(geometry),uint16Array=new Uint16Array(geometry),float32Array=new Float32Array(geometry),_traverse(0,byteOffset$jscomp$0),byteOffset$jscomp$0+=geometry.byteLength}},{key:\"traverse\",value:function(callback){function _traverse(node32Index){var depth=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,node16Index=\n2*node32Index,isLeaf=uint16Array[node16Index+15]===_buildFunctions.IS_LEAFNODE_FLAG;if(isLeaf){var offset=uint32Array[node32Index+6];node16Index=uint16Array[node16Index+14];callback(depth,isLeaf,new Float32Array(buffer,4*node32Index,6),offset,node16Index)}else{offset=node32Index+_buildFunctions.BYTES_PER_NODE/4;node16Index=uint32Array[node32Index+6];var splitAxis=uint32Array[node32Index+7];callback(depth,isLeaf,new Float32Array(buffer,4*node32Index,6),splitAxis)||(_traverse(offset,depth+1),_traverse(node16Index,\ndepth+1))}}var buffer=this._roots[1<arguments.length&&void 0!==arguments[1]?arguments[1]:0],uint32Array=new Uint32Array(buffer),uint16Array=new Uint16Array(buffer);_traverse(0)}},{key:\"raycast\",value:function(mesh,raycaster,ray,intersects){var geometry=this.geometry,localIntersects=intersects?[]:null,_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=this._roots[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=\n!0){var root=_step.value;(0,_castFunctions.setBuffer)(root);(0,_castFunctions.raycast)(0,mesh,geometry,raycaster,ray,localIntersects);(0,_castFunctions.clearBuffer)()}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{if(!_iteratorNormalCompletion&&null!=_iterator[\"return\"])_iterator[\"return\"]()}finally{if(_didIteratorError)throw _iteratorError;}}if(intersects){mesh=0;for(raycaster=localIntersects.length;mesh<raycaster;mesh++)delete localIntersects[mesh].localPoint;mesh=intersects.push;\nraycaster=mesh.apply;if(Array.isArray(localIntersects)){ray=0;for(geometry=Array(localIntersects.length);ray<localIntersects.length;ray++)geometry[ray]=localIntersects[ray];ray=geometry}else ray=void 0;ray||(ray=Symbol.iterator in Object(localIntersects)||\"[object Arguments]\"===Object.prototype.toString.call(localIntersects)?Array.from(localIntersects):void 0);if(!(localIntersects=ray))throw new TypeError(\"Invalid attempt to spread non-iterable instance\");raycaster.call(mesh,intersects,localIntersects)}}},\n{key:\"raycastFirst\",value:function(mesh,raycaster,ray){var geometry=this.geometry,closestResult=null,_iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _iterator2=this._roots[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0){var root=_step2.value;(0,_castFunctions.setBuffer)(root);var result=(0,_castFunctions.raycastFirst)(0,mesh,geometry,raycaster,ray);(0,_castFunctions.clearBuffer)();null!=result&&\n(null==closestResult||result.distance<closestResult.distance)&&(closestResult=result)}}catch(err){_didIteratorError2=!0,_iteratorError2=err}finally{try{if(!_iteratorNormalCompletion2&&null!=_iterator2[\"return\"])_iterator2[\"return\"]()}finally{if(_didIteratorError2)throw _iteratorError2;}}closestResult&&delete closestResult.localPoint;return closestResult}},{key:\"intersectsGeometry\",value:function(mesh,otherGeometry,geomToMesh){var geometry=this.geometry,result=!1,_iteratorNormalCompletion3=!0,_didIteratorError3=\n!1,_iteratorError3=void 0;try{for(var _iterator3=this._roots[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=!0){var root=_step3.value;(0,_castFunctions.setBuffer)(root);result=(0,_castFunctions.intersectsGeometry)(0,mesh,geometry,otherGeometry,geomToMesh);(0,_castFunctions.clearBuffer)();if(result)break}}catch(err){_didIteratorError3=!0,_iteratorError3=err}finally{try{if(!_iteratorNormalCompletion3&&null!=_iterator3[\"return\"])_iterator3[\"return\"]()}finally{if(_didIteratorError3)throw _iteratorError3;\n}}return result}},{key:\"shapecast\",value:function(mesh,callbacks,_intersectsTriangleFunc,_orderNodesFunc){var geometry=this.geometry;if(callbacks instanceof Function){if(_intersectsTriangleFunc){var originalTriangleFunc=_intersectsTriangleFunc;_intersectsTriangleFunc=function(tri,index,contained,depth){index*=3;return originalTriangleFunc(tri,index,index+1,index+2,contained,depth)}}callbacks={boundsTraverseOrder:_orderNodesFunc,intersectsBounds:callbacks,intersectsTriangle:_intersectsTriangleFunc,\nintersectsRange:null};console.warn(\"MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.\")}_orderNodesFunc=callbacks;mesh=_orderNodesFunc.boundsTraverseOrder;callbacks=_orderNodesFunc.intersectsBounds;_intersectsTriangleFunc=_orderNodesFunc.intersectsRange;var intersectsTriangle=_orderNodesFunc.intersectsTriangle;if(_intersectsTriangleFunc&&intersectsTriangle){var originalIntersectsRange=_intersectsTriangleFunc;_intersectsTriangleFunc=\nfunction(offset,count,contained,depth,nodeIndex){return originalIntersectsRange(offset,count,contained,depth,nodeIndex)?!0:(0,_BufferNodeUtils.iterateOverTriangles)(offset,count,geometry,intersectsTriangle,contained,depth,triangle)}}else _intersectsTriangleFunc||(_intersectsTriangleFunc=intersectsTriangle?function(offset,count,contained,depth){return(0,_BufferNodeUtils.iterateOverTriangles)(offset,count,geometry,intersectsTriangle,contained,depth,triangle)}:function(offset,count,contained){return contained});\n_orderNodesFunc=!1;var byteOffset=0,_iteratorNormalCompletion4=!0,_didIteratorError4=!1,_iteratorError4=void 0;try{for(var _iterator4=this._roots[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=!0){var root=_step4.value;(0,_castFunctions.setBuffer)(root);_orderNodesFunc=(0,_castFunctions.shapecast)(0,geometry,callbacks,_intersectsTriangleFunc,mesh,byteOffset);(0,_castFunctions.clearBuffer)();if(_orderNodesFunc)break;byteOffset+=root.byteLength}}catch(err){_didIteratorError4=\n!0,_iteratorError4=err}finally{try{if(!_iteratorNormalCompletion4&&null!=_iterator4[\"return\"])_iterator4[\"return\"]()}finally{if(_didIteratorError4)throw _iteratorError4;}}return _orderNodesFunc}},{key:\"intersectsBox\",value:function(mesh,box$jscomp$0,boxToMesh){obb.set(box$jscomp$0.min,box$jscomp$0.max,boxToMesh);obb.needsUpdate=!0;return this.shapecast(mesh,{intersectsBounds:function(box){return obb.intersectsBox(box)},intersectsTriangle:function(tri){return obb.intersectsTriangle(tri)}})}},{key:\"intersectsSphere\",\nvalue:function(mesh,sphere){return this.shapecast(mesh,{intersectsBounds:function(box){return sphere.intersectsBox(box)},intersectsTriangle:function(tri){return tri.intersectsSphere(sphere)}})}},{key:\"closestPointToGeometry\",value:function(mesh,otherGeometry,geometryToBvh){var target1=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null,target2=4<arguments.length&&void 0!==arguments[4]?arguments[4]:null,minThreshold=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0,maxThreshold=6<arguments.length&&\nvoid 0!==arguments[6]?arguments[6]:Infinity;otherGeometry.boundingBox||otherGeometry.computeBoundingBox();obb.set(otherGeometry.boundingBox.min,otherGeometry.boundingBox.max,geometryToBvh);obb.needsUpdate=!0;var geometry=this.geometry,pos=geometry.attributes.position,index=geometry.index,otherPos=otherGeometry.attributes.position,otherIndex=otherGeometry.index,tempTarget1=null,tempTarget2=null;target1&&(tempTarget1=temp1);target2&&(tempTarget2=temp2);var closestDistance=Infinity;obb2.matrix.copy(geometryToBvh).invert();\nthis.shapecast(mesh,{boundsTraverseOrder:function(box){return obb.distanceToBox(box,Math.min(closestDistance,maxThreshold))},intersectsBounds:function(box,isLeaf,score){return score<closestDistance&&score<maxThreshold?(isLeaf&&(obb2.min.copy(box.min),obb2.max.copy(box.max),obb2.needsUpdate=!0),!0):!1},intersectsRange:function(offset,count){if(otherGeometry.boundsTree)return otherGeometry.boundsTree.shapecast(null,{boundsTraverseOrder:function(box){return obb2.distanceToBox(box,Math.min(closestDistance,\nmaxThreshold))},intersectsBounds:function(box,isLeaf,score){return score<closestDistance&&score<maxThreshold},intersectsRange:function(otherOffset,otherCount){var i2=3*otherOffset;for(otherOffset=3*(otherOffset+otherCount);i2<otherOffset;i2+=3){(0,_TriangleUtils.setTriangle)(triangle2,i2,otherIndex,otherPos);triangle2.a.applyMatrix4(geometryToBvh);triangle2.b.applyMatrix4(geometryToBvh);triangle2.c.applyMatrix4(geometryToBvh);triangle2.needsUpdate=!0;otherCount=3*offset;for(var l=3*(offset+count);otherCount<\nl;otherCount+=3){(0,_TriangleUtils.setTriangle)(triangle,otherCount,index,pos);triangle.needsUpdate=!0;var dist=triangle.distanceToTriangle(triangle2,tempTarget1,tempTarget2);dist<closestDistance&&(target1&&target1.copy(tempTarget1),target2&&target2.copy(tempTarget2),closestDistance=dist);if(dist<minThreshold)return!0}}}});for(var i2$jscomp$0=0,l2=otherIndex?otherIndex.count:otherPos.count;i2$jscomp$0<l2;i2$jscomp$0+=3){(0,_TriangleUtils.setTriangle)(triangle2,i2$jscomp$0,otherIndex,otherPos);triangle2.a.applyMatrix4(geometryToBvh);\ntriangle2.b.applyMatrix4(geometryToBvh);triangle2.c.applyMatrix4(geometryToBvh);triangle2.needsUpdate=!0;for(var i=3*offset,l$jscomp$0=3*(offset+count);i<l$jscomp$0;i+=3){(0,_TriangleUtils.setTriangle)(triangle,i,index,pos);triangle.needsUpdate=!0;var dist$jscomp$0=triangle.distanceToTriangle(triangle2,tempTarget1,tempTarget2);dist$jscomp$0<closestDistance&&(target1&&target1.copy(tempTarget1),target2&&target2.copy(tempTarget2),closestDistance=dist$jscomp$0);if(dist$jscomp$0<minThreshold)return!0}}}});\nreturn closestDistance}},{key:\"distanceToGeometry\",value:function(mesh,geom,matrix,minThreshold,maxThreshold){return this.closestPointToGeometry(mesh,geom,matrix,null,null,minThreshold,maxThreshold)}},{key:\"closestPointToPoint\",value:function(mesh,point,target){var minThreshold=3<arguments.length&&void 0!==arguments[3]?arguments[3]:0,maxThreshold=4<arguments.length&&void 0!==arguments[4]?arguments[4]:Infinity,minThresholdSq=minThreshold*minThreshold,maxThresholdSq=maxThreshold*maxThreshold,closestDistanceSq=\nInfinity;this.shapecast(mesh,{boundsTraverseOrder:function(box){temp.copy(point).clamp(box.min,box.max);return temp.distanceToSquared(point)},intersectsBounds:function(box,isLeaf,score){return score<closestDistanceSq&&score<maxThresholdSq},intersectsTriangle:function(tri){tri.closestPointToPoint(point,temp);tri=point.distanceToSquared(temp);tri<closestDistanceSq&&(target&&target.copy(temp),closestDistanceSq=tri);return tri<minThresholdSq?!0:!1}});return Math.sqrt(closestDistanceSq)}},{key:\"distanceToPoint\",\nvalue:function(mesh,point,minThreshold,maxThreshold){return this.closestPointToPoint(mesh,point,null,minThreshold,maxThreshold)}},{key:\"getBoundingBox\",value:function(target){target.makeEmpty();this._roots.forEach(function(buffer){(0,_BufferNodeUtils.arrayToBox)(0,new Float32Array(buffer),tempBox);target.union(tempBox)});return target}}]);return MeshBVH}();exports[\"default\"]=require}","~:source","shadow$provide[\"module$node_modules$three_mesh_bvh$src$MeshBVH\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _three = require(\"three\");\n\nvar _Constants = require(\"./Constants.js\");\n\nvar _buildFunctions = require(\"./buildFunctions.js\");\n\nvar _OrientedBox = require(\"./Utils/OrientedBox.js\");\n\nvar _SeparatingAxisTriangle = require(\"./Utils/SeparatingAxisTriangle.js\");\n\nvar _TriangleUtils = require(\"./Utils/TriangleUtils.js\");\n\nvar _castFunctions = require(\"./castFunctions.js\");\n\nvar _BufferNodeUtils = require(\"./Utils/BufferNodeUtils.js\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar SKIP_GENERATION = Symbol('skip tree generation');\nvar obb = new _OrientedBox.OrientedBox();\nvar obb2 = new _OrientedBox.OrientedBox();\nvar temp = new _three.Vector3();\nvar temp1 = new _three.Vector3();\nvar temp2 = new _three.Vector3();\nvar tempBox = new _three.Box3();\nvar triangle = new _SeparatingAxisTriangle.SeparatingAxisTriangle();\nvar triangle2 = new _SeparatingAxisTriangle.SeparatingAxisTriangle();\n\nvar MeshBVH =\n/*#__PURE__*/\nfunction () {\n  _createClass(MeshBVH, null, [{\n    key: \"serialize\",\n    value: function serialize(bvh, geometry) {\n      var copyIndexBuffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var rootData = bvh._roots;\n      var indexAttribute = geometry.getIndex();\n      var result = {\n        roots: rootData,\n        index: copyIndexBuffer ? indexAttribute.array.slice() : indexAttribute.array\n      };\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var setIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var index = data.index,\n          roots = data.roots;\n      var bvh = new MeshBVH(geometry, _defineProperty({}, SKIP_GENERATION, true));\n      bvh._roots = roots;\n\n      if (setIndex) {\n        var indexAttribute = geometry.getIndex();\n\n        if (indexAttribute === null) {\n          var newIndex = new _three.BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n\n      return bvh;\n    }\n  }]);\n\n  function MeshBVH(geometry) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, MeshBVH);\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    } // default options\n\n\n    options = Object.assign(_defineProperty({\n      strategy: _Constants.CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      setBoundingBox: true\n    }, SKIP_GENERATION, false), options);\n    options.strategy = Math.max(0, Math.min(2, options.strategy));\n    this._roots = null;\n\n    if (!options[SKIP_GENERATION]) {\n      this._roots = (0, _buildFunctions.buildPackedTree)(geometry, options);\n\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new _three.Box3());\n      }\n    } // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n\n\n    this.geometry = geometry;\n  }\n\n  _createClass(MeshBVH, [{\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var terminationIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n      }\n\n      if (terminationIndices && Array.isArray(terminationIndices)) {\n        terminationIndices = new Set(terminationIndices);\n      }\n\n      var geometry = this.geometry;\n      var indexArr = geometry.index.array;\n      var posAttr = geometry.attributes.position;\n      var posArr = posAttr.array; // support for an interleaved position buffer\n\n      var bufferOffset = posAttr.offset || 0;\n      var stride = 3;\n\n      if (posAttr.isInterleavedBufferAttribute) {\n        stride = posAttr.data.stride;\n      }\n\n      var buffer, uint32Array, uint16Array, float32Array;\n      var byteOffset = 0;\n      var roots = this._roots;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n\n        _traverse(0, byteOffset);\n\n        byteOffset += buffer.byteLength;\n      }\n\n      function _traverse(node32Index, byteOffset) {\n        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === _buildFunctions.IS_LEAFNODE_FLAG;\n\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          var minx = Infinity;\n          var miny = Infinity;\n          var minz = Infinity;\n          var maxx = -Infinity;\n          var maxy = -Infinity;\n          var maxz = -Infinity;\n\n          for (var _i = 3 * offset, _l = 3 * (offset + count); _i < _l; _i++) {\n            var index = indexArr[_i] * stride + bufferOffset;\n            var x = posArr[index + 0];\n            var y = posArr[index + 1];\n            var z = posArr[index + 2];\n            if (x < minx) minx = x;\n            if (x > maxx) maxx = x;\n            if (y < miny) miny = y;\n            if (y > maxy) maxy = y;\n            if (z < minz) minz = z;\n            if (z > maxz) maxz = z;\n          }\n\n          if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n            float32Array[node32Index + 0] = minx;\n            float32Array[node32Index + 1] = miny;\n            float32Array[node32Index + 2] = minz;\n            float32Array[node32Index + 3] = maxx;\n            float32Array[node32Index + 4] = maxy;\n            float32Array[node32Index + 5] = maxz;\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          var left = node32Index + 8;\n          var right = uint32Array[node32Index + 6]; // the indentifying node indices provided by the shapecast function include offsets of all\n          // root buffers to guarantee they're unique between roots so offset left and right indices here.\n\n          var offsetLeft = left + byteOffset;\n          var offsetRight = right + byteOffset;\n          var leftChange = false;\n          var forceLeft = force || terminationIndices && terminationIndices.has(offsetLeft);\n          var traverseLeft = forceLeft || (nodeIndices ? nodeIndices.has(offsetLeft) : true);\n\n          if (traverseLeft) {\n            leftChange = _traverse(left, byteOffset, forceLeft);\n          }\n\n          var rightChange = false;\n          var forceRight = force || terminationIndices && terminationIndices.has(offsetRight);\n          var traverseRight = forceRight || (nodeIndices ? nodeIndices.has(offsetRight) : true);\n\n          if (traverseRight) {\n            rightChange = _traverse(right, byteOffset, forceRight);\n          }\n\n          var didChange = leftChange || rightChange;\n\n          if (didChange) {\n            for (var _i2 = 0; _i2 < 3; _i2++) {\n              var lefti = left + _i2;\n              var righti = right + _i2;\n              var minLeftValue = float32Array[lefti];\n              var maxLeftValue = float32Array[lefti + 3];\n              var minRightValue = float32Array[righti];\n              var maxRightValue = float32Array[righti + 3];\n              float32Array[node32Index + _i2] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n              float32Array[node32Index + _i2 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n          }\n\n          return didChange;\n        }\n      }\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n\n      _traverse(0);\n\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === _buildFunctions.IS_LEAFNODE_FLAG;\n\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          var left = node32Index + _buildFunctions.BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    }\n    /* Core Cast Functions */\n\n  }, {\n    key: \"raycast\",\n    value: function raycast(mesh, raycaster, ray, intersects) {\n      var geometry = this.geometry;\n      var localIntersects = intersects ? [] : null;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._roots[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var root = _step.value;\n          (0, _castFunctions.setBuffer)(root);\n          (0, _castFunctions.raycast)(0, mesh, geometry, raycaster, ray, localIntersects);\n          (0, _castFunctions.clearBuffer)();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (intersects) {\n        for (var i = 0, l = localIntersects.length; i < l; i++) {\n          delete localIntersects[i].localPoint;\n        }\n\n        intersects.push.apply(intersects, _toConsumableArray(localIntersects));\n      }\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(mesh, raycaster, ray) {\n      var geometry = this.geometry;\n      var closestResult = null;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._roots[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var root = _step2.value;\n          (0, _castFunctions.setBuffer)(root);\n          var result = (0, _castFunctions.raycastFirst)(0, mesh, geometry, raycaster, ray);\n          (0, _castFunctions.clearBuffer)();\n\n          if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n            closestResult = result;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      if (closestResult) {\n        delete closestResult.localPoint;\n      }\n\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(mesh, otherGeometry, geomToMesh) {\n      var geometry = this.geometry;\n      var result = false;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this._roots[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var root = _step3.value;\n          (0, _castFunctions.setBuffer)(root);\n          result = (0, _castFunctions.intersectsGeometry)(0, mesh, geometry, otherGeometry, geomToMesh);\n          (0, _castFunctions.clearBuffer)();\n\n          if (result) {\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(mesh, callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n      var geometry = this.geometry;\n\n      if (callbacks instanceof Function) {\n        if (_intersectsTriangleFunc) {\n          // Support the previous function signature that provided three sequential index buffer\n          // indices here.\n          var originalTriangleFunc = _intersectsTriangleFunc;\n\n          _intersectsTriangleFunc = function _intersectsTriangleFunc(tri, index, contained, depth) {\n            var i3 = index * 3;\n            return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n          };\n        }\n\n        callbacks = {\n          boundsTraverseOrder: _orderNodesFunc,\n          intersectsBounds: callbacks,\n          intersectsTriangle: _intersectsTriangleFunc,\n          intersectsRange: null\n        };\n        console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n      }\n\n      var _callbacks = callbacks,\n          boundsTraverseOrder = _callbacks.boundsTraverseOrder,\n          intersectsBounds = _callbacks.intersectsBounds,\n          intersectsRange = _callbacks.intersectsRange,\n          intersectsTriangle = _callbacks.intersectsTriangle;\n\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return (0, _BufferNodeUtils.iterateOverTriangles)(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          }\n\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return (0, _BufferNodeUtils.iterateOverTriangles)(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n\n      var result = false;\n      var byteOffset = 0;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this._roots[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var root = _step4.value;\n          (0, _castFunctions.setBuffer)(root);\n          result = (0, _castFunctions.shapecast)(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n          (0, _castFunctions.clearBuffer)();\n\n          if (result) {\n            break;\n          }\n\n          byteOffset += root.byteLength;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n            _iterator4[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return result;\n    }\n    /* Derived Cast Functions */\n\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(mesh, box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast(mesh, {\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(mesh, sphere) {\n      return this.shapecast(mesh, {\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(mesh, otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var target2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n      var minThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n      var maxThreshold = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Infinity;\n\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      obb.needsUpdate = true;\n      var geometry = this.geometry;\n      var pos = geometry.attributes.position;\n      var index = geometry.index;\n      var otherPos = otherGeometry.attributes.position;\n      var otherIndex = otherGeometry.index;\n      var tempTarget1 = null;\n      var tempTarget2 = null;\n\n      if (target1) {\n        tempTarget1 = temp1;\n      }\n\n      if (target2) {\n        tempTarget2 = temp2;\n      }\n\n      var closestDistance = Infinity;\n      obb2.matrix.copy(geometryToBvh).invert();\n      this.shapecast(mesh, {\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          return obb.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          if (score < closestDistance && score < maxThreshold) {\n            // if we know the triangles of this bounds will be intersected next then\n            // save the bounds to use during triangle checks.\n            if (isLeaf) {\n              obb2.min.copy(box.min);\n              obb2.max.copy(box.max);\n              obb2.needsUpdate = true;\n            }\n\n            return true;\n          }\n\n          return false;\n        },\n        intersectsRange: function intersectsRange(offset, count) {\n          if (otherGeometry.boundsTree) {\n            // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n            // the closest bounds in the other geometry to check.\n            return otherGeometry.boundsTree.shapecast(null, {\n              boundsTraverseOrder: function boundsTraverseOrder(box) {\n                return obb2.distanceToBox(box, Math.min(closestDistance, maxThreshold));\n              },\n              intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n                return score < closestDistance && score < maxThreshold;\n              },\n              intersectsRange: function intersectsRange(otherOffset, otherCount) {\n                for (var i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                  (0, _TriangleUtils.setTriangle)(triangle2, i2, otherIndex, otherPos);\n                  triangle2.a.applyMatrix4(geometryToBvh);\n                  triangle2.b.applyMatrix4(geometryToBvh);\n                  triangle2.c.applyMatrix4(geometryToBvh);\n                  triangle2.needsUpdate = true;\n\n                  for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                    (0, _TriangleUtils.setTriangle)(triangle, i, index, pos);\n                    triangle.needsUpdate = true;\n                    var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                    if (dist < closestDistance) {\n                      if (target1) {\n                        target1.copy(tempTarget1);\n                      }\n\n                      if (target2) {\n                        target2.copy(tempTarget2);\n                      }\n\n                      closestDistance = dist;\n                    } // stop traversal if we find a point that's under the given threshold\n\n\n                    if (dist < minThreshold) {\n                      return true;\n                    }\n                  }\n                }\n              }\n            });\n          } else {\n            // If no bounds tree then we'll just check every triangle.\n            var triCount = otherIndex ? otherIndex.count : otherPos.count;\n\n            for (var i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n              (0, _TriangleUtils.setTriangle)(triangle2, i2, otherIndex, otherPos);\n              triangle2.a.applyMatrix4(geometryToBvh);\n              triangle2.b.applyMatrix4(geometryToBvh);\n              triangle2.c.applyMatrix4(geometryToBvh);\n              triangle2.needsUpdate = true;\n\n              for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                (0, _TriangleUtils.setTriangle)(triangle, i, index, pos);\n                triangle.needsUpdate = true;\n                var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                if (dist < closestDistance) {\n                  if (target1) {\n                    target1.copy(tempTarget1);\n                  }\n\n                  if (target2) {\n                    target2.copy(tempTarget2);\n                  }\n\n                  closestDistance = dist;\n                } // stop traversal if we find a point that's under the given threshold\n\n\n                if (dist < minThreshold) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      });\n      return closestDistance;\n    }\n  }, {\n    key: \"distanceToGeometry\",\n    value: function distanceToGeometry(mesh, geom, matrix, minThreshold, maxThreshold) {\n      return this.closestPointToGeometry(mesh, geom, matrix, null, null, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(mesh, point, target) {\n      var minThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var maxThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;\n      // early out if under minThreshold\n      // skip checking if over maxThreshold\n      // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n      // returns Infinity if no value found\n      var minThresholdSq = minThreshold * minThreshold;\n      var maxThresholdSq = maxThreshold * maxThreshold;\n      var closestDistanceSq = Infinity;\n      this.shapecast(mesh, {\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          temp.copy(point).clamp(box.min, box.max);\n          return temp.distanceToSquared(point);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          tri.closestPointToPoint(point, temp);\n          var distSq = point.distanceToSquared(temp);\n\n          if (distSq < closestDistanceSq) {\n            if (target) {\n              target.copy(temp);\n            }\n\n            closestDistanceSq = distSq;\n          }\n\n          if (distSq < minThresholdSq) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n      return Math.sqrt(closestDistanceSq);\n    }\n  }, {\n    key: \"distanceToPoint\",\n    value: function distanceToPoint(mesh, point, minThreshold, maxThreshold) {\n      return this.closestPointToPoint(mesh, point, null, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        (0, _BufferNodeUtils.arrayToBox)(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }]);\n\n  return MeshBVH;\n}();\n\nexports[\"default\"] = MeshBVH;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_mesh_bvh$src$castFunctions","~$shadow.js","~$module$node_modules$three_mesh_bvh$src$Utils$TriangleUtils","~$module$node_modules$three_mesh_bvh$src$Constants","~$module$node_modules$three_mesh_bvh$src$buildFunctions","~$module$node_modules$three_mesh_bvh$src$Utils$SeparatingAxisTriangle","~$module$node_modules$three_mesh_bvh$src$Utils$BufferNodeUtils","~$module$node_modules$three_mesh_bvh$src$Utils$OrientedBox"]],"~:properties",["^5",["boundsTraverseOrder","setBoundingBox","intersectsTriangle","index","strategy","needsUpdate","key","__esModule","roots","_roots","maxLeafTris","configurable","value","geometry","enumerable","boundingBox","intersectsBounds","writable","intersectsRange","maxDepth","verbose"]],"~:compiled-at",1630917516185,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_mesh_bvh$src$MeshBVH.js\",\n\"lineCount\":33,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-mesh-bvh/src/MeshBVH.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_mesh_bvh$src$MeshBVH\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports[\\\"default\\\"] = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _Constants = require(\\\"./Constants.js\\\");\\n\\nvar _buildFunctions = require(\\\"./buildFunctions.js\\\");\\n\\nvar _OrientedBox = require(\\\"./Utils/OrientedBox.js\\\");\\n\\nvar _SeparatingAxisTriangle = require(\\\"./Utils/SeparatingAxisTriangle.js\\\");\\n\\nvar _TriangleUtils = require(\\\"./Utils/TriangleUtils.js\\\");\\n\\nvar _castFunctions = require(\\\"./castFunctions.js\\\");\\n\\nvar _BufferNodeUtils = require(\\\"./Utils/BufferNodeUtils.js\\\");\\n\\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\\n\\nfunction _nonIterableSpread() { throw new TypeError(\\\"Invalid attempt to spread non-iterable instance\\\"); }\\n\\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \\\"[object Arguments]\\\") return Array.from(iter); }\\n\\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\\n\\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nvar SKIP_GENERATION = Symbol('skip tree generation');\\nvar obb = new _OrientedBox.OrientedBox();\\nvar obb2 = new _OrientedBox.OrientedBox();\\nvar temp = new _three.Vector3();\\nvar temp1 = new _three.Vector3();\\nvar temp2 = new _three.Vector3();\\nvar tempBox = new _three.Box3();\\nvar triangle = new _SeparatingAxisTriangle.SeparatingAxisTriangle();\\nvar triangle2 = new _SeparatingAxisTriangle.SeparatingAxisTriangle();\\n\\nvar MeshBVH =\\n/*#__PURE__*/\\nfunction () {\\n  _createClass(MeshBVH, null, [{\\n    key: \\\"serialize\\\",\\n    value: function serialize(bvh, geometry) {\\n      var copyIndexBuffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\\n      var rootData = bvh._roots;\\n      var indexAttribute = geometry.getIndex();\\n      var result = {\\n        roots: rootData,\\n        index: copyIndexBuffer ? indexAttribute.array.slice() : indexAttribute.array\\n      };\\n      return result;\\n    }\\n  }, {\\n    key: \\\"deserialize\\\",\\n    value: function deserialize(data, geometry) {\\n      var setIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\\n      var index = data.index,\\n          roots = data.roots;\\n      var bvh = new MeshBVH(geometry, _defineProperty({}, SKIP_GENERATION, true));\\n      bvh._roots = roots;\\n\\n      if (setIndex) {\\n        var indexAttribute = geometry.getIndex();\\n\\n        if (indexAttribute === null) {\\n          var newIndex = new _three.BufferAttribute(data.index, 1, false);\\n          geometry.setIndex(newIndex);\\n        } else if (indexAttribute.array !== index) {\\n          indexAttribute.array.set(index);\\n          indexAttribute.needsUpdate = true;\\n        }\\n      }\\n\\n      return bvh;\\n    }\\n  }]);\\n\\n  function MeshBVH(geometry) {\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n    _classCallCheck(this, MeshBVH);\\n\\n    if (!geometry.isBufferGeometry) {\\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\\n    } // default options\\n\\n\\n    options = Object.assign(_defineProperty({\\n      strategy: _Constants.CENTER,\\n      maxDepth: 40,\\n      maxLeafTris: 10,\\n      verbose: true,\\n      setBoundingBox: true\\n    }, SKIP_GENERATION, false), options);\\n    options.strategy = Math.max(0, Math.min(2, options.strategy));\\n    this._roots = null;\\n\\n    if (!options[SKIP_GENERATION]) {\\n      this._roots = (0, _buildFunctions.buildPackedTree)(geometry, options);\\n\\n      if (!geometry.boundingBox && options.setBoundingBox) {\\n        geometry.boundingBox = this.getBoundingBox(new _three.Box3());\\n      }\\n    } // retain references to the geometry so we can use them it without having to\\n    // take a geometry reference in every function.\\n\\n\\n    this.geometry = geometry;\\n  }\\n\\n  _createClass(MeshBVH, [{\\n    key: \\\"refit\\\",\\n    value: function refit() {\\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\\n      var terminationIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\\n\\n      if (nodeIndices && Array.isArray(nodeIndices)) {\\n        nodeIndices = new Set(nodeIndices);\\n      }\\n\\n      if (terminationIndices && Array.isArray(terminationIndices)) {\\n        terminationIndices = new Set(terminationIndices);\\n      }\\n\\n      var geometry = this.geometry;\\n      var indexArr = geometry.index.array;\\n      var posAttr = geometry.attributes.position;\\n      var posArr = posAttr.array; // support for an interleaved position buffer\\n\\n      var bufferOffset = posAttr.offset || 0;\\n      var stride = 3;\\n\\n      if (posAttr.isInterleavedBufferAttribute) {\\n        stride = posAttr.data.stride;\\n      }\\n\\n      var buffer, uint32Array, uint16Array, float32Array;\\n      var byteOffset = 0;\\n      var roots = this._roots;\\n\\n      for (var i = 0, l = roots.length; i < l; i++) {\\n        buffer = roots[i];\\n        uint32Array = new Uint32Array(buffer);\\n        uint16Array = new Uint16Array(buffer);\\n        float32Array = new Float32Array(buffer);\\n\\n        _traverse(0, byteOffset);\\n\\n        byteOffset += buffer.byteLength;\\n      }\\n\\n      function _traverse(node32Index, byteOffset) {\\n        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n        var node16Index = node32Index * 2;\\n        var isLeaf = uint16Array[node16Index + 15] === _buildFunctions.IS_LEAFNODE_FLAG;\\n\\n        if (isLeaf) {\\n          var offset = uint32Array[node32Index + 6];\\n          var count = uint16Array[node16Index + 14];\\n          var minx = Infinity;\\n          var miny = Infinity;\\n          var minz = Infinity;\\n          var maxx = -Infinity;\\n          var maxy = -Infinity;\\n          var maxz = -Infinity;\\n\\n          for (var _i = 3 * offset, _l = 3 * (offset + count); _i < _l; _i++) {\\n            var index = indexArr[_i] * stride + bufferOffset;\\n            var x = posArr[index + 0];\\n            var y = posArr[index + 1];\\n            var z = posArr[index + 2];\\n            if (x < minx) minx = x;\\n            if (x > maxx) maxx = x;\\n            if (y < miny) miny = y;\\n            if (y > maxy) maxy = y;\\n            if (z < minz) minz = z;\\n            if (z > maxz) maxz = z;\\n          }\\n\\n          if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\\n            float32Array[node32Index + 0] = minx;\\n            float32Array[node32Index + 1] = miny;\\n            float32Array[node32Index + 2] = minz;\\n            float32Array[node32Index + 3] = maxx;\\n            float32Array[node32Index + 4] = maxy;\\n            float32Array[node32Index + 5] = maxz;\\n            return true;\\n          } else {\\n            return false;\\n          }\\n        } else {\\n          var left = node32Index + 8;\\n          var right = uint32Array[node32Index + 6]; // the indentifying node indices provided by the shapecast function include offsets of all\\n          // root buffers to guarantee they're unique between roots so offset left and right indices here.\\n\\n          var offsetLeft = left + byteOffset;\\n          var offsetRight = right + byteOffset;\\n          var leftChange = false;\\n          var forceLeft = force || terminationIndices && terminationIndices.has(offsetLeft);\\n          var traverseLeft = forceLeft || (nodeIndices ? nodeIndices.has(offsetLeft) : true);\\n\\n          if (traverseLeft) {\\n            leftChange = _traverse(left, byteOffset, forceLeft);\\n          }\\n\\n          var rightChange = false;\\n          var forceRight = force || terminationIndices && terminationIndices.has(offsetRight);\\n          var traverseRight = forceRight || (nodeIndices ? nodeIndices.has(offsetRight) : true);\\n\\n          if (traverseRight) {\\n            rightChange = _traverse(right, byteOffset, forceRight);\\n          }\\n\\n          var didChange = leftChange || rightChange;\\n\\n          if (didChange) {\\n            for (var _i2 = 0; _i2 < 3; _i2++) {\\n              var lefti = left + _i2;\\n              var righti = right + _i2;\\n              var minLeftValue = float32Array[lefti];\\n              var maxLeftValue = float32Array[lefti + 3];\\n              var minRightValue = float32Array[righti];\\n              var maxRightValue = float32Array[righti + 3];\\n              float32Array[node32Index + _i2] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\\n              float32Array[node32Index + _i2 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\\n            }\\n          }\\n\\n          return didChange;\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"traverse\\\",\\n    value: function traverse(callback) {\\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n      var buffer = this._roots[rootIndex];\\n      var uint32Array = new Uint32Array(buffer);\\n      var uint16Array = new Uint16Array(buffer);\\n\\n      _traverse(0);\\n\\n      function _traverse(node32Index) {\\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n        var node16Index = node32Index * 2;\\n        var isLeaf = uint16Array[node16Index + 15] === _buildFunctions.IS_LEAFNODE_FLAG;\\n\\n        if (isLeaf) {\\n          var offset = uint32Array[node32Index + 6];\\n          var count = uint16Array[node16Index + 14];\\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\\n        } else {\\n          var left = node32Index + _buildFunctions.BYTES_PER_NODE / 4;\\n          var right = uint32Array[node32Index + 6];\\n          var splitAxis = uint32Array[node32Index + 7];\\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\\n\\n          if (!stopTraversal) {\\n            _traverse(left, depth + 1);\\n\\n            _traverse(right, depth + 1);\\n          }\\n        }\\n      }\\n    }\\n    /* Core Cast Functions */\\n\\n  }, {\\n    key: \\\"raycast\\\",\\n    value: function raycast(mesh, raycaster, ray, intersects) {\\n      var geometry = this.geometry;\\n      var localIntersects = intersects ? [] : null;\\n      var _iteratorNormalCompletion = true;\\n      var _didIteratorError = false;\\n      var _iteratorError = undefined;\\n\\n      try {\\n        for (var _iterator = this._roots[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n          var root = _step.value;\\n          (0, _castFunctions.setBuffer)(root);\\n          (0, _castFunctions.raycast)(0, mesh, geometry, raycaster, ray, localIntersects);\\n          (0, _castFunctions.clearBuffer)();\\n        }\\n      } catch (err) {\\n        _didIteratorError = true;\\n        _iteratorError = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion && _iterator[\\\"return\\\"] != null) {\\n            _iterator[\\\"return\\\"]();\\n          }\\n        } finally {\\n          if (_didIteratorError) {\\n            throw _iteratorError;\\n          }\\n        }\\n      }\\n\\n      if (intersects) {\\n        for (var i = 0, l = localIntersects.length; i < l; i++) {\\n          delete localIntersects[i].localPoint;\\n        }\\n\\n        intersects.push.apply(intersects, _toConsumableArray(localIntersects));\\n      }\\n    }\\n  }, {\\n    key: \\\"raycastFirst\\\",\\n    value: function raycastFirst(mesh, raycaster, ray) {\\n      var geometry = this.geometry;\\n      var closestResult = null;\\n      var _iteratorNormalCompletion2 = true;\\n      var _didIteratorError2 = false;\\n      var _iteratorError2 = undefined;\\n\\n      try {\\n        for (var _iterator2 = this._roots[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n          var root = _step2.value;\\n          (0, _castFunctions.setBuffer)(root);\\n          var result = (0, _castFunctions.raycastFirst)(0, mesh, geometry, raycaster, ray);\\n          (0, _castFunctions.clearBuffer)();\\n\\n          if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\\n            closestResult = result;\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError2 = true;\\n        _iteratorError2 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion2 && _iterator2[\\\"return\\\"] != null) {\\n            _iterator2[\\\"return\\\"]();\\n          }\\n        } finally {\\n          if (_didIteratorError2) {\\n            throw _iteratorError2;\\n          }\\n        }\\n      }\\n\\n      if (closestResult) {\\n        delete closestResult.localPoint;\\n      }\\n\\n      return closestResult;\\n    }\\n  }, {\\n    key: \\\"intersectsGeometry\\\",\\n    value: function intersectsGeometry(mesh, otherGeometry, geomToMesh) {\\n      var geometry = this.geometry;\\n      var result = false;\\n      var _iteratorNormalCompletion3 = true;\\n      var _didIteratorError3 = false;\\n      var _iteratorError3 = undefined;\\n\\n      try {\\n        for (var _iterator3 = this._roots[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n          var root = _step3.value;\\n          (0, _castFunctions.setBuffer)(root);\\n          result = (0, _castFunctions.intersectsGeometry)(0, mesh, geometry, otherGeometry, geomToMesh);\\n          (0, _castFunctions.clearBuffer)();\\n\\n          if (result) {\\n            break;\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError3 = true;\\n        _iteratorError3 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion3 && _iterator3[\\\"return\\\"] != null) {\\n            _iterator3[\\\"return\\\"]();\\n          }\\n        } finally {\\n          if (_didIteratorError3) {\\n            throw _iteratorError3;\\n          }\\n        }\\n      }\\n\\n      return result;\\n    }\\n  }, {\\n    key: \\\"shapecast\\\",\\n    value: function shapecast(mesh, callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\\n      var geometry = this.geometry;\\n\\n      if (callbacks instanceof Function) {\\n        if (_intersectsTriangleFunc) {\\n          // Support the previous function signature that provided three sequential index buffer\\n          // indices here.\\n          var originalTriangleFunc = _intersectsTriangleFunc;\\n\\n          _intersectsTriangleFunc = function _intersectsTriangleFunc(tri, index, contained, depth) {\\n            var i3 = index * 3;\\n            return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\\n          };\\n        }\\n\\n        callbacks = {\\n          boundsTraverseOrder: _orderNodesFunc,\\n          intersectsBounds: callbacks,\\n          intersectsTriangle: _intersectsTriangleFunc,\\n          intersectsRange: null\\n        };\\n        console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\\n      }\\n\\n      var _callbacks = callbacks,\\n          boundsTraverseOrder = _callbacks.boundsTraverseOrder,\\n          intersectsBounds = _callbacks.intersectsBounds,\\n          intersectsRange = _callbacks.intersectsRange,\\n          intersectsTriangle = _callbacks.intersectsTriangle;\\n\\n      if (intersectsRange && intersectsTriangle) {\\n        var originalIntersectsRange = intersectsRange;\\n\\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\\n            return (0, _BufferNodeUtils.iterateOverTriangles)(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\\n          }\\n\\n          return true;\\n        };\\n      } else if (!intersectsRange) {\\n        if (intersectsTriangle) {\\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\\n            return (0, _BufferNodeUtils.iterateOverTriangles)(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\\n          };\\n        } else {\\n          intersectsRange = function intersectsRange(offset, count, contained) {\\n            return contained;\\n          };\\n        }\\n      }\\n\\n      var result = false;\\n      var byteOffset = 0;\\n      var _iteratorNormalCompletion4 = true;\\n      var _didIteratorError4 = false;\\n      var _iteratorError4 = undefined;\\n\\n      try {\\n        for (var _iterator4 = this._roots[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n          var root = _step4.value;\\n          (0, _castFunctions.setBuffer)(root);\\n          result = (0, _castFunctions.shapecast)(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\\n          (0, _castFunctions.clearBuffer)();\\n\\n          if (result) {\\n            break;\\n          }\\n\\n          byteOffset += root.byteLength;\\n        }\\n      } catch (err) {\\n        _didIteratorError4 = true;\\n        _iteratorError4 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion4 && _iterator4[\\\"return\\\"] != null) {\\n            _iterator4[\\\"return\\\"]();\\n          }\\n        } finally {\\n          if (_didIteratorError4) {\\n            throw _iteratorError4;\\n          }\\n        }\\n      }\\n\\n      return result;\\n    }\\n    /* Derived Cast Functions */\\n\\n  }, {\\n    key: \\\"intersectsBox\\\",\\n    value: function intersectsBox(mesh, box, boxToMesh) {\\n      obb.set(box.min, box.max, boxToMesh);\\n      obb.needsUpdate = true;\\n      return this.shapecast(mesh, {\\n        intersectsBounds: function intersectsBounds(box) {\\n          return obb.intersectsBox(box);\\n        },\\n        intersectsTriangle: function intersectsTriangle(tri) {\\n          return obb.intersectsTriangle(tri);\\n        }\\n      });\\n    }\\n  }, {\\n    key: \\\"intersectsSphere\\\",\\n    value: function intersectsSphere(mesh, sphere) {\\n      return this.shapecast(mesh, {\\n        intersectsBounds: function intersectsBounds(box) {\\n          return sphere.intersectsBox(box);\\n        },\\n        intersectsTriangle: function intersectsTriangle(tri) {\\n          return tri.intersectsSphere(sphere);\\n        }\\n      });\\n    }\\n  }, {\\n    key: \\\"closestPointToGeometry\\\",\\n    value: function closestPointToGeometry(mesh, otherGeometry, geometryToBvh) {\\n      var target1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\\n      var target2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\\n      var minThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\\n      var maxThreshold = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Infinity;\\n\\n      if (!otherGeometry.boundingBox) {\\n        otherGeometry.computeBoundingBox();\\n      }\\n\\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\\n      obb.needsUpdate = true;\\n      var geometry = this.geometry;\\n      var pos = geometry.attributes.position;\\n      var index = geometry.index;\\n      var otherPos = otherGeometry.attributes.position;\\n      var otherIndex = otherGeometry.index;\\n      var tempTarget1 = null;\\n      var tempTarget2 = null;\\n\\n      if (target1) {\\n        tempTarget1 = temp1;\\n      }\\n\\n      if (target2) {\\n        tempTarget2 = temp2;\\n      }\\n\\n      var closestDistance = Infinity;\\n      obb2.matrix.copy(geometryToBvh).invert();\\n      this.shapecast(mesh, {\\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\\n          return obb.distanceToBox(box, Math.min(closestDistance, maxThreshold));\\n        },\\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\\n          if (score < closestDistance && score < maxThreshold) {\\n            // if we know the triangles of this bounds will be intersected next then\\n            // save the bounds to use during triangle checks.\\n            if (isLeaf) {\\n              obb2.min.copy(box.min);\\n              obb2.max.copy(box.max);\\n              obb2.needsUpdate = true;\\n            }\\n\\n            return true;\\n          }\\n\\n          return false;\\n        },\\n        intersectsRange: function intersectsRange(offset, count) {\\n          if (otherGeometry.boundsTree) {\\n            // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\\n            // the closest bounds in the other geometry to check.\\n            return otherGeometry.boundsTree.shapecast(null, {\\n              boundsTraverseOrder: function boundsTraverseOrder(box) {\\n                return obb2.distanceToBox(box, Math.min(closestDistance, maxThreshold));\\n              },\\n              intersectsBounds: function intersectsBounds(box, isLeaf, score) {\\n                return score < closestDistance && score < maxThreshold;\\n              },\\n              intersectsRange: function intersectsRange(otherOffset, otherCount) {\\n                for (var i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\\n                  (0, _TriangleUtils.setTriangle)(triangle2, i2, otherIndex, otherPos);\\n                  triangle2.a.applyMatrix4(geometryToBvh);\\n                  triangle2.b.applyMatrix4(geometryToBvh);\\n                  triangle2.c.applyMatrix4(geometryToBvh);\\n                  triangle2.needsUpdate = true;\\n\\n                  for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\\n                    (0, _TriangleUtils.setTriangle)(triangle, i, index, pos);\\n                    triangle.needsUpdate = true;\\n                    var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\\n\\n                    if (dist < closestDistance) {\\n                      if (target1) {\\n                        target1.copy(tempTarget1);\\n                      }\\n\\n                      if (target2) {\\n                        target2.copy(tempTarget2);\\n                      }\\n\\n                      closestDistance = dist;\\n                    } // stop traversal if we find a point that's under the given threshold\\n\\n\\n                    if (dist < minThreshold) {\\n                      return true;\\n                    }\\n                  }\\n                }\\n              }\\n            });\\n          } else {\\n            // If no bounds tree then we'll just check every triangle.\\n            var triCount = otherIndex ? otherIndex.count : otherPos.count;\\n\\n            for (var i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\\n              (0, _TriangleUtils.setTriangle)(triangle2, i2, otherIndex, otherPos);\\n              triangle2.a.applyMatrix4(geometryToBvh);\\n              triangle2.b.applyMatrix4(geometryToBvh);\\n              triangle2.c.applyMatrix4(geometryToBvh);\\n              triangle2.needsUpdate = true;\\n\\n              for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\\n                (0, _TriangleUtils.setTriangle)(triangle, i, index, pos);\\n                triangle.needsUpdate = true;\\n                var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\\n\\n                if (dist < closestDistance) {\\n                  if (target1) {\\n                    target1.copy(tempTarget1);\\n                  }\\n\\n                  if (target2) {\\n                    target2.copy(tempTarget2);\\n                  }\\n\\n                  closestDistance = dist;\\n                } // stop traversal if we find a point that's under the given threshold\\n\\n\\n                if (dist < minThreshold) {\\n                  return true;\\n                }\\n              }\\n            }\\n          }\\n        }\\n      });\\n      return closestDistance;\\n    }\\n  }, {\\n    key: \\\"distanceToGeometry\\\",\\n    value: function distanceToGeometry(mesh, geom, matrix, minThreshold, maxThreshold) {\\n      return this.closestPointToGeometry(mesh, geom, matrix, null, null, minThreshold, maxThreshold);\\n    }\\n  }, {\\n    key: \\\"closestPointToPoint\\\",\\n    value: function closestPointToPoint(mesh, point, target) {\\n      var minThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\\n      var maxThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;\\n      // early out if under minThreshold\\n      // skip checking if over maxThreshold\\n      // set minThreshold = maxThreshold to quickly check if a point is within a threshold\\n      // returns Infinity if no value found\\n      var minThresholdSq = minThreshold * minThreshold;\\n      var maxThresholdSq = maxThreshold * maxThreshold;\\n      var closestDistanceSq = Infinity;\\n      this.shapecast(mesh, {\\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\\n          temp.copy(point).clamp(box.min, box.max);\\n          return temp.distanceToSquared(point);\\n        },\\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\\n          return score < closestDistanceSq && score < maxThresholdSq;\\n        },\\n        intersectsTriangle: function intersectsTriangle(tri) {\\n          tri.closestPointToPoint(point, temp);\\n          var distSq = point.distanceToSquared(temp);\\n\\n          if (distSq < closestDistanceSq) {\\n            if (target) {\\n              target.copy(temp);\\n            }\\n\\n            closestDistanceSq = distSq;\\n          }\\n\\n          if (distSq < minThresholdSq) {\\n            return true;\\n          } else {\\n            return false;\\n          }\\n        }\\n      });\\n      return Math.sqrt(closestDistanceSq);\\n    }\\n  }, {\\n    key: \\\"distanceToPoint\\\",\\n    value: function distanceToPoint(mesh, point, minThreshold, maxThreshold) {\\n      return this.closestPointToPoint(mesh, point, null, minThreshold, maxThreshold);\\n    }\\n  }, {\\n    key: \\\"getBoundingBox\\\",\\n    value: function getBoundingBox(target) {\\n      target.makeEmpty();\\n      var roots = this._roots;\\n      roots.forEach(function (buffer) {\\n        (0, _BufferNodeUtils.arrayToBox)(0, new Float32Array(buffer), tempBox);\\n        target.union(tempBox);\\n      });\\n      return target;\\n    }\\n  }]);\\n\\n  return MeshBVH;\\n}();\\n\\nexports[\\\"default\\\"] = MeshBVH;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_defineProperty\",\"obj\",\"key\",\"value\",\"Object\",\"defineProperty\",\"enumerable\",\"configurable\",\"writable\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"prototype\",\"_three\",\"_Constants\",\"_buildFunctions\",\"_OrientedBox\",\"_SeparatingAxisTriangle\",\"_TriangleUtils\",\"_castFunctions\",\"_BufferNodeUtils\",\"SKIP_GENERATION\",\"Symbol\",\"obb\",\"OrientedBox\",\"obb2\",\"temp\",\"Vector3\",\"temp1\",\"temp2\",\"tempBox\",\"Box3\",\"triangle\",\"SeparatingAxisTriangle\",\"triangle2\",\"MeshBVH\",\"geometry\",\"options\",\"arguments\",\"undefined\",\"instance\",\"TypeError\",\"isBufferGeometry\",\"Error\",\"index\",\"isInterleavedBufferAttribute\",\"assign\",\"strategy\",\"CENTER\",\"maxDepth\",\"maxLeafTris\",\"verbose\",\"setBoundingBox\",\"Math\",\"max\",\"min\",\"_roots\",\"buildPackedTree\",\"boundingBox\",\"getBoundingBox\",\"serialize\",\"bvh\",\"copyIndexBuffer\",\"rootData\",\"indexAttribute\",\"getIndex\",\"result\",\"roots\",\"array\",\"slice\",\"deserialize\",\"data\",\"setIndex\",\"newIndex\",\"BufferAttribute\",\"set\",\"needsUpdate\",\"refit\",\"_traverse\",\"node32Index\",\"byteOffset\",\"force\",\"node16Index\",\"uint16Array\",\"IS_LEAFNODE_FLAG\",\"offset\",\"uint32Array\",\"minx\",\"Infinity\",\"miny\",\"minz\",\"maxx\",\"maxy\",\"maxz\",\"_i\",\"_l\",\"count\",\"indexArr\",\"stride\",\"bufferOffset\",\"x\",\"posArr\",\"y\",\"z\",\"float32Array\",\"left\",\"right\",\"offsetLeft\",\"offsetRight\",\"leftChange\",\"forceLeft\",\"terminationIndices\",\"has\",\"nodeIndices\",\"rightChange\",\"forceRight\",\"didChange\",\"_i2\",\"lefti\",\"righti\",\"minLeftValue\",\"maxLeftValue\",\"minRightValue\",\"maxRightValue\",\"Array\",\"isArray\",\"Set\",\"posAttr\",\"attributes\",\"position\",\"l\",\"buffer\",\"Uint32Array\",\"Uint16Array\",\"Float32Array\",\"byteLength\",\"traverse\",\"callback\",\"depth\",\"isLeaf\",\"BYTES_PER_NODE\",\"splitAxis\",\"stopTraversal\",\"rootIndex\",\"raycast\",\"mesh\",\"raycaster\",\"ray\",\"intersects\",\"localIntersects\",\"_iteratorNormalCompletion\",\"_didIteratorError\",\"_iteratorError\",\"_iterator\",\"iterator\",\"_step\",\"done\",\"next\",\"root\",\"setBuffer\",\"clearBuffer\",\"err\",\"localPoint\",\"push\",\"apply\",\"arr\",\"arr2\",\"iter\",\"toString\",\"call\",\"from\",\"raycastFirst\",\"closestResult\",\"_iteratorNormalCompletion2\",\"_didIteratorError2\",\"_iteratorError2\",\"_iterator2\",\"_step2\",\"distance\",\"intersectsGeometry\",\"otherGeometry\",\"geomToMesh\",\"_iteratorNormalCompletion3\",\"_didIteratorError3\",\"_iteratorError3\",\"_iterator3\",\"_step3\",\"shapecast\",\"callbacks\",\"_intersectsTriangleFunc\",\"_orderNodesFunc\",\"Function\",\"originalTriangleFunc\",\"tri\",\"contained\",\"i3\",\"boundsTraverseOrder\",\"intersectsBounds\",\"intersectsTriangle\",\"intersectsRange\",\"console\",\"warn\",\"_callbacks\",\"originalIntersectsRange\",\"nodeIndex\",\"iterateOverTriangles\",\"_iteratorNormalCompletion4\",\"_didIteratorError4\",\"_iteratorError4\",\"_iterator4\",\"_step4\",\"intersectsBox\",\"box\",\"boxToMesh\",\"intersectsSphere\",\"sphere\",\"closestPointToGeometry\",\"geometryToBvh\",\"target1\",\"target2\",\"minThreshold\",\"maxThreshold\",\"computeBoundingBox\",\"pos\",\"otherPos\",\"otherIndex\",\"tempTarget1\",\"tempTarget2\",\"closestDistance\",\"matrix\",\"copy\",\"invert\",\"distanceToBox\",\"score\",\"boundsTree\",\"otherOffset\",\"otherCount\",\"i2\",\"l2\",\"setTriangle\",\"a\",\"applyMatrix4\",\"b\",\"c\",\"dist\",\"distanceToTriangle\",\"triCount\",\"distanceToGeometry\",\"geom\",\"closestPointToPoint\",\"point\",\"minThresholdSq\",\"maxThresholdSq\",\"closestDistanceSq\",\"clamp\",\"distanceToSquared\",\"distSq\",\"sqrt\",\"distanceToPoint\",\"makeEmpty\",\"forEach\",\"arrayToBox\",\"union\"]\n}\n"]