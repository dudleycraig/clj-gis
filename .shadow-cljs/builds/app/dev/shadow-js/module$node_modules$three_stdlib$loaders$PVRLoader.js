["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/PVRLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$PVRLoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=\ndescriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};\nreturn _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};\nreturn _setPrototypeOf(o$jscomp$0,p$jscomp$0)}function _extract(pvrDatas){var pvr={mipmaps:[],width:pvrDatas.width,height:pvrDatas.height,format:pvrDatas.format,mipmapCount:pvrDatas.numMipmaps,isCubemap:pvrDatas.isCubemap},buffer=pvrDatas.buffer,dataOffset=pvrDatas.dataPtr;var blockSize=pvrDatas.bpp;var numSurfs=pvrDatas.numSurfaces;var blockWidth=2===blockSize?8:4;blockSize=4*blockWidth*blockSize/8;pvr.mipmaps.length=pvrDatas.numMipmaps*numSurfs;for(var mipLevel=0;mipLevel<pvrDatas.numMipmaps;){var sWidth=\npvrDatas.width>>mipLevel,sHeight=pvrDatas.height>>mipLevel;var dataSize=sWidth/blockWidth;var heightBlocks=sHeight/4;2>dataSize&&(dataSize=2);2>heightBlocks&&(heightBlocks=2);dataSize=dataSize*heightBlocks*blockSize;for(heightBlocks=0;heightBlocks<numSurfs;heightBlocks++){var mipmap={data:new Uint8Array(buffer,dataOffset,dataSize),width:sWidth,height:sHeight};pvr.mipmaps[heightBlocks*pvrDatas.numMipmaps+mipLevel]=mipmap;dataOffset+=dataSize}mipLevel++}return pvr}Object.defineProperty(exports,\"__esModule\",\n{value:!0});exports.PVRLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_CompressedTextureLoa){function PVRLoader(manager){if(!(this instanceof PVRLoader))throw new TypeError(\"Cannot call a class as a function\");manager=_getPrototypeOf(PVRLoader).call(this,manager);if(!manager||\"object\"!==_typeof(manager)&&\"function\"!==typeof manager){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");manager=this}return manager}\n_inherits(PVRLoader,_CompressedTextureLoa);_createClass(PVRLoader,[{key:\"parse\",value:function(buffer,loadMipmaps){var header=new Uint32Array(buffer,0,13);buffer={buffer,header,loadMipmaps};if(55727696===header[0]){var header$jscomp$0=buffer.header,metaLen=header$jscomp$0[12],pixelFormat=header$jscomp$0[2];header=header$jscomp$0[6];loadMipmaps=header$jscomp$0[7];var numFaces=header$jscomp$0[10];header$jscomp$0=header$jscomp$0[11];switch(pixelFormat){case 0:var bpp=2;var format=_three.RGB_PVRTC_2BPPV1_Format;\nbreak;case 1:bpp=2;format=_three.RGBA_PVRTC_2BPPV1_Format;break;case 2:bpp=4;format=_three.RGB_PVRTC_4BPPV1_Format;break;case 3:bpp=4;format=_three.RGBA_PVRTC_4BPPV1_Format;break;default:console.error(\"THREE.PVRLoader: Unsupported PVR format:\",pixelFormat)}buffer.dataPtr=52+metaLen;buffer.bpp=bpp;buffer.format=format;buffer.width=loadMipmaps;buffer.height=header;buffer.numSurfaces=numFaces;buffer.numMipmaps=header$jscomp$0;buffer.isCubemap=6===numFaces;return _extract(buffer)}if(559044176===header[11]){var header$jscomp$1=\nbuffer.header;bpp=header$jscomp$1[0];format=header$jscomp$1[1];header=header$jscomp$1[2];loadMipmaps=header$jscomp$1[3];numFaces=header$jscomp$1[12];header$jscomp$0=header$jscomp$1[4]&255;header$jscomp$1=0<header$jscomp$1[10];25===header$jscomp$0?(pixelFormat=header$jscomp$1?_three.RGBA_PVRTC_4BPPV1_Format:_three.RGB_PVRTC_4BPPV1_Format,metaLen=4):24===header$jscomp$0?(pixelFormat=header$jscomp$1?_three.RGBA_PVRTC_2BPPV1_Format:_three.RGB_PVRTC_2BPPV1_Format,metaLen=2):console.error(\"THREE.PVRLoader: Unknown PVR format:\",\nheader$jscomp$0);buffer.dataPtr=bpp;buffer.bpp=metaLen;buffer.format=pixelFormat;buffer.width=header;buffer.height=format;buffer.numSurfaces=numFaces;buffer.numMipmaps=loadMipmaps+1;buffer.isCubemap=6===numFaces;return _extract(buffer)}console.error(\"THREE.PVRLoader: Unknown PVR format.\")}}]);return PVRLoader}(_three.CompressedTextureLoader);exports.PVRLoader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$PVRLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PVRLoader = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/*\n *\t PVR v2 (legacy) parser\n *   TODO : Add Support for PVR v3 format\n *   TODO : implement loadMipmaps option\n */\nvar PVRLoader =\n/*#__PURE__*/\nfunction (_CompressedTextureLoa) {\n  _inherits(PVRLoader, _CompressedTextureLoa);\n\n  function PVRLoader(manager) {\n    _classCallCheck(this, PVRLoader);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PVRLoader).call(this, manager));\n  }\n\n  _createClass(PVRLoader, [{\n    key: \"parse\",\n    value: function parse(buffer, loadMipmaps) {\n      var headerLengthInt = 13;\n      var header = new Uint32Array(buffer, 0, headerLengthInt);\n      var pvrDatas = {\n        buffer: buffer,\n        header: header,\n        loadMipmaps: loadMipmaps\n      };\n\n      if (header[0] === 0x03525650) {\n        // PVR v3\n        return _parseV3(pvrDatas);\n      } else if (header[11] === 0x21525650) {\n        // PVR v2\n        return _parseV2(pvrDatas);\n      } else {\n        console.error('THREE.PVRLoader: Unknown PVR format.');\n      }\n    }\n  }]);\n\n  return PVRLoader;\n}(_three.CompressedTextureLoader);\n\nexports.PVRLoader = PVRLoader;\n\nfunction _parseV3(pvrDatas) {\n  var header = pvrDatas.header;\n  var bpp, format;\n  var metaLen = header[12],\n      pixelFormat = header[2],\n      height = header[6],\n      width = header[7],\n      // numSurfs = header[ 9 ],\n  numFaces = header[10],\n      numMipmaps = header[11];\n\n  switch (pixelFormat) {\n    case 0:\n      // PVRTC 2bpp RGB\n      bpp = 2;\n      format = _three.RGB_PVRTC_2BPPV1_Format;\n      break;\n\n    case 1:\n      // PVRTC 2bpp RGBA\n      bpp = 2;\n      format = _three.RGBA_PVRTC_2BPPV1_Format;\n      break;\n\n    case 2:\n      // PVRTC 4bpp RGB\n      bpp = 4;\n      format = _three.RGB_PVRTC_4BPPV1_Format;\n      break;\n\n    case 3:\n      // PVRTC 4bpp RGBA\n      bpp = 4;\n      format = _three.RGBA_PVRTC_4BPPV1_Format;\n      break;\n\n    default:\n      console.error('THREE.PVRLoader: Unsupported PVR format:', pixelFormat);\n  }\n\n  pvrDatas.dataPtr = 52 + metaLen;\n  pvrDatas.bpp = bpp;\n  pvrDatas.format = format;\n  pvrDatas.width = width;\n  pvrDatas.height = height;\n  pvrDatas.numSurfaces = numFaces;\n  pvrDatas.numMipmaps = numMipmaps;\n  pvrDatas.isCubemap = numFaces === 6;\n  return _extract(pvrDatas);\n}\n\nfunction _parseV2(pvrDatas) {\n  var header = pvrDatas.header;\n  var headerLength = header[0],\n      height = header[1],\n      width = header[2],\n      numMipmaps = header[3],\n      flags = header[4],\n      // dataLength = header[ 5 ],\n  // bpp =  header[ 6 ],\n  // bitmaskRed = header[ 7 ],\n  // bitmaskGreen = header[ 8 ],\n  // bitmaskBlue = header[ 9 ],\n  bitmaskAlpha = header[10],\n      // pvrTag = header[ 11 ],\n  numSurfs = header[12];\n  var TYPE_MASK = 0xff;\n  var PVRTC_2 = 24,\n      PVRTC_4 = 25;\n  var formatFlags = flags & TYPE_MASK;\n  var bpp, format;\n\n  var _hasAlpha = bitmaskAlpha > 0;\n\n  if (formatFlags === PVRTC_4) {\n    format = _hasAlpha ? _three.RGBA_PVRTC_4BPPV1_Format : _three.RGB_PVRTC_4BPPV1_Format;\n    bpp = 4;\n  } else if (formatFlags === PVRTC_2) {\n    format = _hasAlpha ? _three.RGBA_PVRTC_2BPPV1_Format : _three.RGB_PVRTC_2BPPV1_Format;\n    bpp = 2;\n  } else {\n    console.error('THREE.PVRLoader: Unknown PVR format:', formatFlags);\n  }\n\n  pvrDatas.dataPtr = headerLength;\n  pvrDatas.bpp = bpp;\n  pvrDatas.format = format;\n  pvrDatas.width = width;\n  pvrDatas.height = height;\n  pvrDatas.numSurfaces = numSurfs;\n  pvrDatas.numMipmaps = numMipmaps + 1; // guess cubemap type seems tricky in v2\n  // it juste a pvr containing 6 surface (no explicit cubemap type)\n\n  pvrDatas.isCubemap = numSurfs === 6;\n  return _extract(pvrDatas);\n}\n\nfunction _extract(pvrDatas) {\n  var pvr = {\n    mipmaps: [],\n    width: pvrDatas.width,\n    height: pvrDatas.height,\n    format: pvrDatas.format,\n    mipmapCount: pvrDatas.numMipmaps,\n    isCubemap: pvrDatas.isCubemap\n  };\n  var buffer = pvrDatas.buffer;\n  var dataOffset = pvrDatas.dataPtr,\n      dataSize = 0,\n      blockSize = 0,\n      blockWidth = 0,\n      blockHeight = 0,\n      widthBlocks = 0,\n      heightBlocks = 0;\n  var bpp = pvrDatas.bpp,\n      numSurfs = pvrDatas.numSurfaces;\n\n  if (bpp === 2) {\n    blockWidth = 8;\n    blockHeight = 4;\n  } else {\n    blockWidth = 4;\n    blockHeight = 4;\n  }\n\n  blockSize = blockWidth * blockHeight * bpp / 8;\n  pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\n  var mipLevel = 0;\n\n  while (mipLevel < pvrDatas.numMipmaps) {\n    var sWidth = pvrDatas.width >> mipLevel,\n        sHeight = pvrDatas.height >> mipLevel;\n    widthBlocks = sWidth / blockWidth;\n    heightBlocks = sHeight / blockHeight; // Clamp to minimum number of blocks\n\n    if (widthBlocks < 2) widthBlocks = 2;\n    if (heightBlocks < 2) heightBlocks = 2;\n    dataSize = widthBlocks * heightBlocks * blockSize;\n\n    for (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {\n      var byteArray = new Uint8Array(buffer, dataOffset, dataSize);\n      var mipmap = {\n        data: byteArray,\n        width: sWidth,\n        height: sHeight\n      };\n      pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;\n      dataOffset += dataSize;\n    }\n\n    mipLevel++;\n  }\n\n  return pvr;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["mipmaps","width","prototype","height","key","numMipmaps","__esModule","mipmapCount","bpp","buffer","configurable","dataPtr","value","enumerable","isCubemap","writable","length","loadMipmaps","__proto__","numSurfaces","PVRLoader","data","header","format","constructor"]],"~:compiled-at",1630917515884,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$PVRLoader.js\",\n\"lineCount\":10,\n\"mappings\":\"AAAAA,cAAA,CAAA,kDAAA,CAAuE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAU/GC,QAASA,QAAO,CAACC,YAAD,CAAM,CAA6ED,OAAA,CAArD,UAAtB,GAAI,MAAOE,OAAX,EAA+D,QAA/D,GAAoC,MAAOA,OAAOC,CAAAA,QAAlD,CAAqFH,QAAgB,CAACC,GAAD,CAAM,CAAE,MAAO,OAAOA,IAAhB,CAA3G,CAAsJD,QAAgB,CAACC,GAAD,CAAM,CAAE,MAAOA,IAAA,EAAyB,UAAzB,GAAO,MAAOC,OAAd,EAAuCD,GAAIG,CAAAA,WAA3C,GAA2DF,MAA3D,EAAqED,GAArE,GAA6EC,MAAOG,CAAAA,SAApF,CAAgG,QAAhG,CAA2G,MAAOJ,IAA3H,CAAqI,OAAOD,QAAA,CAAQC,YAAR,CAA1T,CAItBK,QAASA,kBAAiB,CAACC,MAAD,CAASC,KAAT,CAAgB,CAAE,IAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBD,KAAME,CAAAA,MAA1B,CAAkCD,CAAA,EAAlC,CAAuC,CAAE,IAAIE,WAAaH,KAAA,CAAMC,CAAN,CAAUE,WAAWC,CAAAA,UAAX;AAAwBD,UAAWC,CAAAA,UAAnC,EAAiD,CAAA,CAAOD,WAAWE,CAAAA,YAAX,CAA0B,CAAA,CAAU,QAAJ,EAAeF,WAAf,GAA2BA,UAAWG,CAAAA,QAAtC,CAAiD,CAAA,CAAjD,CAAuDC,OAAOC,CAAAA,cAAP,CAAsBT,MAAtB,CAA8BI,UAAWM,CAAAA,GAAzC,CAA8CN,UAA9C,CAA5K,CAAzC,CAE1CO,QAASA,aAAY,CAACC,WAAD,CAAcC,UAAd,CAA0BC,WAA1B,CAAuC,CAAMD,UAAJ,EAAgBd,iBAAA,CAAkBa,WAAYd,CAAAA,SAA9B,CAAyCe,UAAzC,CAA0DC,YAAJ,EAAiBf,iBAAA,CAAkBa,WAAlB,CAA+BE,WAA/B,CAA6C,OAAOF,YAA7I,CAM5DG,QAASA,gBAAe,CAACC,UAAD,CAAI,CAAED,eAAA,CAAkBP,MAAOS,CAAAA,cAAP,CAAwBT,MAAOU,CAAAA,cAA/B,CAAgDH,QAAwB,CAACC,CAAD,CAAI,CAAE,MAAOA,EAAEG,CAAAA,SAAT,EAAsBX,MAAOU,CAAAA,cAAP,CAAsBF,CAAtB,CAAxB,CAAqD;MAAOD,gBAAA,CAAgBC,UAAhB,CAA5J,CAE5BI,QAASA,UAAS,CAACC,QAAD,CAAWC,UAAX,CAAuB,CAAE,GAA0B,UAA1B,GAAI,MAAOA,WAAX,EAAuD,IAAvD,GAAwCA,UAAxC,CAA+D,KAAM,KAAIC,SAAJ,CAAc,oDAAd,CAAN,CAA6EF,QAASvB,CAAAA,SAAT,CAAqBU,MAAOgB,CAAAA,MAAP,CAAcF,UAAd,EAA4BA,UAAWxB,CAAAA,SAAvC,CAAkD,CAAED,YAAa,CAAE4B,MAAOJ,QAAT,CAAmBd,SAAU,CAAA,CAA7B,CAAmCD,aAAc,CAAA,CAAjD,CAAf,CAAlD,CAAiIgB,WAAJ,EAAgBI,eAAA,CAAgBL,QAAhB,CAA0BC,UAA1B,CAAhT,CAEzCI,QAASA,gBAAe,CAACV,UAAD,CAAIW,UAAJ,CAAO,CAAED,eAAA,CAAkBlB,MAAOS,CAAAA,cAAzB,EAA2CS,QAAwB,CAACV,CAAD,CAAIW,CAAJ,CAAO,CAAEX,CAAEG,CAAAA,SAAF,CAAcQ,CAAG,OAAOX,EAA1B,CAAgC;MAAOU,gBAAA,CAAgBV,UAAhB,CAAmBW,UAAnB,CAAnH,CA+I/BC,QAASA,SAAQ,CAACC,QAAD,CAAW,CAC1B,IAAIC,IAAM,CACRC,QAAS,EADD,CAERC,MAAOH,QAASG,CAAAA,KAFR,CAGRC,OAAQJ,QAASI,CAAAA,MAHT,CAIRC,OAAQL,QAASK,CAAAA,MAJT,CAKRC,YAAaN,QAASO,CAAAA,UALd,CAMRC,UAAWR,QAASQ,CAAAA,SANZ,CAAV,CAQIC,OAAST,QAASS,CAAAA,MARtB,CASIC,WAAaV,QAASW,CAAAA,OAOtBC,KAAAA,UAAMZ,QAASY,CAAAA,GAAnB,KACIC,SAAWb,QAASc,CAAAA,WAGtB,KAAAC,WADU,CAAZ,GAAIH,SAAJ,CACe,CADf,CAIe,CAIfI,UAAA,CANgBC,CAMhB,CAAYF,UAAZ,CAAuCH,SAAvC,CAA6C,CAC7CX,IAAIC,CAAAA,OAAQ5B,CAAAA,MAAZ,CAAqB0B,QAASO,CAAAA,UAA9B,CAA2CM,QAG3C,KAFA,IAAIK,SAAW,CAEf,CAAOA,QAAP,CAAkBlB,QAASO,CAAAA,UAA3B,CAAA,CAAuC,CAAA,IACjCY;AAASnB,QAASG,CAAAA,KAAlBgB,EAA2BD,QADM,CAEjCE,QAAUpB,QAASI,CAAAA,MAAnBgB,EAA6BF,QACjC,KAAAG,SAAcF,MAAdE,CAAuBN,UACvB,KAAAO,aAAeF,OAAfE,CAdcL,CAgBI,EAAlB,CAAII,QAAJ,GAAqBA,QAArB,CAAmC,CAAnC,CACmB,EAAnB,CAAIC,YAAJ,GAAsBA,YAAtB,CAAqC,CAArC,CACAC,SAAA,CAAWF,QAAX,CAAyBC,YAAzB,CAAwCN,SAExC,KAASQ,YAAT,CAAqB,CAArB,CAAwBA,YAAxB,CAAoCX,QAApC,CAA8CW,YAAA,EAA9C,CAA2D,CAEzD,IAAIC,OAAS,CACXC,KAFcC,IAAIC,UAAJD,CAAelB,MAAfkB,CAAuBjB,UAAvBiB,CAAmCJ,QAAnCI,CACH,CAEXxB,MAAOgB,MAFI,CAGXf,OAAQgB,OAHG,CAKbnB,IAAIC,CAAAA,OAAJ,CAAYsB,YAAZ,CAAwBxB,QAASO,CAAAA,UAAjC,CAA8CW,QAA9C,CAAA,CAA0DO,MAC1Df,WAAA,EAAca,QAR2C,CAW3DL,QAAA,EArBqC,CAwBvC,MAAOjB,IAxDmB,CAtK5BtB,MAAOC,CAAAA,cAAP,CAAsBjB,OAAtB,CAA+B,YAA/B;AAA6C,CAC3CiC,MAAO,CAAA,CADoC,CAA7C,CAGAjC,QAAQkE,CAAAA,SAAR,CAAoB,IAAK,EAEzB,KAAIC,OAASrE,OAAA,CAAQ,8CAAR,CAyBToE,OAAAA,CAEJ,QAAS,CAACE,qBAAD,CAAwB,CAG/BF,QAASA,UAAS,CAACG,OAAD,CAAU,CA1BoB,GAAI,EA2BlCC,IA3BkC,WA2B5BJ,UA3B4B,CAAJ,CAA0C,KAAM,KAAInC,SAAJ,CAAc,mCAAd,CAAN,CA6BhD,OAAA,CAAAR,eAAA,CAAgB2C,SAAhB,CAA2BK,CAAAA,IAA3B,CAAgC,IAAhC,CAAsCF,OAAtC,CAvBM,IAAIE,CAAAA,OAAJ,EAA+B,QAA/B,GAAatE,OAAA,CAAQsE,OAAR,CAAb,EAA2D,UAA3D,GAA2C,MAAOA,QAAlD,CAAA,CAEV,GAAa,IAAK,EAAlB,GAF0GC,IAE1G,CAAuB,KAAM,KAAIC,cAAJ,CAAmB,2DAAnB,CAAN,CAAyF,OAAA,CAFND,IAAhG,CAuB9C,MAvB8C,QAoBpB;AAF5B5C,SAAA,CAAUsC,SAAV,CAAqBE,qBAArB,CAQAjD,aAAA,CAAa+C,SAAb,CAAwB,CAAC,CACvBhD,IAAK,OADkB,CAEvBe,MAAOyC,QAAc,CAAC5B,MAAD,CAAS6B,WAAT,CAAsB,CAEzC,IAAIC,OAAS,IAAIC,WAAJ,CAAgB/B,MAAhB,CAAwB,CAAxB,CADSgC,EACT,CACTzC,OAAAA,CAAW,CACLS,MADK,CAEL8B,MAFK,CAGAD,WAHA,CAMf,IAAkB,QAAlB,GAAIC,MAAA,CAAO,CAAP,CAAJ,CAA8B,CAkBlC,IAAIA,gBAhBkBvC,MAgBAuC,CAAAA,MAAtB,CAEIG,QAAUH,eAAA,CAAO,EAAP,CAFd,CAGII,YAAcJ,eAAA,CAAO,CAAP,CACdnC,OAAAA,CAASmC,eAAA,CAAO,CAAP,CACTpC,YAAAA,CAAQoC,eAAA,CAAO,CAAP,CANc,KAQ1BK,SAAWL,eAAA,CAAO,EAAP,CACPhC,gBAAAA,CAAagC,eAAA,CAAO,EAAP,CAEjB,QAAQI,WAAR,EACE,KAAK,CAAL,CAEE,IAAA/B,IAAM,CACN,KAAAP,OAASyB,MAAOe,CAAAA,uBAChB;KAEF,MAAK,CAAL,CAEEjC,GAAA,CAAM,CACNP,OAAA,CAASyB,MAAOgB,CAAAA,wBAChB,MAEF,MAAK,CAAL,CAEElC,GAAA,CAAM,CACNP,OAAA,CAASyB,MAAOiB,CAAAA,uBAChB,MAEF,MAAK,CAAL,CAEEnC,GAAA,CAAM,CACNP,OAAA,CAASyB,MAAOkB,CAAAA,wBAChB,MAEF,SACEC,OAAQC,CAAAA,KAAR,CAAc,0CAAd,CAA0DP,WAA1D,CA1BJ,CA1BsB3C,MAuDbW,CAAAA,OAAT,CAAmB,EAAnB,CAAwB+B,OAvDF1C,OAwDbY,CAAAA,GAAT,CAAeA,GAxDOZ,OAyDbK,CAAAA,MAAT,CAAkBA,MAzDIL,OA0DbG,CAAAA,KAAT,CAAiBA,WA1DKH,OA2DbI,CAAAA,MAAT,CAAkBA,MA3DIJ,OA4Dbc,CAAAA,WAAT,CAAuB8B,QA5DD5C,OA6DbO,CAAAA,UAAT,CAAsBA,eA7DAP,OA8DbQ,CAAAA,SAAT,CAAkC,CAAlC,GAAqBoC,QA9Df,OA+DC7C,SAAA,CA/DeC,MA+Df,CAjE2B,CAGvB,GAAmB,SAAnB,GAAIuC,MAAA,CAAO,EAAP,CAAJ,CAA+B,CAkE1C,IAAIA;AAhEkBvC,MAgEAuC,CAAAA,MAClBY,IAAAA,CAAeZ,eAAA,CAAO,CAAP,CACfnC,OAAAA,CAASmC,eAAA,CAAO,CAAP,CACTpC,OAAAA,CAAQoC,eAAA,CAAO,CAAP,CACRhC,YAAAA,CAAagC,eAAA,CAAO,CAAP,CASjB1B,SAAAA,CAAW0B,eAAA,CAAO,EAAP,CAIPa,gBAAAA,CAZQb,eAAAc,CAAO,CAAPA,CAYRD,CAHYE,GAMZC,gBAAAA,CAA2B,CAA3BA,CATWhB,eAAAiB,CAAO,EAAPA,CAKDC,GAMd,GAAIL,eAAJ,EACE/C,WACA,CADSkD,eAAA,CAAYzB,MAAOkB,CAAAA,wBAAnB,CAA8ClB,MAAOiB,CAAAA,uBAC9D,CAAAnC,OAAA,CAAM,CAFR,EAPc8C,EAUP,GAAIN,eAAJ,EACL/C,WACA,CADSkD,eAAA,CAAYzB,MAAOgB,CAAAA,wBAAnB,CAA8ChB,MAAOe,CAAAA,uBAC9D,CAAAjC,OAAA,CAAM,CAFD,EAILqC,OAAQC,CAAAA,KAAR,CAAc,sCAAd;AAAsDE,eAAtD,CA7FoBpD,OAgGbW,CAAAA,OAAT,CAAmBwC,GAhGGnD,OAiGbY,CAAAA,GAAT,CAAeA,OAjGOZ,OAkGbK,CAAAA,MAAT,CAAkBA,WAlGIL,OAmGbG,CAAAA,KAAT,CAAiBA,MAnGKH,OAoGbI,CAAAA,MAAT,CAAkBA,MApGIJ,OAqGbc,CAAAA,WAAT,CAAuBD,QArGDb,OAsGbO,CAAAA,UAAT,CAAsBA,WAAtB,CAAmC,CAtGbP,OAyGbQ,CAAAA,SAAT,CAAkC,CAAlC,GAAqBK,QAzGf,OA0GCd,SAAA,CA1GeC,MA0Gf,CA5GmC,CAIpCiD,OAAQC,CAAAA,KAAR,CAAc,sCAAd,CAhBuC,CAFpB,CAAD,CAAxB,CAuBA,OAAOrB,UAhCwB,CAAjC,CAiCEC,MAAO6B,CAAAA,uBAjCT,CAmCAhG,QAAQkE,CAAAA,SAAR,CAAoBA,MAtE2F;\",\n\"sources\":[\"node_modules/three-stdlib/loaders/PVRLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$PVRLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.PVRLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/*\\n *\\t PVR v2 (legacy) parser\\n *   TODO : Add Support for PVR v3 format\\n *   TODO : implement loadMipmaps option\\n */\\nvar PVRLoader =\\n/*#__PURE__*/\\nfunction (_CompressedTextureLoa) {\\n  _inherits(PVRLoader, _CompressedTextureLoa);\\n\\n  function PVRLoader(manager) {\\n    _classCallCheck(this, PVRLoader);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(PVRLoader).call(this, manager));\\n  }\\n\\n  _createClass(PVRLoader, [{\\n    key: \\\"parse\\\",\\n    value: function parse(buffer, loadMipmaps) {\\n      var headerLengthInt = 13;\\n      var header = new Uint32Array(buffer, 0, headerLengthInt);\\n      var pvrDatas = {\\n        buffer: buffer,\\n        header: header,\\n        loadMipmaps: loadMipmaps\\n      };\\n\\n      if (header[0] === 0x03525650) {\\n        // PVR v3\\n        return _parseV3(pvrDatas);\\n      } else if (header[11] === 0x21525650) {\\n        // PVR v2\\n        return _parseV2(pvrDatas);\\n      } else {\\n        console.error('THREE.PVRLoader: Unknown PVR format.');\\n      }\\n    }\\n  }]);\\n\\n  return PVRLoader;\\n}(_three.CompressedTextureLoader);\\n\\nexports.PVRLoader = PVRLoader;\\n\\nfunction _parseV3(pvrDatas) {\\n  var header = pvrDatas.header;\\n  var bpp, format;\\n  var metaLen = header[12],\\n      pixelFormat = header[2],\\n      height = header[6],\\n      width = header[7],\\n      // numSurfs = header[ 9 ],\\n  numFaces = header[10],\\n      numMipmaps = header[11];\\n\\n  switch (pixelFormat) {\\n    case 0:\\n      // PVRTC 2bpp RGB\\n      bpp = 2;\\n      format = _three.RGB_PVRTC_2BPPV1_Format;\\n      break;\\n\\n    case 1:\\n      // PVRTC 2bpp RGBA\\n      bpp = 2;\\n      format = _three.RGBA_PVRTC_2BPPV1_Format;\\n      break;\\n\\n    case 2:\\n      // PVRTC 4bpp RGB\\n      bpp = 4;\\n      format = _three.RGB_PVRTC_4BPPV1_Format;\\n      break;\\n\\n    case 3:\\n      // PVRTC 4bpp RGBA\\n      bpp = 4;\\n      format = _three.RGBA_PVRTC_4BPPV1_Format;\\n      break;\\n\\n    default:\\n      console.error('THREE.PVRLoader: Unsupported PVR format:', pixelFormat);\\n  }\\n\\n  pvrDatas.dataPtr = 52 + metaLen;\\n  pvrDatas.bpp = bpp;\\n  pvrDatas.format = format;\\n  pvrDatas.width = width;\\n  pvrDatas.height = height;\\n  pvrDatas.numSurfaces = numFaces;\\n  pvrDatas.numMipmaps = numMipmaps;\\n  pvrDatas.isCubemap = numFaces === 6;\\n  return _extract(pvrDatas);\\n}\\n\\nfunction _parseV2(pvrDatas) {\\n  var header = pvrDatas.header;\\n  var headerLength = header[0],\\n      height = header[1],\\n      width = header[2],\\n      numMipmaps = header[3],\\n      flags = header[4],\\n      // dataLength = header[ 5 ],\\n  // bpp =  header[ 6 ],\\n  // bitmaskRed = header[ 7 ],\\n  // bitmaskGreen = header[ 8 ],\\n  // bitmaskBlue = header[ 9 ],\\n  bitmaskAlpha = header[10],\\n      // pvrTag = header[ 11 ],\\n  numSurfs = header[12];\\n  var TYPE_MASK = 0xff;\\n  var PVRTC_2 = 24,\\n      PVRTC_4 = 25;\\n  var formatFlags = flags & TYPE_MASK;\\n  var bpp, format;\\n\\n  var _hasAlpha = bitmaskAlpha > 0;\\n\\n  if (formatFlags === PVRTC_4) {\\n    format = _hasAlpha ? _three.RGBA_PVRTC_4BPPV1_Format : _three.RGB_PVRTC_4BPPV1_Format;\\n    bpp = 4;\\n  } else if (formatFlags === PVRTC_2) {\\n    format = _hasAlpha ? _three.RGBA_PVRTC_2BPPV1_Format : _three.RGB_PVRTC_2BPPV1_Format;\\n    bpp = 2;\\n  } else {\\n    console.error('THREE.PVRLoader: Unknown PVR format:', formatFlags);\\n  }\\n\\n  pvrDatas.dataPtr = headerLength;\\n  pvrDatas.bpp = bpp;\\n  pvrDatas.format = format;\\n  pvrDatas.width = width;\\n  pvrDatas.height = height;\\n  pvrDatas.numSurfaces = numSurfs;\\n  pvrDatas.numMipmaps = numMipmaps + 1; // guess cubemap type seems tricky in v2\\n  // it juste a pvr containing 6 surface (no explicit cubemap type)\\n\\n  pvrDatas.isCubemap = numSurfs === 6;\\n  return _extract(pvrDatas);\\n}\\n\\nfunction _extract(pvrDatas) {\\n  var pvr = {\\n    mipmaps: [],\\n    width: pvrDatas.width,\\n    height: pvrDatas.height,\\n    format: pvrDatas.format,\\n    mipmapCount: pvrDatas.numMipmaps,\\n    isCubemap: pvrDatas.isCubemap\\n  };\\n  var buffer = pvrDatas.buffer;\\n  var dataOffset = pvrDatas.dataPtr,\\n      dataSize = 0,\\n      blockSize = 0,\\n      blockWidth = 0,\\n      blockHeight = 0,\\n      widthBlocks = 0,\\n      heightBlocks = 0;\\n  var bpp = pvrDatas.bpp,\\n      numSurfs = pvrDatas.numSurfaces;\\n\\n  if (bpp === 2) {\\n    blockWidth = 8;\\n    blockHeight = 4;\\n  } else {\\n    blockWidth = 4;\\n    blockHeight = 4;\\n  }\\n\\n  blockSize = blockWidth * blockHeight * bpp / 8;\\n  pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\\n  var mipLevel = 0;\\n\\n  while (mipLevel < pvrDatas.numMipmaps) {\\n    var sWidth = pvrDatas.width >> mipLevel,\\n        sHeight = pvrDatas.height >> mipLevel;\\n    widthBlocks = sWidth / blockWidth;\\n    heightBlocks = sHeight / blockHeight; // Clamp to minimum number of blocks\\n\\n    if (widthBlocks < 2) widthBlocks = 2;\\n    if (heightBlocks < 2) heightBlocks = 2;\\n    dataSize = widthBlocks * heightBlocks * blockSize;\\n\\n    for (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {\\n      var byteArray = new Uint8Array(buffer, dataOffset, dataSize);\\n      var mipmap = {\\n        data: byteArray,\\n        width: sWidth,\\n        height: sHeight\\n      };\\n      pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;\\n      dataOffset += dataSize;\\n    }\\n\\n    mipLevel++;\\n  }\\n\\n  return pvr;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"_extract\",\"pvrDatas\",\"pvr\",\"mipmaps\",\"width\",\"height\",\"format\",\"mipmapCount\",\"numMipmaps\",\"isCubemap\",\"buffer\",\"dataOffset\",\"dataPtr\",\"bpp\",\"numSurfs\",\"numSurfaces\",\"blockWidth\",\"blockSize\",\"blockHeight\",\"mipLevel\",\"sWidth\",\"sHeight\",\"widthBlocks\",\"heightBlocks\",\"dataSize\",\"surfIndex\",\"mipmap\",\"data\",\"byteArray\",\"Uint8Array\",\"PVRLoader\",\"_three\",\"_CompressedTextureLoa\",\"manager\",\"instance\",\"call\",\"self\",\"ReferenceError\",\"parse\",\"loadMipmaps\",\"header\",\"Uint32Array\",\"headerLengthInt\",\"metaLen\",\"pixelFormat\",\"numFaces\",\"RGB_PVRTC_2BPPV1_Format\",\"RGBA_PVRTC_2BPPV1_Format\",\"RGB_PVRTC_4BPPV1_Format\",\"RGBA_PVRTC_4BPPV1_Format\",\"console\",\"error\",\"headerLength\",\"formatFlags\",\"flags\",\"TYPE_MASK\",\"_hasAlpha\",\"bitmaskAlpha\",\"PVRTC_4\",\"PVRTC_2\",\"CompressedTextureLoader\"]\n}\n"]