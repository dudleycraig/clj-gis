["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/misc/ProgressiveLightmap.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$misc$ProgressiveLightmap=function(global,require,module,exports){function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);\nstaticProps&&_defineProperties(Constructor,staticProps);return Constructor}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ProgressiveLightMap=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_potpack=function(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}(require(\"module$node_modules$potpack$index_mjs\"));global=function(){function ProgressiveLightMap(renderer){var _this=this,res=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1024;if(!(this instanceof\nProgressiveLightMap))throw new TypeError(\"Cannot call a class as a function\");this.renderer=renderer;this.res=res;this.lightMapContainers=[];this.compiled=!1;this.scene=new _three.Scene;this.scene.background=null;this.tinyTarget=new _three.WebGLRenderTarget(1,1);this.buffer1Active=!1;this.firstUpdate=!0;this.warned=!1;res=/(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent)?alfFloatType:_three.FloatType;this.progressiveLightMap1=new _three.WebGLRenderTarget(this.res,this.res,{type:res});this.progressiveLightMap2=\nnew _three.WebGLRenderTarget(this.res,this.res,{type:res});this.uvMat=new _three.MeshPhongMaterial;this.uvMat.uniforms={};this.uvMat.onBeforeCompile=function(shader){shader.vertexShader=\"#define USE_LIGHTMAP\\n\"+shader.vertexShader.slice(0,-1)+\"\\tgl_Position \\x3d vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }\";var bodyStart=shader.fragmentShader.indexOf(\"void main() {\");shader.fragmentShader=\"varying vec2 vUv2;\\n\"+shader.fragmentShader.slice(0,bodyStart)+\"\\tuniform sampler2D previousShadowMap;\\n\\tuniform float averagingWindow;\\n\"+\nshader.fragmentShader.slice(bodyStart-1,-1)+\"\\nvec3 texelOld \\x3d texture2D(previousShadowMap, vUv2).rgb;\\n\\t\\t\\t\\tgl_FragColor.rgb \\x3d mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\\n\\t\\t\\t}\";shader.uniforms.previousShadowMap={value:_this.progressiveLightMap1.texture};shader.uniforms.averagingWindow={value:100};_this.uvMat.uniforms=shader.uniforms;_this.uvMat.userData.shader=shader;_this.compiled=!0}}_createClass(ProgressiveLightMap,[{key:\"addObjectsToLightMap\",value:function(objects){this.uv_boxes=\n[];for(var padding=3/this.res,ob=0;ob<objects.length;ob++){var object=objects[ob];object.isLight?this.scene.attach(object):object.geometry.hasAttribute(\"uv\")?(null==this.blurringPlane&&this._initializeBlurPlane(this.res,this.progressiveLightMap1),object.material.lightMap=this.progressiveLightMap2.texture,object.material.dithering=!0,object.castShadow=!0,object.receiveShadow=!0,object.renderOrder=1E3+ob,this.uv_boxes.push({w:1+2*padding,h:1+2*padding,index:ob}),this.lightMapContainers.push({basicMat:object.material,\nobject}),this.compiled=!1):console.warn(\"All lightmap objects need UVs!\")}var dimensions=(0,_potpack[\"default\"])(this.uv_boxes);this.uv_boxes.forEach(function(box){for(var uv2=objects[box.index].geometry.getAttribute(\"uv\").clone(),i=0;i<uv2.array.length;i+=uv2.itemSize)uv2.array[i]=(uv2.array[i]+box.x+padding)/dimensions.w,uv2.array[i+1]=(uv2.array[i+1]+box.y+padding)/dimensions.h;objects[box.index].geometry.setAttribute(\"uv2\",uv2);objects[box.index].geometry.getAttribute(\"uv2\").needsUpdate=!0})}},\n{key:\"update\",value:function(camera){var blendWindow=1<arguments.length&&void 0!==arguments[1]?arguments[1]:100,blurEdges=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!0;if(null!=this.blurringPlane){var oldTarget=this.renderer.getRenderTarget();this.blurringPlane.visible=blurEdges;for(blurEdges=0;blurEdges<this.lightMapContainers.length;blurEdges++)this.lightMapContainers[blurEdges].object.oldScene=this.lightMapContainers[blurEdges].object.parent,this.scene.attach(this.lightMapContainers[blurEdges].object);\nthis.firstUpdate&&(this.renderer.setRenderTarget(this.tinyTarget),this.renderer.render(this.scene,camera),this.firstUpdate=!1);for(blurEdges=0;blurEdges<this.lightMapContainers.length;blurEdges++)this.uvMat.uniforms.averagingWindow={value:blendWindow},this.lightMapContainers[blurEdges].object.material=this.uvMat,this.lightMapContainers[blurEdges].object.oldFrustumCulled=this.lightMapContainers[blurEdges].object.frustumCulled,this.lightMapContainers[blurEdges].object.frustumCulled=!1;blendWindow=this.buffer1Active?\nthis.progressiveLightMap2:this.progressiveLightMap1;this.renderer.setRenderTarget(this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2);this.uvMat.uniforms.previousShadowMap={value:blendWindow.texture};this.blurringPlane.material.uniforms.previousShadowMap={value:blendWindow.texture};this.buffer1Active=!this.buffer1Active;this.renderer.render(this.scene,camera);for(blendWindow=0;blendWindow<this.lightMapContainers.length;blendWindow++)this.lightMapContainers[blendWindow].object.frustumCulled=\nthis.lightMapContainers[blendWindow].object.oldFrustumCulled,this.lightMapContainers[blendWindow].object.material=this.lightMapContainers[blendWindow].basicMat,this.lightMapContainers[blendWindow].object.oldScene.attach(this.lightMapContainers[blendWindow].object);this.renderer.setRenderTarget(oldTarget)}}},{key:\"showDebugLightmap\",value:function(visible){var position=1<arguments.length&&void 0!==arguments[1]?arguments[1]:void 0;0==this.lightMapContainers.length?this.warned||(console.warn(\"Call this after adding the objects!\"),\nthis.warned=!0):(null==this.labelMesh&&(this.labelMaterial=new _three.MeshBasicMaterial({map:this.progressiveLightMap1.texture,side:_three.DoubleSide}),this.labelPlane=new _three.PlaneGeometry(100,100),this.labelMesh=new _three.Mesh(this.labelPlane,this.labelMaterial),this.labelMesh.position.y=250,this.lightMapContainers[0].object.parent.add(this.labelMesh)),void 0!=position&&this.labelMesh.position.copy(position),this.labelMesh.visible=visible)}},{key:\"_initializeBlurPlane\",value:function(res){var _this2=\nthis,lightMap=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null,blurMaterial=new _three.MeshBasicMaterial;blurMaterial.uniforms={previousShadowMap:{value:null},pixelOffset:{value:1/res},polygonOffset:!0,polygonOffsetFactor:-1,polygonOffsetUnits:3};blurMaterial.onBeforeCompile=function(shader){shader.vertexShader=\"#define USE_UV\\n\"+shader.vertexShader.slice(0,-1)+\"\\tgl_Position \\x3d vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";var bodyStart=shader.fragmentShader.indexOf(\"void main() {\");shader.fragmentShader=\n\"#define USE_UV\\n\"+shader.fragmentShader.slice(0,bodyStart)+\"\\tuniform sampler2D previousShadowMap;\\n\\tuniform float pixelOffset;\\n\"+shader.fragmentShader.slice(bodyStart-1,-1)+\"\\tgl_FragColor.rgb \\x3d (\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\\n\\t\\t}\";\nshader.uniforms.previousShadowMap={value:lightMap.texture};shader.uniforms.pixelOffset={value:.5/res};blurMaterial.uniforms=shader.uniforms;blurMaterial.userData.shader=shader;_this2.compiled=!0};this.blurringPlane=new _three.Mesh(new _three.PlaneBufferGeometry(1,1),blurMaterial);this.blurringPlane.name=\"Blurring Plane\";this.blurringPlane.frustumCulled=!1;this.blurringPlane.renderOrder=0;this.blurringPlane.material.depthWrite=!1;this.scene.add(this.blurringPlane)}}]);return ProgressiveLightMap}();\nexports.ProgressiveLightMap=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$misc$ProgressiveLightmap\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProgressiveLightMap = void 0;\n\nvar _three = require(\"three\");\n\nvar _potpack = _interopRequireDefault(require(\"potpack\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\nvar ProgressiveLightMap =\n/*#__PURE__*/\nfunction () {\n  function ProgressiveLightMap(renderer) {\n    var _this = this;\n\n    var res = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n\n    _classCallCheck(this, ProgressiveLightMap);\n\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new _three.Scene();\n    this.scene.background = null;\n    this.tinyTarget = new _three.WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false; // Create the Progressive LightMap Texture\n\n    var format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : _three.FloatType;\n    this.progressiveLightMap1 = new _three.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new _three.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new _three.MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n\n    this.uvMat.onBeforeCompile = function (shader) {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_LIGHTMAP\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      var bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = 'varying vec2 vUv2;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\\n\\t\\t\\t\\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\\n\\t\\t\\t}\"; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = {\n        value: _this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      _this.uvMat.uniforms = shader.uniforms; // Set the new Shader to this\n\n      _this.uvMat.userData.shader = shader;\n      _this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n\n\n  _createClass(ProgressiveLightMap, [{\n    key: \"addObjectsToLightMap\",\n    value: function addObjectsToLightMap(objects) {\n      // Prepare list of UV bounding boxes for packing later...\n      this.uv_boxes = [];\n      var padding = 3 / this.res;\n\n      for (var ob = 0; ob < objects.length; ob++) {\n        var object = objects[ob]; // If this object is a light, simply add it to the internal scene\n\n        if (object.isLight) {\n          this.scene.attach(object);\n          continue;\n        }\n\n        if (!object.geometry.hasAttribute('uv')) {\n          console.warn('All lightmap objects need UVs!');\n          continue;\n        }\n\n        if (this.blurringPlane == null) {\n          this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n        } // Apply the lightmap to the object\n\n\n        object.material.lightMap = this.progressiveLightMap2.texture;\n        object.material.dithering = true;\n        object.castShadow = true;\n        object.receiveShadow = true;\n        object.renderOrder = 1000 + ob; // Prepare UV boxes for potpack\n        // TODO: Size these by object surface area\n\n        this.uv_boxes.push({\n          w: 1 + padding * 2,\n          h: 1 + padding * 2,\n          index: ob\n        });\n        this.lightMapContainers.push({\n          basicMat: object.material,\n          object: object\n        });\n        this.compiled = false;\n      } // Pack the objects' lightmap UVs into the same global space\n\n\n      var dimensions = (0, _potpack[\"default\"])(this.uv_boxes);\n      this.uv_boxes.forEach(function (box) {\n        var uv2 = objects[box.index].geometry.getAttribute('uv').clone();\n\n        for (var i = 0; i < uv2.array.length; i += uv2.itemSize) {\n          uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\n          uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\n        }\n\n        objects[box.index].geometry.setAttribute('uv2', uv2);\n        objects[box.index].geometry.getAttribute('uv2').needsUpdate = true;\n      });\n    }\n    /**\n     * This function renders each mesh one at a time into their respective surface maps\n     * @param {Camera} camera Standard Rendering Camera\n     * @param {number} blendWindow When >1, samples will accumulate over time.\n     * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(camera) {\n      var blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      var blurEdges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (this.blurringPlane == null) {\n        return;\n      } // Store the original Render Target\n\n\n      var oldTarget = this.renderer.getRenderTarget(); // The blurring plane applies blur to the seams of the lightmap\n\n      this.blurringPlane.visible = blurEdges; // Steal the Object3D from the real world to our special dimension\n\n      for (var l = 0; l < this.lightMapContainers.length; l++) {\n        this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n        this.scene.attach(this.lightMapContainers[l].object);\n      } // Render once normally to initialize everything\n\n\n      if (this.firstUpdate) {\n        this.renderer.setRenderTarget(this.tinyTarget); // Tiny for Speed\n\n        this.renderer.render(this.scene, camera);\n        this.firstUpdate = false;\n      } // Set each object's material to the UV Unwrapped Surface Mapping Version\n\n\n      for (var _l = 0; _l < this.lightMapContainers.length; _l++) {\n        this.uvMat.uniforms.averagingWindow = {\n          value: blendWindow\n        };\n        this.lightMapContainers[_l].object.material = this.uvMat;\n        this.lightMapContainers[_l].object.oldFrustumCulled = this.lightMapContainers[_l].object.frustumCulled;\n        this.lightMapContainers[_l].object.frustumCulled = false;\n      } // Ping-pong two surface buffers for reading/writing\n\n\n      var activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n      var inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n      this.renderer.setRenderTarget(activeMap);\n      this.uvMat.uniforms.previousShadowMap = {\n        value: inactiveMap.texture\n      };\n      this.blurringPlane.material.uniforms.previousShadowMap = {\n        value: inactiveMap.texture\n      };\n      this.buffer1Active = !this.buffer1Active;\n      this.renderer.render(this.scene, camera); // Restore the object's Real-time Material and add it back to the original world\n\n      for (var _l2 = 0; _l2 < this.lightMapContainers.length; _l2++) {\n        this.lightMapContainers[_l2].object.frustumCulled = this.lightMapContainers[_l2].object.oldFrustumCulled;\n        this.lightMapContainers[_l2].object.material = this.lightMapContainers[_l2].basicMat;\n\n        this.lightMapContainers[_l2].object.oldScene.attach(this.lightMapContainers[_l2].object);\n      } // Restore the original Render Target\n\n\n      this.renderer.setRenderTarget(oldTarget);\n    }\n    /** DEBUG\n     * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n     * @param {boolean} visible Whether the debug plane should be visible\n     * @param {Vector3} position Where the debug plane should be drawn\n     */\n\n  }, {\n    key: \"showDebugLightmap\",\n    value: function showDebugLightmap(visible) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n      if (this.lightMapContainers.length == 0) {\n        if (!this.warned) {\n          console.warn('Call this after adding the objects!');\n          this.warned = true;\n        }\n\n        return;\n      }\n\n      if (this.labelMesh == null) {\n        this.labelMaterial = new _three.MeshBasicMaterial({\n          map: this.progressiveLightMap1.texture,\n          side: _three.DoubleSide\n        });\n        this.labelPlane = new _three.PlaneGeometry(100, 100);\n        this.labelMesh = new _three.Mesh(this.labelPlane, this.labelMaterial);\n        this.labelMesh.position.y = 250;\n        this.lightMapContainers[0].object.parent.add(this.labelMesh);\n      }\n\n      if (position != undefined) {\n        this.labelMesh.position.copy(position);\n      }\n\n      this.labelMesh.visible = visible;\n    }\n    /**\n     * INTERNAL Creates the Blurring Plane\n     * @param {number} res The square resolution of this object's lightMap.\n     * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n     */\n\n  }, {\n    key: \"_initializeBlurPlane\",\n    value: function _initializeBlurPlane(res) {\n      var _this2 = this;\n\n      var lightMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var blurMaterial = new _three.MeshBasicMaterial();\n      blurMaterial.uniforms = {\n        previousShadowMap: {\n          value: null\n        },\n        pixelOffset: {\n          value: 1.0 / res\n        },\n        polygonOffset: true,\n        polygonOffsetFactor: -1,\n        polygonOffsetUnits: 3.0\n      };\n\n      blurMaterial.onBeforeCompile = function (shader) {\n        // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n        shader.vertexShader = '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n\n        var bodyStart = shader.fragmentShader.indexOf('void main() {');\n        shader.fragmentShader = '#define USE_UV\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\tgl_FragColor.rgb = (\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\\n\\t\\t}\"; // Set the LightMap Accumulation Buffer\n\n        shader.uniforms.previousShadowMap = {\n          value: lightMap.texture\n        };\n        shader.uniforms.pixelOffset = {\n          value: 0.5 / res\n        };\n        blurMaterial.uniforms = shader.uniforms; // Set the new Shader to this\n\n        blurMaterial.userData.shader = shader;\n        _this2.compiled = true;\n      };\n\n      this.blurringPlane = new _three.Mesh(new _three.PlaneBufferGeometry(1, 1), blurMaterial);\n      this.blurringPlane.name = 'Blurring Plane';\n      this.blurringPlane.frustumCulled = false;\n      this.blurringPlane.renderOrder = 0;\n      this.blurringPlane.material.depthWrite = false;\n      this.scene.add(this.blurringPlane);\n    }\n  }]);\n\n  return ProgressiveLightMap;\n}();\n\nexports.ProgressiveLightMap = ProgressiveLightMap;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$potpack$index_mjs","~$shadow.js"]],"~:properties",["^5",["fragmentShader","progressiveLightMap1","lightMap","map","warned","object","w","labelMesh","res","labelMaterial","renderer","frustumCulled","oldScene","receiveShadow","index","blurringPlane","needsUpdate","side","castShadow","firstUpdate","key","__esModule","renderOrder","dithering","uvMat","vertexShader","name","configurable","value","visible","polygonOffset","enumerable","buffer1Active","writable","uv_boxes","averagingWindow","polygonOffsetFactor","type","y","onBeforeCompile","tinyTarget","polygonOffsetUnits","depthWrite","basicMat","previousShadowMap","labelPlane","lightMapContainers","uniforms","h","shader","background","oldFrustumCulled","pixelOffset","ProgressiveLightMap","progressiveLightMap2","scene","compiled","material"]],"~:compiled-at",1630917515134,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$misc$ProgressiveLightmap.js\",\n\"lineCount\":16,\n\"mappings\":\"AAAAA,cAAA,CAAA,yDAAA,CAA8E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAgBtHC,QAASA,kBAAiB,CAACC,MAAD,CAASC,KAAT,CAAgB,CAAE,IAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBD,KAAME,CAAAA,MAA1B,CAAkCD,CAAA,EAAlC,CAAuC,CAAE,IAAIE,WAAaH,KAAA,CAAMC,CAAN,CAAUE,WAAWC,CAAAA,UAAX,CAAwBD,UAAWC,CAAAA,UAAnC,EAAiD,CAAA,CAAOD,WAAWE,CAAAA,YAAX,CAA0B,CAAA,CAAU,QAAJ,EAAeF,WAAf,GAA2BA,UAAWG,CAAAA,QAAtC,CAAiD,CAAA,CAAjD,CAAuDC,OAAOC,CAAAA,cAAP,CAAsBT,MAAtB,CAA8BI,UAAWM,CAAAA,GAAzC,CAA8CN,UAA9C,CAA5K,CAAzC,CAE1CO,QAASA,aAAY,CAACC,WAAD,CAAcC,UAAd,CAA0BC,WAA1B,CAAuC,CAAMD,UAAJ,EAAgBd,iBAAA,CAAkBa,WAAYG,CAAAA,SAA9B,CAAyCF,UAAzC,CAA0DC;WAAJ,EAAiBf,iBAAA,CAAkBa,WAAlB,CAA+BE,WAA/B,CAA6C,OAAOF,YAA7I,CAf5DJ,MAAOC,CAAAA,cAAP,CAAsBX,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CkB,MAAO,CAAA,CADoC,CAA7C,CAGAlB,QAAQmB,CAAAA,mBAAR,CAA8B,IAAK,EAEnC,KAAIC,OAAStB,OAAA,CAAQ,8CAAR,CAAb,CAEIuB,SAEJC,QAA+B,CAACC,GAAD,CAAM,CAAE,MAAOA,IAAA,EAAOA,GAAIC,CAAAA,UAAX,CAAwBD,GAAxB,CAA8B,CAAE,UAAWA,GAAb,CAAvC,CAFtB,CAAuBzB,OAAA,CAAQ,uCAAR,CAAvB,CA0BXqB,OAAAA,CAEJ,QAAS,EAAG,CACVA,QAASA,oBAAmB,CAACM,QAAD,CAAW,CACrC,IAAIC,MAAQ,IAAZ,CAEIC,IAAyB,CAAnB,CAAAC,SAAUvB,CAAAA,MAAV,EAAyCwB,IAAAA,EAAzC,GAAwBD,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoE,IA5BhC,IAAI,EA8BlCE,IA9BkC;AA8B5BX,mBA9B4B,CAAJ,CAA0C,KAAM,KAAIY,SAAJ,CAAc,mCAAd,CAAN,CAgCxF,IAAKN,CAAAA,QAAL,CAAgBA,QAChB,KAAKE,CAAAA,GAAL,CAAWA,GACX,KAAKK,CAAAA,kBAAL,CAA0B,EAC1B,KAAKC,CAAAA,QAAL,CAAgB,CAAA,CAChB,KAAKC,CAAAA,KAAL,CAAa,IAAId,MAAOe,CAAAA,KACxB,KAAKD,CAAAA,KAAME,CAAAA,UAAX,CAAwB,IACxB,KAAKC,CAAAA,UAAL,CAAkB,IAAIjB,MAAOkB,CAAAA,iBAAX,CAA6B,CAA7B,CAAgC,CAAhC,CAClB,KAAKC,CAAAA,aAAL,CAAqB,CAAA,CACrB,KAAKC,CAAAA,WAAL,CAAmB,CAAA,CACnB,KAAKC,CAAAA,MAAL,CAAc,CAAA,CAEVC,IAAAA,CAAS,6BAA8BC,CAAAA,IAA9B,CAAmCC,SAAUC,CAAAA,SAA7C,CAAA,CAA0DC,YAA1D,CAAyE1B,MAAO2B,CAAAA,SAC7F,KAAKC,CAAAA,oBAAL,CAA4B,IAAI5B,MAAOkB,CAAAA,iBAAX,CAA6B,IAAKX,CAAAA,GAAlC,CAAuC,IAAKA,CAAAA,GAA5C,CAAiD,CAC3EsB,KAAMP,GADqE,CAAjD,CAG5B,KAAKQ,CAAAA,oBAAL;AAA4B,IAAI9B,MAAOkB,CAAAA,iBAAX,CAA6B,IAAKX,CAAAA,GAAlC,CAAuC,IAAKA,CAAAA,GAA5C,CAAiD,CAC3EsB,KAAMP,GADqE,CAAjD,CAI5B,KAAKS,CAAAA,KAAL,CAAa,IAAI/B,MAAOgC,CAAAA,iBACxB,KAAKD,CAAAA,KAAME,CAAAA,QAAX,CAAsB,EAEtB,KAAKF,CAAAA,KAAMG,CAAAA,eAAX,CAA6BC,QAAS,CAACC,MAAD,CAAS,CAE7CA,MAAOC,CAAAA,YAAP,CAAsB,wBAAtB,CAAiDD,MAAOC,CAAAA,YAAaC,CAAAA,KAApB,CAA0B,CAA1B,CAA6B,EAA7B,CAAjD,CAAoF,yDAEpF,KAAIC,UAAYH,MAAOI,CAAAA,cAAeC,CAAAA,OAAtB,CAA8B,eAA9B,CAChBL,OAAOI,CAAAA,cAAP,CAAwB,sBAAxB,CAAiDJ,MAAOI,CAAAA,cAAeF,CAAAA,KAAtB,CAA4B,CAA5B,CAA+BC,SAA/B,CAAjD,CAA6F,4EAA7F;AAA0KH,MAAOI,CAAAA,cAAeF,CAAAA,KAAtB,CAA4BC,SAA5B,CAAwC,CAAxC,CAA2C,EAA3C,CAA1K,CAA2N,4JAE3NH,OAAOH,CAAAA,QAASS,CAAAA,iBAAhB,CAAoC,CAClC5C,MAAOQ,KAAMsB,CAAAA,oBAAqBe,CAAAA,OADA,CAGpCP,OAAOH,CAAAA,QAASW,CAAAA,eAAhB,CAAkC,CAChC9C,MAAO,GADyB,CAGlCQ,MAAMyB,CAAAA,KAAME,CAAAA,QAAZ,CAAuBG,MAAOH,CAAAA,QAE9B3B,MAAMyB,CAAAA,KAAMc,CAAAA,QAAST,CAAAA,MAArB,CAA8BA,MAC9B9B,MAAMO,CAAAA,QAAN,CAAiB,CAAA,CAhB4B,CA7BV,CAsDvCpB,YAAA,CAAaM,mBAAb,CAAkC,CAAC,CACjCP,IAAK,sBAD4B,CAEjCM,MAAOgD,QAA6B,CAACC,OAAD,CAAU,CAE5C,IAAKC,CAAAA,QAAL;AAAgB,EAGhB,KAFA,IAAIC,QAAU,CAAVA,CAAc,IAAK1C,CAAAA,GAAvB,CAES2C,GAAK,CAAd,CAAiBA,EAAjB,CAAsBH,OAAQ9D,CAAAA,MAA9B,CAAsCiE,EAAA,EAAtC,CAA4C,CAC1C,IAAIC,OAASJ,OAAA,CAAQG,EAAR,CAETC,OAAOC,CAAAA,OAAX,CACE,IAAKtC,CAAAA,KAAMuC,CAAAA,MAAX,CAAkBF,MAAlB,CADF,CAKKA,MAAOG,CAAAA,QAASC,CAAAA,YAAhB,CAA6B,IAA7B,CAAL,EAK0B,IAqB1B,EArBI,IAAKC,CAAAA,aAqBT,EApBE,IAAKC,CAAAA,oBAAL,CAA0B,IAAKlD,CAAAA,GAA/B,CAAoC,IAAKqB,CAAAA,oBAAzC,CAoBF,CAhBAuB,MAAOO,CAAAA,QAASC,CAAAA,QAgBhB,CAhB2B,IAAK7B,CAAAA,oBAAqBa,CAAAA,OAgBrD,CAfAQ,MAAOO,CAAAA,QAASE,CAAAA,SAehB,CAf4B,CAAA,CAe5B,CAdAT,MAAOU,CAAAA,UAcP,CAdoB,CAAA,CAcpB,CAbAV,MAAOW,CAAAA,aAaP,CAbuB,CAAA,CAavB,CAZAX,MAAOY,CAAAA,WAYP,CAZqB,GAYrB,CAZ4Bb,EAY5B,CATA,IAAKF,CAAAA,QAASgB,CAAAA,IAAd,CAAmB,CACjBC,EAAG,CAAHA,CAAiB,CAAjBA,CAAOhB,OADU,CAEjBiB,EAAG,CAAHA,CAAiB,CAAjBA,CAAOjB,OAFU,CAGjBkB,MAAOjB,EAHU,CAAnB,CASA,CAJA,IAAKtC,CAAAA,kBAAmBoD,CAAAA,IAAxB,CAA6B,CAC3BI,SAAUjB,MAAOO,CAAAA,QADU;AAEnBP,MAFmB,CAA7B,CAIA,CAAA,IAAKtC,CAAAA,QAAL,CAAgB,CAAA,CA1BhB,EACEwD,OAAQC,CAAAA,IAAR,CAAa,gCAAb,CATwC,CAsC5C,IAAIC,WAAa,CAAC,CAAA,CAAGtE,QAAA,CAAS,SAAT,CAAJ,EAAyB,IAAK+C,CAAAA,QAA9B,CACjB,KAAKA,CAAAA,QAASwB,CAAAA,OAAd,CAAsB,QAAS,CAACC,GAAD,CAAM,CAGnC,IAFA,IAAIC,IAAM3B,OAAA,CAAQ0B,GAAIN,CAAAA,KAAZ,CAAmBb,CAAAA,QAASqB,CAAAA,YAA5B,CAAyC,IAAzC,CAA+CC,CAAAA,KAA/C,EAAV,CAES5F,EAAI,CAAb,CAAgBA,CAAhB,CAAoB0F,GAAIG,CAAAA,KAAM5F,CAAAA,MAA9B,CAAsCD,CAAtC,EAA2C0F,GAAII,CAAAA,QAA/C,CACEJ,GAAIG,CAAAA,KAAJ,CAAU7F,CAAV,CACA,EADgB0F,GAAIG,CAAAA,KAAJ,CAAU7F,CAAV,CAChB,CAD+ByF,GAAIM,CAAAA,CACnC,CADuC9B,OACvC,EADkDsB,UAAWN,CAAAA,CAC7D,CAAAS,GAAIG,CAAAA,KAAJ,CAAU7F,CAAV,CAAc,CAAd,CAAA,EAAoB0F,GAAIG,CAAAA,KAAJ,CAAU7F,CAAV,CAAc,CAAd,CAApB,CAAuCyF,GAAIO,CAAAA,CAA3C,CAA+C/B,OAA/C,EAA0DsB,UAAWL,CAAAA,CAGvEnB,QAAA,CAAQ0B,GAAIN,CAAAA,KAAZ,CAAmBb,CAAAA,QAAS2B,CAAAA,YAA5B,CAAyC,KAAzC,CAAgDP,GAAhD,CACA3B,QAAA,CAAQ0B,GAAIN,CAAAA,KAAZ,CAAmBb,CAAAA,QAASqB,CAAAA,YAA5B,CAAyC,KAAzC,CAAgDO,CAAAA,WAAhD,CAA8D,CAAA,CAT3B,CAArC,CA5C4C,CAFb,CAAD;AAiE/B,CACD1F,IAAK,QADJ,CAEDM,MAAOqF,QAAe,CAACC,MAAD,CAAS,CAC7B,IAAIC,YAAiC,CAAnB,CAAA7E,SAAUvB,CAAAA,MAAV,EAAyCwB,IAAAA,EAAzC,GAAwBD,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoE,GAAtF,CACI8E,UAA+B,CAAnB,CAAA9E,SAAUvB,CAAAA,MAAV,EAAyCwB,IAAAA,EAAzC,GAAwBD,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoE,CAAA,CAEpF,IAA0B,IAA1B,EAAI,IAAKgD,CAAAA,aAAT,CAAA,CAKA,IAAI+B,UAAY,IAAKlF,CAAAA,QAASmF,CAAAA,eAAd,EAEhB,KAAKhC,CAAAA,aAAciC,CAAAA,OAAnB,CAA6BH,SAE7B,KAASI,SAAT,CAAa,CAAb,CAAgBA,SAAhB,CAAoB,IAAK9E,CAAAA,kBAAmB3B,CAAAA,MAA5C,CAAoDyG,SAAA,EAApD,CACE,IAAK9E,CAAAA,kBAAL,CAAwB8E,SAAxB,CAA2BvC,CAAAA,MAAOwC,CAAAA,QAClC,CAD6C,IAAK/E,CAAAA,kBAAL,CAAwB8E,SAAxB,CAA2BvC,CAAAA,MAAOyC,CAAAA,MAC/E,CAAA,IAAK9E,CAAAA,KAAMuC,CAAAA,MAAX,CAAkB,IAAKzC,CAAAA,kBAAL,CAAwB8E,SAAxB,CAA2BvC,CAAAA,MAA7C,CAIE;IAAK/B,CAAAA,WAAT,GACE,IAAKf,CAAAA,QAASwF,CAAAA,eAAd,CAA8B,IAAK5E,CAAAA,UAAnC,CAGA,CADA,IAAKZ,CAAAA,QAASyF,CAAAA,MAAd,CAAqB,IAAKhF,CAAAA,KAA1B,CAAiCsE,MAAjC,CACA,CAAA,IAAKhE,CAAAA,WAAL,CAAmB,CAAA,CAJrB,CAQA,KAAS2E,SAAT,CAAc,CAAd,CAAiBA,SAAjB,CAAsB,IAAKnF,CAAAA,kBAAmB3B,CAAAA,MAA9C,CAAsD8G,SAAA,EAAtD,CACE,IAAKhE,CAAAA,KAAME,CAAAA,QAASW,CAAAA,eAKpB,CALsC,CACpC9C,MAAOuF,WAD6B,CAKtC,CAFA,IAAKzE,CAAAA,kBAAL,CAAwBmF,SAAxB,CAA4B5C,CAAAA,MAAOO,CAAAA,QAEnC,CAF8C,IAAK3B,CAAAA,KAEnD,CADA,IAAKnB,CAAAA,kBAAL,CAAwBmF,SAAxB,CAA4B5C,CAAAA,MAAO6C,CAAAA,gBACnC,CADsD,IAAKpF,CAAAA,kBAAL,CAAwBmF,SAAxB,CAA4B5C,CAAAA,MAAO8C,CAAAA,aACzF,CAAA,IAAKrF,CAAAA,kBAAL,CAAwBmF,SAAxB,CAA4B5C,CAAAA,MAAO8C,CAAAA,aAAnC,CAAmD,CAAA,CAKjDC,YAAAA,CAAc,IAAK/E,CAAAA,aAAL;AAAqB,IAAKW,CAAAA,oBAA1B,CAAiD,IAAKF,CAAAA,oBAExE,KAAKvB,CAAAA,QAASwF,CAAAA,eAAd,CAHgB,IAAK1E,CAAAA,aAALgF,CAAqB,IAAKvE,CAAAA,oBAA1BuE,CAAiD,IAAKrE,CAAAA,oBAGtE,CACA,KAAKC,CAAAA,KAAME,CAAAA,QAASS,CAAAA,iBAApB,CAAwC,CACtC5C,MAAOoG,WAAYvD,CAAAA,OADmB,CAGxC,KAAKa,CAAAA,aAAcE,CAAAA,QAASzB,CAAAA,QAASS,CAAAA,iBAArC,CAAyD,CACvD5C,MAAOoG,WAAYvD,CAAAA,OADoC,CAGzD,KAAKxB,CAAAA,aAAL,CAAqB,CAAC,IAAKA,CAAAA,aAC3B,KAAKd,CAAAA,QAASyF,CAAAA,MAAd,CAAqB,IAAKhF,CAAAA,KAA1B,CAAiCsE,MAAjC,CAEA,KAASgB,WAAT,CAAe,CAAf,CAAkBA,WAAlB,CAAwB,IAAKxF,CAAAA,kBAAmB3B,CAAAA,MAAhD,CAAwDmH,WAAA,EAAxD,CACE,IAAKxF,CAAAA,kBAAL,CAAwBwF,WAAxB,CAA6BjD,CAAAA,MAAO8C,CAAAA,aAGpC;AAHoD,IAAKrF,CAAAA,kBAAL,CAAwBwF,WAAxB,CAA6BjD,CAAAA,MAAO6C,CAAAA,gBAGxF,CAFA,IAAKpF,CAAAA,kBAAL,CAAwBwF,WAAxB,CAA6BjD,CAAAA,MAAOO,CAAAA,QAEpC,CAF+C,IAAK9C,CAAAA,kBAAL,CAAwBwF,WAAxB,CAA6BhC,CAAAA,QAE5E,CAAA,IAAKxD,CAAAA,kBAAL,CAAwBwF,WAAxB,CAA6BjD,CAAAA,MAAOwC,CAAAA,QAAStC,CAAAA,MAA7C,CAAoD,IAAKzC,CAAAA,kBAAL,CAAwBwF,WAAxB,CAA6BjD,CAAAA,MAAjF,CAIF,KAAK9C,CAAAA,QAASwF,CAAAA,eAAd,CAA8BN,SAA9B,CAtDA,CAJ6B,CAF9B,CAjE+B,CAqI/B,CACD/F,IAAK,mBADJ,CAEDM,MAAOuG,QAA0B,CAACZ,OAAD,CAAU,CACzC,IAAIa,SAA8B,CAAnB,CAAA9F,SAAUvB,CAAAA,MAAV,EAAyCwB,IAAAA,EAAzC,GAAwBD,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoEC,IAAAA,EAE7C,EAAtC,EAAI,IAAKG,CAAAA,kBAAmB3B,CAAAA,MAA5B,CACO,IAAKoC,CAAAA,MADZ,GAEIgD,OAAQC,CAAAA,IAAR,CAAa,qCAAb,CACA;AAAA,IAAKjD,CAAAA,MAAL,CAAc,CAAA,CAHlB,GASsB,IAetB,EAfI,IAAKkF,CAAAA,SAeT,GAdE,IAAKC,CAAAA,aAOL,CAPqB,IAAIxG,MAAOyG,CAAAA,iBAAX,CAA6B,CAChDC,IAAK,IAAK9E,CAAAA,oBAAqBe,CAAAA,OADiB,CAEhDgE,KAAM3G,MAAO4G,CAAAA,UAFmC,CAA7B,CAOrB,CAHA,IAAKC,CAAAA,UAGL,CAHkB,IAAI7G,MAAO8G,CAAAA,aAAX,CAAyB,GAAzB,CAA8B,GAA9B,CAGlB,CAFA,IAAKP,CAAAA,SAEL,CAFiB,IAAIvG,MAAO+G,CAAAA,IAAX,CAAgB,IAAKF,CAAAA,UAArB,CAAiC,IAAKL,CAAAA,aAAtC,CAEjB,CADA,IAAKD,CAAAA,SAAUD,CAAAA,QAAStB,CAAAA,CACxB,CAD4B,GAC5B,CAAA,IAAKpE,CAAAA,kBAAL,CAAwB,CAAxB,CAA2BuC,CAAAA,MAAOyC,CAAAA,MAAOoB,CAAAA,GAAzC,CAA6C,IAAKT,CAAAA,SAAlD,CAOF,EAJgB9F,IAAAA,EAIhB,EAJI6F,QAIJ,EAHE,IAAKC,CAAAA,SAAUD,CAAAA,QAASW,CAAAA,IAAxB,CAA6BX,QAA7B,CAGF,CAAA,IAAKC,CAAAA,SAAUd,CAAAA,OAAf,CAAyBA,OAxBzB,CAHyC,CAF1C,CArI+B,CA0K/B,CACDjG,IAAK,sBADJ,CAEDM,MAAO2D,QAA6B,CAAClD,GAAD,CAAM,CACxC,IAAI2G;AAAS,IAAb,CAEIvD,SAA8B,CAAnB,CAAAnD,SAAUvB,CAAAA,MAAV,EAAyCwB,IAAAA,EAAzC,GAAwBD,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoE,IAFnF,CAGI2G,aAAe,IAAInH,MAAOyG,CAAAA,iBAC9BU,aAAalF,CAAAA,QAAb,CAAwB,CACtBS,kBAAmB,CACjB5C,MAAO,IADU,CADG,CAItBsH,YAAa,CACXtH,MAAO,CAAPA,CAAaS,GADF,CAJS,CAOtB8G,cAAe,CAAA,CAPO,CAQtBC,oBAAqB,EARC,CAStBC,mBAAoB,CATE,CAYxBJ,aAAajF,CAAAA,eAAb,CAA+BsF,QAAS,CAACpF,MAAD,CAAS,CAE/CA,MAAOC,CAAAA,YAAP,CAAsB,kBAAtB,CAA2CD,MAAOC,CAAAA,YAAaC,CAAAA,KAApB,CAA0B,CAA1B,CAA6B,EAA7B,CAA3C,CAA8E,wDAE9E,KAAIC,UAAYH,MAAOI,CAAAA,cAAeC,CAAAA,OAAtB,CAA8B,eAA9B,CAChBL,OAAOI,CAAAA,cAAP;AAAwB,kBAAxB,CAA6CJ,MAAOI,CAAAA,cAAeF,CAAAA,KAAtB,CAA4B,CAA5B,CAA+BC,SAA/B,CAA7C,CAAyF,wEAAzF,CAAkKH,MAAOI,CAAAA,cAAeF,CAAAA,KAAtB,CAA4BC,SAA5B,CAAwC,CAAxC,CAA2C,EAA3C,CAAlK,CAAmN,ssBAEnNH;MAAOH,CAAAA,QAASS,CAAAA,iBAAhB,CAAoC,CAClC5C,MAAO6D,QAAShB,CAAAA,OADkB,CAGpCP,OAAOH,CAAAA,QAASmF,CAAAA,WAAhB,CAA8B,CAC5BtH,MAAO,EAAPA,CAAaS,GADe,CAG9B4G,aAAalF,CAAAA,QAAb,CAAwBG,MAAOH,CAAAA,QAE/BkF,aAAatE,CAAAA,QAAST,CAAAA,MAAtB,CAA+BA,MAC/B8E,OAAOrG,CAAAA,QAAP,CAAkB,CAAA,CAhB6B,CAmBjD,KAAK2C,CAAAA,aAAL,CAAqB,IAAIxD,MAAO+G,CAAAA,IAAX,CAAgB,IAAI/G,MAAOyH,CAAAA,mBAAX,CAA+B,CAA/B,CAAkC,CAAlC,CAAhB,CAAsDN,YAAtD,CACrB,KAAK3D,CAAAA,aAAckE,CAAAA,IAAnB,CAA0B,gBAC1B,KAAKlE,CAAAA,aAAcyC,CAAAA,aAAnB,CAAmC,CAAA,CACnC,KAAKzC,CAAAA,aAAcO,CAAAA,WAAnB,CAAiC,CACjC,KAAKP,CAAAA,aAAcE,CAAAA,QAASiE,CAAAA,UAA5B,CAAyC,CAAA,CACzC,KAAK7G,CAAAA,KAAMkG,CAAAA,GAAX,CAAe,IAAKxD,CAAAA,aAApB,CAzCwC,CAFzC,CA1K+B,CAAlC,CAyNA,OAAOzD,oBAhRG,CAAZ,EAmRAnB;OAAQmB,CAAAA,mBAAR,CAA8BA,MAzTwF;\",\n\"sources\":[\"node_modules/three-stdlib/misc/ProgressiveLightmap.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$misc$ProgressiveLightmap\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ProgressiveLightMap = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _potpack = _interopRequireDefault(require(\\\"potpack\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \\\"default\\\": obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n/**\\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\\n *\\n * To use, simply construct a `ProgressiveLightMap` object,\\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\\n * objects and lights to the class once, and then call\\n * `plmap.update(camera)` every frame to begin accumulating\\n * lighting samples.\\n *\\n * This should begin accumulating lightmaps which apply to\\n * your objects, so you can start jittering lighting to achieve\\n * the texture-space effect you're looking for.\\n *\\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\\n * @param {number} res The side-long dimension of you total lightmap\\n */\\nvar ProgressiveLightMap =\\n/*#__PURE__*/\\nfunction () {\\n  function ProgressiveLightMap(renderer) {\\n    var _this = this;\\n\\n    var res = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\\n\\n    _classCallCheck(this, ProgressiveLightMap);\\n\\n    this.renderer = renderer;\\n    this.res = res;\\n    this.lightMapContainers = [];\\n    this.compiled = false;\\n    this.scene = new _three.Scene();\\n    this.scene.background = null;\\n    this.tinyTarget = new _three.WebGLRenderTarget(1, 1);\\n    this.buffer1Active = false;\\n    this.firstUpdate = true;\\n    this.warned = false; // Create the Progressive LightMap Texture\\n\\n    var format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : _three.FloatType;\\n    this.progressiveLightMap1 = new _three.WebGLRenderTarget(this.res, this.res, {\\n      type: format\\n    });\\n    this.progressiveLightMap2 = new _three.WebGLRenderTarget(this.res, this.res, {\\n      type: format\\n    }); // Inject some spicy new logic into a standard phong material\\n\\n    this.uvMat = new _three.MeshPhongMaterial();\\n    this.uvMat.uniforms = {};\\n\\n    this.uvMat.onBeforeCompile = function (shader) {\\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\\n      shader.vertexShader = '#define USE_LIGHTMAP\\\\n' + shader.vertexShader.slice(0, -1) + '\\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\\n\\n      var bodyStart = shader.fragmentShader.indexOf('void main() {');\\n      shader.fragmentShader = 'varying vec2 vUv2;\\\\n' + shader.fragmentShader.slice(0, bodyStart) + '\\tuniform sampler2D previousShadowMap;\\\\n\\tuniform float averagingWindow;\\\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + \\\"\\\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\\\\n\\\\t\\\\t\\\\t\\\\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\\\\n\\\\t\\\\t\\\\t}\\\"; // Set the Previous Frame's Texture Buffer and Averaging Window\\n\\n      shader.uniforms.previousShadowMap = {\\n        value: _this.progressiveLightMap1.texture\\n      };\\n      shader.uniforms.averagingWindow = {\\n        value: 100\\n      };\\n      _this.uvMat.uniforms = shader.uniforms; // Set the new Shader to this\\n\\n      _this.uvMat.userData.shader = shader;\\n      _this.compiled = true;\\n    };\\n  }\\n  /**\\n   * Sets these objects' materials' lightmaps and modifies their uv2's.\\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\\n   */\\n\\n\\n  _createClass(ProgressiveLightMap, [{\\n    key: \\\"addObjectsToLightMap\\\",\\n    value: function addObjectsToLightMap(objects) {\\n      // Prepare list of UV bounding boxes for packing later...\\n      this.uv_boxes = [];\\n      var padding = 3 / this.res;\\n\\n      for (var ob = 0; ob < objects.length; ob++) {\\n        var object = objects[ob]; // If this object is a light, simply add it to the internal scene\\n\\n        if (object.isLight) {\\n          this.scene.attach(object);\\n          continue;\\n        }\\n\\n        if (!object.geometry.hasAttribute('uv')) {\\n          console.warn('All lightmap objects need UVs!');\\n          continue;\\n        }\\n\\n        if (this.blurringPlane == null) {\\n          this._initializeBlurPlane(this.res, this.progressiveLightMap1);\\n        } // Apply the lightmap to the object\\n\\n\\n        object.material.lightMap = this.progressiveLightMap2.texture;\\n        object.material.dithering = true;\\n        object.castShadow = true;\\n        object.receiveShadow = true;\\n        object.renderOrder = 1000 + ob; // Prepare UV boxes for potpack\\n        // TODO: Size these by object surface area\\n\\n        this.uv_boxes.push({\\n          w: 1 + padding * 2,\\n          h: 1 + padding * 2,\\n          index: ob\\n        });\\n        this.lightMapContainers.push({\\n          basicMat: object.material,\\n          object: object\\n        });\\n        this.compiled = false;\\n      } // Pack the objects' lightmap UVs into the same global space\\n\\n\\n      var dimensions = (0, _potpack[\\\"default\\\"])(this.uv_boxes);\\n      this.uv_boxes.forEach(function (box) {\\n        var uv2 = objects[box.index].geometry.getAttribute('uv').clone();\\n\\n        for (var i = 0; i < uv2.array.length; i += uv2.itemSize) {\\n          uv2.array[i] = (uv2.array[i] + box.x + padding) / dimensions.w;\\n          uv2.array[i + 1] = (uv2.array[i + 1] + box.y + padding) / dimensions.h;\\n        }\\n\\n        objects[box.index].geometry.setAttribute('uv2', uv2);\\n        objects[box.index].geometry.getAttribute('uv2').needsUpdate = true;\\n      });\\n    }\\n    /**\\n     * This function renders each mesh one at a time into their respective surface maps\\n     * @param {Camera} camera Standard Rendering Camera\\n     * @param {number} blendWindow When >1, samples will accumulate over time.\\n     * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\\n     */\\n\\n  }, {\\n    key: \\\"update\\\",\\n    value: function update(camera) {\\n      var blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\\n      var blurEdges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\\n\\n      if (this.blurringPlane == null) {\\n        return;\\n      } // Store the original Render Target\\n\\n\\n      var oldTarget = this.renderer.getRenderTarget(); // The blurring plane applies blur to the seams of the lightmap\\n\\n      this.blurringPlane.visible = blurEdges; // Steal the Object3D from the real world to our special dimension\\n\\n      for (var l = 0; l < this.lightMapContainers.length; l++) {\\n        this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\\n        this.scene.attach(this.lightMapContainers[l].object);\\n      } // Render once normally to initialize everything\\n\\n\\n      if (this.firstUpdate) {\\n        this.renderer.setRenderTarget(this.tinyTarget); // Tiny for Speed\\n\\n        this.renderer.render(this.scene, camera);\\n        this.firstUpdate = false;\\n      } // Set each object's material to the UV Unwrapped Surface Mapping Version\\n\\n\\n      for (var _l = 0; _l < this.lightMapContainers.length; _l++) {\\n        this.uvMat.uniforms.averagingWindow = {\\n          value: blendWindow\\n        };\\n        this.lightMapContainers[_l].object.material = this.uvMat;\\n        this.lightMapContainers[_l].object.oldFrustumCulled = this.lightMapContainers[_l].object.frustumCulled;\\n        this.lightMapContainers[_l].object.frustumCulled = false;\\n      } // Ping-pong two surface buffers for reading/writing\\n\\n\\n      var activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\\n      var inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\\n\\n      this.renderer.setRenderTarget(activeMap);\\n      this.uvMat.uniforms.previousShadowMap = {\\n        value: inactiveMap.texture\\n      };\\n      this.blurringPlane.material.uniforms.previousShadowMap = {\\n        value: inactiveMap.texture\\n      };\\n      this.buffer1Active = !this.buffer1Active;\\n      this.renderer.render(this.scene, camera); // Restore the object's Real-time Material and add it back to the original world\\n\\n      for (var _l2 = 0; _l2 < this.lightMapContainers.length; _l2++) {\\n        this.lightMapContainers[_l2].object.frustumCulled = this.lightMapContainers[_l2].object.oldFrustumCulled;\\n        this.lightMapContainers[_l2].object.material = this.lightMapContainers[_l2].basicMat;\\n\\n        this.lightMapContainers[_l2].object.oldScene.attach(this.lightMapContainers[_l2].object);\\n      } // Restore the original Render Target\\n\\n\\n      this.renderer.setRenderTarget(oldTarget);\\n    }\\n    /** DEBUG\\n     * Draw the lightmap in the main scene.  Call this after adding the objects to it.\\n     * @param {boolean} visible Whether the debug plane should be visible\\n     * @param {Vector3} position Where the debug plane should be drawn\\n     */\\n\\n  }, {\\n    key: \\\"showDebugLightmap\\\",\\n    value: function showDebugLightmap(visible) {\\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\\n\\n      if (this.lightMapContainers.length == 0) {\\n        if (!this.warned) {\\n          console.warn('Call this after adding the objects!');\\n          this.warned = true;\\n        }\\n\\n        return;\\n      }\\n\\n      if (this.labelMesh == null) {\\n        this.labelMaterial = new _three.MeshBasicMaterial({\\n          map: this.progressiveLightMap1.texture,\\n          side: _three.DoubleSide\\n        });\\n        this.labelPlane = new _three.PlaneGeometry(100, 100);\\n        this.labelMesh = new _three.Mesh(this.labelPlane, this.labelMaterial);\\n        this.labelMesh.position.y = 250;\\n        this.lightMapContainers[0].object.parent.add(this.labelMesh);\\n      }\\n\\n      if (position != undefined) {\\n        this.labelMesh.position.copy(position);\\n      }\\n\\n      this.labelMesh.visible = visible;\\n    }\\n    /**\\n     * INTERNAL Creates the Blurring Plane\\n     * @param {number} res The square resolution of this object's lightMap.\\n     * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\\n     */\\n\\n  }, {\\n    key: \\\"_initializeBlurPlane\\\",\\n    value: function _initializeBlurPlane(res) {\\n      var _this2 = this;\\n\\n      var lightMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\\n      var blurMaterial = new _three.MeshBasicMaterial();\\n      blurMaterial.uniforms = {\\n        previousShadowMap: {\\n          value: null\\n        },\\n        pixelOffset: {\\n          value: 1.0 / res\\n        },\\n        polygonOffset: true,\\n        polygonOffsetFactor: -1,\\n        polygonOffsetUnits: 3.0\\n      };\\n\\n      blurMaterial.onBeforeCompile = function (shader) {\\n        // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\\n        shader.vertexShader = '#define USE_UV\\\\n' + shader.vertexShader.slice(0, -1) + '\\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\\n\\n        var bodyStart = shader.fragmentShader.indexOf('void main() {');\\n        shader.fragmentShader = '#define USE_UV\\\\n' + shader.fragmentShader.slice(0, bodyStart) + '\\tuniform sampler2D previousShadowMap;\\\\n\\tuniform float pixelOffset;\\\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + \\\"\\\\tgl_FragColor.rgb = (\\\\n\\\\t\\\\t\\\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\\\\n\\\\t\\\\t\\\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\\\\n\\\\t\\\\t\\\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\\\\n\\\\t\\\\t\\\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\\\\n\\\\t\\\\t\\\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\\\\n\\\\t\\\\t\\\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\\\\n\\\\t\\\\t\\\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\\\\n\\\\t\\\\t\\\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\\\\n\\\\t\\\\t}\\\"; // Set the LightMap Accumulation Buffer\\n\\n        shader.uniforms.previousShadowMap = {\\n          value: lightMap.texture\\n        };\\n        shader.uniforms.pixelOffset = {\\n          value: 0.5 / res\\n        };\\n        blurMaterial.uniforms = shader.uniforms; // Set the new Shader to this\\n\\n        blurMaterial.userData.shader = shader;\\n        _this2.compiled = true;\\n      };\\n\\n      this.blurringPlane = new _three.Mesh(new _three.PlaneBufferGeometry(1, 1), blurMaterial);\\n      this.blurringPlane.name = 'Blurring Plane';\\n      this.blurringPlane.frustumCulled = false;\\n      this.blurringPlane.renderOrder = 0;\\n      this.blurringPlane.material.depthWrite = false;\\n      this.scene.add(this.blurringPlane);\\n    }\\n  }]);\\n\\n  return ProgressiveLightMap;\\n}();\\n\\nexports.ProgressiveLightMap = ProgressiveLightMap;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"prototype\",\"value\",\"ProgressiveLightMap\",\"_three\",\"_potpack\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"renderer\",\"_this\",\"res\",\"arguments\",\"undefined\",\"instance\",\"TypeError\",\"lightMapContainers\",\"compiled\",\"scene\",\"Scene\",\"background\",\"tinyTarget\",\"WebGLRenderTarget\",\"buffer1Active\",\"firstUpdate\",\"warned\",\"format\",\"test\",\"navigator\",\"userAgent\",\"alfFloatType\",\"FloatType\",\"progressiveLightMap1\",\"type\",\"progressiveLightMap2\",\"uvMat\",\"MeshPhongMaterial\",\"uniforms\",\"onBeforeCompile\",\"this.uvMat.onBeforeCompile\",\"shader\",\"vertexShader\",\"slice\",\"bodyStart\",\"fragmentShader\",\"indexOf\",\"previousShadowMap\",\"texture\",\"averagingWindow\",\"userData\",\"addObjectsToLightMap\",\"objects\",\"uv_boxes\",\"padding\",\"ob\",\"object\",\"isLight\",\"attach\",\"geometry\",\"hasAttribute\",\"blurringPlane\",\"_initializeBlurPlane\",\"material\",\"lightMap\",\"dithering\",\"castShadow\",\"receiveShadow\",\"renderOrder\",\"push\",\"w\",\"h\",\"index\",\"basicMat\",\"console\",\"warn\",\"dimensions\",\"forEach\",\"box\",\"uv2\",\"getAttribute\",\"clone\",\"array\",\"itemSize\",\"x\",\"y\",\"setAttribute\",\"needsUpdate\",\"update\",\"camera\",\"blendWindow\",\"blurEdges\",\"oldTarget\",\"getRenderTarget\",\"visible\",\"l\",\"oldScene\",\"parent\",\"setRenderTarget\",\"render\",\"_l\",\"oldFrustumCulled\",\"frustumCulled\",\"inactiveMap\",\"activeMap\",\"_l2\",\"showDebugLightmap\",\"position\",\"labelMesh\",\"labelMaterial\",\"MeshBasicMaterial\",\"map\",\"side\",\"DoubleSide\",\"labelPlane\",\"PlaneGeometry\",\"Mesh\",\"add\",\"copy\",\"_this2\",\"blurMaterial\",\"pixelOffset\",\"polygonOffset\",\"polygonOffsetFactor\",\"polygonOffsetUnits\",\"blurMaterial.onBeforeCompile\",\"PlaneBufferGeometry\",\"name\",\"depthWrite\"]\n}\n"]