["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/SSAOShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$SSAOShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.SSAOShader=exports.SSAODepthShader=exports.SSAOBlurShader=void 0;global=require(\"module$node_modules$three$build$three_module\");require={defines:{PERSPECTIVE_CAMERA:1,KERNEL_SIZE:32},uniforms:{tDiffuse:{value:null},tNormal:{value:null},tDepth:{value:null},tNoise:{value:null},kernel:{value:null},cameraNear:{value:null},cameraFar:{value:null},\nresolution:{value:new global.Vector2},cameraProjectionMatrix:{value:new global.Matrix4},cameraInverseProjectionMatrix:{value:new global.Matrix4},kernelRadius:{value:8},minDistance:{value:.005},maxDistance:{value:.05}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform sampler2D tDiffuse;\\nuniform sampler2D tNormal;\\nuniform sampler2D tDepth;\\nuniform sampler2D tNoise;\\nuniform vec3 kernel[ KERNEL_SIZE ];\\nuniform vec2 resolution;\\nuniform float cameraNear;\\nuniform float cameraFar;\\nuniform mat4 cameraProjectionMatrix;\\nuniform mat4 cameraInverseProjectionMatrix;\\nuniform float kernelRadius;\\nuniform float minDistance;\\nuniform float maxDistance;\\nvarying vec2 vUv;\\n#include \\x3cpacking\\x3e\\nfloat getDepth( const in vec2 screenPosition ) {\\n\\treturn texture2D( tDepth, screenPosition ).x;\\n}\\nfloat getLinearDepth( const in vec2 screenPosition ) {\\n\\t#if PERSPECTIVE_CAMERA \\x3d\\x3d 1\\n\\t\\tfloat fragCoordZ \\x3d texture2D( tDepth, screenPosition ).x;\\n\\t\\tfloat viewZ \\x3d perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\\n\\t\\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\\n\\t#else\\n\\t\\treturn texture2D( tDepth, screenPosition ).x;\\n\\t#endif\\n}\\nfloat getViewZ( const in float depth ) {\\n\\t#if PERSPECTIVE_CAMERA \\x3d\\x3d 1\\n\\t\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\\n\\t#else\\n\\t\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\\n\\t#endif\\n}\\nvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\\n\\tfloat clipW \\x3d cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\\n\\tvec4 clipPosition \\x3d vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\\n\\tclipPosition *\\x3d clipW; // unprojection.\\n\\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\\n}\\nvec3 getViewNormal( const in vec2 screenPosition ) {\\n\\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\\n}\\nvoid main() {\\n\\tfloat depth \\x3d getDepth( vUv );\\n\\tfloat viewZ \\x3d getViewZ( depth );\\n\\tvec3 viewPosition \\x3d getViewPosition( vUv, depth, viewZ );\\n\\tvec3 viewNormal \\x3d getViewNormal( vUv );\\n vec2 noiseScale \\x3d vec2( resolution.x / 4.0, resolution.y / 4.0 );\\n\\tvec3 random \\x3d texture2D( tNoise, vUv * noiseScale ).xyz;\\n\\tvec3 tangent \\x3d normalize( random - viewNormal * dot( random, viewNormal ) );\\n\\tvec3 bitangent \\x3d cross( viewNormal, tangent );\\n\\tmat3 kernelMatrix \\x3d mat3( tangent, bitangent, viewNormal );\\n float occlusion \\x3d 0.0;\\n for ( int i \\x3d 0; i \\x3c KERNEL_SIZE; i ++ ) {\\n\\t\\tvec3 sampleVector \\x3d kernelMatrix * kernel[ i ];\\n\\t\\tvec3 samplePoint \\x3d viewPosition + ( sampleVector * kernelRadius );\\n\\t\\tvec4 samplePointNDC \\x3d cameraProjectionMatrix * vec4( samplePoint, 1.0 );\\n\\t\\tsamplePointNDC /\\x3d samplePointNDC.w;\\n\\t\\tvec2 samplePointUv \\x3d samplePointNDC.xy * 0.5 + 0.5;\\n\\t\\tfloat realDepth \\x3d getLinearDepth( samplePointUv );\\n\\t\\tfloat sampleDepth \\x3d viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\\n\\t\\tfloat delta \\x3d sampleDepth - realDepth;\\n\\t\\tif ( delta \\x3e minDistance \\x26\\x26 delta \\x3c maxDistance ) {\\n\\t\\t\\tocclusion +\\x3d 1.0;\\n\\t\\t}\\n\\t}\\n\\tocclusion \\x3d clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\\n\\tgl_FragColor \\x3d vec4( vec3( 1.0 - occlusion ), 1.0 );\\n}\"};\nexports.SSAOShader=require;exports.SSAODepthShader={defines:{PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform sampler2D tDepth;\\nuniform float cameraNear;\\nuniform float cameraFar;\\nvarying vec2 vUv;\\n#include \\x3cpacking\\x3e\\nfloat getLinearDepth( const in vec2 screenPosition ) {\\n\\t#if PERSPECTIVE_CAMERA \\x3d\\x3d 1\\n\\t\\tfloat fragCoordZ \\x3d texture2D( tDepth, screenPosition ).x;\\n\\t\\tfloat viewZ \\x3d perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\\n\\t\\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\\n\\t#else\\n\\t\\treturn texture2D( tDepth, screenPosition ).x;\\n\\t#endif\\n}\\nvoid main() {\\n\\tfloat depth \\x3d getLinearDepth( vUv );\\n\\tgl_FragColor \\x3d vec4( vec3( 1.0 - depth ), 1.0 );\\n}\"};\nglobal={uniforms:{tDiffuse:{value:null},resolution:{value:new global.Vector2}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform sampler2D tDiffuse;\\nuniform vec2 resolution;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec2 texelSize \\x3d ( 1.0 / resolution );\\n\\tfloat result \\x3d 0.0;\\n\\tfor ( int i \\x3d - 2; i \\x3c\\x3d 2; i ++ ) {\\n\\t\\tfor ( int j \\x3d - 2; j \\x3c\\x3d 2; j ++ ) {\\n\\t\\t\\tvec2 offset \\x3d ( vec2( float( i ), float( j ) ) ) * texelSize;\\n\\t\\t\\tresult +\\x3d texture2D( tDiffuse, vUv + offset ).r;\\n\\t\\t}\\n\\t}\\n\\tgl_FragColor \\x3d vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\\n}\"};\nexports.SSAOBlurShader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$SSAOShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SSAOShader = exports.SSAODepthShader = exports.SSAOBlurShader = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\nvar SSAOShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1,\n    KERNEL_SIZE: 32\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    tNoise: {\n      value: null\n    },\n    kernel: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    },\n    resolution: {\n      value: new _three.Vector2()\n    },\n    cameraProjectionMatrix: {\n      value: new _three.Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new _three.Matrix4()\n    },\n    kernelRadius: {\n      value: 8\n    },\n    minDistance: {\n      value: 0.005\n    },\n    maxDistance: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform sampler2D tNormal;', 'uniform sampler2D tDepth;', 'uniform sampler2D tNoise;', 'uniform vec3 kernel[ KERNEL_SIZE ];', 'uniform vec2 resolution;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float kernelRadius;', 'uniform float minDistance;', // avoid artifacts caused by neighbour fragments with minimal depth difference\n  'uniform float maxDistance;', // avoid the influence of fragments which are too far away\n  'varying vec2 vUv;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '\treturn texture2D( tDepth, screenPosition ).x;', '}', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec2 screenPosition ) {', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '}', 'void main() {', '\tfloat depth = getDepth( vUv );', '\tfloat viewZ = getViewZ( depth );', '\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );', '\tvec3 viewNormal = getViewNormal( vUv );', ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );', '\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;', // compute matrix used to reorient a kernel vector\n  '\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );', '\tvec3 bitangent = cross( viewNormal, tangent );', '\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );', ' float occlusion = 0.0;', ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {', '\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];', // reorient sample vector in view space\n  '\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );', // calculate sample point\n  '\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );', // project point and calculate NDC\n  '\t\tsamplePointNDC /= samplePointNDC.w;', '\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;', // compute uv coordinates\n  '\t\tfloat realDepth = getLinearDepth( samplePointUv );', // get linear depth from depth texture\n  '\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );', // compute linear depth of the sample view Z value\n  '\t\tfloat delta = sampleDepth - realDepth;', '\t\tif ( delta > minDistance && delta < maxDistance ) {', // if fragment is before sample point, increase occlusion\n  '\t\t\tocclusion += 1.0;', '\t\t}', '\t}', '\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );', '\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );', '}'].join('\\n')\n};\nexports.SSAOShader = SSAOShader;\nvar SSAODepthShader = {\n  defines: {\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    cameraNear: {\n      value: null\n    },\n    cameraFar: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'varying vec2 vUv;', '#include <packing>', 'float getLinearDepth( const in vec2 screenPosition ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\t#else', '\t\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'void main() {', '\tfloat depth = getLinearDepth( vUv );', '\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );', '}'].join('\\n')\n};\nexports.SSAODepthShader = SSAODepthShader;\nvar SSAOBlurShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    resolution: {\n      value: new _three.Vector2()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\tvec2 texelSize = ( 1.0 / resolution );', '\tfloat result = 0.0;', '\tfor ( int i = - 2; i <= 2; i ++ ) {', '\t\tfor ( int j = - 2; j <= 2; j ++ ) {', '\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;', '\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;', '\t\t}', '\t}', '\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );', '}'].join('\\n')\n};\nexports.SSAOBlurShader = SSAOBlurShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","kernel","cameraProjectionMatrix","tNormal","SSAOShader","PERSPECTIVE_CAMERA","cameraInverseProjectionMatrix","cameraFar","SSAODepthShader","kernelRadius","__esModule","tDiffuse","KERNEL_SIZE","defines","maxDistance","vertexShader","tNoise","minDistance","value","tDepth","SSAOBlurShader","cameraNear","uniforms","resolution"]],"~:compiled-at",1630917515500,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$SSAOShader.js\",\n\"lineCount\":5,\n\"mappings\":\"AAAAA,cAAA,CAAA,mDAAA,CAAwE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGhHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,UAAR,CAAqBJ,OAAQK,CAAAA,eAA7B,CAA+CL,OAAQM,CAAAA,cAAvD,CAAwE,IAAK,EAEzEC,OAAAA,CAAST,OAAA,CAAQ,8CAAR,CAQTM,QAAAA,CAAa,CACfI,QAAS,CACPC,mBAAoB,CADb,CAEPC,YAAa,EAFN,CADM,CAKfC,SAAU,CACRC,SAAU,CACRT,MAAO,IADC,CADF,CAIRU,QAAS,CACPV,MAAO,IADA,CAJD,CAORW,OAAQ,CACNX,MAAO,IADD,CAPA,CAURY,OAAQ,CACNZ,MAAO,IADD,CAVA,CAaRa,OAAQ,CACNb,MAAO,IADD,CAbA,CAgBRc,WAAY,CACVd,MAAO,IADG,CAhBJ,CAmBRe,UAAW,CACTf,MAAO,IADE,CAnBH;AAsBRgB,WAAY,CACVhB,MAAO,IAAII,MAAOa,CAAAA,OADR,CAtBJ,CAyBRC,uBAAwB,CACtBlB,MAAO,IAAII,MAAOe,CAAAA,OADI,CAzBhB,CA4BRC,8BAA+B,CAC7BpB,MAAO,IAAII,MAAOe,CAAAA,OADW,CA5BvB,CA+BRE,aAAc,CACZrB,MAAO,CADK,CA/BN,CAkCRsB,YAAa,CACXtB,MAAO,IADI,CAlCL,CAqCRuB,YAAa,CACXvB,MAAO,GADI,CArCL,CALK,CA8CfwB,aAAiJ,qIA9ClI,CA+CfC,eAUmK,o/FAzDpJ,CA2DjB5B;OAAQI,CAAAA,UAAR,CAAqBA,OAmBrBJ,QAAQK,CAAAA,eAAR,CAlBsBA,CACpBG,QAAS,CACPC,mBAAoB,CADb,CADWJ,CAIpBM,SAAU,CACRG,OAAQ,CACNX,MAAO,IADD,CADA,CAIRc,WAAY,CACVd,MAAO,IADG,CAJJ,CAORe,UAAW,CACTf,MAAO,IADE,CAPH,CAJUE,CAepBsB,aAAiJ,qIAf7HtB,CAgBpBuB,eAA8nB,mnBAhB1mBvB,CAmBlBC;MAAAA,CAAiB,CACnBK,SAAU,CACRC,SAAU,CACRT,MAAO,IADC,CADF,CAIRgB,WAAY,CACVhB,MAAO,IAAII,MAAOa,CAAAA,OADR,CAJJ,CADS,CASnBO,aAAiJ,qIAT9H,CAUnBC,eAA8c,sdAV3b,CAYrB5B;OAAQM,CAAAA,cAAR,CAAyBA,MA3GuF;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/SSAOShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$SSAOShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.SSAOShader = exports.SSAODepthShader = exports.SSAOBlurShader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * References:\\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\\n * https://learnopengl.com/Advanced-Lighting/SSAO\\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\\n */\\nvar SSAOShader = {\\n  defines: {\\n    PERSPECTIVE_CAMERA: 1,\\n    KERNEL_SIZE: 32\\n  },\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    tNormal: {\\n      value: null\\n    },\\n    tDepth: {\\n      value: null\\n    },\\n    tNoise: {\\n      value: null\\n    },\\n    kernel: {\\n      value: null\\n    },\\n    cameraNear: {\\n      value: null\\n    },\\n    cameraFar: {\\n      value: null\\n    },\\n    resolution: {\\n      value: new _three.Vector2()\\n    },\\n    cameraProjectionMatrix: {\\n      value: new _three.Matrix4()\\n    },\\n    cameraInverseProjectionMatrix: {\\n      value: new _three.Matrix4()\\n    },\\n    kernelRadius: {\\n      value: 8\\n    },\\n    minDistance: {\\n      value: 0.005\\n    },\\n    maxDistance: {\\n      value: 0.05\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform sampler2D tNormal;', 'uniform sampler2D tDepth;', 'uniform sampler2D tNoise;', 'uniform vec3 kernel[ KERNEL_SIZE ];', 'uniform vec2 resolution;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float kernelRadius;', 'uniform float minDistance;', // avoid artifacts caused by neighbour fragments with minimal depth difference\\n  'uniform float maxDistance;', // avoid the influence of fragments which are too far away\\n  'varying vec2 vUv;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '\\treturn texture2D( tDepth, screenPosition ).x;', '}', 'float getLinearDepth( const in vec2 screenPosition ) {', '\\t#if PERSPECTIVE_CAMERA == 1', '\\t\\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\\t\\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\\t\\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\\t#else', '\\t\\treturn texture2D( tDepth, screenPosition ).x;', '\\t#endif', '}', 'float getViewZ( const in float depth ) {', '\\t#if PERSPECTIVE_CAMERA == 1', '\\t\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\\t#else', '\\t\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\\tclipPosition *= clipW; // unprojection.', '\\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec2 screenPosition ) {', '\\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '}', 'void main() {', '\\tfloat depth = getDepth( vUv );', '\\tfloat viewZ = getViewZ( depth );', '\\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );', '\\tvec3 viewNormal = getViewNormal( vUv );', ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );', '\\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;', // compute matrix used to reorient a kernel vector\\n  '\\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );', '\\tvec3 bitangent = cross( viewNormal, tangent );', '\\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );', ' float occlusion = 0.0;', ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {', '\\t\\tvec3 sampleVector = kernelMatrix * kernel[ i ];', // reorient sample vector in view space\\n  '\\t\\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );', // calculate sample point\\n  '\\t\\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );', // project point and calculate NDC\\n  '\\t\\tsamplePointNDC /= samplePointNDC.w;', '\\t\\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;', // compute uv coordinates\\n  '\\t\\tfloat realDepth = getLinearDepth( samplePointUv );', // get linear depth from depth texture\\n  '\\t\\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );', // compute linear depth of the sample view Z value\\n  '\\t\\tfloat delta = sampleDepth - realDepth;', '\\t\\tif ( delta > minDistance && delta < maxDistance ) {', // if fragment is before sample point, increase occlusion\\n  '\\t\\t\\tocclusion += 1.0;', '\\t\\t}', '\\t}', '\\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );', '\\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );', '}'].join('\\\\n')\\n};\\nexports.SSAOShader = SSAOShader;\\nvar SSAODepthShader = {\\n  defines: {\\n    PERSPECTIVE_CAMERA: 1\\n  },\\n  uniforms: {\\n    tDepth: {\\n      value: null\\n    },\\n    cameraNear: {\\n      value: null\\n    },\\n    cameraFar: {\\n      value: null\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform sampler2D tDepth;', 'uniform float cameraNear;', 'uniform float cameraFar;', 'varying vec2 vUv;', '#include <packing>', 'float getLinearDepth( const in vec2 screenPosition ) {', '\\t#if PERSPECTIVE_CAMERA == 1', '\\t\\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;', '\\t\\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );', '\\t\\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );', '\\t#else', '\\t\\treturn texture2D( tDepth, screenPosition ).x;', '\\t#endif', '}', 'void main() {', '\\tfloat depth = getLinearDepth( vUv );', '\\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );', '}'].join('\\\\n')\\n};\\nexports.SSAODepthShader = SSAODepthShader;\\nvar SSAOBlurShader = {\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    resolution: {\\n      value: new _three.Vector2()\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform vec2 resolution;', 'varying vec2 vUv;', 'void main() {', '\\tvec2 texelSize = ( 1.0 / resolution );', '\\tfloat result = 0.0;', '\\tfor ( int i = - 2; i <= 2; i ++ ) {', '\\t\\tfor ( int j = - 2; j <= 2; j ++ ) {', '\\t\\t\\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;', '\\t\\t\\tresult += texture2D( tDiffuse, vUv + offset ).r;', '\\t\\t}', '\\t}', '\\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );', '}'].join('\\\\n')\\n};\\nexports.SSAOBlurShader = SSAOBlurShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"SSAOShader\",\"SSAODepthShader\",\"SSAOBlurShader\",\"_three\",\"defines\",\"PERSPECTIVE_CAMERA\",\"KERNEL_SIZE\",\"uniforms\",\"tDiffuse\",\"tNormal\",\"tDepth\",\"tNoise\",\"kernel\",\"cameraNear\",\"cameraFar\",\"resolution\",\"Vector2\",\"cameraProjectionMatrix\",\"Matrix4\",\"cameraInverseProjectionMatrix\",\"kernelRadius\",\"minDistance\",\"maxDistance\",\"vertexShader\",\"fragmentShader\"]\n}\n"]