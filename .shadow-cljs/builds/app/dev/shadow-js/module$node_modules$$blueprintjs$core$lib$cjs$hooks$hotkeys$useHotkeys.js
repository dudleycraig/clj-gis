["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@blueprintjs/core/lib/cjs/hooks/hotkeys/useHotkeys.js"],"~:js","shadow$provide.module$node_modules$$blueprintjs$core$lib$cjs$hooks$hotkeys$useHotkeys=function(global$jscomp$0,require,module,exports){function isTargetATextInput(e){e=e.target;if(null==e||null==e.closest)return!1;e=e.closest(\"input, textarea, [contenteditable\\x3dtrue]\");if(null==e)return!1;if(\"input\"===e.tagName.toLowerCase()){var inputType=e.type;if(\"checkbox\"===inputType||\"radio\"===inputType)return!1}return e.readOnly?!1:!0}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.useHotkeys=\nvoid 0;var tslib_1=require(\"module$node_modules$tslib$tslib\"),React=tslib_1.__importStar(require(\"module$node_modules$react$index\")),hotkeyParser_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$components$hotkeys$hotkeyParser\"),context_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$context$index\");exports.useHotkeys=function(keys,options){void 0===options&&(options={});var _a$jscomp$0=options.document;void 0===_a$jscomp$0&&(_a$jscomp$0=\"undefined\"===typeof window?void 0:window.document);\nvar document=_a$jscomp$0;options=options.showDialogKeyCombo;var showDialogKeyCombo=void 0===options?\"?\":options,localKeys=React.useMemo(function(){return keys.filter(function(k){return!k.global}).map(function(k){return{combo:hotkeyParser_1.parseKeyCombo(k.combo),config:k}})},[keys]),globalKeys=React.useMemo(function(){return keys.filter(function(k){return k.global}).map(function(k){return{combo:hotkeyParser_1.parseKeyCombo(k.combo),config:k}})},[keys]),dispatch=React.useContext(context_1.HotkeysContext)[1];\nReact.useEffect(function(){var payload=tslib_1.__spreadArrays(globalKeys.map(function(k){return k.config}),localKeys.map(function(k){return k.config}));dispatch({type:\"ADD_HOTKEYS\",payload});return function(){return dispatch({type:\"REMOVE_HOTKEYS\",payload})}},[keys]);var invokeNamedCallbackIfComboRecognized=function(global,combo,callbackName,e){var _a,_b,isTextInput=isTargetATextInput(e),_i=0;for(global=global?globalKeys:localKeys;_i<global.length;_i++){var key=global[_i],_d=key.config,_e=_d.allowInInput;\n_e=void 0===_e?!1:_e;var _f=_d.disabled;_f=void 0===_f?!1:_f;var _g=_d.preventDefault;_g=void 0===_g?!1:_g;_d=_d.stopPropagation;_d=void 0===_d?!1:_d;isTextInput&&!_e||_f||!hotkeyParser_1.comboMatches(key.combo,combo)||(_g&&e.preventDefault(),_d&&(e.isPropagationStopped=!0,e.stopPropagation()),null===(_b=(_a=key.config)[callbackName])||void 0===_b?void 0:_b.call(_a,e))}},handleGlobalKeyDown=React.useCallback(function(e){var combo=hotkeyParser_1.getKeyCombo(e);!isTargetATextInput(e)&&hotkeyParser_1.comboMatches(hotkeyParser_1.parseKeyCombo(showDialogKeyCombo),\ncombo)?dispatch({type:\"OPEN_DIALOG\"}):invokeNamedCallbackIfComboRecognized(!0,hotkeyParser_1.getKeyCombo(e),\"onKeyDown\",e)},[globalKeys]),handleGlobalKeyUp=React.useCallback(function(e){return invokeNamedCallbackIfComboRecognized(!0,hotkeyParser_1.getKeyCombo(e),\"onKeyUp\",e)},[globalKeys]);options=React.useCallback(function(e){return invokeNamedCallbackIfComboRecognized(!1,hotkeyParser_1.getKeyCombo(e.nativeEvent),\"onKeyDown\",e.nativeEvent)},[localKeys]);_a$jscomp$0=React.useCallback(function(e){return invokeNamedCallbackIfComboRecognized(!1,\nhotkeyParser_1.getKeyCombo(e.nativeEvent),\"onKeyUp\",e.nativeEvent)},[localKeys]);React.useEffect(function(){document.addEventListener(\"keydown\",handleGlobalKeyDown);document.addEventListener(\"keyup\",handleGlobalKeyUp);return function(){document.removeEventListener(\"keydown\",handleGlobalKeyDown);document.removeEventListener(\"keyup\",handleGlobalKeyUp)}},[handleGlobalKeyDown,handleGlobalKeyUp]);return{handleKeyDown:options,handleKeyUp:_a$jscomp$0}}}","~:source","shadow$provide[\"module$node_modules$$blueprintjs$core$lib$cjs$hooks$hotkeys$useHotkeys\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useHotkeys = void 0;\nvar tslib_1 = require(\"tslib\");\nvar React = tslib_1.__importStar(require(\"react\"));\nvar hotkeyParser_1 = require(\"../../components/hotkeys/hotkeyParser\");\nvar context_1 = require(\"../../context\");\n/**\n * React hook to register global and local hotkeys for a component.\n *\n * @param keys list of hotkeys to configure\n * @param options hook options\n */\nfunction useHotkeys(keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.document, document = _a === void 0 ? getDefaultDocument() : _a, _b = options.showDialogKeyCombo, showDialogKeyCombo = _b === void 0 ? \"?\" : _b;\n    var localKeys = React.useMemo(function () {\n        return keys\n            .filter(function (k) { return !k.global; })\n            .map(function (k) { return ({\n            combo: hotkeyParser_1.parseKeyCombo(k.combo),\n            config: k,\n        }); });\n    }, [keys]);\n    var globalKeys = React.useMemo(function () {\n        return keys\n            .filter(function (k) { return k.global; })\n            .map(function (k) { return ({\n            combo: hotkeyParser_1.parseKeyCombo(k.combo),\n            config: k,\n        }); });\n    }, [keys]);\n    // register keys with global context\n    var _c = React.useContext(context_1.HotkeysContext), dispatch = _c[1];\n    React.useEffect(function () {\n        var payload = tslib_1.__spreadArrays(globalKeys.map(function (k) { return k.config; }), localKeys.map(function (k) { return k.config; }));\n        dispatch({ type: \"ADD_HOTKEYS\", payload: payload });\n        return function () { return dispatch({ type: \"REMOVE_HOTKEYS\", payload: payload }); };\n    }, [keys]);\n    var invokeNamedCallbackIfComboRecognized = function (global, combo, callbackName, e) {\n        var _a, _b;\n        var isTextInput = isTargetATextInput(e);\n        for (var _i = 0, _c = global ? globalKeys : localKeys; _i < _c.length; _i++) {\n            var key = _c[_i];\n            var _d = key.config, _e = _d.allowInInput, allowInInput = _e === void 0 ? false : _e, _f = _d.disabled, disabled = _f === void 0 ? false : _f, _g = _d.preventDefault, preventDefault = _g === void 0 ? false : _g, _h = _d.stopPropagation, stopPropagation = _h === void 0 ? false : _h;\n            var shouldIgnore = (isTextInput && !allowInInput) || disabled;\n            if (!shouldIgnore && hotkeyParser_1.comboMatches(key.combo, combo)) {\n                if (preventDefault) {\n                    e.preventDefault();\n                }\n                if (stopPropagation) {\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\n                    e.isPropagationStopped = true;\n                    e.stopPropagation();\n                }\n                (_b = (_a = key.config)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n            }\n        }\n    };\n    var handleGlobalKeyDown = React.useCallback(function (e) {\n        // special case for global keydown: if '?' is pressed, open the hotkeys dialog\n        var combo = hotkeyParser_1.getKeyCombo(e);\n        var isTextInput = isTargetATextInput(e);\n        if (!isTextInput && hotkeyParser_1.comboMatches(hotkeyParser_1.parseKeyCombo(showDialogKeyCombo), combo)) {\n            dispatch({ type: \"OPEN_DIALOG\" });\n        }\n        else {\n            invokeNamedCallbackIfComboRecognized(true, hotkeyParser_1.getKeyCombo(e), \"onKeyDown\", e);\n        }\n    }, [globalKeys]);\n    var handleGlobalKeyUp = React.useCallback(function (e) { return invokeNamedCallbackIfComboRecognized(true, hotkeyParser_1.getKeyCombo(e), \"onKeyUp\", e); }, [globalKeys]);\n    var handleLocalKeyDown = React.useCallback(function (e) {\n        return invokeNamedCallbackIfComboRecognized(false, hotkeyParser_1.getKeyCombo(e.nativeEvent), \"onKeyDown\", e.nativeEvent);\n    }, [localKeys]);\n    var handleLocalKeyUp = React.useCallback(function (e) {\n        return invokeNamedCallbackIfComboRecognized(false, hotkeyParser_1.getKeyCombo(e.nativeEvent), \"onKeyUp\", e.nativeEvent);\n    }, [localKeys]);\n    React.useEffect(function () {\n        // document is guaranteed to be defined inside effects\n        document.addEventListener(\"keydown\", handleGlobalKeyDown);\n        document.addEventListener(\"keyup\", handleGlobalKeyUp);\n        return function () {\n            document.removeEventListener(\"keydown\", handleGlobalKeyDown);\n            document.removeEventListener(\"keyup\", handleGlobalKeyUp);\n        };\n    }, [handleGlobalKeyDown, handleGlobalKeyUp]);\n    return { handleKeyDown: handleLocalKeyDown, handleKeyUp: handleLocalKeyUp };\n}\nexports.useHotkeys = useHotkeys;\n/**\n * @returns true if the event target is a text input which should take priority over hotkey bindings\n */\nfunction isTargetATextInput(e) {\n    var elem = e.target;\n    // we check these cases for unit testing, but this should not happen\n    // during normal operation\n    if (elem == null || elem.closest == null) {\n        return false;\n    }\n    var editable = elem.closest(\"input, textarea, [contenteditable=true]\");\n    if (editable == null) {\n        return false;\n    }\n    // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\n    if (editable.tagName.toLowerCase() === \"input\") {\n        var inputType = editable.type;\n        if (inputType === \"checkbox\" || inputType === \"radio\") {\n            return false;\n        }\n    }\n    // don't let read-only fields prevent hotkey behavior\n    if (editable.readOnly) {\n        return false;\n    }\n    return true;\n}\nfunction getDefaultDocument() {\n    if (typeof window === \"undefined\") {\n        return undefined;\n    }\n    return window.document;\n}\n//# sourceMappingURL=useHotkeys.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$tslib$tslib","~$module$node_modules$$blueprintjs$core$lib$cjs$components$hotkeys$hotkeyParser","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$$blueprintjs$core$lib$cjs$context$index"]],"~:properties",["^5",["config","handleKeyUp","__esModule","combo","value","handleKeyDown","type","isPropagationStopped","payload","useHotkeys"]],"~:compiled-at",1630405505195,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$blueprintjs$core$lib$cjs$hooks$hotkeys$useHotkeys.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@blueprintjs/core/lib/cjs/hooks/hotkeys/useHotkeys.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$blueprintjs$core$lib$cjs$hooks$hotkeys$useHotkeys\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n/*\\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.useHotkeys = void 0;\\nvar tslib_1 = require(\\\"tslib\\\");\\nvar React = tslib_1.__importStar(require(\\\"react\\\"));\\nvar hotkeyParser_1 = require(\\\"../../components/hotkeys/hotkeyParser\\\");\\nvar context_1 = require(\\\"../../context\\\");\\n/**\\n * React hook to register global and local hotkeys for a component.\\n *\\n * @param keys list of hotkeys to configure\\n * @param options hook options\\n */\\nfunction useHotkeys(keys, options) {\\n    if (options === void 0) { options = {}; }\\n    var _a = options.document, document = _a === void 0 ? getDefaultDocument() : _a, _b = options.showDialogKeyCombo, showDialogKeyCombo = _b === void 0 ? \\\"?\\\" : _b;\\n    var localKeys = React.useMemo(function () {\\n        return keys\\n            .filter(function (k) { return !k.global; })\\n            .map(function (k) { return ({\\n            combo: hotkeyParser_1.parseKeyCombo(k.combo),\\n            config: k,\\n        }); });\\n    }, [keys]);\\n    var globalKeys = React.useMemo(function () {\\n        return keys\\n            .filter(function (k) { return k.global; })\\n            .map(function (k) { return ({\\n            combo: hotkeyParser_1.parseKeyCombo(k.combo),\\n            config: k,\\n        }); });\\n    }, [keys]);\\n    // register keys with global context\\n    var _c = React.useContext(context_1.HotkeysContext), dispatch = _c[1];\\n    React.useEffect(function () {\\n        var payload = tslib_1.__spreadArrays(globalKeys.map(function (k) { return k.config; }), localKeys.map(function (k) { return k.config; }));\\n        dispatch({ type: \\\"ADD_HOTKEYS\\\", payload: payload });\\n        return function () { return dispatch({ type: \\\"REMOVE_HOTKEYS\\\", payload: payload }); };\\n    }, [keys]);\\n    var invokeNamedCallbackIfComboRecognized = function (global, combo, callbackName, e) {\\n        var _a, _b;\\n        var isTextInput = isTargetATextInput(e);\\n        for (var _i = 0, _c = global ? globalKeys : localKeys; _i < _c.length; _i++) {\\n            var key = _c[_i];\\n            var _d = key.config, _e = _d.allowInInput, allowInInput = _e === void 0 ? false : _e, _f = _d.disabled, disabled = _f === void 0 ? false : _f, _g = _d.preventDefault, preventDefault = _g === void 0 ? false : _g, _h = _d.stopPropagation, stopPropagation = _h === void 0 ? false : _h;\\n            var shouldIgnore = (isTextInput && !allowInInput) || disabled;\\n            if (!shouldIgnore && hotkeyParser_1.comboMatches(key.combo, combo)) {\\n                if (preventDefault) {\\n                    e.preventDefault();\\n                }\\n                if (stopPropagation) {\\n                    // set a flag just for unit testing. not meant to be referenced in feature work.\\n                    e.isPropagationStopped = true;\\n                    e.stopPropagation();\\n                }\\n                (_b = (_a = key.config)[callbackName]) === null || _b === void 0 ? void 0 : _b.call(_a, e);\\n            }\\n        }\\n    };\\n    var handleGlobalKeyDown = React.useCallback(function (e) {\\n        // special case for global keydown: if '?' is pressed, open the hotkeys dialog\\n        var combo = hotkeyParser_1.getKeyCombo(e);\\n        var isTextInput = isTargetATextInput(e);\\n        if (!isTextInput && hotkeyParser_1.comboMatches(hotkeyParser_1.parseKeyCombo(showDialogKeyCombo), combo)) {\\n            dispatch({ type: \\\"OPEN_DIALOG\\\" });\\n        }\\n        else {\\n            invokeNamedCallbackIfComboRecognized(true, hotkeyParser_1.getKeyCombo(e), \\\"onKeyDown\\\", e);\\n        }\\n    }, [globalKeys]);\\n    var handleGlobalKeyUp = React.useCallback(function (e) { return invokeNamedCallbackIfComboRecognized(true, hotkeyParser_1.getKeyCombo(e), \\\"onKeyUp\\\", e); }, [globalKeys]);\\n    var handleLocalKeyDown = React.useCallback(function (e) {\\n        return invokeNamedCallbackIfComboRecognized(false, hotkeyParser_1.getKeyCombo(e.nativeEvent), \\\"onKeyDown\\\", e.nativeEvent);\\n    }, [localKeys]);\\n    var handleLocalKeyUp = React.useCallback(function (e) {\\n        return invokeNamedCallbackIfComboRecognized(false, hotkeyParser_1.getKeyCombo(e.nativeEvent), \\\"onKeyUp\\\", e.nativeEvent);\\n    }, [localKeys]);\\n    React.useEffect(function () {\\n        // document is guaranteed to be defined inside effects\\n        document.addEventListener(\\\"keydown\\\", handleGlobalKeyDown);\\n        document.addEventListener(\\\"keyup\\\", handleGlobalKeyUp);\\n        return function () {\\n            document.removeEventListener(\\\"keydown\\\", handleGlobalKeyDown);\\n            document.removeEventListener(\\\"keyup\\\", handleGlobalKeyUp);\\n        };\\n    }, [handleGlobalKeyDown, handleGlobalKeyUp]);\\n    return { handleKeyDown: handleLocalKeyDown, handleKeyUp: handleLocalKeyUp };\\n}\\nexports.useHotkeys = useHotkeys;\\n/**\\n * @returns true if the event target is a text input which should take priority over hotkey bindings\\n */\\nfunction isTargetATextInput(e) {\\n    var elem = e.target;\\n    // we check these cases for unit testing, but this should not happen\\n    // during normal operation\\n    if (elem == null || elem.closest == null) {\\n        return false;\\n    }\\n    var editable = elem.closest(\\\"input, textarea, [contenteditable=true]\\\");\\n    if (editable == null) {\\n        return false;\\n    }\\n    // don't let checkboxes, switches, and radio buttons prevent hotkey behavior\\n    if (editable.tagName.toLowerCase() === \\\"input\\\") {\\n        var inputType = editable.type;\\n        if (inputType === \\\"checkbox\\\" || inputType === \\\"radio\\\") {\\n            return false;\\n        }\\n    }\\n    // don't let read-only fields prevent hotkey behavior\\n    if (editable.readOnly) {\\n        return false;\\n    }\\n    return true;\\n}\\nfunction getDefaultDocument() {\\n    if (typeof window === \\\"undefined\\\") {\\n        return undefined;\\n    }\\n    return window.document;\\n}\\n//# sourceMappingURL=useHotkeys.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"isTargetATextInput\",\"e\",\"elem\",\"target\",\"closest\",\"editable\",\"tagName\",\"toLowerCase\",\"inputType\",\"type\",\"readOnly\",\"Object\",\"defineProperty\",\"value\",\"useHotkeys\",\"tslib_1\",\"React\",\"__importStar\",\"hotkeyParser_1\",\"context_1\",\"keys\",\"options\",\"_a\",\"document\",\"window\",\"undefined\",\"_b\",\"showDialogKeyCombo\",\"localKeys\",\"useMemo\",\"filter\",\"k\",\"map\",\"combo\",\"parseKeyCombo\",\"config\",\"globalKeys\",\"dispatch\",\"useContext\",\"_c\",\"HotkeysContext\",\"useEffect\",\"payload\",\"__spreadArrays\",\"invokeNamedCallbackIfComboRecognized\",\"callbackName\",\"isTextInput\",\"_i\",\"length\",\"key\",\"_d\",\"_e\",\"allowInInput\",\"_f\",\"disabled\",\"_g\",\"preventDefault\",\"_h\",\"stopPropagation\",\"comboMatches\",\"isPropagationStopped\",\"call\",\"handleGlobalKeyDown\",\"useCallback\",\"getKeyCombo\",\"handleGlobalKeyUp\",\"handleLocalKeyDown\",\"nativeEvent\",\"handleLocalKeyUp\",\"addEventListener\",\"removeEventListener\",\"handleKeyDown\",\"handleKeyUp\"]\n}\n"]