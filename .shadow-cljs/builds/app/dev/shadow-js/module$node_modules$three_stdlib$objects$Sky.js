["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/objects/Sky.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$objects$Sky=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||\nObject.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,\np){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.Sky=void 0;global=function(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}(require(\"module$node_modules$$babel$runtime$helpers$esm$defineProperty\"));var _three=require(\"module$node_modules$three$build$three_module\");require=function(_Mesh){function Sky(){if(!(this instanceof Sky))throw new TypeError(\"Cannot call a class as a function\");var call=_getPrototypeOf(Sky).call(this,\nnew _three.BoxGeometry(1,1,1),Sky.material);if(!call||\"object\"!==_typeof(call)&&\"function\"!==typeof call){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");call=this}return call}_inherits(Sky,_Mesh);return Sky}(_three.Mesh);exports.Sky=require;(0,global[\"default\"])(require,\"SkyShader\",{uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new _three.Vector3},up:{value:new _three.Vector3(0,\n1,0)}},vertexShader:\"uniform vec3 sunPosition;\\nuniform float rayleigh;\\nuniform float turbidity;\\nuniform float mieCoefficient;\\nuniform vec3 up;\\nvarying vec3 vWorldPosition;\\nvarying vec3 vSunDirection;\\nvarying float vSunfade;\\nvarying vec3 vBetaR;\\nvarying vec3 vBetaM;\\nvarying float vSunE;\\nconst float e \\x3d 2.71828182845904523536028747135266249775724709369995957;\\nconst float pi \\x3d 3.141592653589793238462643383279502884197169;\\nconst vec3 lambda \\x3d vec3( 680E-9, 550E-9, 450E-9 );\\nconst vec3 totalRayleigh \\x3d vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\\nconst float v \\x3d 4.0;\\nconst vec3 K \\x3d vec3( 0.686, 0.678, 0.666 );\\nconst vec3 MieConst \\x3d vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\\nconst float cutoffAngle \\x3d 1.6110731556870734;\\nconst float steepness \\x3d 1.5;\\nconst float EE \\x3d 1000.0;\\nfloat sunIntensity( float zenithAngleCos ) {\\n\\tzenithAngleCos \\x3d clamp( zenithAngleCos, -1.0, 1.0 );\\n\\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\\n}\\nvec3 totalMie( float T ) {\\n\\tfloat c \\x3d ( 0.2 * T ) * 10E-18;\\n\\treturn 0.434 * c * MieConst;\\n}\\nvoid main() {\\n\\tvec4 worldPosition \\x3d modelMatrix * vec4( position, 1.0 );\\n\\tvWorldPosition \\x3d worldPosition.xyz;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position.z \\x3d gl_Position.w;\\n\\tvSunDirection \\x3d normalize( sunPosition );\\n\\tvSunE \\x3d sunIntensity( dot( vSunDirection, up ) );\\n\\tvSunfade \\x3d 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\\n\\tfloat rayleighCoefficient \\x3d rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\\n\\tvBetaR \\x3d totalRayleigh * rayleighCoefficient;\\n\\tvBetaM \\x3d totalMie( turbidity ) * mieCoefficient;\\n}\",\nfragmentShader:\"varying vec3 vWorldPosition;\\nvarying vec3 vSunDirection;\\nvarying float vSunfade;\\nvarying vec3 vBetaR;\\nvarying vec3 vBetaM;\\nvarying float vSunE;\\nuniform float mieDirectionalG;\\nuniform vec3 up;\\nconst vec3 cameraPos \\x3d vec3( 0.0, 0.0, 0.0 );\\nconst float pi \\x3d 3.141592653589793238462643383279502884197169;\\nconst float n \\x3d 1.0003;\\nconst float N \\x3d 2.545E25;\\nconst float rayleighZenithLength \\x3d 8.4E3;\\nconst float mieZenithLength \\x3d 1.25E3;\\nconst float sunAngularDiameterCos \\x3d 0.999956676946448443553574619906976478926848692873900859324;\\nconst float THREE_OVER_SIXTEENPI \\x3d 0.05968310365946075;\\nconst float ONE_OVER_FOURPI \\x3d 0.07957747154594767;\\nfloat rayleighPhase( float cosTheta ) {\\n\\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\\n}\\nfloat hgPhase( float cosTheta, float g ) {\\n\\tfloat g2 \\x3d pow( g, 2.0 );\\n\\tfloat inverse \\x3d 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\\n\\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\\n}\\nvoid main() {\\n\\tvec3 direction \\x3d normalize( vWorldPosition - cameraPos );\\n\\tfloat zenithAngle \\x3d acos( max( 0.0, dot( up, direction ) ) );\\n\\tfloat inverse \\x3d 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\\n\\tfloat sR \\x3d rayleighZenithLength * inverse;\\n\\tfloat sM \\x3d mieZenithLength * inverse;\\n\\tvec3 Fex \\x3d exp( -( vBetaR * sR + vBetaM * sM ) );\\n\\tfloat cosTheta \\x3d dot( direction, vSunDirection );\\n\\tfloat rPhase \\x3d rayleighPhase( cosTheta * 0.5 + 0.5 );\\n\\tvec3 betaRTheta \\x3d vBetaR * rPhase;\\n\\tfloat mPhase \\x3d hgPhase( cosTheta, mieDirectionalG );\\n\\tvec3 betaMTheta \\x3d vBetaM * mPhase;\\n\\tvec3 Lin \\x3d pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\\n\\tLin *\\x3d mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\\n\\tfloat theta \\x3d acos( direction.y ); // elevation --\\x3e y-axis, [-pi/2, pi/2]\\n\\tfloat phi \\x3d atan( direction.z, direction.x ); // azimuth --\\x3e x-axis [-pi/2, pi/2]\\n\\tvec2 uv \\x3d vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\\n\\tvec3 L0 \\x3d vec3( 0.1 ) * Fex;\\n\\tfloat sundisk \\x3d smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\\n\\tL0 +\\x3d ( vSunE * 19000.0 * Fex ) * sundisk;\\n\\tvec3 texColor \\x3d ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\\n\\tvec3 retColor \\x3d pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\\n\\tgl_FragColor \\x3d vec4( retColor, 1.0 );\\n#include \\x3ctonemapping_fragment\\x3e\\n#include \\x3cencodings_fragment\\x3e\\n}\"});\n(0,global[\"default\"])(require,\"material\",new _three.ShaderMaterial({name:\"SkyShader\",fragmentShader:require.SkyShader.fragmentShader,vertexShader:require.SkyShader.vertexShader,uniforms:_three.UniformsUtils.clone(require.SkyShader.uniforms),side:_three.BackSide,depthWrite:!1}))}","~:source","shadow$provide[\"module$node_modules$three_stdlib$objects$Sky\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Sky = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/esm/defineProperty\"));\n\nvar _three = require(\"three\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Based on \"A Practical Analytic Model for Daylight\"\n * aka The Preetham Model, the de facto standard analytic skydome model\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\n *\n * First implemented by Simon Wallner\n * http://www.simonwallner.at/projects/atmospheric-scattering\n *\n * Improved by Martin Upitis\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\n *\n * Three.js integration by zz85 http://twitter.com/blurspline\n */\nvar Sky =\n/*#__PURE__*/\nfunction (_Mesh) {\n  _inherits(Sky, _Mesh);\n\n  function Sky() {\n    _classCallCheck(this, Sky);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Sky).call(this, new _three.BoxGeometry(1, 1, 1), Sky.material));\n  }\n\n  return Sky;\n}(_three.Mesh);\n\nexports.Sky = Sky;\n(0, _defineProperty2[\"default\"])(Sky, \"SkyShader\", {\n  uniforms: {\n    turbidity: {\n      value: 2\n    },\n    rayleigh: {\n      value: 1\n    },\n    mieCoefficient: {\n      value: 0.005\n    },\n    mieDirectionalG: {\n      value: 0.8\n    },\n    sunPosition: {\n      value: new _three.Vector3()\n    },\n    up: {\n      value: new _three.Vector3(0, 1, 0)\n    }\n  },\n  vertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', // constants for atmospheric scattering\n  'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', // wavelength of used primaries, according to preetham\n  'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );', // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n  'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );', // mie stuff\n  // K coefficient for the primaries\n  'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );', // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n  'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );', // earth shadow hack\n  // cutoffAngle = pi / 1.95;\n  'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '\tfloat c = ( 0.2 * T ) * 10E-18;', '\treturn 0.434 * c * MieConst;', '}', 'void main() {', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvWorldPosition = worldPosition.xyz;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position.z = gl_Position.w;', // set z to camera.far\n  '\tvSunDirection = normalize( sunPosition );', '\tvSunE = sunIntensity( dot( vSunDirection, up ) );', '\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );', // extinction (absorbtion + out scattering)\n  // rayleigh coefficients\n  '\tvBetaR = totalRayleigh * rayleighCoefficient;', // mie coefficients\n  '\tvBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\\n'),\n  fragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float mieDirectionalG;', 'uniform vec3 up;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );', // constants for atmospheric scattering\n  'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air\n  'const float N = 2.545E25;', // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n  // optical length at zenith for molecules\n  'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', // 66 arc seconds -> degrees, and the cosine of that\n  'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', // 3.0 / ( 16.0 * pi )\n  'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;', // 1.0 / ( 4.0 * pi )\n  'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '\tfloat g2 = pow( g, 2.0 );', '\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}', 'void main() {', '\tvec3 direction = normalize( vWorldPosition - cameraPos );', // optical length\n  // cutoff angle at 90 to avoid singularity in next formula.\n  '\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );', '\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '\tfloat sR = rayleighZenithLength * inverse;', '\tfloat sM = mieZenithLength * inverse;', // combined extinction factor\n  '\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );', // in scattering\n  '\tfloat cosTheta = dot( direction, vSunDirection );', '\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '\tvec3 betaRTheta = vBetaR * rPhase;', '\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );', '\tvec3 betaMTheta = vBetaM * mPhase;', '\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );', // nightsky\n  '\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '\tvec3 L0 = vec3( 0.1 ) * Fex;', // composition + solar disc\n  '\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );', '\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;', '\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '\tgl_FragColor = vec4( retColor, 1.0 );', '#include <tonemapping_fragment>', '#include <encodings_fragment>', '}'].join('\\n')\n});\n(0, _defineProperty2[\"default\"])(Sky, \"material\", new _three.ShaderMaterial({\n  name: 'SkyShader',\n  fragmentShader: Sky.SkyShader.fragmentShader,\n  vertexShader: Sky.SkyShader.vertexShader,\n  uniforms: _three.UniformsUtils.clone(Sky.SkyShader.uniforms),\n  side: _three.BackSide,\n  depthWrite: false\n}));\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$$babel$runtime$helpers$esm$defineProperty"]],"~:properties",["^5",["fragmentShader","up","prototype","side","turbidity","__esModule","mieDirectionalG","Sky","vertexShader","name","configurable","value","mieCoefficient","rayleigh","writable","__proto__","depthWrite","uniforms","constructor","sunPosition"]],"~:compiled-at",1630917515393,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$objects$Sky.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/objects/Sky.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$objects$Sky\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.Sky = void 0;\\n\\nvar _defineProperty2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/esm/defineProperty\\\"));\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \\\"default\\\": obj }; }\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * Based on \\\"A Practical Analytic Model for Daylight\\\"\\n * aka The Preetham Model, the de facto standard analytic skydome model\\n * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight\\n *\\n * First implemented by Simon Wallner\\n * http://www.simonwallner.at/projects/atmospheric-scattering\\n *\\n * Improved by Martin Upitis\\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\\n *\\n * Three.js integration by zz85 http://twitter.com/blurspline\\n */\\nvar Sky =\\n/*#__PURE__*/\\nfunction (_Mesh) {\\n  _inherits(Sky, _Mesh);\\n\\n  function Sky() {\\n    _classCallCheck(this, Sky);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(Sky).call(this, new _three.BoxGeometry(1, 1, 1), Sky.material));\\n  }\\n\\n  return Sky;\\n}(_three.Mesh);\\n\\nexports.Sky = Sky;\\n(0, _defineProperty2[\\\"default\\\"])(Sky, \\\"SkyShader\\\", {\\n  uniforms: {\\n    turbidity: {\\n      value: 2\\n    },\\n    rayleigh: {\\n      value: 1\\n    },\\n    mieCoefficient: {\\n      value: 0.005\\n    },\\n    mieDirectionalG: {\\n      value: 0.8\\n    },\\n    sunPosition: {\\n      value: new _three.Vector3()\\n    },\\n    up: {\\n      value: new _three.Vector3(0, 1, 0)\\n    }\\n  },\\n  vertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', // constants for atmospheric scattering\\n  'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', // wavelength of used primaries, according to preetham\\n  'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );', // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\\n  // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\\n  'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );', // mie stuff\\n  // K coefficient for the primaries\\n  'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );', // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\\n  'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );', // earth shadow hack\\n  // cutoffAngle = pi / 1.95;\\n  'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '\\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '\\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '\\tfloat c = ( 0.2 * T ) * 10E-18;', '\\treturn 0.434 * c * MieConst;', '}', 'void main() {', '\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\\tvWorldPosition = worldPosition.xyz;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\\tgl_Position.z = gl_Position.w;', // set z to camera.far\\n  '\\tvSunDirection = normalize( sunPosition );', '\\tvSunE = sunIntensity( dot( vSunDirection, up ) );', '\\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '\\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );', // extinction (absorbtion + out scattering)\\n  // rayleigh coefficients\\n  '\\tvBetaR = totalRayleigh * rayleighCoefficient;', // mie coefficients\\n  '\\tvBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\\\\n'),\\n  fragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float mieDirectionalG;', 'uniform vec3 up;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );', // constants for atmospheric scattering\\n  'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air\\n  'const float N = 2.545E25;', // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\\n  // optical length at zenith for molecules\\n  'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', // 66 arc seconds -> degrees, and the cosine of that\\n  'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', // 3.0 / ( 16.0 * pi )\\n  'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;', // 1.0 / ( 4.0 * pi )\\n  'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '\\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '\\tfloat g2 = pow( g, 2.0 );', '\\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '\\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}', 'void main() {', '\\tvec3 direction = normalize( vWorldPosition - cameraPos );', // optical length\\n  // cutoff angle at 90 to avoid singularity in next formula.\\n  '\\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );', '\\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '\\tfloat sR = rayleighZenithLength * inverse;', '\\tfloat sM = mieZenithLength * inverse;', // combined extinction factor\\n  '\\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );', // in scattering\\n  '\\tfloat cosTheta = dot( direction, vSunDirection );', '\\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '\\tvec3 betaRTheta = vBetaR * rPhase;', '\\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );', '\\tvec3 betaMTheta = vBetaM * mPhase;', '\\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '\\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );', // nightsky\\n  '\\tfloat theta = acos( direction.y ); // elevation --\\u003e y-axis, [-pi/2, pi/2]', '\\tfloat phi = atan( direction.z, direction.x ); // azimuth --\\u003e x-axis [-pi/2, pi/2]', '\\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '\\tvec3 L0 = vec3( 0.1 ) * Fex;', // composition + solar disc\\n  '\\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );', '\\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;', '\\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '\\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '\\tgl_FragColor = vec4( retColor, 1.0 );', '#include <tonemapping_fragment>', '#include <encodings_fragment>', '}'].join('\\\\n')\\n});\\n(0, _defineProperty2[\\\"default\\\"])(Sky, \\\"material\\\", new _three.ShaderMaterial({\\n  name: 'SkyShader',\\n  fragmentShader: Sky.SkyShader.fragmentShader,\\n  vertexShader: Sky.SkyShader.vertexShader,\\n  uniforms: _three.UniformsUtils.clone(Sky.SkyShader.uniforms),\\n  side: _three.BackSide,\\n  depthWrite: false\\n}));\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"defineProperty\",\"Sky\",\"_defineProperty2\",\"_interopRequireDefault\",\"__esModule\",\"_three\",\"_Mesh\",\"instance\",\"call\",\"BoxGeometry\",\"material\",\"self\",\"ReferenceError\",\"Mesh\",\"uniforms\",\"turbidity\",\"rayleigh\",\"mieCoefficient\",\"mieDirectionalG\",\"sunPosition\",\"Vector3\",\"up\",\"vertexShader\",\"fragmentShader\",\"ShaderMaterial\",\"name\",\"SkyShader\",\"UniformsUtils\",\"clone\",\"side\",\"BackSide\",\"depthWrite\"]\n}\n"]