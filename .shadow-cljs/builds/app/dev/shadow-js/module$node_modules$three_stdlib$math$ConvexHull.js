["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/math/ConvexHull.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$math$ConvexHull=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ConvexHull=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(){function ConvexHull(){this.tolerance=-1;this.faces=[];this.newFaces=[];this.assigned=new VertexList;this.unassigned=new VertexList;this.vertices=[]}function Face(){this.normal=new _three.Vector3;this.midpoint=new _three.Vector3;this.constant=\nthis.area=0;this.outside=null;this.mark=0;this.edge=null}function HalfEdge(vertex,face){this.vertex=vertex;this.twin=this.next=this.prev=null;this.face=face}function VertexNode(point){this.point=point;this.face=this.next=this.prev=null}function VertexList(){this.tail=this.head=null}var v1=new _three.Vector3;Object.assign(ConvexHull.prototype,{setFromPoints:function(points){!0!==Array.isArray(points)&&console.error(\"THREE.ConvexHull: Points parameter is not an array.\");4>points.length&&console.error(\"THREE.ConvexHull: The algorithm needs at least four points.\");\nthis.makeEmpty();for(var i=0,l=points.length;i<l;i++)this.vertices.push(new VertexNode(points[i]));this.compute();return this},setFromObject:function(object){var points=[];object.updateMatrixWorld(!0);object.traverse(function(node){var l;var i=node.geometry;if(void 0!==i)if(i.isGeometry)console.error(\"THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.\");else if(i.isBufferGeometry){var attribute=i.attributes.position;if(void 0!==attribute)for(i=0,l=attribute.count;i<l;i++){var point=\nnew _three.Vector3;point.fromBufferAttribute(attribute,i).applyMatrix4(node.matrixWorld);points.push(point)}}});return this.setFromPoints(points)},containsPoint:function(point){for(var faces=this.faces,i=0,l=faces.length;i<l;i++)if(faces[i].distanceToPoint(point)>this.tolerance)return!1;return!0},intersectRay:function(ray,target){for(var faces=this.faces,tNear=-Infinity,tFar=Infinity,i=0,l=faces.length;i<l;i++){var face=faces[i],vN=face.distanceToPoint(ray.origin);face=face.normal.dot(ray.direction);\nif(0<vN&&0<=face)return null;vN=0!==face?-vN/face:0;if(!(0>=vN)&&(0<face?tFar=Math.min(vN,tFar):tNear=Math.max(vN,tNear),tNear>tFar))return null}-Infinity!==tNear?ray.at(tNear,target):ray.at(tFar,target);return target},intersectsRay:function(ray){return null!==this.intersectRay(ray,v1)},makeEmpty:function(){this.faces=[];this.vertices=[];return this},addVertexToFace:function(vertex,face){vertex.face=face;null===face.outside?this.assigned.append(vertex):this.assigned.insertBefore(face.outside,vertex);\nface.outside=vertex;return this},removeVertexFromFace:function(vertex,face){vertex===face.outside&&(face.outside=null!==vertex.next&&vertex.next.face===face?vertex.next:null);this.assigned.remove(vertex);return this},removeAllVerticesFromFace:function(face){if(null!==face.outside){for(var start=face.outside,end=face.outside;null!==end.next&&end.next.face===face;)end=end.next;this.assigned.removeSubList(start,end);start.prev=end.next=null;face.outside=null;return start}},deleteFaceVertices:function(face,\nabsorbingFace){face=this.removeAllVerticesFromFace(face);if(void 0!==face)if(void 0===absorbingFace)this.unassigned.appendChain(face);else{do{var nextVertex=face.next;absorbingFace.distanceToPoint(face.point)>this.tolerance?this.addVertexToFace(face,absorbingFace):this.unassigned.append(face);face=nextVertex}while(null!==face)}return this},resolveUnassignedPoints:function(newFaces){if(!1===this.unassigned.isEmpty()){var vertex=this.unassigned.first();do{for(var nextVertex=vertex.next,maxDistance=\nthis.tolerance,maxFace=null,i=0;i<newFaces.length;i++){var face=newFaces[i];if(0===face.mark){var distance=face.distanceToPoint(vertex.point);distance>maxDistance&&(maxDistance=distance,maxFace=face);if(maxDistance>1E3*this.tolerance)break}}null!==maxFace&&this.addVertexToFace(vertex,maxFace);vertex=nextVertex}while(null!==vertex)}return this},computeExtremes:function(){var min=new _three.Vector3,max=new _three.Vector3,minVertices=[],maxVertices=[],i,l,j;for(i=0;3>i;i++)minVertices[i]=maxVertices[i]=\nthis.vertices[0];min.copy(this.vertices[0].point);max.copy(this.vertices[0].point);i=0;for(l=this.vertices.length;i<l;i++){var vertex=this.vertices[i],point=vertex.point;for(j=0;3>j;j++)point.getComponent(j)<min.getComponent(j)&&(min.setComponent(j,point.getComponent(j)),minVertices[j]=vertex);for(j=0;3>j;j++)point.getComponent(j)>max.getComponent(j)&&(max.setComponent(j,point.getComponent(j)),maxVertices[j]=vertex)}this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(min.x),Math.abs(max.x))+Math.max(Math.abs(min.y),\nMath.abs(max.y))+Math.max(Math.abs(min.z),Math.abs(max.z)));return{min:minVertices,max:maxVertices}},computeInitialHull:function(){var line3,plane,closestPoint;return function(){void 0===line3&&(line3=new _three.Line3,plane=new _three.Plane,closestPoint=new _three.Vector3);var vertices=this.vertices,extremes=this.computeExtremes(),min=extremes.min,max=extremes.max,l,j,maxDistance=0;for(extremes=j=0;3>extremes;extremes++){var distance=max[extremes].point.getComponent(extremes)-min[extremes].point.getComponent(extremes);\ndistance>maxDistance&&(maxDistance=distance,j=extremes)}min=min[j];max=max[j];maxDistance=0;line3.set(min.point,max.point);extremes=0;for(l=this.vertices.length;extremes<l;extremes++){var vertex=vertices[extremes];if(vertex!==min&&vertex!==max&&(line3.closestPointToPoint(vertex.point,!0,closestPoint),distance=closestPoint.distanceToSquared(vertex.point),distance>maxDistance)){maxDistance=distance;var v2=vertex}}maxDistance=-1;plane.setFromCoplanarPoints(min.point,max.point,v2.point);extremes=0;for(l=\nthis.vertices.length;extremes<l;extremes++)if(vertex=vertices[extremes],vertex!==min&&vertex!==max&&vertex!==v2&&(distance=Math.abs(plane.distanceToPoint(vertex.point)),distance>maxDistance)){maxDistance=distance;var v3=vertex}distance=[];if(0>plane.distanceToPoint(v3.point))for(distance.push(Face.create(min,max,v2),Face.create(v3,max,min),Face.create(v3,v2,max),Face.create(v3,min,v2)),extremes=0;3>extremes;extremes++)j=(extremes+1)%3,distance[extremes+1].getEdge(2).setTwin(distance[0].getEdge(j)),\ndistance[extremes+1].getEdge(1).setTwin(distance[j+1].getEdge(0));else for(distance.push(Face.create(min,v2,max),Face.create(v3,min,max),Face.create(v3,max,v2),Face.create(v3,v2,min)),extremes=0;3>extremes;extremes++)j=(extremes+1)%3,distance[extremes+1].getEdge(2).setTwin(distance[0].getEdge((3-extremes)%3)),distance[extremes+1].getEdge(0).setTwin(distance[j+1].getEdge(1));for(extremes=0;4>extremes;extremes++)this.faces.push(distance[extremes]);extremes=0;for(l=vertices.length;extremes<l;extremes++)if(vertex=\nvertices[extremes],vertex!==min&&vertex!==max&&vertex!==v2&&vertex!==v3){maxDistance=this.tolerance;var maxFace=null;for(j=0;4>j;j++)distance=this.faces[j].distanceToPoint(vertex.point),distance>maxDistance&&(maxDistance=distance,maxFace=this.faces[j]);null!==maxFace&&this.addVertexToFace(vertex,maxFace)}return this}}(),reindexFaces:function(){for(var activeFaces=[],i=0;i<this.faces.length;i++){var face=this.faces[i];0===face.mark&&activeFaces.push(face)}this.faces=activeFaces;return this},nextVertexToAdd:function(){if(!1===\nthis.assigned.isEmpty()){var maxDistance=0,eyeFace=this.assigned.first().face,vertex=eyeFace.outside;do{var distance=eyeFace.distanceToPoint(vertex.point);if(distance>maxDistance){maxDistance=distance;var eyeVertex=vertex}vertex=vertex.next}while(null!==vertex&&vertex.face===eyeFace);return eyeVertex}},computeHorizon:function(eyePoint,crossEdge,face,horizon){this.deleteFaceVertices(face);face.mark=1;face=null===crossEdge?crossEdge=face.getEdge(0):crossEdge.next;do{var twinEdge=face.twin,oppositeFace=\ntwinEdge.face;0===oppositeFace.mark&&(oppositeFace.distanceToPoint(eyePoint)>this.tolerance?this.computeHorizon(eyePoint,twinEdge,oppositeFace,horizon):horizon.push(face));face=face.next}while(face!==crossEdge);return this},addAdjoiningFace:function(eyeVertex,horizonEdge){eyeVertex=Face.create(eyeVertex,horizonEdge.tail(),horizonEdge.head());this.faces.push(eyeVertex);eyeVertex.getEdge(-1).setTwin(horizonEdge.twin);return eyeVertex.getEdge(0)},addNewFaces:function(eyeVertex,horizon){this.newFaces=\n[];for(var firstSideEdge=null,previousSideEdge=null,i=0;i<horizon.length;i++){var sideEdge=this.addAdjoiningFace(eyeVertex,horizon[i]);null===firstSideEdge?firstSideEdge=sideEdge:sideEdge.next.setTwin(previousSideEdge);this.newFaces.push(sideEdge.face);previousSideEdge=sideEdge}firstSideEdge.next.setTwin(previousSideEdge);return this},addVertexToHull:function(eyeVertex){var horizon=[];this.unassigned.clear();this.removeVertexFromFace(eyeVertex,eyeVertex.face);this.computeHorizon(eyeVertex.point,null,\neyeVertex.face,horizon);this.addNewFaces(eyeVertex,horizon);this.resolveUnassignedPoints(this.newFaces);return this},cleanup:function(){this.assigned.clear();this.unassigned.clear();this.newFaces=[];return this},compute:function(){var vertex;for(this.computeInitialHull();void 0!==(vertex=this.nextVertexToAdd());)this.addVertexToHull(vertex);this.reindexFaces();this.cleanup();return this}});Object.assign(Face,{create:function(a,b,c){var face=new Face;a=new HalfEdge(a,face);b=new HalfEdge(b,face);c=\nnew HalfEdge(c,face);a.next=c.prev=b;b.next=a.prev=c;c.next=b.prev=a;face.edge=a;return face.compute()}});Object.assign(Face.prototype,{getEdge:function(i){for(var edge=this.edge;0<i;)edge=edge.next,i--;for(;0>i;)edge=edge.prev,i++;return edge},compute:function(){var triangle;return function(){void 0===triangle&&(triangle=new _three.Triangle);var a=this.edge.tail(),b=this.edge.head(),c=this.edge.next.head();triangle.set(a.point,b.point,c.point);triangle.getNormal(this.normal);triangle.getMidpoint(this.midpoint);\nthis.area=triangle.getArea();this.constant=this.normal.dot(this.midpoint);return this}}(),distanceToPoint:function(point){return this.normal.dot(point)-this.constant}});Object.assign(HalfEdge.prototype,{head:function(){return this.vertex},tail:function(){return this.prev?this.prev.vertex:null},length:function(){var head=this.head(),tail=this.tail();return null!==tail?tail.point.distanceTo(head.point):-1},lengthSquared:function(){var head=this.head(),tail=this.tail();return null!==tail?tail.point.distanceToSquared(head.point):\n-1},setTwin:function(edge){this.twin=edge;edge.twin=this;return this}});Object.assign(VertexList.prototype,{first:function(){return this.head},last:function(){return this.tail},clear:function(){this.head=this.tail=null;return this},insertBefore:function(target,vertex){vertex.prev=target.prev;vertex.next=target;null===vertex.prev?this.head=vertex:vertex.prev.next=vertex;target.prev=vertex;return this},insertAfter:function(target,vertex){vertex.prev=target;vertex.next=target.next;null===vertex.next?\nthis.tail=vertex:vertex.next.prev=vertex;target.next=vertex;return this},append:function(vertex){null===this.head?this.head=vertex:this.tail.next=vertex;vertex.prev=this.tail;vertex.next=null;this.tail=vertex;return this},appendChain:function(vertex){null===this.head?this.head=vertex:this.tail.next=vertex;for(vertex.prev=this.tail;null!==vertex.next;)vertex=vertex.next;this.tail=vertex;return this},remove:function(vertex){null===vertex.prev?this.head=vertex.next:vertex.prev.next=vertex.next;null===\nvertex.next?this.tail=vertex.prev:vertex.next.prev=vertex.prev;return this},removeSubList:function(a,b){null===a.prev?this.head=b.next:a.prev.next=b.next;null===b.next?this.tail=a.prev:b.next.prev=a.prev;return this},isEmpty:function(){return null===this.head}});return ConvexHull}();exports.ConvexHull=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$math$ConvexHull\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConvexHull = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\nvar ConvexHull = function () {\n  var Visible = 0;\n  var Deleted = 1;\n  var v1 = new _three.Vector3();\n\n  function ConvexHull() {\n    this.tolerance = -1;\n    this.faces = []; // the generated faces of the convex hull\n\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\n  }\n\n  Object.assign(ConvexHull.prototype, {\n    setFromPoints: function setFromPoints(points) {\n      if (Array.isArray(points) !== true) {\n        console.error('THREE.ConvexHull: Points parameter is not an array.');\n      }\n\n      if (points.length < 4) {\n        console.error('THREE.ConvexHull: The algorithm needs at least four points.');\n      }\n\n      this.makeEmpty();\n\n      for (var i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]));\n      }\n\n      this.compute();\n      return this;\n    },\n    setFromObject: function setFromObject(object) {\n      var points = [];\n      object.updateMatrixWorld(true);\n      object.traverse(function (node) {\n        var i, l, point;\n        var geometry = node.geometry;\n\n        if (geometry !== undefined) {\n          if (geometry.isGeometry) {\n            console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\n            return;\n          } else if (geometry.isBufferGeometry) {\n            var attribute = geometry.attributes.position;\n\n            if (attribute !== undefined) {\n              for (i = 0, l = attribute.count; i < l; i++) {\n                point = new _three.Vector3();\n                point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n                points.push(point);\n              }\n            }\n          }\n        }\n      });\n      return this.setFromPoints(points);\n    },\n    containsPoint: function containsPoint(point) {\n      var faces = this.faces;\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // compute signed distance and check on what half space the point lies\n\n        if (face.distanceToPoint(point) > this.tolerance) return false;\n      }\n\n      return true;\n    },\n    intersectRay: function intersectRay(ray, target) {\n      // based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n      var faces = this.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i]; // interpret faces as planes for the further computation\n\n        var vN = face.distanceToPoint(ray.origin);\n        var vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n        // the ray is turned away or parallel to the plane, there is no intersection\n\n        if (vN > 0 && vD >= 0) return null; // compute the distance from the rayâ€™s origin to the intersection with the plane\n\n        var t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\n        // lies \"behind\" the origin\n\n        if (t <= 0) continue; // now categorized plane as front-facing or back-facing\n\n        if (vD > 0) {\n          //  plane faces away from the ray, so this plane is a back-face\n          tFar = Math.min(t, tFar);\n        } else {\n          // front-face\n          tNear = Math.max(t, tNear);\n        }\n\n        if (tNear > tFar) {\n          // if tNear ever is greater than tFar, the ray must miss the convex hull\n          return null;\n        }\n      } // evaluate intersection point\n      // always try tNear first since its the closer intersection point\n\n\n      if (tNear !== -Infinity) {\n        ray.at(tNear, target);\n      } else {\n        ray.at(tFar, target);\n      }\n\n      return target;\n    },\n    intersectsRay: function intersectsRay(ray) {\n      return this.intersectRay(ray, v1) !== null;\n    },\n    makeEmpty: function makeEmpty() {\n      this.faces = [];\n      this.vertices = [];\n      return this;\n    },\n    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n    addVertexToFace: function addVertexToFace(vertex, face) {\n      vertex.face = face;\n\n      if (face.outside === null) {\n        this.assigned.append(vertex);\n      } else {\n        this.assigned.insertBefore(face.outside, vertex);\n      }\n\n      face.outside = vertex;\n      return this;\n    },\n    // Removes a vertex from the 'assigned' list of vertices and from the given face\n    removeVertexFromFace: function removeVertexFromFace(vertex, face) {\n      if (vertex === face.outside) {\n        // fix face.outside link\n        if (vertex.next !== null && vertex.next.face === face) {\n          // face has at least 2 outside vertices, move the 'outside' reference\n          face.outside = vertex.next;\n        } else {\n          // vertex was the only outside vertex that face had\n          face.outside = null;\n        }\n      }\n\n      this.assigned.remove(vertex);\n      return this;\n    },\n    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n    removeAllVerticesFromFace: function removeAllVerticesFromFace(face) {\n      if (face.outside !== null) {\n        // reference to the first and last vertex of this face\n        var start = face.outside;\n        var end = face.outside;\n\n        while (end.next !== null && end.next.face === face) {\n          end = end.next;\n        }\n\n        this.assigned.removeSubList(start, end); // fix references\n\n        start.prev = end.next = null;\n        face.outside = null;\n        return start;\n      }\n    },\n    // Removes all the visible vertices that 'face' is able to see\n    deleteFaceVertices: function deleteFaceVertices(face, absorbingFace) {\n      var faceVertices = this.removeAllVerticesFromFace(face);\n\n      if (faceVertices !== undefined) {\n        if (absorbingFace === undefined) {\n          // mark the vertices to be reassigned to some other face\n          this.unassigned.appendChain(faceVertices);\n        } else {\n          // if there's an absorbing face try to assign as many vertices as possible to it\n          var vertex = faceVertices;\n\n          do {\n            // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n            // will be changed by upcoming method calls\n            var nextVertex = vertex.next;\n            var distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\n\n            if (distance > this.tolerance) {\n              this.addVertexToFace(vertex, absorbingFace);\n            } else {\n              this.unassigned.append(vertex);\n            } // now assign next vertex\n\n\n            vertex = nextVertex;\n          } while (vertex !== null);\n        }\n      }\n\n      return this;\n    },\n    // Reassigns as many vertices as possible from the unassigned list to the new faces\n    resolveUnassignedPoints: function resolveUnassignedPoints(newFaces) {\n      if (this.unassigned.isEmpty() === false) {\n        var vertex = this.unassigned.first();\n\n        do {\n          // buffer 'next' reference, see .deleteFaceVertices()\n          var nextVertex = vertex.next;\n          var maxDistance = this.tolerance;\n          var maxFace = null;\n\n          for (var i = 0; i < newFaces.length; i++) {\n            var face = newFaces[i];\n\n            if (face.mark === Visible) {\n              var distance = face.distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n\n              if (maxDistance > 1000 * this.tolerance) break;\n            }\n          } // 'maxFace' can be null e.g. if there are identical vertices\n\n\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace);\n          }\n\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n\n      return this;\n    },\n    // Computes the extremes of a simplex which will be the initial hull\n    computeExtremes: function computeExtremes() {\n      var min = new _three.Vector3();\n      var max = new _three.Vector3();\n      var minVertices = [];\n      var maxVertices = [];\n      var i, l, j; // initially assume that the first vertex is the min/max\n\n      for (i = 0; i < 3; i++) {\n        minVertices[i] = maxVertices[i] = this.vertices[0];\n      }\n\n      min.copy(this.vertices[0].point);\n      max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\n\n      for (i = 0, l = this.vertices.length; i < l; i++) {\n        var vertex = this.vertices[i];\n        var point = vertex.point; // update the min coordinates\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) < min.getComponent(j)) {\n            min.setComponent(j, point.getComponent(j));\n            minVertices[j] = vertex;\n          }\n        } // update the max coordinates\n\n\n        for (j = 0; j < 3; j++) {\n          if (point.getComponent(j) > max.getComponent(j)) {\n            max.setComponent(j, point.getComponent(j));\n            maxVertices[j] = vertex;\n          }\n        }\n      } // use min/max vectors to compute an optimal epsilon\n\n\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    },\n    // Computes the initial simplex assigning to its faces all the points\n    // that are candidates to form part of the hull\n    computeInitialHull: function () {\n      var line3, plane, closestPoint;\n      return function computeInitialHull() {\n        if (line3 === undefined) {\n          line3 = new _three.Line3();\n          plane = new _three.Plane();\n          closestPoint = new _three.Vector3();\n        }\n\n        var vertex,\n            vertices = this.vertices;\n        var extremes = this.computeExtremes();\n        var min = extremes.min;\n        var max = extremes.max;\n        var v0, v1, v2, v3;\n        var i, l, j; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n        // (max.x - min.x)\n        // (max.y - min.y)\n        // (max.z - min.z)\n\n        var distance,\n            maxDistance = 0;\n        var index = 0;\n\n        for (i = 0; i < 3; i++) {\n          distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            index = i;\n          }\n        }\n\n        v0 = min[index];\n        v1 = max[index]; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n        maxDistance = 0;\n        line3.set(v0.point, v1.point);\n\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1) {\n            line3.closestPointToPoint(vertex.point, true, closestPoint);\n            distance = closestPoint.distanceToSquared(vertex.point);\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v2 = vertex;\n            }\n          }\n        } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\n        maxDistance = -1;\n        plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n\n        for (i = 0, l = this.vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n            distance = Math.abs(plane.distanceToPoint(vertex.point));\n\n            if (distance > maxDistance) {\n              maxDistance = distance;\n              v3 = vertex;\n            }\n          }\n        }\n\n        var faces = [];\n\n        if (plane.distanceToPoint(v3.point) < 0) {\n          // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n          faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n            faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n          }\n        } else {\n          // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n          faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\n\n          for (i = 0; i < 3; i++) {\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\n\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\n\n            faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n          }\n        } // the initial hull is the tetrahedron\n\n\n        for (i = 0; i < 4; i++) {\n          this.faces.push(faces[i]);\n        } // initial assignment of vertices to the faces of the tetrahedron\n\n\n        for (i = 0, l = vertices.length; i < l; i++) {\n          vertex = vertices[i];\n\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n            maxDistance = this.tolerance;\n            var maxFace = null;\n\n            for (j = 0; j < 4; j++) {\n              distance = this.faces[j].distanceToPoint(vertex.point);\n\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = this.faces[j];\n              }\n            }\n\n            if (maxFace !== null) {\n              this.addVertexToFace(vertex, maxFace);\n            }\n          }\n        }\n\n        return this;\n      };\n    }(),\n    // Removes inactive faces\n    reindexFaces: function reindexFaces() {\n      var activeFaces = [];\n\n      for (var i = 0; i < this.faces.length; i++) {\n        var face = this.faces[i];\n\n        if (face.mark === Visible) {\n          activeFaces.push(face);\n        }\n      }\n\n      this.faces = activeFaces;\n      return this;\n    },\n    // Finds the next vertex to create faces with the current hull\n    nextVertexToAdd: function nextVertexToAdd() {\n      // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n      if (this.assigned.isEmpty() === false) {\n        var eyeVertex,\n            maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\n\n        var eyeFace = this.assigned.first().face;\n        var vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\n\n        do {\n          var distance = eyeFace.distanceToPoint(vertex.point);\n\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            eyeVertex = vertex;\n          }\n\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === eyeFace);\n\n        return eyeVertex;\n      }\n    },\n    // Computes a chain of half edges in CCW order called the 'horizon'.\n    // For an edge to be part of the horizon it must join a face that can see\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\n    computeHorizon: function computeHorizon(eyePoint, crossEdge, face, horizon) {\n      // moves face's vertices to the 'unassigned' vertex list\n      this.deleteFaceVertices(face);\n      face.mark = Deleted;\n      var edge;\n\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        // start from the next edge since 'crossEdge' was already analyzed\n        // (actually 'crossEdge.twin' was the edge who called this method recursively)\n        edge = crossEdge.next;\n      }\n\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.face;\n\n        if (oppositeFace.mark === Visible) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n            // the opposite face can see the vertex, so proceed with next edge\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            // the opposite face can't see the vertex, so this edge is part of the horizon\n            horizon.push(edge);\n          }\n        }\n\n        edge = edge.next;\n      } while (edge !== crossEdge);\n\n      return this;\n    },\n    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n    addAdjoiningFace: function addAdjoiningFace(eyeVertex, horizonEdge) {\n      // all the half edges are created in ccw order thus the face is always pointing outside the hull\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n      this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n      face.getEdge(-1).setTwin(horizonEdge.twin);\n      return face.getEdge(0); // the half edge whose vertex is the eyeVertex\n    },\n    //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n    //  horizon opposite face and the face on the left/right\n    addNewFaces: function addNewFaces(eyeVertex, horizon) {\n      this.newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n\n      for (var i = 0; i < horizon.length; i++) {\n        var horizonEdge = horizon[i]; // returns the right side edge\n\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n          sideEdge.next.setTwin(previousSideEdge);\n        }\n\n        this.newFaces.push(sideEdge.face);\n        previousSideEdge = sideEdge;\n      } // perform final join of new faces\n\n\n      firstSideEdge.next.setTwin(previousSideEdge);\n      return this;\n    },\n    // Adds a vertex to the hull\n    addVertexToHull: function addVertexToHull(eyeVertex) {\n      var horizon = [];\n      this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n      this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\n\n      this.resolveUnassignedPoints(this.newFaces);\n      return this;\n    },\n    cleanup: function cleanup() {\n      this.assigned.clear();\n      this.unassigned.clear();\n      this.newFaces = [];\n      return this;\n    },\n    compute: function compute() {\n      var vertex;\n      this.computeInitialHull(); // add all available vertices gradually to the hull\n\n      while ((vertex = this.nextVertexToAdd()) !== undefined) {\n        this.addVertexToHull(vertex);\n      }\n\n      this.reindexFaces();\n      this.cleanup();\n      return this;\n    }\n  }); //\n\n  function Face() {\n    this.normal = new _three.Vector3();\n    this.midpoint = new _three.Vector3();\n    this.area = 0;\n    this.constant = 0; // signed distance from face to the origin\n\n    this.outside = null; // reference to a vertex in a vertex list this face can see\n\n    this.mark = Visible;\n    this.edge = null;\n  }\n\n  Object.assign(Face, {\n    create: function create(a, b, c) {\n      var face = new Face();\n      var e0 = new HalfEdge(a, face);\n      var e1 = new HalfEdge(b, face);\n      var e2 = new HalfEdge(c, face); // join edges\n\n      e0.next = e2.prev = e1;\n      e1.next = e0.prev = e2;\n      e2.next = e1.prev = e0; // main half edge reference\n\n      face.edge = e0;\n      return face.compute();\n    }\n  });\n  Object.assign(Face.prototype, {\n    getEdge: function getEdge(i) {\n      var edge = this.edge;\n\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n\n      return edge;\n    },\n    compute: function () {\n      var triangle;\n      return function compute() {\n        if (triangle === undefined) triangle = new _three.Triangle();\n        var a = this.edge.tail();\n        var b = this.edge.head();\n        var c = this.edge.next.head();\n        triangle.set(a.point, b.point, c.point);\n        triangle.getNormal(this.normal);\n        triangle.getMidpoint(this.midpoint);\n        this.area = triangle.getArea();\n        this.constant = this.normal.dot(this.midpoint);\n        return this;\n      };\n    }(),\n    distanceToPoint: function distanceToPoint(point) {\n      return this.normal.dot(point) - this.constant;\n    }\n  }); // Entity for a Doubly-Connected Edge List (DCEL).\n\n  function HalfEdge(vertex, face) {\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n\n  Object.assign(HalfEdge.prototype, {\n    head: function head() {\n      return this.vertex;\n    },\n    tail: function tail() {\n      return this.prev ? this.prev.vertex : null;\n    },\n    length: function length() {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceTo(head.point);\n      }\n\n      return -1;\n    },\n    lengthSquared: function lengthSquared() {\n      var head = this.head();\n      var tail = this.tail();\n\n      if (tail !== null) {\n        return tail.point.distanceToSquared(head.point);\n      }\n\n      return -1;\n    },\n    setTwin: function setTwin(edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n  }); // A vertex as a double linked list node.\n\n  function VertexNode(point) {\n    this.point = point;\n    this.prev = null;\n    this.next = null;\n    this.face = null; // the face that is able to see this vertex\n  } // A double linked list that contains vertex nodes.\n\n\n  function VertexList() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  Object.assign(VertexList.prototype, {\n    first: function first() {\n      return this.head;\n    },\n    last: function last() {\n      return this.tail;\n    },\n    clear: function clear() {\n      this.head = this.tail = null;\n      return this;\n    },\n    // Inserts a vertex before the target vertex\n    insertBefore: function insertBefore(target, vertex) {\n      vertex.prev = target.prev;\n      vertex.next = target;\n\n      if (vertex.prev === null) {\n        this.head = vertex;\n      } else {\n        vertex.prev.next = vertex;\n      }\n\n      target.prev = vertex;\n      return this;\n    },\n    // Inserts a vertex after the target vertex\n    insertAfter: function insertAfter(target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n\n      if (vertex.next === null) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n\n      target.next = vertex;\n      return this;\n    },\n    // Appends a vertex to the end of the linked list\n    append: function append(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail;\n      vertex.next = null; // the tail has no subsequent vertex\n\n      this.tail = vertex;\n      return this;\n    },\n    // Appends a chain of vertices where 'vertex' is the head.\n    appendChain: function appendChain(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n\n      vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\n\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n\n      this.tail = vertex;\n      return this;\n    },\n    // Removes a vertex from the linked list\n    remove: function remove(vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n\n      return this;\n    },\n    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n    removeSubList: function removeSubList(a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n\n      return this;\n    },\n    isEmpty: function isEmpty() {\n      return this.head === null;\n    }\n  });\n  return ConvexHull;\n}();\n\nexports.ConvexHull = ConvexHull;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["lengthSquared","tail","addAdjoiningFace","unassigned","nextVertexToAdd","min","cleanup","next","setTwin","intersectRay","deleteFaceVertices","area","constant","twin","distanceToPoint","assigned","containsPoint","__esModule","max","addVertexToFace","newFaces","setFromPoints","appendChain","computeInitialHull","edge","normal","resolveUnassignedPoints","insertBefore","face","outside","addVertexToHull","value","setFromObject","vertices","reindexFaces","prev","remove","faces","tolerance","makeEmpty","length","head","last","removeAllVerticesFromFace","append","removeVertexFromFace","create","vertex","intersectsRay","addNewFaces","removeSubList","isEmpty","getEdge","clear","insertAfter","mark","compute","ConvexHull","point","midpoint","computeHorizon","computeExtremes","first"]],"~:compiled-at",1630917515098,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$math$ConvexHull.js\",\n\"lineCount\":23,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/math/ConvexHull.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$math$ConvexHull\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ConvexHull = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\\n */\\nvar ConvexHull = function () {\\n  var Visible = 0;\\n  var Deleted = 1;\\n  var v1 = new _three.Vector3();\\n\\n  function ConvexHull() {\\n    this.tolerance = -1;\\n    this.faces = []; // the generated faces of the convex hull\\n\\n    this.newFaces = []; // this array holds the faces that are generated within a single iteration\\n    // the vertex lists work as follows:\\n    //\\n    // let 'a' and 'b' be 'Face' instances\\n    // let 'v' be points wrapped as instance of 'Vertex'\\n    //\\n    //     [v, v, ..., v, v, v, ...]\\n    //      ^             ^\\n    //      |             |\\n    //  a.outside     b.outside\\n    //\\n\\n    this.assigned = new VertexList();\\n    this.unassigned = new VertexList();\\n    this.vertices = []; // vertices of the hull (internal representation of given geometry data)\\n  }\\n\\n  Object.assign(ConvexHull.prototype, {\\n    setFromPoints: function setFromPoints(points) {\\n      if (Array.isArray(points) !== true) {\\n        console.error('THREE.ConvexHull: Points parameter is not an array.');\\n      }\\n\\n      if (points.length < 4) {\\n        console.error('THREE.ConvexHull: The algorithm needs at least four points.');\\n      }\\n\\n      this.makeEmpty();\\n\\n      for (var i = 0, l = points.length; i < l; i++) {\\n        this.vertices.push(new VertexNode(points[i]));\\n      }\\n\\n      this.compute();\\n      return this;\\n    },\\n    setFromObject: function setFromObject(object) {\\n      var points = [];\\n      object.updateMatrixWorld(true);\\n      object.traverse(function (node) {\\n        var i, l, point;\\n        var geometry = node.geometry;\\n\\n        if (geometry !== undefined) {\\n          if (geometry.isGeometry) {\\n            console.error('THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.');\\n            return;\\n          } else if (geometry.isBufferGeometry) {\\n            var attribute = geometry.attributes.position;\\n\\n            if (attribute !== undefined) {\\n              for (i = 0, l = attribute.count; i < l; i++) {\\n                point = new _three.Vector3();\\n                point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\\n                points.push(point);\\n              }\\n            }\\n          }\\n        }\\n      });\\n      return this.setFromPoints(points);\\n    },\\n    containsPoint: function containsPoint(point) {\\n      var faces = this.faces;\\n\\n      for (var i = 0, l = faces.length; i < l; i++) {\\n        var face = faces[i]; // compute signed distance and check on what half space the point lies\\n\\n        if (face.distanceToPoint(point) > this.tolerance) return false;\\n      }\\n\\n      return true;\\n    },\\n    intersectRay: function intersectRay(ray, target) {\\n      // based on \\\"Fast Ray-Convex Polyhedron Intersection\\\"  by Eric Haines, GRAPHICS GEMS II\\n      var faces = this.faces;\\n      var tNear = -Infinity;\\n      var tFar = Infinity;\\n\\n      for (var i = 0, l = faces.length; i < l; i++) {\\n        var face = faces[i]; // interpret faces as planes for the further computation\\n\\n        var vN = face.distanceToPoint(ray.origin);\\n        var vD = face.normal.dot(ray.direction); // if the origin is on the positive side of a plane (so the plane can \\\"see\\\" the origin) and\\n        // the ray is turned away or parallel to the plane, there is no intersection\\n\\n        if (vN > 0 && vD >= 0) return null; // compute the distance from the ray\\u2019s origin to the intersection with the plane\\n\\n        var t = vD !== 0 ? -vN / vD : 0; // only proceed if the distance is positive. a negative distance means the intersection point\\n        // lies \\\"behind\\\" the origin\\n\\n        if (t <= 0) continue; // now categorized plane as front-facing or back-facing\\n\\n        if (vD > 0) {\\n          //  plane faces away from the ray, so this plane is a back-face\\n          tFar = Math.min(t, tFar);\\n        } else {\\n          // front-face\\n          tNear = Math.max(t, tNear);\\n        }\\n\\n        if (tNear > tFar) {\\n          // if tNear ever is greater than tFar, the ray must miss the convex hull\\n          return null;\\n        }\\n      } // evaluate intersection point\\n      // always try tNear first since its the closer intersection point\\n\\n\\n      if (tNear !== -Infinity) {\\n        ray.at(tNear, target);\\n      } else {\\n        ray.at(tFar, target);\\n      }\\n\\n      return target;\\n    },\\n    intersectsRay: function intersectsRay(ray) {\\n      return this.intersectRay(ray, v1) !== null;\\n    },\\n    makeEmpty: function makeEmpty() {\\n      this.faces = [];\\n      this.vertices = [];\\n      return this;\\n    },\\n    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\\n    addVertexToFace: function addVertexToFace(vertex, face) {\\n      vertex.face = face;\\n\\n      if (face.outside === null) {\\n        this.assigned.append(vertex);\\n      } else {\\n        this.assigned.insertBefore(face.outside, vertex);\\n      }\\n\\n      face.outside = vertex;\\n      return this;\\n    },\\n    // Removes a vertex from the 'assigned' list of vertices and from the given face\\n    removeVertexFromFace: function removeVertexFromFace(vertex, face) {\\n      if (vertex === face.outside) {\\n        // fix face.outside link\\n        if (vertex.next !== null && vertex.next.face === face) {\\n          // face has at least 2 outside vertices, move the 'outside' reference\\n          face.outside = vertex.next;\\n        } else {\\n          // vertex was the only outside vertex that face had\\n          face.outside = null;\\n        }\\n      }\\n\\n      this.assigned.remove(vertex);\\n      return this;\\n    },\\n    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\\n    removeAllVerticesFromFace: function removeAllVerticesFromFace(face) {\\n      if (face.outside !== null) {\\n        // reference to the first and last vertex of this face\\n        var start = face.outside;\\n        var end = face.outside;\\n\\n        while (end.next !== null && end.next.face === face) {\\n          end = end.next;\\n        }\\n\\n        this.assigned.removeSubList(start, end); // fix references\\n\\n        start.prev = end.next = null;\\n        face.outside = null;\\n        return start;\\n      }\\n    },\\n    // Removes all the visible vertices that 'face' is able to see\\n    deleteFaceVertices: function deleteFaceVertices(face, absorbingFace) {\\n      var faceVertices = this.removeAllVerticesFromFace(face);\\n\\n      if (faceVertices !== undefined) {\\n        if (absorbingFace === undefined) {\\n          // mark the vertices to be reassigned to some other face\\n          this.unassigned.appendChain(faceVertices);\\n        } else {\\n          // if there's an absorbing face try to assign as many vertices as possible to it\\n          var vertex = faceVertices;\\n\\n          do {\\n            // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\\n            // will be changed by upcoming method calls\\n            var nextVertex = vertex.next;\\n            var distance = absorbingFace.distanceToPoint(vertex.point); // check if 'vertex' is able to see 'absorbingFace'\\n\\n            if (distance > this.tolerance) {\\n              this.addVertexToFace(vertex, absorbingFace);\\n            } else {\\n              this.unassigned.append(vertex);\\n            } // now assign next vertex\\n\\n\\n            vertex = nextVertex;\\n          } while (vertex !== null);\\n        }\\n      }\\n\\n      return this;\\n    },\\n    // Reassigns as many vertices as possible from the unassigned list to the new faces\\n    resolveUnassignedPoints: function resolveUnassignedPoints(newFaces) {\\n      if (this.unassigned.isEmpty() === false) {\\n        var vertex = this.unassigned.first();\\n\\n        do {\\n          // buffer 'next' reference, see .deleteFaceVertices()\\n          var nextVertex = vertex.next;\\n          var maxDistance = this.tolerance;\\n          var maxFace = null;\\n\\n          for (var i = 0; i < newFaces.length; i++) {\\n            var face = newFaces[i];\\n\\n            if (face.mark === Visible) {\\n              var distance = face.distanceToPoint(vertex.point);\\n\\n              if (distance > maxDistance) {\\n                maxDistance = distance;\\n                maxFace = face;\\n              }\\n\\n              if (maxDistance > 1000 * this.tolerance) break;\\n            }\\n          } // 'maxFace' can be null e.g. if there are identical vertices\\n\\n\\n          if (maxFace !== null) {\\n            this.addVertexToFace(vertex, maxFace);\\n          }\\n\\n          vertex = nextVertex;\\n        } while (vertex !== null);\\n      }\\n\\n      return this;\\n    },\\n    // Computes the extremes of a simplex which will be the initial hull\\n    computeExtremes: function computeExtremes() {\\n      var min = new _three.Vector3();\\n      var max = new _three.Vector3();\\n      var minVertices = [];\\n      var maxVertices = [];\\n      var i, l, j; // initially assume that the first vertex is the min/max\\n\\n      for (i = 0; i < 3; i++) {\\n        minVertices[i] = maxVertices[i] = this.vertices[0];\\n      }\\n\\n      min.copy(this.vertices[0].point);\\n      max.copy(this.vertices[0].point); // compute the min/max vertex on all six directions\\n\\n      for (i = 0, l = this.vertices.length; i < l; i++) {\\n        var vertex = this.vertices[i];\\n        var point = vertex.point; // update the min coordinates\\n\\n        for (j = 0; j < 3; j++) {\\n          if (point.getComponent(j) < min.getComponent(j)) {\\n            min.setComponent(j, point.getComponent(j));\\n            minVertices[j] = vertex;\\n          }\\n        } // update the max coordinates\\n\\n\\n        for (j = 0; j < 3; j++) {\\n          if (point.getComponent(j) > max.getComponent(j)) {\\n            max.setComponent(j, point.getComponent(j));\\n            maxVertices[j] = vertex;\\n          }\\n        }\\n      } // use min/max vectors to compute an optimal epsilon\\n\\n\\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\\n      return {\\n        min: minVertices,\\n        max: maxVertices\\n      };\\n    },\\n    // Computes the initial simplex assigning to its faces all the points\\n    // that are candidates to form part of the hull\\n    computeInitialHull: function () {\\n      var line3, plane, closestPoint;\\n      return function computeInitialHull() {\\n        if (line3 === undefined) {\\n          line3 = new _three.Line3();\\n          plane = new _three.Plane();\\n          closestPoint = new _three.Vector3();\\n        }\\n\\n        var vertex,\\n            vertices = this.vertices;\\n        var extremes = this.computeExtremes();\\n        var min = extremes.min;\\n        var max = extremes.max;\\n        var v0, v1, v2, v3;\\n        var i, l, j; // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\\n        // (max.x - min.x)\\n        // (max.y - min.y)\\n        // (max.z - min.z)\\n\\n        var distance,\\n            maxDistance = 0;\\n        var index = 0;\\n\\n        for (i = 0; i < 3; i++) {\\n          distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\\n\\n          if (distance > maxDistance) {\\n            maxDistance = distance;\\n            index = i;\\n          }\\n        }\\n\\n        v0 = min[index];\\n        v1 = max[index]; // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\\n\\n        maxDistance = 0;\\n        line3.set(v0.point, v1.point);\\n\\n        for (i = 0, l = this.vertices.length; i < l; i++) {\\n          vertex = vertices[i];\\n\\n          if (vertex !== v0 && vertex !== v1) {\\n            line3.closestPointToPoint(vertex.point, true, closestPoint);\\n            distance = closestPoint.distanceToSquared(vertex.point);\\n\\n            if (distance > maxDistance) {\\n              maxDistance = distance;\\n              v2 = vertex;\\n            }\\n          }\\n        } // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\\n\\n\\n        maxDistance = -1;\\n        plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\\n\\n        for (i = 0, l = this.vertices.length; i < l; i++) {\\n          vertex = vertices[i];\\n\\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\\n            distance = Math.abs(plane.distanceToPoint(vertex.point));\\n\\n            if (distance > maxDistance) {\\n              maxDistance = distance;\\n              v3 = vertex;\\n            }\\n          }\\n        }\\n\\n        var faces = [];\\n\\n        if (plane.distanceToPoint(v3.point) < 0) {\\n          // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\\n          faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2)); // set the twin edge\\n\\n          for (i = 0; i < 3; i++) {\\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\\n\\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j)); // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\\n\\n            faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\\n          }\\n        } else {\\n          // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\\n          faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0)); // set the twin edge\\n\\n          for (i = 0; i < 3; i++) {\\n            j = (i + 1) % 3; // join face[ i ] i > 0, with the first face\\n\\n            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3)); // join face[ i ] with face[ i + 1 ]\\n\\n            faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\\n          }\\n        } // the initial hull is the tetrahedron\\n\\n\\n        for (i = 0; i < 4; i++) {\\n          this.faces.push(faces[i]);\\n        } // initial assignment of vertices to the faces of the tetrahedron\\n\\n\\n        for (i = 0, l = vertices.length; i < l; i++) {\\n          vertex = vertices[i];\\n\\n          if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\\n            maxDistance = this.tolerance;\\n            var maxFace = null;\\n\\n            for (j = 0; j < 4; j++) {\\n              distance = this.faces[j].distanceToPoint(vertex.point);\\n\\n              if (distance > maxDistance) {\\n                maxDistance = distance;\\n                maxFace = this.faces[j];\\n              }\\n            }\\n\\n            if (maxFace !== null) {\\n              this.addVertexToFace(vertex, maxFace);\\n            }\\n          }\\n        }\\n\\n        return this;\\n      };\\n    }(),\\n    // Removes inactive faces\\n    reindexFaces: function reindexFaces() {\\n      var activeFaces = [];\\n\\n      for (var i = 0; i < this.faces.length; i++) {\\n        var face = this.faces[i];\\n\\n        if (face.mark === Visible) {\\n          activeFaces.push(face);\\n        }\\n      }\\n\\n      this.faces = activeFaces;\\n      return this;\\n    },\\n    // Finds the next vertex to create faces with the current hull\\n    nextVertexToAdd: function nextVertexToAdd() {\\n      // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\\n      if (this.assigned.isEmpty() === false) {\\n        var eyeVertex,\\n            maxDistance = 0; // grap the first available face and start with the first visible vertex of that face\\n\\n        var eyeFace = this.assigned.first().face;\\n        var vertex = eyeFace.outside; // now calculate the farthest vertex that face can see\\n\\n        do {\\n          var distance = eyeFace.distanceToPoint(vertex.point);\\n\\n          if (distance > maxDistance) {\\n            maxDistance = distance;\\n            eyeVertex = vertex;\\n          }\\n\\n          vertex = vertex.next;\\n        } while (vertex !== null && vertex.face === eyeFace);\\n\\n        return eyeVertex;\\n      }\\n    },\\n    // Computes a chain of half edges in CCW order called the 'horizon'.\\n    // For an edge to be part of the horizon it must join a face that can see\\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\\n    computeHorizon: function computeHorizon(eyePoint, crossEdge, face, horizon) {\\n      // moves face's vertices to the 'unassigned' vertex list\\n      this.deleteFaceVertices(face);\\n      face.mark = Deleted;\\n      var edge;\\n\\n      if (crossEdge === null) {\\n        edge = crossEdge = face.getEdge(0);\\n      } else {\\n        // start from the next edge since 'crossEdge' was already analyzed\\n        // (actually 'crossEdge.twin' was the edge who called this method recursively)\\n        edge = crossEdge.next;\\n      }\\n\\n      do {\\n        var twinEdge = edge.twin;\\n        var oppositeFace = twinEdge.face;\\n\\n        if (oppositeFace.mark === Visible) {\\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\\n            // the opposite face can see the vertex, so proceed with next edge\\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\\n          } else {\\n            // the opposite face can't see the vertex, so this edge is part of the horizon\\n            horizon.push(edge);\\n          }\\n        }\\n\\n        edge = edge.next;\\n      } while (edge !== crossEdge);\\n\\n      return this;\\n    },\\n    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\\n    addAdjoiningFace: function addAdjoiningFace(eyeVertex, horizonEdge) {\\n      // all the half edges are created in ccw order thus the face is always pointing outside the hull\\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\\n      this.faces.push(face); // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\\n\\n      face.getEdge(-1).setTwin(horizonEdge.twin);\\n      return face.getEdge(0); // the half edge whose vertex is the eyeVertex\\n    },\\n    //  Adds 'horizon.length' faces to the hull, each face will be linked with the\\n    //  horizon opposite face and the face on the left/right\\n    addNewFaces: function addNewFaces(eyeVertex, horizon) {\\n      this.newFaces = [];\\n      var firstSideEdge = null;\\n      var previousSideEdge = null;\\n\\n      for (var i = 0; i < horizon.length; i++) {\\n        var horizonEdge = horizon[i]; // returns the right side edge\\n\\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\\n\\n        if (firstSideEdge === null) {\\n          firstSideEdge = sideEdge;\\n        } else {\\n          // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\\n          sideEdge.next.setTwin(previousSideEdge);\\n        }\\n\\n        this.newFaces.push(sideEdge.face);\\n        previousSideEdge = sideEdge;\\n      } // perform final join of new faces\\n\\n\\n      firstSideEdge.next.setTwin(previousSideEdge);\\n      return this;\\n    },\\n    // Adds a vertex to the hull\\n    addVertexToHull: function addVertexToHull(eyeVertex) {\\n      var horizon = [];\\n      this.unassigned.clear(); // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\\n\\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\\n      this.addNewFaces(eyeVertex, horizon); // reassign 'unassigned' vertices to the new faces\\n\\n      this.resolveUnassignedPoints(this.newFaces);\\n      return this;\\n    },\\n    cleanup: function cleanup() {\\n      this.assigned.clear();\\n      this.unassigned.clear();\\n      this.newFaces = [];\\n      return this;\\n    },\\n    compute: function compute() {\\n      var vertex;\\n      this.computeInitialHull(); // add all available vertices gradually to the hull\\n\\n      while ((vertex = this.nextVertexToAdd()) !== undefined) {\\n        this.addVertexToHull(vertex);\\n      }\\n\\n      this.reindexFaces();\\n      this.cleanup();\\n      return this;\\n    }\\n  }); //\\n\\n  function Face() {\\n    this.normal = new _three.Vector3();\\n    this.midpoint = new _three.Vector3();\\n    this.area = 0;\\n    this.constant = 0; // signed distance from face to the origin\\n\\n    this.outside = null; // reference to a vertex in a vertex list this face can see\\n\\n    this.mark = Visible;\\n    this.edge = null;\\n  }\\n\\n  Object.assign(Face, {\\n    create: function create(a, b, c) {\\n      var face = new Face();\\n      var e0 = new HalfEdge(a, face);\\n      var e1 = new HalfEdge(b, face);\\n      var e2 = new HalfEdge(c, face); // join edges\\n\\n      e0.next = e2.prev = e1;\\n      e1.next = e0.prev = e2;\\n      e2.next = e1.prev = e0; // main half edge reference\\n\\n      face.edge = e0;\\n      return face.compute();\\n    }\\n  });\\n  Object.assign(Face.prototype, {\\n    getEdge: function getEdge(i) {\\n      var edge = this.edge;\\n\\n      while (i > 0) {\\n        edge = edge.next;\\n        i--;\\n      }\\n\\n      while (i < 0) {\\n        edge = edge.prev;\\n        i++;\\n      }\\n\\n      return edge;\\n    },\\n    compute: function () {\\n      var triangle;\\n      return function compute() {\\n        if (triangle === undefined) triangle = new _three.Triangle();\\n        var a = this.edge.tail();\\n        var b = this.edge.head();\\n        var c = this.edge.next.head();\\n        triangle.set(a.point, b.point, c.point);\\n        triangle.getNormal(this.normal);\\n        triangle.getMidpoint(this.midpoint);\\n        this.area = triangle.getArea();\\n        this.constant = this.normal.dot(this.midpoint);\\n        return this;\\n      };\\n    }(),\\n    distanceToPoint: function distanceToPoint(point) {\\n      return this.normal.dot(point) - this.constant;\\n    }\\n  }); // Entity for a Doubly-Connected Edge List (DCEL).\\n\\n  function HalfEdge(vertex, face) {\\n    this.vertex = vertex;\\n    this.prev = null;\\n    this.next = null;\\n    this.twin = null;\\n    this.face = face;\\n  }\\n\\n  Object.assign(HalfEdge.prototype, {\\n    head: function head() {\\n      return this.vertex;\\n    },\\n    tail: function tail() {\\n      return this.prev ? this.prev.vertex : null;\\n    },\\n    length: function length() {\\n      var head = this.head();\\n      var tail = this.tail();\\n\\n      if (tail !== null) {\\n        return tail.point.distanceTo(head.point);\\n      }\\n\\n      return -1;\\n    },\\n    lengthSquared: function lengthSquared() {\\n      var head = this.head();\\n      var tail = this.tail();\\n\\n      if (tail !== null) {\\n        return tail.point.distanceToSquared(head.point);\\n      }\\n\\n      return -1;\\n    },\\n    setTwin: function setTwin(edge) {\\n      this.twin = edge;\\n      edge.twin = this;\\n      return this;\\n    }\\n  }); // A vertex as a double linked list node.\\n\\n  function VertexNode(point) {\\n    this.point = point;\\n    this.prev = null;\\n    this.next = null;\\n    this.face = null; // the face that is able to see this vertex\\n  } // A double linked list that contains vertex nodes.\\n\\n\\n  function VertexList() {\\n    this.head = null;\\n    this.tail = null;\\n  }\\n\\n  Object.assign(VertexList.prototype, {\\n    first: function first() {\\n      return this.head;\\n    },\\n    last: function last() {\\n      return this.tail;\\n    },\\n    clear: function clear() {\\n      this.head = this.tail = null;\\n      return this;\\n    },\\n    // Inserts a vertex before the target vertex\\n    insertBefore: function insertBefore(target, vertex) {\\n      vertex.prev = target.prev;\\n      vertex.next = target;\\n\\n      if (vertex.prev === null) {\\n        this.head = vertex;\\n      } else {\\n        vertex.prev.next = vertex;\\n      }\\n\\n      target.prev = vertex;\\n      return this;\\n    },\\n    // Inserts a vertex after the target vertex\\n    insertAfter: function insertAfter(target, vertex) {\\n      vertex.prev = target;\\n      vertex.next = target.next;\\n\\n      if (vertex.next === null) {\\n        this.tail = vertex;\\n      } else {\\n        vertex.next.prev = vertex;\\n      }\\n\\n      target.next = vertex;\\n      return this;\\n    },\\n    // Appends a vertex to the end of the linked list\\n    append: function append(vertex) {\\n      if (this.head === null) {\\n        this.head = vertex;\\n      } else {\\n        this.tail.next = vertex;\\n      }\\n\\n      vertex.prev = this.tail;\\n      vertex.next = null; // the tail has no subsequent vertex\\n\\n      this.tail = vertex;\\n      return this;\\n    },\\n    // Appends a chain of vertices where 'vertex' is the head.\\n    appendChain: function appendChain(vertex) {\\n      if (this.head === null) {\\n        this.head = vertex;\\n      } else {\\n        this.tail.next = vertex;\\n      }\\n\\n      vertex.prev = this.tail; // ensure that the 'tail' reference points to the last vertex of the chain\\n\\n      while (vertex.next !== null) {\\n        vertex = vertex.next;\\n      }\\n\\n      this.tail = vertex;\\n      return this;\\n    },\\n    // Removes a vertex from the linked list\\n    remove: function remove(vertex) {\\n      if (vertex.prev === null) {\\n        this.head = vertex.next;\\n      } else {\\n        vertex.prev.next = vertex.next;\\n      }\\n\\n      if (vertex.next === null) {\\n        this.tail = vertex.prev;\\n      } else {\\n        vertex.next.prev = vertex.prev;\\n      }\\n\\n      return this;\\n    },\\n    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\\n    removeSubList: function removeSubList(a, b) {\\n      if (a.prev === null) {\\n        this.head = b.next;\\n      } else {\\n        a.prev.next = b.next;\\n      }\\n\\n      if (b.next === null) {\\n        this.tail = a.prev;\\n      } else {\\n        b.next.prev = a.prev;\\n      }\\n\\n      return this;\\n    },\\n    isEmpty: function isEmpty() {\\n      return this.head === null;\\n    }\\n  });\\n  return ConvexHull;\\n}();\\n\\nexports.ConvexHull = ConvexHull;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"ConvexHull\",\"_three\",\"tolerance\",\"faces\",\"newFaces\",\"assigned\",\"VertexList\",\"unassigned\",\"vertices\",\"Face\",\"normal\",\"Vector3\",\"midpoint\",\"constant\",\"area\",\"outside\",\"mark\",\"Visible\",\"edge\",\"HalfEdge\",\"vertex\",\"face\",\"twin\",\"next\",\"prev\",\"VertexNode\",\"point\",\"tail\",\"head\",\"v1\",\"assign\",\"prototype\",\"setFromPoints\",\"points\",\"Array\",\"isArray\",\"console\",\"error\",\"length\",\"makeEmpty\",\"i\",\"l\",\"push\",\"compute\",\"setFromObject\",\"object\",\"updateMatrixWorld\",\"traverse\",\"node\",\"geometry\",\"undefined\",\"isGeometry\",\"isBufferGeometry\",\"attribute\",\"attributes\",\"position\",\"count\",\"fromBufferAttribute\",\"applyMatrix4\",\"matrixWorld\",\"containsPoint\",\"distanceToPoint\",\"intersectRay\",\"ray\",\"target\",\"tNear\",\"Infinity\",\"tFar\",\"vN\",\"origin\",\"vD\",\"dot\",\"direction\",\"t\",\"Math\",\"min\",\"max\",\"at\",\"intersectsRay\",\"addVertexToFace\",\"append\",\"insertBefore\",\"removeVertexFromFace\",\"remove\",\"removeAllVerticesFromFace\",\"start\",\"end\",\"removeSubList\",\"deleteFaceVertices\",\"absorbingFace\",\"faceVertices\",\"appendChain\",\"nextVertex\",\"distance\",\"resolveUnassignedPoints\",\"isEmpty\",\"first\",\"maxDistance\",\"maxFace\",\"computeExtremes\",\"minVertices\",\"maxVertices\",\"j\",\"copy\",\"getComponent\",\"setComponent\",\"Number\",\"EPSILON\",\"abs\",\"x\",\"y\",\"z\",\"computeInitialHull\",\"line3\",\"plane\",\"closestPoint\",\"Line3\",\"Plane\",\"extremes\",\"index\",\"v0\",\"set\",\"closestPointToPoint\",\"distanceToSquared\",\"v2\",\"setFromCoplanarPoints\",\"v3\",\"create\",\"getEdge\",\"setTwin\",\"reindexFaces\",\"activeFaces\",\"nextVertexToAdd\",\"eyeFace\",\"eyeVertex\",\"computeHorizon\",\"eyePoint\",\"crossEdge\",\"horizon\",\"Deleted\",\"twinEdge\",\"oppositeFace\",\"addAdjoiningFace\",\"horizonEdge\",\"addNewFaces\",\"firstSideEdge\",\"previousSideEdge\",\"sideEdge\",\"addVertexToHull\",\"clear\",\"cleanup\",\"a\",\"b\",\"c\",\"e0\",\"e1\",\"e2\",\"triangle\",\"Triangle\",\"getNormal\",\"getMidpoint\",\"getArea\",\"distanceTo\",\"lengthSquared\",\"last\",\"insertAfter\"]\n}\n"]