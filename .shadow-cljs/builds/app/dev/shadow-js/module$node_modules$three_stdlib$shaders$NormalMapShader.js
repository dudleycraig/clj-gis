["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/NormalMapShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$NormalMapShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.NormalMapShader=void 0;global=require(\"module$node_modules$three$build$three_module\");global={uniforms:{heightMap:{value:null},resolution:{value:new global.Vector2(512,512)},scale:{value:new global.Vector2(1,1)},height:{value:.05}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",\nfragmentShader:\"uniform float height;\\nuniform vec2 resolution;\\nuniform sampler2D heightMap;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tfloat val \\x3d texture2D( heightMap, vUv ).x;\\n\\tfloat valU \\x3d texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\\n\\tfloat valV \\x3d texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\\n\\tgl_FragColor \\x3d vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\\n}\"};exports.NormalMapShader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$NormalMapShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NormalMapShader = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Normal map shader\n * - compute normals from heightmap\n */\nvar NormalMapShader = {\n  uniforms: {\n    heightMap: {\n      value: null\n    },\n    resolution: {\n      value: new _three.Vector2(512, 512)\n    },\n    scale: {\n      value: new _three.Vector2(1, 1)\n    },\n    height: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float height;', 'uniform vec2 resolution;', 'uniform sampler2D heightMap;', 'varying vec2 vUv;', 'void main() {', '\tfloat val = texture2D( heightMap, vUv ).x;', '\tfloat valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;', '\tfloat valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;', '\tgl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );', '}'].join('\\n')\n};\nexports.NormalMapShader = NormalMapShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","NormalMapShader","heightMap","height","scale","__esModule","vertexShader","value","uniforms","resolution"]],"~:compiled-at",1630917515587,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$NormalMapShader.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,wDAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGrHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,eAAR,CAA0B,IAAK,EAE3BC,OAAAA,CAASP,OAAA,CAAQ,8CAAR,CAMTM,OAAAA,CAAkB,CACpBE,SAAU,CACRC,UAAW,CACTJ,MAAO,IADE,CADH,CAIRK,WAAY,CACVL,MAAO,IAAIE,MAAOI,CAAAA,OAAX,CAAmB,GAAnB,CAAwB,GAAxB,CADG,CAJJ,CAORC,MAAO,CACLP,MAAO,IAAIE,MAAOI,CAAAA,OAAX,CAAmB,CAAnB,CAAsB,CAAtB,CADF,CAPC,CAURE,OAAQ,CACNR,MAAO,GADD,CAVA,CADU,CAepBS,aAAiJ,qIAf7H;AAgBpBC,eAAqc,qbAhBjb,CAkBtBb,QAAQI,CAAAA,eAAR,CAA0BA,MAhC2F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/NormalMapShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$NormalMapShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.NormalMapShader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Normal map shader\\n * - compute normals from heightmap\\n */\\nvar NormalMapShader = {\\n  uniforms: {\\n    heightMap: {\\n      value: null\\n    },\\n    resolution: {\\n      value: new _three.Vector2(512, 512)\\n    },\\n    scale: {\\n      value: new _three.Vector2(1, 1)\\n    },\\n    height: {\\n      value: 0.05\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform float height;', 'uniform vec2 resolution;', 'uniform sampler2D heightMap;', 'varying vec2 vUv;', 'void main() {', '\\tfloat val = texture2D( heightMap, vUv ).x;', '\\tfloat valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;', '\\tfloat valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;', '\\tgl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );', '}'].join('\\\\n')\\n};\\nexports.NormalMapShader = NormalMapShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"NormalMapShader\",\"_three\",\"uniforms\",\"heightMap\",\"resolution\",\"Vector2\",\"scale\",\"height\",\"vertexShader\",\"fragmentShader\"]\n}\n"]