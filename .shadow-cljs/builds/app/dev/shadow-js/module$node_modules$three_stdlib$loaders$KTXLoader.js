["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/KTXLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$KTXLoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");\n}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=\nObject.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,\np$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.KTXLoader=void 0;global=function(_CompressedTextureLoa){function KTXLoader(manager){_classCallCheck(this,KTXLoader);manager=_getPrototypeOf(KTXLoader).call(this,manager);if(!manager||\"object\"!==_typeof(manager)&&\"function\"!==typeof manager){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\nmanager=this}return manager}_inherits(KTXLoader,_CompressedTextureLoa);_createClass(KTXLoader,[{key:\"parse\",value:function(buffer,loadMipmaps){buffer=new KhronosTextureContainer(buffer,1);return{mipmaps:buffer.mipmaps(loadMipmaps),width:buffer.pixelWidth,height:buffer.pixelHeight,format:buffer.glInternalFormat,isCubemap:6===buffer.numberOfFaces,mipmapCount:buffer.numberOfMipmapLevels}}}]);return KTXLoader}(require(\"module$node_modules$three$build$three_module\").CompressedTextureLoader);exports.KTXLoader=\nglobal;var KhronosTextureContainer=function(){function KhronosTextureContainer(arrayBuffer,facesExpected){_classCallCheck(this,KhronosTextureContainer);this.arrayBuffer=arrayBuffer;arrayBuffer=new Uint8Array(this.arrayBuffer,0,12);if(171!==arrayBuffer[0]||75!==arrayBuffer[1]||84!==arrayBuffer[2]||88!==arrayBuffer[3]||32!==arrayBuffer[4]||49!==arrayBuffer[5]||49!==arrayBuffer[6]||187!==arrayBuffer[7]||13!==arrayBuffer[8]||10!==arrayBuffer[9]||26!==arrayBuffer[10]||10!==arrayBuffer[11])console.error(\"texture missing KTX identifier\");\nelse{arrayBuffer=Uint32Array.BYTES_PER_ELEMENT;var headerDataView=new DataView(this.arrayBuffer,12,13*arrayBuffer),littleEndian=67305985===headerDataView.getUint32(0,!0);this.glType=headerDataView.getUint32(1*arrayBuffer,littleEndian);this.glTypeSize=headerDataView.getUint32(2*arrayBuffer,littleEndian);this.glFormat=headerDataView.getUint32(3*arrayBuffer,littleEndian);this.glInternalFormat=headerDataView.getUint32(4*arrayBuffer,littleEndian);this.glBaseInternalFormat=headerDataView.getUint32(5*arrayBuffer,\nlittleEndian);this.pixelWidth=headerDataView.getUint32(6*arrayBuffer,littleEndian);this.pixelHeight=headerDataView.getUint32(7*arrayBuffer,littleEndian);this.pixelDepth=headerDataView.getUint32(8*arrayBuffer,littleEndian);this.numberOfArrayElements=headerDataView.getUint32(9*arrayBuffer,littleEndian);this.numberOfFaces=headerDataView.getUint32(10*arrayBuffer,littleEndian);this.numberOfMipmapLevels=headerDataView.getUint32(11*arrayBuffer,littleEndian);this.bytesOfKeyValueData=headerDataView.getUint32(12*\narrayBuffer,littleEndian);0!==this.glType?console.warn(\"only compressed formats currently supported\"):(this.numberOfMipmapLevels=Math.max(1,this.numberOfMipmapLevels),0===this.pixelHeight||0!==this.pixelDepth?console.warn(\"only 2D textures currently supported\"):0!==this.numberOfArrayElements?console.warn(\"texture arrays not currently supported\"):this.numberOfFaces!==facesExpected?console.warn(\"number of faces expected\"+facesExpected+\", but found \"+this.numberOfFaces):this.loadType=0)}}_createClass(KhronosTextureContainer,\n[{key:\"mipmaps\",value:function(loadMipmaps){var mipmaps=[],dataOffset=64+this.bytesOfKeyValueData,width=this.pixelWidth,height=this.pixelHeight;loadMipmaps=loadMipmaps?this.numberOfMipmapLevels:1;for(var level=0;level<loadMipmaps;level++){var imageSize=(new Int32Array(this.arrayBuffer,dataOffset,1))[0];dataOffset+=4;for(var face=0;face<this.numberOfFaces;face++){var byteArray=new Uint8Array(this.arrayBuffer,dataOffset,imageSize);mipmaps.push({data:byteArray,width,height});dataOffset+=imageSize;dataOffset+=\n3-(imageSize+3)%4}width=Math.max(1,.5*width);height=Math.max(1,.5*height)}return mipmaps}}]);return KhronosTextureContainer}()}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$KTXLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KTXLoader = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n *\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n */\nvar KTXLoader =\n/*#__PURE__*/\nfunction (_CompressedTextureLoa) {\n  _inherits(KTXLoader, _CompressedTextureLoa);\n\n  function KTXLoader(manager) {\n    _classCallCheck(this, KTXLoader);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(KTXLoader).call(this, manager));\n  }\n\n  _createClass(KTXLoader, [{\n    key: \"parse\",\n    value: function parse(buffer, loadMipmaps) {\n      var ktx = new KhronosTextureContainer(buffer, 1);\n      return {\n        mipmaps: ktx.mipmaps(loadMipmaps),\n        width: ktx.pixelWidth,\n        height: ktx.pixelHeight,\n        format: ktx.glInternalFormat,\n        isCubemap: ktx.numberOfFaces === 6,\n        mipmapCount: ktx.numberOfMipmapLevels\n      };\n    }\n  }]);\n\n  return KTXLoader;\n}(_three.CompressedTextureLoader);\n\nexports.KTXLoader = KTXLoader;\nvar HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\n// load types\n\nvar COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\n//const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\n//const TEX_2D = 2; // uses a gl.texImage2D()\n//const TEX_3D = 3; // uses a gl.texImage3D()\n\nvar KhronosTextureContainer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\n   * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\n   * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\n   * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\n   */\n  function KhronosTextureContainer(arrayBuffer, facesExpected\n  /*, threeDExpected, textureArrayExpected */\n  ) {\n    _classCallCheck(this, KhronosTextureContainer);\n\n    this.arrayBuffer = arrayBuffer; // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\n    // '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n    // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n\n    var identifier = new Uint8Array(this.arrayBuffer, 0, 12);\n\n    if (identifier[0] !== 0xab || identifier[1] !== 0x4b || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 || identifier[6] !== 0x31 || identifier[7] !== 0xbb || identifier[8] !== 0x0d || identifier[9] !== 0x0a || identifier[10] !== 0x1a || identifier[11] !== 0x0a) {\n      console.error('texture missing KTX identifier');\n      return;\n    } // load the reset of the header in native 32 bit uint\n\n\n    var dataSize = Uint32Array.BYTES_PER_ELEMENT;\n    var headerDataView = new DataView(this.arrayBuffer, 12, 13 * dataSize);\n    var endianness = headerDataView.getUint32(0, true);\n    var littleEndian = endianness === 0x04030201;\n    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures\n\n    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures\n\n    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures\n\n    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n\n    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n\n    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n\n    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n\n    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n\n    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays\n\n    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6\n\n    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures\n\n    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data\n    // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n\n    if (this.glType !== 0) {\n      console.warn('only compressed formats currently supported');\n      return;\n    } else {\n      // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\n    }\n\n    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\n      console.warn('only 2D textures currently supported');\n      return;\n    }\n\n    if (this.numberOfArrayElements !== 0) {\n      console.warn('texture arrays not currently supported');\n      return;\n    }\n\n    if (this.numberOfFaces !== facesExpected) {\n      console.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces);\n      return;\n    } // we now have a completely validated file, so could use existence of loadType as success\n    // would need to make this more elaborate & adjust checks above to support more than one load type\n\n\n    this.loadType = COMPRESSED_2D;\n  }\n\n  _createClass(KhronosTextureContainer, [{\n    key: \"mipmaps\",\n    value: function mipmaps(loadMipmaps) {\n      var mipmaps = []; // initialize width & height for level 1\n\n      var dataOffset = HEADER_LEN + this.bytesOfKeyValueData;\n      var width = this.pixelWidth;\n      var height = this.pixelHeight;\n      var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\n\n      for (var level = 0; level < mipmapCount; level++) {\n        var imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\n\n        dataOffset += 4; // size of the image + 4 for the imageSize field\n\n        for (var face = 0; face < this.numberOfFaces; face++) {\n          var byteArray = new Uint8Array(this.arrayBuffer, dataOffset, imageSize);\n          mipmaps.push({\n            data: byteArray,\n            width: width,\n            height: height\n          });\n          dataOffset += imageSize;\n          dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image\n        }\n\n        width = Math.max(1.0, width * 0.5);\n        height = Math.max(1.0, height * 0.5);\n      }\n\n      return mipmaps;\n    }\n  }]);\n\n  return KhronosTextureContainer;\n}();\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["mipmaps","KTXLoader","bytesOfKeyValueData","glFormat","width","glTypeSize","glInternalFormat","prototype","height","pixelHeight","numberOfMipmapLevels","glType","key","__esModule","mipmapCount","arrayBuffer","loadType","numberOfArrayElements","configurable","value","enumerable","isCubemap","writable","__proto__","pixelDepth","numberOfFaces","pixelWidth","data","glBaseInternalFormat","format","constructor"]],"~:compiled-at",1630917515928,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$KTXLoader.js\",\n\"lineCount\":11,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/KTXLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$KTXLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.KTXLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\\n *\\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\\n */\\nvar KTXLoader =\\n/*#__PURE__*/\\nfunction (_CompressedTextureLoa) {\\n  _inherits(KTXLoader, _CompressedTextureLoa);\\n\\n  function KTXLoader(manager) {\\n    _classCallCheck(this, KTXLoader);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(KTXLoader).call(this, manager));\\n  }\\n\\n  _createClass(KTXLoader, [{\\n    key: \\\"parse\\\",\\n    value: function parse(buffer, loadMipmaps) {\\n      var ktx = new KhronosTextureContainer(buffer, 1);\\n      return {\\n        mipmaps: ktx.mipmaps(loadMipmaps),\\n        width: ktx.pixelWidth,\\n        height: ktx.pixelHeight,\\n        format: ktx.glInternalFormat,\\n        isCubemap: ktx.numberOfFaces === 6,\\n        mipmapCount: ktx.numberOfMipmapLevels\\n      };\\n    }\\n  }]);\\n\\n  return KTXLoader;\\n}(_three.CompressedTextureLoader);\\n\\nexports.KTXLoader = KTXLoader;\\nvar HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\\n// load types\\n\\nvar COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\\n//const COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\\n//const TEX_2D = 2; // uses a gl.texImage2D()\\n//const TEX_3D = 3; // uses a gl.texImage3D()\\n\\nvar KhronosTextureContainer =\\n/*#__PURE__*/\\nfunction () {\\n  /**\\n   * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\\n   * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\\n   * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\\n   * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\\n   */\\n  function KhronosTextureContainer(arrayBuffer, facesExpected\\n  /*, threeDExpected, textureArrayExpected */\\n  ) {\\n    _classCallCheck(this, KhronosTextureContainer);\\n\\n    this.arrayBuffer = arrayBuffer; // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\\n    // '\\u00b4', 'K', 'T', 'X', ' ', '1', '1', '\\u00aa', '\\\\r', '\\\\n', '\\\\x1A', '\\\\n'\\n    // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\\n\\n    var identifier = new Uint8Array(this.arrayBuffer, 0, 12);\\n\\n    if (identifier[0] !== 0xab || identifier[1] !== 0x4b || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 || identifier[6] !== 0x31 || identifier[7] !== 0xbb || identifier[8] !== 0x0d || identifier[9] !== 0x0a || identifier[10] !== 0x1a || identifier[11] !== 0x0a) {\\n      console.error('texture missing KTX identifier');\\n      return;\\n    } // load the reset of the header in native 32 bit uint\\n\\n\\n    var dataSize = Uint32Array.BYTES_PER_ELEMENT;\\n    var headerDataView = new DataView(this.arrayBuffer, 12, 13 * dataSize);\\n    var endianness = headerDataView.getUint32(0, true);\\n    var littleEndian = endianness === 0x04030201;\\n    this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures\\n\\n    this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures\\n\\n    this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures\\n\\n    this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\\n\\n    this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\\n\\n    this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\\n\\n    this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\\n\\n    this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\\n\\n    this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays\\n\\n    this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6\\n\\n    this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures\\n\\n    this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data\\n    // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\\n\\n    if (this.glType !== 0) {\\n      console.warn('only compressed formats currently supported');\\n      return;\\n    } else {\\n      // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\\n      this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\\n    }\\n\\n    if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\\n      console.warn('only 2D textures currently supported');\\n      return;\\n    }\\n\\n    if (this.numberOfArrayElements !== 0) {\\n      console.warn('texture arrays not currently supported');\\n      return;\\n    }\\n\\n    if (this.numberOfFaces !== facesExpected) {\\n      console.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces);\\n      return;\\n    } // we now have a completely validated file, so could use existence of loadType as success\\n    // would need to make this more elaborate & adjust checks above to support more than one load type\\n\\n\\n    this.loadType = COMPRESSED_2D;\\n  }\\n\\n  _createClass(KhronosTextureContainer, [{\\n    key: \\\"mipmaps\\\",\\n    value: function mipmaps(loadMipmaps) {\\n      var mipmaps = []; // initialize width & height for level 1\\n\\n      var dataOffset = HEADER_LEN + this.bytesOfKeyValueData;\\n      var width = this.pixelWidth;\\n      var height = this.pixelHeight;\\n      var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\\n\\n      for (var level = 0; level < mipmapCount; level++) {\\n        var imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\\n\\n        dataOffset += 4; // size of the image + 4 for the imageSize field\\n\\n        for (var face = 0; face < this.numberOfFaces; face++) {\\n          var byteArray = new Uint8Array(this.arrayBuffer, dataOffset, imageSize);\\n          mipmaps.push({\\n            data: byteArray,\\n            width: width,\\n            height: height\\n          });\\n          dataOffset += imageSize;\\n          dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image\\n        }\\n\\n        width = Math.max(1.0, width * 0.5);\\n        height = Math.max(1.0, height * 0.5);\\n      }\\n\\n      return mipmaps;\\n    }\\n  }]);\\n\\n  return KhronosTextureContainer;\\n}();\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_classCallCheck\",\"instance\",\"Constructor\",\"TypeError\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"KTXLoader\",\"_CompressedTextureLoa\",\"manager\",\"call\",\"self\",\"ReferenceError\",\"parse\",\"buffer\",\"loadMipmaps\",\"ktx\",\"KhronosTextureContainer\",\"mipmaps\",\"width\",\"pixelWidth\",\"height\",\"pixelHeight\",\"format\",\"glInternalFormat\",\"isCubemap\",\"numberOfFaces\",\"mipmapCount\",\"numberOfMipmapLevels\",\"_three\",\"CompressedTextureLoader\",\"arrayBuffer\",\"facesExpected\",\"identifier\",\"Uint8Array\",\"console\",\"error\",\"dataSize\",\"Uint32Array\",\"BYTES_PER_ELEMENT\",\"headerDataView\",\"DataView\",\"littleEndian\",\"getUint32\",\"endianness\",\"glType\",\"glTypeSize\",\"glFormat\",\"glBaseInternalFormat\",\"pixelDepth\",\"numberOfArrayElements\",\"bytesOfKeyValueData\",\"warn\",\"Math\",\"max\",\"loadType\",\"COMPRESSED_2D\",\"dataOffset\",\"HEADER_LEN\",\"level\",\"imageSize\",\"Int32Array\",\"face\",\"byteArray\",\"push\",\"data\"]\n}\n"]