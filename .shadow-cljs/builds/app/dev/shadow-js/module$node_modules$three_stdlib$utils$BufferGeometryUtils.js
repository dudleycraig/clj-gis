["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/utils/BufferGeometryUtils.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$utils$BufferGeometryUtils=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.computeMorphedAttributes=function(object$jscomp$0){function _calculateMorphedAttributeData(object,material,attribute,morphAttribute,morphTargetsRelative,a,b,c,modifiedAttributeArray){_vA.fromBufferAttribute(attribute,a);_vB.fromBufferAttribute(attribute,b);_vC.fromBufferAttribute(attribute,c);attribute=object.morphTargetInfluences;\nif(material.morphTargets&&morphAttribute&&attribute){_morphA.set(0,0,0);_morphB.set(0,0,0);_morphC.set(0,0,0);material=0;for(var _il=morphAttribute.length;material<_il;material++){var influence=attribute[material],morph=morphAttribute[material];0!==influence&&(_tempA.fromBufferAttribute(morph,a),_tempB.fromBufferAttribute(morph,b),_tempC.fromBufferAttribute(morph,c),morphTargetsRelative?(_morphA.addScaledVector(_tempA,influence),_morphB.addScaledVector(_tempB,influence),_morphC.addScaledVector(_tempC,\ninfluence)):(_morphA.addScaledVector(_tempA.sub(_vA),influence),_morphB.addScaledVector(_tempB.sub(_vB),influence),_morphC.addScaledVector(_tempC.sub(_vC),influence)))}_vA.add(_morphA);_vB.add(_morphB);_vC.add(_morphC)}object.isSkinnedMesh&&(object.boneTransform(a,_vA),object.boneTransform(b,_vB),object.boneTransform(c,_vC));modifiedAttributeArray[3*a]=_vA.x;modifiedAttributeArray[3*a+1]=_vA.y;modifiedAttributeArray[3*a+2]=_vA.z;modifiedAttributeArray[3*b]=_vB.x;modifiedAttributeArray[3*b+1]=_vB.y;\nmodifiedAttributeArray[3*b+2]=_vB.z;modifiedAttributeArray[3*c]=_vC.x;modifiedAttributeArray[3*c+1]=_vC.y;modifiedAttributeArray[3*c+2]=_vC.z}if(!0!==object$jscomp$0.geometry.isBufferGeometry)return console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\"),null;var _vA=new _three.Vector3,_vB=new _three.Vector3,_vC=new _three.Vector3,_tempA=new _three.Vector3,_tempB=new _three.Vector3,_tempC=new _three.Vector3,_morphA=new _three.Vector3,_morphB=new _three.Vector3,_morphC=\nnew _three.Vector3,geometry=object$jscomp$0.geometry,material$jscomp$0=object$jscomp$0.material,index=geometry.index,positionAttribute=geometry.attributes.position,morphPosition=geometry.morphAttributes.position,morphTargetsRelative$jscomp$0=geometry.morphTargetsRelative,normalAttribute=geometry.attributes.normal,morphNormal=geometry.morphAttributes.position,groups=geometry.groups,drawRange=geometry.drawRange,il,jl,modifiedPosition=new Float32Array(positionAttribute.count*positionAttribute.itemSize);\ngeometry=new Float32Array(normalAttribute.count*normalAttribute.itemSize);if(null!==index)if(Array.isArray(material$jscomp$0)){var i=0;for(il=groups.length;i<il;i++){var a$jscomp$0=groups[i];var groupMaterial=material$jscomp$0[a$jscomp$0.materialIndex];var j=Math.max(a$jscomp$0.start,drawRange.start);for(jl=a$jscomp$0=Math.min(a$jscomp$0.start+a$jscomp$0.count,drawRange.start+drawRange.count);j<jl;j+=3){a$jscomp$0=index.getX(j);var b$jscomp$0=index.getX(j+1);var c$jscomp$0=index.getX(j+2);_calculateMorphedAttributeData(object$jscomp$0,\ngroupMaterial,positionAttribute,morphPosition,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,modifiedPosition);_calculateMorphedAttributeData(object$jscomp$0,groupMaterial,normalAttribute,morphNormal,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,geometry)}}}else for(j=Math.max(0,drawRange.start),a$jscomp$0=Math.min(index.count,drawRange.start+drawRange.count),i=j,il=a$jscomp$0;i<il;i+=3)a$jscomp$0=index.getX(i),b$jscomp$0=index.getX(i+1),c$jscomp$0=index.getX(i+2),\n_calculateMorphedAttributeData(object$jscomp$0,material$jscomp$0,positionAttribute,morphPosition,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,modifiedPosition),_calculateMorphedAttributeData(object$jscomp$0,material$jscomp$0,normalAttribute,morphNormal,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,geometry);else if(void 0!==positionAttribute)if(Array.isArray(material$jscomp$0))for(i=0,il=groups.length;i<il;i++)for(a$jscomp$0=groups[i],groupMaterial=material$jscomp$0[a$jscomp$0.materialIndex],\nj=Math.max(a$jscomp$0.start,drawRange.start),jl=a$jscomp$0=Math.min(a$jscomp$0.start+a$jscomp$0.count,drawRange.start+drawRange.count);j<jl;j+=3)a$jscomp$0=j,b$jscomp$0=j+1,c$jscomp$0=j+2,_calculateMorphedAttributeData(object$jscomp$0,groupMaterial,positionAttribute,morphPosition,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,modifiedPosition),_calculateMorphedAttributeData(object$jscomp$0,groupMaterial,normalAttribute,morphNormal,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,\nc$jscomp$0,geometry);else for(j=Math.max(0,drawRange.start),a$jscomp$0=Math.min(positionAttribute.count,drawRange.start+drawRange.count),i=j,il=a$jscomp$0;i<il;i+=3)a$jscomp$0=i,b$jscomp$0=i+1,c$jscomp$0=i+2,_calculateMorphedAttributeData(object$jscomp$0,material$jscomp$0,positionAttribute,morphPosition,morphTargetsRelative$jscomp$0,a$jscomp$0,b$jscomp$0,c$jscomp$0,modifiedPosition),_calculateMorphedAttributeData(object$jscomp$0,material$jscomp$0,normalAttribute,morphNormal,morphTargetsRelative$jscomp$0,\na$jscomp$0,b$jscomp$0,c$jscomp$0,geometry);object$jscomp$0=new _three.Float32BufferAttribute(modifiedPosition,3);material$jscomp$0=new _three.Float32BufferAttribute(geometry,3);return{positionAttribute,normalAttribute,morphedPositionAttribute:object$jscomp$0,morphedNormalAttribute:material$jscomp$0}};exports.estimateBytesUsed=function(geometry){var mem=0,name;for(name in geometry.attributes){var attr=geometry.getAttribute(name);mem+=attr.count*attr.itemSize*attr.array.BYTES_PER_ELEMENT}geometry=geometry.getIndex();\nreturn mem+=geometry?geometry.count*geometry.itemSize*geometry.array.BYTES_PER_ELEMENT:0};exports.mergeVertices=function(geometry){var tolerance=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1E-4;tolerance=Math.max(tolerance,Number.EPSILON);var hashToIndex={},indices=geometry.getIndex(),positions=geometry.getAttribute(\"position\"),vertexCount=indices?indices.count:positions.count,nextIndex=0;positions=Object.keys(geometry.attributes);for(var attrArrays={},morphAttrsArrays={},newIndices=[],\ngetters=[\"getX\",\"getY\",\"getZ\",\"getW\"],i=0,l=positions.length;i<l;i++){var name=positions[i];attrArrays[name]=[];var morphAttr=geometry.morphAttributes[name];morphAttr&&(morphAttrsArrays[name]=Array(morphAttr.length).fill(0).map(function(){return[]}))}tolerance=Math.pow(10,Math.log10(1/tolerance));for(i=0;i<vertexCount;i++){l=indices?indices.getX(i):i;name=\"\";morphAttr=0;for(var _l2=positions.length;morphAttr<_l2;morphAttr++)for(var attribute=geometry.getAttribute(positions[morphAttr]),itemSize=attribute.itemSize,\nk=0;k<itemSize;k++)name+=\"\".concat(~~(attribute[getters[k]](l)*tolerance),\",\");if(name in hashToIndex)newIndices.push(hashToIndex[name]);else{morphAttr=0;for(_l2=positions.length;morphAttr<_l2;morphAttr++){var _name4=positions[morphAttr];attribute=geometry.getAttribute(_name4);itemSize=geometry.morphAttributes[_name4];k=attribute.itemSize;var newarray=attrArrays[_name4];_name4=morphAttrsArrays[_name4];for(var _k=0;_k<k;_k++){var getterFunc=getters[_k];newarray.push(attribute[getterFunc](l));if(itemSize)for(var m=\n0,ml=itemSize.length;m<ml;m++)_name4[m].push(itemSize[m][getterFunc](l))}}hashToIndex[name]=nextIndex;newIndices.push(nextIndex);nextIndex++}}hashToIndex=geometry.clone();indices=0;for(vertexCount=positions.length;indices<vertexCount;indices++)if(nextIndex=positions[indices],getters=geometry.getAttribute(nextIndex),tolerance=new getters.array.constructor(attrArrays[nextIndex]),getters=new _three.BufferAttribute(tolerance,getters.itemSize,getters.normalized),hashToIndex.setAttribute(nextIndex,getters),\nnextIndex in morphAttrsArrays)for(getters=0;getters<morphAttrsArrays[nextIndex].length;getters++)tolerance=geometry.morphAttributes[nextIndex][getters],i=new tolerance.array.constructor(morphAttrsArrays[nextIndex][getters]),tolerance=new _three.BufferAttribute(i,tolerance.itemSize,tolerance.normalized),hashToIndex.morphAttributes[nextIndex][getters]=tolerance;hashToIndex.setIndex(newIndices);return hashToIndex};exports.toTrianglesDrawMode=function(geometry,drawMode){if(drawMode===_three.TrianglesDrawMode)return console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\"),\ngeometry;if(drawMode===_three.TriangleFanDrawMode||drawMode===_three.TriangleStripDrawMode){var index=geometry.getIndex();if(null===index){var indices=[];index=geometry.getAttribute(\"position\");if(void 0!==index){for(var i=0;i<index.count;i++)indices.push(i);geometry.setIndex(indices);index=geometry.getIndex()}else return console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"),geometry}i=index.count-2;indices=[];if(index)if(drawMode===\n_three.TriangleFanDrawMode)for(drawMode=1;drawMode<=i;drawMode++)indices.push(index.getX(0)),indices.push(index.getX(drawMode)),indices.push(index.getX(drawMode+1));else for(drawMode=0;drawMode<i;drawMode++)0===drawMode%2?(indices.push(index.getX(drawMode)),indices.push(index.getX(drawMode+1)),indices.push(index.getX(drawMode+2))):(indices.push(index.getX(drawMode+2)),indices.push(index.getX(drawMode+1)),indices.push(index.getX(drawMode)));indices.length/3!==i&&console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\ngeometry=geometry.clone();geometry.setIndex(indices);geometry.clearGroups();return geometry}console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\",drawMode);return geometry};exports.mergeBufferGeometries=exports.mergeBufferAttributes=exports.interleaveAttributes=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_helpers=require(\"module$node_modules$three_stdlib$types$helpers\");exports.mergeBufferGeometries=function(geometries,useGroups){var isIndexed=\nnull!==geometries[0].index,attributesUsed=new Set(Object.keys(geometries[0].attributes)),morphAttributesUsed=new Set(Object.keys(geometries[0].morphAttributes)),attributes={},morphAttributes={},morphTargetsRelative=geometries[0].morphTargetsRelative,mergedGeometry=new _three.BufferGeometry,offset=0;geometries.forEach(function(geom,i){var attributesCount=0;if(isIndexed!==(null!==geom.index))return console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \"+i+\n\". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"),null;for(var name in geom.attributes){if(!attributesUsed.has(name))return console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \"+i+'. All geometries must have compatible attributes; make sure \"'+name+'\" attribute exists among all geometries, or in none of them.'),null;void 0===attributes[name]&&(attributes[name]=[]);attributes[name].push(geom.attributes[name]);\nattributesCount++}if(attributesCount!==attributesUsed.size)return console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \"+i+\". Make sure all geometries have the same number of attributes.\"),null;if(morphTargetsRelative!==geom.morphTargetsRelative)return console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \"+i+\". .morphTargetsRelative must be consistent throughout all geometries.\"),null;for(var _name in geom.morphAttributes){if(!morphAttributesUsed.has(_name))return console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \"+\ni+\".  .morphAttributes must be consistent throughout all geometries.\"),null;void 0===morphAttributes[_name]&&(morphAttributes[_name]=[]);morphAttributes[_name].push(geom.morphAttributes[_name])}mergedGeometry.userData.mergedUserData=mergedGeometry.userData.mergedUserData||[];mergedGeometry.userData.mergedUserData.push(geom.userData);if(useGroups){if(geom.index)geom=geom.index.count;else if(void 0!==geom.attributes.position)geom=geom.attributes.position.count;else return console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \"+\ni+\". The geometry must have either an index or a position attribute\"),null;mergedGeometry.addGroup(offset,geom,i);offset+=geom}});if(isIndexed){var indexOffset=0,mergedIndex=[];geometries.forEach(function(geom){for(var index=geom.index,j=0;j<index.count;++j)mergedIndex.push(index.getX(j)+indexOffset);indexOffset+=geom.attributes.position.count});mergedGeometry.setIndex(mergedIndex)}for(var name$jscomp$0 in attributes){geometries=mergeBufferAttributes(attributes[name$jscomp$0]);if(!geometries)return console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \"+\nname$jscomp$0+\" attribute.\"),null;mergedGeometry.setAttribute(name$jscomp$0,geometries)}for(var _name2 in morphAttributes){name$jscomp$0=morphAttributes[_name2][0].length;if(0===name$jscomp$0)break;mergedGeometry.morphAttributes=mergedGeometry.morphAttributes||{};mergedGeometry.morphAttributes[_name2]=[];for(geometries=0;geometries<name$jscomp$0;++geometries){for(var morphAttributesToMerge=[],j$jscomp$0=0;j$jscomp$0<morphAttributes[_name2].length;++j$jscomp$0)morphAttributesToMerge.push(morphAttributes[_name2][j$jscomp$0][geometries]);\nmorphAttributesToMerge=mergeBufferAttributes(morphAttributesToMerge);if(!morphAttributesToMerge)return console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \"+_name2+\" morphAttribute.\"),null;mergedGeometry.morphAttributes[_name2].push(morphAttributesToMerge)}}return mergedGeometry};var mergeBufferAttributes=function(attributes){var TypedArray=void 0,itemSize=void 0,normalized=void 0,arrayLength=0;attributes.forEach(function(attr){void 0===TypedArray&&\n(TypedArray=attr.array.constructor);if(TypedArray!==attr.array.constructor)return console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"),null;void 0===itemSize&&(itemSize=attr.itemSize);if(itemSize!==attr.itemSize)return console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"),null;void 0===normalized&&\n(normalized=attr.normalized);if(normalized!==attr.normalized)return console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"),null;arrayLength+=attr.array.length});if(TypedArray&&itemSize){var array=new TypedArray(arrayLength),offset=0;attributes.forEach(function(attr){array.set(attr.array,offset);offset+=attr.array.length});return new _three.BufferAttribute(array,itemSize,normalized)}};exports.mergeBufferAttributes=\nmergeBufferAttributes;exports.interleaveAttributes=function(attributes){for(var TypedArray=void 0,arrayLength=0,stride=0,i=0,l=attributes.length;i<l;++i){var attribute=attributes[i];void 0===TypedArray&&(TypedArray=attribute.array.constructor);if(TypedArray!==attribute.array.constructor)return console.error(\"AttributeBuffers of different types cannot be interleaved\"),null;arrayLength+=attribute.array.length;stride+=attribute.itemSize}TypedArray=new _three.InterleavedBuffer(new TypedArray(arrayLength),\nstride);arrayLength=0;stride=[];i=[\"getX\",\"getY\",\"getZ\",\"getW\"];l=[\"setX\",\"setY\",\"setZ\",\"setW\"];attribute=0;for(var _l=attributes.length;attribute<_l;attribute++){var _attribute=attributes[attribute],itemSize=_attribute.itemSize,count=_attribute.count,iba=new _three.InterleavedBufferAttribute(TypedArray,itemSize,arrayLength,_attribute.normalized);stride.push(iba);arrayLength+=itemSize;for(var c=0;c<count;c++)for(var k=0;k<itemSize;k++){var set=(0,_helpers.getWithKey)(iba,l[k]),get=(0,_helpers.getWithKey)(_attribute,\ni[k]);set(c,get(c))}}return stride}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$utils$BufferGeometryUtils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeMorphedAttributes = computeMorphedAttributes;\nexports.estimateBytesUsed = estimateBytesUsed;\nexports.mergeVertices = mergeVertices;\nexports.toTrianglesDrawMode = toTrianglesDrawMode;\nexports.mergeBufferGeometries = exports.mergeBufferAttributes = exports.interleaveAttributes = void 0;\n\nvar _three = require(\"three\");\n\nvar _helpers = require(\"../types/helpers.js\");\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nvar mergeBufferGeometries = function mergeBufferGeometries(geometries, useGroups) {\n  var isIndexed = geometries[0].index !== null;\n  var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  var attributes = {};\n  var morphAttributes = {};\n  var morphTargetsRelative = geometries[0].morphTargetsRelative;\n  var mergedGeometry = new _three.BufferGeometry();\n  var offset = 0;\n  geometries.forEach(function (geom, i) {\n    var attributesCount = 0; // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    } // gather attributes, exit early if they're different\n\n\n    for (var name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    } // ensure geometries have the same number of attributes\n\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    } // gather morph attributes, exit early if they're different\n\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n\n    for (var _name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(_name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n\n      if (morphAttributes[_name] === undefined) morphAttributes[_name] = [];\n\n      morphAttributes[_name].push(geom.morphAttributes[_name]);\n    } // gather .userData\n\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n\n    if (useGroups) {\n      var count;\n\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }); // merge indices\n\n  if (isIndexed) {\n    var indexOffset = 0;\n    var mergedIndex = [];\n    geometries.forEach(function (geom) {\n      var index = geom.index;\n\n      for (var j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  } // merge attributes\n\n\n  for (var name in attributes) {\n    var mergedAttribute = mergeBufferAttributes(attributes[name]);\n\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n      return null;\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  } // merge morph attributes\n\n\n  for (var _name2 in morphAttributes) {\n    var numMorphTargets = morphAttributes[_name2][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[_name2] = [];\n\n    for (var i = 0; i < numMorphTargets; ++i) {\n      var morphAttributesToMerge = [];\n\n      for (var j = 0; j < morphAttributes[_name2].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[_name2][j][i]);\n      }\n\n      var mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + _name2 + ' morphAttribute.');\n        return null;\n      }\n\n      mergedGeometry.morphAttributes[_name2].push(mergedMorphAttribute);\n    }\n  }\n\n  return mergedGeometry;\n};\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\n\n\nexports.mergeBufferGeometries = mergeBufferGeometries;\n\nvar mergeBufferAttributes = function mergeBufferAttributes(attributes) {\n  var TypedArray = undefined;\n  var itemSize = undefined;\n  var normalized = undefined;\n  var arrayLength = 0;\n  attributes.forEach(function (attr) {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor;\n    }\n\n    if (TypedArray !== attr.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize;\n\n    if (itemSize !== attr.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n\n    if (normalized === undefined) normalized = attr.normalized;\n\n    if (normalized !== attr.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n\n    arrayLength += attr.array.length;\n  });\n\n  if (TypedArray && itemSize) {\n    // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    var array = new TypedArray(arrayLength);\n    var offset = 0;\n    attributes.forEach(function (attr) {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new _three.BufferAttribute(array, itemSize, normalized);\n  }\n};\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\n\n\nexports.mergeBufferAttributes = mergeBufferAttributes;\n\nvar interleaveAttributes = function interleaveAttributes(attributes) {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  var TypedArray = undefined;\n  var arrayLength = 0;\n  var stride = 0; // calculate the the length and type of the interleavedBuffer\n\n  for (var i = 0, l = attributes.length; i < l; ++i) {\n    var attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  } // Create the set of buffer attributes\n  // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n\n\n  var interleavedBuffer = new _three.InterleavedBuffer(new TypedArray(arrayLength), stride);\n  var offset = 0;\n  var res = [];\n  var getters = ['getX', 'getY', 'getZ', 'getW'];\n  var setters = ['setX', 'setY', 'setZ', 'setW'];\n\n  for (var j = 0, _l = attributes.length; j < _l; j++) {\n    var _attribute = attributes[j];\n    var itemSize = _attribute.itemSize;\n    var count = _attribute.count;\n    var iba = new _three.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, _attribute.normalized);\n    res.push(iba);\n    offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n\n    for (var c = 0; c < count; c++) {\n      for (var k = 0; k < itemSize; k++) {\n        var set = (0, _helpers.getWithKey)(iba, setters[k]);\n        var get = (0, _helpers.getWithKey)(_attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n\n  return res;\n};\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\n\n\nexports.interleaveAttributes = interleaveAttributes;\n\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  var mem = 0;\n\n  for (var name in geometry.attributes) {\n    var attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n\n  var indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\n\n\nfunction mergeVertices(geometry) {\n  var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n\n  var hashToIndex = {};\n  var indices = geometry.getIndex();\n  var positions = geometry.getAttribute('position');\n  var vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n  var nextIndex = 0; // attributes and new attribute arrays\n\n  var attributeNames = Object.keys(geometry.attributes);\n  var attrArrays = {};\n  var morphAttrsArrays = {};\n  var newIndices = [];\n  var getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n  for (var i = 0, l = attributeNames.length; i < l; i++) {\n    var name = attributeNames[i];\n    attrArrays[name] = [];\n    var morphAttr = geometry.morphAttributes[name];\n\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(function () {\n        return [];\n      });\n    }\n  } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n  var decimalShift = Math.log10(1 / tolerance);\n  var shiftMultiplier = Math.pow(10, decimalShift);\n\n  for (var _i = 0; _i < vertexCount; _i++) {\n    var index = indices ? indices.getX(_i) : _i; // Generate a hash for the vertex attributes at the current index 'i'\n\n    var hash = '';\n\n    for (var j = 0, _l2 = attributeNames.length; j < _l2; j++) {\n      var _name3 = attributeNames[j];\n      var attribute = geometry.getAttribute(_name3);\n      var itemSize = attribute.itemSize;\n\n      for (var k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n      }\n    } // Add another reference to the vertex if it's already\n    // used by another index\n\n\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (var _j = 0, _l3 = attributeNames.length; _j < _l3; _j++) {\n        var _name4 = attributeNames[_j];\n\n        var _attribute2 = geometry.getAttribute(_name4);\n\n        var _morphAttr = geometry.morphAttributes[_name4];\n        var _itemSize = _attribute2.itemSize;\n        var newarray = attrArrays[_name4];\n        var newMorphArrays = morphAttrsArrays[_name4];\n\n        for (var _k = 0; _k < _itemSize; _k++) {\n          var getterFunc = getters[_k]; // @ts-ignore\n\n          newarray.push(_attribute2[getterFunc](index));\n\n          if (_morphAttr) {\n            for (var m = 0, ml = _morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(_morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  } // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n\n\n  var result = geometry.clone();\n\n  for (var _i2 = 0, _l4 = attributeNames.length; _i2 < _l4; _i2++) {\n    var _name5 = attributeNames[_i2];\n    var oldAttribute = geometry.getAttribute(_name5); //@ts-expect-error  something to do with functions and constructors and new\n\n    var buffer = new oldAttribute.array.constructor(attrArrays[_name5]);\n\n    var _attribute3 = new _three.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n\n    result.setAttribute(_name5, _attribute3); // Update the attribute arrays\n\n    if (_name5 in morphAttrsArrays) {\n      for (var _j2 = 0; _j2 < morphAttrsArrays[_name5].length; _j2++) {\n        var oldMorphAttribute = geometry.morphAttributes[_name5][_j2]; //@ts-expect-error something to do with functions and constructors and new\n\n        var _buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[_name5][_j2]);\n\n        var morphAttribute = new _three.BufferAttribute(_buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[_name5][_j2] = morphAttribute;\n      }\n    }\n  } // indices\n\n\n  result.setIndex(newIndices);\n  return result;\n}\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\n\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === _three.TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n\n  if (drawMode === _three.TriangleFanDrawMode || drawMode === _three.TriangleStripDrawMode) {\n    var index = geometry.getIndex(); // generate index if not present\n\n    if (index === null) {\n      var indices = [];\n      var position = geometry.getAttribute('position');\n\n      if (position !== undefined) {\n        for (var i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    } //\n\n\n    var numberOfTriangles = index.count - 2;\n    var newIndices = [];\n\n    if (index) {\n      if (drawMode === _three.TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n        for (var _i3 = 1; _i3 <= numberOfTriangles; _i3++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(_i3));\n          newIndices.push(index.getX(_i3 + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n        for (var _i4 = 0; _i4 < numberOfTriangles; _i4++) {\n          if (_i4 % 2 === 0) {\n            newIndices.push(index.getX(_i4));\n            newIndices.push(index.getX(_i4 + 1));\n            newIndices.push(index.getX(_i4 + 2));\n          } else {\n            newIndices.push(index.getX(_i4 + 2));\n            newIndices.push(index.getX(_i4 + 1));\n            newIndices.push(index.getX(_i4));\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    } // build final geometry\n\n\n    var newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\n\n\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n    return null;\n  }\n\n  var _vA = new _three.Vector3();\n\n  var _vB = new _three.Vector3();\n\n  var _vC = new _three.Vector3();\n\n  var _tempA = new _three.Vector3();\n\n  var _tempB = new _three.Vector3();\n\n  var _tempC = new _three.Vector3();\n\n  var _morphA = new _three.Vector3();\n\n  var _morphB = new _three.Vector3();\n\n  var _morphC = new _three.Vector3();\n\n  function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n\n    _vB.fromBufferAttribute(attribute, b);\n\n    _vC.fromBufferAttribute(attribute, c);\n\n    var morphInfluences = object.morphTargetInfluences;\n\n    if (material.morphTargets && morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n\n      _morphB.set(0, 0, 0);\n\n      _morphC.set(0, 0, 0);\n\n      for (var _i5 = 0, _il = morphAttribute.length; _i5 < _il; _i5++) {\n        var influence = morphInfluences[_i5];\n        var morph = morphAttribute[_i5];\n        if (influence === 0) continue;\n\n        _tempA.fromBufferAttribute(morph, a);\n\n        _tempB.fromBufferAttribute(morph, b);\n\n        _tempC.fromBufferAttribute(morph, c);\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n\n          _morphB.addScaledVector(_tempB, influence);\n\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n\n      _vA.add(_morphA);\n\n      _vB.add(_morphB);\n\n      _vC.add(_morphC);\n    }\n\n    if (object.isSkinnedMesh) {\n      // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n\n      object.boneTransform(b, _vB); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n\n      object.boneTransform(c, _vC);\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n\n  var geometry = object.geometry;\n  var material = object.material;\n  var a, b, c;\n  var index = geometry.index;\n  var positionAttribute = geometry.attributes.position;\n  var morphPosition = geometry.morphAttributes.position;\n  var morphTargetsRelative = geometry.morphTargetsRelative;\n  var normalAttribute = geometry.attributes.normal;\n  var morphNormal = geometry.morphAttributes.position;\n  var groups = geometry.groups;\n  var drawRange = geometry.drawRange;\n  var i, j, il, jl;\n  var group, groupMaterial;\n  var start, end;\n  var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n\n  if (index !== null) {\n    // indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n\n  var morphedPositionAttribute = new _three.Float32BufferAttribute(modifiedPosition, 3);\n  var morphedNormalAttribute = new _three.Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$three_stdlib$types$helpers"]],"~:properties",["^5",["mergeVertices","estimateBytesUsed","morphAttributes","mergeBufferAttributes","morphedNormalAttribute","toTrianglesDrawMode","mergedUserData","__esModule","value","mergeBufferGeometries","normalAttribute","computeMorphedAttributes","positionAttribute","interleaveAttributes","morphedPositionAttribute"]],"~:compiled-at",1630917515172,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$utils$BufferGeometryUtils.js\",\n\"lineCount\":31,\n\"mappings\":\"AAAAA,cAAA,CAAA,0DAAA,CAA+E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGvHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,wBAAR,CAkeAA,QAAiC,CAACC,eAAD,CAAS,CAwBxCC,QAASA,+BAA8B,CAACD,MAAD,CAASE,QAAT,CAAmBC,SAAnB,CAA8BC,cAA9B,CAA8CC,oBAA9C,CAAoEC,CAApE,CAAuEC,CAAvE,CAA0EC,CAA1E,CAA6EC,sBAA7E,CAAqG,CAC1IC,GAAIC,CAAAA,mBAAJ,CAAwBR,SAAxB,CAAmCG,CAAnC,CAEAM,IAAID,CAAAA,mBAAJ,CAAwBR,SAAxB,CAAmCI,CAAnC,CAEAM,IAAIF,CAAAA,mBAAJ,CAAwBR,SAAxB,CAAmCK,CAAnC,CAEIM,UAAAA,CAAkBd,MAAOe,CAAAA,qBAE7B;GAAIb,QAASc,CAAAA,YAAb,EAA6BZ,cAA7B,EAA+CU,SAA/C,CAAgE,CAC9DG,OAAQC,CAAAA,GAAR,CAAY,CAAZ,CAAe,CAAf,CAAkB,CAAlB,CAEAC,QAAQD,CAAAA,GAAR,CAAY,CAAZ,CAAe,CAAf,CAAkB,CAAlB,CAEAE,QAAQF,CAAAA,GAAR,CAAY,CAAZ,CAAe,CAAf,CAAkB,CAAlB,CAESG,SAAAA,CAAM,CAAf,KAAK,IAAaC,IAAMlB,cAAemB,CAAAA,MAAvC,CAA+CF,QAA/C,CAAqDC,GAArD,CAA0DD,QAAA,EAA1D,CAAiE,CAC/D,IAAIG,UAAYV,SAAA,CAAgBO,QAAhB,CAAhB,CACII,MAAQrB,cAAA,CAAeiB,QAAf,CACM,EAAlB,GAAIG,SAAJ,GAEAE,MAAOf,CAAAA,mBAAP,CAA2Bc,KAA3B,CAAkCnB,CAAlC,CAMA,CAJAqB,MAAOhB,CAAAA,mBAAP,CAA2Bc,KAA3B,CAAkClB,CAAlC,CAIA,CAFAqB,MAAOjB,CAAAA,mBAAP,CAA2Bc,KAA3B,CAAkCjB,CAAlC,CAEA,CAAIH,oBAAJ,EACEY,OAAQY,CAAAA,eAAR,CAAwBH,MAAxB,CAAgCF,SAAhC,CAIA,CAFAL,OAAQU,CAAAA,eAAR,CAAwBF,MAAxB,CAAgCH,SAAhC,CAEA,CAAAJ,OAAQS,CAAAA,eAAR,CAAwBD,MAAxB;AAAgCJ,SAAhC,CALF,GAOEP,OAAQY,CAAAA,eAAR,CAAwBH,MAAOI,CAAAA,GAAP,CAAWpB,GAAX,CAAxB,CAAyCc,SAAzC,CAIA,CAFAL,OAAQU,CAAAA,eAAR,CAAwBF,MAAOG,CAAAA,GAAP,CAAWlB,GAAX,CAAxB,CAAyCY,SAAzC,CAEA,CAAAJ,OAAQS,CAAAA,eAAR,CAAwBD,MAAOE,CAAAA,GAAP,CAAWjB,GAAX,CAAxB,CAAyCW,SAAzC,CAXF,CARA,CAH+D,CA0BjEd,GAAIqB,CAAAA,GAAJ,CAAQd,OAAR,CAEAL,IAAImB,CAAAA,GAAJ,CAAQZ,OAAR,CAEAN,IAAIkB,CAAAA,GAAJ,CAAQX,OAAR,CArC8D,CAwC5DpB,MAAOgC,CAAAA,aAAX,GAEEhC,MAAOiC,CAAAA,aAAP,CAAqB3B,CAArB,CAAwBI,GAAxB,CAIA,CAFAV,MAAOiC,CAAAA,aAAP,CAAqB1B,CAArB,CAAwBK,GAAxB,CAEA,CAAAZ,MAAOiC,CAAAA,aAAP,CAAqBzB,CAArB,CAAwBK,GAAxB,CANF,CASAJ,uBAAA,CAA2B,CAA3B,CAAuBH,CAAvB,CAAA,CAAoCI,GAAIwB,CAAAA,CACxCzB,uBAAA,CAA2B,CAA3B,CAAuBH,CAAvB,CAA+B,CAA/B,CAAA,CAAoCI,GAAIyB,CAAAA,CACxC1B,uBAAA,CAA2B,CAA3B,CAAuBH,CAAvB,CAA+B,CAA/B,CAAA,CAAoCI,GAAI0B,CAAAA,CACxC3B,uBAAA,CAA2B,CAA3B,CAAuBF,CAAvB,CAAA,CAAoCK,GAAIsB,CAAAA,CACxCzB,uBAAA,CAA2B,CAA3B,CAAuBF,CAAvB,CAA+B,CAA/B,CAAA,CAAoCK,GAAIuB,CAAAA,CACxC1B;sBAAA,CAA2B,CAA3B,CAAuBF,CAAvB,CAA+B,CAA/B,CAAA,CAAoCK,GAAIwB,CAAAA,CACxC3B,uBAAA,CAA2B,CAA3B,CAAuBD,CAAvB,CAAA,CAAoCK,GAAIqB,CAAAA,CACxCzB,uBAAA,CAA2B,CAA3B,CAAuBD,CAAvB,CAA+B,CAA/B,CAAA,CAAoCK,GAAIsB,CAAAA,CACxC1B,uBAAA,CAA2B,CAA3B,CAAuBD,CAAvB,CAA+B,CAA/B,CAAA,CAAoCK,GAAIuB,CAAAA,CAlEkG,CAvB5I,GAAyC,CAAA,CAAzC,GAAIpC,eAAOqC,CAAAA,QAASC,CAAAA,gBAApB,CAEE,MADAC,QAAQC,CAAAA,KAAR,CAAc,oEAAd,CACO,CAAA,IAGT,KAAI9B,IAAM,IAAI+B,MAAOC,CAAAA,OAArB,CAEI9B,IAAM,IAAI6B,MAAOC,CAAAA,OAFrB,CAII7B,IAAM,IAAI4B,MAAOC,CAAAA,OAJrB,CAMIhB,OAAS,IAAIe,MAAOC,CAAAA,OANxB,CAQIf,OAAS,IAAIc,MAAOC,CAAAA,OARxB,CAUId,OAAS,IAAIa,MAAOC,CAAAA,OAVxB,CAYIzB,QAAU,IAAIwB,MAAOC,CAAAA,OAZzB,CAcIvB,QAAU,IAAIsB,MAAOC,CAAAA,OAdzB,CAgBItB;AAAU,IAAIqB,MAAOC,CAAAA,OAhBzB,CAuFIL,SAAWrC,eAAOqC,CAAAA,QAvFtB,CAwFInC,kBAAWF,eAAOE,CAAAA,QAxFtB,CA0FIyC,MAAQN,QAASM,CAAAA,KA1FrB,CA2FIC,kBAAoBP,QAASQ,CAAAA,UAAWC,CAAAA,QA3F5C,CA4FIC,cAAgBV,QAASW,CAAAA,eAAgBF,CAAAA,QA5F7C,CA6FIzC,8BAAuBgC,QAAShC,CAAAA,oBA7FpC,CA8FI4C,gBAAkBZ,QAASQ,CAAAA,UAAWK,CAAAA,MA9F1C,CA+FIC,YAAcd,QAASW,CAAAA,eAAgBF,CAAAA,QA/F3C,CAgGIM,OAASf,QAASe,CAAAA,MAhGtB,CAiGIC,UAAYhB,QAASgB,CAAAA,SAjGzB,CAkGUC,EAlGV,CAkGcC,EAlGd,CAqGIC,iBAAmB,IAAIC,YAAJ,CAAiBb,iBAAkBc,CAAAA,KAAnC,CAA2Cd,iBAAkBe,CAAAA,QAA7D,CACnBC;QAAAA,CAAiB,IAAIH,YAAJ,CAAiBR,eAAgBS,CAAAA,KAAjC,CAAyCT,eAAgBU,CAAAA,QAAzD,CAErB,IAAc,IAAd,GAAIhB,KAAJ,CAEE,GAAIkB,KAAMC,CAAAA,OAAN,CAAc5D,iBAAd,CAAJ,CAA6B,CACtB,IAAA6D,EAAI,CAAT,KAAYT,EAAZ,CAAiBF,MAAO7B,CAAAA,MAAxB,CAAgCwC,CAAhC,CAAoCT,EAApC,CAAwCS,CAAA,EAAxC,CAA6C,CAC3C,IAAAC,WAAQZ,MAAA,CAAOW,CAAP,CACR,KAAAE,cAAgB/D,iBAAA,CAAS8D,UAAME,CAAAA,aAAf,CAChB,KAAAC,EAAQC,IAAKC,CAAAA,GAAL,CAASL,UAAMG,CAAAA,KAAf,CAAsBd,SAAUc,CAAAA,KAAhC,CAGR,KAAgBZ,EAAhB,CAFAe,UAEA,CAFMF,IAAKG,CAAAA,GAAL,CAASP,UAAMG,CAAAA,KAAf,CAAuBH,UAAMN,CAAAA,KAA7B,CAAoCL,SAAUc,CAAAA,KAA9C,CAAsDd,SAAUK,CAAAA,KAAhE,CAEN,CAA0Bc,CAA1B,CAA8BjB,EAA9B,CAAkCiB,CAAlC,EAAuC,CAAvC,CAA0C,CACxClE,UAAA,CAAIqC,KAAM8B,CAAAA,IAAN,CAAWD,CAAX,CACJ,KAAAjE,WAAIoC,KAAM8B,CAAAA,IAAN,CAAWD,CAAX,CAAe,CAAf,CACJ,KAAAhE,WAAImC,KAAM8B,CAAAA,IAAN,CAAWD,CAAX,CAAe,CAAf,CAEJvE,+BAAA,CAA+BD,eAA/B;AAAuCiE,aAAvC,CAAsDrB,iBAAtD,CAAyEG,aAAzE,CAAwF1C,6BAAxF,CAA8GC,UAA9G,CAAiHC,UAAjH,CAAoHC,UAApH,CAAuHgD,gBAAvH,CAEAvD,+BAAA,CAA+BD,eAA/B,CAAuCiE,aAAvC,CAAsDhB,eAAtD,CAAuEE,WAAvE,CAAoF9C,6BAApF,CAA0GC,UAA1G,CAA6GC,UAA7G,CAAgHC,UAAhH,CAAmHoD,QAAnH,CAPwC,CANC,CADlB,CAA7B,IAqBE,KAHAO,CAGgB,CAHRC,IAAKC,CAAAA,GAAL,CAAS,CAAT,CAAYhB,SAAUc,CAAAA,KAAtB,CAGQ,CAFhBG,UAEgB,CAFVF,IAAKG,CAAAA,GAAL,CAAS5B,KAAMe,CAAAA,KAAf,CAAsBL,SAAUc,CAAAA,KAAhC,CAAwCd,SAAUK,CAAAA,KAAlD,CAEU,CAAXK,CAAW,CAAPI,CAAO,CAAAb,EAAA,CAAKgB,UAArB,CAA0BP,CAA1B,CAA8BT,EAA9B,CAAkCS,CAAlC,EAAuC,CAAvC,CACEzD,UAMA,CANIqC,KAAM8B,CAAAA,IAAN,CAAWV,CAAX,CAMJ,CALAxD,UAKA,CALIoC,KAAM8B,CAAAA,IAAN,CAAWV,CAAX,CAAe,CAAf,CAKJ,CAJAvD,UAIA,CAJImC,KAAM8B,CAAAA,IAAN,CAAWV,CAAX,CAAe,CAAf,CAIJ;AAFA9D,8BAAA,CAA+BD,eAA/B,CAAuCE,iBAAvC,CAAiD0C,iBAAjD,CAAoEG,aAApE,CAAmF1C,6BAAnF,CAAyGC,UAAzG,CAA4GC,UAA5G,CAA+GC,UAA/G,CAAkHgD,gBAAlH,CAEA,CAAAvD,8BAAA,CAA+BD,eAA/B,CAAuCE,iBAAvC,CAAiD+C,eAAjD,CAAkEE,WAAlE,CAA+E9C,6BAA/E,CAAqGC,UAArG,CAAwGC,UAAxG,CAA2GC,UAA3G,CAA8GoD,QAA9G,CA9BN,KAiCO,IAA0Bc,IAAAA,EAA1B,GAAI9B,iBAAJ,CAEL,GAAIiB,KAAMC,CAAAA,OAAN,CAAc5D,iBAAd,CAAJ,CACE,IAAK6D,CAAO,CAAH,CAAG,CAAAT,EAAA,CAAKF,MAAO7B,CAAAA,MAAxB,CAAgCwC,CAAhC,CAAoCT,EAApC,CAAwCS,CAAA,EAAxC,CAME,IALAC,UAKgB,CALRZ,MAAA,CAAOW,CAAP,CAKQ,CAJhBE,aAIgB,CAJA/D,iBAAA,CAAS8D,UAAME,CAAAA,aAAf,CAIA;AAHhBC,CAGgB,CAHRC,IAAKC,CAAAA,GAAL,CAASL,UAAMG,CAAAA,KAAf,CAAsBd,SAAUc,CAAAA,KAAhC,CAGQ,CAAAZ,EAAA,CAFhBe,UAEgB,CAFVF,IAAKG,CAAAA,GAAL,CAASP,UAAMG,CAAAA,KAAf,CAAuBH,UAAMN,CAAAA,KAA7B,CAAoCL,SAAUc,CAAAA,KAA9C,CAAsDd,SAAUK,CAAAA,KAAhE,CAEN,CAA0Bc,CAA1B,CAA8BjB,EAA9B,CAAkCiB,CAAlC,EAAuC,CAAvC,CACElE,UAMA,CANIkE,CAMJ,CALAjE,UAKA,CALIiE,CAKJ,CALQ,CAKR,CAJAhE,UAIA,CAJIgE,CAIJ,CAJQ,CAIR,CAFAvE,8BAAA,CAA+BD,eAA/B,CAAuCiE,aAAvC,CAAsDrB,iBAAtD,CAAyEG,aAAzE,CAAwF1C,6BAAxF,CAA8GC,UAA9G,CAAiHC,UAAjH,CAAoHC,UAApH,CAAuHgD,gBAAvH,CAEA,CAAAvD,8BAAA,CAA+BD,eAA/B,CAAuCiE,aAAvC,CAAsDhB,eAAtD,CAAuEE,WAAvE,CAAoF9C,6BAApF,CAA0GC,UAA1G,CAA6GC,UAA7G;AAAgHC,UAAhH,CAAmHoD,QAAnH,CAdN,KAqBE,KAHAO,CAGgB,CAHRC,IAAKC,CAAAA,GAAL,CAAS,CAAT,CAAYhB,SAAUc,CAAAA,KAAtB,CAGQ,CAFhBG,UAEgB,CAFVF,IAAKG,CAAAA,GAAL,CAAS3B,iBAAkBc,CAAAA,KAA3B,CAAkCL,SAAUc,CAAAA,KAA5C,CAAoDd,SAAUK,CAAAA,KAA9D,CAEU,CAAXK,CAAW,CAAPI,CAAO,CAAAb,EAAA,CAAKgB,UAArB,CAA0BP,CAA1B,CAA8BT,EAA9B,CAAkCS,CAAlC,EAAuC,CAAvC,CACEzD,UAMA,CANIyD,CAMJ,CALAxD,UAKA,CALIwD,CAKJ,CALQ,CAKR,CAJAvD,UAIA,CAJIuD,CAIJ,CAJQ,CAIR,CAFA9D,8BAAA,CAA+BD,eAA/B,CAAuCE,iBAAvC,CAAiD0C,iBAAjD,CAAoEG,aAApE,CAAmF1C,6BAAnF,CAAyGC,UAAzG,CAA4GC,UAA5G,CAA+GC,UAA/G,CAAkHgD,gBAAlH,CAEA,CAAAvD,8BAAA,CAA+BD,eAA/B,CAAuCE,iBAAvC,CAAiD+C,eAAjD,CAAkEE,WAAlE,CAA+E9C,6BAA/E;AAAqGC,UAArG,CAAwGC,UAAxG,CAA2GC,UAA3G,CAA8GoD,QAA9G,CAKFe,gBAAAA,CAA2B,IAAIlC,MAAOmC,CAAAA,sBAAX,CAAkCpB,gBAAlC,CAAoD,CAApD,CAC3BqB,kBAAAA,CAAyB,IAAIpC,MAAOmC,CAAAA,sBAAX,CAAkChB,QAAlC,CAAkD,CAAlD,CAC7B,OAAO,CACchB,iBADd,CAEYK,eAFZ,CAGL0B,yBAA0BA,eAHrB,CAILE,uBAAwBA,iBAJnB,CApLiC,CAje1ClF,QAAQmF,CAAAA,iBAAR,CAmQAA,QAA0B,CAACzC,QAAD,CAAW,CAInC,IAAI0C,IAAM,CAAV,CAESC,IAAT,KAASA,IAAT,GAAiB3C,SAASQ,CAAAA,UAA1B,CAAsC,CACpC,IAAIoC,KAAO5C,QAAS6C,CAAAA,YAAT,CAAsBF,IAAtB,CACXD,IAAA,EAAOE,IAAKvB,CAAAA,KAAZ,CAAoBuB,IAAKtB,CAAAA,QAAzB,CAAoCsB,IAAKE,CAAAA,KAAMC,CAAAA,iBAFX,CAKlCC,QAAAA,CAAUhD,QAASiD,CAAAA,QAAT,EAEd;MADAP,IACA,EADOM,QAAA,CAAUA,QAAQ3B,CAAAA,KAAlB,CAA0B2B,QAAQ1B,CAAAA,QAAlC,CAA6C0B,QAAQF,CAAAA,KAAMC,CAAAA,iBAA3D,CAA+E,CAZnD,CAlQrCzF,QAAQ4F,CAAAA,aAAR,CAwRAA,QAAsB,CAAClD,QAAD,CAAW,CAC/B,IAAImD,UAA+B,CAAnB,CAAAC,SAAUlE,CAAAA,MAAV,EAAyCmD,IAAAA,EAAzC,GAAwBe,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoE,IACpFD,UAAA,CAAYpB,IAAKC,CAAAA,GAAL,CAASmB,SAAT,CAAoBE,MAAOC,CAAAA,OAA3B,CAGZ,KAAIC,YAAc,EAAlB,CACIP,QAAUhD,QAASiD,CAAAA,QAAT,EADd,CAEIO,UAAYxD,QAAS6C,CAAAA,YAAT,CAAsB,UAAtB,CAFhB,CAGIY,YAAcT,OAAA,CAAUA,OAAQ3B,CAAAA,KAAlB,CAA0BmC,SAAUnC,CAAAA,KAHtD,CAKIqC,UAAY,CAEZC,UAAAA,CAAiBpG,MAAOqG,CAAAA,IAAP,CAAY5D,QAASQ,CAAAA,UAArB,CAMrB,KALA,IAAIqD,WAAa,EAAjB,CACIC,iBAAmB,EADvB,CAEIC,WAAa,EAFjB;AAGIC,QAAU,CAAC,MAAD,CAAS,MAAT,CAAiB,MAAjB,CAAyB,MAAzB,CAHd,CAKStC,EAAI,CALb,CAKgBuC,EAAIN,SAAezE,CAAAA,MAAnC,CAA2CwC,CAA3C,CAA+CuC,CAA/C,CAAkDvC,CAAA,EAAlD,CAAuD,CACrD,IAAIiB,KAAOgB,SAAA,CAAejC,CAAf,CACXmC,WAAA,CAAWlB,IAAX,CAAA,CAAmB,EACnB,KAAIuB,UAAYlE,QAASW,CAAAA,eAAT,CAAyBgC,IAAzB,CAEZuB,UAAJ,GACEJ,gBAAA,CAAiBnB,IAAjB,CADF,CAC+BnB,KAAJ,CAAU0C,SAAUhF,CAAAA,MAApB,CAA4BiF,CAAAA,IAA5B,CAAiC,CAAjC,CAAoCC,CAAAA,GAApC,CAAwC,QAAS,EAAG,CAC3E,MAAO,EADoE,CAApD,CAD3B,CALqD,CAcnDC,SAAAA,CAAkBtC,IAAKuC,CAAAA,GAAL,CAAS,EAAT,CADHvC,IAAKwC,CAAAA,KAALC,CAAW,CAAXA,CAAerB,SAAfqB,CACG,CAEtB,KAASC,CAAT,CAAc,CAAd,CAAiBA,CAAjB,CAAsBhB,WAAtB,CAAmCgB,CAAA,EAAnC,CAAyC,CACnCnE,CAAAA,CAAQ0C,OAAA,CAAUA,OAAQZ,CAAAA,IAAR,CAAaqC,CAAb,CAAV,CAA6BA,CAErCC,KAAAA,CAAO,EAEFvC,UAAAA,CAAI,CAAb,KAAK,IAAWwC,IAAMhB,SAAezE,CAAAA,MAArC,CAA6CiD,SAA7C,CAAiDwC,GAAjD,CAAsDxC,SAAA,EAAtD,CAKE,IAHA,IAAIrE,UAAYkC,QAAS6C,CAAAA,YAAT,CADHc,SAAAiB,CAAezC,SAAfyC,CACG,CAAhB,CACItD,SAAWxD,SAAUwD,CAAAA,QADzB;AAGSuD,EAAI,CAAb,CAAgBA,CAAhB,CAAoBvD,QAApB,CAA8BuD,CAAA,EAA9B,CAGEH,IAAA,EAAQ,EAAGI,CAAAA,MAAH,CAAU,CAAC,EAAEhH,SAAA,CAAUkG,OAAA,CAAQa,CAAR,CAAV,CAAA,CAAsBvE,CAAtB,CAAF,CAAiC+D,SAAjC,CAAX,CAA8D,GAA9D,CAMZ,IAAIK,IAAJ,GAAYnB,YAAZ,CACEQ,UAAWgB,CAAAA,IAAX,CAAgBxB,WAAA,CAAYmB,IAAZ,CAAhB,CADF,KAEO,CAEIM,SAAAA,CAAK,CAAd,KAAiBC,GAAjB,CAAuBtB,SAAezE,CAAAA,MAAtC,CAA8C8F,SAA9C,CAAmDC,GAAnD,CAAwDD,SAAA,EAAxD,CAA8D,CAC5D,IAAIE,OAASvB,SAAA,CAAeqB,SAAf,CAETG,UAAAA,CAAcnF,QAAS6C,CAAAA,YAAT,CAAsBqC,MAAtB,CAEdE,SAAAA,CAAapF,QAASW,CAAAA,eAAT,CAAyBuE,MAAzB,CACbG,EAAAA,CAAYF,SAAY7D,CAAAA,QAC5B,KAAIgE,SAAWzB,UAAA,CAAWqB,MAAX,CACXK,OAAAA,CAAiBzB,gBAAA,CAAiBoB,MAAjB,CAErB,KAAK,IAAIM,GAAK,CAAd,CAAiBA,EAAjB,CAAsBH,CAAtB,CAAiCG,EAAA,EAAjC,CAAuC,CACrC,IAAIC,WAAazB,OAAA,CAAQwB,EAAR,CAEjBF,SAASP,CAAAA,IAAT,CAAcI,SAAA,CAAYM,UAAZ,CAAA,CAAwBnF,CAAxB,CAAd,CAEA,IAAI8E,QAAJ,CACE,IADc,IACLM;AAAI,CADC,CACEC,GAAKP,QAAWlG,CAAAA,MAAhC,CAAwCwG,CAAxC,CAA4CC,EAA5C,CAAgDD,CAAA,EAAhD,CAEEH,MAAA,CAAeG,CAAf,CAAkBX,CAAAA,IAAlB,CAAuBK,QAAA,CAAWM,CAAX,CAAA,CAAcD,UAAd,CAAA,CAA0BnF,CAA1B,CAAvB,CARiC,CAVqB,CAwB9DiD,WAAA,CAAYmB,IAAZ,CAAA,CAAoBhB,SACpBK,WAAWgB,CAAAA,IAAX,CAAgBrB,SAAhB,CACAA,UAAA,EA5BK,CArBgC,CAuDrCkC,WAAAA,CAAS5F,QAAS6F,CAAAA,KAAT,EAEJC,QAAAA,CAAM,CAAf,KAAkBC,WAAlB,CAAwBpC,SAAezE,CAAAA,MAAvC,CAA+C4G,OAA/C,CAAqDC,WAArD,CAA0DD,OAAA,EAA1D,CAUE,GATIE,SASA,CATSrC,SAAA,CAAemC,OAAf,CAST,CARAG,OAQA,CARejG,QAAS6C,CAAAA,YAAT,CAAsBmD,SAAtB,CAQf,CANAE,SAMA,CANS,IAAID,OAAanD,CAAAA,KAAMqD,CAAAA,WAAvB,CAAmCtC,UAAA,CAAWmC,SAAX,CAAnC,CAMT,CAJAI,OAIA,CAJc,IAAIhG,MAAOiG,CAAAA,eAAX,CAA2BH,SAA3B,CAAmCD,OAAa3E,CAAAA,QAAhD,CAA0D2E,OAAaK,CAAAA,UAAvE,CAId,CAFJV,WAAOW,CAAAA,YAAP,CAAoBP,SAApB,CAA4BI,OAA5B,CAEI;AAAAJ,SAAA,GAAUlC,iBAAd,CACE,IAAS0C,OAAT,CAAe,CAAf,CAAkBA,OAAlB,CAAwB1C,gBAAA,CAAiBkC,SAAjB,CAAyB9G,CAAAA,MAAjD,CAAyDsH,OAAA,EAAzD,CACMC,SAKJ,CALwBzG,QAASW,CAAAA,eAAT,CAAyBqF,SAAzB,CAAA,CAAiCQ,OAAjC,CAKxB,CAHIE,CAGJ,CAHc,IAAID,SAAkB3D,CAAAA,KAAMqD,CAAAA,WAA5B,CAAwCrC,gBAAA,CAAiBkC,SAAjB,CAAA,CAAyBQ,OAAzB,CAAxC,CAGd,CADIzI,SACJ,CADqB,IAAIqC,MAAOiG,CAAAA,eAAX,CAA2BK,CAA3B,CAAoCD,SAAkBnF,CAAAA,QAAtD,CAAgEmF,SAAkBH,CAAAA,UAAlF,CACrB,CAAAV,WAAOjF,CAAAA,eAAP,CAAuBqF,SAAvB,CAAA,CAA+BQ,OAA/B,CAAA,CAAsCzI,SAM5C6H,YAAOe,CAAAA,QAAP,CAAgB5C,UAAhB,CACA,OAAO6B,YAnHwB,CAvRjCtI,QAAQsJ,CAAAA,mBAAR,CAmZAA,QAA4B,CAAC5G,QAAD,CAAW6G,QAAX,CAAqB,CAC/C,GAAIA,QAAJ,GAAiBzG,MAAO0G,CAAAA,iBAAxB,CAEE,MADA5G,QAAQ6G,CAAAA,IAAR,CAAa,yFAAb,CACO/G;AAAAA,QAGT,IAAI6G,QAAJ,GAAiBzG,MAAO4G,CAAAA,mBAAxB,EAA+CH,QAA/C,GAA4DzG,MAAO6G,CAAAA,qBAAnE,CAA0F,CACxF,IAAI3G,MAAQN,QAASiD,CAAAA,QAAT,EAEZ,IAAc,IAAd,GAAI3C,KAAJ,CAAoB,CAClB,IAAI0C,QAAU,EACVvC,MAAAA,CAAWT,QAAS6C,CAAAA,YAAT,CAAsB,UAAtB,CAEf,IAAiBR,IAAAA,EAAjB,GAAI5B,KAAJ,CAA4B,CAC1B,IAAK,IAAIiB,EAAI,CAAb,CAAgBA,CAAhB,CAAoBjB,KAASY,CAAAA,KAA7B,CAAoCK,CAAA,EAApC,CACEsB,OAAQ+B,CAAAA,IAAR,CAAarD,CAAb,CAGF1B,SAAS2G,CAAAA,QAAT,CAAkB3D,OAAlB,CACA1C,MAAA,CAAQN,QAASiD,CAAAA,QAAT,EANkB,CAA5B,IASE,OADA/C,QAAQC,CAAAA,KAAR,CAAc,yGAAd,CACOH,CAAAA,QAbS,CAkBhBkH,CAAAA,CAAoB5G,KAAMe,CAAAA,KAA1B6F,CAAkC,CAClCnD,QAAAA,CAAa,EAEjB,IAAIzD,KAAJ,CACE,GAAIuG,QAAJ;AAAiBzG,MAAO4G,CAAAA,mBAAxB,CAEE,IAASG,QAAT,CAAe,CAAf,CAAkBA,QAAlB,EAAyBD,CAAzB,CAA4CC,QAAA,EAA5C,CACEpD,OAAWgB,CAAAA,IAAX,CAAgBzE,KAAM8B,CAAAA,IAAN,CAAW,CAAX,CAAhB,CAEA,CADA2B,OAAWgB,CAAAA,IAAX,CAAgBzE,KAAM8B,CAAAA,IAAN,CAAW+E,QAAX,CAAhB,CACA,CAAApD,OAAWgB,CAAAA,IAAX,CAAgBzE,KAAM8B,CAAAA,IAAN,CAAW+E,QAAX,CAAiB,CAAjB,CAAhB,CALJ,KASE,KAASC,QAAT,CAAe,CAAf,CAAkBA,QAAlB,CAAwBF,CAAxB,CAA2CE,QAAA,EAA3C,CACkB,CAAhB,GAAIA,QAAJ,CAAU,CAAV,EACErD,OAAWgB,CAAAA,IAAX,CAAgBzE,KAAM8B,CAAAA,IAAN,CAAWgF,QAAX,CAAhB,CAEA,CADArD,OAAWgB,CAAAA,IAAX,CAAgBzE,KAAM8B,CAAAA,IAAN,CAAWgF,QAAX,CAAiB,CAAjB,CAAhB,CACA,CAAArD,OAAWgB,CAAAA,IAAX,CAAgBzE,KAAM8B,CAAAA,IAAN,CAAWgF,QAAX,CAAiB,CAAjB,CAAhB,CAHF,GAKErD,OAAWgB,CAAAA,IAAX,CAAgBzE,KAAM8B,CAAAA,IAAN,CAAWgF,QAAX,CAAiB,CAAjB,CAAhB,CAEA,CADArD,OAAWgB,CAAAA,IAAX,CAAgBzE,KAAM8B,CAAAA,IAAN,CAAWgF,QAAX,CAAiB,CAAjB,CAAhB,CACA,CAAArD,OAAWgB,CAAAA,IAAX,CAAgBzE,KAAM8B,CAAAA,IAAN,CAAWgF,QAAX,CAAhB,CAPF,CAaFrD,QAAW7E,CAAAA,MAAf,CAAwB,CAAxB,GAA8BgI,CAA9B,EACEhH,OAAQC,CAAAA,KAAR,CAAc,kGAAd,CAIEkH;QAAAA,CAAcrH,QAAS6F,CAAAA,KAAT,EAClBwB,SAAYV,CAAAA,QAAZ,CAAqB5C,OAArB,CACAsD,SAAYC,CAAAA,WAAZ,EACA,OAAOD,SAxDiF,CA0DxFnH,OAAQC,CAAAA,KAAR,CAAc,qEAAd,CAAqF0G,QAArF,CACA,OAAO7G,SAjEsC,CAlZjD1C,QAAQiK,CAAAA,qBAAR,CAAgCjK,OAAQkK,CAAAA,qBAAxC,CAAgElK,OAAQmK,CAAAA,oBAAxE,CAA+F,IAAK,EAEpG,KAAIrH,OAAShD,OAAA,CAAQ,8CAAR,CAAb,CAEIsK,SAAWtK,OAAA,CAAQ,gDAAR,CA+IfE,QAAQiK,CAAAA,qBAAR,CAxI4BA,QAA8B,CAACI,UAAD,CAAaC,SAAb,CAAwB,CAChF,IAAIC;AAAoC,IAApCA,GAAYF,UAAA,CAAW,CAAX,CAAcrH,CAAAA,KAA9B,CACIwH,eAAiB,IAAIC,GAAJ,CAAQxK,MAAOqG,CAAAA,IAAP,CAAY+D,UAAA,CAAW,CAAX,CAAcnH,CAAAA,UAA1B,CAAR,CADrB,CAEIwH,oBAAsB,IAAID,GAAJ,CAAQxK,MAAOqG,CAAAA,IAAP,CAAY+D,UAAA,CAAW,CAAX,CAAchH,CAAAA,eAA1B,CAAR,CAF1B,CAGIH,WAAa,EAHjB,CAIIG,gBAAkB,EAJtB,CAKI3C,qBAAuB2J,UAAA,CAAW,CAAX,CAAc3J,CAAAA,oBALzC,CAMIiK,eAAiB,IAAI7H,MAAO8H,CAAAA,cANhC,CAOIC,OAAS,CACbR,WAAWS,CAAAA,OAAX,CAAmB,QAAS,CAACC,IAAD,CAAO3G,CAAP,CAAU,CACpC,IAAI4G,gBAAkB,CAEtB,IAAIT,SAAJ,IAAkC,IAAlC,GAAmBQ,IAAK/H,CAAAA,KAAxB,EAEE,MADAJ,QAAQC,CAAAA,KAAR,CAAc,oFAAd,CAAqGuB,CAArG;AAAyG,8HAAzG,CACO,CAAA,IAIT,KAAKiB,IAAIA,IAAT,GAAiB0F,KAAK7H,CAAAA,UAAtB,CAAkC,CAChC,GAAI,CAACsH,cAAeS,CAAAA,GAAf,CAAmB5F,IAAnB,CAAL,CAEE,MADAzC,QAAQC,CAAAA,KAAR,CAAc,oFAAd,CAAqGuB,CAArG,CAAyG,+DAAzG,CAA2KiB,IAA3K,CAAkL,8DAAlL,CACO,CAAA,IAGgBN,KAAAA,EAAzB,GAAI7B,UAAA,CAAWmC,IAAX,CAAJ,GACEnC,UAAA,CAAWmC,IAAX,CADF,CACqB,EADrB,CAIAnC,WAAA,CAAWmC,IAAX,CAAiBoC,CAAAA,IAAjB,CAAsBsD,IAAK7H,CAAAA,UAAL,CAAgBmC,IAAhB,CAAtB,CACA2F;eAAA,EAXgC,CAelC,GAAIA,eAAJ,GAAwBR,cAAeU,CAAAA,IAAvC,CAEE,MADAtI,QAAQC,CAAAA,KAAR,CAAc,oFAAd,CAAqGuB,CAArG,CAAyG,gEAAzG,CACO,CAAA,IAIT,IAAI1D,oBAAJ,GAA6BqK,IAAKrK,CAAAA,oBAAlC,CAEE,MADAkC,QAAQC,CAAAA,KAAR,CAAc,oFAAd,CAAqGuB,CAArG,CAAyG,uEAAzG,CACO,CAAA,IAGT,KAAK+G,IAAIA,KAAT,GAAkBJ,KAAK1H,CAAAA,eAAvB,CAAwC,CACtC,GAAI,CAACqH,mBAAoBO,CAAAA,GAApB,CAAwBE,KAAxB,CAAL,CAEE,MADAvI,QAAQC,CAAAA,KAAR,CAAc,oFAAd;AAAqGuB,CAArG,CAAyG,mEAAzG,CACO,CAAA,IAGsBW,KAAAA,EAA/B,GAAI1B,eAAA,CAAgB8H,KAAhB,CAAJ,GAA0C9H,eAAA,CAAgB8H,KAAhB,CAA1C,CAAmE,EAAnE,CAEA9H,gBAAA,CAAgB8H,KAAhB,CAAuB1D,CAAAA,IAAvB,CAA4BsD,IAAK1H,CAAAA,eAAL,CAAqB8H,KAArB,CAA5B,CARsC,CAYxCR,cAAeS,CAAAA,QAASC,CAAAA,cAAxB,CAAyCV,cAAeS,CAAAA,QAASC,CAAAA,cAAjE,EAAmF,EACnFV,eAAeS,CAAAA,QAASC,CAAAA,cAAe5D,CAAAA,IAAvC,CAA4CsD,IAAKK,CAAAA,QAAjD,CAEA,IAAId,SAAJ,CAAe,CAGb,GAAIS,IAAK/H,CAAAA,KAAT,CACEe,IAAA,CAAQgH,IAAK/H,CAAAA,KAAMe,CAAAA,KADrB,KAEO,IAAiCgB,IAAAA,EAAjC,GAAIgG,IAAK7H,CAAAA,UAAWC,CAAAA,QAApB,CACLY,IAAA,CAAQgH,IAAK7H,CAAAA,UAAWC,CAAAA,QAASY,CAAAA,KAD5B,KAIL,OADAnB,QAAQC,CAAAA,KAAR,CAAc,oFAAd;AAAqGuB,CAArG,CAAyG,kEAAzG,CACO,CAAA,IAGTuG,eAAeW,CAAAA,QAAf,CAAwBT,MAAxB,CAAgC9G,IAAhC,CAAuCK,CAAvC,CACAyG,OAAA,EAAU9G,IAbG,CAlDqB,CAAtC,CAmEA,IAAIwG,SAAJ,CAAe,CACb,IAAIgB,YAAc,CAAlB,CACIC,YAAc,EAClBnB,WAAWS,CAAAA,OAAX,CAAmB,QAAS,CAACC,IAAD,CAAO,CAGjC,IAFA,IAAI/H,MAAQ+H,IAAK/H,CAAAA,KAAjB,CAES6B,EAAI,CAAb,CAAgBA,CAAhB,CAAoB7B,KAAMe,CAAAA,KAA1B,CAAiC,EAAEc,CAAnC,CACE2G,WAAY/D,CAAAA,IAAZ,CAAiBzE,KAAM8B,CAAAA,IAAN,CAAWD,CAAX,CAAjB,CAAiC0G,WAAjC,CAGFA,YAAA,EAAeR,IAAK7H,CAAAA,UAAWC,CAAAA,QAASY,CAAAA,KAPP,CAAnC,CASA4G,eAAetB,CAAAA,QAAf,CAAwBmC,WAAxB,CAZa,CAgBf,IAAKnG,IAAIA,aAAT,GAAiBnC,WAAjB,CAA6B,CACvBuI,UAAAA,CAAkBvB,qBAAA,CAAsBhH,UAAA,CAAWmC,aAAX,CAAtB,CAEtB,IAAI,CAACoG,UAAL,CAEE,MADA7I,QAAQC,CAAAA,KAAR,CAAc,uFAAd;AAAwGwC,aAAxG,CAA+G,aAA/G,CACO,CAAA,IAGTsF,eAAe1B,CAAAA,YAAf,CAA4B5D,aAA5B,CAAkCoG,UAAlC,CAR2B,CAY7B,IAAKC,IAAIA,MAAT,GAAmBrI,gBAAnB,CAAoC,CAC9BsI,aAAAA,CAAkBtI,eAAA,CAAgBqI,MAAhB,CAAA,CAAwB,CAAxB,CAA2B9J,CAAAA,MACjD,IAAwB,CAAxB,GAAI+J,aAAJ,CAA2B,KAC3BhB,eAAetH,CAAAA,eAAf,CAAiCsH,cAAetH,CAAAA,eAAhD,EAAmE,EACnEsH,eAAetH,CAAAA,eAAf,CAA+BqI,MAA/B,CAAA,CAAyC,EAEzC,KAAStH,UAAT,CAAa,CAAb,CAAgBA,UAAhB,CAAoBuH,aAApB,CAAqC,EAAEvH,UAAvC,CAA0C,CAGxC,IAFA,IAAIwH,uBAAyB,EAA7B,CAES/G,WAAI,CAAb,CAAgBA,UAAhB,CAAoBxB,eAAA,CAAgBqI,MAAhB,CAAwB9J,CAAAA,MAA5C,CAAoD,EAAEiD,UAAtD,CACE+G,sBAAuBnE,CAAAA,IAAvB,CAA4BpE,eAAA,CAAgBqI,MAAhB,CAAA,CAAwB7G,UAAxB,CAAA,CAA2BT,UAA3B,CAA5B,CAGEyH;sBAAAA,CAAuB3B,qBAAA,CAAsB0B,sBAAtB,CAE3B,IAAI,CAACC,sBAAL,CAEE,MADAjJ,QAAQC,CAAAA,KAAR,CAAc,uFAAd,CAAwG6I,MAAxG,CAAiH,kBAAjH,CACO,CAAA,IAGTf,eAAetH,CAAAA,eAAf,CAA+BqI,MAA/B,CAAuCjE,CAAAA,IAAvC,CAA4CoE,sBAA5C,CAdwC,CANR,CAwBpC,MAAOlB,eAhIyE,CA0IlF,KAAIT,sBAAwBA,QAA8B,CAAChH,UAAD,CAAa,CACrE,IAAI4I,WAAa/G,IAAAA,EAAjB,CACIf,SAAWe,IAAAA,EADf,CAEIiE,WAAajE,IAAAA,EAFjB,CAGIgH,YAAc,CAClB7I,WAAW4H,CAAAA,OAAX,CAAmB,QAAS,CAACxF,IAAD,CAAO,CACdP,IAAAA,EAAnB,GAAI+G,UAAJ;CACEA,UADF,CACexG,IAAKE,CAAAA,KAAMqD,CAAAA,WAD1B,CAIA,IAAIiD,UAAJ,GAAmBxG,IAAKE,CAAAA,KAAMqD,CAAAA,WAA9B,CAEE,MADAjG,QAAQC,CAAAA,KAAR,CAAc,iJAAd,CACO,CAAA,IAGQkC,KAAAA,EAAjB,GAAIf,QAAJ,GAA4BA,QAA5B,CAAuCsB,IAAKtB,CAAAA,QAA5C,CAEA,IAAIA,QAAJ,GAAiBsB,IAAKtB,CAAAA,QAAtB,CAEE,MADApB,QAAQC,CAAAA,KAAR,CAAc,qIAAd,CACO,CAAA,IAGUkC,KAAAA,EAAnB,GAAIiE,UAAJ;CAA8BA,UAA9B,CAA2C1D,IAAK0D,CAAAA,UAAhD,CAEA,IAAIA,UAAJ,GAAmB1D,IAAK0D,CAAAA,UAAxB,CAEE,MADApG,QAAQC,CAAAA,KAAR,CAAc,uIAAd,CACO,CAAA,IAGTkJ,YAAA,EAAezG,IAAKE,CAAAA,KAAM5D,CAAAA,MAxBO,CAAnC,CA2BA,IAAIkK,UAAJ,EAAkB9H,QAAlB,CAA4B,CAE1B,IAAIwB,MAAQ,IAAIsG,UAAJ,CAAeC,WAAf,CAAZ,CACIlB,OAAS,CACb3H,WAAW4H,CAAAA,OAAX,CAAmB,QAAS,CAACxF,IAAD,CAAO,CACjCE,KAAMjE,CAAAA,GAAN,CAAU+D,IAAKE,CAAAA,KAAf,CAAsBqF,MAAtB,CACAA,OAAA,EAAUvF,IAAKE,CAAAA,KAAM5D,CAAAA,MAFY,CAAnC,CAIA,OAAO,KAAIkB,MAAOiG,CAAAA,eAAX,CAA2BvD,KAA3B,CAAkCxB,QAAlC,CAA4CgF,UAA5C,CARmB,CAhCyC,CAiDvEhJ,QAAQkK,CAAAA,qBAAR;AAAgCA,qBAwDhClK,QAAQmK,CAAAA,oBAAR,CAtD2BA,QAA6B,CAACjH,UAAD,CAAa,CAOnE,IAJA,IAAI4I,WAAa/G,IAAAA,EAAjB,CACIgH,YAAc,CADlB,CAEIC,OAAS,CAFb,CAIS5H,EAAI,CAJb,CAIgBuC,EAAIzD,UAAWtB,CAAAA,MAA/B,CAAuCwC,CAAvC,CAA2CuC,CAA3C,CAA8C,EAAEvC,CAAhD,CAAmD,CACjD,IAAI5D,UAAY0C,UAAA,CAAWkB,CAAX,CACGW,KAAAA,EAAnB,GAAI+G,UAAJ,GAA8BA,UAA9B,CAA2CtL,SAAUgF,CAAAA,KAAMqD,CAAAA,WAA3D,CAEA,IAAIiD,UAAJ,GAAmBtL,SAAUgF,CAAAA,KAAMqD,CAAAA,WAAnC,CAEE,MADAjG,QAAQC,CAAAA,KAAR,CAAc,2DAAd,CACO,CAAA,IAGTkJ,YAAA,EAAevL,SAAUgF,CAAAA,KAAM5D,CAAAA,MAC/BoK,OAAA,EAAUxL,SAAUwD,CAAAA,QAV6B,CAe/CiI,UAAAA,CAAoB,IAAInJ,MAAOoJ,CAAAA,iBAAX,CAA6B,IAAIJ,UAAJ,CAAeC,WAAf,CAA7B;AAA0DC,MAA1D,CACpBnB,YAAAA,CAAS,CACTsB,OAAAA,CAAM,EACNzF,EAAAA,CAAU,CAAC,MAAD,CAAS,MAAT,CAAiB,MAAjB,CAAyB,MAAzB,CACV0F,EAAAA,CAAU,CAAC,MAAD,CAAS,MAAT,CAAiB,MAAjB,CAAyB,MAAzB,CAELvH,UAAAA,CAAI,CAAb,KAAK,IAAWwH,GAAKnJ,UAAWtB,CAAAA,MAAhC,CAAwCiD,SAAxC,CAA4CwH,EAA5C,CAAgDxH,SAAA,EAAhD,CAAqD,CACnD,IAAIyH,WAAapJ,UAAA,CAAW2B,SAAX,CAAjB,CACIb,SAAWsI,UAAWtI,CAAAA,QAD1B,CAEID,MAAQuI,UAAWvI,CAAAA,KAFvB,CAGIwI,IAAM,IAAIzJ,MAAO0J,CAAAA,0BAAX,CAAsCP,UAAtC,CAAyDjI,QAAzD,CAAmE6G,WAAnE,CAA2EyB,UAAWtD,CAAAA,UAAtF,CACVmD,OAAI1E,CAAAA,IAAJ,CAAS8E,GAAT,CACA1B,YAAA,EAAU7G,QAGV,KAAK,IAAInD,EAAI,CAAb,CAAgBA,CAAhB,CAAoBkD,KAApB,CAA2BlD,CAAA,EAA3B,CACE,IAAK,IAAI0G,EAAI,CAAb,CAAgBA,CAAhB,CAAoBvD,QAApB,CAA8BuD,CAAA,EAA9B,CAAmC,CACjC,IAAIhG,IAAM,CAAC,CAAA,CAAG6I,QAASqC,CAAAA,UAAb,EAAyBF,GAAzB,CAA8BH,CAAA,CAAQ7E,CAAR,CAA9B,CAAV,CACImF,IAAM,CAAC,CAAA,CAAGtC,QAASqC,CAAAA,UAAb,EAAyBH,UAAzB;AAAqC5F,CAAA,CAAQa,CAAR,CAArC,CACVhG,IAAA,CAAIV,CAAJ,CAAO6L,GAAA,CAAI7L,CAAJ,CAAP,CAHiC,CAVc,CAkBrD,MAAOsL,OA9C4D,CAlNkD;\",\n\"sources\":[\"node_modules/three-stdlib/utils/BufferGeometryUtils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$utils$BufferGeometryUtils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.computeMorphedAttributes = computeMorphedAttributes;\\nexports.estimateBytesUsed = estimateBytesUsed;\\nexports.mergeVertices = mergeVertices;\\nexports.toTrianglesDrawMode = toTrianglesDrawMode;\\nexports.mergeBufferGeometries = exports.mergeBufferAttributes = exports.interleaveAttributes = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _helpers = require(\\\"../types/helpers.js\\\");\\n\\n/**\\n * @param  {Array<BufferGeometry>} geometries\\n * @param  {Boolean} useGroups\\n * @return {BufferGeometry}\\n */\\nvar mergeBufferGeometries = function mergeBufferGeometries(geometries, useGroups) {\\n  var isIndexed = geometries[0].index !== null;\\n  var attributesUsed = new Set(Object.keys(geometries[0].attributes));\\n  var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\\n  var attributes = {};\\n  var morphAttributes = {};\\n  var morphTargetsRelative = geometries[0].morphTargetsRelative;\\n  var mergedGeometry = new _three.BufferGeometry();\\n  var offset = 0;\\n  geometries.forEach(function (geom, i) {\\n    var attributesCount = 0; // ensure that all geometries are indexed, or none\\n\\n    if (isIndexed !== (geom.index !== null)) {\\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\\n      return null;\\n    } // gather attributes, exit early if they're different\\n\\n\\n    for (var name in geom.attributes) {\\n      if (!attributesUsed.has(name)) {\\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \\\"' + name + '\\\" attribute exists among all geometries, or in none of them.');\\n        return null;\\n      }\\n\\n      if (attributes[name] === undefined) {\\n        attributes[name] = [];\\n      }\\n\\n      attributes[name].push(geom.attributes[name]);\\n      attributesCount++;\\n    } // ensure geometries have the same number of attributes\\n\\n\\n    if (attributesCount !== attributesUsed.size) {\\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\\n      return null;\\n    } // gather morph attributes, exit early if they're different\\n\\n\\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\\n      return null;\\n    }\\n\\n    for (var _name in geom.morphAttributes) {\\n      if (!morphAttributesUsed.has(_name)) {\\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\\n        return null;\\n      }\\n\\n      if (morphAttributes[_name] === undefined) morphAttributes[_name] = [];\\n\\n      morphAttributes[_name].push(geom.morphAttributes[_name]);\\n    } // gather .userData\\n\\n\\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\\n\\n    if (useGroups) {\\n      var count;\\n\\n      if (geom.index) {\\n        count = geom.index.count;\\n      } else if (geom.attributes.position !== undefined) {\\n        count = geom.attributes.position.count;\\n      } else {\\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\\n        return null;\\n      }\\n\\n      mergedGeometry.addGroup(offset, count, i);\\n      offset += count;\\n    }\\n  }); // merge indices\\n\\n  if (isIndexed) {\\n    var indexOffset = 0;\\n    var mergedIndex = [];\\n    geometries.forEach(function (geom) {\\n      var index = geom.index;\\n\\n      for (var j = 0; j < index.count; ++j) {\\n        mergedIndex.push(index.getX(j) + indexOffset);\\n      }\\n\\n      indexOffset += geom.attributes.position.count;\\n    });\\n    mergedGeometry.setIndex(mergedIndex);\\n  } // merge attributes\\n\\n\\n  for (var name in attributes) {\\n    var mergedAttribute = mergeBufferAttributes(attributes[name]);\\n\\n    if (!mergedAttribute) {\\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\\n      return null;\\n    }\\n\\n    mergedGeometry.setAttribute(name, mergedAttribute);\\n  } // merge morph attributes\\n\\n\\n  for (var _name2 in morphAttributes) {\\n    var numMorphTargets = morphAttributes[_name2][0].length;\\n    if (numMorphTargets === 0) break;\\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\\n    mergedGeometry.morphAttributes[_name2] = [];\\n\\n    for (var i = 0; i < numMorphTargets; ++i) {\\n      var morphAttributesToMerge = [];\\n\\n      for (var j = 0; j < morphAttributes[_name2].length; ++j) {\\n        morphAttributesToMerge.push(morphAttributes[_name2][j][i]);\\n      }\\n\\n      var mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\\n\\n      if (!mergedMorphAttribute) {\\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + _name2 + ' morphAttribute.');\\n        return null;\\n      }\\n\\n      mergedGeometry.morphAttributes[_name2].push(mergedMorphAttribute);\\n    }\\n  }\\n\\n  return mergedGeometry;\\n};\\n/**\\n * @param {Array<BufferAttribute>} attributes\\n * @return {BufferAttribute}\\n */\\n\\n\\nexports.mergeBufferGeometries = mergeBufferGeometries;\\n\\nvar mergeBufferAttributes = function mergeBufferAttributes(attributes) {\\n  var TypedArray = undefined;\\n  var itemSize = undefined;\\n  var normalized = undefined;\\n  var arrayLength = 0;\\n  attributes.forEach(function (attr) {\\n    if (TypedArray === undefined) {\\n      TypedArray = attr.array.constructor;\\n    }\\n\\n    if (TypedArray !== attr.array.constructor) {\\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\\n      return null;\\n    }\\n\\n    if (itemSize === undefined) itemSize = attr.itemSize;\\n\\n    if (itemSize !== attr.itemSize) {\\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\\n      return null;\\n    }\\n\\n    if (normalized === undefined) normalized = attr.normalized;\\n\\n    if (normalized !== attr.normalized) {\\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\\n      return null;\\n    }\\n\\n    arrayLength += attr.array.length;\\n  });\\n\\n  if (TypedArray && itemSize) {\\n    // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\\n    var array = new TypedArray(arrayLength);\\n    var offset = 0;\\n    attributes.forEach(function (attr) {\\n      array.set(attr.array, offset);\\n      offset += attr.array.length;\\n    });\\n    return new _three.BufferAttribute(array, itemSize, normalized);\\n  }\\n};\\n/**\\n * @param {Array<BufferAttribute>} attributes\\n * @return {Array<InterleavedBufferAttribute>}\\n */\\n\\n\\nexports.mergeBufferAttributes = mergeBufferAttributes;\\n\\nvar interleaveAttributes = function interleaveAttributes(attributes) {\\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\\n  // a set of InterleavedBufferAttributes for each attribute\\n  var TypedArray = undefined;\\n  var arrayLength = 0;\\n  var stride = 0; // calculate the the length and type of the interleavedBuffer\\n\\n  for (var i = 0, l = attributes.length; i < l; ++i) {\\n    var attribute = attributes[i];\\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\\n\\n    if (TypedArray !== attribute.array.constructor) {\\n      console.error('AttributeBuffers of different types cannot be interleaved');\\n      return null;\\n    }\\n\\n    arrayLength += attribute.array.length;\\n    stride += attribute.itemSize;\\n  } // Create the set of buffer attributes\\n  // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\\n\\n\\n  var interleavedBuffer = new _three.InterleavedBuffer(new TypedArray(arrayLength), stride);\\n  var offset = 0;\\n  var res = [];\\n  var getters = ['getX', 'getY', 'getZ', 'getW'];\\n  var setters = ['setX', 'setY', 'setZ', 'setW'];\\n\\n  for (var j = 0, _l = attributes.length; j < _l; j++) {\\n    var _attribute = attributes[j];\\n    var itemSize = _attribute.itemSize;\\n    var count = _attribute.count;\\n    var iba = new _three.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, _attribute.normalized);\\n    res.push(iba);\\n    offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\\n    // at the appropriate offset\\n\\n    for (var c = 0; c < count; c++) {\\n      for (var k = 0; k < itemSize; k++) {\\n        var set = (0, _helpers.getWithKey)(iba, setters[k]);\\n        var get = (0, _helpers.getWithKey)(_attribute, getters[k]);\\n        set(c, get(c));\\n      }\\n    }\\n  }\\n\\n  return res;\\n};\\n/**\\n * @param {Array<BufferGeometry>} geometry\\n * @return {number}\\n */\\n\\n\\nexports.interleaveAttributes = interleaveAttributes;\\n\\nfunction estimateBytesUsed(geometry) {\\n  // Return the estimated memory used by this geometry in bytes\\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\\n  // for InterleavedBufferAttributes.\\n  var mem = 0;\\n\\n  for (var name in geometry.attributes) {\\n    var attr = geometry.getAttribute(name);\\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\\n  }\\n\\n  var indices = geometry.getIndex();\\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\\n  return mem;\\n}\\n/**\\n * @param {BufferGeometry} geometry\\n * @param {number} tolerance\\n * @return {BufferGeometry>}\\n */\\n\\n\\nfunction mergeVertices(geometry) {\\n  var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\\n  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\\n  // if it's already available.\\n\\n  var hashToIndex = {};\\n  var indices = geometry.getIndex();\\n  var positions = geometry.getAttribute('position');\\n  var vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\\n\\n  var nextIndex = 0; // attributes and new attribute arrays\\n\\n  var attributeNames = Object.keys(geometry.attributes);\\n  var attrArrays = {};\\n  var morphAttrsArrays = {};\\n  var newIndices = [];\\n  var getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\\n\\n  for (var i = 0, l = attributeNames.length; i < l; i++) {\\n    var name = attributeNames[i];\\n    attrArrays[name] = [];\\n    var morphAttr = geometry.morphAttributes[name];\\n\\n    if (morphAttr) {\\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(function () {\\n        return [];\\n      });\\n    }\\n  } // convert the error tolerance to an amount of decimal places to truncate to\\n\\n\\n  var decimalShift = Math.log10(1 / tolerance);\\n  var shiftMultiplier = Math.pow(10, decimalShift);\\n\\n  for (var _i = 0; _i < vertexCount; _i++) {\\n    var index = indices ? indices.getX(_i) : _i; // Generate a hash for the vertex attributes at the current index 'i'\\n\\n    var hash = '';\\n\\n    for (var j = 0, _l2 = attributeNames.length; j < _l2; j++) {\\n      var _name3 = attributeNames[j];\\n      var attribute = geometry.getAttribute(_name3);\\n      var itemSize = attribute.itemSize;\\n\\n      for (var k = 0; k < itemSize; k++) {\\n        // double tilde truncates the decimal value\\n        // @ts-ignore no\\n        hash += \\\"\\\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \\\",\\\");\\n      }\\n    } // Add another reference to the vertex if it's already\\n    // used by another index\\n\\n\\n    if (hash in hashToIndex) {\\n      newIndices.push(hashToIndex[hash]);\\n    } else {\\n      // copy data to the new index in the attribute arrays\\n      for (var _j = 0, _l3 = attributeNames.length; _j < _l3; _j++) {\\n        var _name4 = attributeNames[_j];\\n\\n        var _attribute2 = geometry.getAttribute(_name4);\\n\\n        var _morphAttr = geometry.morphAttributes[_name4];\\n        var _itemSize = _attribute2.itemSize;\\n        var newarray = attrArrays[_name4];\\n        var newMorphArrays = morphAttrsArrays[_name4];\\n\\n        for (var _k = 0; _k < _itemSize; _k++) {\\n          var getterFunc = getters[_k]; // @ts-ignore\\n\\n          newarray.push(_attribute2[getterFunc](index));\\n\\n          if (_morphAttr) {\\n            for (var m = 0, ml = _morphAttr.length; m < ml; m++) {\\n              // @ts-ignore\\n              newMorphArrays[m].push(_morphAttr[m][getterFunc](index));\\n            }\\n          }\\n        }\\n      }\\n\\n      hashToIndex[hash] = nextIndex;\\n      newIndices.push(nextIndex);\\n      nextIndex++;\\n    }\\n  } // Generate typed arrays from new attribute arrays and update\\n  // the attributeBuffers\\n\\n\\n  var result = geometry.clone();\\n\\n  for (var _i2 = 0, _l4 = attributeNames.length; _i2 < _l4; _i2++) {\\n    var _name5 = attributeNames[_i2];\\n    var oldAttribute = geometry.getAttribute(_name5); //@ts-expect-error  something to do with functions and constructors and new\\n\\n    var buffer = new oldAttribute.array.constructor(attrArrays[_name5]);\\n\\n    var _attribute3 = new _three.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\\n\\n    result.setAttribute(_name5, _attribute3); // Update the attribute arrays\\n\\n    if (_name5 in morphAttrsArrays) {\\n      for (var _j2 = 0; _j2 < morphAttrsArrays[_name5].length; _j2++) {\\n        var oldMorphAttribute = geometry.morphAttributes[_name5][_j2]; //@ts-expect-error something to do with functions and constructors and new\\n\\n        var _buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[_name5][_j2]);\\n\\n        var morphAttribute = new _three.BufferAttribute(_buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\\n        result.morphAttributes[_name5][_j2] = morphAttribute;\\n      }\\n    }\\n  } // indices\\n\\n\\n  result.setIndex(newIndices);\\n  return result;\\n}\\n/**\\n * @param {BufferGeometry} geometry\\n * @param {number} drawMode\\n * @return {BufferGeometry}\\n */\\n\\n\\nfunction toTrianglesDrawMode(geometry, drawMode) {\\n  if (drawMode === _three.TrianglesDrawMode) {\\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\\n    return geometry;\\n  }\\n\\n  if (drawMode === _three.TriangleFanDrawMode || drawMode === _three.TriangleStripDrawMode) {\\n    var index = geometry.getIndex(); // generate index if not present\\n\\n    if (index === null) {\\n      var indices = [];\\n      var position = geometry.getAttribute('position');\\n\\n      if (position !== undefined) {\\n        for (var i = 0; i < position.count; i++) {\\n          indices.push(i);\\n        }\\n\\n        geometry.setIndex(indices);\\n        index = geometry.getIndex();\\n      } else {\\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\\n        return geometry;\\n      }\\n    } //\\n\\n\\n    var numberOfTriangles = index.count - 2;\\n    var newIndices = [];\\n\\n    if (index) {\\n      if (drawMode === _three.TriangleFanDrawMode) {\\n        // gl.TRIANGLE_FAN\\n        for (var _i3 = 1; _i3 <= numberOfTriangles; _i3++) {\\n          newIndices.push(index.getX(0));\\n          newIndices.push(index.getX(_i3));\\n          newIndices.push(index.getX(_i3 + 1));\\n        }\\n      } else {\\n        // gl.TRIANGLE_STRIP\\n        for (var _i4 = 0; _i4 < numberOfTriangles; _i4++) {\\n          if (_i4 % 2 === 0) {\\n            newIndices.push(index.getX(_i4));\\n            newIndices.push(index.getX(_i4 + 1));\\n            newIndices.push(index.getX(_i4 + 2));\\n          } else {\\n            newIndices.push(index.getX(_i4 + 2));\\n            newIndices.push(index.getX(_i4 + 1));\\n            newIndices.push(index.getX(_i4));\\n          }\\n        }\\n      }\\n    }\\n\\n    if (newIndices.length / 3 !== numberOfTriangles) {\\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\\n    } // build final geometry\\n\\n\\n    var newGeometry = geometry.clone();\\n    newGeometry.setIndex(newIndices);\\n    newGeometry.clearGroups();\\n    return newGeometry;\\n  } else {\\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\\n    return geometry;\\n  }\\n}\\n/**\\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\\n * Helpful for Raytracing or Decals.\\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\\n * @return {Object} An Object with original position/normal attributes and morphed ones.\\n */\\n\\n\\nfunction computeMorphedAttributes(object) {\\n  if (object.geometry.isBufferGeometry !== true) {\\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\\n    return null;\\n  }\\n\\n  var _vA = new _three.Vector3();\\n\\n  var _vB = new _three.Vector3();\\n\\n  var _vC = new _three.Vector3();\\n\\n  var _tempA = new _three.Vector3();\\n\\n  var _tempB = new _three.Vector3();\\n\\n  var _tempC = new _three.Vector3();\\n\\n  var _morphA = new _three.Vector3();\\n\\n  var _morphB = new _three.Vector3();\\n\\n  var _morphC = new _three.Vector3();\\n\\n  function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\\n    _vA.fromBufferAttribute(attribute, a);\\n\\n    _vB.fromBufferAttribute(attribute, b);\\n\\n    _vC.fromBufferAttribute(attribute, c);\\n\\n    var morphInfluences = object.morphTargetInfluences;\\n\\n    if (material.morphTargets && morphAttribute && morphInfluences) {\\n      _morphA.set(0, 0, 0);\\n\\n      _morphB.set(0, 0, 0);\\n\\n      _morphC.set(0, 0, 0);\\n\\n      for (var _i5 = 0, _il = morphAttribute.length; _i5 < _il; _i5++) {\\n        var influence = morphInfluences[_i5];\\n        var morph = morphAttribute[_i5];\\n        if (influence === 0) continue;\\n\\n        _tempA.fromBufferAttribute(morph, a);\\n\\n        _tempB.fromBufferAttribute(morph, b);\\n\\n        _tempC.fromBufferAttribute(morph, c);\\n\\n        if (morphTargetsRelative) {\\n          _morphA.addScaledVector(_tempA, influence);\\n\\n          _morphB.addScaledVector(_tempB, influence);\\n\\n          _morphC.addScaledVector(_tempC, influence);\\n        } else {\\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\\n\\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\\n\\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\\n        }\\n      }\\n\\n      _vA.add(_morphA);\\n\\n      _vB.add(_morphB);\\n\\n      _vC.add(_morphC);\\n    }\\n\\n    if (object.isSkinnedMesh) {\\n      // @ts-expect-error \\u2013 https://github.com/three-types/three-ts-types/issues/37\\n      object.boneTransform(a, _vA); // @ts-expect-error \\u2013 https://github.com/three-types/three-ts-types/issues/37\\n\\n      object.boneTransform(b, _vB); // @ts-expect-error \\u2013 https://github.com/three-types/three-ts-types/issues/37\\n\\n      object.boneTransform(c, _vC);\\n    }\\n\\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\\n  }\\n\\n  var geometry = object.geometry;\\n  var material = object.material;\\n  var a, b, c;\\n  var index = geometry.index;\\n  var positionAttribute = geometry.attributes.position;\\n  var morphPosition = geometry.morphAttributes.position;\\n  var morphTargetsRelative = geometry.morphTargetsRelative;\\n  var normalAttribute = geometry.attributes.normal;\\n  var morphNormal = geometry.morphAttributes.position;\\n  var groups = geometry.groups;\\n  var drawRange = geometry.drawRange;\\n  var i, j, il, jl;\\n  var group, groupMaterial;\\n  var start, end;\\n  var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\\n  var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\\n\\n  if (index !== null) {\\n    // indexed buffer geometry\\n    if (Array.isArray(material)) {\\n      for (i = 0, il = groups.length; i < il; i++) {\\n        group = groups[i];\\n        groupMaterial = material[group.materialIndex];\\n        start = Math.max(group.start, drawRange.start);\\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\\n\\n        for (j = start, jl = end; j < jl; j += 3) {\\n          a = index.getX(j);\\n          b = index.getX(j + 1);\\n          c = index.getX(j + 2);\\n\\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\\n\\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\\n        }\\n      }\\n    } else {\\n      start = Math.max(0, drawRange.start);\\n      end = Math.min(index.count, drawRange.start + drawRange.count);\\n\\n      for (i = start, il = end; i < il; i += 3) {\\n        a = index.getX(i);\\n        b = index.getX(i + 1);\\n        c = index.getX(i + 2);\\n\\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\\n\\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\\n      }\\n    }\\n  } else if (positionAttribute !== undefined) {\\n    // non-indexed buffer geometry\\n    if (Array.isArray(material)) {\\n      for (i = 0, il = groups.length; i < il; i++) {\\n        group = groups[i];\\n        groupMaterial = material[group.materialIndex];\\n        start = Math.max(group.start, drawRange.start);\\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\\n\\n        for (j = start, jl = end; j < jl; j += 3) {\\n          a = j;\\n          b = j + 1;\\n          c = j + 2;\\n\\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\\n\\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\\n        }\\n      }\\n    } else {\\n      start = Math.max(0, drawRange.start);\\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\\n\\n      for (i = start, il = end; i < il; i += 3) {\\n        a = i;\\n        b = i + 1;\\n        c = i + 2;\\n\\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\\n\\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\\n      }\\n    }\\n  }\\n\\n  var morphedPositionAttribute = new _three.Float32BufferAttribute(modifiedPosition, 3);\\n  var morphedNormalAttribute = new _three.Float32BufferAttribute(modifiedNormal, 3);\\n  return {\\n    positionAttribute: positionAttribute,\\n    normalAttribute: normalAttribute,\\n    morphedPositionAttribute: morphedPositionAttribute,\\n    morphedNormalAttribute: morphedNormalAttribute\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"computeMorphedAttributes\",\"object\",\"_calculateMorphedAttributeData\",\"material\",\"attribute\",\"morphAttribute\",\"morphTargetsRelative\",\"a\",\"b\",\"c\",\"modifiedAttributeArray\",\"_vA\",\"fromBufferAttribute\",\"_vB\",\"_vC\",\"morphInfluences\",\"morphTargetInfluences\",\"morphTargets\",\"_morphA\",\"set\",\"_morphB\",\"_morphC\",\"_i5\",\"_il\",\"length\",\"influence\",\"morph\",\"_tempA\",\"_tempB\",\"_tempC\",\"addScaledVector\",\"sub\",\"add\",\"isSkinnedMesh\",\"boneTransform\",\"x\",\"y\",\"z\",\"geometry\",\"isBufferGeometry\",\"console\",\"error\",\"_three\",\"Vector3\",\"index\",\"positionAttribute\",\"attributes\",\"position\",\"morphPosition\",\"morphAttributes\",\"normalAttribute\",\"normal\",\"morphNormal\",\"groups\",\"drawRange\",\"il\",\"jl\",\"modifiedPosition\",\"Float32Array\",\"count\",\"itemSize\",\"modifiedNormal\",\"Array\",\"isArray\",\"i\",\"group\",\"groupMaterial\",\"materialIndex\",\"start\",\"Math\",\"max\",\"end\",\"min\",\"j\",\"getX\",\"undefined\",\"morphedPositionAttribute\",\"Float32BufferAttribute\",\"morphedNormalAttribute\",\"estimateBytesUsed\",\"mem\",\"name\",\"attr\",\"getAttribute\",\"array\",\"BYTES_PER_ELEMENT\",\"indices\",\"getIndex\",\"mergeVertices\",\"tolerance\",\"arguments\",\"Number\",\"EPSILON\",\"hashToIndex\",\"positions\",\"vertexCount\",\"nextIndex\",\"attributeNames\",\"keys\",\"attrArrays\",\"morphAttrsArrays\",\"newIndices\",\"getters\",\"l\",\"morphAttr\",\"fill\",\"map\",\"shiftMultiplier\",\"pow\",\"log10\",\"decimalShift\",\"_i\",\"hash\",\"_l2\",\"_name3\",\"k\",\"concat\",\"push\",\"_j\",\"_l3\",\"_name4\",\"_attribute2\",\"_morphAttr\",\"_itemSize\",\"newarray\",\"newMorphArrays\",\"_k\",\"getterFunc\",\"m\",\"ml\",\"result\",\"clone\",\"_i2\",\"_l4\",\"_name5\",\"oldAttribute\",\"buffer\",\"constructor\",\"_attribute3\",\"BufferAttribute\",\"normalized\",\"setAttribute\",\"_j2\",\"oldMorphAttribute\",\"_buffer\",\"setIndex\",\"toTrianglesDrawMode\",\"drawMode\",\"TrianglesDrawMode\",\"warn\",\"TriangleFanDrawMode\",\"TriangleStripDrawMode\",\"numberOfTriangles\",\"_i3\",\"_i4\",\"newGeometry\",\"clearGroups\",\"mergeBufferGeometries\",\"mergeBufferAttributes\",\"interleaveAttributes\",\"_helpers\",\"geometries\",\"useGroups\",\"isIndexed\",\"attributesUsed\",\"Set\",\"morphAttributesUsed\",\"mergedGeometry\",\"BufferGeometry\",\"offset\",\"forEach\",\"geom\",\"attributesCount\",\"has\",\"size\",\"_name\",\"userData\",\"mergedUserData\",\"addGroup\",\"indexOffset\",\"mergedIndex\",\"mergedAttribute\",\"_name2\",\"numMorphTargets\",\"morphAttributesToMerge\",\"mergedMorphAttribute\",\"TypedArray\",\"arrayLength\",\"stride\",\"interleavedBuffer\",\"InterleavedBuffer\",\"res\",\"setters\",\"_l\",\"_attribute\",\"iba\",\"InterleavedBufferAttribute\",\"getWithKey\",\"get\"]\n}\n"]