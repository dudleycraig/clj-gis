["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/misc/ConvexObjectBreaker.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$misc$ConvexObjectBreaker=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ConvexObjectBreaker=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_ConvexGeometry=require(\"module$node_modules$three_stdlib$geometries$ConvexGeometry\"),ConvexObjectBreaker=function(minSizeForBreak,smallDelta){this.minSizeForBreak=minSizeForBreak||1.4;this.smallDelta=smallDelta||1E-4;this.tempLine1=\nnew _three.Line3;this.tempPlane1=new _three.Plane;this.tempPlane2=new _three.Plane;this.tempPlane_Cut=new _three.Plane;this.tempCM1=new _three.Vector3;this.tempCM2=new _three.Vector3;this.tempVector3=new _three.Vector3;this.tempVector3_2=new _three.Vector3;this.tempVector3_3=new _three.Vector3;this.tempVector3_P0=new _three.Vector3;this.tempVector3_P1=new _three.Vector3;this.tempVector3_P2=new _three.Vector3;this.tempVector3_N0=new _three.Vector3;this.tempVector3_N1=new _three.Vector3;this.tempVector3_AB=\nnew _three.Vector3;this.tempVector3_CB=new _three.Vector3;this.tempResultObjects={object1:null,object2:null};this.segments=[];for(minSizeForBreak=0;900>minSizeForBreak;minSizeForBreak++)this.segments[minSizeForBreak]=!1};exports.ConvexObjectBreaker=ConvexObjectBreaker;ConvexObjectBreaker.prototype={constructor:ConvexObjectBreaker,prepareBreakableObject:function(object,mass,velocity,angularVelocity,breakable){object.geometry.isBufferGeometry||console.error(\"THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.\");\nobject=object.userData;object.mass=mass;object.velocity=velocity.clone();object.angularVelocity=angularVelocity.clone();object.breakable=breakable},subdivideByImpact:function(object,pointOfImpact,normal,maxRadialIterations,maxRandomIterations){function subdivideRadial(subObject,startAngle,endAngle,numIterations){if(Math.random()<.05*numIterations||numIterations>maxTotalIterations)debris.push(subObject);else{var angle=Math.PI;0===numIterations?(tempPlane2.normal.copy(tempPlane1.normal),tempPlane2.constant=\ntempPlane1.constant):numIterations<=maxRadialIterations?(angle=(endAngle-startAngle)*(.2+.6*Math.random())+startAngle,scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal,angle).add(pointOfImpact),tempPlane2.setFromCoplanarPoints(pointOfImpact,scope.tempVector3,scope.tempVector3_2)):(angle=(.5*(numIterations&1)+.2*(2-Math.random()))*Math.PI,scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal,angle).add(subObject.position),scope.tempVector3_3.copy(normal).add(subObject.position),\ntempPlane2.setFromCoplanarPoints(subObject.position,scope.tempVector3_3,scope.tempVector3_2));scope.cutByPlane(subObject,tempPlane2,scope.tempResultObjects);subObject=scope.tempResultObjects.object1;var obj2=scope.tempResultObjects.object2;subObject&&subdivideRadial(subObject,startAngle,angle,numIterations+1);obj2&&subdivideRadial(obj2,angle,endAngle,numIterations+1)}}var debris=[],tempPlane1=this.tempPlane1,tempPlane2=this.tempPlane2;this.tempVector3.addVectors(pointOfImpact,normal);tempPlane1.setFromCoplanarPoints(pointOfImpact,\nobject.position,this.tempVector3);var maxTotalIterations=maxRandomIterations+maxRadialIterations,scope=this;subdivideRadial(object,0,2*Math.PI,0);return debris},cutByPlane:function(object,plane,output){function getVertexIndex(faceIdx,vert){faceIdx=3*faceIdx+vert;return indices?indices[faceIdx]:faceIdx}var geometry=object.geometry,coords=geometry.attributes.position.array,normals=geometry.attributes.normal.array,numPoints=coords.length/3,numFaces=numPoints/3,indices=geometry.getIndex();indices&&(indices=\nindices.array,numFaces=indices.length/3);geometry=[];for(var points2=[],delta=this.smallDelta,numPointPairs=numPoints*numPoints,i=0;i<numPointPairs;i++)this.segments[i]=!1;numPointPairs=this.tempVector3_P0;i=this.tempVector3_P1;for(var n0=this.tempVector3_N0,n1=this.tempVector3_N1,_i=0;_i<numFaces-1;_i++){var a1=getVertexIndex(_i,0),b1=getVertexIndex(_i,1),c1=getVertexIndex(_i,2);n0.set(normals[a1],normals[a1]+1,normals[a1]+2);for(var j=_i+1;j<numFaces;j++){var a2=getVertexIndex(j,0),b2=getVertexIndex(j,\n1),c2=getVertexIndex(j,2);n1.set(normals[a2],normals[a2]+1,normals[a2]+2);if(1-n0.dot(n1)<delta)if(a1===a2||a1===b2||a1===c2)b1===a2||b1===b2||b1===c2?(this.segments[a1*numPoints+b1]=!0,this.segments[b1*numPoints+a1]=!0):(this.segments[c1*numPoints+a1]=!0,this.segments[a1*numPoints+c1]=!0);else if(b1===a2||b1===b2||b1===c2)this.segments[c1*numPoints+b1]=!0,this.segments[b1*numPoints+c1]=!0}}normals=this.tempPlane_Cut;object.updateMatrix();ConvexObjectBreaker.transformPlaneToLocalSpace(plane,object.matrix,\nnormals);for(plane=0;plane<numFaces;plane++)for(n0=getVertexIndex(plane,0),n1=getVertexIndex(plane,1),_i=getVertexIndex(plane,2),a1=0;3>a1;a1++)if(b1=0===a1?n0:1===a1?n1:_i,c1=0===a1?n1:1===a1?_i:n0,!this.segments[b1*numPoints+c1]&&(this.segments[b1*numPoints+c1]=!0,this.segments[c1*numPoints+b1]=!0,numPointPairs.set(coords[3*b1],coords[3*b1+1],coords[3*b1+2]),i.set(coords[3*c1],coords[3*c1+1],coords[3*c1+2]),b1=0,c1=normals.distanceToPoint(numPointPairs),c1>delta?(b1=2,points2.push(numPointPairs.clone())):\nc1<-delta?(b1=1,geometry.push(numPointPairs.clone())):(b1=3,geometry.push(numPointPairs.clone()),points2.push(numPointPairs.clone())),c1=0,c1=normals.distanceToPoint(i),c1>delta?(c1=2,points2.push(i.clone())):c1<-delta?(c1=1,geometry.push(i.clone())):(c1=3,geometry.push(i.clone()),points2.push(i.clone())),1===b1&&2===c1||2===b1&&1===c1)){this.tempLine1.start.copy(numPointPairs);this.tempLine1.end.copy(i);b1=new _three.Vector3;b1=normals.intersectLine(this.tempLine1,b1);if(void 0===b1)return console.error(\"Internal error: segment does not intersect plane.\"),\noutput.segmentedObject1=null,output.segmentedObject2=null,0;geometry.push(b1);points2.push(b1.clone())}coords=.5*object.userData.mass;this.tempCM1.set(0,0,0);numPoints=0;numFaces=geometry.length;if(0<numFaces){for(delta=0;delta<numFaces;delta++)this.tempCM1.add(geometry[delta]);this.tempCM1.divideScalar(numFaces);for(delta=0;delta<numFaces;delta++)i=geometry[delta],i.sub(this.tempCM1),numPoints=Math.max(numPoints,i.x,i.y,i.z);this.tempCM1.add(object.position)}this.tempCM2.set(0,0,0);delta=0;numPointPairs=\npoints2.length;if(0<numPointPairs){for(i=0;i<numPointPairs;i++)this.tempCM2.add(points2[i]);this.tempCM2.divideScalar(numPointPairs);for(plane=0;plane<numPointPairs;plane++)i=points2[plane],i.sub(this.tempCM2),delta=Math.max(delta,i.x,i.y,i.z);this.tempCM2.add(object.position)}plane=i=null;normals=0;4<numFaces&&(i=new _three.Mesh(new _ConvexGeometry.ConvexGeometry(geometry),object.material),i.position.copy(this.tempCM1),i.quaternion.copy(object.quaternion),this.prepareBreakableObject(i,coords,object.userData.velocity,\nobject.userData.angularVelocity,2*numPoints>this.minSizeForBreak),normals++);4<numPointPairs&&(plane=new _three.Mesh(new _ConvexGeometry.ConvexGeometry(points2),object.material),plane.position.copy(this.tempCM2),plane.quaternion.copy(object.quaternion),this.prepareBreakableObject(plane,coords,object.userData.velocity,object.userData.angularVelocity,2*delta>this.minSizeForBreak),normals++);output.object1=i;output.object2=plane;return normals}};ConvexObjectBreaker.transformFreeVector=function(v,m){var x=\nv.x,y=v.y,z=v.z;m=m.elements;v.x=m[0]*x+m[4]*y+m[8]*z;v.y=m[1]*x+m[5]*y+m[9]*z;v.z=m[2]*x+m[6]*y+m[10]*z;return v};ConvexObjectBreaker.transformFreeVectorInverse=function(v,m){var x=v.x,y=v.y,z=v.z;m=m.elements;v.x=m[0]*x+m[1]*y+m[2]*z;v.y=m[4]*x+m[5]*y+m[6]*z;v.z=m[8]*x+m[9]*y+m[10]*z;return v};ConvexObjectBreaker.transformTiedVectorInverse=function(v,m){var x=v.x,y=v.y,z=v.z;m=m.elements;v.x=m[0]*x+m[1]*y+m[2]*z-m[12];v.y=m[4]*x+m[5]*y+m[6]*z-m[13];v.z=m[8]*x+m[9]*y+m[10]*z-m[14];return v};ConvexObjectBreaker.transformPlaneToLocalSpace=\nfunction(){var v1=new _three.Vector3;return function(plane,m,resultPlane){resultPlane.normal.copy(plane.normal);resultPlane.constant=plane.constant;plane=ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1),m);ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal,m);resultPlane.constant=-plane.dot(resultPlane.normal)}}()}","~:source","shadow$provide[\"module$node_modules$three_stdlib$misc$ConvexObjectBreaker\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConvexObjectBreaker = void 0;\n\nvar _three = require(\"three\");\n\nvar _ConvexGeometry = require(\"../geometries/ConvexGeometry.js\");\n\n/**\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Usage:\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n *\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\n *\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n *\n *  - Mesh object must have a BufferGeometry (not Geometry) and a Material\n *\n *  - Vertex normals must be planar (not smoothed)\n *\n *  - The geometry must be convex (this is not checked in the library). You can create convex\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\n *  can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @param {double} minSizeForBreak Min size a debris can have to break.\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\n *\n */\nvar ConvexObjectBreaker = function ConvexObjectBreaker(minSizeForBreak, smallDelta) {\n  this.minSizeForBreak = minSizeForBreak || 1.4;\n  this.smallDelta = smallDelta || 0.0001;\n  this.tempLine1 = new _three.Line3();\n  this.tempPlane1 = new _three.Plane();\n  this.tempPlane2 = new _three.Plane();\n  this.tempPlane_Cut = new _three.Plane();\n  this.tempCM1 = new _three.Vector3();\n  this.tempCM2 = new _three.Vector3();\n  this.tempVector3 = new _three.Vector3();\n  this.tempVector3_2 = new _three.Vector3();\n  this.tempVector3_3 = new _three.Vector3();\n  this.tempVector3_P0 = new _three.Vector3();\n  this.tempVector3_P1 = new _three.Vector3();\n  this.tempVector3_P2 = new _three.Vector3();\n  this.tempVector3_N0 = new _three.Vector3();\n  this.tempVector3_N1 = new _three.Vector3();\n  this.tempVector3_AB = new _three.Vector3();\n  this.tempVector3_CB = new _three.Vector3();\n  this.tempResultObjects = {\n    object1: null,\n    object2: null\n  };\n  this.segments = [];\n  var n = 30 * 30;\n\n  for (var i = 0; i < n; i++) {\n    this.segments[i] = false;\n  }\n};\n\nexports.ConvexObjectBreaker = ConvexObjectBreaker;\nConvexObjectBreaker.prototype = {\n  constructor: ConvexObjectBreaker,\n  prepareBreakableObject: function prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n    // object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\n    // Its material property is propagated to its children (sub-pieces)\n    // mass must be > 0\n    if (!object.geometry.isBufferGeometry) {\n      console.error('THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.');\n    }\n\n    var userData = object.userData;\n    userData.mass = mass;\n    userData.velocity = velocity.clone();\n    userData.angularVelocity = angularVelocity.clone();\n    userData.breakable = breakable;\n  },\n\n  /*\n   * @param {int} maxRadialIterations Iterations for radial cuts.\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n   *\n   * Returns the array of pieces\n   */\n  subdivideByImpact: function subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    var debris = [];\n    var tempPlane1 = this.tempPlane1;\n    var tempPlane2 = this.tempPlane2;\n    this.tempVector3.addVectors(pointOfImpact, normal);\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n    var maxTotalIterations = maxRandomIterations + maxRadialIterations;\n    var scope = this;\n\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject);\n        return;\n      }\n\n      var angle = Math.PI;\n\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal);\n        tempPlane2.constant = tempPlane1.constant;\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle; // Rotate tempPlane2 at impact point around normal axis and the angle\n\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI; // Rotate tempPlane2 at object position around normal axis and the angle\n\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n          scope.tempVector3_3.copy(normal).add(subObject.position);\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n        }\n      } // Perform the cut\n\n\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n      var obj1 = scope.tempResultObjects.object1;\n      var obj2 = scope.tempResultObjects.object2;\n\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n      }\n\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n      }\n    }\n\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\n    return debris;\n  },\n  cutByPlane: function cutByPlane(object, plane, output) {\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n    // object2 can be null if the plane doesn't cut the object.\n    // object1 can be null only in case of internal error\n    // Returned value is number of pieces, 0 for error.\n    var geometry = object.geometry;\n    var coords = geometry.attributes.position.array;\n    var normals = geometry.attributes.normal.array;\n    var numPoints = coords.length / 3;\n    var numFaces = numPoints / 3;\n    var indices = geometry.getIndex();\n\n    if (indices) {\n      indices = indices.array;\n      numFaces = indices.length / 3;\n    }\n\n    function getVertexIndex(faceIdx, vert) {\n      // vert = 0, 1 or 2.\n      var idx = faceIdx * 3 + vert;\n      return indices ? indices[idx] : idx;\n    }\n\n    var points1 = [];\n    var points2 = [];\n    var delta = this.smallDelta; // Reset segments mark\n\n    var numPointPairs = numPoints * numPoints;\n\n    for (var i = 0; i < numPointPairs; i++) {\n      this.segments[i] = false;\n    }\n\n    var p0 = this.tempVector3_P0;\n    var p1 = this.tempVector3_P1;\n    var n0 = this.tempVector3_N0;\n    var n1 = this.tempVector3_N1; // Iterate through the faces to mark edges shared by coplanar faces\n\n    for (var _i = 0; _i < numFaces - 1; _i++) {\n      var a1 = getVertexIndex(_i, 0);\n      var b1 = getVertexIndex(_i, 1);\n      var c1 = getVertexIndex(_i, 2); // Assuming all 3 vertices have the same normal\n\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n\n      for (var j = _i + 1; j < numFaces; j++) {\n        var a2 = getVertexIndex(j, 0);\n        var b2 = getVertexIndex(j, 1);\n        var c2 = getVertexIndex(j, 2); // Assuming all 3 vertices have the same normal\n\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n        var coplanar = 1 - n0.dot(n1) < delta;\n\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + a1] = true;\n            } else {\n              this.segments[c1 * numPoints + a1] = true;\n              this.segments[a1 * numPoints + c1] = true;\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true;\n            this.segments[b1 * numPoints + c1] = true;\n          }\n        }\n      }\n    } // Transform the plane to object local space\n\n\n    var localPlane = this.tempPlane_Cut;\n    object.updateMatrix();\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane); // Iterate through the faces adding points to both pieces\n\n    for (var _i2 = 0; _i2 < numFaces; _i2++) {\n      var va = getVertexIndex(_i2, 0);\n      var vb = getVertexIndex(_i2, 1);\n      var vc = getVertexIndex(_i2, 2);\n\n      for (var segment = 0; segment < 3; segment++) {\n        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n        var segmentState = this.segments[i0 * numPoints + i1];\n        if (segmentState) continue; // The segment already has been processed in another face\n        // Mark segment as processed (also inverted segment)\n\n        this.segments[i0 * numPoints + i1] = true;\n        this.segments[i1 * numPoints + i0] = true;\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]); // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\n        var mark0 = 0;\n        var d = localPlane.distanceToPoint(p0);\n\n        if (d > delta) {\n          mark0 = 2;\n          points2.push(p0.clone());\n        } else if (d < -delta) {\n          mark0 = 1;\n          points1.push(p0.clone());\n        } else {\n          mark0 = 3;\n          points1.push(p0.clone());\n          points2.push(p0.clone());\n        } // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\n\n        var mark1 = 0;\n        var d = localPlane.distanceToPoint(p1);\n\n        if (d > delta) {\n          mark1 = 2;\n          points2.push(p1.clone());\n        } else if (d < -delta) {\n          mark1 = 1;\n          points1.push(p1.clone());\n        } else {\n          mark1 = 3;\n          points1.push(p1.clone());\n          points2.push(p1.clone());\n        }\n\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n          // Intersection of segment with the plane\n          this.tempLine1.start.copy(p0);\n          this.tempLine1.end.copy(p1);\n          var intersection = new _three.Vector3();\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\n\n          if (intersection === undefined) {\n            // Shouldn't happen\n            console.error('Internal error: segment does not intersect plane.');\n            output.segmentedObject1 = null;\n            output.segmentedObject2 = null;\n            return 0;\n          }\n\n          points1.push(intersection);\n          points2.push(intersection.clone());\n        }\n      }\n    } // Calculate debris mass (very fast and imprecise):\n\n\n    var newMass = object.userData.mass * 0.5; // Calculate debris Center of Mass (again fast and imprecise)\n\n    this.tempCM1.set(0, 0, 0);\n    var radius1 = 0;\n    var numPoints1 = points1.length;\n\n    if (numPoints1 > 0) {\n      for (var _i3 = 0; _i3 < numPoints1; _i3++) {\n        this.tempCM1.add(points1[_i3]);\n      }\n\n      this.tempCM1.divideScalar(numPoints1);\n\n      for (var _i4 = 0; _i4 < numPoints1; _i4++) {\n        var p = points1[_i4];\n        p.sub(this.tempCM1);\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\n      }\n\n      this.tempCM1.add(object.position);\n    }\n\n    this.tempCM2.set(0, 0, 0);\n    var radius2 = 0;\n    var numPoints2 = points2.length;\n\n    if (numPoints2 > 0) {\n      for (var _i5 = 0; _i5 < numPoints2; _i5++) {\n        this.tempCM2.add(points2[_i5]);\n      }\n\n      this.tempCM2.divideScalar(numPoints2);\n\n      for (var _i6 = 0; _i6 < numPoints2; _i6++) {\n        var p = points2[_i6];\n        p.sub(this.tempCM2);\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\n      }\n\n      this.tempCM2.add(object.position);\n    }\n\n    var object1 = null;\n    var object2 = null;\n    var numObjects = 0;\n\n    if (numPoints1 > 4) {\n      object1 = new _three.Mesh(new _ConvexGeometry.ConvexGeometry(points1), object.material);\n      object1.position.copy(this.tempCM1);\n      object1.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n      numObjects++;\n    }\n\n    if (numPoints2 > 4) {\n      object2 = new _three.Mesh(new _ConvexGeometry.ConvexGeometry(points2), object.material);\n      object2.position.copy(this.tempCM2);\n      object2.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n      numObjects++;\n    }\n\n    output.object1 = object1;\n    output.object2 = object2;\n    return numObjects;\n  }\n};\n\nConvexObjectBreaker.transformFreeVector = function (v, m) {\n  // input:\n  // vector interpreted as a free vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[4] * y + e[8] * z;\n  v.y = e[1] * x + e[5] * y + e[9] * z;\n  v.z = e[2] * x + e[6] * y + e[10] * z;\n  return v;\n};\n\nConvexObjectBreaker.transformFreeVectorInverse = function (v, m) {\n  // input:\n  // vector interpreted as a free vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[1] * y + e[2] * z;\n  v.y = e[4] * x + e[5] * y + e[6] * z;\n  v.z = e[8] * x + e[9] * y + e[10] * z;\n  return v;\n};\n\nConvexObjectBreaker.transformTiedVectorInverse = function (v, m) {\n  // input:\n  // vector interpreted as a tied (ordinary) vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n  return v;\n};\n\nConvexObjectBreaker.transformPlaneToLocalSpace = function () {\n  var v1 = new _three.Vector3();\n  return function transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal);\n    resultPlane.constant = plane.constant;\n    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1), m);\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m); // recalculate constant (like in setFromNormalAndCoplanarPoint)\n\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n  };\n}();\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_stdlib$geometries$ConvexGeometry","~$shadow.js"]],"~:properties",["^5",["z","segmentedObject1","transformTiedVectorInverse","tempVector3","tempVector3_P1","prototype","angularVelocity","constant","tempVector3_CB","tempVector3_N1","tempLine1","smallDelta","object1","x","__esModule","segmentedObject2","tempVector3_P2","tempVector3_2","tempPlane1","breakable","value","tempResultObjects","transformPlaneToLocalSpace","prepareBreakableObject","tempVector3_N0","segments","tempPlane2","tempPlane_Cut","y","transformFreeVector","tempVector3_3","minSizeForBreak","mass","object2","tempVector3_P0","transformFreeVectorInverse","ConvexObjectBreaker","tempCM2","cutByPlane","velocity","constructor","tempCM1","subdivideByImpact","tempVector3_AB"]],"~:compiled-at",1630917515104,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$misc$ConvexObjectBreaker.js\",\n\"lineCount\":16,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/misc/ConvexObjectBreaker.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$misc$ConvexObjectBreaker\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ConvexObjectBreaker = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _ConvexGeometry = require(\\\"../geometries/ConvexGeometry.js\\\");\\n\\n/**\\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\\n *\\n * Usage:\\n *\\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\\n *\\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\\n *\\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\\n *\\n * Requisites for the object:\\n *\\n *  - Mesh object must have a BufferGeometry (not Geometry) and a Material\\n *\\n *  - Vertex normals must be planar (not smoothed)\\n *\\n *  - The geometry must be convex (this is not checked in the library). You can create convex\\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\\n *  can also be used.\\n *\\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\\n * Use with caution and read the code when using with other libs.\\n *\\n * @param {double} minSizeForBreak Min size a debris can have to break.\\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\\n *\\n */\\nvar ConvexObjectBreaker = function ConvexObjectBreaker(minSizeForBreak, smallDelta) {\\n  this.minSizeForBreak = minSizeForBreak || 1.4;\\n  this.smallDelta = smallDelta || 0.0001;\\n  this.tempLine1 = new _three.Line3();\\n  this.tempPlane1 = new _three.Plane();\\n  this.tempPlane2 = new _three.Plane();\\n  this.tempPlane_Cut = new _three.Plane();\\n  this.tempCM1 = new _three.Vector3();\\n  this.tempCM2 = new _three.Vector3();\\n  this.tempVector3 = new _three.Vector3();\\n  this.tempVector3_2 = new _three.Vector3();\\n  this.tempVector3_3 = new _three.Vector3();\\n  this.tempVector3_P0 = new _three.Vector3();\\n  this.tempVector3_P1 = new _three.Vector3();\\n  this.tempVector3_P2 = new _three.Vector3();\\n  this.tempVector3_N0 = new _three.Vector3();\\n  this.tempVector3_N1 = new _three.Vector3();\\n  this.tempVector3_AB = new _three.Vector3();\\n  this.tempVector3_CB = new _three.Vector3();\\n  this.tempResultObjects = {\\n    object1: null,\\n    object2: null\\n  };\\n  this.segments = [];\\n  var n = 30 * 30;\\n\\n  for (var i = 0; i < n; i++) {\\n    this.segments[i] = false;\\n  }\\n};\\n\\nexports.ConvexObjectBreaker = ConvexObjectBreaker;\\nConvexObjectBreaker.prototype = {\\n  constructor: ConvexObjectBreaker,\\n  prepareBreakableObject: function prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\\n    // object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\\n    // Its material property is propagated to its children (sub-pieces)\\n    // mass must be > 0\\n    if (!object.geometry.isBufferGeometry) {\\n      console.error('THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.');\\n    }\\n\\n    var userData = object.userData;\\n    userData.mass = mass;\\n    userData.velocity = velocity.clone();\\n    userData.angularVelocity = angularVelocity.clone();\\n    userData.breakable = breakable;\\n  },\\n\\n  /*\\n   * @param {int} maxRadialIterations Iterations for radial cuts.\\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\\n   *\\n   * Returns the array of pieces\\n   */\\n  subdivideByImpact: function subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\\n    var debris = [];\\n    var tempPlane1 = this.tempPlane1;\\n    var tempPlane2 = this.tempPlane2;\\n    this.tempVector3.addVectors(pointOfImpact, normal);\\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\\n    var maxTotalIterations = maxRandomIterations + maxRadialIterations;\\n    var scope = this;\\n\\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\\n        debris.push(subObject);\\n        return;\\n      }\\n\\n      var angle = Math.PI;\\n\\n      if (numIterations === 0) {\\n        tempPlane2.normal.copy(tempPlane1.normal);\\n        tempPlane2.constant = tempPlane1.constant;\\n      } else {\\n        if (numIterations <= maxRadialIterations) {\\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle; // Rotate tempPlane2 at impact point around normal axis and the angle\\n\\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\\n        } else {\\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI; // Rotate tempPlane2 at object position around normal axis and the angle\\n\\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\\n          scope.tempVector3_3.copy(normal).add(subObject.position);\\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\\n        }\\n      } // Perform the cut\\n\\n\\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\\n      var obj1 = scope.tempResultObjects.object1;\\n      var obj2 = scope.tempResultObjects.object2;\\n\\n      if (obj1) {\\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\\n      }\\n\\n      if (obj2) {\\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\\n      }\\n    }\\n\\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\\n    return debris;\\n  },\\n  cutByPlane: function cutByPlane(object, plane, output) {\\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\\n    // object2 can be null if the plane doesn't cut the object.\\n    // object1 can be null only in case of internal error\\n    // Returned value is number of pieces, 0 for error.\\n    var geometry = object.geometry;\\n    var coords = geometry.attributes.position.array;\\n    var normals = geometry.attributes.normal.array;\\n    var numPoints = coords.length / 3;\\n    var numFaces = numPoints / 3;\\n    var indices = geometry.getIndex();\\n\\n    if (indices) {\\n      indices = indices.array;\\n      numFaces = indices.length / 3;\\n    }\\n\\n    function getVertexIndex(faceIdx, vert) {\\n      // vert = 0, 1 or 2.\\n      var idx = faceIdx * 3 + vert;\\n      return indices ? indices[idx] : idx;\\n    }\\n\\n    var points1 = [];\\n    var points2 = [];\\n    var delta = this.smallDelta; // Reset segments mark\\n\\n    var numPointPairs = numPoints * numPoints;\\n\\n    for (var i = 0; i < numPointPairs; i++) {\\n      this.segments[i] = false;\\n    }\\n\\n    var p0 = this.tempVector3_P0;\\n    var p1 = this.tempVector3_P1;\\n    var n0 = this.tempVector3_N0;\\n    var n1 = this.tempVector3_N1; // Iterate through the faces to mark edges shared by coplanar faces\\n\\n    for (var _i = 0; _i < numFaces - 1; _i++) {\\n      var a1 = getVertexIndex(_i, 0);\\n      var b1 = getVertexIndex(_i, 1);\\n      var c1 = getVertexIndex(_i, 2); // Assuming all 3 vertices have the same normal\\n\\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\\n\\n      for (var j = _i + 1; j < numFaces; j++) {\\n        var a2 = getVertexIndex(j, 0);\\n        var b2 = getVertexIndex(j, 1);\\n        var c2 = getVertexIndex(j, 2); // Assuming all 3 vertices have the same normal\\n\\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\\n        var coplanar = 1 - n0.dot(n1) < delta;\\n\\n        if (coplanar) {\\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\\n              this.segments[a1 * numPoints + b1] = true;\\n              this.segments[b1 * numPoints + a1] = true;\\n            } else {\\n              this.segments[c1 * numPoints + a1] = true;\\n              this.segments[a1 * numPoints + c1] = true;\\n            }\\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\\n            this.segments[c1 * numPoints + b1] = true;\\n            this.segments[b1 * numPoints + c1] = true;\\n          }\\n        }\\n      }\\n    } // Transform the plane to object local space\\n\\n\\n    var localPlane = this.tempPlane_Cut;\\n    object.updateMatrix();\\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane); // Iterate through the faces adding points to both pieces\\n\\n    for (var _i2 = 0; _i2 < numFaces; _i2++) {\\n      var va = getVertexIndex(_i2, 0);\\n      var vb = getVertexIndex(_i2, 1);\\n      var vc = getVertexIndex(_i2, 2);\\n\\n      for (var segment = 0; segment < 3; segment++) {\\n        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\\n        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\\n        var segmentState = this.segments[i0 * numPoints + i1];\\n        if (segmentState) continue; // The segment already has been processed in another face\\n        // Mark segment as processed (also inverted segment)\\n\\n        this.segments[i0 * numPoints + i1] = true;\\n        this.segments[i1 * numPoints + i0] = true;\\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]); // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\\n\\n        var mark0 = 0;\\n        var d = localPlane.distanceToPoint(p0);\\n\\n        if (d > delta) {\\n          mark0 = 2;\\n          points2.push(p0.clone());\\n        } else if (d < -delta) {\\n          mark0 = 1;\\n          points1.push(p0.clone());\\n        } else {\\n          mark0 = 3;\\n          points1.push(p0.clone());\\n          points2.push(p0.clone());\\n        } // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\\n\\n\\n        var mark1 = 0;\\n        var d = localPlane.distanceToPoint(p1);\\n\\n        if (d > delta) {\\n          mark1 = 2;\\n          points2.push(p1.clone());\\n        } else if (d < -delta) {\\n          mark1 = 1;\\n          points1.push(p1.clone());\\n        } else {\\n          mark1 = 3;\\n          points1.push(p1.clone());\\n          points2.push(p1.clone());\\n        }\\n\\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\\n          // Intersection of segment with the plane\\n          this.tempLine1.start.copy(p0);\\n          this.tempLine1.end.copy(p1);\\n          var intersection = new _three.Vector3();\\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\\n\\n          if (intersection === undefined) {\\n            // Shouldn't happen\\n            console.error('Internal error: segment does not intersect plane.');\\n            output.segmentedObject1 = null;\\n            output.segmentedObject2 = null;\\n            return 0;\\n          }\\n\\n          points1.push(intersection);\\n          points2.push(intersection.clone());\\n        }\\n      }\\n    } // Calculate debris mass (very fast and imprecise):\\n\\n\\n    var newMass = object.userData.mass * 0.5; // Calculate debris Center of Mass (again fast and imprecise)\\n\\n    this.tempCM1.set(0, 0, 0);\\n    var radius1 = 0;\\n    var numPoints1 = points1.length;\\n\\n    if (numPoints1 > 0) {\\n      for (var _i3 = 0; _i3 < numPoints1; _i3++) {\\n        this.tempCM1.add(points1[_i3]);\\n      }\\n\\n      this.tempCM1.divideScalar(numPoints1);\\n\\n      for (var _i4 = 0; _i4 < numPoints1; _i4++) {\\n        var p = points1[_i4];\\n        p.sub(this.tempCM1);\\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\\n      }\\n\\n      this.tempCM1.add(object.position);\\n    }\\n\\n    this.tempCM2.set(0, 0, 0);\\n    var radius2 = 0;\\n    var numPoints2 = points2.length;\\n\\n    if (numPoints2 > 0) {\\n      for (var _i5 = 0; _i5 < numPoints2; _i5++) {\\n        this.tempCM2.add(points2[_i5]);\\n      }\\n\\n      this.tempCM2.divideScalar(numPoints2);\\n\\n      for (var _i6 = 0; _i6 < numPoints2; _i6++) {\\n        var p = points2[_i6];\\n        p.sub(this.tempCM2);\\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\\n      }\\n\\n      this.tempCM2.add(object.position);\\n    }\\n\\n    var object1 = null;\\n    var object2 = null;\\n    var numObjects = 0;\\n\\n    if (numPoints1 > 4) {\\n      object1 = new _three.Mesh(new _ConvexGeometry.ConvexGeometry(points1), object.material);\\n      object1.position.copy(this.tempCM1);\\n      object1.quaternion.copy(object.quaternion);\\n      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\\n      numObjects++;\\n    }\\n\\n    if (numPoints2 > 4) {\\n      object2 = new _three.Mesh(new _ConvexGeometry.ConvexGeometry(points2), object.material);\\n      object2.position.copy(this.tempCM2);\\n      object2.quaternion.copy(object.quaternion);\\n      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\\n      numObjects++;\\n    }\\n\\n    output.object1 = object1;\\n    output.object2 = object2;\\n    return numObjects;\\n  }\\n};\\n\\nConvexObjectBreaker.transformFreeVector = function (v, m) {\\n  // input:\\n  // vector interpreted as a free vector\\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\\n  var x = v.x,\\n      y = v.y,\\n      z = v.z;\\n  var e = m.elements;\\n  v.x = e[0] * x + e[4] * y + e[8] * z;\\n  v.y = e[1] * x + e[5] * y + e[9] * z;\\n  v.z = e[2] * x + e[6] * y + e[10] * z;\\n  return v;\\n};\\n\\nConvexObjectBreaker.transformFreeVectorInverse = function (v, m) {\\n  // input:\\n  // vector interpreted as a free vector\\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\\n  var x = v.x,\\n      y = v.y,\\n      z = v.z;\\n  var e = m.elements;\\n  v.x = e[0] * x + e[1] * y + e[2] * z;\\n  v.y = e[4] * x + e[5] * y + e[6] * z;\\n  v.z = e[8] * x + e[9] * y + e[10] * z;\\n  return v;\\n};\\n\\nConvexObjectBreaker.transformTiedVectorInverse = function (v, m) {\\n  // input:\\n  // vector interpreted as a tied (ordinary) vector\\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\\n  var x = v.x,\\n      y = v.y,\\n      z = v.z;\\n  var e = m.elements;\\n  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\\n  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\\n  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\\n  return v;\\n};\\n\\nConvexObjectBreaker.transformPlaneToLocalSpace = function () {\\n  var v1 = new _three.Vector3();\\n  return function transformPlaneToLocalSpace(plane, m, resultPlane) {\\n    resultPlane.normal.copy(plane.normal);\\n    resultPlane.constant = plane.constant;\\n    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1), m);\\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m); // recalculate constant (like in setFromNormalAndCoplanarPoint)\\n\\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\\n  };\\n}();\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"ConvexObjectBreaker\",\"_three\",\"_ConvexGeometry\",\"minSizeForBreak\",\"smallDelta\",\"tempLine1\",\"Line3\",\"tempPlane1\",\"Plane\",\"tempPlane2\",\"tempPlane_Cut\",\"tempCM1\",\"Vector3\",\"tempCM2\",\"tempVector3\",\"tempVector3_2\",\"tempVector3_3\",\"tempVector3_P0\",\"tempVector3_P1\",\"tempVector3_P2\",\"tempVector3_N0\",\"tempVector3_N1\",\"tempVector3_AB\",\"tempVector3_CB\",\"tempResultObjects\",\"object1\",\"object2\",\"segments\",\"i\",\"n\",\"prototype\",\"constructor\",\"prepareBreakableObject\",\"object\",\"mass\",\"velocity\",\"angularVelocity\",\"breakable\",\"geometry\",\"isBufferGeometry\",\"console\",\"error\",\"userData\",\"clone\",\"subdivideByImpact\",\"pointOfImpact\",\"normal\",\"maxRadialIterations\",\"maxRandomIterations\",\"subdivideRadial\",\"subObject\",\"startAngle\",\"endAngle\",\"numIterations\",\"Math\",\"random\",\"maxTotalIterations\",\"debris\",\"push\",\"angle\",\"PI\",\"copy\",\"constant\",\"scope\",\"position\",\"sub\",\"applyAxisAngle\",\"add\",\"setFromCoplanarPoints\",\"cutByPlane\",\"obj1\",\"obj2\",\"addVectors\",\"plane\",\"output\",\"getVertexIndex\",\"faceIdx\",\"vert\",\"idx\",\"indices\",\"coords\",\"attributes\",\"array\",\"normals\",\"numPoints\",\"length\",\"numFaces\",\"getIndex\",\"points1\",\"points2\",\"delta\",\"numPointPairs\",\"p0\",\"p1\",\"n0\",\"n1\",\"_i\",\"a1\",\"b1\",\"c1\",\"set\",\"j\",\"a2\",\"b2\",\"c2\",\"dot\",\"localPlane\",\"updateMatrix\",\"transformPlaneToLocalSpace\",\"matrix\",\"_i2\",\"va\",\"segment\",\"vb\",\"vc\",\"i0\",\"segmentState\",\"i1\",\"mark0\",\"d\",\"distanceToPoint\",\"mark1\",\"start\",\"end\",\"intersection\",\"intersectLine\",\"undefined\",\"segmentedObject1\",\"segmentedObject2\",\"newMass\",\"radius1\",\"numPoints1\",\"_i3\",\"divideScalar\",\"_i4\",\"p\",\"max\",\"x\",\"y\",\"z\",\"radius2\",\"numPoints2\",\"_i5\",\"_i6\",\"numObjects\",\"Mesh\",\"ConvexGeometry\",\"material\",\"quaternion\",\"transformFreeVector\",\"ConvexObjectBreaker.transformFreeVector\",\"v\",\"m\",\"e\",\"elements\",\"transformFreeVectorInverse\",\"ConvexObjectBreaker.transformFreeVectorInverse\",\"transformTiedVectorInverse\",\"ConvexObjectBreaker.transformTiedVectorInverse\",\"v1\",\"resultPlane\",\"referencePoint\",\"coplanarPoint\"]\n}\n"]