["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/nodes/materials/nodes/BasicNode.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$nodes$materials$nodes$BasicNode=function(global,require,module,exports){function BasicNode(){_Node.Node.call(this);this.color=new _ColorNode.ColorNode(16777215)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.BasicNode=BasicNode;var _Node=require(\"module$node_modules$three_stdlib$nodes$core$Node\"),_ColorNode=require(\"module$node_modules$three_stdlib$nodes$inputs$ColorNode\");BasicNode.prototype=Object.create(_Node.Node.prototype);BasicNode.prototype.constructor=\nBasicNode;BasicNode.prototype.nodeType=\"Basic\";BasicNode.prototype.generate=function(builder){if(builder.isShader(\"vertex\")){var position=this.position?this.position.analyzeAndFlow(builder,\"v3\",{cache:\"position\"}):void 0;builder.addParsCode(\"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n varying vec3 vNormal;\\n#endif\");builder=\"#include \\x3cbeginnormal_vertex\\x3e,#include \\x3cdefaultnormal_vertex\\x3e,#ifndef FLAT_SHADED, vNormal \\x3d normalize( transformedNormal );,#endif,#include \\x3cbegin_vertex\\x3e\".split(\",\");\nposition&&builder.push(position.code,position.result?\"transformed \\x3d \"+position.result+\";\":\"\");builder.push(\"#include \\x3cmorphtarget_vertex\\x3e\",\"#include \\x3cskinning_vertex\\x3e\",\"#include \\x3cproject_vertex\\x3e\",\"#include \\x3cfog_vertex\\x3e\",\"#include \\x3clogdepthbuf_vertex\\x3e\",\"#include \\x3cclipping_planes_vertex\\x3e\",\"\\tvViewPosition \\x3d - mvPosition.xyz;\",\"#include \\x3cworldpos_vertex\\x3e\",\"#include \\x3cshadowmap_vertex\\x3e\")}else{this.color.analyze(builder,{slot:\"color\"});this.alpha&&this.alpha.analyze(builder);\nthis.mask&&this.mask.analyze(builder);position=this.color.flow(builder,\"c\",{slot:\"color\"});var alpha=this.alpha?this.alpha.flow(builder,\"f\"):void 0,mask=this.mask?this.mask.flow(builder,\"b\"):void 0;builder.requires.transparent=void 0!==alpha;builder.addParsCode(\"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n varying vec3 vNormal;\\n#endif\");builder=[\"#include \\x3cnormal_fragment_begin\\x3e\",position.code];mask&&builder.push(mask.code,\"if ( ! \"+mask.result+\" ) discard;\");alpha&&builder.push(alpha.code,\n\"#ifdef ALPHATEST\",\" if ( \"+alpha.result+\" \\x3c\\x3d ALPHATEST ) discard;\",\"#endif\");alpha?builder.push(\"gl_FragColor \\x3d vec4(\"+position.result+\", \"+alpha.result+\" );\"):builder.push(\"gl_FragColor \\x3d vec4(\"+position.result+\", 1.0 );\")}return builder.join(\"\\n\")};BasicNode.prototype.copy=function(source){_Node.Node.prototype.copy.call(this,source);this.color=source.color;source.position&&(this.position=source.position);source.alpha&&(this.alpha=source.alpha);source.mask&&(this.mask=source.mask);return this};\nBasicNode.prototype.toJSON=function(meta){var data=this.getJSONNode(meta);data||(data=this.createJSONNode(meta),data.color=this.color.toJSON(meta).uuid,this.position&&(data.position=this.position.toJSON(meta).uuid),this.alpha&&(data.alpha=this.alpha.toJSON(meta).uuid),this.mask&&(data.mask=this.mask.toJSON(meta).uuid));return data}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$nodes$materials$nodes$BasicNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BasicNode = BasicNode;\n\nvar _Node = require(\"../../core/Node.js\");\n\nvar _ColorNode = require(\"../../inputs/ColorNode.js\");\n\nfunction BasicNode() {\n  _Node.Node.call(this);\n\n  this.color = new _ColorNode.ColorNode(0xffffff);\n}\n\nBasicNode.prototype = Object.create(_Node.Node.prototype);\nBasicNode.prototype.constructor = BasicNode;\nBasicNode.prototype.nodeType = 'Basic';\n\nBasicNode.prototype.generate = function (builder) {\n  var code;\n\n  if (builder.isShader('vertex')) {\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\n      cache: 'position'\n    }) : undefined;\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', ' varying vec3 vNormal;', '#endif'].join('\\n'));\n    var output = ['#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED', // Normal computed with derivatives when FLAT_SHADED\n    ' vNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\n\n    if (position) {\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n    }\n\n    output.push('#include <morphtarget_vertex>', '#include <skinning_vertex>', '#include <project_vertex>', '#include <fog_vertex>', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '\tvViewPosition = - mvPosition.xyz;', '#include <worldpos_vertex>', '#include <shadowmap_vertex>');\n    code = output.join('\\n');\n  } else {\n    // Analyze all nodes to reuse generate codes\n    this.color.analyze(builder, {\n      slot: 'color'\n    });\n    if (this.alpha) this.alpha.analyze(builder);\n    if (this.mask) this.mask.analyze(builder); // Build code\n\n    var color = this.color.flow(builder, 'c', {\n      slot: 'color'\n    });\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\n    builder.requires.transparent = alpha !== undefined;\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', ' varying vec3 vNormal;', '#endif'].join('\\n'));\n    var output = [// add before: prevent undeclared normal\n    '#include <normal_fragment_begin>', color.code];\n\n    if (mask) {\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n    }\n\n    if (alpha) {\n      output.push(alpha.code, '#ifdef ALPHATEST', ' if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\n    }\n\n    if (alpha) {\n      output.push('gl_FragColor = vec4(' + color.result + ', ' + alpha.result + ' );');\n    } else {\n      output.push('gl_FragColor = vec4(' + color.result + ', 1.0 );');\n    }\n\n    code = output.join('\\n');\n  }\n\n  return code;\n};\n\nBasicNode.prototype.copy = function (source) {\n  _Node.Node.prototype.copy.call(this, source);\n\n  this.color = source.color;\n  if (source.position) this.position = source.position;\n  if (source.alpha) this.alpha = source.alpha;\n  if (source.mask) this.mask = source.mask;\n  return this;\n};\n\nBasicNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.color = this.color.toJSON(meta).uuid;\n    if (this.position) data.position = this.position.toJSON(meta).uuid;\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\n  }\n\n  return data;\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$three_stdlib$nodes$inputs$ColorNode","~$module$node_modules$three_stdlib$nodes$core$Node"]],"~:properties",["^5",["BasicNode","copy","prototype","transparent","slot","__esModule","generate","cache","position","nodeType","value","alpha","color","mask","constructor","toJSON"]],"~:compiled-at",1630917515244,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$nodes$materials$nodes$BasicNode.js\",\n\"lineCount\":6,\n\"mappings\":\"AAAAA,cAAA,CAAA,gEAAA,CAAqF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAY7HC,QAASA,UAAS,EAAG,CACnBC,KAAMC,CAAAA,IAAKC,CAAAA,IAAX,CAAgB,IAAhB,CAEA,KAAKC,CAAAA,KAAL,CAAa,IAAIC,UAAWC,CAAAA,SAAf,CAAyB,QAAzB,CAHM,CATrBC,MAAOC,CAAAA,cAAP,CAAsBT,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CU,MAAO,CAAA,CADoC,CAA7C,CAGAV,QAAQC,CAAAA,SAAR,CAAoBA,SAEpB,KAAIC,MAAQJ,OAAA,CAAQ,kDAAR,CAAZ,CAEIQ,WAAaR,OAAA,CAAQ,yDAAR,CAQjBG,UAAUU,CAAAA,SAAV,CAAsBH,MAAOI,CAAAA,MAAP,CAAcV,KAAMC,CAAAA,IAAKQ,CAAAA,SAAzB,CACtBV,UAAUU,CAAAA,SAAUE,CAAAA,WAApB;AAAkCZ,SAClCA,UAAUU,CAAAA,SAAUG,CAAAA,QAApB,CAA+B,OAE/Bb,UAAUU,CAAAA,SAAUI,CAAAA,QAApB,CAA+BC,QAAS,CAACC,OAAD,CAAU,CAGhD,GAAIA,OAAQC,CAAAA,QAAR,CAAiB,QAAjB,CAAJ,CAAgC,CAC9B,IAAIC,SAAW,IAAKA,CAAAA,QAAL,CAAgB,IAAKA,CAAAA,QAASC,CAAAA,cAAd,CAA6BH,OAA7B,CAAsC,IAAtC,CAA4C,CACzEI,MAAO,UADkE,CAA5C,CAAhB,CAEVC,IAAAA,EACLL,QAAQM,CAAAA,WAAR,CAAqG,kFAArG,CACIC,QAAAA,CAAS,kLAAA,CAAA,KAAA,CAAA,GAAA,CAGTL;QAAJ,EACEK,OAAOC,CAAAA,IAAP,CAAYN,QAASO,CAAAA,IAArB,CAA2BP,QAASQ,CAAAA,MAAT,CAAkB,mBAAlB,CAAqCR,QAASQ,CAAAA,MAA9C,CAAuD,GAAvD,CAA6D,EAAxF,CAGFH,QAAOC,CAAAA,IAAP,CAAY,qCAAZ,CAA6C,kCAA7C,CAA2E,iCAA3E,CAAwG,6BAAxG,CAAiI,qCAAjI,CAAkK,yCAAlK,CAAuM,wCAAvM,CAA6O,kCAA7O,CAA2Q,mCAA3Q,CAZ8B,CAAhC,IAcO,CAEL,IAAKpB,CAAAA,KAAMuB,CAAAA,OAAX,CAAmBX,OAAnB,CAA4B,CAC1BY,KAAM,OADoB,CAA5B,CAGI,KAAKC,CAAAA,KAAT,EAAgB,IAAKA,CAAAA,KAAMF,CAAAA,OAAX,CAAmBX,OAAnB,CACZ;IAAKc,CAAAA,IAAT,EAAe,IAAKA,CAAAA,IAAKH,CAAAA,OAAV,CAAkBX,OAAlB,CAEXZ,SAAAA,CAAQ,IAAKA,CAAAA,KAAM2B,CAAAA,IAAX,CAAgBf,OAAhB,CAAyB,GAAzB,CAA8B,CACxCY,KAAM,OADkC,CAA9B,CAGZ,KAAIC,MAAQ,IAAKA,CAAAA,KAAL,CAAa,IAAKA,CAAAA,KAAME,CAAAA,IAAX,CAAgBf,OAAhB,CAAyB,GAAzB,CAAb,CAA6CK,IAAAA,EAAzD,CACIS,KAAO,IAAKA,CAAAA,IAAL,CAAY,IAAKA,CAAAA,IAAKC,CAAAA,IAAV,CAAef,OAAf,CAAwB,GAAxB,CAAZ,CAA2CK,IAAAA,EACtDL,QAAQgB,CAAAA,QAASC,CAAAA,WAAjB,CAAyCZ,IAAAA,EAAzC,GAA+BQ,KAC/Bb,QAAQM,CAAAA,WAAR,CAAqG,kFAArG,CACIC,QAAJ,CAAa,CACb,wCADa,CACuBnB,QAAMqB,CAAAA,IAD7B,CAGTK,KAAJ,EACEP,OAAOC,CAAAA,IAAP,CAAYM,IAAKL,CAAAA,IAAjB,CAAuB,SAAvB,CAAmCK,IAAKJ,CAAAA,MAAxC,CAAiD,aAAjD,CAGEG,MAAJ,EACEN,OAAOC,CAAAA,IAAP,CAAYK,KAAMJ,CAAAA,IAAlB;AAAwB,kBAAxB,CAA4C,QAA5C,CAAuDI,KAAMH,CAAAA,MAA7D,CAAsE,gCAAtE,CAAkG,QAAlG,CAGEG,MAAJ,CACEN,OAAOC,CAAAA,IAAP,CAAY,yBAAZ,CAAqCpB,QAAMsB,CAAAA,MAA3C,CAAoD,IAApD,CAA2DG,KAAMH,CAAAA,MAAjE,CAA0E,KAA1E,CADF,CAGEH,OAAOC,CAAAA,IAAP,CAAY,yBAAZ,CAAqCpB,QAAMsB,CAAAA,MAA3C,CAAoD,UAApD,CA7BG,CAmCP,MApCSH,QAAOW,CAAAA,IAAPT,CAAY,IAAZA,CAhBuC,CAuDlDzB,UAAUU,CAAAA,SAAUyB,CAAAA,IAApB,CAA2BC,QAAS,CAACC,MAAD,CAAS,CAC3CpC,KAAMC,CAAAA,IAAKQ,CAAAA,SAAUyB,CAAAA,IAAKhC,CAAAA,IAA1B,CAA+B,IAA/B,CAAqCkC,MAArC,CAEA,KAAKjC,CAAAA,KAAL,CAAaiC,MAAOjC,CAAAA,KAChBiC,OAAOnB,CAAAA,QAAX,GAAqB,IAAKA,CAAAA,QAA1B,CAAqCmB,MAAOnB,CAAAA,QAA5C,CACImB,OAAOR,CAAAA,KAAX,GAAkB,IAAKA,CAAAA,KAAvB,CAA+BQ,MAAOR,CAAAA,KAAtC,CACIQ,OAAOP,CAAAA,IAAX,GAAiB,IAAKA,CAAAA,IAAtB,CAA6BO,MAAOP,CAAAA,IAApC,CACA,OAAO,KAPoC,CAU7C9B;SAAUU,CAAAA,SAAU4B,CAAAA,MAApB,CAA6BC,QAAS,CAACC,IAAD,CAAO,CAC3C,IAAIC,KAAO,IAAKC,CAAAA,WAAL,CAAiBF,IAAjB,CAENC,KAAL,GACEA,IAIA,CAJO,IAAKE,CAAAA,cAAL,CAAoBH,IAApB,CAIP,CAHAC,IAAKrC,CAAAA,KAGL,CAHa,IAAKA,CAAAA,KAAMkC,CAAAA,MAAX,CAAkBE,IAAlB,CAAwBI,CAAAA,IAGrC,CAFI,IAAK1B,CAAAA,QAET,GAFmBuB,IAAKvB,CAAAA,QAExB,CAFmC,IAAKA,CAAAA,QAASoB,CAAAA,MAAd,CAAqBE,IAArB,CAA2BI,CAAAA,IAE9D,EADI,IAAKf,CAAAA,KACT,GADgBY,IAAKZ,CAAAA,KACrB,CAD6B,IAAKA,CAAAA,KAAMS,CAAAA,MAAX,CAAkBE,IAAlB,CAAwBI,CAAAA,IACrD,EAAI,IAAKd,CAAAA,IAAT,GAAeW,IAAKX,CAAAA,IAApB,CAA2B,IAAKA,CAAAA,IAAKQ,CAAAA,MAAV,CAAiBE,IAAjB,CAAuBI,CAAAA,IAAlD,CALF,CAQA,OAAOH,KAXoC,CAvFgF;\",\n\"sources\":[\"node_modules/three-stdlib/nodes/materials/nodes/BasicNode.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$nodes$materials$nodes$BasicNode\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.BasicNode = BasicNode;\\n\\nvar _Node = require(\\\"../../core/Node.js\\\");\\n\\nvar _ColorNode = require(\\\"../../inputs/ColorNode.js\\\");\\n\\nfunction BasicNode() {\\n  _Node.Node.call(this);\\n\\n  this.color = new _ColorNode.ColorNode(0xffffff);\\n}\\n\\nBasicNode.prototype = Object.create(_Node.Node.prototype);\\nBasicNode.prototype.constructor = BasicNode;\\nBasicNode.prototype.nodeType = 'Basic';\\n\\nBasicNode.prototype.generate = function (builder) {\\n  var code;\\n\\n  if (builder.isShader('vertex')) {\\n    var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', {\\n      cache: 'position'\\n    }) : undefined;\\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', ' varying vec3 vNormal;', '#endif'].join('\\\\n'));\\n    var output = ['#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#ifndef FLAT_SHADED', // Normal computed with derivatives when FLAT_SHADED\\n    ' vNormal = normalize( transformedNormal );', '#endif', '#include <begin_vertex>'];\\n\\n    if (position) {\\n      output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\\n    }\\n\\n    output.push('#include <morphtarget_vertex>', '#include <skinning_vertex>', '#include <project_vertex>', '#include <fog_vertex>', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '\\tvViewPosition = - mvPosition.xyz;', '#include <worldpos_vertex>', '#include <shadowmap_vertex>');\\n    code = output.join('\\\\n');\\n  } else {\\n    // Analyze all nodes to reuse generate codes\\n    this.color.analyze(builder, {\\n      slot: 'color'\\n    });\\n    if (this.alpha) this.alpha.analyze(builder);\\n    if (this.mask) this.mask.analyze(builder); // Build code\\n\\n    var color = this.color.flow(builder, 'c', {\\n      slot: 'color'\\n    });\\n    var alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined;\\n    var mask = this.mask ? this.mask.flow(builder, 'b') : undefined;\\n    builder.requires.transparent = alpha !== undefined;\\n    builder.addParsCode(['varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', ' varying vec3 vNormal;', '#endif'].join('\\\\n'));\\n    var output = [// add before: prevent undeclared normal\\n    '#include <normal_fragment_begin>', color.code];\\n\\n    if (mask) {\\n      output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\\n    }\\n\\n    if (alpha) {\\n      output.push(alpha.code, '#ifdef ALPHATEST', ' if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif');\\n    }\\n\\n    if (alpha) {\\n      output.push('gl_FragColor = vec4(' + color.result + ', ' + alpha.result + ' );');\\n    } else {\\n      output.push('gl_FragColor = vec4(' + color.result + ', 1.0 );');\\n    }\\n\\n    code = output.join('\\\\n');\\n  }\\n\\n  return code;\\n};\\n\\nBasicNode.prototype.copy = function (source) {\\n  _Node.Node.prototype.copy.call(this, source);\\n\\n  this.color = source.color;\\n  if (source.position) this.position = source.position;\\n  if (source.alpha) this.alpha = source.alpha;\\n  if (source.mask) this.mask = source.mask;\\n  return this;\\n};\\n\\nBasicNode.prototype.toJSON = function (meta) {\\n  var data = this.getJSONNode(meta);\\n\\n  if (!data) {\\n    data = this.createJSONNode(meta);\\n    data.color = this.color.toJSON(meta).uuid;\\n    if (this.position) data.position = this.position.toJSON(meta).uuid;\\n    if (this.alpha) data.alpha = this.alpha.toJSON(meta).uuid;\\n    if (this.mask) data.mask = this.mask.toJSON(meta).uuid;\\n  }\\n\\n  return data;\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"BasicNode\",\"_Node\",\"Node\",\"call\",\"color\",\"_ColorNode\",\"ColorNode\",\"Object\",\"defineProperty\",\"value\",\"prototype\",\"create\",\"constructor\",\"nodeType\",\"generate\",\"BasicNode.prototype.generate\",\"builder\",\"isShader\",\"position\",\"analyzeAndFlow\",\"cache\",\"undefined\",\"addParsCode\",\"output\",\"push\",\"code\",\"result\",\"analyze\",\"slot\",\"alpha\",\"mask\",\"flow\",\"requires\",\"transparent\",\"join\",\"copy\",\"BasicNode.prototype.copy\",\"source\",\"toJSON\",\"BasicNode.prototype.toJSON\",\"meta\",\"data\",\"getJSONNode\",\"createJSONNode\",\"uuid\"]\n}\n"]