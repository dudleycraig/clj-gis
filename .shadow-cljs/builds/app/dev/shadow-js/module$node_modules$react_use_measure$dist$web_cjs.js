["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-use-measure/dist/web.cjs.js"],"~:js","shadow$provide.module$node_modules$react_use_measure$dist$web_cjs=function(global,require,module,exports){function useOnWindowResize(onWindowResize){react.useEffect(function(){window.addEventListener(\"resize\",onWindowResize);return function(){return void window.removeEventListener(\"resize\",onWindowResize)}},[onWindowResize])}function useOnWindowScroll(onScroll,enabled){react.useEffect(function(){if(enabled)return window.addEventListener(\"scroll\",onScroll,{capture:!0,passive:!0}),function(){return void window.removeEventListener(\"scroll\",\nonScroll,!0)}},[onScroll,enabled])}function findScrollContainers(element){var result=[];if(!element||element===document.body)return result;var _window$getComputedSt=window.getComputedStyle(element);[_window$getComputedSt.overflow,_window$getComputedSt.overflowX,_window$getComputedSt.overflowY].some(function(prop){return\"auto\"===prop||\"scroll\"===prop})&&result.push(element);return[].concat(result,findScrollContainers(element.parentElement))}var react=require(\"module$node_modules$react$index\"),debounce=\nrequire(\"module$node_modules$debounce$index\"),keys=\"x y top bottom left right width height\".split(\" \"),areBoundsEqual=function(a,b){return keys.every(function(key){return a[key]===b[key]})};module.exports=function(_temp){function removeListeners(){state.current.scrollContainers&&(state.current.scrollContainers.forEach(function(element){return element.removeEventListener(\"scroll\",scrollChange,!0)}),state.current.scrollContainers=null);state.current.resizeObserver&&(state.current.resizeObserver.disconnect(),\nstate.current.resizeObserver=null)}function addListeners(){state.current.element&&(state.current.resizeObserver=new ResizeObserver(scrollChange),state.current.resizeObserver.observe(state.current.element),scroll&&state.current.scrollContainers&&state.current.scrollContainers.forEach(function(scrollContainer){return scrollContainer.addEventListener(\"scroll\",scrollChange,{capture:!0,passive:!0})}))}_temp=void 0===_temp?{debounce:0,scroll:!1}:_temp;var debounce$1=_temp.debounce,scroll=_temp.scroll,ResizeObserver=\n_temp.polyfill||(\"undefined\"===typeof window?function(){}:window.ResizeObserver);if(!ResizeObserver)throw Error(\"This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills\");var _useState=react.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0});_temp=_useState[0];var set=_useState[1],state=react.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:_temp}),scrollDebounce=debounce$1?\n\"number\"===typeof debounce$1?debounce$1:debounce$1.scroll:null,resizeDebounce=debounce$1?\"number\"===typeof debounce$1?debounce$1:debounce$1.resize:null,mounted=react.useRef(!1);react.useEffect(function(){mounted.current=!0;return function(){return void(mounted.current=!1)}});debounce$1=react.useMemo(function(){var callback=function(){if(state.current.element){var _ref2=state.current.element.getBoundingClientRect();_ref2={left:_ref2.left,top:_ref2.top,width:_ref2.width,height:_ref2.height,bottom:_ref2.bottom,\nright:_ref2.right,x:_ref2.x,y:_ref2.y};Object.freeze(_ref2);mounted.current&&!areBoundsEqual(state.current.lastBounds,_ref2)&&set(state.current.lastBounds=_ref2)}};return[callback,resizeDebounce?debounce.debounce(callback,resizeDebounce):callback,scrollDebounce?debounce.debounce(callback,scrollDebounce):callback]},[set,scrollDebounce,resizeDebounce]);_useState=debounce$1[0];var resizeChange=debounce$1[1],scrollChange=debounce$1[2];useOnWindowScroll(scrollChange,!!scroll);useOnWindowResize(resizeChange);\nreact.useEffect(function(){removeListeners();addListeners()},[scroll,scrollChange,resizeChange]);react.useEffect(function(){return removeListeners},[]);return[function(node){node&&node!==state.current.element&&(removeListeners(),state.current.element=node,state.current.scrollContainers=findScrollContainers(node),addListeners())},_temp,_useState]}}","~:source","shadow$provide[\"module$node_modules$react_use_measure$dist$web_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nvar react = require('react');\nvar debounce = require('debounce');\n\nfunction useMeasure(_temp) {\n  var _ref = _temp === void 0 ? {\n    debounce: 0,\n    scroll: false\n  } : _temp,\n      debounce$1 = _ref.debounce,\n      scroll = _ref.scroll,\n      polyfill = _ref.polyfill;\n\n  var ResizeObserver = polyfill || (typeof window === 'undefined' ? function ResizeObserver() {} : window.ResizeObserver);\n\n  if (!ResizeObserver) {\n    throw new Error('This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills');\n  }\n\n  var _useState = react.useState({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    bottom: 0,\n    right: 0,\n    x: 0,\n    y: 0\n  }),\n      bounds = _useState[0],\n      set = _useState[1]; // keep all state in a ref\n\n\n  var state = react.useRef({\n    element: null,\n    scrollContainers: null,\n    resizeObserver: null,\n    lastBounds: bounds\n  }); // set actual debounce values early, so effects know if they should react accordingly\n\n  var scrollDebounce = debounce$1 ? typeof debounce$1 === 'number' ? debounce$1 : debounce$1.scroll : null;\n  var resizeDebounce = debounce$1 ? typeof debounce$1 === 'number' ? debounce$1 : debounce$1.resize : null; // make sure to update state only as long as the component is truly mounted\n\n  var mounted = react.useRef(false);\n  react.useEffect(function () {\n    mounted.current = true;\n    return function () {\n      return void (mounted.current = false);\n    };\n  }); // memoize handlers, so event-listeners know when they should update\n\n  var _useMemo = react.useMemo(function () {\n    var callback = function callback() {\n      if (!state.current.element) return;\n\n      var _ref2 = state.current.element.getBoundingClientRect(),\n          left = _ref2.left,\n          top = _ref2.top,\n          width = _ref2.width,\n          height = _ref2.height,\n          bottom = _ref2.bottom,\n          right = _ref2.right,\n          x = _ref2.x,\n          y = _ref2.y;\n\n      var size = {\n        left: left,\n        top: top,\n        width: width,\n        height: height,\n        bottom: bottom,\n        right: right,\n        x: x,\n        y: y\n      };\n      Object.freeze(size);\n      if (mounted.current && !areBoundsEqual(state.current.lastBounds, size)) set(state.current.lastBounds = size);\n    };\n\n    return [callback, resizeDebounce ? debounce.debounce(callback, resizeDebounce) : callback, scrollDebounce ? debounce.debounce(callback, scrollDebounce) : callback];\n  }, [set, scrollDebounce, resizeDebounce]),\n      forceRefresh = _useMemo[0],\n      resizeChange = _useMemo[1],\n      scrollChange = _useMemo[2]; // cleanup current scroll-listeners / observers\n\n\n  function removeListeners() {\n    if (state.current.scrollContainers) {\n      state.current.scrollContainers.forEach(function (element) {\n        return element.removeEventListener('scroll', scrollChange, true);\n      });\n      state.current.scrollContainers = null;\n    }\n\n    if (state.current.resizeObserver) {\n      state.current.resizeObserver.disconnect();\n      state.current.resizeObserver = null;\n    }\n  } // add scroll-listeners / observers\n\n\n  function addListeners() {\n    if (!state.current.element) return;\n    state.current.resizeObserver = new ResizeObserver(scrollChange);\n    state.current.resizeObserver.observe(state.current.element);\n\n    if (scroll && state.current.scrollContainers) {\n      state.current.scrollContainers.forEach(function (scrollContainer) {\n        return scrollContainer.addEventListener('scroll', scrollChange, {\n          capture: true,\n          passive: true\n        });\n      });\n    }\n  } // the ref we expose to the user\n\n\n  var ref = function ref(node) {\n    if (!node || node === state.current.element) return;\n    removeListeners();\n    state.current.element = node;\n    state.current.scrollContainers = findScrollContainers(node);\n    addListeners();\n  }; // add general event listeners\n\n\n  useOnWindowScroll(scrollChange, Boolean(scroll));\n  useOnWindowResize(resizeChange); // respond to changes that are relevant for the listeners\n\n  react.useEffect(function () {\n    removeListeners();\n    addListeners();\n  }, [scroll, scrollChange, resizeChange]); // remove all listeners when the components unmounts\n\n  react.useEffect(function () {\n    return removeListeners;\n  }, []);\n  return [ref, bounds, forceRefresh];\n} // Adds native resize listener to window\n\n\nfunction useOnWindowResize(onWindowResize) {\n  react.useEffect(function () {\n    var cb = onWindowResize;\n    window.addEventListener('resize', cb);\n    return function () {\n      return void window.removeEventListener('resize', cb);\n    };\n  }, [onWindowResize]);\n}\n\nfunction useOnWindowScroll(onScroll, enabled) {\n  react.useEffect(function () {\n    if (enabled) {\n      var _cb = onScroll;\n      window.addEventListener('scroll', _cb, {\n        capture: true,\n        passive: true\n      });\n      return function () {\n        return void window.removeEventListener('scroll', _cb, true);\n      };\n    }\n  }, [onScroll, enabled]);\n} // Returns a list of scroll offsets\n\n\nfunction findScrollContainers(element) {\n  var result = [];\n  if (!element || element === document.body) return result;\n\n  var _window$getComputedSt = window.getComputedStyle(element),\n      overflow = _window$getComputedSt.overflow,\n      overflowX = _window$getComputedSt.overflowX,\n      overflowY = _window$getComputedSt.overflowY;\n\n  if ([overflow, overflowX, overflowY].some(function (prop) {\n    return prop === 'auto' || prop === 'scroll';\n  })) result.push(element);\n  return [].concat(result, findScrollContainers(element.parentElement));\n} // Checks if element boundaries are equal\n\n\nvar keys = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'];\n\nvar areBoundsEqual = function areBoundsEqual(a, b) {\n  return keys.every(function (key) {\n    return a[key] === b[key];\n  });\n};\n\nmodule.exports = useMeasure;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$debounce$index","~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["width","debounce","right","passive","top","height","scroll","x","scrollContainers","element","resizeObserver","current","lastBounds","y","capture","bottom","left"]],"~:compiled-at",1630582888147,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_use_measure$dist$web_cjs.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-use-measure/dist/web.cjs.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_use_measure$dist$web_cjs\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nvar react = require('react');\\nvar debounce = require('debounce');\\n\\nfunction useMeasure(_temp) {\\n  var _ref = _temp === void 0 ? {\\n    debounce: 0,\\n    scroll: false\\n  } : _temp,\\n      debounce$1 = _ref.debounce,\\n      scroll = _ref.scroll,\\n      polyfill = _ref.polyfill;\\n\\n  var ResizeObserver = polyfill || (typeof window === 'undefined' ? function ResizeObserver() {} : window.ResizeObserver);\\n\\n  if (!ResizeObserver) {\\n    throw new Error('This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills');\\n  }\\n\\n  var _useState = react.useState({\\n    left: 0,\\n    top: 0,\\n    width: 0,\\n    height: 0,\\n    bottom: 0,\\n    right: 0,\\n    x: 0,\\n    y: 0\\n  }),\\n      bounds = _useState[0],\\n      set = _useState[1]; // keep all state in a ref\\n\\n\\n  var state = react.useRef({\\n    element: null,\\n    scrollContainers: null,\\n    resizeObserver: null,\\n    lastBounds: bounds\\n  }); // set actual debounce values early, so effects know if they should react accordingly\\n\\n  var scrollDebounce = debounce$1 ? typeof debounce$1 === 'number' ? debounce$1 : debounce$1.scroll : null;\\n  var resizeDebounce = debounce$1 ? typeof debounce$1 === 'number' ? debounce$1 : debounce$1.resize : null; // make sure to update state only as long as the component is truly mounted\\n\\n  var mounted = react.useRef(false);\\n  react.useEffect(function () {\\n    mounted.current = true;\\n    return function () {\\n      return void (mounted.current = false);\\n    };\\n  }); // memoize handlers, so event-listeners know when they should update\\n\\n  var _useMemo = react.useMemo(function () {\\n    var callback = function callback() {\\n      if (!state.current.element) return;\\n\\n      var _ref2 = state.current.element.getBoundingClientRect(),\\n          left = _ref2.left,\\n          top = _ref2.top,\\n          width = _ref2.width,\\n          height = _ref2.height,\\n          bottom = _ref2.bottom,\\n          right = _ref2.right,\\n          x = _ref2.x,\\n          y = _ref2.y;\\n\\n      var size = {\\n        left: left,\\n        top: top,\\n        width: width,\\n        height: height,\\n        bottom: bottom,\\n        right: right,\\n        x: x,\\n        y: y\\n      };\\n      Object.freeze(size);\\n      if (mounted.current && !areBoundsEqual(state.current.lastBounds, size)) set(state.current.lastBounds = size);\\n    };\\n\\n    return [callback, resizeDebounce ? debounce.debounce(callback, resizeDebounce) : callback, scrollDebounce ? debounce.debounce(callback, scrollDebounce) : callback];\\n  }, [set, scrollDebounce, resizeDebounce]),\\n      forceRefresh = _useMemo[0],\\n      resizeChange = _useMemo[1],\\n      scrollChange = _useMemo[2]; // cleanup current scroll-listeners / observers\\n\\n\\n  function removeListeners() {\\n    if (state.current.scrollContainers) {\\n      state.current.scrollContainers.forEach(function (element) {\\n        return element.removeEventListener('scroll', scrollChange, true);\\n      });\\n      state.current.scrollContainers = null;\\n    }\\n\\n    if (state.current.resizeObserver) {\\n      state.current.resizeObserver.disconnect();\\n      state.current.resizeObserver = null;\\n    }\\n  } // add scroll-listeners / observers\\n\\n\\n  function addListeners() {\\n    if (!state.current.element) return;\\n    state.current.resizeObserver = new ResizeObserver(scrollChange);\\n    state.current.resizeObserver.observe(state.current.element);\\n\\n    if (scroll && state.current.scrollContainers) {\\n      state.current.scrollContainers.forEach(function (scrollContainer) {\\n        return scrollContainer.addEventListener('scroll', scrollChange, {\\n          capture: true,\\n          passive: true\\n        });\\n      });\\n    }\\n  } // the ref we expose to the user\\n\\n\\n  var ref = function ref(node) {\\n    if (!node || node === state.current.element) return;\\n    removeListeners();\\n    state.current.element = node;\\n    state.current.scrollContainers = findScrollContainers(node);\\n    addListeners();\\n  }; // add general event listeners\\n\\n\\n  useOnWindowScroll(scrollChange, Boolean(scroll));\\n  useOnWindowResize(resizeChange); // respond to changes that are relevant for the listeners\\n\\n  react.useEffect(function () {\\n    removeListeners();\\n    addListeners();\\n  }, [scroll, scrollChange, resizeChange]); // remove all listeners when the components unmounts\\n\\n  react.useEffect(function () {\\n    return removeListeners;\\n  }, []);\\n  return [ref, bounds, forceRefresh];\\n} // Adds native resize listener to window\\n\\n\\nfunction useOnWindowResize(onWindowResize) {\\n  react.useEffect(function () {\\n    var cb = onWindowResize;\\n    window.addEventListener('resize', cb);\\n    return function () {\\n      return void window.removeEventListener('resize', cb);\\n    };\\n  }, [onWindowResize]);\\n}\\n\\nfunction useOnWindowScroll(onScroll, enabled) {\\n  react.useEffect(function () {\\n    if (enabled) {\\n      var _cb = onScroll;\\n      window.addEventListener('scroll', _cb, {\\n        capture: true,\\n        passive: true\\n      });\\n      return function () {\\n        return void window.removeEventListener('scroll', _cb, true);\\n      };\\n    }\\n  }, [onScroll, enabled]);\\n} // Returns a list of scroll offsets\\n\\n\\nfunction findScrollContainers(element) {\\n  var result = [];\\n  if (!element || element === document.body) return result;\\n\\n  var _window$getComputedSt = window.getComputedStyle(element),\\n      overflow = _window$getComputedSt.overflow,\\n      overflowX = _window$getComputedSt.overflowX,\\n      overflowY = _window$getComputedSt.overflowY;\\n\\n  if ([overflow, overflowX, overflowY].some(function (prop) {\\n    return prop === 'auto' || prop === 'scroll';\\n  })) result.push(element);\\n  return [].concat(result, findScrollContainers(element.parentElement));\\n} // Checks if element boundaries are equal\\n\\n\\nvar keys = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'];\\n\\nvar areBoundsEqual = function areBoundsEqual(a, b) {\\n  return keys.every(function (key) {\\n    return a[key] === b[key];\\n  });\\n};\\n\\nmodule.exports = useMeasure;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"useOnWindowResize\",\"onWindowResize\",\"react\",\"useEffect\",\"window\",\"addEventListener\",\"removeEventListener\",\"useOnWindowScroll\",\"onScroll\",\"enabled\",\"capture\",\"passive\",\"findScrollContainers\",\"element\",\"result\",\"document\",\"body\",\"_window$getComputedSt\",\"getComputedStyle\",\"overflow\",\"overflowX\",\"overflowY\",\"some\",\"prop\",\"push\",\"concat\",\"parentElement\",\"debounce\",\"keys\",\"areBoundsEqual\",\"a\",\"b\",\"every\",\"key\",\"useMeasure\",\"_temp\",\"removeListeners\",\"state\",\"current\",\"scrollContainers\",\"forEach\",\"scrollChange\",\"resizeObserver\",\"disconnect\",\"addListeners\",\"ResizeObserver\",\"observe\",\"scroll\",\"scrollContainer\",\"_ref\",\"debounce$1\",\"polyfill\",\"Error\",\"_useState\",\"useState\",\"left\",\"top\",\"width\",\"height\",\"bottom\",\"right\",\"x\",\"y\",\"bounds\",\"set\",\"useRef\",\"lastBounds\",\"scrollDebounce\",\"resizeDebounce\",\"resize\",\"mounted\",\"_useMemo\",\"useMemo\",\"callback\",\"_ref2\",\"getBoundingClientRect\",\"size\",\"Object\",\"freeze\",\"forceRefresh\",\"resizeChange\",\"ref\",\"node\"]\n}\n"]