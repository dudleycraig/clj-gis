["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/deprecated/Geometry.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$deprecated$Geometry=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");\n}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=\nObject.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,\np$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.Geometry=exports.Face3=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_m1=new _three.Matrix4,_obj=new _three.Object3D,_offset=new _three.Vector3;global=function(_EventDispatcher){function Geometry(){_classCallCheck(this,Geometry);var _this=_getPrototypeOf(Geometry).call(this);\nif(!_this||\"object\"!==_typeof(_this)&&\"function\"!==typeof _this){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");_this=this}_this.isGeometry=!0;_this.uuid=_three.MathUtils.generateUUID();_this.name=\"\";_this.type=\"Geometry\";_this.vertices=[];_this.colors=[];_this.faces=[];_this.faceVertexUvs=[[]];_this.morphTargets=[];_this.morphNormals=[];_this.skinWeights=[];_this.skinIndices=[];_this.lineDistances=[];_this.boundingBox=null;_this.boundingSphere=\nnull;_this.elementsNeedUpdate=!1;_this.verticesNeedUpdate=!1;_this.uvsNeedUpdate=!1;_this.normalsNeedUpdate=!1;_this.colorsNeedUpdate=!1;_this.lineDistancesNeedUpdate=!1;_this.groupsNeedUpdate=!1;return _this}_inherits(Geometry,_EventDispatcher);_createClass(Geometry,[{key:\"applyMatrix4\",value:function(matrix){for(var normalMatrix=(new _three.Matrix3).getNormalMatrix(matrix),i=0,il=this.vertices.length;i<il;i++)this.vertices[i].applyMatrix4(matrix);matrix=0;for(i=this.faces.length;matrix<i;matrix++){il=\nthis.faces[matrix];il.normal.applyMatrix3(normalMatrix).normalize();for(var j=0,jl=il.vertexNormals.length;j<jl;j++)il.vertexNormals[j].applyMatrix3(normalMatrix).normalize()}null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();this.normalsNeedUpdate=this.verticesNeedUpdate=!0;return this}},{key:\"rotateX\",value:function(angle){_m1.makeRotationX(angle);this.applyMatrix4(_m1);return this}},{key:\"rotateY\",value:function(angle){_m1.makeRotationY(angle);\nthis.applyMatrix4(_m1);return this}},{key:\"rotateZ\",value:function(angle){_m1.makeRotationZ(angle);this.applyMatrix4(_m1);return this}},{key:\"translate\",value:function(x,y,z){_m1.makeTranslation(x,y,z);this.applyMatrix4(_m1);return this}},{key:\"scale\",value:function(x,y,z){_m1.makeScale(x,y,z);this.applyMatrix4(_m1);return this}},{key:\"lookAt\",value:function(vector){_obj.lookAt(vector);_obj.updateMatrix();this.applyMatrix4(_obj.matrix);return this}},{key:\"fromBufferGeometry\",value:function(geometry){function addFace(a,\nb,c,materialIndex){var vertexColors=void 0===color?[]:[scope.colors[a].clone(),scope.colors[b].clone(),scope.colors[c].clone()],vertexNormals=void 0===normal?[]:[(new _three.Vector3).fromBufferAttribute(normal,a),(new _three.Vector3).fromBufferAttribute(normal,b),(new _three.Vector3).fromBufferAttribute(normal,c)];materialIndex=new Face3(a,b,c,vertexNormals,vertexColors,materialIndex);scope.faces.push(materialIndex);void 0!==uv&&scope.faceVertexUvs[0].push([(new _three.Vector2).fromBufferAttribute(uv,\na),(new _three.Vector2).fromBufferAttribute(uv,b),(new _three.Vector2).fromBufferAttribute(uv,c)]);void 0!==uv2&&scope.faceVertexUvs[1].push([(new _three.Vector2).fromBufferAttribute(uv2,a),(new _three.Vector2).fromBufferAttribute(uv2,b),(new _three.Vector2).fromBufferAttribute(uv2,c)])}var scope=this,index=null!==geometry.index?geometry.index:void 0,attributes=geometry.attributes;if(void 0===attributes.position)return console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\"),\nthis;var position=attributes.position,normal=attributes.normal,color=attributes.color,uv=attributes.uv,uv2=attributes.uv2;void 0!==uv2&&(this.faceVertexUvs[1]=[]);for(attributes=0;attributes<position.count;attributes++)scope.vertices.push((new _three.Vector3).fromBufferAttribute(position,attributes)),void 0!==color&&scope.colors.push((new _three.Color).fromBufferAttribute(color,attributes));attributes=geometry.groups;if(0<attributes.length)for(position=0;position<attributes.length;position++){var group=\nattributes[position],start=group.start,j=start;for(start+=group.count;j<start;j+=3)void 0!==index?addFace(index.getX(j),index.getX(j+1),index.getX(j+2),group.materialIndex):addFace(j,j+1,j+2,group.materialIndex)}else if(void 0!==index)for(attributes=0;attributes<index.count;attributes+=3)addFace(index.getX(attributes),index.getX(attributes+1),index.getX(attributes+2));else for(index=0;index<position.count;index+=3)addFace(index,index+1,index+2);this.computeFaceNormals();null!==geometry.boundingBox&&\n(this.boundingBox=geometry.boundingBox.clone());null!==geometry.boundingSphere&&(this.boundingSphere=geometry.boundingSphere.clone());return this}},{key:\"center\",value:function(){this.computeBoundingBox();this.boundingBox.getCenter(_offset).negate();this.translate(_offset.x,_offset.y,_offset.z);return this}},{key:\"normalize\",value:function(){this.computeBoundingSphere();var center=this.boundingSphere.center,radius=this.boundingSphere.radius;radius=0===radius?1:1/radius;var matrix=new _three.Matrix4;\nmatrix.set(radius,0,0,-radius*center.x,0,radius,0,-radius*center.y,0,0,radius,-radius*center.z,0,0,0,1);this.applyMatrix4(matrix);return this}},{key:\"computeFaceNormals\",value:function(){for(var cb=new _three.Vector3,ab=new _three.Vector3,f=0,fl=this.faces.length;f<fl;f++){var face=this.faces[f],vA=this.vertices[face.a],vB=this.vertices[face.b];cb.subVectors(this.vertices[face.c],vB);ab.subVectors(vA,vB);cb.cross(ab);cb.normalize();face.normal.copy(cb)}}},{key:\"computeVertexNormals\",value:function(){for(var areaWeighted=\n0<arguments.length&&void 0!==arguments[0]?arguments[0]:!0,vertices=Array(this.vertices.length),v=0,vl=this.vertices.length;v<vl;v++)vertices[v]=new _three.Vector3;if(areaWeighted){areaWeighted=new _three.Vector3;v=new _three.Vector3;vl=0;for(var fl=this.faces.length;vl<fl;vl++){var face=this.faces[vl],vA=this.vertices[face.a],vB=this.vertices[face.b];areaWeighted.subVectors(this.vertices[face.c],vB);v.subVectors(vA,vB);areaWeighted.cross(v);vertices[face.a].add(areaWeighted);vertices[face.b].add(areaWeighted);\nvertices[face.c].add(areaWeighted)}}else for(this.computeFaceNormals(),areaWeighted=0,v=this.faces.length;areaWeighted<v;areaWeighted++)vl=this.faces[areaWeighted],vertices[vl.a].add(vl.normal),vertices[vl.b].add(vl.normal),vertices[vl.c].add(vl.normal);areaWeighted=0;for(v=this.vertices.length;areaWeighted<v;areaWeighted++)vertices[areaWeighted].normalize();areaWeighted=0;for(v=this.faces.length;areaWeighted<v;areaWeighted++)vl=this.faces[areaWeighted],fl=vl.vertexNormals,3===fl.length?(fl[0].copy(vertices[vl.a]),\nfl[1].copy(vertices[vl.b]),fl[2].copy(vertices[vl.c])):(fl[0]=vertices[vl.a].clone(),fl[1]=vertices[vl.b].clone(),fl[2]=vertices[vl.c].clone());0<this.faces.length&&(this.normalsNeedUpdate=!0)}},{key:\"computeFlatVertexNormals\",value:function(){this.computeFaceNormals();for(var f=0,fl=this.faces.length;f<fl;f++){var face=this.faces[f],vertexNormals=face.vertexNormals;3===vertexNormals.length?(vertexNormals[0].copy(face.normal),vertexNormals[1].copy(face.normal),vertexNormals[2].copy(face.normal)):\n(vertexNormals[0]=face.normal.clone(),vertexNormals[1]=face.normal.clone(),vertexNormals[2]=face.normal.clone())}0<this.faces.length&&(this.normalsNeedUpdate=!0)}},{key:\"computeMorphNormals\",value:function(){for(var f=0,fl=this.faces.length;f<fl;f++){var face=this.faces[f];face.__originalFaceNormal?face.__originalFaceNormal.copy(face.normal):face.__originalFaceNormal=face.normal.clone();face.__originalVertexNormals||(face.__originalVertexNormals=[]);for(var i=0,il=face.vertexNormals.length;i<il;i++)face.__originalVertexNormals[i]?\nface.__originalVertexNormals[i].copy(face.vertexNormals[i]):face.__originalVertexNormals[i]=face.vertexNormals[i].clone()}f=new Geometry;f.faces=this.faces;fl=0;for(face=this.morphTargets.length;fl<face;fl++){if(!this.morphNormals[fl]){this.morphNormals[fl]={};this.morphNormals[fl].faceNormals=[];this.morphNormals[fl].vertexNormals=[];i=this.morphNormals[fl].faceNormals;il=this.morphNormals[fl].vertexNormals;for(var _f3=0,_fl3=this.faces.length;_f3<_fl3;_f3++){var faceNormal=new _three.Vector3,vertexNormals=\n{a:new _three.Vector3,b:new _three.Vector3,c:new _three.Vector3};i.push(faceNormal);il.push(vertexNormals)}}i=this.morphNormals[fl];f.vertices=this.morphTargets[fl].vertices;f.computeFaceNormals();f.computeVertexNormals();il=0;for(_f3=this.faces.length;il<_f3;il++)_fl3=this.faces[il],faceNormal=i.vertexNormals[il],i.faceNormals[il].copy(_fl3.normal),faceNormal.a.copy(_fl3.vertexNormals[0]),faceNormal.b.copy(_fl3.vertexNormals[1]),faceNormal.c.copy(_fl3.vertexNormals[2])}f=0;for(fl=this.faces.length;f<\nfl;f++)face=this.faces[f],face.normal=face.__originalFaceNormal,face.vertexNormals=face.__originalVertexNormals}},{key:\"computeBoundingBox\",value:function(){null===this.boundingBox&&(this.boundingBox=new _three.Box3);this.boundingBox.setFromPoints(this.vertices)}},{key:\"computeBoundingSphere\",value:function(){null===this.boundingSphere&&(this.boundingSphere=new _three.Sphere);this.boundingSphere.setFromPoints(this.vertices)}},{key:\"merge\",value:function(geometry,matrix){var materialIndexOffset=2<\narguments.length&&void 0!==arguments[2]?arguments[2]:0;if(geometry&&geometry.isGeometry){var normalMatrix,vertexOffset=this.vertices.length,vertices1=this.vertices,vertices2=geometry.vertices,faces1=this.faces,faces2=geometry.faces,colors1=this.colors,colors2=geometry.colors;void 0!==matrix&&(normalMatrix=(new _three.Matrix3).getNormalMatrix(matrix));for(var i=0,il=vertices2.length;i<il;i++){var vertexCopy=vertices2[i].clone();void 0!==matrix&&vertexCopy.applyMatrix4(matrix);vertices1.push(vertexCopy)}vertices1=\n0;for(vertices2=colors2.length;vertices1<vertices2;vertices1++)colors1.push(colors2[vertices1].clone());colors1=0;for(colors2=faces2.length;colors1<colors2;colors1++){vertices1=faces2[colors1];vertexCopy=vertices1.vertexNormals;vertices2=vertices1.vertexColors;i=new Face3(vertices1.a+vertexOffset,vertices1.b+vertexOffset,vertices1.c+vertexOffset);i.normal.copy(vertices1.normal);void 0!==normalMatrix&&i.normal.applyMatrix3(normalMatrix).normalize();for(var j=0,jl=vertexCopy.length;j<jl;j++)il=vertexCopy[j].clone(),\nvoid 0!==normalMatrix&&il.applyMatrix3(normalMatrix).normalize(),i.vertexNormals.push(il);i.color.copy(vertices1.color);vertexCopy=0;for(j=vertices2.length;vertexCopy<j;vertexCopy++)il=vertices2[vertexCopy],i.vertexColors.push(il.clone());i.materialIndex=vertices1.materialIndex+materialIndexOffset;faces1.push(i)}materialIndexOffset=0;for(normalMatrix=geometry.faceVertexUvs.length;materialIndexOffset<normalMatrix;materialIndexOffset++)for(vertexOffset=geometry.faceVertexUvs[materialIndexOffset],void 0===\nthis.faceVertexUvs[materialIndexOffset]&&(this.faceVertexUvs[materialIndexOffset]=[]),faces1=0,faces2=vertexOffset.length;faces1<faces2;faces1++){colors1=vertexOffset[faces1];colors2=[];vertices1=0;for(vertices2=colors1.length;vertices1<vertices2;vertices1++)colors2.push(colors1[vertices1].clone());this.faceVertexUvs[materialIndexOffset].push(colors2)}}else console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\",geometry)}},{key:\"mergeMesh\",value:function(mesh){mesh&&mesh.isMesh?\n(mesh.matrixAutoUpdate&&mesh.updateMatrix(),this.merge(mesh.geometry,mesh.matrix)):console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\",mesh)}},{key:\"mergeVertices\",value:function(){for(var verticesMap={},unique=[],changes=[],precision=Math.pow(10,0<arguments.length&&void 0!==arguments[0]?arguments[0]:4),i=0,il=this.vertices.length;i<il;i++){var v=this.vertices[i];v=\"\".concat(Math.round(v.x*precision),\"_\").concat(Math.round(v.y*precision),\"_\").concat(Math.round(v.z*precision));\nvoid 0===verticesMap[v]?(verticesMap[v]=i,unique.push(this.vertices[i]),changes[i]=unique.length-1):changes[i]=changes[verticesMap[v]]}verticesMap=[];precision=0;for(i=this.faces.length;precision<i;precision++)for(il=this.faces[precision],il.a=changes[il.a],il.b=changes[il.b],il.c=changes[il.c],il=[il.a,il.b,il.c],v=0;3>v;v++)if(il[v]===il[(v+1)%3]){verticesMap.push(precision);break}for(changes=verticesMap.length-1;0<=changes;changes--)for(precision=verticesMap[changes],this.faces.splice(precision,\n1),i=0,il=this.faceVertexUvs.length;i<il;i++)this.faceVertexUvs[i].splice(precision,1);changes=this.vertices.length-unique.length;this.vertices=unique;return changes}},{key:\"setFromPoints\",value:function(points){this.vertices=[];for(var i=0,l=points.length;i<l;i++){var point=points[i];this.vertices.push(new _three.Vector3(point.x,point.y,point.z||0))}return this}},{key:\"sortFacesByMaterialIndex\",value:function(){for(var faces=this.faces,length=faces.length,i=0;i<length;i++)faces[i]._id=i;faces.sort(function(a,\nb){return a.materialIndex-b.materialIndex});i=this.faceVertexUvs[0];var uvs2=this.faceVertexUvs[1],newUvs1,newUvs2;i&&i.length===length&&(newUvs1=[]);uvs2&&uvs2.length===length&&(newUvs2=[]);for(var _i11=0;_i11<length;_i11++){var id=faces[_i11]._id;newUvs1&&newUvs1.push(i[id]);newUvs2&&newUvs2.push(uvs2[id])}newUvs1&&(this.faceVertexUvs[0]=newUvs1);newUvs2&&(this.faceVertexUvs[1]=newUvs2)}},{key:\"toJSON\",value:function(){function setBit(value,position,enabled){return enabled?value|1<<position:value&\n~(1<<position)}function getNormalIndex(normal){var hash=normal.x.toString()+normal.y.toString()+normal.z.toString();if(void 0!==normalsHash[hash])return normalsHash[hash];normalsHash[hash]=normals.length/3;normals.push(normal.x,normal.y,normal.z);return normalsHash[hash]}function getColorIndex(color){var hash=color.r.toString()+color.g.toString()+color.b.toString();if(void 0!==colorsHash[hash])return colorsHash[hash];colorsHash[hash]=colors.length;colors.push(color.getHex());return colorsHash[hash]}\nfunction getUvIndex(uv){var hash=uv.x.toString()+uv.y.toString();if(void 0!==uvsHash[hash])return uvsHash[hash];uvsHash[hash]=uvs.length/2;uvs.push(uv.x,uv.y);return uvsHash[hash]}var data={metadata:{version:4.5,type:\"Geometry\",generator:\"Geometry.toJSON\"}};data.uuid=this.uuid;data.type=this.type;\"\"!==this.name&&(data.name=this.name);if(void 0!==this.parameters){var parameters=this.parameters,key;for(key in parameters)void 0!==parameters[key]&&(data[key]=parameters[key]);return data}parameters=[];\nfor(key=0;key<this.vertices.length;key++){var vertex=this.vertices[key];parameters.push(vertex.x,vertex.y,vertex.z)}key=[];var normals=[],normalsHash={},colors=[],colorsHash={},uvs=[],uvsHash={};for(vertex=0;vertex<this.faces.length;vertex++){var face=this.faces[vertex],hasFaceVertexUv=void 0!==this.faceVertexUvs[0][vertex],hasFaceNormal=0<face.normal.length(),hasFaceVertexNormal=0<face.vertexNormals.length,hasFaceColor=1!==face.color.r||1!==face.color.g||1!==face.color.b,hasFaceVertexColor=0<face.vertexColors.length,\nfaceType=0;faceType=setBit(faceType,0,0);faceType=setBit(faceType,1,!0);faceType=setBit(faceType,2,!1);faceType=setBit(faceType,3,hasFaceVertexUv);faceType=setBit(faceType,4,hasFaceNormal);faceType=setBit(faceType,5,hasFaceVertexNormal);faceType=setBit(faceType,6,hasFaceColor);faceType=setBit(faceType,7,hasFaceVertexColor);key.push(faceType);key.push(face.a,face.b,face.c);key.push(face.materialIndex);hasFaceVertexUv&&(hasFaceVertexUv=this.faceVertexUvs[0][vertex],key.push(getUvIndex(hasFaceVertexUv[0]),\ngetUvIndex(hasFaceVertexUv[1]),getUvIndex(hasFaceVertexUv[2])));hasFaceNormal&&key.push(getNormalIndex(face.normal));hasFaceVertexNormal&&(hasFaceNormal=face.vertexNormals,key.push(getNormalIndex(hasFaceNormal[0]),getNormalIndex(hasFaceNormal[1]),getNormalIndex(hasFaceNormal[2])));hasFaceColor&&key.push(getColorIndex(face.color));hasFaceVertexColor&&(face=face.vertexColors,key.push(getColorIndex(face[0]),getColorIndex(face[1]),getColorIndex(face[2])))}data.data={};data.data.vertices=parameters;data.data.normals=\nnormals;0<colors.length&&(data.data.colors=colors);0<uvs.length&&(data.data.uvs=[uvs]);data.data.faces=key;return data}},{key:\"clone\",value:function(){return(new Geometry).copy(this)}},{key:\"copy\",value:function(source){this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.name=source.name;for(var vertices=source.vertices,i=0,il=vertices.length;i<\nil;i++)this.vertices.push(vertices[i].clone());vertices=source.colors;i=0;for(il=vertices.length;i<il;i++)this.colors.push(vertices[i].clone());vertices=source.faces;i=0;for(il=vertices.length;i<il;i++)this.faces.push(vertices[i].clone());vertices=0;for(i=source.faceVertexUvs.length;vertices<i;vertices++){il=source.faceVertexUvs[vertices];void 0===this.faceVertexUvs[vertices]&&(this.faceVertexUvs[vertices]=[]);for(var j=0,jl=il.length;j<jl;j++){for(var uvs=il[j],uvsCopy=[],k=0,kl=uvs.length;k<kl;k++)uvsCopy.push(uvs[k].clone());\nthis.faceVertexUvs[vertices].push(uvsCopy)}}vertices=source.morphTargets;i=0;for(il=vertices.length;i<il;i++){j={};j.name=vertices[i].name;if(void 0!==vertices[i].vertices)for(j.vertices=[],jl=0,uvs=vertices[i].vertices.length;jl<uvs;jl++)j.vertices.push(vertices[i].vertices[jl].clone());if(void 0!==vertices[i].normals)for(j.normals=[],jl=0,uvs=vertices[i].normals.length;jl<uvs;jl++)j.normals.push(vertices[i].normals[jl].clone());this.morphTargets.push(j)}vertices=source.morphNormals;i=0;for(il=vertices.length;i<\nil;i++){j={};if(void 0!==vertices[i].vertexNormals)for(j.vertexNormals=[],jl=0,uvs=vertices[i].vertexNormals.length;jl<uvs;jl++)uvsCopy=vertices[i].vertexNormals[jl],k={},k.a=uvsCopy.a.clone(),k.b=uvsCopy.b.clone(),k.c=uvsCopy.c.clone(),j.vertexNormals.push(k);if(void 0!==vertices[i].faceNormals)for(j.faceNormals=[],jl=0,uvs=vertices[i].faceNormals.length;jl<uvs;jl++)j.faceNormals.push(vertices[i].faceNormals[jl].clone());this.morphNormals.push(j)}vertices=source.skinWeights;i=0;for(il=vertices.length;i<\nil;i++)this.skinWeights.push(vertices[i].clone());vertices=source.skinIndices;i=0;for(il=vertices.length;i<il;i++)this.skinIndices.push(vertices[i].clone());vertices=source.lineDistances;i=0;for(il=vertices.length;i<il;i++)this.lineDistances.push(vertices[i]);vertices=source.boundingBox;null!==vertices&&(this.boundingBox=vertices.clone());vertices=source.boundingSphere;null!==vertices&&(this.boundingSphere=vertices.clone());this.elementsNeedUpdate=source.elementsNeedUpdate;this.verticesNeedUpdate=\nsource.verticesNeedUpdate;this.uvsNeedUpdate=source.uvsNeedUpdate;this.normalsNeedUpdate=source.normalsNeedUpdate;this.colorsNeedUpdate=source.colorsNeedUpdate;this.lineDistancesNeedUpdate=source.lineDistancesNeedUpdate;this.groupsNeedUpdate=source.groupsNeedUpdate;return this}},{key:\"toBufferGeometry\",value:function(){var geometry=(new DirectGeometry).fromGeometry(this),buffergeometry=new _three.BufferGeometry,positions=new Float32Array(3*geometry.vertices.length);buffergeometry.setAttribute(\"position\",\n(new _three.BufferAttribute(positions,3)).copyVector3sArray(geometry.vertices));0<geometry.normals.length&&(positions=new Float32Array(3*geometry.normals.length),buffergeometry.setAttribute(\"normal\",(new _three.BufferAttribute(positions,3)).copyVector3sArray(geometry.normals)));0<geometry.colors.length&&(positions=new Float32Array(3*geometry.colors.length),buffergeometry.setAttribute(\"color\",(new _three.BufferAttribute(positions,3)).copyColorsArray(geometry.colors)));0<geometry.uvs.length&&(positions=\nnew Float32Array(2*geometry.uvs.length),buffergeometry.setAttribute(\"uv\",(new _three.BufferAttribute(positions,2)).copyVector2sArray(geometry.uvs)));0<geometry.uvs2.length&&(positions=new Float32Array(2*geometry.uvs2.length),buffergeometry.setAttribute(\"uv2\",(new _three.BufferAttribute(positions,2)).copyVector2sArray(geometry.uvs2)));buffergeometry.groups=geometry.groups;for(var name in geometry.morphTargets){positions=[];for(var morphTargets=geometry.morphTargets[name],i=0,l=morphTargets.length;i<\nl;i++){var morphTarget=morphTargets[i],attribute=new _three.Float32BufferAttribute(3*morphTarget.data.length,3);attribute.name=morphTarget.name;positions.push(attribute.copyVector3sArray(morphTarget.data))}buffergeometry.morphAttributes[name]=positions}0<geometry.skinIndices.length&&(name=new _three.Float32BufferAttribute(4*geometry.skinIndices.length,4),buffergeometry.setAttribute(\"skinIndex\",name.copyVector4sArray(geometry.skinIndices)));0<geometry.skinWeights.length&&(name=new _three.Float32BufferAttribute(4*\ngeometry.skinWeights.length,4),buffergeometry.setAttribute(\"skinWeight\",name.copyVector4sArray(geometry.skinWeights)));null!==geometry.boundingSphere&&(buffergeometry.boundingSphere=geometry.boundingSphere.clone());null!==geometry.boundingBox&&(buffergeometry.boundingBox=geometry.boundingBox.clone());return buffergeometry}},{key:\"computeTangents\",value:function(){console.error(\"THREE.Geometry: .computeTangents() has been removed.\")}},{key:\"computeLineDistances\",value:function(){console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\")}},\n{key:\"applyMatrix\",value:function(matrix){console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");return this.applyMatrix4(matrix)}},{key:\"dispose\",value:function(){this.dispatchEvent({type:\"dispose\"})}}]);return Geometry}(_three.EventDispatcher);exports.Geometry=global;global.createBufferGeometryFromObject=function(object){var buffergeometry=new _three.BufferGeometry,geometry=object.geometry;if(object.isPoints||object.isLine){object=new _three.Float32BufferAttribute(3*\ngeometry.vertices.length,3);var colors=new _three.Float32BufferAttribute(3*geometry.colors.length,3);buffergeometry.setAttribute(\"position\",object.copyVector3sArray(geometry.vertices));buffergeometry.setAttribute(\"color\",colors.copyColorsArray(geometry.colors));geometry.lineDistances&&geometry.lineDistances.length===geometry.vertices.length&&(object=new _three.Float32BufferAttribute(geometry.lineDistances.length,1),buffergeometry.setAttribute(\"lineDistance\",object.copyArray(geometry.lineDistances)));\nnull!==geometry.boundingSphere&&(buffergeometry.boundingSphere=geometry.boundingSphere.clone());null!==geometry.boundingBox&&(buffergeometry.boundingBox=geometry.boundingBox.clone())}else object.isMesh&&(buffergeometry=geometry.toBufferGeometry());return buffergeometry};var DirectGeometry=function(){function DirectGeometry(){_classCallCheck(this,DirectGeometry);this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=[];this.morphTargets={};this.skinWeights=[];this.skinIndices=\n[];this.boundingSphere=this.boundingBox=null;this.groupsNeedUpdate=this.uvsNeedUpdate=this.colorsNeedUpdate=this.normalsNeedUpdate=this.verticesNeedUpdate=!1}_createClass(DirectGeometry,[{key:\"computeGroups\",value:function(geometry){var groups=[],materialIndex=void 0,faces=geometry.faces;for(geometry=0;geometry<faces.length;geometry++){var face=faces[geometry];if(face.materialIndex!==materialIndex){materialIndex=face.materialIndex;void 0!==group&&(group.count=3*geometry-group.start,groups.push(group));\nvar group={start:3*geometry,materialIndex}}}void 0!==group&&(group.count=3*geometry-group.start,groups.push(group));this.groups=groups}},{key:\"fromGeometry\",value:function(geometry){var faces=geometry.faces,vertices=geometry.vertices,faceVertexUvs=geometry.faceVertexUvs,hasFaceVertexUv=faceVertexUvs[0]&&0<faceVertexUvs[0].length,hasFaceVertexUv2=faceVertexUvs[1]&&0<faceVertexUvs[1].length,morphTargets=geometry.morphTargets,morphTargetsLength=morphTargets.length;if(0<morphTargetsLength){var morphTargetsPosition=\n[];for(var i=0;i<morphTargetsLength;i++)morphTargetsPosition[i]={name:morphTargets[i].name,data:[]};this.morphTargets.position=morphTargetsPosition}i=geometry.morphNormals;var morphNormalsLength=i.length;if(0<morphNormalsLength){var morphTargetsNormal=[];for(var _i21=0;_i21<morphNormalsLength;_i21++)morphTargetsNormal[_i21]={name:i[_i21].name,data:[]};this.morphTargets.normal=morphTargetsNormal}_i21=geometry.skinIndices;var skinWeights=geometry.skinWeights,hasSkinIndices=_i21.length===vertices.length,\nhasSkinWeights=skinWeights.length===vertices.length;0<vertices.length&&0===faces.length&&console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");for(var _i22=0;_i22<faces.length;_i22++){var face=faces[_i22];this.vertices.push(vertices[face.a],vertices[face.b],vertices[face.c]);var vertexNormals=face.vertexNormals;3===vertexNormals.length?this.normals.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]):(vertexNormals=face.normal,this.normals.push(vertexNormals,vertexNormals,\nvertexNormals));vertexNormals=face.vertexColors;3===vertexNormals.length?this.colors.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]):(vertexNormals=face.color,this.colors.push(vertexNormals,vertexNormals,vertexNormals));!0===hasFaceVertexUv&&(vertexNormals=faceVertexUvs[0][_i22],void 0!==vertexNormals?this.uvs.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]):(console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \",_i22),this.uvs.push(new _three.Vector2,new _three.Vector2,\nnew _three.Vector2)));!0===hasFaceVertexUv2&&(vertexNormals=faceVertexUvs[1][_i22],void 0!==vertexNormals?this.uvs2.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]):(console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \",_i22),this.uvs2.push(new _three.Vector2,new _three.Vector2,new _three.Vector2)));for(vertexNormals=0;vertexNormals<morphTargetsLength;vertexNormals++){var morphTarget=morphTargets[vertexNormals].vertices;morphTargetsPosition[vertexNormals].data.push(morphTarget[face.a],\nmorphTarget[face.b],morphTarget[face.c])}for(vertexNormals=0;vertexNormals<morphNormalsLength;vertexNormals++)morphTarget=i[vertexNormals].vertexNormals[_i22],morphTargetsNormal[vertexNormals].data.push(morphTarget.a,morphTarget.b,morphTarget.c);hasSkinIndices&&this.skinIndices.push(_i21[face.a],_i21[face.b],_i21[face.c]);hasSkinWeights&&this.skinWeights.push(skinWeights[face.a],skinWeights[face.b],skinWeights[face.c])}this.computeGroups(geometry);this.verticesNeedUpdate=geometry.verticesNeedUpdate;\nthis.normalsNeedUpdate=geometry.normalsNeedUpdate;this.colorsNeedUpdate=geometry.colorsNeedUpdate;this.uvsNeedUpdate=geometry.uvsNeedUpdate;this.groupsNeedUpdate=geometry.groupsNeedUpdate;null!==geometry.boundingSphere&&(this.boundingSphere=geometry.boundingSphere.clone());null!==geometry.boundingBox&&(this.boundingBox=geometry.boundingBox.clone());return this}}]);return DirectGeometry}(),Face3=function(){function Face3(a,b,c,normal,color){var materialIndex=5<arguments.length&&void 0!==arguments[5]?\narguments[5]:0;_classCallCheck(this,Face3);this.a=a;this.b=b;this.c=c;this.normal=normal&&normal.isVector3?normal:new _three.Vector3;this.vertexNormals=Array.isArray(normal)?normal:[];this.color=color&&color.isColor?color:new _three.Color;this.vertexColors=Array.isArray(color)?color:[];this.materialIndex=materialIndex}_createClass(Face3,[{key:\"clone\",value:function(){return(new this.constructor).copy(this)}},{key:\"copy\",value:function(source){this.a=source.a;this.b=source.b;this.c=source.c;this.normal.copy(source.normal);\nthis.color.copy(source.color);this.materialIndex=source.materialIndex;for(var i=0,il=source.vertexNormals.length;i<il;i++)this.vertexNormals[i]=source.vertexNormals[i].clone();i=0;for(il=source.vertexColors.length;i<il;i++)this.vertexColors[i]=source.vertexColors[i].clone();return this}}]);return Face3}();exports.Face3=Face3}","~:source","shadow$provide[\"module$node_modules$three_stdlib$deprecated$Geometry\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Geometry = exports.Face3 = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar _m1 = new _three.Matrix4();\n\nvar _obj = new _three.Object3D();\n\nvar _offset = new _three.Vector3();\n\nvar Geometry =\n/*#__PURE__*/\nfunction (_EventDispatcher) {\n  _inherits(Geometry, _EventDispatcher);\n\n  function Geometry() {\n    var _this;\n\n    _classCallCheck(this, Geometry);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Geometry).call(this));\n    _this.isGeometry = true;\n    _this.uuid = _three.MathUtils.generateUUID();\n    _this.name = '';\n    _this.type = 'Geometry';\n    _this.vertices = [];\n    _this.colors = [];\n    _this.faces = [];\n    _this.faceVertexUvs = [[]];\n    _this.morphTargets = [];\n    _this.morphNormals = [];\n    _this.skinWeights = [];\n    _this.skinIndices = [];\n    _this.lineDistances = [];\n    _this.boundingBox = null;\n    _this.boundingSphere = null; // update flags\n\n    _this.elementsNeedUpdate = false;\n    _this.verticesNeedUpdate = false;\n    _this.uvsNeedUpdate = false;\n    _this.normalsNeedUpdate = false;\n    _this.colorsNeedUpdate = false;\n    _this.lineDistancesNeedUpdate = false;\n    _this.groupsNeedUpdate = false;\n    return _this;\n  }\n\n  _createClass(Geometry, [{\n    key: \"applyMatrix4\",\n    value: function applyMatrix4(matrix) {\n      var normalMatrix = new _three.Matrix3().getNormalMatrix(matrix);\n\n      for (var i = 0, il = this.vertices.length; i < il; i++) {\n        var vertex = this.vertices[i];\n        vertex.applyMatrix4(matrix);\n      }\n\n      for (var _i = 0, _il = this.faces.length; _i < _il; _i++) {\n        var face = this.faces[_i];\n        face.normal.applyMatrix3(normalMatrix).normalize();\n\n        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n        }\n      }\n\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n\n      this.verticesNeedUpdate = true;\n      this.normalsNeedUpdate = true;\n      return this;\n    }\n  }, {\n    key: \"rotateX\",\n    value: function rotateX(angle) {\n      // rotate geometry around world x-axis\n      _m1.makeRotationX(angle);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"rotateY\",\n    value: function rotateY(angle) {\n      // rotate geometry around world y-axis\n      _m1.makeRotationY(angle);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"rotateZ\",\n    value: function rotateZ(angle) {\n      // rotate geometry around world z-axis\n      _m1.makeRotationZ(angle);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(x, y, z) {\n      // translate geometry\n      _m1.makeTranslation(x, y, z);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(x, y, z) {\n      // scale geometry\n      _m1.makeScale(x, y, z);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"lookAt\",\n    value: function lookAt(vector) {\n      _obj.lookAt(vector);\n\n      _obj.updateMatrix();\n\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n  }, {\n    key: \"fromBufferGeometry\",\n    value: function fromBufferGeometry(geometry) {\n      var scope = this;\n      var index = geometry.index !== null ? geometry.index : undefined;\n      var attributes = geometry.attributes;\n\n      if (attributes.position === undefined) {\n        console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n        return this;\n      }\n\n      var position = attributes.position;\n      var normal = attributes.normal;\n      var color = attributes.color;\n      var uv = attributes.uv;\n      var uv2 = attributes.uv2;\n      if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n\n      for (var i = 0; i < position.count; i++) {\n        scope.vertices.push(new _three.Vector3().fromBufferAttribute(position, i));\n\n        if (color !== undefined) {\n          scope.colors.push(new _three.Color().fromBufferAttribute(color, i));\n        }\n      }\n\n      function addFace(a, b, c, materialIndex) {\n        var vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n        var vertexNormals = normal === undefined ? [] : [new _three.Vector3().fromBufferAttribute(normal, a), new _three.Vector3().fromBufferAttribute(normal, b), new _three.Vector3().fromBufferAttribute(normal, c)];\n        var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n        scope.faces.push(face);\n\n        if (uv !== undefined) {\n          scope.faceVertexUvs[0].push([new _three.Vector2().fromBufferAttribute(uv, a), new _three.Vector2().fromBufferAttribute(uv, b), new _three.Vector2().fromBufferAttribute(uv, c)]);\n        }\n\n        if (uv2 !== undefined) {\n          scope.faceVertexUvs[1].push([new _three.Vector2().fromBufferAttribute(uv2, a), new _three.Vector2().fromBufferAttribute(uv2, b), new _three.Vector2().fromBufferAttribute(uv2, c)]);\n        }\n      }\n\n      var groups = geometry.groups;\n\n      if (groups.length > 0) {\n        for (var _i2 = 0; _i2 < groups.length; _i2++) {\n          var group = groups[_i2];\n          var start = group.start;\n          var count = group.count;\n\n          for (var j = start, jl = start + count; j < jl; j += 3) {\n            if (index !== undefined) {\n              addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n            } else {\n              addFace(j, j + 1, j + 2, group.materialIndex);\n            }\n          }\n        }\n      } else {\n        if (index !== undefined) {\n          for (var _i3 = 0; _i3 < index.count; _i3 += 3) {\n            addFace(index.getX(_i3), index.getX(_i3 + 1), index.getX(_i3 + 2));\n          }\n        } else {\n          for (var _i4 = 0; _i4 < position.count; _i4 += 3) {\n            addFace(_i4, _i4 + 1, _i4 + 2);\n          }\n        }\n      }\n\n      this.computeFaceNormals();\n\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"center\",\n    value: function center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      this.computeBoundingSphere();\n      var center = this.boundingSphere.center;\n      var radius = this.boundingSphere.radius;\n      var s = radius === 0 ? 1 : 1.0 / radius;\n      var matrix = new _three.Matrix4();\n      matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n      this.applyMatrix4(matrix);\n      return this;\n    }\n  }, {\n    key: \"computeFaceNormals\",\n    value: function computeFaceNormals() {\n      var cb = new _three.Vector3(),\n          ab = new _three.Vector3();\n\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        var vA = this.vertices[face.a];\n        var vB = this.vertices[face.b];\n        var vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n      }\n    }\n  }, {\n    key: \"computeVertexNormals\",\n    value: function computeVertexNormals() {\n      var areaWeighted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var vertices = new Array(this.vertices.length);\n\n      for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n        vertices[v] = new _three.Vector3();\n      }\n\n      if (areaWeighted) {\n        // vertex normals weighted by triangle areas\n        // http://www.iquilezles.org/www/articles/normals/normals.htm\n        var cb = new _three.Vector3(),\n            ab = new _three.Vector3();\n\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n          var face = this.faces[f];\n          var vA = this.vertices[face.a];\n          var vB = this.vertices[face.b];\n          var vC = this.vertices[face.c];\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          vertices[face.a].add(cb);\n          vertices[face.b].add(cb);\n          vertices[face.c].add(cb);\n        }\n      } else {\n        this.computeFaceNormals();\n\n        for (var _f = 0, _fl = this.faces.length; _f < _fl; _f++) {\n          var _face = this.faces[_f];\n\n          vertices[_face.a].add(_face.normal);\n\n          vertices[_face.b].add(_face.normal);\n\n          vertices[_face.c].add(_face.normal);\n        }\n      }\n\n      for (var _v = 0, _vl = this.vertices.length; _v < _vl; _v++) {\n        vertices[_v].normalize();\n      }\n\n      for (var _f2 = 0, _fl2 = this.faces.length; _f2 < _fl2; _f2++) {\n        var _face2 = this.faces[_f2];\n        var vertexNormals = _face2.vertexNormals;\n\n        if (vertexNormals.length === 3) {\n          vertexNormals[0].copy(vertices[_face2.a]);\n          vertexNormals[1].copy(vertices[_face2.b]);\n          vertexNormals[2].copy(vertices[_face2.c]);\n        } else {\n          vertexNormals[0] = vertices[_face2.a].clone();\n          vertexNormals[1] = vertices[_face2.b].clone();\n          vertexNormals[2] = vertices[_face2.c].clone();\n        }\n      }\n\n      if (this.faces.length > 0) {\n        this.normalsNeedUpdate = true;\n      }\n    }\n  }, {\n    key: \"computeFlatVertexNormals\",\n    value: function computeFlatVertexNormals() {\n      this.computeFaceNormals();\n\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        var vertexNormals = face.vertexNormals;\n\n        if (vertexNormals.length === 3) {\n          vertexNormals[0].copy(face.normal);\n          vertexNormals[1].copy(face.normal);\n          vertexNormals[2].copy(face.normal);\n        } else {\n          vertexNormals[0] = face.normal.clone();\n          vertexNormals[1] = face.normal.clone();\n          vertexNormals[2] = face.normal.clone();\n        }\n      }\n\n      if (this.faces.length > 0) {\n        this.normalsNeedUpdate = true;\n      }\n    }\n  }, {\n    key: \"computeMorphNormals\",\n    value: function computeMorphNormals() {\n      // save original normals\n      // - create temp variables on first access\n      //   otherwise just copy (for faster repeated calls)\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n\n        if (!face.__originalFaceNormal) {\n          face.__originalFaceNormal = face.normal.clone();\n        } else {\n          face.__originalFaceNormal.copy(face.normal);\n        }\n\n        if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n        for (var i = 0, il = face.vertexNormals.length; i < il; i++) {\n          if (!face.__originalVertexNormals[i]) {\n            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n          } else {\n            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n          }\n        }\n      } // use temp geometry to compute face and vertex normals for each morph\n\n\n      var tmpGeo = new Geometry();\n      tmpGeo.faces = this.faces;\n\n      for (var _i5 = 0, _il2 = this.morphTargets.length; _i5 < _il2; _i5++) {\n        // create on first access\n        if (!this.morphNormals[_i5]) {\n          this.morphNormals[_i5] = {};\n          this.morphNormals[_i5].faceNormals = [];\n          this.morphNormals[_i5].vertexNormals = [];\n          var dstNormalsFace = this.morphNormals[_i5].faceNormals;\n          var dstNormalsVertex = this.morphNormals[_i5].vertexNormals;\n\n          for (var _f3 = 0, _fl3 = this.faces.length; _f3 < _fl3; _f3++) {\n            var faceNormal = new _three.Vector3();\n            var vertexNormals = {\n              a: new _three.Vector3(),\n              b: new _three.Vector3(),\n              c: new _three.Vector3()\n            };\n            dstNormalsFace.push(faceNormal);\n            dstNormalsVertex.push(vertexNormals);\n          }\n        }\n\n        var morphNormals = this.morphNormals[_i5]; // set vertices to morph target\n\n        tmpGeo.vertices = this.morphTargets[_i5].vertices; // compute morph normals\n\n        tmpGeo.computeFaceNormals();\n        tmpGeo.computeVertexNormals(); // store morph normals\n\n        for (var _f4 = 0, _fl4 = this.faces.length; _f4 < _fl4; _f4++) {\n          var _face3 = this.faces[_f4];\n          var _faceNormal = morphNormals.faceNormals[_f4];\n          var _vertexNormals = morphNormals.vertexNormals[_f4];\n\n          _faceNormal.copy(_face3.normal);\n\n          _vertexNormals.a.copy(_face3.vertexNormals[0]);\n\n          _vertexNormals.b.copy(_face3.vertexNormals[1]);\n\n          _vertexNormals.c.copy(_face3.vertexNormals[2]);\n        }\n      } // restore original normals\n\n\n      for (var _f5 = 0, _fl5 = this.faces.length; _f5 < _fl5; _f5++) {\n        var _face4 = this.faces[_f5];\n        _face4.normal = _face4.__originalFaceNormal;\n        _face4.vertexNormals = _face4.__originalVertexNormals;\n      }\n    }\n  }, {\n    key: \"computeBoundingBox\",\n    value: function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new _three.Box3();\n      }\n\n      this.boundingBox.setFromPoints(this.vertices);\n    }\n  }, {\n    key: \"computeBoundingSphere\",\n    value: function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new _three.Sphere();\n      }\n\n      this.boundingSphere.setFromPoints(this.vertices);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(geometry, matrix) {\n      var materialIndexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (!(geometry && geometry.isGeometry)) {\n        console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n        return;\n      }\n\n      var normalMatrix;\n      var vertexOffset = this.vertices.length,\n          vertices1 = this.vertices,\n          vertices2 = geometry.vertices,\n          faces1 = this.faces,\n          faces2 = geometry.faces,\n          colors1 = this.colors,\n          colors2 = geometry.colors;\n\n      if (matrix !== undefined) {\n        normalMatrix = new _three.Matrix3().getNormalMatrix(matrix);\n      } // vertices\n\n\n      for (var i = 0, il = vertices2.length; i < il; i++) {\n        var vertex = vertices2[i];\n        var vertexCopy = vertex.clone();\n        if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n        vertices1.push(vertexCopy);\n      } // colors\n\n\n      for (var _i6 = 0, _il3 = colors2.length; _i6 < _il3; _i6++) {\n        colors1.push(colors2[_i6].clone());\n      } // faces\n\n\n      for (var _i7 = 0, _il4 = faces2.length; _i7 < _il4; _i7++) {\n        var face = faces2[_i7];\n        var normal = void 0,\n            color = void 0;\n        var faceVertexNormals = face.vertexNormals,\n            faceVertexColors = face.vertexColors;\n        var faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n        faceCopy.normal.copy(face.normal);\n\n        if (normalMatrix !== undefined) {\n          faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n          normal = faceVertexNormals[j].clone();\n\n          if (normalMatrix !== undefined) {\n            normal.applyMatrix3(normalMatrix).normalize();\n          }\n\n          faceCopy.vertexNormals.push(normal);\n        }\n\n        faceCopy.color.copy(face.color);\n\n        for (var _j = 0, _jl = faceVertexColors.length; _j < _jl; _j++) {\n          color = faceVertexColors[_j];\n          faceCopy.vertexColors.push(color.clone());\n        }\n\n        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n        faces1.push(faceCopy);\n      } // uvs\n\n\n      for (var _i8 = 0, _il5 = geometry.faceVertexUvs.length; _i8 < _il5; _i8++) {\n        var faceVertexUvs2 = geometry.faceVertexUvs[_i8];\n        if (this.faceVertexUvs[_i8] === undefined) this.faceVertexUvs[_i8] = [];\n\n        for (var _j2 = 0, _jl2 = faceVertexUvs2.length; _j2 < _jl2; _j2++) {\n          var uvs2 = faceVertexUvs2[_j2],\n              uvsCopy = [];\n\n          for (var k = 0, kl = uvs2.length; k < kl; k++) {\n            uvsCopy.push(uvs2[k].clone());\n          }\n\n          this.faceVertexUvs[_i8].push(uvsCopy);\n        }\n      }\n    }\n  }, {\n    key: \"mergeMesh\",\n    value: function mergeMesh(mesh) {\n      if (!(mesh && mesh.isMesh)) {\n        console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n        return;\n      }\n\n      if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n      this.merge(mesh.geometry, mesh.matrix);\n    }\n    /*\n     * Checks for duplicate vertices with hashmap.\n     * Duplicated vertices are removed\n     * and faces' vertices are updated.\n     */\n\n  }, {\n    key: \"mergeVertices\",\n    value: function mergeVertices() {\n      var precisionPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n      var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n      var unique = [],\n          changes = [];\n      var precision = Math.pow(10, precisionPoints);\n\n      for (var i = 0, il = this.vertices.length; i < il; i++) {\n        var v = this.vertices[i];\n        var key = \"\".concat(Math.round(v.x * precision), \"_\").concat(Math.round(v.y * precision), \"_\").concat(Math.round(v.z * precision));\n\n        if (verticesMap[key] === undefined) {\n          verticesMap[key] = i;\n          unique.push(this.vertices[i]);\n          changes[i] = unique.length - 1;\n        } else {\n          //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n          changes[i] = changes[verticesMap[key]];\n        }\n      } // if faces are completely degenerate after merging vertices, we\n      // have to remove them from the geometry.\n\n\n      var faceIndicesToRemove = [];\n\n      for (var _i9 = 0, _il6 = this.faces.length; _i9 < _il6; _i9++) {\n        var face = this.faces[_i9];\n        face.a = changes[face.a];\n        face.b = changes[face.b];\n        face.c = changes[face.c];\n        var indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n        // we have to remove the face as nothing can be saved\n\n        for (var n = 0; n < 3; n++) {\n          if (indices[n] === indices[(n + 1) % 3]) {\n            faceIndicesToRemove.push(_i9);\n            break;\n          }\n        }\n      }\n\n      for (var _i10 = faceIndicesToRemove.length - 1; _i10 >= 0; _i10--) {\n        var idx = faceIndicesToRemove[_i10];\n        this.faces.splice(idx, 1);\n\n        for (var j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n          this.faceVertexUvs[j].splice(idx, 1);\n        }\n      } // Use unique set of vertices\n\n\n      var diff = this.vertices.length - unique.length;\n      this.vertices = unique;\n      return diff;\n    }\n  }, {\n    key: \"setFromPoints\",\n    value: function setFromPoints(points) {\n      this.vertices = [];\n\n      for (var i = 0, l = points.length; i < l; i++) {\n        var point = points[i];\n        this.vertices.push(new _three.Vector3(point.x, point.y, point.z || 0));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"sortFacesByMaterialIndex\",\n    value: function sortFacesByMaterialIndex() {\n      var faces = this.faces;\n      var length = faces.length; // tag faces\n\n      for (var i = 0; i < length; i++) {\n        faces[i]._id = i;\n      } // sort faces\n\n\n      function materialIndexSort(a, b) {\n        return a.materialIndex - b.materialIndex;\n      }\n\n      faces.sort(materialIndexSort); // sort uvs\n\n      var uvs1 = this.faceVertexUvs[0];\n      var uvs2 = this.faceVertexUvs[1];\n      var newUvs1, newUvs2;\n      if (uvs1 && uvs1.length === length) newUvs1 = [];\n      if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n      for (var _i11 = 0; _i11 < length; _i11++) {\n        var id = faces[_i11]._id;\n        if (newUvs1) newUvs1.push(uvs1[id]);\n        if (newUvs2) newUvs2.push(uvs2[id]);\n      }\n\n      if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n      if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = {\n        metadata: {\n          version: 4.5,\n          type: 'Geometry',\n          generator: 'Geometry.toJSON'\n        }\n      }; // standard Geometry serialization\n\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== '') data.name = this.name;\n\n      if (this.parameters !== undefined) {\n        var parameters = this.parameters;\n\n        for (var key in parameters) {\n          if (parameters[key] !== undefined) data[key] = parameters[key];\n        }\n\n        return data;\n      }\n\n      var vertices = [];\n\n      for (var i = 0; i < this.vertices.length; i++) {\n        var vertex = this.vertices[i];\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n\n      var faces = [];\n      var normals = [];\n      var normalsHash = {};\n      var colors = [];\n      var colorsHash = {};\n      var uvs = [];\n      var uvsHash = {};\n\n      for (var _i12 = 0; _i12 < this.faces.length; _i12++) {\n        var face = this.faces[_i12];\n        var hasMaterial = true;\n        var hasFaceUv = false; // deprecated\n\n        var hasFaceVertexUv = this.faceVertexUvs[0][_i12] !== undefined;\n        var hasFaceNormal = face.normal.length() > 0;\n        var hasFaceVertexNormal = face.vertexNormals.length > 0;\n        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n        var hasFaceVertexColor = face.vertexColors.length > 0;\n        var faceType = 0;\n        faceType = setBit(faceType, 0, 0); // isQuad\n\n        faceType = setBit(faceType, 1, hasMaterial);\n        faceType = setBit(faceType, 2, hasFaceUv);\n        faceType = setBit(faceType, 3, hasFaceVertexUv);\n        faceType = setBit(faceType, 4, hasFaceNormal);\n        faceType = setBit(faceType, 5, hasFaceVertexNormal);\n        faceType = setBit(faceType, 6, hasFaceColor);\n        faceType = setBit(faceType, 7, hasFaceVertexColor);\n        faces.push(faceType);\n        faces.push(face.a, face.b, face.c);\n        faces.push(face.materialIndex);\n\n        if (hasFaceVertexUv) {\n          var faceVertexUvs = this.faceVertexUvs[0][_i12];\n          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n        }\n\n        if (hasFaceNormal) {\n          faces.push(getNormalIndex(face.normal));\n        }\n\n        if (hasFaceVertexNormal) {\n          var vertexNormals = face.vertexNormals;\n          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n        }\n\n        if (hasFaceColor) {\n          faces.push(getColorIndex(face.color));\n        }\n\n        if (hasFaceVertexColor) {\n          var vertexColors = face.vertexColors;\n          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n        }\n      }\n\n      function setBit(value, position, enabled) {\n        return enabled ? value | 1 << position : value & ~(1 << position);\n      }\n\n      function getNormalIndex(normal) {\n        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n        if (normalsHash[hash] !== undefined) {\n          return normalsHash[hash];\n        }\n\n        normalsHash[hash] = normals.length / 3;\n        normals.push(normal.x, normal.y, normal.z);\n        return normalsHash[hash];\n      }\n\n      function getColorIndex(color) {\n        var hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n        if (colorsHash[hash] !== undefined) {\n          return colorsHash[hash];\n        }\n\n        colorsHash[hash] = colors.length;\n        colors.push(color.getHex());\n        return colorsHash[hash];\n      }\n\n      function getUvIndex(uv) {\n        var hash = uv.x.toString() + uv.y.toString();\n\n        if (uvsHash[hash] !== undefined) {\n          return uvsHash[hash];\n        }\n\n        uvsHash[hash] = uvs.length / 2;\n        uvs.push(uv.x, uv.y);\n        return uvsHash[hash];\n      }\n\n      data.data = {};\n      data.data.vertices = vertices;\n      data.data.normals = normals;\n      if (colors.length > 0) data.data.colors = colors;\n      if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n      data.data.faces = faces;\n      return data;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      /*\n      // Handle primitives\n      const parameters = this.parameters;\n      if ( parameters !== undefined ) {\n      const values = [];\n      for ( const key in parameters ) {\n      values.push( parameters[ key ] );\n      }\n      const geometry = Object.create( this.constructor.prototype );\n      this.constructor.apply( geometry, values );\n      return geometry;\n      }\n      return new this.constructor().copy( this );\n      */\n      return new Geometry().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      // reset\n      this.vertices = [];\n      this.colors = [];\n      this.faces = [];\n      this.faceVertexUvs = [[]];\n      this.morphTargets = [];\n      this.morphNormals = [];\n      this.skinWeights = [];\n      this.skinIndices = [];\n      this.lineDistances = [];\n      this.boundingBox = null;\n      this.boundingSphere = null; // name\n\n      this.name = source.name; // vertices\n\n      var vertices = source.vertices;\n\n      for (var i = 0, il = vertices.length; i < il; i++) {\n        this.vertices.push(vertices[i].clone());\n      } // colors\n\n\n      var colors = source.colors;\n\n      for (var _i13 = 0, _il7 = colors.length; _i13 < _il7; _i13++) {\n        this.colors.push(colors[_i13].clone());\n      } // faces\n\n\n      var faces = source.faces;\n\n      for (var _i14 = 0, _il8 = faces.length; _i14 < _il8; _i14++) {\n        this.faces.push(faces[_i14].clone());\n      } // face vertex uvs\n\n\n      for (var _i15 = 0, _il9 = source.faceVertexUvs.length; _i15 < _il9; _i15++) {\n        var faceVertexUvs = source.faceVertexUvs[_i15];\n\n        if (this.faceVertexUvs[_i15] === undefined) {\n          this.faceVertexUvs[_i15] = [];\n        }\n\n        for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n          var uvs = faceVertexUvs[j],\n              uvsCopy = [];\n\n          for (var k = 0, kl = uvs.length; k < kl; k++) {\n            var uv = uvs[k];\n            uvsCopy.push(uv.clone());\n          }\n\n          this.faceVertexUvs[_i15].push(uvsCopy);\n        }\n      } // morph targets\n\n\n      var morphTargets = source.morphTargets;\n\n      for (var _i16 = 0, _il10 = morphTargets.length; _i16 < _il10; _i16++) {\n        var morphTarget = {};\n        morphTarget.name = morphTargets[_i16].name; // vertices\n\n        if (morphTargets[_i16].vertices !== undefined) {\n          morphTarget.vertices = [];\n\n          for (var _j3 = 0, _jl3 = morphTargets[_i16].vertices.length; _j3 < _jl3; _j3++) {\n            morphTarget.vertices.push(morphTargets[_i16].vertices[_j3].clone());\n          }\n        } // normals\n\n\n        if (morphTargets[_i16].normals !== undefined) {\n          morphTarget.normals = [];\n\n          for (var _j4 = 0, _jl4 = morphTargets[_i16].normals.length; _j4 < _jl4; _j4++) {\n            morphTarget.normals.push(morphTargets[_i16].normals[_j4].clone());\n          }\n        }\n\n        this.morphTargets.push(morphTarget);\n      } // morph normals\n\n\n      var morphNormals = source.morphNormals;\n\n      for (var _i17 = 0, _il11 = morphNormals.length; _i17 < _il11; _i17++) {\n        var morphNormal = {}; // vertex normals\n\n        if (morphNormals[_i17].vertexNormals !== undefined) {\n          morphNormal.vertexNormals = [];\n\n          for (var _j5 = 0, _jl5 = morphNormals[_i17].vertexNormals.length; _j5 < _jl5; _j5++) {\n            var srcVertexNormal = morphNormals[_i17].vertexNormals[_j5];\n            var destVertexNormal = {};\n            destVertexNormal.a = srcVertexNormal.a.clone();\n            destVertexNormal.b = srcVertexNormal.b.clone();\n            destVertexNormal.c = srcVertexNormal.c.clone();\n            morphNormal.vertexNormals.push(destVertexNormal);\n          }\n        } // face normals\n\n\n        if (morphNormals[_i17].faceNormals !== undefined) {\n          morphNormal.faceNormals = [];\n\n          for (var _j6 = 0, _jl6 = morphNormals[_i17].faceNormals.length; _j6 < _jl6; _j6++) {\n            morphNormal.faceNormals.push(morphNormals[_i17].faceNormals[_j6].clone());\n          }\n        }\n\n        this.morphNormals.push(morphNormal);\n      } // skin weights\n\n\n      var skinWeights = source.skinWeights;\n\n      for (var _i18 = 0, _il12 = skinWeights.length; _i18 < _il12; _i18++) {\n        this.skinWeights.push(skinWeights[_i18].clone());\n      } // skin indices\n\n\n      var skinIndices = source.skinIndices;\n\n      for (var _i19 = 0, _il13 = skinIndices.length; _i19 < _il13; _i19++) {\n        this.skinIndices.push(skinIndices[_i19].clone());\n      } // line distances\n\n\n      var lineDistances = source.lineDistances;\n\n      for (var _i20 = 0, _il14 = lineDistances.length; _i20 < _il14; _i20++) {\n        this.lineDistances.push(lineDistances[_i20]);\n      } // bounding box\n\n\n      var boundingBox = source.boundingBox;\n\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      } // bounding sphere\n\n\n      var boundingSphere = source.boundingSphere;\n\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      } // update flags\n\n\n      this.elementsNeedUpdate = source.elementsNeedUpdate;\n      this.verticesNeedUpdate = source.verticesNeedUpdate;\n      this.uvsNeedUpdate = source.uvsNeedUpdate;\n      this.normalsNeedUpdate = source.normalsNeedUpdate;\n      this.colorsNeedUpdate = source.colorsNeedUpdate;\n      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n      this.groupsNeedUpdate = source.groupsNeedUpdate;\n      return this;\n    }\n  }, {\n    key: \"toBufferGeometry\",\n    value: function toBufferGeometry() {\n      var geometry = new DirectGeometry().fromGeometry(this);\n      var buffergeometry = new _three.BufferGeometry();\n      var positions = new Float32Array(geometry.vertices.length * 3);\n      buffergeometry.setAttribute('position', new _three.BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n      if (geometry.normals.length > 0) {\n        var normals = new Float32Array(geometry.normals.length * 3);\n        buffergeometry.setAttribute('normal', new _three.BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n      }\n\n      if (geometry.colors.length > 0) {\n        var colors = new Float32Array(geometry.colors.length * 3);\n        buffergeometry.setAttribute('color', new _three.BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n      }\n\n      if (geometry.uvs.length > 0) {\n        var uvs = new Float32Array(geometry.uvs.length * 2);\n        buffergeometry.setAttribute('uv', new _three.BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n      }\n\n      if (geometry.uvs2.length > 0) {\n        var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n        buffergeometry.setAttribute('uv2', new _three.BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n      } // groups\n\n\n      buffergeometry.groups = geometry.groups; // morphs\n\n      for (var name in geometry.morphTargets) {\n        var array = [];\n        var morphTargets = geometry.morphTargets[name];\n\n        for (var i = 0, l = morphTargets.length; i < l; i++) {\n          var morphTarget = morphTargets[i];\n          var attribute = new _three.Float32BufferAttribute(morphTarget.data.length * 3, 3);\n          attribute.name = morphTarget.name;\n          array.push(attribute.copyVector3sArray(morphTarget.data));\n        }\n\n        buffergeometry.morphAttributes[name] = array;\n      } // skinning\n\n\n      if (geometry.skinIndices.length > 0) {\n        var skinIndices = new _three.Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n        buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n      }\n\n      if (geometry.skinWeights.length > 0) {\n        var skinWeights = new _three.Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n        buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n      } //\n\n\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n\n      return buffergeometry;\n    }\n  }, {\n    key: \"computeTangents\",\n    value: function computeTangents() {\n      console.error('THREE.Geometry: .computeTangents() has been removed.');\n    }\n  }, {\n    key: \"computeLineDistances\",\n    value: function computeLineDistances() {\n      console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n    }\n  }, {\n    key: \"applyMatrix\",\n    value: function applyMatrix(matrix) {\n      console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n      return this.applyMatrix4(matrix);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: 'dispose'\n      });\n    }\n  }]);\n\n  return Geometry;\n}(_three.EventDispatcher);\n\nexports.Geometry = Geometry;\n\nGeometry.createBufferGeometryFromObject = function (object) {\n  var buffergeometry = new _three.BufferGeometry();\n  var geometry = object.geometry;\n\n  if (object.isPoints || object.isLine) {\n    var positions = new _three.Float32BufferAttribute(geometry.vertices.length * 3, 3);\n    var colors = new _three.Float32BufferAttribute(geometry.colors.length * 3, 3);\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n      var lineDistances = new _three.Float32BufferAttribute(geometry.lineDistances.length, 1);\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n    }\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n  } else if (object.isMesh) {\n    buffergeometry = geometry.toBufferGeometry();\n  }\n\n  return buffergeometry;\n};\n\nvar DirectGeometry =\n/*#__PURE__*/\nfunction () {\n  function DirectGeometry() {\n    _classCallCheck(this, DirectGeometry);\n\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  _createClass(DirectGeometry, [{\n    key: \"computeGroups\",\n    value: function computeGroups(geometry) {\n      var groups = [];\n      var group, i;\n      var materialIndex = undefined;\n      var faces = geometry.faces;\n\n      for (i = 0; i < faces.length; i++) {\n        var face = faces[i]; // materials\n\n        if (face.materialIndex !== materialIndex) {\n          materialIndex = face.materialIndex;\n\n          if (group !== undefined) {\n            group.count = i * 3 - group.start;\n            groups.push(group);\n          }\n\n          group = {\n            start: i * 3,\n            materialIndex: materialIndex\n          };\n        }\n      }\n\n      if (group !== undefined) {\n        group.count = i * 3 - group.start;\n        groups.push(group);\n      }\n\n      this.groups = groups;\n    }\n  }, {\n    key: \"fromGeometry\",\n    value: function fromGeometry(geometry) {\n      var faces = geometry.faces;\n      var vertices = geometry.vertices;\n      var faceVertexUvs = geometry.faceVertexUvs;\n      var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n      var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n      var morphTargets = geometry.morphTargets;\n      var morphTargetsLength = morphTargets.length;\n      var morphTargetsPosition;\n\n      if (morphTargetsLength > 0) {\n        morphTargetsPosition = [];\n\n        for (var i = 0; i < morphTargetsLength; i++) {\n          morphTargetsPosition[i] = {\n            name: morphTargets[i].name,\n            data: []\n          };\n        }\n\n        this.morphTargets.position = morphTargetsPosition;\n      }\n\n      var morphNormals = geometry.morphNormals;\n      var morphNormalsLength = morphNormals.length;\n      var morphTargetsNormal;\n\n      if (morphNormalsLength > 0) {\n        morphTargetsNormal = [];\n\n        for (var _i21 = 0; _i21 < morphNormalsLength; _i21++) {\n          morphTargetsNormal[_i21] = {\n            name: morphNormals[_i21].name,\n            data: []\n          };\n        }\n\n        this.morphTargets.normal = morphTargetsNormal;\n      } // skins\n\n\n      var skinIndices = geometry.skinIndices;\n      var skinWeights = geometry.skinWeights;\n      var hasSkinIndices = skinIndices.length === vertices.length;\n      var hasSkinWeights = skinWeights.length === vertices.length; //\n\n      if (vertices.length > 0 && faces.length === 0) {\n        console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n      }\n\n      for (var _i22 = 0; _i22 < faces.length; _i22++) {\n        var face = faces[_i22];\n        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n        var vertexNormals = face.vertexNormals;\n\n        if (vertexNormals.length === 3) {\n          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n        } else {\n          var normal = face.normal;\n          this.normals.push(normal, normal, normal);\n        }\n\n        var vertexColors = face.vertexColors;\n\n        if (vertexColors.length === 3) {\n          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n        } else {\n          var color = face.color;\n          this.colors.push(color, color, color);\n        }\n\n        if (hasFaceVertexUv === true) {\n          var vertexUvs = faceVertexUvs[0][_i22];\n\n          if (vertexUvs !== undefined) {\n            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n          } else {\n            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', _i22);\n            this.uvs.push(new _three.Vector2(), new _three.Vector2(), new _three.Vector2());\n          }\n        }\n\n        if (hasFaceVertexUv2 === true) {\n          var _vertexUvs = faceVertexUvs[1][_i22];\n\n          if (_vertexUvs !== undefined) {\n            this.uvs2.push(_vertexUvs[0], _vertexUvs[1], _vertexUvs[2]);\n          } else {\n            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', _i22);\n            this.uvs2.push(new _three.Vector2(), new _three.Vector2(), new _three.Vector2());\n          }\n        } // morphs\n\n\n        for (var j = 0; j < morphTargetsLength; j++) {\n          var morphTarget = morphTargets[j].vertices;\n          morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n        }\n\n        for (var _j7 = 0; _j7 < morphNormalsLength; _j7++) {\n          var morphNormal = morphNormals[_j7].vertexNormals[_i22];\n\n          morphTargetsNormal[_j7].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n        } // skins\n\n\n        if (hasSkinIndices) {\n          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n        }\n\n        if (hasSkinWeights) {\n          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n        }\n      }\n\n      this.computeGroups(geometry);\n      this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n      this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n      this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n      this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n      this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n\n      return this;\n    }\n  }]);\n\n  return DirectGeometry;\n}();\n\nvar Face3 =\n/*#__PURE__*/\nfunction () {\n  function Face3(a, b, c, normal, color) {\n    var materialIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    _classCallCheck(this, Face3);\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new _three.Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new _three.Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n\n  _createClass(Face3, [{\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      this.a = source.a;\n      this.b = source.b;\n      this.c = source.c;\n      this.normal.copy(source.normal);\n      this.color.copy(source.color);\n      this.materialIndex = source.materialIndex;\n\n      for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\n        this.vertexNormals[i] = source.vertexNormals[i].clone();\n      }\n\n      for (var _i23 = 0, _il15 = source.vertexColors.length; _i23 < _il15; _i23++) {\n        this.vertexColors[_i23] = source.vertexColors[_i23].clone();\n      }\n\n      return this;\n    }\n  }]);\n\n  return Face3;\n}();\n\nexports.Face3 = Face3;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["groupsNeedUpdate","prototype","uvs","Geometry","key","__esModule","colorsNeedUpdate","Face3","faceNormals","vertexNormals","count","normal","skinIndices","lineDistances","position","normals","name","boundingSphere","configurable","uuid","normalsNeedUpdate","value","faceVertexUvs","enumerable","vertices","materialIndex","boundingBox","isGeometry","vertexColors","start","a","faces","writable","metadata","elementsNeedUpdate","skinWeights","uvs2","type","b","version","__proto__","_id","__originalVertexNormals","generator","morphTargets","lineDistancesNeedUpdate","verticesNeedUpdate","createBufferGeometryFromObject","__originalFaceNormal","colors","uvsNeedUpdate","data","color","groups","c","morphNormals","constructor"]],"~:compiled-at",1630917516070,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$deprecated$Geometry.js\",\n\"lineCount\":57,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/deprecated/Geometry.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$deprecated$Geometry\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.Geometry = exports.Face3 = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar _m1 = new _three.Matrix4();\\n\\nvar _obj = new _three.Object3D();\\n\\nvar _offset = new _three.Vector3();\\n\\nvar Geometry =\\n/*#__PURE__*/\\nfunction (_EventDispatcher) {\\n  _inherits(Geometry, _EventDispatcher);\\n\\n  function Geometry() {\\n    var _this;\\n\\n    _classCallCheck(this, Geometry);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Geometry).call(this));\\n    _this.isGeometry = true;\\n    _this.uuid = _three.MathUtils.generateUUID();\\n    _this.name = '';\\n    _this.type = 'Geometry';\\n    _this.vertices = [];\\n    _this.colors = [];\\n    _this.faces = [];\\n    _this.faceVertexUvs = [[]];\\n    _this.morphTargets = [];\\n    _this.morphNormals = [];\\n    _this.skinWeights = [];\\n    _this.skinIndices = [];\\n    _this.lineDistances = [];\\n    _this.boundingBox = null;\\n    _this.boundingSphere = null; // update flags\\n\\n    _this.elementsNeedUpdate = false;\\n    _this.verticesNeedUpdate = false;\\n    _this.uvsNeedUpdate = false;\\n    _this.normalsNeedUpdate = false;\\n    _this.colorsNeedUpdate = false;\\n    _this.lineDistancesNeedUpdate = false;\\n    _this.groupsNeedUpdate = false;\\n    return _this;\\n  }\\n\\n  _createClass(Geometry, [{\\n    key: \\\"applyMatrix4\\\",\\n    value: function applyMatrix4(matrix) {\\n      var normalMatrix = new _three.Matrix3().getNormalMatrix(matrix);\\n\\n      for (var i = 0, il = this.vertices.length; i < il; i++) {\\n        var vertex = this.vertices[i];\\n        vertex.applyMatrix4(matrix);\\n      }\\n\\n      for (var _i = 0, _il = this.faces.length; _i < _il; _i++) {\\n        var face = this.faces[_i];\\n        face.normal.applyMatrix3(normalMatrix).normalize();\\n\\n        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\\n          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\\n        }\\n      }\\n\\n      if (this.boundingBox !== null) {\\n        this.computeBoundingBox();\\n      }\\n\\n      if (this.boundingSphere !== null) {\\n        this.computeBoundingSphere();\\n      }\\n\\n      this.verticesNeedUpdate = true;\\n      this.normalsNeedUpdate = true;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"rotateX\\\",\\n    value: function rotateX(angle) {\\n      // rotate geometry around world x-axis\\n      _m1.makeRotationX(angle);\\n\\n      this.applyMatrix4(_m1);\\n      return this;\\n    }\\n  }, {\\n    key: \\\"rotateY\\\",\\n    value: function rotateY(angle) {\\n      // rotate geometry around world y-axis\\n      _m1.makeRotationY(angle);\\n\\n      this.applyMatrix4(_m1);\\n      return this;\\n    }\\n  }, {\\n    key: \\\"rotateZ\\\",\\n    value: function rotateZ(angle) {\\n      // rotate geometry around world z-axis\\n      _m1.makeRotationZ(angle);\\n\\n      this.applyMatrix4(_m1);\\n      return this;\\n    }\\n  }, {\\n    key: \\\"translate\\\",\\n    value: function translate(x, y, z) {\\n      // translate geometry\\n      _m1.makeTranslation(x, y, z);\\n\\n      this.applyMatrix4(_m1);\\n      return this;\\n    }\\n  }, {\\n    key: \\\"scale\\\",\\n    value: function scale(x, y, z) {\\n      // scale geometry\\n      _m1.makeScale(x, y, z);\\n\\n      this.applyMatrix4(_m1);\\n      return this;\\n    }\\n  }, {\\n    key: \\\"lookAt\\\",\\n    value: function lookAt(vector) {\\n      _obj.lookAt(vector);\\n\\n      _obj.updateMatrix();\\n\\n      this.applyMatrix4(_obj.matrix);\\n      return this;\\n    }\\n  }, {\\n    key: \\\"fromBufferGeometry\\\",\\n    value: function fromBufferGeometry(geometry) {\\n      var scope = this;\\n      var index = geometry.index !== null ? geometry.index : undefined;\\n      var attributes = geometry.attributes;\\n\\n      if (attributes.position === undefined) {\\n        console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\\n        return this;\\n      }\\n\\n      var position = attributes.position;\\n      var normal = attributes.normal;\\n      var color = attributes.color;\\n      var uv = attributes.uv;\\n      var uv2 = attributes.uv2;\\n      if (uv2 !== undefined) this.faceVertexUvs[1] = [];\\n\\n      for (var i = 0; i < position.count; i++) {\\n        scope.vertices.push(new _three.Vector3().fromBufferAttribute(position, i));\\n\\n        if (color !== undefined) {\\n          scope.colors.push(new _three.Color().fromBufferAttribute(color, i));\\n        }\\n      }\\n\\n      function addFace(a, b, c, materialIndex) {\\n        var vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\\n        var vertexNormals = normal === undefined ? [] : [new _three.Vector3().fromBufferAttribute(normal, a), new _three.Vector3().fromBufferAttribute(normal, b), new _three.Vector3().fromBufferAttribute(normal, c)];\\n        var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\\n        scope.faces.push(face);\\n\\n        if (uv !== undefined) {\\n          scope.faceVertexUvs[0].push([new _three.Vector2().fromBufferAttribute(uv, a), new _three.Vector2().fromBufferAttribute(uv, b), new _three.Vector2().fromBufferAttribute(uv, c)]);\\n        }\\n\\n        if (uv2 !== undefined) {\\n          scope.faceVertexUvs[1].push([new _three.Vector2().fromBufferAttribute(uv2, a), new _three.Vector2().fromBufferAttribute(uv2, b), new _three.Vector2().fromBufferAttribute(uv2, c)]);\\n        }\\n      }\\n\\n      var groups = geometry.groups;\\n\\n      if (groups.length > 0) {\\n        for (var _i2 = 0; _i2 < groups.length; _i2++) {\\n          var group = groups[_i2];\\n          var start = group.start;\\n          var count = group.count;\\n\\n          for (var j = start, jl = start + count; j < jl; j += 3) {\\n            if (index !== undefined) {\\n              addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\\n            } else {\\n              addFace(j, j + 1, j + 2, group.materialIndex);\\n            }\\n          }\\n        }\\n      } else {\\n        if (index !== undefined) {\\n          for (var _i3 = 0; _i3 < index.count; _i3 += 3) {\\n            addFace(index.getX(_i3), index.getX(_i3 + 1), index.getX(_i3 + 2));\\n          }\\n        } else {\\n          for (var _i4 = 0; _i4 < position.count; _i4 += 3) {\\n            addFace(_i4, _i4 + 1, _i4 + 2);\\n          }\\n        }\\n      }\\n\\n      this.computeFaceNormals();\\n\\n      if (geometry.boundingBox !== null) {\\n        this.boundingBox = geometry.boundingBox.clone();\\n      }\\n\\n      if (geometry.boundingSphere !== null) {\\n        this.boundingSphere = geometry.boundingSphere.clone();\\n      }\\n\\n      return this;\\n    }\\n  }, {\\n    key: \\\"center\\\",\\n    value: function center() {\\n      this.computeBoundingBox();\\n      this.boundingBox.getCenter(_offset).negate();\\n      this.translate(_offset.x, _offset.y, _offset.z);\\n      return this;\\n    }\\n  }, {\\n    key: \\\"normalize\\\",\\n    value: function normalize() {\\n      this.computeBoundingSphere();\\n      var center = this.boundingSphere.center;\\n      var radius = this.boundingSphere.radius;\\n      var s = radius === 0 ? 1 : 1.0 / radius;\\n      var matrix = new _three.Matrix4();\\n      matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\\n      this.applyMatrix4(matrix);\\n      return this;\\n    }\\n  }, {\\n    key: \\\"computeFaceNormals\\\",\\n    value: function computeFaceNormals() {\\n      var cb = new _three.Vector3(),\\n          ab = new _three.Vector3();\\n\\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\\n        var face = this.faces[f];\\n        var vA = this.vertices[face.a];\\n        var vB = this.vertices[face.b];\\n        var vC = this.vertices[face.c];\\n        cb.subVectors(vC, vB);\\n        ab.subVectors(vA, vB);\\n        cb.cross(ab);\\n        cb.normalize();\\n        face.normal.copy(cb);\\n      }\\n    }\\n  }, {\\n    key: \\\"computeVertexNormals\\\",\\n    value: function computeVertexNormals() {\\n      var areaWeighted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\\n      var vertices = new Array(this.vertices.length);\\n\\n      for (var v = 0, vl = this.vertices.length; v < vl; v++) {\\n        vertices[v] = new _three.Vector3();\\n      }\\n\\n      if (areaWeighted) {\\n        // vertex normals weighted by triangle areas\\n        // http://www.iquilezles.org/www/articles/normals/normals.htm\\n        var cb = new _three.Vector3(),\\n            ab = new _three.Vector3();\\n\\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\\n          var face = this.faces[f];\\n          var vA = this.vertices[face.a];\\n          var vB = this.vertices[face.b];\\n          var vC = this.vertices[face.c];\\n          cb.subVectors(vC, vB);\\n          ab.subVectors(vA, vB);\\n          cb.cross(ab);\\n          vertices[face.a].add(cb);\\n          vertices[face.b].add(cb);\\n          vertices[face.c].add(cb);\\n        }\\n      } else {\\n        this.computeFaceNormals();\\n\\n        for (var _f = 0, _fl = this.faces.length; _f < _fl; _f++) {\\n          var _face = this.faces[_f];\\n\\n          vertices[_face.a].add(_face.normal);\\n\\n          vertices[_face.b].add(_face.normal);\\n\\n          vertices[_face.c].add(_face.normal);\\n        }\\n      }\\n\\n      for (var _v = 0, _vl = this.vertices.length; _v < _vl; _v++) {\\n        vertices[_v].normalize();\\n      }\\n\\n      for (var _f2 = 0, _fl2 = this.faces.length; _f2 < _fl2; _f2++) {\\n        var _face2 = this.faces[_f2];\\n        var vertexNormals = _face2.vertexNormals;\\n\\n        if (vertexNormals.length === 3) {\\n          vertexNormals[0].copy(vertices[_face2.a]);\\n          vertexNormals[1].copy(vertices[_face2.b]);\\n          vertexNormals[2].copy(vertices[_face2.c]);\\n        } else {\\n          vertexNormals[0] = vertices[_face2.a].clone();\\n          vertexNormals[1] = vertices[_face2.b].clone();\\n          vertexNormals[2] = vertices[_face2.c].clone();\\n        }\\n      }\\n\\n      if (this.faces.length > 0) {\\n        this.normalsNeedUpdate = true;\\n      }\\n    }\\n  }, {\\n    key: \\\"computeFlatVertexNormals\\\",\\n    value: function computeFlatVertexNormals() {\\n      this.computeFaceNormals();\\n\\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\\n        var face = this.faces[f];\\n        var vertexNormals = face.vertexNormals;\\n\\n        if (vertexNormals.length === 3) {\\n          vertexNormals[0].copy(face.normal);\\n          vertexNormals[1].copy(face.normal);\\n          vertexNormals[2].copy(face.normal);\\n        } else {\\n          vertexNormals[0] = face.normal.clone();\\n          vertexNormals[1] = face.normal.clone();\\n          vertexNormals[2] = face.normal.clone();\\n        }\\n      }\\n\\n      if (this.faces.length > 0) {\\n        this.normalsNeedUpdate = true;\\n      }\\n    }\\n  }, {\\n    key: \\\"computeMorphNormals\\\",\\n    value: function computeMorphNormals() {\\n      // save original normals\\n      // - create temp variables on first access\\n      //   otherwise just copy (for faster repeated calls)\\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\\n        var face = this.faces[f];\\n\\n        if (!face.__originalFaceNormal) {\\n          face.__originalFaceNormal = face.normal.clone();\\n        } else {\\n          face.__originalFaceNormal.copy(face.normal);\\n        }\\n\\n        if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\\n\\n        for (var i = 0, il = face.vertexNormals.length; i < il; i++) {\\n          if (!face.__originalVertexNormals[i]) {\\n            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\\n          } else {\\n            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\\n          }\\n        }\\n      } // use temp geometry to compute face and vertex normals for each morph\\n\\n\\n      var tmpGeo = new Geometry();\\n      tmpGeo.faces = this.faces;\\n\\n      for (var _i5 = 0, _il2 = this.morphTargets.length; _i5 < _il2; _i5++) {\\n        // create on first access\\n        if (!this.morphNormals[_i5]) {\\n          this.morphNormals[_i5] = {};\\n          this.morphNormals[_i5].faceNormals = [];\\n          this.morphNormals[_i5].vertexNormals = [];\\n          var dstNormalsFace = this.morphNormals[_i5].faceNormals;\\n          var dstNormalsVertex = this.morphNormals[_i5].vertexNormals;\\n\\n          for (var _f3 = 0, _fl3 = this.faces.length; _f3 < _fl3; _f3++) {\\n            var faceNormal = new _three.Vector3();\\n            var vertexNormals = {\\n              a: new _three.Vector3(),\\n              b: new _three.Vector3(),\\n              c: new _three.Vector3()\\n            };\\n            dstNormalsFace.push(faceNormal);\\n            dstNormalsVertex.push(vertexNormals);\\n          }\\n        }\\n\\n        var morphNormals = this.morphNormals[_i5]; // set vertices to morph target\\n\\n        tmpGeo.vertices = this.morphTargets[_i5].vertices; // compute morph normals\\n\\n        tmpGeo.computeFaceNormals();\\n        tmpGeo.computeVertexNormals(); // store morph normals\\n\\n        for (var _f4 = 0, _fl4 = this.faces.length; _f4 < _fl4; _f4++) {\\n          var _face3 = this.faces[_f4];\\n          var _faceNormal = morphNormals.faceNormals[_f4];\\n          var _vertexNormals = morphNormals.vertexNormals[_f4];\\n\\n          _faceNormal.copy(_face3.normal);\\n\\n          _vertexNormals.a.copy(_face3.vertexNormals[0]);\\n\\n          _vertexNormals.b.copy(_face3.vertexNormals[1]);\\n\\n          _vertexNormals.c.copy(_face3.vertexNormals[2]);\\n        }\\n      } // restore original normals\\n\\n\\n      for (var _f5 = 0, _fl5 = this.faces.length; _f5 < _fl5; _f5++) {\\n        var _face4 = this.faces[_f5];\\n        _face4.normal = _face4.__originalFaceNormal;\\n        _face4.vertexNormals = _face4.__originalVertexNormals;\\n      }\\n    }\\n  }, {\\n    key: \\\"computeBoundingBox\\\",\\n    value: function computeBoundingBox() {\\n      if (this.boundingBox === null) {\\n        this.boundingBox = new _three.Box3();\\n      }\\n\\n      this.boundingBox.setFromPoints(this.vertices);\\n    }\\n  }, {\\n    key: \\\"computeBoundingSphere\\\",\\n    value: function computeBoundingSphere() {\\n      if (this.boundingSphere === null) {\\n        this.boundingSphere = new _three.Sphere();\\n      }\\n\\n      this.boundingSphere.setFromPoints(this.vertices);\\n    }\\n  }, {\\n    key: \\\"merge\\\",\\n    value: function merge(geometry, matrix) {\\n      var materialIndexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n\\n      if (!(geometry && geometry.isGeometry)) {\\n        console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\\n        return;\\n      }\\n\\n      var normalMatrix;\\n      var vertexOffset = this.vertices.length,\\n          vertices1 = this.vertices,\\n          vertices2 = geometry.vertices,\\n          faces1 = this.faces,\\n          faces2 = geometry.faces,\\n          colors1 = this.colors,\\n          colors2 = geometry.colors;\\n\\n      if (matrix !== undefined) {\\n        normalMatrix = new _three.Matrix3().getNormalMatrix(matrix);\\n      } // vertices\\n\\n\\n      for (var i = 0, il = vertices2.length; i < il; i++) {\\n        var vertex = vertices2[i];\\n        var vertexCopy = vertex.clone();\\n        if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\\n        vertices1.push(vertexCopy);\\n      } // colors\\n\\n\\n      for (var _i6 = 0, _il3 = colors2.length; _i6 < _il3; _i6++) {\\n        colors1.push(colors2[_i6].clone());\\n      } // faces\\n\\n\\n      for (var _i7 = 0, _il4 = faces2.length; _i7 < _il4; _i7++) {\\n        var face = faces2[_i7];\\n        var normal = void 0,\\n            color = void 0;\\n        var faceVertexNormals = face.vertexNormals,\\n            faceVertexColors = face.vertexColors;\\n        var faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\\n        faceCopy.normal.copy(face.normal);\\n\\n        if (normalMatrix !== undefined) {\\n          faceCopy.normal.applyMatrix3(normalMatrix).normalize();\\n        }\\n\\n        for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\\n          normal = faceVertexNormals[j].clone();\\n\\n          if (normalMatrix !== undefined) {\\n            normal.applyMatrix3(normalMatrix).normalize();\\n          }\\n\\n          faceCopy.vertexNormals.push(normal);\\n        }\\n\\n        faceCopy.color.copy(face.color);\\n\\n        for (var _j = 0, _jl = faceVertexColors.length; _j < _jl; _j++) {\\n          color = faceVertexColors[_j];\\n          faceCopy.vertexColors.push(color.clone());\\n        }\\n\\n        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\\n        faces1.push(faceCopy);\\n      } // uvs\\n\\n\\n      for (var _i8 = 0, _il5 = geometry.faceVertexUvs.length; _i8 < _il5; _i8++) {\\n        var faceVertexUvs2 = geometry.faceVertexUvs[_i8];\\n        if (this.faceVertexUvs[_i8] === undefined) this.faceVertexUvs[_i8] = [];\\n\\n        for (var _j2 = 0, _jl2 = faceVertexUvs2.length; _j2 < _jl2; _j2++) {\\n          var uvs2 = faceVertexUvs2[_j2],\\n              uvsCopy = [];\\n\\n          for (var k = 0, kl = uvs2.length; k < kl; k++) {\\n            uvsCopy.push(uvs2[k].clone());\\n          }\\n\\n          this.faceVertexUvs[_i8].push(uvsCopy);\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"mergeMesh\\\",\\n    value: function mergeMesh(mesh) {\\n      if (!(mesh && mesh.isMesh)) {\\n        console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\\n        return;\\n      }\\n\\n      if (mesh.matrixAutoUpdate) mesh.updateMatrix();\\n      this.merge(mesh.geometry, mesh.matrix);\\n    }\\n    /*\\n     * Checks for duplicate vertices with hashmap.\\n     * Duplicated vertices are removed\\n     * and faces' vertices are updated.\\n     */\\n\\n  }, {\\n    key: \\\"mergeVertices\\\",\\n    value: function mergeVertices() {\\n      var precisionPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\\n      var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\\n\\n      var unique = [],\\n          changes = [];\\n      var precision = Math.pow(10, precisionPoints);\\n\\n      for (var i = 0, il = this.vertices.length; i < il; i++) {\\n        var v = this.vertices[i];\\n        var key = \\\"\\\".concat(Math.round(v.x * precision), \\\"_\\\").concat(Math.round(v.y * precision), \\\"_\\\").concat(Math.round(v.z * precision));\\n\\n        if (verticesMap[key] === undefined) {\\n          verticesMap[key] = i;\\n          unique.push(this.vertices[i]);\\n          changes[i] = unique.length - 1;\\n        } else {\\n          //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\\n          changes[i] = changes[verticesMap[key]];\\n        }\\n      } // if faces are completely degenerate after merging vertices, we\\n      // have to remove them from the geometry.\\n\\n\\n      var faceIndicesToRemove = [];\\n\\n      for (var _i9 = 0, _il6 = this.faces.length; _i9 < _il6; _i9++) {\\n        var face = this.faces[_i9];\\n        face.a = changes[face.a];\\n        face.b = changes[face.b];\\n        face.c = changes[face.c];\\n        var indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\\n        // we have to remove the face as nothing can be saved\\n\\n        for (var n = 0; n < 3; n++) {\\n          if (indices[n] === indices[(n + 1) % 3]) {\\n            faceIndicesToRemove.push(_i9);\\n            break;\\n          }\\n        }\\n      }\\n\\n      for (var _i10 = faceIndicesToRemove.length - 1; _i10 >= 0; _i10--) {\\n        var idx = faceIndicesToRemove[_i10];\\n        this.faces.splice(idx, 1);\\n\\n        for (var j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\\n          this.faceVertexUvs[j].splice(idx, 1);\\n        }\\n      } // Use unique set of vertices\\n\\n\\n      var diff = this.vertices.length - unique.length;\\n      this.vertices = unique;\\n      return diff;\\n    }\\n  }, {\\n    key: \\\"setFromPoints\\\",\\n    value: function setFromPoints(points) {\\n      this.vertices = [];\\n\\n      for (var i = 0, l = points.length; i < l; i++) {\\n        var point = points[i];\\n        this.vertices.push(new _three.Vector3(point.x, point.y, point.z || 0));\\n      }\\n\\n      return this;\\n    }\\n  }, {\\n    key: \\\"sortFacesByMaterialIndex\\\",\\n    value: function sortFacesByMaterialIndex() {\\n      var faces = this.faces;\\n      var length = faces.length; // tag faces\\n\\n      for (var i = 0; i < length; i++) {\\n        faces[i]._id = i;\\n      } // sort faces\\n\\n\\n      function materialIndexSort(a, b) {\\n        return a.materialIndex - b.materialIndex;\\n      }\\n\\n      faces.sort(materialIndexSort); // sort uvs\\n\\n      var uvs1 = this.faceVertexUvs[0];\\n      var uvs2 = this.faceVertexUvs[1];\\n      var newUvs1, newUvs2;\\n      if (uvs1 && uvs1.length === length) newUvs1 = [];\\n      if (uvs2 && uvs2.length === length) newUvs2 = [];\\n\\n      for (var _i11 = 0; _i11 < length; _i11++) {\\n        var id = faces[_i11]._id;\\n        if (newUvs1) newUvs1.push(uvs1[id]);\\n        if (newUvs2) newUvs2.push(uvs2[id]);\\n      }\\n\\n      if (newUvs1) this.faceVertexUvs[0] = newUvs1;\\n      if (newUvs2) this.faceVertexUvs[1] = newUvs2;\\n    }\\n  }, {\\n    key: \\\"toJSON\\\",\\n    value: function toJSON() {\\n      var data = {\\n        metadata: {\\n          version: 4.5,\\n          type: 'Geometry',\\n          generator: 'Geometry.toJSON'\\n        }\\n      }; // standard Geometry serialization\\n\\n      data.uuid = this.uuid;\\n      data.type = this.type;\\n      if (this.name !== '') data.name = this.name;\\n\\n      if (this.parameters !== undefined) {\\n        var parameters = this.parameters;\\n\\n        for (var key in parameters) {\\n          if (parameters[key] !== undefined) data[key] = parameters[key];\\n        }\\n\\n        return data;\\n      }\\n\\n      var vertices = [];\\n\\n      for (var i = 0; i < this.vertices.length; i++) {\\n        var vertex = this.vertices[i];\\n        vertices.push(vertex.x, vertex.y, vertex.z);\\n      }\\n\\n      var faces = [];\\n      var normals = [];\\n      var normalsHash = {};\\n      var colors = [];\\n      var colorsHash = {};\\n      var uvs = [];\\n      var uvsHash = {};\\n\\n      for (var _i12 = 0; _i12 < this.faces.length; _i12++) {\\n        var face = this.faces[_i12];\\n        var hasMaterial = true;\\n        var hasFaceUv = false; // deprecated\\n\\n        var hasFaceVertexUv = this.faceVertexUvs[0][_i12] !== undefined;\\n        var hasFaceNormal = face.normal.length() > 0;\\n        var hasFaceVertexNormal = face.vertexNormals.length > 0;\\n        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\\n        var hasFaceVertexColor = face.vertexColors.length > 0;\\n        var faceType = 0;\\n        faceType = setBit(faceType, 0, 0); // isQuad\\n\\n        faceType = setBit(faceType, 1, hasMaterial);\\n        faceType = setBit(faceType, 2, hasFaceUv);\\n        faceType = setBit(faceType, 3, hasFaceVertexUv);\\n        faceType = setBit(faceType, 4, hasFaceNormal);\\n        faceType = setBit(faceType, 5, hasFaceVertexNormal);\\n        faceType = setBit(faceType, 6, hasFaceColor);\\n        faceType = setBit(faceType, 7, hasFaceVertexColor);\\n        faces.push(faceType);\\n        faces.push(face.a, face.b, face.c);\\n        faces.push(face.materialIndex);\\n\\n        if (hasFaceVertexUv) {\\n          var faceVertexUvs = this.faceVertexUvs[0][_i12];\\n          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\\n        }\\n\\n        if (hasFaceNormal) {\\n          faces.push(getNormalIndex(face.normal));\\n        }\\n\\n        if (hasFaceVertexNormal) {\\n          var vertexNormals = face.vertexNormals;\\n          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\\n        }\\n\\n        if (hasFaceColor) {\\n          faces.push(getColorIndex(face.color));\\n        }\\n\\n        if (hasFaceVertexColor) {\\n          var vertexColors = face.vertexColors;\\n          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\\n        }\\n      }\\n\\n      function setBit(value, position, enabled) {\\n        return enabled ? value | 1 << position : value & ~(1 << position);\\n      }\\n\\n      function getNormalIndex(normal) {\\n        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\\n\\n        if (normalsHash[hash] !== undefined) {\\n          return normalsHash[hash];\\n        }\\n\\n        normalsHash[hash] = normals.length / 3;\\n        normals.push(normal.x, normal.y, normal.z);\\n        return normalsHash[hash];\\n      }\\n\\n      function getColorIndex(color) {\\n        var hash = color.r.toString() + color.g.toString() + color.b.toString();\\n\\n        if (colorsHash[hash] !== undefined) {\\n          return colorsHash[hash];\\n        }\\n\\n        colorsHash[hash] = colors.length;\\n        colors.push(color.getHex());\\n        return colorsHash[hash];\\n      }\\n\\n      function getUvIndex(uv) {\\n        var hash = uv.x.toString() + uv.y.toString();\\n\\n        if (uvsHash[hash] !== undefined) {\\n          return uvsHash[hash];\\n        }\\n\\n        uvsHash[hash] = uvs.length / 2;\\n        uvs.push(uv.x, uv.y);\\n        return uvsHash[hash];\\n      }\\n\\n      data.data = {};\\n      data.data.vertices = vertices;\\n      data.data.normals = normals;\\n      if (colors.length > 0) data.data.colors = colors;\\n      if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\\n\\n      data.data.faces = faces;\\n      return data;\\n    }\\n  }, {\\n    key: \\\"clone\\\",\\n    value: function clone() {\\n      /*\\n      // Handle primitives\\n      const parameters = this.parameters;\\n      if ( parameters !== undefined ) {\\n      const values = [];\\n      for ( const key in parameters ) {\\n      values.push( parameters[ key ] );\\n      }\\n      const geometry = Object.create( this.constructor.prototype );\\n      this.constructor.apply( geometry, values );\\n      return geometry;\\n      }\\n      return new this.constructor().copy( this );\\n      */\\n      return new Geometry().copy(this);\\n    }\\n  }, {\\n    key: \\\"copy\\\",\\n    value: function copy(source) {\\n      // reset\\n      this.vertices = [];\\n      this.colors = [];\\n      this.faces = [];\\n      this.faceVertexUvs = [[]];\\n      this.morphTargets = [];\\n      this.morphNormals = [];\\n      this.skinWeights = [];\\n      this.skinIndices = [];\\n      this.lineDistances = [];\\n      this.boundingBox = null;\\n      this.boundingSphere = null; // name\\n\\n      this.name = source.name; // vertices\\n\\n      var vertices = source.vertices;\\n\\n      for (var i = 0, il = vertices.length; i < il; i++) {\\n        this.vertices.push(vertices[i].clone());\\n      } // colors\\n\\n\\n      var colors = source.colors;\\n\\n      for (var _i13 = 0, _il7 = colors.length; _i13 < _il7; _i13++) {\\n        this.colors.push(colors[_i13].clone());\\n      } // faces\\n\\n\\n      var faces = source.faces;\\n\\n      for (var _i14 = 0, _il8 = faces.length; _i14 < _il8; _i14++) {\\n        this.faces.push(faces[_i14].clone());\\n      } // face vertex uvs\\n\\n\\n      for (var _i15 = 0, _il9 = source.faceVertexUvs.length; _i15 < _il9; _i15++) {\\n        var faceVertexUvs = source.faceVertexUvs[_i15];\\n\\n        if (this.faceVertexUvs[_i15] === undefined) {\\n          this.faceVertexUvs[_i15] = [];\\n        }\\n\\n        for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\\n          var uvs = faceVertexUvs[j],\\n              uvsCopy = [];\\n\\n          for (var k = 0, kl = uvs.length; k < kl; k++) {\\n            var uv = uvs[k];\\n            uvsCopy.push(uv.clone());\\n          }\\n\\n          this.faceVertexUvs[_i15].push(uvsCopy);\\n        }\\n      } // morph targets\\n\\n\\n      var morphTargets = source.morphTargets;\\n\\n      for (var _i16 = 0, _il10 = morphTargets.length; _i16 < _il10; _i16++) {\\n        var morphTarget = {};\\n        morphTarget.name = morphTargets[_i16].name; // vertices\\n\\n        if (morphTargets[_i16].vertices !== undefined) {\\n          morphTarget.vertices = [];\\n\\n          for (var _j3 = 0, _jl3 = morphTargets[_i16].vertices.length; _j3 < _jl3; _j3++) {\\n            morphTarget.vertices.push(morphTargets[_i16].vertices[_j3].clone());\\n          }\\n        } // normals\\n\\n\\n        if (morphTargets[_i16].normals !== undefined) {\\n          morphTarget.normals = [];\\n\\n          for (var _j4 = 0, _jl4 = morphTargets[_i16].normals.length; _j4 < _jl4; _j4++) {\\n            morphTarget.normals.push(morphTargets[_i16].normals[_j4].clone());\\n          }\\n        }\\n\\n        this.morphTargets.push(morphTarget);\\n      } // morph normals\\n\\n\\n      var morphNormals = source.morphNormals;\\n\\n      for (var _i17 = 0, _il11 = morphNormals.length; _i17 < _il11; _i17++) {\\n        var morphNormal = {}; // vertex normals\\n\\n        if (morphNormals[_i17].vertexNormals !== undefined) {\\n          morphNormal.vertexNormals = [];\\n\\n          for (var _j5 = 0, _jl5 = morphNormals[_i17].vertexNormals.length; _j5 < _jl5; _j5++) {\\n            var srcVertexNormal = morphNormals[_i17].vertexNormals[_j5];\\n            var destVertexNormal = {};\\n            destVertexNormal.a = srcVertexNormal.a.clone();\\n            destVertexNormal.b = srcVertexNormal.b.clone();\\n            destVertexNormal.c = srcVertexNormal.c.clone();\\n            morphNormal.vertexNormals.push(destVertexNormal);\\n          }\\n        } // face normals\\n\\n\\n        if (morphNormals[_i17].faceNormals !== undefined) {\\n          morphNormal.faceNormals = [];\\n\\n          for (var _j6 = 0, _jl6 = morphNormals[_i17].faceNormals.length; _j6 < _jl6; _j6++) {\\n            morphNormal.faceNormals.push(morphNormals[_i17].faceNormals[_j6].clone());\\n          }\\n        }\\n\\n        this.morphNormals.push(morphNormal);\\n      } // skin weights\\n\\n\\n      var skinWeights = source.skinWeights;\\n\\n      for (var _i18 = 0, _il12 = skinWeights.length; _i18 < _il12; _i18++) {\\n        this.skinWeights.push(skinWeights[_i18].clone());\\n      } // skin indices\\n\\n\\n      var skinIndices = source.skinIndices;\\n\\n      for (var _i19 = 0, _il13 = skinIndices.length; _i19 < _il13; _i19++) {\\n        this.skinIndices.push(skinIndices[_i19].clone());\\n      } // line distances\\n\\n\\n      var lineDistances = source.lineDistances;\\n\\n      for (var _i20 = 0, _il14 = lineDistances.length; _i20 < _il14; _i20++) {\\n        this.lineDistances.push(lineDistances[_i20]);\\n      } // bounding box\\n\\n\\n      var boundingBox = source.boundingBox;\\n\\n      if (boundingBox !== null) {\\n        this.boundingBox = boundingBox.clone();\\n      } // bounding sphere\\n\\n\\n      var boundingSphere = source.boundingSphere;\\n\\n      if (boundingSphere !== null) {\\n        this.boundingSphere = boundingSphere.clone();\\n      } // update flags\\n\\n\\n      this.elementsNeedUpdate = source.elementsNeedUpdate;\\n      this.verticesNeedUpdate = source.verticesNeedUpdate;\\n      this.uvsNeedUpdate = source.uvsNeedUpdate;\\n      this.normalsNeedUpdate = source.normalsNeedUpdate;\\n      this.colorsNeedUpdate = source.colorsNeedUpdate;\\n      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\\n      this.groupsNeedUpdate = source.groupsNeedUpdate;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"toBufferGeometry\\\",\\n    value: function toBufferGeometry() {\\n      var geometry = new DirectGeometry().fromGeometry(this);\\n      var buffergeometry = new _three.BufferGeometry();\\n      var positions = new Float32Array(geometry.vertices.length * 3);\\n      buffergeometry.setAttribute('position', new _three.BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\\n\\n      if (geometry.normals.length > 0) {\\n        var normals = new Float32Array(geometry.normals.length * 3);\\n        buffergeometry.setAttribute('normal', new _three.BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\\n      }\\n\\n      if (geometry.colors.length > 0) {\\n        var colors = new Float32Array(geometry.colors.length * 3);\\n        buffergeometry.setAttribute('color', new _three.BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\\n      }\\n\\n      if (geometry.uvs.length > 0) {\\n        var uvs = new Float32Array(geometry.uvs.length * 2);\\n        buffergeometry.setAttribute('uv', new _three.BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\\n      }\\n\\n      if (geometry.uvs2.length > 0) {\\n        var uvs2 = new Float32Array(geometry.uvs2.length * 2);\\n        buffergeometry.setAttribute('uv2', new _three.BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\\n      } // groups\\n\\n\\n      buffergeometry.groups = geometry.groups; // morphs\\n\\n      for (var name in geometry.morphTargets) {\\n        var array = [];\\n        var morphTargets = geometry.morphTargets[name];\\n\\n        for (var i = 0, l = morphTargets.length; i < l; i++) {\\n          var morphTarget = morphTargets[i];\\n          var attribute = new _three.Float32BufferAttribute(morphTarget.data.length * 3, 3);\\n          attribute.name = morphTarget.name;\\n          array.push(attribute.copyVector3sArray(morphTarget.data));\\n        }\\n\\n        buffergeometry.morphAttributes[name] = array;\\n      } // skinning\\n\\n\\n      if (geometry.skinIndices.length > 0) {\\n        var skinIndices = new _three.Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\\n        buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\\n      }\\n\\n      if (geometry.skinWeights.length > 0) {\\n        var skinWeights = new _three.Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\\n        buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\\n      } //\\n\\n\\n      if (geometry.boundingSphere !== null) {\\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\\n      }\\n\\n      if (geometry.boundingBox !== null) {\\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\\n      }\\n\\n      return buffergeometry;\\n    }\\n  }, {\\n    key: \\\"computeTangents\\\",\\n    value: function computeTangents() {\\n      console.error('THREE.Geometry: .computeTangents() has been removed.');\\n    }\\n  }, {\\n    key: \\\"computeLineDistances\\\",\\n    value: function computeLineDistances() {\\n      console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\\n    }\\n  }, {\\n    key: \\\"applyMatrix\\\",\\n    value: function applyMatrix(matrix) {\\n      console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\\n      return this.applyMatrix4(matrix);\\n    }\\n  }, {\\n    key: \\\"dispose\\\",\\n    value: function dispose() {\\n      this.dispatchEvent({\\n        type: 'dispose'\\n      });\\n    }\\n  }]);\\n\\n  return Geometry;\\n}(_three.EventDispatcher);\\n\\nexports.Geometry = Geometry;\\n\\nGeometry.createBufferGeometryFromObject = function (object) {\\n  var buffergeometry = new _three.BufferGeometry();\\n  var geometry = object.geometry;\\n\\n  if (object.isPoints || object.isLine) {\\n    var positions = new _three.Float32BufferAttribute(geometry.vertices.length * 3, 3);\\n    var colors = new _three.Float32BufferAttribute(geometry.colors.length * 3, 3);\\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\\n\\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\\n      var lineDistances = new _three.Float32BufferAttribute(geometry.lineDistances.length, 1);\\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\\n    }\\n\\n    if (geometry.boundingSphere !== null) {\\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\\n    }\\n\\n    if (geometry.boundingBox !== null) {\\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\\n    }\\n  } else if (object.isMesh) {\\n    buffergeometry = geometry.toBufferGeometry();\\n  }\\n\\n  return buffergeometry;\\n};\\n\\nvar DirectGeometry =\\n/*#__PURE__*/\\nfunction () {\\n  function DirectGeometry() {\\n    _classCallCheck(this, DirectGeometry);\\n\\n    this.vertices = [];\\n    this.normals = [];\\n    this.colors = [];\\n    this.uvs = [];\\n    this.uvs2 = [];\\n    this.groups = [];\\n    this.morphTargets = {};\\n    this.skinWeights = [];\\n    this.skinIndices = []; // this.lineDistances = [];\\n\\n    this.boundingBox = null;\\n    this.boundingSphere = null; // update flags\\n\\n    this.verticesNeedUpdate = false;\\n    this.normalsNeedUpdate = false;\\n    this.colorsNeedUpdate = false;\\n    this.uvsNeedUpdate = false;\\n    this.groupsNeedUpdate = false;\\n  }\\n\\n  _createClass(DirectGeometry, [{\\n    key: \\\"computeGroups\\\",\\n    value: function computeGroups(geometry) {\\n      var groups = [];\\n      var group, i;\\n      var materialIndex = undefined;\\n      var faces = geometry.faces;\\n\\n      for (i = 0; i < faces.length; i++) {\\n        var face = faces[i]; // materials\\n\\n        if (face.materialIndex !== materialIndex) {\\n          materialIndex = face.materialIndex;\\n\\n          if (group !== undefined) {\\n            group.count = i * 3 - group.start;\\n            groups.push(group);\\n          }\\n\\n          group = {\\n            start: i * 3,\\n            materialIndex: materialIndex\\n          };\\n        }\\n      }\\n\\n      if (group !== undefined) {\\n        group.count = i * 3 - group.start;\\n        groups.push(group);\\n      }\\n\\n      this.groups = groups;\\n    }\\n  }, {\\n    key: \\\"fromGeometry\\\",\\n    value: function fromGeometry(geometry) {\\n      var faces = geometry.faces;\\n      var vertices = geometry.vertices;\\n      var faceVertexUvs = geometry.faceVertexUvs;\\n      var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\\n      var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\\n\\n      var morphTargets = geometry.morphTargets;\\n      var morphTargetsLength = morphTargets.length;\\n      var morphTargetsPosition;\\n\\n      if (morphTargetsLength > 0) {\\n        morphTargetsPosition = [];\\n\\n        for (var i = 0; i < morphTargetsLength; i++) {\\n          morphTargetsPosition[i] = {\\n            name: morphTargets[i].name,\\n            data: []\\n          };\\n        }\\n\\n        this.morphTargets.position = morphTargetsPosition;\\n      }\\n\\n      var morphNormals = geometry.morphNormals;\\n      var morphNormalsLength = morphNormals.length;\\n      var morphTargetsNormal;\\n\\n      if (morphNormalsLength > 0) {\\n        morphTargetsNormal = [];\\n\\n        for (var _i21 = 0; _i21 < morphNormalsLength; _i21++) {\\n          morphTargetsNormal[_i21] = {\\n            name: morphNormals[_i21].name,\\n            data: []\\n          };\\n        }\\n\\n        this.morphTargets.normal = morphTargetsNormal;\\n      } // skins\\n\\n\\n      var skinIndices = geometry.skinIndices;\\n      var skinWeights = geometry.skinWeights;\\n      var hasSkinIndices = skinIndices.length === vertices.length;\\n      var hasSkinWeights = skinWeights.length === vertices.length; //\\n\\n      if (vertices.length > 0 && faces.length === 0) {\\n        console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\\n      }\\n\\n      for (var _i22 = 0; _i22 < faces.length; _i22++) {\\n        var face = faces[_i22];\\n        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\\n        var vertexNormals = face.vertexNormals;\\n\\n        if (vertexNormals.length === 3) {\\n          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\\n        } else {\\n          var normal = face.normal;\\n          this.normals.push(normal, normal, normal);\\n        }\\n\\n        var vertexColors = face.vertexColors;\\n\\n        if (vertexColors.length === 3) {\\n          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\\n        } else {\\n          var color = face.color;\\n          this.colors.push(color, color, color);\\n        }\\n\\n        if (hasFaceVertexUv === true) {\\n          var vertexUvs = faceVertexUvs[0][_i22];\\n\\n          if (vertexUvs !== undefined) {\\n            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\\n          } else {\\n            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', _i22);\\n            this.uvs.push(new _three.Vector2(), new _three.Vector2(), new _three.Vector2());\\n          }\\n        }\\n\\n        if (hasFaceVertexUv2 === true) {\\n          var _vertexUvs = faceVertexUvs[1][_i22];\\n\\n          if (_vertexUvs !== undefined) {\\n            this.uvs2.push(_vertexUvs[0], _vertexUvs[1], _vertexUvs[2]);\\n          } else {\\n            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', _i22);\\n            this.uvs2.push(new _three.Vector2(), new _three.Vector2(), new _three.Vector2());\\n          }\\n        } // morphs\\n\\n\\n        for (var j = 0; j < morphTargetsLength; j++) {\\n          var morphTarget = morphTargets[j].vertices;\\n          morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\\n        }\\n\\n        for (var _j7 = 0; _j7 < morphNormalsLength; _j7++) {\\n          var morphNormal = morphNormals[_j7].vertexNormals[_i22];\\n\\n          morphTargetsNormal[_j7].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\\n        } // skins\\n\\n\\n        if (hasSkinIndices) {\\n          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\\n        }\\n\\n        if (hasSkinWeights) {\\n          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\\n        }\\n      }\\n\\n      this.computeGroups(geometry);\\n      this.verticesNeedUpdate = geometry.verticesNeedUpdate;\\n      this.normalsNeedUpdate = geometry.normalsNeedUpdate;\\n      this.colorsNeedUpdate = geometry.colorsNeedUpdate;\\n      this.uvsNeedUpdate = geometry.uvsNeedUpdate;\\n      this.groupsNeedUpdate = geometry.groupsNeedUpdate;\\n\\n      if (geometry.boundingSphere !== null) {\\n        this.boundingSphere = geometry.boundingSphere.clone();\\n      }\\n\\n      if (geometry.boundingBox !== null) {\\n        this.boundingBox = geometry.boundingBox.clone();\\n      }\\n\\n      return this;\\n    }\\n  }]);\\n\\n  return DirectGeometry;\\n}();\\n\\nvar Face3 =\\n/*#__PURE__*/\\nfunction () {\\n  function Face3(a, b, c, normal, color) {\\n    var materialIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\\n\\n    _classCallCheck(this, Face3);\\n\\n    this.a = a;\\n    this.b = b;\\n    this.c = c;\\n    this.normal = normal && normal.isVector3 ? normal : new _three.Vector3();\\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\\n    this.color = color && color.isColor ? color : new _three.Color();\\n    this.vertexColors = Array.isArray(color) ? color : [];\\n    this.materialIndex = materialIndex;\\n  }\\n\\n  _createClass(Face3, [{\\n    key: \\\"clone\\\",\\n    value: function clone() {\\n      return new this.constructor().copy(this);\\n    }\\n  }, {\\n    key: \\\"copy\\\",\\n    value: function copy(source) {\\n      this.a = source.a;\\n      this.b = source.b;\\n      this.c = source.c;\\n      this.normal.copy(source.normal);\\n      this.color.copy(source.color);\\n      this.materialIndex = source.materialIndex;\\n\\n      for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\\n        this.vertexNormals[i] = source.vertexNormals[i].clone();\\n      }\\n\\n      for (var _i23 = 0, _il15 = source.vertexColors.length; _i23 < _il15; _i23++) {\\n        this.vertexColors[_i23] = source.vertexColors[_i23].clone();\\n      }\\n\\n      return this;\\n    }\\n  }]);\\n\\n  return Face3;\\n}();\\n\\nexports.Face3 = Face3;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_classCallCheck\",\"instance\",\"Constructor\",\"TypeError\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"Geometry\",\"Face3\",\"_three\",\"_m1\",\"Matrix4\",\"_obj\",\"Object3D\",\"_offset\",\"Vector3\",\"_EventDispatcher\",\"call\",\"self\",\"ReferenceError\",\"_this\",\"isGeometry\",\"uuid\",\"MathUtils\",\"generateUUID\",\"name\",\"type\",\"vertices\",\"colors\",\"faces\",\"faceVertexUvs\",\"morphTargets\",\"morphNormals\",\"skinWeights\",\"skinIndices\",\"lineDistances\",\"boundingBox\",\"boundingSphere\",\"elementsNeedUpdate\",\"verticesNeedUpdate\",\"uvsNeedUpdate\",\"normalsNeedUpdate\",\"colorsNeedUpdate\",\"lineDistancesNeedUpdate\",\"groupsNeedUpdate\",\"applyMatrix4\",\"matrix\",\"normalMatrix\",\"getNormalMatrix\",\"Matrix3\",\"il\",\"vertex\",\"_i\",\"_il\",\"face\",\"normal\",\"applyMatrix3\",\"normalize\",\"j\",\"jl\",\"vertexNormals\",\"computeBoundingBox\",\"computeBoundingSphere\",\"rotateX\",\"angle\",\"makeRotationX\",\"rotateY\",\"makeRotationY\",\"rotateZ\",\"makeRotationZ\",\"translate\",\"x\",\"y\",\"z\",\"makeTranslation\",\"scale\",\"makeScale\",\"lookAt\",\"vector\",\"updateMatrix\",\"fromBufferGeometry\",\"geometry\",\"addFace\",\"a\",\"b\",\"c\",\"materialIndex\",\"vertexColors\",\"undefined\",\"color\",\"scope\",\"clone\",\"fromBufferAttribute\",\"push\",\"uv\",\"Vector2\",\"uv2\",\"index\",\"attributes\",\"position\",\"console\",\"error\",\"count\",\"Color\",\"groups\",\"_i2\",\"group\",\"start\",\"getX\",\"_i3\",\"_i4\",\"computeFaceNormals\",\"center\",\"getCenter\",\"negate\",\"radius\",\"s\",\"set\",\"cb\",\"ab\",\"f\",\"fl\",\"vA\",\"vB\",\"subVectors\",\"vC\",\"cross\",\"copy\",\"computeVertexNormals\",\"areaWeighted\",\"arguments\",\"Array\",\"v\",\"vl\",\"add\",\"_fl\",\"_f\",\"_face\",\"_v\",\"_vl\",\"_f2\",\"_fl2\",\"_face2\",\"computeFlatVertexNormals\",\"computeMorphNormals\",\"__originalFaceNormal\",\"__originalVertexNormals\",\"tmpGeo\",\"_i5\",\"_il2\",\"faceNormals\",\"dstNormalsFace\",\"dstNormalsVertex\",\"_f3\",\"_fl3\",\"faceNormal\",\"_f4\",\"_fl4\",\"_face3\",\"_vertexNormals\",\"_faceNormal\",\"_f5\",\"_fl5\",\"_face4\",\"Box3\",\"setFromPoints\",\"Sphere\",\"merge\",\"materialIndexOffset\",\"vertexOffset\",\"vertices1\",\"vertices2\",\"faces1\",\"faces2\",\"colors1\",\"colors2\",\"vertexCopy\",\"_i6\",\"_il3\",\"_i7\",\"_il4\",\"faceVertexNormals\",\"faceVertexColors\",\"faceCopy\",\"_j\",\"_jl\",\"_i8\",\"_il5\",\"faceVertexUvs2\",\"_jl2\",\"_j2\",\"uvs2\",\"uvsCopy\",\"k\",\"kl\",\"mergeMesh\",\"mesh\",\"isMesh\",\"matrixAutoUpdate\",\"mergeVertices\",\"verticesMap\",\"unique\",\"changes\",\"precision\",\"Math\",\"pow\",\"precisionPoints\",\"concat\",\"round\",\"faceIndicesToRemove\",\"_i9\",\"_il6\",\"n\",\"indices\",\"_i10\",\"idx\",\"splice\",\"diff\",\"points\",\"l\",\"point\",\"sortFacesByMaterialIndex\",\"_id\",\"sort\",\"materialIndexSort\",\"uvs1\",\"newUvs1\",\"newUvs2\",\"_i11\",\"id\",\"toJSON\",\"setBit\",\"enabled\",\"getNormalIndex\",\"hash\",\"toString\",\"normalsHash\",\"normals\",\"getColorIndex\",\"r\",\"g\",\"colorsHash\",\"getHex\",\"getUvIndex\",\"uvsHash\",\"uvs\",\"data\",\"metadata\",\"version\",\"generator\",\"parameters\",\"_i12\",\"hasFaceVertexUv\",\"hasFaceNormal\",\"hasFaceVertexNormal\",\"hasFaceColor\",\"hasFaceVertexColor\",\"faceType\",\"hasMaterial\",\"hasFaceUv\",\"source\",\"_i13\",\"_il7\",\"_i14\",\"_il8\",\"_i15\",\"_il9\",\"_i16\",\"_il10\",\"morphTarget\",\"_jl3\",\"_j3\",\"_jl4\",\"_j4\",\"_i17\",\"_il11\",\"morphNormal\",\"_jl5\",\"_j5\",\"srcVertexNormal\",\"destVertexNormal\",\"_jl6\",\"_j6\",\"_i18\",\"_il12\",\"_i19\",\"_il13\",\"_i20\",\"_il14\",\"toBufferGeometry\",\"fromGeometry\",\"DirectGeometry\",\"buffergeometry\",\"BufferGeometry\",\"positions\",\"Float32Array\",\"setAttribute\",\"copyVector3sArray\",\"BufferAttribute\",\"copyColorsArray\",\"copyVector2sArray\",\"array\",\"attribute\",\"Float32BufferAttribute\",\"morphAttributes\",\"copyVector4sArray\",\"computeTangents\",\"computeLineDistances\",\"applyMatrix\",\"warn\",\"dispose\",\"dispatchEvent\",\"EventDispatcher\",\"createBufferGeometryFromObject\",\"Geometry.createBufferGeometryFromObject\",\"object\",\"isPoints\",\"isLine\",\"copyArray\",\"computeGroups\",\"hasFaceVertexUv2\",\"morphTargetsLength\",\"morphTargetsPosition\",\"morphNormalsLength\",\"morphTargetsNormal\",\"_i21\",\"hasSkinIndices\",\"hasSkinWeights\",\"_i22\",\"vertexUvs\",\"_vertexUvs\",\"_j7\",\"isVector3\",\"isArray\",\"isColor\",\"_i23\",\"_il15\"]\n}\n"]