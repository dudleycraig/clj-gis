["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/modifiers/CurveModifier.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$modifiers$CurveModifier=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||\nObject.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});\nsuperClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||\n!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function getUniforms(splineTexture){return{spineTexture:{value:splineTexture},pathOffset:{type:\"f\",value:0},pathSegment:{type:\"f\",value:1},spineOffset:{type:\"f\",value:161},\nspineLength:{type:\"f\",value:400},flow:{type:\"i\",value:1}}}function modifyShader(material,uniforms){var numberOfCurves=2<arguments.length&&void 0!==arguments[2]?arguments[2]:1;material.__ok||(material.__ok=!0,material.onBeforeCompile=function(shader){if(!shader.__modified){shader.__modified=!0;Object.assign(shader.uniforms,uniforms);var vertexShader=\"\\n\\t\\tuniform sampler2D spineTexture;\\n\\t\\tuniform float pathOffset;\\n\\t\\tuniform float pathSegment;\\n\\t\\tuniform float spineOffset;\\n\\t\\tuniform float spineLength;\\n\\t\\tuniform int flow;\\n\\n\\t\\tfloat textureLayers \\x3d \".concat(TEXTURE_HEIGHT*\nnumberOfCurves,\".;\\n\\t\\tfloat textureStacks \\x3d \").concat(TEXTURE_HEIGHT/4,\".;\\n\\n\\t\\t\").concat(shader.vertexShader,\"\\n\\t\\t\").replace(\"#include \\x3cbeginnormal_vertex\\x3e\",\"\").replace(\"#include \\x3cdefaultnormal_vertex\\x3e\",\"\").replace(\"#include \\x3cbegin_vertex\\x3e\",\"\").replace(/void\\s*main\\s*\\(\\)\\s*\\{/,\"\\n        void main() {\\n        #include \\x3cbeginnormal_vertex\\x3e\\n\\n        vec4 worldPos \\x3d modelMatrix * vec4(position, 1.);\\n\\n        bool bend \\x3d flow \\x3e 0;\\n        float xWeight \\x3d bend ? 0. : 1.;\\n\\n        #ifdef USE_INSTANCING\\n        float pathOffsetFromInstanceMatrix \\x3d instanceMatrix[3][2];\\n        float spineLengthFromInstanceMatrix \\x3d instanceMatrix[3][0];\\n        float spinePortion \\x3d bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\\n        float mt \\x3d (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\\n        #else\\n        float spinePortion \\x3d bend ? (worldPos.x + spineOffset) / spineLength : 0.;\\n        float mt \\x3d (spinePortion * pathSegment + pathOffset)*textureStacks;\\n        #endif\\n\\n        mt \\x3d mod(mt, textureStacks);\\n        float rowOffset \\x3d floor(mt);\\n\\n        #ifdef USE_INSTANCING\\n        rowOffset +\\x3d instanceMatrix[3][1] * \".concat(TEXTURE_HEIGHT,\n\".;\\n        #endif\\n\\n        vec3 spinePos \\x3d texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 a \\x3d        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 b \\x3d        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 c \\x3d        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\\n        mat3 basis \\x3d mat3(a, b, c);\\n\\n        vec3 transformed \\x3d basis\\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\\n          + spinePos;\\n\\n        vec3 transformedNormal \\x3d normalMatrix * (basis * objectNormal);\\n\\t\\t\\t\")).replace(\"#include \\x3cproject_vertex\\x3e\",\n\"vec4 mvPosition \\x3d modelViewMatrix * vec4( transformed, 1.0 );\\n\\t\\t\\t\\tgl_Position \\x3d projectionMatrix * mvPosition;\");shader.vertexShader=vertexShader}})}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.getUniforms=getUniforms;exports.modifyShader=modifyShader;exports.updateSplineTexture=exports.initSplineTexture=exports.InstancedFlow=exports.Flow=void 0;var _defineProperty2=function(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}(require(\"module$node_modules$$babel$runtime$helpers$esm$defineProperty\")),\n_three=require(\"module$node_modules$three$build$three_module\"),TEXTURE_HEIGHT=4,initSplineTexture=function(){var numberOfCurves=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1,dataArray=new Float32Array(1024*TEXTURE_HEIGHT*numberOfCurves*3);numberOfCurves=new _three.DataTexture(dataArray,1024,TEXTURE_HEIGHT*numberOfCurves,_three.RGBFormat,_three.FloatType);numberOfCurves.wrapS=_three.RepeatWrapping;numberOfCurves.wrapT=_three.RepeatWrapping;numberOfCurves.magFilter=_three.NearestFilter;numberOfCurves.needsUpdate=\n!0;return numberOfCurves};exports.initSplineTexture=initSplineTexture;var updateSplineTexture=function(texture,splineCurve){var offset=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0,numberOfPoints=Math.floor(TEXTURE_HEIGHT/4*1024);splineCurve.arcLengthDivisions=numberOfPoints/2;splineCurve.updateArcLengths();for(var points=splineCurve.getSpacedPoints(numberOfPoints),frenetFrames=splineCurve.computeFrenetFrames(numberOfPoints,!0),i=0;i<numberOfPoints;i++){var rowOffset=Math.floor(i/1024),\nrowIndex=i%1024,pt=points[i];setTextureValue(texture,rowIndex,pt.x,pt.y,pt.z,0+rowOffset+TEXTURE_HEIGHT*offset);pt=frenetFrames.tangents[i];setTextureValue(texture,rowIndex,pt.x,pt.y,pt.z,1+rowOffset+TEXTURE_HEIGHT*offset);pt=frenetFrames.normals[i];setTextureValue(texture,rowIndex,pt.x,pt.y,pt.z,2+rowOffset+TEXTURE_HEIGHT*offset);pt=frenetFrames.binormals[i];setTextureValue(texture,rowIndex,pt.x,pt.y,pt.z,3+rowOffset+TEXTURE_HEIGHT*offset)}texture.needsUpdate=!0};exports.updateSplineTexture=updateSplineTexture;\nvar setTextureValue=function(texture,index,x,y,z,o){texture=texture.image.data;o*=3072;texture[3*index+o+0]=x;texture[3*index+o+1]=y;texture[3*index+o+2]=z};global=function(){function Flow(mesh){var numberOfCurves=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1;_classCallCheck(this,Flow);(0,_defineProperty2[\"default\"])(this,\"curveArray\",void 0);(0,_defineProperty2[\"default\"])(this,\"curveLengthArray\",void 0);(0,_defineProperty2[\"default\"])(this,\"object3D\",void 0);(0,_defineProperty2[\"default\"])(this,\n\"splineTexure\",void 0);(0,_defineProperty2[\"default\"])(this,\"uniforms\",void 0);var obj3D=mesh.clone(),splineTexure=initSplineTexture(numberOfCurves),uniforms=getUniforms(splineTexure);obj3D.traverse(function(child){if(child instanceof _three.Mesh||child instanceof _three.InstancedMesh)child.material=child.material.clone(),modifyShader(child.material,uniforms,numberOfCurves)});this.curveArray=Array(numberOfCurves);this.curveLengthArray=Array(numberOfCurves);this.object3D=obj3D;this.splineTexure=splineTexure;\nthis.uniforms=uniforms}_createClass(Flow,[{key:\"updateCurve\",value:function(index,curve){if(index>=this.curveArray.length)throw Error(\"Index out of range for Flow\");var curveLength=curve.getLength();this.uniforms.spineLength.value=curveLength;this.curveLengthArray[index]=curveLength;this.curveArray[index]=curve;updateSplineTexture(this.splineTexure,curve,index)}},{key:\"moveAlongCurve\",value:function(amount){this.uniforms.pathOffset.value+=amount}}]);return Flow}();exports.Flow=global;var matrix=new _three.Matrix4;\nglobal=function(_Flow){function InstancedFlow(count,curveCount,geometry,material){_classCallCheck(this,InstancedFlow);geometry=new _three.InstancedMesh(geometry,material,count);geometry.instanceMatrix.setUsage(_three.DynamicDrawUsage);curveCount=_getPrototypeOf(InstancedFlow).call(this,geometry,curveCount);curveCount=!curveCount||\"object\"!==_typeof(curveCount)&&\"function\"!==typeof curveCount?_assertThisInitialized(this):curveCount;(0,_defineProperty2[\"default\"])(_assertThisInitialized(curveCount),\n\"offsets\",void 0);(0,_defineProperty2[\"default\"])(_assertThisInitialized(curveCount),\"whichCurve\",void 0);curveCount.offsets=Array(count).fill(0);curveCount.whichCurve=Array(count).fill(0);return curveCount}_inherits(InstancedFlow,_Flow);_createClass(InstancedFlow,[{key:\"writeChanges\",value:function(index){matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]],this.whichCurve[index],this.offsets[index]);this.object3D.setMatrixAt(index,matrix);this.object3D.instanceMatrix.needsUpdate=\n!0}},{key:\"moveIndividualAlongCurve\",value:function(index,offset){this.offsets[index]+=offset;this.writeChanges(index)}},{key:\"setCurve\",value:function(index,curveNo){if(isNaN(curveNo))throw Error(\"curve index being set is Not a Number (NaN)\");this.whichCurve[index]=curveNo;this.writeChanges(index)}}]);return InstancedFlow}(global);exports.InstancedFlow=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$modifiers$CurveModifier\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getUniforms = getUniforms;\nexports.modifyShader = modifyShader;\nexports.updateSplineTexture = exports.initSplineTexture = exports.InstancedFlow = exports.Flow = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/esm/defineProperty\"));\n\nvar _three = require(\"three\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Original src: https://github.com/zz85/threejs-path-flow\nvar BITS = 3;\nvar TEXTURE_WIDTH = 1024;\nvar TEXTURE_HEIGHT = 4;\n/**\n * Make a new DataTexture to store the descriptions of the curves.\n *\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\n */\n\nvar initSplineTexture = function initSplineTexture() {\n  var numberOfCurves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * BITS);\n  var dataTexture = new _three.DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, _three.RGBFormat, _three.FloatType);\n  dataTexture.wrapS = _three.RepeatWrapping;\n  dataTexture.wrapT = _three.RepeatWrapping;\n  dataTexture.magFilter = _three.NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\n/**\n * Write the curve description to the data texture\n *\n * @param { DataTexture } texture The DataTexture to write to\n * @param { Curve } splineCurve The curve to describe\n * @param { number } offset Which curve slot to write to\n */\n\n\nexports.initSplineTexture = initSplineTexture;\n\nvar updateSplineTexture = function updateSplineTexture(texture, splineCurve) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  var points = splineCurve.getSpacedPoints(numberOfPoints);\n  var frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n\n  for (var i = 0; i < numberOfPoints; i++) {\n    var rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    var rowIndex = i % TEXTURE_WIDTH;\n    var pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n\n  texture.needsUpdate = true;\n};\n\nexports.updateSplineTexture = updateSplineTexture;\n\nvar setTextureValue = function setTextureValue(texture, index, x, y, z, o) {\n  var image = texture.image;\n  var data = image.data;\n  var i = BITS * TEXTURE_WIDTH * o; // Row Offset\n\n  data[index * BITS + i + 0] = x;\n  data[index * BITS + i + 1] = y;\n  data[index * BITS + i + 2] = z;\n};\n/**\n * Create a new set of uniforms for describing the curve modifier\n *\n * @param { DataTexture } Texture which holds the curve description\n */\n\n\nfunction getUniforms(splineTexture) {\n  var uniforms = {\n    spineTexture: {\n      value: splineTexture\n    },\n    pathOffset: {\n      type: 'f',\n      value: 0\n    },\n    // time of path curve\n    pathSegment: {\n      type: 'f',\n      value: 1\n    },\n    // fractional length of path\n    spineOffset: {\n      type: 'f',\n      value: 161\n    },\n    spineLength: {\n      type: 'f',\n      value: 400\n    },\n    flow: {\n      type: 'i',\n      value: 1\n    }\n  };\n  return uniforms;\n}\n\nfunction modifyShader(material, uniforms) {\n  var numberOfCurves = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (material.__ok) return;\n  material.__ok = true;\n\n  material.onBeforeCompile = function (shader) {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    var vertexShader =\n    /* glsl */\n    \"\\n\\t\\tuniform sampler2D spineTexture;\\n\\t\\tuniform float pathOffset;\\n\\t\\tuniform float pathSegment;\\n\\t\\tuniform float spineOffset;\\n\\t\\tuniform float spineLength;\\n\\t\\tuniform int flow;\\n\\n\\t\\tfloat textureLayers = \".concat(TEXTURE_HEIGHT * numberOfCurves, \".;\\n\\t\\tfloat textureStacks = \").concat(TEXTURE_HEIGHT / 4, \".;\\n\\n\\t\\t\").concat(shader.vertexShader, \"\\n\\t\\t\") // chunk import moved in front of modified shader below\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\n    .replace('#include <begin_vertex>', '') // shader override\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/,\n    /* glsl */\n    \"\\n        void main() {\\n        #include <beginnormal_vertex>\\n\\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\\n\\n        bool bend = flow > 0;\\n        float xWeight = bend ? 0. : 1.;\\n\\n        #ifdef USE_INSTANCING\\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\\n        #else\\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\\n        #endif\\n\\n        mt = mod(mt, textureStacks);\\n        float rowOffset = floor(mt);\\n\\n        #ifdef USE_INSTANCING\\n        rowOffset += instanceMatrix[3][1] * \".concat(TEXTURE_HEIGHT, \".;\\n        #endif\\n\\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\\n        mat3 basis = mat3(a, b, c);\\n\\n        vec3 transformed = basis\\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\\n          + spinePos;\\n\\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\\n\\t\\t\\t\")).replace('#include <project_vertex>',\n    /* glsl */\n    \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n\\t\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\");\n    shader.vertexShader = vertexShader;\n  };\n}\n/**\n * A helper class for making meshes bend aroudn curves\n */\n\n\nvar Flow =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\n   */\n  function Flow(mesh) {\n    var numberOfCurves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _classCallCheck(this, Flow);\n\n    (0, _defineProperty2[\"default\"])(this, \"curveArray\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"curveLengthArray\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"object3D\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"splineTexure\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"uniforms\", void 0);\n    var obj3D = mesh.clone();\n    var splineTexure = initSplineTexture(numberOfCurves);\n    var uniforms = getUniforms(splineTexure);\n    obj3D.traverse(function (child) {\n      if (child instanceof _three.Mesh || child instanceof _three.InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n\n  _createClass(Flow, [{\n    key: \"updateCurve\",\n    value: function updateCurve(index, curve) {\n      if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\n      var curveLength = curve.getLength();\n      this.uniforms.spineLength.value = curveLength;\n      this.curveLengthArray[index] = curveLength;\n      this.curveArray[index] = curve;\n      updateSplineTexture(this.splineTexure, curve, index);\n    }\n  }, {\n    key: \"moveAlongCurve\",\n    value: function moveAlongCurve(amount) {\n      this.uniforms.pathOffset.value += amount;\n    }\n  }]);\n\n  return Flow;\n}();\n\nexports.Flow = Flow;\nvar matrix = new _three.Matrix4();\n/**\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\n */\n\nvar InstancedFlow =\n/*#__PURE__*/\nfunction (_Flow) {\n  _inherits(InstancedFlow, _Flow);\n\n  /**\n   *\n   * @param {number} count The number of instanced elements\n   * @param {number} curveCount The number of curves to preallocate for\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\n   * @param {Material} material The material to use for the instanced mesh\n   */\n  function InstancedFlow(count, curveCount, geometry, material) {\n    var _this;\n\n    _classCallCheck(this, InstancedFlow);\n\n    var mesh = new _three.InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(_three.DynamicDrawUsage);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InstancedFlow).call(this, mesh, curveCount));\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"offsets\", void 0);\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"whichCurve\", void 0);\n    _this.offsets = new Array(count).fill(0);\n    _this.whichCurve = new Array(count).fill(0);\n    return _this;\n  }\n  /**\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\n   * This writes that information to the matrix and marks it as needing update.\n   *\n   * @param {number} index of the instanced element to update\n   */\n\n\n  _createClass(InstancedFlow, [{\n    key: \"writeChanges\",\n    value: function writeChanges(index) {\n      matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n      this.object3D.setMatrixAt(index, matrix);\n      this.object3D.instanceMatrix.needsUpdate = true;\n    }\n    /**\n     * Move an individual element along the curve by a specific amount\n     *\n     * @param {number} index Which element to update\n     * @param {number} offset Move by how much\n     */\n\n  }, {\n    key: \"moveIndividualAlongCurve\",\n    value: function moveIndividualAlongCurve(index, offset) {\n      this.offsets[index] += offset;\n      this.writeChanges(index);\n    }\n    /**\n     * Select which curve to use for an element\n     *\n     * @param {number} index the index of the instanced element to update\n     * @param {number} curveNo the index of the curve it should use\n     */\n\n  }, {\n    key: \"setCurve\",\n    value: function setCurve(index, curveNo) {\n      if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\n      this.whichCurve[index] = curveNo;\n      this.writeChanges(index);\n    }\n  }]);\n\n  return InstancedFlow;\n}(Flow);\n\nexports.InstancedFlow = InstancedFlow;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$$babel$runtime$helpers$esm$defineProperty"]],"~:properties",["^5",["wrapS","needsUpdate","spineOffset","curveLengthArray","prototype","splineTexure","__modified","spineTexture","key","__esModule","spineLength","vertexShader","configurable","value","initSplineTexture","modifyShader","enumerable","magFilter","writable","updateSplineTexture","object3D","whichCurve","pathSegment","type","InstancedFlow","pathOffset","onBeforeCompile","wrapT","__proto__","arcLengthDivisions","uniforms","flow","offsets","constructor","__ok","Flow","curveArray","getUniforms","material"]],"~:compiled-at",1630917515165,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$modifiers$CurveModifier.js\",\n\"lineCount\":17,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/modifiers/CurveModifier.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$modifiers$CurveModifier\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.getUniforms = getUniforms;\\nexports.modifyShader = modifyShader;\\nexports.updateSplineTexture = exports.initSplineTexture = exports.InstancedFlow = exports.Flow = void 0;\\n\\nvar _defineProperty2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/esm/defineProperty\\\"));\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \\\"default\\\": obj }; }\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\n// Original src: https://github.com/zz85/threejs-path-flow\\nvar BITS = 3;\\nvar TEXTURE_WIDTH = 1024;\\nvar TEXTURE_HEIGHT = 4;\\n/**\\n * Make a new DataTexture to store the descriptions of the curves.\\n *\\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\\n */\\n\\nvar initSplineTexture = function initSplineTexture() {\\n  var numberOfCurves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n  var dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * BITS);\\n  var dataTexture = new _three.DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, _three.RGBFormat, _three.FloatType);\\n  dataTexture.wrapS = _three.RepeatWrapping;\\n  dataTexture.wrapT = _three.RepeatWrapping;\\n  dataTexture.magFilter = _three.NearestFilter;\\n  dataTexture.needsUpdate = true;\\n  return dataTexture;\\n};\\n/**\\n * Write the curve description to the data texture\\n *\\n * @param { DataTexture } texture The DataTexture to write to\\n * @param { Curve } splineCurve The curve to describe\\n * @param { number } offset Which curve slot to write to\\n */\\n\\n\\nexports.initSplineTexture = initSplineTexture;\\n\\nvar updateSplineTexture = function updateSplineTexture(texture, splineCurve) {\\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n  var numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\\n  splineCurve.updateArcLengths();\\n  var points = splineCurve.getSpacedPoints(numberOfPoints);\\n  var frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\\n\\n  for (var i = 0; i < numberOfPoints; i++) {\\n    var rowOffset = Math.floor(i / TEXTURE_WIDTH);\\n    var rowIndex = i % TEXTURE_WIDTH;\\n    var pt = points[i];\\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\\n    pt = frenetFrames.tangents[i];\\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\\n    pt = frenetFrames.normals[i];\\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\\n    pt = frenetFrames.binormals[i];\\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\\n  }\\n\\n  texture.needsUpdate = true;\\n};\\n\\nexports.updateSplineTexture = updateSplineTexture;\\n\\nvar setTextureValue = function setTextureValue(texture, index, x, y, z, o) {\\n  var image = texture.image;\\n  var data = image.data;\\n  var i = BITS * TEXTURE_WIDTH * o; // Row Offset\\n\\n  data[index * BITS + i + 0] = x;\\n  data[index * BITS + i + 1] = y;\\n  data[index * BITS + i + 2] = z;\\n};\\n/**\\n * Create a new set of uniforms for describing the curve modifier\\n *\\n * @param { DataTexture } Texture which holds the curve description\\n */\\n\\n\\nfunction getUniforms(splineTexture) {\\n  var uniforms = {\\n    spineTexture: {\\n      value: splineTexture\\n    },\\n    pathOffset: {\\n      type: 'f',\\n      value: 0\\n    },\\n    // time of path curve\\n    pathSegment: {\\n      type: 'f',\\n      value: 1\\n    },\\n    // fractional length of path\\n    spineOffset: {\\n      type: 'f',\\n      value: 161\\n    },\\n    spineLength: {\\n      type: 'f',\\n      value: 400\\n    },\\n    flow: {\\n      type: 'i',\\n      value: 1\\n    }\\n  };\\n  return uniforms;\\n}\\n\\nfunction modifyShader(material, uniforms) {\\n  var numberOfCurves = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n  if (material.__ok) return;\\n  material.__ok = true;\\n\\n  material.onBeforeCompile = function (shader) {\\n    if (shader.__modified) return;\\n    shader.__modified = true;\\n    Object.assign(shader.uniforms, uniforms);\\n    var vertexShader =\\n    /* glsl */\\n    \\\"\\\\n\\\\t\\\\tuniform sampler2D spineTexture;\\\\n\\\\t\\\\tuniform float pathOffset;\\\\n\\\\t\\\\tuniform float pathSegment;\\\\n\\\\t\\\\tuniform float spineOffset;\\\\n\\\\t\\\\tuniform float spineLength;\\\\n\\\\t\\\\tuniform int flow;\\\\n\\\\n\\\\t\\\\tfloat textureLayers = \\\".concat(TEXTURE_HEIGHT * numberOfCurves, \\\".;\\\\n\\\\t\\\\tfloat textureStacks = \\\").concat(TEXTURE_HEIGHT / 4, \\\".;\\\\n\\\\n\\\\t\\\\t\\\").concat(shader.vertexShader, \\\"\\\\n\\\\t\\\\t\\\") // chunk import moved in front of modified shader below\\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\\n    .replace('#include <begin_vertex>', '') // shader override\\n    .replace(/void\\\\s*main\\\\s*\\\\(\\\\)\\\\s*\\\\{/,\\n    /* glsl */\\n    \\\"\\\\n        void main() {\\\\n        #include <beginnormal_vertex>\\\\n\\\\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\\\\n\\\\n        bool bend = flow > 0;\\\\n        float xWeight = bend ? 0. : 1.;\\\\n\\\\n        #ifdef USE_INSTANCING\\\\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\\\\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\\\\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\\\\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\\\\n        #else\\\\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\\\\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\\\\n        #endif\\\\n\\\\n        mt = mod(mt, textureStacks);\\\\n        float rowOffset = floor(mt);\\\\n\\\\n        #ifdef USE_INSTANCING\\\\n        rowOffset += instanceMatrix[3][1] * \\\".concat(TEXTURE_HEIGHT, \\\".;\\\\n        #endif\\\\n\\\\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\\\\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\\\\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\\\\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\\\\n        mat3 basis = mat3(a, b, c);\\\\n\\\\n        vec3 transformed = basis\\\\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\\\\n          + spinePos;\\\\n\\\\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\\\\n\\\\t\\\\t\\\\t\\\")).replace('#include <project_vertex>',\\n    /* glsl */\\n    \\\"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\\\n\\\\t\\\\t\\\\t\\\\tgl_Position = projectionMatrix * mvPosition;\\\");\\n    shader.vertexShader = vertexShader;\\n  };\\n}\\n/**\\n * A helper class for making meshes bend aroudn curves\\n */\\n\\n\\nvar Flow =\\n/*#__PURE__*/\\nfunction () {\\n  /**\\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\\n   */\\n  function Flow(mesh) {\\n    var numberOfCurves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n    _classCallCheck(this, Flow);\\n\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"curveArray\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"curveLengthArray\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"object3D\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"splineTexure\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"uniforms\\\", void 0);\\n    var obj3D = mesh.clone();\\n    var splineTexure = initSplineTexture(numberOfCurves);\\n    var uniforms = getUniforms(splineTexure);\\n    obj3D.traverse(function (child) {\\n      if (child instanceof _three.Mesh || child instanceof _three.InstancedMesh) {\\n        child.material = child.material.clone();\\n        modifyShader(child.material, uniforms, numberOfCurves);\\n      }\\n    });\\n    this.curveArray = new Array(numberOfCurves);\\n    this.curveLengthArray = new Array(numberOfCurves);\\n    this.object3D = obj3D;\\n    this.splineTexure = splineTexure;\\n    this.uniforms = uniforms;\\n  }\\n\\n  _createClass(Flow, [{\\n    key: \\\"updateCurve\\\",\\n    value: function updateCurve(index, curve) {\\n      if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\\n      var curveLength = curve.getLength();\\n      this.uniforms.spineLength.value = curveLength;\\n      this.curveLengthArray[index] = curveLength;\\n      this.curveArray[index] = curve;\\n      updateSplineTexture(this.splineTexure, curve, index);\\n    }\\n  }, {\\n    key: \\\"moveAlongCurve\\\",\\n    value: function moveAlongCurve(amount) {\\n      this.uniforms.pathOffset.value += amount;\\n    }\\n  }]);\\n\\n  return Flow;\\n}();\\n\\nexports.Flow = Flow;\\nvar matrix = new _three.Matrix4();\\n/**\\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\\n */\\n\\nvar InstancedFlow =\\n/*#__PURE__*/\\nfunction (_Flow) {\\n  _inherits(InstancedFlow, _Flow);\\n\\n  /**\\n   *\\n   * @param {number} count The number of instanced elements\\n   * @param {number} curveCount The number of curves to preallocate for\\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\\n   * @param {Material} material The material to use for the instanced mesh\\n   */\\n  function InstancedFlow(count, curveCount, geometry, material) {\\n    var _this;\\n\\n    _classCallCheck(this, InstancedFlow);\\n\\n    var mesh = new _three.InstancedMesh(geometry, material, count);\\n    mesh.instanceMatrix.setUsage(_three.DynamicDrawUsage);\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InstancedFlow).call(this, mesh, curveCount));\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"offsets\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"whichCurve\\\", void 0);\\n    _this.offsets = new Array(count).fill(0);\\n    _this.whichCurve = new Array(count).fill(0);\\n    return _this;\\n  }\\n  /**\\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\\n   * This writes that information to the matrix and marks it as needing update.\\n   *\\n   * @param {number} index of the instanced element to update\\n   */\\n\\n\\n  _createClass(InstancedFlow, [{\\n    key: \\\"writeChanges\\\",\\n    value: function writeChanges(index) {\\n      matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\\n      this.object3D.setMatrixAt(index, matrix);\\n      this.object3D.instanceMatrix.needsUpdate = true;\\n    }\\n    /**\\n     * Move an individual element along the curve by a specific amount\\n     *\\n     * @param {number} index Which element to update\\n     * @param {number} offset Move by how much\\n     */\\n\\n  }, {\\n    key: \\\"moveIndividualAlongCurve\\\",\\n    value: function moveIndividualAlongCurve(index, offset) {\\n      this.offsets[index] += offset;\\n      this.writeChanges(index);\\n    }\\n    /**\\n     * Select which curve to use for an element\\n     *\\n     * @param {number} index the index of the instanced element to update\\n     * @param {number} curveNo the index of the curve it should use\\n     */\\n\\n  }, {\\n    key: \\\"setCurve\\\",\\n    value: function setCurve(index, curveNo) {\\n      if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\\n      this.whichCurve[index] = curveNo;\\n      this.writeChanges(index);\\n    }\\n  }]);\\n\\n  return InstancedFlow;\\n}(Flow);\\n\\nexports.InstancedFlow = InstancedFlow;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_assertThisInitialized\",\"self\",\"ReferenceError\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"_classCallCheck\",\"instance\",\"Constructor\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"defineProperty\",\"key\",\"_createClass\",\"protoProps\",\"staticProps\",\"getUniforms\",\"splineTexture\",\"uniforms\",\"spineTexture\",\"pathOffset\",\"type\",\"pathSegment\",\"spineOffset\",\"spineLength\",\"flow\",\"modifyShader\",\"material\",\"numberOfCurves\",\"arguments\",\"undefined\",\"__ok\",\"onBeforeCompile\",\"material.onBeforeCompile\",\"shader\",\"__modified\",\"assign\",\"vertexShader\",\"concat\",\"TEXTURE_HEIGHT\",\"replace\",\"updateSplineTexture\",\"initSplineTexture\",\"InstancedFlow\",\"Flow\",\"_defineProperty2\",\"_interopRequireDefault\",\"__esModule\",\"_three\",\"dataArray\",\"Float32Array\",\"TEXTURE_WIDTH\",\"BITS\",\"dataTexture\",\"DataTexture\",\"RGBFormat\",\"FloatType\",\"wrapS\",\"RepeatWrapping\",\"wrapT\",\"magFilter\",\"NearestFilter\",\"needsUpdate\",\"texture\",\"splineCurve\",\"offset\",\"numberOfPoints\",\"Math\",\"floor\",\"arcLengthDivisions\",\"updateArcLengths\",\"points\",\"getSpacedPoints\",\"frenetFrames\",\"computeFrenetFrames\",\"rowOffset\",\"rowIndex\",\"pt\",\"setTextureValue\",\"x\",\"y\",\"z\",\"tangents\",\"normals\",\"binormals\",\"index\",\"data\",\"image\",\"mesh\",\"obj3D\",\"clone\",\"splineTexure\",\"traverse\",\"child\",\"Mesh\",\"InstancedMesh\",\"curveArray\",\"Array\",\"curveLengthArray\",\"object3D\",\"updateCurve\",\"curve\",\"Error\",\"curveLength\",\"getLength\",\"moveAlongCurve\",\"amount\",\"matrix\",\"Matrix4\",\"_Flow\",\"count\",\"curveCount\",\"geometry\",\"instanceMatrix\",\"setUsage\",\"DynamicDrawUsage\",\"call\",\"_this\",\"offsets\",\"fill\",\"whichCurve\",\"writeChanges\",\"makeTranslation\",\"setMatrixAt\",\"moveIndividualAlongCurve\",\"setCurve\",\"curveNo\",\"isNaN\"]\n}\n"]