["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/SAOShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$SAOShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.SAOShader=void 0;global=require(\"module$node_modules$three$build$three_module\");global={defines:{NUM_SAMPLES:7,NUM_RINGS:4,NORMAL_TEXTURE:0,DIFFUSE_TEXTURE:0,DEPTH_PACKING:1,PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{value:null},tDiffuse:{value:null},tNormal:{value:null},size:{value:new global.Vector2(512,512)},cameraNear:{value:1},cameraFar:{value:100},\ncameraProjectionMatrix:{value:new global.Matrix4},cameraInverseProjectionMatrix:{value:new global.Matrix4},scale:{value:1},intensity:{value:.1},bias:{value:.5},minResolution:{value:0},kernelRadius:{value:100},randomSeed:{value:0}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"#include \\x3ccommon\\x3e\\nvarying vec2 vUv;\\n#if DIFFUSE_TEXTURE \\x3d\\x3d 1\\nuniform sampler2D tDiffuse;\\n#endif\\nuniform sampler2D tDepth;\\n#if NORMAL_TEXTURE \\x3d\\x3d 1\\nuniform sampler2D tNormal;\\n#endif\\nuniform float cameraNear;\\nuniform float cameraFar;\\nuniform mat4 cameraProjectionMatrix;\\nuniform mat4 cameraInverseProjectionMatrix;\\nuniform float scale;\\nuniform float intensity;\\nuniform float bias;\\nuniform float kernelRadius;\\nuniform float minResolution;\\nuniform vec2 size;\\nuniform float randomSeed;\\n// RGBA depth\\n#include \\x3cpacking\\x3e\\nvec4 getDefaultColor( const in vec2 screenPosition ) {\\n\\t#if DIFFUSE_TEXTURE \\x3d\\x3d 1\\n\\treturn texture2D( tDiffuse, vUv );\\n\\t#else\\n\\treturn vec4( 1.0 );\\n\\t#endif\\n}\\nfloat getDepth( const in vec2 screenPosition ) {\\n\\t#if DEPTH_PACKING \\x3d\\x3d 1\\n\\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\\n\\t#else\\n\\treturn texture2D( tDepth, screenPosition ).x;\\n\\t#endif\\n}\\nfloat getViewZ( const in float depth ) {\\n\\t#if PERSPECTIVE_CAMERA \\x3d\\x3d 1\\n\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\\n\\t#else\\n\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\\n\\t#endif\\n}\\nvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\\n\\tfloat clipW \\x3d cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\\n\\tvec4 clipPosition \\x3d vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\\n\\tclipPosition *\\x3d clipW; // unprojection.\\n\\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\\n}\\nvec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\\n\\t#if NORMAL_TEXTURE \\x3d\\x3d 1\\n\\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\\n\\t#else\\n\\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\\n\\t#endif\\n}\\nfloat scaleDividedByCameraFar;\\nfloat minResolutionMultipliedByCameraFar;\\nfloat getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\\n\\tvec3 viewDelta \\x3d sampleViewPosition - centerViewPosition;\\n\\tfloat viewDistance \\x3d length( viewDelta );\\n\\tfloat scaledScreenDistance \\x3d scaleDividedByCameraFar * viewDistance;\\n\\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\\n}\\n// moving costly divides into consts\\nconst float ANGLE_STEP \\x3d PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\\nconst float INV_NUM_SAMPLES \\x3d 1.0 / float( NUM_SAMPLES );\\nfloat getAmbientOcclusion( const in vec3 centerViewPosition ) {\\n\\t// precompute some variables require in getOcclusion.\\n\\tscaleDividedByCameraFar \\x3d scale / cameraFar;\\n\\tminResolutionMultipliedByCameraFar \\x3d minResolution * cameraFar;\\n\\tvec3 centerViewNormal \\x3d getViewNormal( centerViewPosition, vUv );\\n\\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\\n\\tfloat angle \\x3d rand( vUv + randomSeed ) * PI2;\\n\\tvec2 radius \\x3d vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\\n\\tvec2 radiusStep \\x3d radius;\\n\\tfloat occlusionSum \\x3d 0.0;\\n\\tfloat weightSum \\x3d 0.0;\\n\\tfor( int i \\x3d 0; i \\x3c NUM_SAMPLES; i ++ ) {\\n\\t\\tvec2 sampleUv \\x3d vUv + vec2( cos( angle ), sin( angle ) ) * radius;\\n\\t\\tradius +\\x3d radiusStep;\\n\\t\\tangle +\\x3d ANGLE_STEP;\\n\\t\\tfloat sampleDepth \\x3d getDepth( sampleUv );\\n\\t\\tif( sampleDepth \\x3e\\x3d ( 1.0 - EPSILON ) ) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tfloat sampleViewZ \\x3d getViewZ( sampleDepth );\\n\\t\\tvec3 sampleViewPosition \\x3d getViewPosition( sampleUv, sampleDepth, sampleViewZ );\\n\\t\\tocclusionSum +\\x3d getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\\n\\t\\tweightSum +\\x3d 1.0;\\n\\t}\\n\\tif( weightSum \\x3d\\x3d 0.0 ) discard;\\n\\treturn occlusionSum * ( intensity / weightSum );\\n}\\nvoid main() {\\n\\tfloat centerDepth \\x3d getDepth( vUv );\\n\\tif( centerDepth \\x3e\\x3d ( 1.0 - EPSILON ) ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tfloat centerViewZ \\x3d getViewZ( centerDepth );\\n\\tvec3 viewPosition \\x3d getViewPosition( vUv, centerDepth, centerViewZ );\\n\\tfloat ambientOcclusion \\x3d getAmbientOcclusion( viewPosition );\\n\\tgl_FragColor \\x3d getDefaultColor( vUv );\\n\\tgl_FragColor.xyz *\\x3d  1.0 - ambientOcclusion;\\n}\"};\nexports.SAOShader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$SAOShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SAOShader = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * TODO\n */\nvar SAOShader = {\n  defines: {\n    NUM_SAMPLES: 7,\n    NUM_RINGS: 4,\n    NORMAL_TEXTURE: 0,\n    DIFFUSE_TEXTURE: 0,\n    DEPTH_PACKING: 1,\n    PERSPECTIVE_CAMERA: 1\n  },\n  uniforms: {\n    tDepth: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tNormal: {\n      value: null\n    },\n    size: {\n      value: new _three.Vector2(512, 512)\n    },\n    cameraNear: {\n      value: 1\n    },\n    cameraFar: {\n      value: 100\n    },\n    cameraProjectionMatrix: {\n      value: new _three.Matrix4()\n    },\n    cameraInverseProjectionMatrix: {\n      value: new _three.Matrix4()\n    },\n    scale: {\n      value: 1.0\n    },\n    intensity: {\n      value: 0.1\n    },\n    bias: {\n      value: 0.5\n    },\n    minResolution: {\n      value: 0.0\n    },\n    kernelRadius: {\n      value: 100.0\n    },\n    randomSeed: {\n      value: 0.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', '#if DIFFUSE_TEXTURE == 1', 'uniform sampler2D tDiffuse;', '#endif', 'uniform sampler2D tDepth;', '#if NORMAL_TEXTURE == 1', 'uniform sampler2D tNormal;', '#endif', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float scale;', 'uniform float intensity;', 'uniform float bias;', 'uniform float kernelRadius;', 'uniform float minResolution;', 'uniform vec2 size;', 'uniform float randomSeed;', '// RGBA depth', '#include <packing>', 'vec4 getDefaultColor( const in vec2 screenPosition ) {', '\t#if DIFFUSE_TEXTURE == 1', '\treturn texture2D( tDiffuse, vUv );', '\t#else', '\treturn vec4( 1.0 );', '\t#endif', '}', 'float getDepth( const in vec2 screenPosition ) {', '\t#if DEPTH_PACKING == 1', '\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\t#else', '\treturn texture2D( tDepth, screenPosition ).x;', '\t#endif', '}', 'float getViewZ( const in float depth ) {', '\t#if PERSPECTIVE_CAMERA == 1', '\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\t#else', '\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\tclipPosition *= clipW; // unprojection.', '\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {', '\t#if NORMAL_TEXTURE == 1', '\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '\t#else', '\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );', '\t#endif', '}', 'float scaleDividedByCameraFar;', 'float minResolutionMultipliedByCameraFar;', 'float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {', '\tvec3 viewDelta = sampleViewPosition - centerViewPosition;', '\tfloat viewDistance = length( viewDelta );', '\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;', '\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );', '}', '// moving costly divides into consts', 'const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );', 'const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );', 'float getAmbientOcclusion( const in vec3 centerViewPosition ) {', '\t// precompute some variables require in getOcclusion.', '\tscaleDividedByCameraFar = scale / cameraFar;', '\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;', '\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );', '\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/', '\tfloat angle = rand( vUv + randomSeed ) * PI2;', '\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;', '\tvec2 radiusStep = radius;', '\tfloat occlusionSum = 0.0;', '\tfloat weightSum = 0.0;', '\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {', '\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;', '\t\tradius += radiusStep;', '\t\tangle += ANGLE_STEP;', '\t\tfloat sampleDepth = getDepth( sampleUv );', '\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {', '\t\t\tcontinue;', '\t\t}', '\t\tfloat sampleViewZ = getViewZ( sampleDepth );', '\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );', '\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );', '\t\tweightSum += 1.0;', '\t}', '\tif( weightSum == 0.0 ) discard;', '\treturn occlusionSum * ( intensity / weightSum );', '}', 'void main() {', '\tfloat centerDepth = getDepth( vUv );', '\tif( centerDepth >= ( 1.0 - EPSILON ) ) {', '\t\tdiscard;', '\t}', '\tfloat centerViewZ = getViewZ( centerDepth );', '\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );', '\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );', '\tgl_FragColor = getDefaultColor( vUv );', '\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;', '}'].join('\\n')\n};\nexports.SAOShader = SAOShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","intensity","cameraProjectionMatrix","SAOShader","NUM_RINGS","tNormal","PERSPECTIVE_CAMERA","cameraInverseProjectionMatrix","cameraFar","scale","randomSeed","kernelRadius","__esModule","tDiffuse","defines","NUM_SAMPLES","NORMAL_TEXTURE","vertexShader","value","DIFFUSE_TEXTURE","tDepth","minResolution","DEPTH_PACKING","cameraNear","size","bias","uniforms"]],"~:compiled-at",1630917515517,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$SAOShader.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,kDAAA,CAAuE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG/GC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,SAAR,CAAoB,IAAK,EAErBC,OAAAA,CAASP,OAAA,CAAQ,8CAAR,CAKTM,OAAAA,CAAY,CACdE,QAAS,CACPC,YAAa,CADN,CAEPC,UAAW,CAFJ,CAGPC,eAAgB,CAHT,CAIPC,gBAAiB,CAJV,CAKPC,cAAe,CALR,CAMPC,mBAAoB,CANb,CADK,CASdC,SAAU,CACRC,OAAQ,CACNX,MAAO,IADD,CADA,CAIRY,SAAU,CACRZ,MAAO,IADC,CAJF,CAORa,QAAS,CACPb,MAAO,IADA,CAPD,CAURc,KAAM,CACJd,MAAO,IAAIE,MAAOa,CAAAA,OAAX,CAAmB,GAAnB,CAAwB,GAAxB,CADH,CAVE,CAaRC,WAAY,CACVhB,MAAO,CADG,CAbJ,CAgBRiB,UAAW,CACTjB,MAAO,GADE,CAhBH;AAmBRkB,uBAAwB,CACtBlB,MAAO,IAAIE,MAAOiB,CAAAA,OADI,CAnBhB,CAsBRC,8BAA+B,CAC7BpB,MAAO,IAAIE,MAAOiB,CAAAA,OADW,CAtBvB,CAyBRE,MAAO,CACLrB,MAAO,CADF,CAzBC,CA4BRsB,UAAW,CACTtB,MAAO,EADE,CA5BH,CA+BRuB,KAAM,CACJvB,MAAO,EADH,CA/BE,CAkCRwB,cAAe,CACbxB,MAAO,CADM,CAlCP,CAqCRyB,aAAc,CACZzB,MAAO,GADK,CArCN,CAwCR0B,WAAY,CACV1B,MAAO,CADG,CAxCJ,CATI,CAqDd2B,aAAiJ,qIArDnI,CAsDdC,eAA6/H,osIAtD/+H,CAwDhB/B;OAAQI,CAAAA,SAAR,CAAoBA,MArE2F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/SAOShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$SAOShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.SAOShader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * TODO\\n */\\nvar SAOShader = {\\n  defines: {\\n    NUM_SAMPLES: 7,\\n    NUM_RINGS: 4,\\n    NORMAL_TEXTURE: 0,\\n    DIFFUSE_TEXTURE: 0,\\n    DEPTH_PACKING: 1,\\n    PERSPECTIVE_CAMERA: 1\\n  },\\n  uniforms: {\\n    tDepth: {\\n      value: null\\n    },\\n    tDiffuse: {\\n      value: null\\n    },\\n    tNormal: {\\n      value: null\\n    },\\n    size: {\\n      value: new _three.Vector2(512, 512)\\n    },\\n    cameraNear: {\\n      value: 1\\n    },\\n    cameraFar: {\\n      value: 100\\n    },\\n    cameraProjectionMatrix: {\\n      value: new _three.Matrix4()\\n    },\\n    cameraInverseProjectionMatrix: {\\n      value: new _three.Matrix4()\\n    },\\n    scale: {\\n      value: 1.0\\n    },\\n    intensity: {\\n      value: 0.1\\n    },\\n    bias: {\\n      value: 0.5\\n    },\\n    minResolution: {\\n      value: 0.0\\n    },\\n    kernelRadius: {\\n      value: 100.0\\n    },\\n    randomSeed: {\\n      value: 0.0\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['#include <common>', 'varying vec2 vUv;', '#if DIFFUSE_TEXTURE == 1', 'uniform sampler2D tDiffuse;', '#endif', 'uniform sampler2D tDepth;', '#if NORMAL_TEXTURE == 1', 'uniform sampler2D tNormal;', '#endif', 'uniform float cameraNear;', 'uniform float cameraFar;', 'uniform mat4 cameraProjectionMatrix;', 'uniform mat4 cameraInverseProjectionMatrix;', 'uniform float scale;', 'uniform float intensity;', 'uniform float bias;', 'uniform float kernelRadius;', 'uniform float minResolution;', 'uniform vec2 size;', 'uniform float randomSeed;', '// RGBA depth', '#include <packing>', 'vec4 getDefaultColor( const in vec2 screenPosition ) {', '\\t#if DIFFUSE_TEXTURE == 1', '\\treturn texture2D( tDiffuse, vUv );', '\\t#else', '\\treturn vec4( 1.0 );', '\\t#endif', '}', 'float getDepth( const in vec2 screenPosition ) {', '\\t#if DEPTH_PACKING == 1', '\\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '\\t#else', '\\treturn texture2D( tDepth, screenPosition ).x;', '\\t#endif', '}', 'float getViewZ( const in float depth ) {', '\\t#if PERSPECTIVE_CAMERA == 1', '\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );', '\\t#else', '\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );', '\\t#endif', '}', 'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {', '\\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];', '\\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );', '\\tclipPosition *= clipW; // unprojection.', '\\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;', '}', 'vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {', '\\t#if NORMAL_TEXTURE == 1', '\\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );', '\\t#else', '\\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );', '\\t#endif', '}', 'float scaleDividedByCameraFar;', 'float minResolutionMultipliedByCameraFar;', 'float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {', '\\tvec3 viewDelta = sampleViewPosition - centerViewPosition;', '\\tfloat viewDistance = length( viewDelta );', '\\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;', '\\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );', '}', '// moving costly divides into consts', 'const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );', 'const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );', 'float getAmbientOcclusion( const in vec3 centerViewPosition ) {', '\\t// precompute some variables require in getOcclusion.', '\\tscaleDividedByCameraFar = scale / cameraFar;', '\\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;', '\\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );', '\\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/', '\\tfloat angle = rand( vUv + randomSeed ) * PI2;', '\\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;', '\\tvec2 radiusStep = radius;', '\\tfloat occlusionSum = 0.0;', '\\tfloat weightSum = 0.0;', '\\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {', '\\t\\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;', '\\t\\tradius += radiusStep;', '\\t\\tangle += ANGLE_STEP;', '\\t\\tfloat sampleDepth = getDepth( sampleUv );', '\\t\\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {', '\\t\\t\\tcontinue;', '\\t\\t}', '\\t\\tfloat sampleViewZ = getViewZ( sampleDepth );', '\\t\\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );', '\\t\\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );', '\\t\\tweightSum += 1.0;', '\\t}', '\\tif( weightSum == 0.0 ) discard;', '\\treturn occlusionSum * ( intensity / weightSum );', '}', 'void main() {', '\\tfloat centerDepth = getDepth( vUv );', '\\tif( centerDepth >= ( 1.0 - EPSILON ) ) {', '\\t\\tdiscard;', '\\t}', '\\tfloat centerViewZ = getViewZ( centerDepth );', '\\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );', '\\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );', '\\tgl_FragColor = getDefaultColor( vUv );', '\\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;', '}'].join('\\\\n')\\n};\\nexports.SAOShader = SAOShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"SAOShader\",\"_three\",\"defines\",\"NUM_SAMPLES\",\"NUM_RINGS\",\"NORMAL_TEXTURE\",\"DIFFUSE_TEXTURE\",\"DEPTH_PACKING\",\"PERSPECTIVE_CAMERA\",\"uniforms\",\"tDepth\",\"tDiffuse\",\"tNormal\",\"size\",\"Vector2\",\"cameraNear\",\"cameraFar\",\"cameraProjectionMatrix\",\"Matrix4\",\"cameraInverseProjectionMatrix\",\"scale\",\"intensity\",\"bias\",\"minResolution\",\"kernelRadius\",\"randomSeed\",\"vertexShader\",\"fragmentShader\"]\n}\n"]