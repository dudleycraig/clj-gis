["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$parse$parser$traits$tree_builder=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.TreeBuilder=void 0;var cst_1=require(\"module$node_modules$chevrotain$lib$src$parse$cst$cst\"),utils_1=require(\"module$node_modules$$chevrotain$utils$lib$src$api\"),cst_visitor_1=require(\"module$node_modules$chevrotain$lib$src$parse$cst$cst_visitor\"),parser_1=require(\"module$node_modules$chevrotain$lib$src$parse$parser$parser\");\nglobal=function(){function TreeBuilder(){}TreeBuilder.prototype.initTreeBuilder=function(config){this.CST_STACK=[];this.outputCst=config.outputCst;this.nodeLocationTracking=utils_1.has(config,\"nodeLocationTracking\")?config.nodeLocationTracking:parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;if(this.outputCst)if(/full/i.test(this.nodeLocationTracking))this.recoveryEnabled?(this.setNodeLocationFromNode=this.setNodeLocationFromToken=cst_1.setNodeLocationFull,this.cstPostRule=utils_1.NOOP,this.setInitialNodeLocation=\nthis.setInitialNodeLocationFullRecovery):(this.setNodeLocationFromNode=this.setNodeLocationFromToken=utils_1.NOOP,this.cstPostRule=this.cstPostRuleFull,this.setInitialNodeLocation=this.setInitialNodeLocationFullRegular);else if(/onlyOffset/i.test(this.nodeLocationTracking))this.recoveryEnabled?(this.setNodeLocationFromNode=this.setNodeLocationFromToken=cst_1.setNodeLocationOnlyOffset,this.cstPostRule=utils_1.NOOP,this.setInitialNodeLocation=this.setInitialNodeLocationOnlyOffsetRecovery):(this.setNodeLocationFromNode=\nthis.setNodeLocationFromToken=utils_1.NOOP,this.cstPostRule=this.cstPostRuleOnlyOffset,this.setInitialNodeLocation=this.setInitialNodeLocationOnlyOffsetRegular);else if(/none/i.test(this.nodeLocationTracking))this.setInitialNodeLocation=this.cstPostRule=this.setNodeLocationFromNode=this.setNodeLocationFromToken=utils_1.NOOP;else throw Error('Invalid \\x3cnodeLocationTracking\\x3e config option: \"'+config.nodeLocationTracking+'\"');else this.cstPostRule=this.cstPostNonTerminal=this.cstPostTerminal=this.cstFinallyStateUpdate=\nthis.cstInvocationStateUpdate=utils_1.NOOP};TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery=function(cstNode){cstNode.location={startOffset:NaN,endOffset:NaN}};TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular=function(cstNode){cstNode.location={startOffset:this.LA(1).startOffset,endOffset:NaN}};TreeBuilder.prototype.setInitialNodeLocationFullRecovery=function(cstNode){cstNode.location={startOffset:NaN,startLine:NaN,startColumn:NaN,endOffset:NaN,endLine:NaN,endColumn:NaN}};\nTreeBuilder.prototype.setInitialNodeLocationFullRegular=function(cstNode){var nextToken=this.LA(1);cstNode.location={startOffset:nextToken.startOffset,startLine:nextToken.startLine,startColumn:nextToken.startColumn,endOffset:NaN,endLine:NaN,endColumn:NaN}};TreeBuilder.prototype.cstInvocationStateUpdate=function(fullRuleName,shortName){fullRuleName={name:fullRuleName,children:{}};this.setInitialNodeLocation(fullRuleName);this.CST_STACK.push(fullRuleName)};TreeBuilder.prototype.cstFinallyStateUpdate=\nfunction(){this.CST_STACK.pop()};TreeBuilder.prototype.cstPostRuleFull=function(ruleCstNode){var prevToken=this.LA(0);ruleCstNode=ruleCstNode.location;!0===ruleCstNode.startOffset<=prevToken.startOffset?(ruleCstNode.endOffset=prevToken.endOffset,ruleCstNode.endLine=prevToken.endLine,ruleCstNode.endColumn=prevToken.endColumn):(ruleCstNode.startOffset=NaN,ruleCstNode.startLine=NaN,ruleCstNode.startColumn=NaN)};TreeBuilder.prototype.cstPostRuleOnlyOffset=function(ruleCstNode){var prevToken=this.LA(0);\nruleCstNode=ruleCstNode.location;!0===ruleCstNode.startOffset<=prevToken.startOffset?ruleCstNode.endOffset=prevToken.endOffset:ruleCstNode.startOffset=NaN};TreeBuilder.prototype.cstPostTerminal=function(key,consumedToken){var rootCst=this.CST_STACK[this.CST_STACK.length-1];cst_1.addTerminalToCst(rootCst,consumedToken,key);this.setNodeLocationFromToken(rootCst.location,consumedToken)};TreeBuilder.prototype.cstPostNonTerminal=function(ruleCstResult,ruleName){var preCstNode=this.CST_STACK[this.CST_STACK.length-\n1];cst_1.addNoneTerminalToCst(preCstNode,ruleName,ruleCstResult);this.setNodeLocationFromNode(preCstNode.location,ruleCstResult.location)};TreeBuilder.prototype.getBaseCstVisitorConstructor=function(){if(utils_1.isUndefined(this.baseCstVisitorConstructor)){var newBaseCstVisitorConstructor=cst_visitor_1.createBaseSemanticVisitorConstructor(this.className,utils_1.keys(this.gastProductionsCache));return this.baseCstVisitorConstructor=newBaseCstVisitorConstructor}return this.baseCstVisitorConstructor};\nTreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults=function(){if(utils_1.isUndefined(this.baseCstVisitorWithDefaultsConstructor)){var newConstructor=cst_visitor_1.createBaseVisitorConstructorWithDefaults(this.className,utils_1.keys(this.gastProductionsCache),this.getBaseCstVisitorConstructor());return this.baseCstVisitorWithDefaultsConstructor=newConstructor}return this.baseCstVisitorWithDefaultsConstructor};TreeBuilder.prototype.getLastExplicitRuleShortName=function(){var ruleStack=this.RULE_STACK;\nreturn ruleStack[ruleStack.length-1]};TreeBuilder.prototype.getPreviousExplicitRuleShortName=function(){var ruleStack=this.RULE_STACK;return ruleStack[ruleStack.length-2]};TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex=function(){var occurrenceStack=this.RULE_OCCURRENCE_STACK;return occurrenceStack[occurrenceStack.length-1]};return TreeBuilder}();exports.TreeBuilder=global}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$parse$parser$traits$tree_builder\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TreeBuilder = void 0;\nvar cst_1 = require(\"../../cst/cst\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar cst_visitor_1 = require(\"../../cst/cst_visitor\");\nvar parser_1 = require(\"../parser\");\n/**\n * This trait is responsible for the CST building logic.\n */\nvar TreeBuilder = /** @class */ (function () {\n    function TreeBuilder() {\n    }\n    TreeBuilder.prototype.initTreeBuilder = function (config) {\n        this.CST_STACK = [];\n        // outputCst is no longer exposed/defined in the pubic API\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = utils_1.has(config, \"nodeLocationTracking\")\n            ? config.nodeLocationTracking\n            : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = utils_1.NOOP;\n            this.cstFinallyStateUpdate = utils_1.NOOP;\n            this.cstPostTerminal = utils_1.NOOP;\n            this.cstPostNonTerminal = utils_1.NOOP;\n            this.cstPostRule = utils_1.NOOP;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\n                    this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\n                    this.cstPostRule = utils_1.NOOP;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = utils_1.NOOP;\n                    this.setNodeLocationFromNode = utils_1.NOOP;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\n                    this.cstPostRule = utils_1.NOOP;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = utils_1.NOOP;\n                    this.setNodeLocationFromNode = utils_1.NOOP;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = utils_1.NOOP;\n                this.setNodeLocationFromNode = utils_1.NOOP;\n                this.cstPostRule = utils_1.NOOP;\n                this.setInitialNodeLocation = utils_1.NOOP;\n            }\n            else {\n                throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\" + config.nodeLocationTracking + \"\\\"\");\n            }\n        }\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n        };\n    };\n    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n        var nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n        };\n    };\n    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\n        var cstNode = {\n            name: fullRuleName,\n            children: {}\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    };\n    TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n        this.CST_STACK.pop();\n    };\n    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n        var prevToken = this.LA(0);\n        var loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // \"empty\" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    };\n    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        cst_1.addTerminalToCst(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    };\n    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n        var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        cst_1.addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n        if (utils_1.isUndefined(this.baseCstVisitorConstructor)) {\n            var newBaseCstVisitorConstructor = cst_visitor_1.createBaseSemanticVisitorConstructor(this.className, utils_1.keys(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    };\n    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n        if (utils_1.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n            var newConstructor = cst_visitor_1.createBaseVisitorConstructorWithDefaults(this.className, utils_1.keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    };\n    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    };\n    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n        var ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    };\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n        var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    };\n    return TreeBuilder;\n}());\nexports.TreeBuilder = TreeBuilder;\n//# sourceMappingURL=tree_builder.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$chevrotain$lib$src$parse$cst$cst_visitor","~$module$node_modules$$chevrotain$utils$lib$src$api","~$shadow.js","~$module$node_modules$chevrotain$lib$src$parse$cst$cst","~$module$node_modules$chevrotain$lib$src$parse$parser$parser"]],"~:properties",["^5",["getLastExplicitRuleOccurrenceIndex","cstPostRuleOnlyOffset","endColumn","endLine","CST_STACK","nodeLocationTracking","baseCstVisitorWithDefaultsConstructor","children","__esModule","baseCstVisitorConstructor","endOffset","setInitialNodeLocation","name","value","location","setNodeLocationFromToken","startOffset","startLine","TreeBuilder","cstInvocationStateUpdate","cstPostRuleFull","getBaseCstVisitorConstructor","initTreeBuilder","getBaseCstVisitorConstructorWithDefaults","startColumn","outputCst","cstFinallyStateUpdate","cstPostNonTerminal","setInitialNodeLocationOnlyOffsetRegular","cstPostTerminal","setNodeLocationFromNode","setInitialNodeLocationFullRegular","cstPostRule","setInitialNodeLocationFullRecovery","setInitialNodeLocationOnlyOffsetRecovery","getLastExplicitRuleShortName","getPreviousExplicitRuleShortName"]],"~:compiled-at",1630917515706,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$parse$parser$traits$tree_builder.js\",\n\"lineCount\":11,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$parse$parser$traits$tree_builder\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.TreeBuilder = void 0;\\nvar cst_1 = require(\\\"../../cst/cst\\\");\\nvar utils_1 = require(\\\"@chevrotain/utils\\\");\\nvar cst_visitor_1 = require(\\\"../../cst/cst_visitor\\\");\\nvar parser_1 = require(\\\"../parser\\\");\\n/**\\n * This trait is responsible for the CST building logic.\\n */\\nvar TreeBuilder = /** @class */ (function () {\\n    function TreeBuilder() {\\n    }\\n    TreeBuilder.prototype.initTreeBuilder = function (config) {\\n        this.CST_STACK = [];\\n        // outputCst is no longer exposed/defined in the pubic API\\n        this.outputCst = config.outputCst;\\n        this.nodeLocationTracking = utils_1.has(config, \\\"nodeLocationTracking\\\")\\n            ? config.nodeLocationTracking\\n            : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\\n        if (!this.outputCst) {\\n            this.cstInvocationStateUpdate = utils_1.NOOP;\\n            this.cstFinallyStateUpdate = utils_1.NOOP;\\n            this.cstPostTerminal = utils_1.NOOP;\\n            this.cstPostNonTerminal = utils_1.NOOP;\\n            this.cstPostRule = utils_1.NOOP;\\n        }\\n        else {\\n            if (/full/i.test(this.nodeLocationTracking)) {\\n                if (this.recoveryEnabled) {\\n                    this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\\n                    this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\\n                    this.cstPostRule = utils_1.NOOP;\\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\\n                }\\n                else {\\n                    this.setNodeLocationFromToken = utils_1.NOOP;\\n                    this.setNodeLocationFromNode = utils_1.NOOP;\\n                    this.cstPostRule = this.cstPostRuleFull;\\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\\n                }\\n            }\\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\\n                if (this.recoveryEnabled) {\\n                    this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\\n                    this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\\n                    this.cstPostRule = utils_1.NOOP;\\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\\n                }\\n                else {\\n                    this.setNodeLocationFromToken = utils_1.NOOP;\\n                    this.setNodeLocationFromNode = utils_1.NOOP;\\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\\n                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\\n                }\\n            }\\n            else if (/none/i.test(this.nodeLocationTracking)) {\\n                this.setNodeLocationFromToken = utils_1.NOOP;\\n                this.setNodeLocationFromNode = utils_1.NOOP;\\n                this.cstPostRule = utils_1.NOOP;\\n                this.setInitialNodeLocation = utils_1.NOOP;\\n            }\\n            else {\\n                throw Error(\\\"Invalid <nodeLocationTracking> config option: \\\\\\\"\\\" + config.nodeLocationTracking + \\\"\\\\\\\"\\\");\\n            }\\n        }\\n    };\\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\\n        cstNode.location = {\\n            startOffset: NaN,\\n            endOffset: NaN\\n        };\\n    };\\n    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\\n        cstNode.location = {\\n            // without error recovery the starting Location of a new CstNode is guaranteed\\n            // To be the next Token's startOffset (for valid inputs).\\n            // For invalid inputs there won't be any CSTOutput so this potential\\n            // inaccuracy does not matter\\n            startOffset: this.LA(1).startOffset,\\n            endOffset: NaN\\n        };\\n    };\\n    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\\n        cstNode.location = {\\n            startOffset: NaN,\\n            startLine: NaN,\\n            startColumn: NaN,\\n            endOffset: NaN,\\n            endLine: NaN,\\n            endColumn: NaN\\n        };\\n    };\\n    /**\\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\\n  \\n       * @param cstNode\\n       */\\n    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\\n        var nextToken = this.LA(1);\\n        cstNode.location = {\\n            startOffset: nextToken.startOffset,\\n            startLine: nextToken.startLine,\\n            startColumn: nextToken.startColumn,\\n            endOffset: NaN,\\n            endLine: NaN,\\n            endColumn: NaN\\n        };\\n    };\\n    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {\\n        var cstNode = {\\n            name: fullRuleName,\\n            children: {}\\n        };\\n        this.setInitialNodeLocation(cstNode);\\n        this.CST_STACK.push(cstNode);\\n    };\\n    TreeBuilder.prototype.cstFinallyStateUpdate = function () {\\n        this.CST_STACK.pop();\\n    };\\n    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\\n        var prevToken = this.LA(0);\\n        var loc = ruleCstNode.location;\\n        // If this condition is true it means we consumed at least one Token\\n        // In this CstNode.\\n        if (loc.startOffset <= prevToken.startOffset === true) {\\n            loc.endOffset = prevToken.endOffset;\\n            loc.endLine = prevToken.endLine;\\n            loc.endColumn = prevToken.endColumn;\\n        }\\n        // \\\"empty\\\" CstNode edge case\\n        else {\\n            loc.startOffset = NaN;\\n            loc.startLine = NaN;\\n            loc.startColumn = NaN;\\n        }\\n    };\\n    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\\n        var prevToken = this.LA(0);\\n        var loc = ruleCstNode.location;\\n        // If this condition is true it means we consumed at least one Token\\n        // In this CstNode.\\n        if (loc.startOffset <= prevToken.startOffset === true) {\\n            loc.endOffset = prevToken.endOffset;\\n        }\\n        // \\\"empty\\\" CstNode edge case\\n        else {\\n            loc.startOffset = NaN;\\n        }\\n    };\\n    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\\n        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\\n        cst_1.addTerminalToCst(rootCst, consumedToken, key);\\n        // This is only used when **both** error recovery and CST Output are enabled.\\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\\n    };\\n    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\\n        var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\\n        cst_1.addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\\n        // This is only used when **both** error recovery and CST Output are enabled.\\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\\n    };\\n    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\\n        if (utils_1.isUndefined(this.baseCstVisitorConstructor)) {\\n            var newBaseCstVisitorConstructor = cst_visitor_1.createBaseSemanticVisitorConstructor(this.className, utils_1.keys(this.gastProductionsCache));\\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\\n            return newBaseCstVisitorConstructor;\\n        }\\n        return this.baseCstVisitorConstructor;\\n    };\\n    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\\n        if (utils_1.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\\n            var newConstructor = cst_visitor_1.createBaseVisitorConstructorWithDefaults(this.className, utils_1.keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\\n            return newConstructor;\\n        }\\n        return this.baseCstVisitorWithDefaultsConstructor;\\n    };\\n    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\\n        var ruleStack = this.RULE_STACK;\\n        return ruleStack[ruleStack.length - 1];\\n    };\\n    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\\n        var ruleStack = this.RULE_STACK;\\n        return ruleStack[ruleStack.length - 2];\\n    };\\n    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\\n        var occurrenceStack = this.RULE_OCCURRENCE_STACK;\\n        return occurrenceStack[occurrenceStack.length - 1];\\n    };\\n    return TreeBuilder;\\n}());\\nexports.TreeBuilder = TreeBuilder;\\n//# sourceMappingURL=tree_builder.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"TreeBuilder\",\"cst_1\",\"utils_1\",\"cst_visitor_1\",\"parser_1\",\"prototype\",\"initTreeBuilder\",\"TreeBuilder.prototype.initTreeBuilder\",\"config\",\"CST_STACK\",\"outputCst\",\"nodeLocationTracking\",\"has\",\"DEFAULT_PARSER_CONFIG\",\"test\",\"recoveryEnabled\",\"setNodeLocationFromNode\",\"setNodeLocationFromToken\",\"setNodeLocationFull\",\"cstPostRule\",\"NOOP\",\"setInitialNodeLocation\",\"setInitialNodeLocationFullRecovery\",\"cstPostRuleFull\",\"setInitialNodeLocationFullRegular\",\"setNodeLocationOnlyOffset\",\"setInitialNodeLocationOnlyOffsetRecovery\",\"cstPostRuleOnlyOffset\",\"setInitialNodeLocationOnlyOffsetRegular\",\"Error\",\"cstPostNonTerminal\",\"cstPostTerminal\",\"cstFinallyStateUpdate\",\"cstInvocationStateUpdate\",\"TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery\",\"cstNode\",\"location\",\"startOffset\",\"NaN\",\"endOffset\",\"TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular\",\"LA\",\"TreeBuilder.prototype.setInitialNodeLocationFullRecovery\",\"startLine\",\"startColumn\",\"endLine\",\"endColumn\",\"TreeBuilder.prototype.setInitialNodeLocationFullRegular\",\"nextToken\",\"TreeBuilder.prototype.cstInvocationStateUpdate\",\"fullRuleName\",\"shortName\",\"name\",\"children\",\"push\",\"TreeBuilder.prototype.cstFinallyStateUpdate\",\"pop\",\"TreeBuilder.prototype.cstPostRuleFull\",\"ruleCstNode\",\"prevToken\",\"loc\",\"TreeBuilder.prototype.cstPostRuleOnlyOffset\",\"TreeBuilder.prototype.cstPostTerminal\",\"key\",\"consumedToken\",\"rootCst\",\"length\",\"addTerminalToCst\",\"TreeBuilder.prototype.cstPostNonTerminal\",\"ruleCstResult\",\"ruleName\",\"preCstNode\",\"addNoneTerminalToCst\",\"getBaseCstVisitorConstructor\",\"TreeBuilder.prototype.getBaseCstVisitorConstructor\",\"isUndefined\",\"baseCstVisitorConstructor\",\"newBaseCstVisitorConstructor\",\"createBaseSemanticVisitorConstructor\",\"className\",\"keys\",\"gastProductionsCache\",\"getBaseCstVisitorConstructorWithDefaults\",\"TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults\",\"baseCstVisitorWithDefaultsConstructor\",\"newConstructor\",\"createBaseVisitorConstructorWithDefaults\",\"getLastExplicitRuleShortName\",\"TreeBuilder.prototype.getLastExplicitRuleShortName\",\"ruleStack\",\"RULE_STACK\",\"getPreviousExplicitRuleShortName\",\"TreeBuilder.prototype.getPreviousExplicitRuleShortName\",\"getLastExplicitRuleOccurrenceIndex\",\"TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex\",\"occurrenceStack\",\"RULE_OCCURRENCE_STACK\"]\n}\n"]