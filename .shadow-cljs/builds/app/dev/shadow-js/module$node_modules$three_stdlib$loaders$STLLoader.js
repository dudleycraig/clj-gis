["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/STLLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$STLLoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=\ndescriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};\nreturn _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};\nreturn _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.STLLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_Loader){function STLLoader(manager){if(!(this instanceof STLLoader))throw new TypeError(\"Cannot call a class as a function\");manager=_getPrototypeOf(STLLoader).call(this,manager);if(!manager||\"object\"!==_typeof(manager)&&\"function\"!==typeof manager){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\nmanager=this}return manager}_inherits(STLLoader,_Loader);_createClass(STLLoader,[{key:\"load\",value:function(url,onLoad,onProgress,onError){var scope=this,loader=new _three.FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType(\"arraybuffer\");loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);loader.load(url,function(text){try{onLoad(scope.parse(text))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}},onProgress,\nonError)}},{key:\"parse\",value:function(data$jscomp$0){function parseBinary(data){data=new DataView(data);for(var faces=data.getUint32(80,!0),r,g,b,hasColors=!1,colors,defaultR,defaultG,defaultB,alpha,index=0;70>index;index++)1129270351==data.getUint32(index,!1)&&82==data.getUint8(index+4)&&61==data.getUint8(index+5)&&(hasColors=!0,colors=new Float32Array(9*faces),defaultR=data.getUint8(index+6)/255,defaultG=data.getUint8(index+7)/255,defaultB=data.getUint8(index+8)/255,alpha=data.getUint8(index+9)/\n255);index=new _three.BufferGeometry;for(var vertices=new Float32Array(9*faces),normals=new Float32Array(9*faces),face=0;face<faces;face++){var start=84+50*face,normalX=data.getFloat32(start,!0),normalY=data.getFloat32(start+4,!0),normalZ=data.getFloat32(start+8,!0);hasColors&&(b=data.getUint16(start+48,!0),0===(b&32768)?(r=(b&31)/31,g=(b>>5&31)/31,b=(b>>10&31)/31):(r=defaultR,g=defaultG,b=defaultB));for(var i=1;3>=i;i++){var vertexstart=start+12*i,componentIdx=9*face+3*(i-1);vertices[componentIdx]=\ndata.getFloat32(vertexstart,!0);vertices[componentIdx+1]=data.getFloat32(vertexstart+4,!0);vertices[componentIdx+2]=data.getFloat32(vertexstart+8,!0);normals[componentIdx]=normalX;normals[componentIdx+1]=normalY;normals[componentIdx+2]=normalZ;hasColors&&(colors[componentIdx]=r,colors[componentIdx+1]=g,colors[componentIdx+2]=b)}}index.setAttribute(\"position\",new _three.BufferAttribute(vertices,3));index.setAttribute(\"normal\",new _three.BufferAttribute(normals,3));hasColors&&(index.setAttribute(\"color\",\nnew _three.BufferAttribute(colors,3)),index.hasColors=!0,index.alpha=alpha);return index}function parseASCII(data){var geometry=new _three.BufferGeometry,patternSolid=/solid([\\s\\S]*?)endsolid/g,patternFace=/facet([\\s\\S]*?)endfacet/g,faceCounter=0,patternFloat=/[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source,patternVertex=new RegExp(\"vertex\"+patternFloat+patternFloat+patternFloat,\"g\");patternFloat=new RegExp(\"normal\"+patternFloat+patternFloat+patternFloat,\"g\");for(var vertices=[],normals=[],\nnormal=new _three.Vector3,result,groupCount=0,startVertex,endVertex=0;null!==(result=patternSolid.exec(data));){startVertex=endVertex;for(var solid=result[0];null!==(result=patternFace.exec(solid));){for(var vertexCountPerFace=0,normalCountPerFace=0,text=result[0];null!==(result=patternFloat.exec(text));)normal.x=parseFloat(result[1]),normal.y=parseFloat(result[2]),normal.z=parseFloat(result[3]),normalCountPerFace++;for(;null!==(result=patternVertex.exec(text));)vertices.push(parseFloat(result[1]),\nparseFloat(result[2]),parseFloat(result[3])),normals.push(normal.x,normal.y,normal.z),vertexCountPerFace++,endVertex++;1!==normalCountPerFace&&console.error(\"THREE.STLLoader: Something isn't right with the normal of face number \"+faceCounter);3!==vertexCountPerFace&&console.error(\"THREE.STLLoader: Something isn't right with the vertices of face number \"+faceCounter);faceCounter++}geometry.addGroup(startVertex,endVertex-startVertex,groupCount);groupCount++}geometry.setAttribute(\"position\",new _three.Float32BufferAttribute(vertices,\n3));geometry.setAttribute(\"normal\",new _three.Float32BufferAttribute(normals,3));return geometry}function ensureString(buffer){return\"string\"!==typeof buffer?_three.LoaderUtils.decodeText(new Uint8Array(buffer)):buffer}var binData=function(buffer){if(\"string\"===typeof buffer){for(var array_buffer=new Uint8Array(buffer.length),i=0;i<buffer.length;i++)array_buffer[i]=buffer.charCodeAt(i)&255;return array_buffer.buffer||array_buffer}return buffer}(data$jscomp$0);return function(data){data=new DataView(data);\nif(84+50*data.getUint32(80,!0)===data.byteLength)return!0;for(var solid=[115,111,108,105,100],off=0;5>off;off++){a:{var JSCompiler_inline_result=solid;for(var reader=data,offset=off,i=0,il=JSCompiler_inline_result.length;i<il;i++)if(JSCompiler_inline_result[i]!==reader.getUint8(offset+i,!1)){JSCompiler_inline_result=!1;break a}JSCompiler_inline_result=!0}if(JSCompiler_inline_result)return!1}return!0}(binData)?parseBinary(binData):parseASCII(ensureString(data$jscomp$0))}}]);return STLLoader}(_three.Loader);\nexports.STLLoader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$STLLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.STLLoader = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  const loader = new STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n *  } else { .... }\n *  const mesh = new THREE.Mesh( geometry, material );\n *\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n * Groups can be used to assign a different color by defining an array of materials with the same length of\n * geometry.groups and passing it to the Mesh constructor:\n *\n * const mesh = new THREE.Mesh( geometry, material );\n *\n * For example:\n *\n *  const materials = [];\n *  const nGeometryGroups = geometry.groups.length;\n *\n *  const colorMap = ...; // Some logic to index colors.\n *\n *  for (let i = 0; i < nGeometryGroups; i++) {\n *\n *\t\tconst material = new THREE.MeshPhongMaterial({\n *\t\t\tcolor: colorMap[i],\n *\t\t\twireframe: false\n *\t\t});\n *\n *  }\n *\n *  materials.push(material);\n *  const mesh = new THREE.Mesh(geometry, materials);\n */\nvar STLLoader =\n/*#__PURE__*/\nfunction (_Loader) {\n  _inherits(STLLoader, _Loader);\n\n  function STLLoader(manager) {\n    _classCallCheck(this, STLLoader);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(STLLoader).call(this, manager));\n  }\n\n  _createClass(STLLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new _three.FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function isBinary(data) {\n        var reader = new DataView(data);\n        var face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n        var n_faces = reader.getUint32(80, true);\n        var expect = 80 + 32 / 8 + n_faces * face_size;\n\n        if (expect === reader.byteLength) {\n          return true;\n        } // An ASCII STL data must begin with 'solid ' as the first six bytes.\n        // However, ASCII STLs lacking the SPACE after the 'd' are known to be\n        // plentiful.  So, check the first 5 bytes for 'solid'.\n        // Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n        // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n        // Search for \"solid\" to start anywhere after those prefixes.\n        // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\n        var solid = [115, 111, 108, 105, 100];\n\n        for (var off = 0; off < 5; off++) {\n          // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n          if (matchDataViewAt(solid, reader, off)) return false;\n        } // Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\n        return true;\n      }\n\n      function matchDataViewAt(query, reader, offset) {\n        // Check if each byte in query matches the corresponding byte from the current offset\n        for (var i = 0, il = query.length; i < il; i++) {\n          if (query[i] !== reader.getUint8(offset + i, false)) return false;\n        }\n\n        return true;\n      }\n\n      function parseBinary(data) {\n        var reader = new DataView(data);\n        var faces = reader.getUint32(80, true);\n        var r,\n            g,\n            b,\n            hasColors = false,\n            colors;\n        var defaultR, defaultG, defaultB, alpha; // process STL header\n        // check for default color in header (\"COLOR=rgba\" sequence).\n\n        for (var index = 0; index < 80 - 10; index++) {\n          if (reader.getUint32(index, false) == 0x434f4c4f\n          /*COLO*/\n          && reader.getUint8(index + 4) == 0x52\n          /*'R'*/\n          && reader.getUint8(index + 5) == 0x3d\n          /*'='*/\n          ) {\n              hasColors = true;\n              colors = new Float32Array(faces * 3 * 3);\n              defaultR = reader.getUint8(index + 6) / 255;\n              defaultG = reader.getUint8(index + 7) / 255;\n              defaultB = reader.getUint8(index + 8) / 255;\n              alpha = reader.getUint8(index + 9) / 255;\n            }\n        }\n\n        var dataOffset = 84;\n        var faceLength = 12 * 4 + 2;\n        var geometry = new _three.BufferGeometry();\n        var vertices = new Float32Array(faces * 3 * 3);\n        var normals = new Float32Array(faces * 3 * 3);\n\n        for (var face = 0; face < faces; face++) {\n          var start = dataOffset + face * faceLength;\n          var normalX = reader.getFloat32(start, true);\n          var normalY = reader.getFloat32(start + 4, true);\n          var normalZ = reader.getFloat32(start + 8, true);\n\n          if (hasColors) {\n            var packedColor = reader.getUint16(start + 48, true);\n\n            if ((packedColor & 0x8000) === 0) {\n              // facet has its own unique color\n              r = (packedColor & 0x1f) / 31;\n              g = (packedColor >> 5 & 0x1f) / 31;\n              b = (packedColor >> 10 & 0x1f) / 31;\n            } else {\n              r = defaultR;\n              g = defaultG;\n              b = defaultB;\n            }\n          }\n\n          for (var i = 1; i <= 3; i++) {\n            var vertexstart = start + i * 12;\n            var componentIdx = face * 3 * 3 + (i - 1) * 3;\n            vertices[componentIdx] = reader.getFloat32(vertexstart, true);\n            vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);\n            vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);\n            normals[componentIdx] = normalX;\n            normals[componentIdx + 1] = normalY;\n            normals[componentIdx + 2] = normalZ;\n\n            if (hasColors) {\n              colors[componentIdx] = r;\n              colors[componentIdx + 1] = g;\n              colors[componentIdx + 2] = b;\n            }\n          }\n        }\n\n        geometry.setAttribute('position', new _three.BufferAttribute(vertices, 3));\n        geometry.setAttribute('normal', new _three.BufferAttribute(normals, 3));\n\n        if (hasColors) {\n          geometry.setAttribute('color', new _three.BufferAttribute(colors, 3));\n          geometry.hasColors = true;\n          geometry.alpha = alpha;\n        }\n\n        return geometry;\n      }\n\n      function parseASCII(data) {\n        var geometry = new _three.BufferGeometry();\n        var patternSolid = /solid([\\s\\S]*?)endsolid/g;\n        var patternFace = /facet([\\s\\S]*?)endfacet/g;\n        var faceCounter = 0;\n        var patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n        var patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g');\n        var patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g');\n        var vertices = [];\n        var normals = [];\n        var normal = new _three.Vector3();\n        var result;\n        var groupCount = 0;\n        var startVertex = 0;\n        var endVertex = 0;\n\n        while ((result = patternSolid.exec(data)) !== null) {\n          startVertex = endVertex;\n          var solid = result[0];\n\n          while ((result = patternFace.exec(solid)) !== null) {\n            var vertexCountPerFace = 0;\n            var normalCountPerFace = 0;\n            var text = result[0];\n\n            while ((result = patternNormal.exec(text)) !== null) {\n              normal.x = parseFloat(result[1]);\n              normal.y = parseFloat(result[2]);\n              normal.z = parseFloat(result[3]);\n              normalCountPerFace++;\n            }\n\n            while ((result = patternVertex.exec(text)) !== null) {\n              vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n              normals.push(normal.x, normal.y, normal.z);\n              vertexCountPerFace++;\n              endVertex++;\n            } // every face have to own ONE valid normal\n\n\n            if (normalCountPerFace !== 1) {\n              console.error(\"THREE.STLLoader: Something isn't right with the normal of face number \" + faceCounter);\n            } // each face have to own THREE valid vertices\n\n\n            if (vertexCountPerFace !== 3) {\n              console.error(\"THREE.STLLoader: Something isn't right with the vertices of face number \" + faceCounter);\n            }\n\n            faceCounter++;\n          }\n\n          var start = startVertex;\n          var count = endVertex - startVertex;\n          geometry.addGroup(start, count, groupCount);\n          groupCount++;\n        }\n\n        geometry.setAttribute('position', new _three.Float32BufferAttribute(vertices, 3));\n        geometry.setAttribute('normal', new _three.Float32BufferAttribute(normals, 3));\n        return geometry;\n      }\n\n      function ensureString(buffer) {\n        if (typeof buffer !== 'string') {\n          return _three.LoaderUtils.decodeText(new Uint8Array(buffer));\n        }\n\n        return buffer;\n      }\n\n      function ensureBinary(buffer) {\n        if (typeof buffer === 'string') {\n          var array_buffer = new Uint8Array(buffer.length);\n\n          for (var i = 0; i < buffer.length; i++) {\n            array_buffer[i] = buffer.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n          }\n\n          return array_buffer.buffer || array_buffer;\n        } else {\n          return buffer;\n        }\n      } // start\n\n\n      var binData = ensureBinary(data);\n      return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));\n    }\n  }]);\n\n  return STLLoader;\n}(_three.Loader);\n\nexports.STLLoader = STLLoader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["STLLoader","z","prototype","key","x","__esModule","configurable","value","enumerable","hasColors","writable","y","__proto__","alpha","constructor"]],"~:compiled-at",1630917515611,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$STLLoader.js\",\n\"lineCount\":14,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/STLLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$STLLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.STLLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\\n *\\n * Supports both binary and ASCII encoded files, with automatic detection of type.\\n *\\n * The loader returns a non-indexed buffer geometry.\\n *\\n * Limitations:\\n *  Binary decoding supports \\\"Magics\\\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\\n *  ASCII decoding assumes file is UTF-8.\\n *\\n * Usage:\\n *  const loader = new STLLoader();\\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\\n *    scene.add( new THREE.Mesh( geometry ) );\\n *  });\\n *\\n * For binary STLs geometry might contain colors for vertices. To use it:\\n *  // use the same code to load STL as above\\n *  if (geometry.hasColors) {\\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\\n *  } else { .... }\\n *  const mesh = new THREE.Mesh( geometry, material );\\n *\\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\\n * Groups can be used to assign a different color by defining an array of materials with the same length of\\n * geometry.groups and passing it to the Mesh constructor:\\n *\\n * const mesh = new THREE.Mesh( geometry, material );\\n *\\n * For example:\\n *\\n *  const materials = [];\\n *  const nGeometryGroups = geometry.groups.length;\\n *\\n *  const colorMap = ...; // Some logic to index colors.\\n *\\n *  for (let i = 0; i < nGeometryGroups; i++) {\\n *\\n *\\t\\tconst material = new THREE.MeshPhongMaterial({\\n *\\t\\t\\tcolor: colorMap[i],\\n *\\t\\t\\twireframe: false\\n *\\t\\t});\\n *\\n *  }\\n *\\n *  materials.push(material);\\n *  const mesh = new THREE.Mesh(geometry, materials);\\n */\\nvar STLLoader =\\n/*#__PURE__*/\\nfunction (_Loader) {\\n  _inherits(STLLoader, _Loader);\\n\\n  function STLLoader(manager) {\\n    _classCallCheck(this, STLLoader);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(STLLoader).call(this, manager));\\n  }\\n\\n  _createClass(STLLoader, [{\\n    key: \\\"load\\\",\\n    value: function load(url, onLoad, onProgress, onError) {\\n      var scope = this;\\n      var loader = new _three.FileLoader(this.manager);\\n      loader.setPath(this.path);\\n      loader.setResponseType('arraybuffer');\\n      loader.setRequestHeader(this.requestHeader);\\n      loader.setWithCredentials(this.withCredentials);\\n      loader.load(url, function (text) {\\n        try {\\n          onLoad(scope.parse(text));\\n        } catch (e) {\\n          if (onError) {\\n            onError(e);\\n          } else {\\n            console.error(e);\\n          }\\n\\n          scope.manager.itemError(url);\\n        }\\n      }, onProgress, onError);\\n    }\\n  }, {\\n    key: \\\"parse\\\",\\n    value: function parse(data) {\\n      function isBinary(data) {\\n        var reader = new DataView(data);\\n        var face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\\n        var n_faces = reader.getUint32(80, true);\\n        var expect = 80 + 32 / 8 + n_faces * face_size;\\n\\n        if (expect === reader.byteLength) {\\n          return true;\\n        } // An ASCII STL data must begin with 'solid ' as the first six bytes.\\n        // However, ASCII STLs lacking the SPACE after the 'd' are known to be\\n        // plentiful.  So, check the first 5 bytes for 'solid'.\\n        // Several encodings, such as UTF-8, precede the text with up to 5 bytes:\\n        // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\\n        // Search for \\\"solid\\\" to start anywhere after those prefixes.\\n        // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\\n\\n\\n        var solid = [115, 111, 108, 105, 100];\\n\\n        for (var off = 0; off < 5; off++) {\\n          // If \\\"solid\\\" text is matched to the current offset, declare it to be an ASCII STL.\\n          if (matchDataViewAt(solid, reader, off)) return false;\\n        } // Couldn't find \\\"solid\\\" text at the beginning; it is binary STL.\\n\\n\\n        return true;\\n      }\\n\\n      function matchDataViewAt(query, reader, offset) {\\n        // Check if each byte in query matches the corresponding byte from the current offset\\n        for (var i = 0, il = query.length; i < il; i++) {\\n          if (query[i] !== reader.getUint8(offset + i, false)) return false;\\n        }\\n\\n        return true;\\n      }\\n\\n      function parseBinary(data) {\\n        var reader = new DataView(data);\\n        var faces = reader.getUint32(80, true);\\n        var r,\\n            g,\\n            b,\\n            hasColors = false,\\n            colors;\\n        var defaultR, defaultG, defaultB, alpha; // process STL header\\n        // check for default color in header (\\\"COLOR=rgba\\\" sequence).\\n\\n        for (var index = 0; index < 80 - 10; index++) {\\n          if (reader.getUint32(index, false) == 0x434f4c4f\\n          /*COLO*/\\n          && reader.getUint8(index + 4) == 0x52\\n          /*'R'*/\\n          && reader.getUint8(index + 5) == 0x3d\\n          /*'='*/\\n          ) {\\n              hasColors = true;\\n              colors = new Float32Array(faces * 3 * 3);\\n              defaultR = reader.getUint8(index + 6) / 255;\\n              defaultG = reader.getUint8(index + 7) / 255;\\n              defaultB = reader.getUint8(index + 8) / 255;\\n              alpha = reader.getUint8(index + 9) / 255;\\n            }\\n        }\\n\\n        var dataOffset = 84;\\n        var faceLength = 12 * 4 + 2;\\n        var geometry = new _three.BufferGeometry();\\n        var vertices = new Float32Array(faces * 3 * 3);\\n        var normals = new Float32Array(faces * 3 * 3);\\n\\n        for (var face = 0; face < faces; face++) {\\n          var start = dataOffset + face * faceLength;\\n          var normalX = reader.getFloat32(start, true);\\n          var normalY = reader.getFloat32(start + 4, true);\\n          var normalZ = reader.getFloat32(start + 8, true);\\n\\n          if (hasColors) {\\n            var packedColor = reader.getUint16(start + 48, true);\\n\\n            if ((packedColor & 0x8000) === 0) {\\n              // facet has its own unique color\\n              r = (packedColor & 0x1f) / 31;\\n              g = (packedColor >> 5 & 0x1f) / 31;\\n              b = (packedColor >> 10 & 0x1f) / 31;\\n            } else {\\n              r = defaultR;\\n              g = defaultG;\\n              b = defaultB;\\n            }\\n          }\\n\\n          for (var i = 1; i <= 3; i++) {\\n            var vertexstart = start + i * 12;\\n            var componentIdx = face * 3 * 3 + (i - 1) * 3;\\n            vertices[componentIdx] = reader.getFloat32(vertexstart, true);\\n            vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);\\n            vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);\\n            normals[componentIdx] = normalX;\\n            normals[componentIdx + 1] = normalY;\\n            normals[componentIdx + 2] = normalZ;\\n\\n            if (hasColors) {\\n              colors[componentIdx] = r;\\n              colors[componentIdx + 1] = g;\\n              colors[componentIdx + 2] = b;\\n            }\\n          }\\n        }\\n\\n        geometry.setAttribute('position', new _three.BufferAttribute(vertices, 3));\\n        geometry.setAttribute('normal', new _three.BufferAttribute(normals, 3));\\n\\n        if (hasColors) {\\n          geometry.setAttribute('color', new _three.BufferAttribute(colors, 3));\\n          geometry.hasColors = true;\\n          geometry.alpha = alpha;\\n        }\\n\\n        return geometry;\\n      }\\n\\n      function parseASCII(data) {\\n        var geometry = new _three.BufferGeometry();\\n        var patternSolid = /solid([\\\\s\\\\S]*?)endsolid/g;\\n        var patternFace = /facet([\\\\s\\\\S]*?)endfacet/g;\\n        var faceCounter = 0;\\n        var patternFloat = /[\\\\s]+([+-]?(?:\\\\d*)(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)/.source;\\n        var patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g');\\n        var patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g');\\n        var vertices = [];\\n        var normals = [];\\n        var normal = new _three.Vector3();\\n        var result;\\n        var groupCount = 0;\\n        var startVertex = 0;\\n        var endVertex = 0;\\n\\n        while ((result = patternSolid.exec(data)) !== null) {\\n          startVertex = endVertex;\\n          var solid = result[0];\\n\\n          while ((result = patternFace.exec(solid)) !== null) {\\n            var vertexCountPerFace = 0;\\n            var normalCountPerFace = 0;\\n            var text = result[0];\\n\\n            while ((result = patternNormal.exec(text)) !== null) {\\n              normal.x = parseFloat(result[1]);\\n              normal.y = parseFloat(result[2]);\\n              normal.z = parseFloat(result[3]);\\n              normalCountPerFace++;\\n            }\\n\\n            while ((result = patternVertex.exec(text)) !== null) {\\n              vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\\n              normals.push(normal.x, normal.y, normal.z);\\n              vertexCountPerFace++;\\n              endVertex++;\\n            } // every face have to own ONE valid normal\\n\\n\\n            if (normalCountPerFace !== 1) {\\n              console.error(\\\"THREE.STLLoader: Something isn't right with the normal of face number \\\" + faceCounter);\\n            } // each face have to own THREE valid vertices\\n\\n\\n            if (vertexCountPerFace !== 3) {\\n              console.error(\\\"THREE.STLLoader: Something isn't right with the vertices of face number \\\" + faceCounter);\\n            }\\n\\n            faceCounter++;\\n          }\\n\\n          var start = startVertex;\\n          var count = endVertex - startVertex;\\n          geometry.addGroup(start, count, groupCount);\\n          groupCount++;\\n        }\\n\\n        geometry.setAttribute('position', new _three.Float32BufferAttribute(vertices, 3));\\n        geometry.setAttribute('normal', new _three.Float32BufferAttribute(normals, 3));\\n        return geometry;\\n      }\\n\\n      function ensureString(buffer) {\\n        if (typeof buffer !== 'string') {\\n          return _three.LoaderUtils.decodeText(new Uint8Array(buffer));\\n        }\\n\\n        return buffer;\\n      }\\n\\n      function ensureBinary(buffer) {\\n        if (typeof buffer === 'string') {\\n          var array_buffer = new Uint8Array(buffer.length);\\n\\n          for (var i = 0; i < buffer.length; i++) {\\n            array_buffer[i] = buffer.charCodeAt(i) & 0xff; // implicitly assumes little-endian\\n          }\\n\\n          return array_buffer.buffer || array_buffer;\\n        } else {\\n          return buffer;\\n        }\\n      } // start\\n\\n\\n      var binData = ensureBinary(data);\\n      return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));\\n    }\\n  }]);\\n\\n  return STLLoader;\\n}(_three.Loader);\\n\\nexports.STLLoader = STLLoader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"STLLoader\",\"_three\",\"_Loader\",\"manager\",\"instance\",\"call\",\"self\",\"ReferenceError\",\"load\",\"url\",\"onLoad\",\"onProgress\",\"onError\",\"scope\",\"loader\",\"FileLoader\",\"setPath\",\"path\",\"setResponseType\",\"setRequestHeader\",\"requestHeader\",\"setWithCredentials\",\"withCredentials\",\"text\",\"parse\",\"e\",\"console\",\"error\",\"itemError\",\"data\",\"parseBinary\",\"reader\",\"DataView\",\"faces\",\"getUint32\",\"r\",\"g\",\"b\",\"hasColors\",\"colors\",\"defaultR\",\"defaultG\",\"defaultB\",\"alpha\",\"index\",\"getUint8\",\"Float32Array\",\"geometry\",\"BufferGeometry\",\"vertices\",\"normals\",\"face\",\"start\",\"dataOffset\",\"faceLength\",\"normalX\",\"getFloat32\",\"normalY\",\"normalZ\",\"packedColor\",\"getUint16\",\"vertexstart\",\"componentIdx\",\"setAttribute\",\"BufferAttribute\",\"parseASCII\",\"patternSolid\",\"patternFace\",\"faceCounter\",\"patternFloat\",\"source\",\"patternVertex\",\"RegExp\",\"patternNormal\",\"normal\",\"Vector3\",\"result\",\"groupCount\",\"startVertex\",\"endVertex\",\"exec\",\"solid\",\"vertexCountPerFace\",\"normalCountPerFace\",\"x\",\"parseFloat\",\"y\",\"z\",\"push\",\"addGroup\",\"Float32BufferAttribute\",\"ensureString\",\"buffer\",\"LoaderUtils\",\"decodeText\",\"Uint8Array\",\"binData\",\"ensureBinary\",\"array_buffer\",\"charCodeAt\",\"isBinary\",\"face_size\",\"n_faces\",\"byteLength\",\"off\",\"il\",\"query\",\"offset\",\"Loader\"]\n}\n"]