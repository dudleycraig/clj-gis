["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@blueprintjs/core/lib/cjs/components/popover/popover.js"],"~:js","shadow$provide.module$node_modules$$blueprintjs$core$lib$cjs$components$popover$popover=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.Popover=exports.PopoverInteractionKind=void 0;var tslib_1=require(\"module$node_modules$tslib$tslib\"),classnames_1=tslib_1.__importDefault(require(\"module$node_modules$classnames$index\")),React=tslib_1.__importStar(require(\"module$node_modules$react$index\")),react_lifecycles_compat_1=require(\"module$node_modules$react_lifecycles_compat$react_lifecycles_compat_cjs\"),\nreact_popper_1=require(\"module$node_modules$react_popper$lib$cjs$index\"),common_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$common$index\"),Errors=tslib_1.__importStar(require(\"module$node_modules$$blueprintjs$core$lib$cjs$common$errors\")),props_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$common$props\"),Utils=tslib_1.__importStar(require(\"module$node_modules$$blueprintjs$core$lib$cjs$common$utils$index\")),overlay_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$components$overlay$overlay\"),\nresizeSensor_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$components$resize_sensor$resizeSensor\"),tooltip_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$components$tooltip$tooltip\"),popoverArrow_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$components$popover$popoverArrow\"),popoverMigrationUtils_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$components$popover$popoverMigrationUtils\"),popperUtils_1=require(\"module$node_modules$$blueprintjs$core$lib$cjs$components$popover$popperUtils\");\nexports.PopoverInteractionKind={CLICK:\"click\",CLICK_TARGET_ONLY:\"click-target\",HOVER:\"hover\",HOVER_TARGET_ONLY:\"hover-target\"};global=function(_super){function Popover(){var _this=null!==_super&&_super.apply(this,arguments)||this;_this.popoverRef=Utils.createReactRef();_this.popoverElement=null;_this.targetElement=null;_this.state={hasDarkParent:!1,isOpen:_this.getIsOpen(_this.props),transformOrigin:\"\"};_this.isMouseInTargetOrPopover=!1;_this.lostFocusOnSamePage=!0;_this.handlePopoverRef=common_1.refHandler(_this,\n\"popoverElement\",_this.props.popoverRef);_this.handleTargetRef=function(ref){return _this.targetElement=ref};_this.reposition=function(){var _a;return null===(_a=_this.popperScheduleUpdate)||void 0===_a?void 0:_a.call(_this)};_this.renderPopover=function(popperProps){var _a,_b=_this.props,usePortal=_b.usePortal,interactionKind=_b.interactionKind;_b=_this.state.transformOrigin;_this.popperScheduleUpdate=popperProps.scheduleUpdate;var popoverHandlers={onClick:_this.handlePopoverClick};if(interactionKind===\nexports.PopoverInteractionKind.HOVER||!usePortal&&interactionKind===exports.PopoverInteractionKind.HOVER_TARGET_ONLY)popoverHandlers.onMouseEnter=_this.handleMouseEnter,popoverHandlers.onMouseLeave=_this.handleMouseLeave;usePortal=classnames_1.default(common_1.Classes.POPOVER,(_a={},_a[common_1.Classes.DARK]=_this.props.inheritDarkTheme&&_this.state.hasDarkParent,_a[common_1.Classes.MINIMAL]=_this.props.minimal,_a[common_1.Classes.POPOVER_CAPTURING_DISMISS]=_this.props.captureDismiss,_a),_this.props.popoverClassName);\nreturn React.createElement(\"div\",{className:common_1.Classes.TRANSITION_CONTAINER,ref:popperProps.ref,style:popperProps.style},React.createElement(resizeSensor_1.ResizeSensor,{onResize:_this.reposition},React.createElement(\"div\",tslib_1.__assign({className:usePortal,style:{transformOrigin:_b},ref:_this.popoverRef},popoverHandlers),_this.isArrowEnabled()&&React.createElement(popoverArrow_1.PopoverArrow,{arrowProps:popperProps.arrowProps,placement:popperProps.placement}),React.createElement(\"div\",{className:common_1.Classes.POPOVER_CONTENT},\n_this.understandChildren().content))))};_this.renderTarget=function(referenceProps){var _a,_b,_c=_this.props,fill=_c.fill,openOnTargetFocus=_c.openOnTargetFocus,targetClassName=_c.targetClassName;_c=_c.targetProps;_c=void 0===_c?{}:_c;var isOpen=_this.state.isOpen,isControlled=_this.isControlled(),isHoverInteractionKind=_this.isHoverInteractionKind(),targetTagName=_this.props.targetTagName;fill&&(targetTagName=\"div\");fill=isHoverInteractionKind?{onBlur:_this.handleTargetBlur,onFocus:_this.handleTargetFocus,\nonMouseEnter:_this.handleMouseEnter,onMouseLeave:_this.handleMouseLeave}:{onClick:_this.handleTargetClick};fill[\"aria-haspopup\"]=\"true\";fill.className=classnames_1.default(common_1.Classes.POPOVER_TARGET,(_a={},_a[common_1.Classes.POPOVER_OPEN]=isOpen,_a),_c.className,targetClassName);fill.ref=referenceProps.ref;referenceProps=Utils.ensureElement(_this.understandChildren().target);if(void 0===referenceProps)return null;_a=referenceProps.props.tabIndex;openOnTargetFocus=null==_a&&openOnTargetFocus&&\nisHoverInteractionKind?0:_a;openOnTargetFocus=React.cloneElement(referenceProps,{className:classnames_1.default(referenceProps.props.className,(_b={},_b[common_1.Classes.ACTIVE]=isOpen&&!isControlled&&!isHoverInteractionKind,_b)),disabled:isOpen&&Utils.isElementOfType(referenceProps,tooltip_1.Tooltip)?!0:referenceProps.props.disabled,tabIndex:openOnTargetFocus});_b=React.createElement(targetTagName,tslib_1.__assign(tslib_1.__assign({},_c),fill),openOnTargetFocus);return React.createElement(resizeSensor_1.ResizeSensor,\n{onResize:_this.reposition},_b)};_this.isControlled=function(){return void 0!==_this.props.isOpen};_this.handleTargetFocus=function(e){var _a,_b;if(_this.props.openOnTargetFocus&&_this.isHoverInteractionKind()){if(null==e.relatedTarget&&!_this.lostFocusOnSamePage)return;_this.handleMouseEnter(e)}null===(_b=null===(_a=_this.props.targetProps)||void 0===_a?void 0:_a.onFocus)||void 0===_b?void 0:_b.call(_a,e)};_this.handleTargetBlur=function(e){var _a,_b;_this.props.openOnTargetFocus&&_this.isHoverInteractionKind()&&\n(null==e.relatedTarget||_this.isElementInPopover(e.relatedTarget)||_this.handleMouseLeave(e));_this.lostFocusOnSamePage=null!=e.relatedTarget;null===(_b=null===(_a=_this.props.targetProps)||void 0===_a?void 0:_a.onBlur)||void 0===_b?void 0:_b.call(_a,e)};_this.handleMouseEnter=function(e){var _a,_b;_this.isMouseInTargetOrPopover=!0;_this.props.usePortal||!_this.isElementInPopover(e.target)||_this.props.interactionKind!==exports.PopoverInteractionKind.HOVER_TARGET_ONLY||_this.props.openOnTargetFocus?\n_this.props.disabled||_this.setOpenState(!0,e,_this.props.hoverOpenDelay):_this.handleMouseLeave(e);null===(_b=null===(_a=_this.props.targetProps)||void 0===_a?void 0:_a.onMouseEnter)||void 0===_b?void 0:_b.call(_a,e)};_this.handleMouseLeave=function(e){var _a,_b;_this.isMouseInTargetOrPopover=!1;_this.setTimeout(function(){_this.isMouseInTargetOrPopover||_this.setOpenState(!1,e,_this.props.hoverCloseDelay)});null===(_b=null===(_a=_this.props.targetProps)||void 0===_a?void 0:_a.onMouseLeave)||void 0===\n_b?void 0:_b.call(_a,e)};_this.handlePopoverClick=function(e){var eventTarget=e.target,eventPopover=eventTarget.closest(\".\"+common_1.Classes.POPOVER),isEventFromSelf=eventPopover===_this.popoverRef.current;eventPopover=null===eventPopover||void 0===eventPopover?void 0:eventPopover.classList.contains(common_1.Classes.POPOVER_CAPTURING_DISMISS);var dismissElement=eventTarget.closest(\".\"+common_1.Classes.POPOVER_DISMISS+\", .\"+common_1.Classes.POPOVER_DISMISS_OVERRIDE);dismissElement=null!=dismissElement&&\ndismissElement.classList.contains(common_1.Classes.POPOVER_DISMISS);eventTarget=null!=eventTarget.closest(\":disabled, .\"+common_1.Classes.DISABLED);!dismissElement||eventTarget||eventPopover&&!isEventFromSelf||_this.setOpenState(!1,e)};_this.handleOverlayClose=function(e){null!==_this.targetElement&&void 0!==e&&(!Utils.elementIsOrContains(_this.targetElement,e.target)||e.nativeEvent instanceof KeyboardEvent)&&_this.setOpenState(!1,e)};_this.handleTargetClick=function(e){var _a,_b;_this.props.disabled||\n_this.isElementInPopover(e.target)||(null==_this.props.isOpen?_this.setState(function(prevState){return{isOpen:!prevState.isOpen}}):_this.setOpenState(!_this.props.isOpen,e));null===(_b=null===(_a=_this.props.targetProps)||void 0===_a?void 0:_a.onClick)||void 0===_b?void 0:_b.call(_a,e)};_this.updatePopoverState=function(data){_this.setState({transformOrigin:popperUtils_1.getTransformOrigin(data)});return data};return _this}tslib_1.__extends(Popover,_super);Popover.prototype.render=function(){var _a,\n_b=this.props,className=_b.className,disabled=_b.disabled,fill=_b.fill,placement=_b.placement;_b=_b.position;_b=void 0===_b?\"auto\":_b;var isOpen=this.state.isOpen,wrapperTagName=this.props.wrapperTagName;fill&&(wrapperTagName=\"div\");var isContentEmpty=null==Utils.ensureElement(this.understandChildren().content);!isContentEmpty||disabled||!1===isOpen||Utils.isNodeEnv(\"production\")||console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);className=classnames_1.default(common_1.Classes.POPOVER_WRAPPER,className,\n(_a={},_a[common_1.Classes.FILL]=fill,_a));_a=React.createElement(wrapperTagName,{className},React.createElement(react_popper_1.Reference,{innerRef:this.handleTargetRef},this.renderTarget),React.createElement(overlay_1.Overlay,{autoFocus:this.props.autoFocus,backdropClassName:common_1.Classes.POPOVER_BACKDROP,backdropProps:this.props.backdropProps,canEscapeKeyClose:this.props.canEscapeKeyClose,canOutsideClickClose:this.props.interactionKind===exports.PopoverInteractionKind.CLICK,className:this.props.portalClassName,\nenforceFocus:this.props.enforceFocus,hasBackdrop:this.props.hasBackdrop,isOpen:isOpen&&!isContentEmpty,onClose:this.handleOverlayClose,onClosed:this.props.onClosed,onClosing:this.props.onClosing,onOpened:this.props.onOpened,onOpening:this.props.onOpening,transitionDuration:this.props.transitionDuration,transitionName:common_1.Classes.POPOVER,usePortal:this.props.usePortal,portalContainer:this.props.portalContainer},React.createElement(react_popper_1.Popper,{innerRef:this.handlePopoverRef,placement:null!==\nplacement&&void 0!==placement?placement:popoverMigrationUtils_1.positionToPlacement(_b),modifiers:this.getPopperModifiers()},this.renderPopover)));return React.createElement(react_popper_1.Manager,null,_a)};Popover.prototype.componentDidMount=function(){this.updateDarkParent()};Popover.prototype.componentDidUpdate=function(prevProps,prevState){_super.prototype.componentDidUpdate.call(this,prevProps,prevState);prevProps.popoverRef!==this.props.popoverRef&&(common_1.setRef(prevProps.popoverRef,null),\nthis.handlePopoverRef=common_1.refHandler(this,\"popoverElement\",this.props.popoverRef),common_1.setRef(this.props.popoverRef,this.popoverElement));this.updateDarkParent();prevProps=this.getIsOpen(this.props);null!=this.props.isOpen&&prevProps!==this.state.isOpen?(this.setOpenState(prevProps),this.setState({isOpen:prevProps})):this.props.disabled&&this.state.isOpen&&null==this.props.isOpen&&this.setOpenState(!1)};Popover.prototype.validateProps=function(props){null==props.isOpen&&null!=props.onInteraction&&\nconsole.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);props.hasBackdrop&&!props.usePortal&&console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);props.hasBackdrop&&props.interactionKind!==exports.PopoverInteractionKind.CLICK&&console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);void 0!==props.placement&&void 0!==props.position&&console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);var childrenCount=React.Children.count(props.children),hasContentProp=void 0!==props.content;props=\nvoid 0!==props.target;0!==childrenCount||props||console.error(Errors.POPOVER_REQUIRES_TARGET);2<childrenCount&&console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);0<childrenCount&&props&&console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);2===childrenCount&&hasContentProp&&console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT)};Popover.prototype.updateDarkParent=function(){if(this.props.usePortal&&this.state.isOpen){var hasDarkParent=null!=this.targetElement&&null!=this.targetElement.closest(\".\"+common_1.Classes.DARK);\nthis.setState({hasDarkParent})}};Popover.prototype.understandChildren=function(){var _a=this.props,contentProp=_a.content,targetProp=_a.target,_b=React.Children.toArray(_a.children);_a=_b[0];_b=_b[1];return{content:null==_b?contentProp:_b,target:null==_a?targetProp:_a}};Popover.prototype.getIsOpen=function(props){return props.disabled?!1:null!=props.isOpen?props.isOpen:props.defaultIsOpen};Popover.prototype.getPopperModifiers=function(){var _a=this.props,boundary=_a.boundary;_a=_a.modifiers;var _c=\n_a.flip;_c=void 0===_c?{}:_c;var _d=_a.preventOverflow;_d=void 0===_d?{}:_d;return tslib_1.__assign(tslib_1.__assign({},_a),{arrowOffset:{enabled:this.isArrowEnabled(),fn:popperUtils_1.arrowOffsetModifier,order:510},flip:tslib_1.__assign({boundariesElement:boundary},_c),preventOverflow:tslib_1.__assign({boundariesElement:boundary},_d),updatePopoverState:{enabled:!0,fn:this.updatePopoverState,order:900}})};Popover.prototype.setOpenState=function(isOpen,e,timeout){var _this=this,_a,_b,_c,_d,_e;null===\n(_a=this.cancelOpenTimeout)||void 0===_a?void 0:_a.call(this);void 0!==timeout&&0<timeout?this.cancelOpenTimeout=this.setTimeout(function(){return _this.setOpenState(isOpen,e)},timeout):(null==this.props.isOpen?this.setState({isOpen}):null===(_c=(_b=this.props).onInteraction)||void 0===_c?void 0:_c.call(_b,isOpen,e),isOpen||(null===(_e=(_d=this.props).onClose)||void 0===_e?void 0:_e.call(_d,e)))};Popover.prototype.isArrowEnabled=function(){var _a=this.props,modifiers=_a.modifiers;return!_a.minimal&&\n(null==(null===modifiers||void 0===modifiers?void 0:modifiers.arrow)||modifiers.arrow.enabled)};Popover.prototype.isElementInPopover=function(element){var _a;return null===(_a=this.popoverElement)||void 0===_a?void 0:_a.contains(element)};Popover.prototype.isHoverInteractionKind=function(){return this.props.interactionKind===exports.PopoverInteractionKind.HOVER||this.props.interactionKind===exports.PopoverInteractionKind.HOVER_TARGET_ONLY};Popover.displayName=props_1.DISPLAYNAME_PREFIX+\".Popover\";\nPopover.defaultProps={boundary:\"scrollParent\",captureDismiss:!1,defaultIsOpen:!1,disabled:!1,fill:!1,hasBackdrop:!1,hoverCloseDelay:300,hoverOpenDelay:150,inheritDarkTheme:!0,interactionKind:exports.PopoverInteractionKind.CLICK,minimal:!1,modifiers:{},openOnTargetFocus:!0,targetTagName:\"span\",transitionDuration:300,usePortal:!0,wrapperTagName:\"span\"};return Popover=tslib_1.__decorate([react_lifecycles_compat_1.polyfill],Popover)}(common_1.AbstractPureComponent2);exports.Popover=global}","~:source","shadow$provide[\"module$node_modules$$blueprintjs$core$lib$cjs$components$popover$popover\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Popover = exports.PopoverInteractionKind = void 0;\nvar tslib_1 = require(\"tslib\");\nvar classnames_1 = tslib_1.__importDefault(require(\"classnames\"));\nvar React = tslib_1.__importStar(require(\"react\"));\nvar react_lifecycles_compat_1 = require(\"react-lifecycles-compat\");\nvar react_popper_1 = require(\"react-popper\");\nvar common_1 = require(\"../../common\");\nvar Errors = tslib_1.__importStar(require(\"../../common/errors\"));\nvar props_1 = require(\"../../common/props\");\nvar Utils = tslib_1.__importStar(require(\"../../common/utils\"));\nvar overlay_1 = require(\"../overlay/overlay\");\nvar resizeSensor_1 = require(\"../resize-sensor/resizeSensor\");\n// eslint-disable-next-line import/no-cycle\nvar tooltip_1 = require(\"../tooltip/tooltip\");\nvar popoverArrow_1 = require(\"./popoverArrow\");\nvar popoverMigrationUtils_1 = require(\"./popoverMigrationUtils\");\nvar popperUtils_1 = require(\"./popperUtils\");\nexports.PopoverInteractionKind = {\n    CLICK: \"click\",\n    CLICK_TARGET_ONLY: \"click-target\",\n    HOVER: \"hover\",\n    HOVER_TARGET_ONLY: \"hover-target\",\n};\n/** @deprecated use { Popover2 } from \"@blueprintjs/popover2\" */\nvar Popover = /** @class */ (function (_super) {\n    tslib_1.__extends(Popover, _super);\n    function Popover() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // eslint-disable-next-line deprecation/deprecation\n        _this.popoverRef = Utils.createReactRef();\n        /**\n         * DOM element that contains the popover.\n         * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n         * so this reference can be very useful for testing.\n         */\n        _this.popoverElement = null;\n        /** DOM element that contains the target. */\n        _this.targetElement = null;\n        _this.state = {\n            hasDarkParent: false,\n            isOpen: _this.getIsOpen(_this.props),\n            transformOrigin: \"\",\n        };\n        // a flag that lets us detect mouse movement between the target and popover,\n        // now that mouseleave is triggered when you cross the gap between the two.\n        _this.isMouseInTargetOrPopover = false;\n        // a flag that indicates whether the target previously lost focus to another\n        // element on the same page.\n        _this.lostFocusOnSamePage = true;\n        _this.handlePopoverRef = common_1.refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n        _this.handleTargetRef = function (ref) { return (_this.targetElement = ref); };\n        /**\n         * Instance method to instruct the `Popover` to recompute its position.\n         *\n         * This method should only be used if you are updating the target in a way\n         * that does not cause it to re-render, such as changing its _position_\n         * without changing its _size_ (since `Popover` already repositions when it\n         * detects a resize).\n         */\n        _this.reposition = function () { var _a; return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this); };\n        _this.renderPopover = function (popperProps) {\n            var _a;\n            var _b = _this.props, usePortal = _b.usePortal, interactionKind = _b.interactionKind;\n            var transformOrigin = _this.state.transformOrigin;\n            // Need to update our reference to this on every render as it will change.\n            _this.popperScheduleUpdate = popperProps.scheduleUpdate;\n            var popoverHandlers = {\n                // always check popover clicks for dismiss class\n                onClick: _this.handlePopoverClick,\n            };\n            if (interactionKind === exports.PopoverInteractionKind.HOVER ||\n                (!usePortal && interactionKind === exports.PopoverInteractionKind.HOVER_TARGET_ONLY)) {\n                popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n                popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n            }\n            var popoverClasses = classnames_1.default(common_1.Classes.POPOVER, (_a = {},\n                _a[common_1.Classes.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent,\n                _a[common_1.Classes.MINIMAL] = _this.props.minimal,\n                _a[common_1.Classes.POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss,\n                _a), _this.props.popoverClassName);\n            return (React.createElement(\"div\", { className: common_1.Classes.TRANSITION_CONTAINER, ref: popperProps.ref, style: popperProps.style },\n                React.createElement(resizeSensor_1.ResizeSensor, { onResize: _this.reposition },\n                    React.createElement(\"div\", tslib_1.__assign({ className: popoverClasses, style: { transformOrigin: transformOrigin }, ref: _this.popoverRef }, popoverHandlers),\n                        _this.isArrowEnabled() && (React.createElement(popoverArrow_1.PopoverArrow, { arrowProps: popperProps.arrowProps, placement: popperProps.placement })),\n                        React.createElement(\"div\", { className: common_1.Classes.POPOVER_CONTENT }, _this.understandChildren().content)))));\n        };\n        _this.renderTarget = function (referenceProps) {\n            var _a, _b;\n            var _c = _this.props, fill = _c.fill, openOnTargetFocus = _c.openOnTargetFocus, targetClassName = _c.targetClassName, _d = _c.targetProps, targetProps = _d === void 0 ? {} : _d;\n            var isOpen = _this.state.isOpen;\n            var isControlled = _this.isControlled();\n            var isHoverInteractionKind = _this.isHoverInteractionKind();\n            var targetTagName = _this.props.targetTagName;\n            if (fill) {\n                targetTagName = \"div\";\n            }\n            var finalTargetProps = isHoverInteractionKind\n                ? {\n                    // HOVER handlers\n                    onBlur: _this.handleTargetBlur,\n                    onFocus: _this.handleTargetFocus,\n                    onMouseEnter: _this.handleMouseEnter,\n                    onMouseLeave: _this.handleMouseLeave,\n                }\n                : {\n                    // CLICK needs only one handler\n                    onClick: _this.handleTargetClick,\n                };\n            finalTargetProps[\"aria-haspopup\"] = \"true\";\n            finalTargetProps.className = classnames_1.default(common_1.Classes.POPOVER_TARGET, (_a = {}, _a[common_1.Classes.POPOVER_OPEN] = isOpen, _a), targetProps.className, targetClassName);\n            finalTargetProps.ref = referenceProps.ref;\n            var rawTarget = Utils.ensureElement(_this.understandChildren().target);\n            if (rawTarget === undefined) {\n                return null;\n            }\n            var rawTabIndex = rawTarget.props.tabIndex;\n            // ensure target is focusable if relevant prop enabled\n            var tabIndex = rawTabIndex == null && openOnTargetFocus && isHoverInteractionKind ? 0 : rawTabIndex;\n            var clonedTarget = React.cloneElement(rawTarget, {\n                className: classnames_1.default(rawTarget.props.className, (_b = {},\n                    // this class is mainly useful for button targets; we should only apply it for uncontrolled popovers\n                    // when they are opened by a user interaction\n                    _b[common_1.Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind,\n                    _b)),\n                // force disable single Tooltip child when popover is open (BLUEPRINT-552)\n                /* eslint-disable-next-line deprecation/deprecation */\n                disabled: isOpen && Utils.isElementOfType(rawTarget, tooltip_1.Tooltip) ? true : rawTarget.props.disabled,\n                tabIndex: tabIndex,\n            });\n            var target = React.createElement(targetTagName, tslib_1.__assign(tslib_1.__assign({}, targetProps), finalTargetProps), clonedTarget);\n            return React.createElement(resizeSensor_1.ResizeSensor, { onResize: _this.reposition }, target);\n        };\n        _this.isControlled = function () { return _this.props.isOpen !== undefined; };\n        _this.handleTargetFocus = function (e) {\n            var _a, _b;\n            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n                if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n                    // ignore this focus event -- the target was already focused but the page itself\n                    // lost focus (e.g. due to switching tabs).\n                    return;\n                }\n                _this.handleMouseEnter(e);\n            }\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        _this.handleTargetBlur = function (e) {\n            var _a, _b;\n            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n                // if the next element to receive focus is within the popover, we'll want to leave the\n                // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n                // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n                // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n                // close the popover if necessary.\n                if (e.relatedTarget != null && !_this.isElementInPopover(e.relatedTarget)) {\n                    _this.handleMouseLeave(e);\n                }\n            }\n            _this.lostFocusOnSamePage = e.relatedTarget != null;\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        _this.handleMouseEnter = function (e) {\n            var _a, _b;\n            _this.isMouseInTargetOrPopover = true;\n            // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n            // trigger the mouse leave event, as hovering over the popover shouldn't count.\n            if (!_this.props.usePortal &&\n                _this.isElementInPopover(e.target) &&\n                _this.props.interactionKind === exports.PopoverInteractionKind.HOVER_TARGET_ONLY &&\n                !_this.props.openOnTargetFocus) {\n                _this.handleMouseLeave(e);\n            }\n            else if (!_this.props.disabled) {\n                // only begin opening popover when it is enabled\n                _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n            }\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        _this.handleMouseLeave = function (e) {\n            var _a, _b;\n            _this.isMouseInTargetOrPopover = false;\n            // wait until the event queue is flushed, because we want to leave the\n            // popover open if the mouse entered the popover immediately after\n            // leaving the target (or vice versa).\n            _this.setTimeout(function () {\n                if (_this.isMouseInTargetOrPopover) {\n                    return;\n                }\n                // user-configurable closing delay is helpful when moving mouse from target to popover\n                _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n            });\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        _this.handlePopoverClick = function (e) {\n            var eventTarget = e.target;\n            var eventPopover = eventTarget.closest(\".\" + common_1.Classes.POPOVER);\n            var isEventFromSelf = eventPopover === _this.popoverRef.current;\n            var isEventPopoverCapturing = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(common_1.Classes.POPOVER_CAPTURING_DISMISS);\n            // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n            var dismissElement = eventTarget.closest(\".\" + common_1.Classes.POPOVER_DISMISS + \", .\" + common_1.Classes.POPOVER_DISMISS_OVERRIDE);\n            var shouldDismiss = dismissElement != null && dismissElement.classList.contains(common_1.Classes.POPOVER_DISMISS);\n            var isDisabled = eventTarget.closest(\":disabled, .\" + common_1.Classes.DISABLED) != null;\n            if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n                _this.setOpenState(false, e);\n            }\n        };\n        _this.handleOverlayClose = function (e) {\n            if (_this.targetElement === null || e === undefined) {\n                return;\n            }\n            var eventTarget = e.target;\n            // if click was in target, target event listener will handle things, so don't close\n            if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n                _this.setOpenState(false, e);\n            }\n        };\n        _this.handleTargetClick = function (e) {\n            var _a, _b;\n            // ensure click did not originate from within inline popover before closing\n            if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n                if (_this.props.isOpen == null) {\n                    _this.setState(function (prevState) { return ({ isOpen: !prevState.isOpen }); });\n                }\n                else {\n                    _this.setOpenState(!_this.props.isOpen, e);\n                }\n            }\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        /** Popper modifier that updates React state (for style properties) based on latest data. */\n        _this.updatePopoverState = function (data) {\n            // always set string; let shouldComponentUpdate determine if update is necessary\n            _this.setState({ transformOrigin: popperUtils_1.getTransformOrigin(data) });\n            return data;\n        };\n        return _this;\n    }\n    Popover.prototype.render = function () {\n        var _a;\n        // rename wrapper tag to begin with uppercase letter so it's recognized\n        // as JSX component instead of intrinsic element. but because of its\n        // type, tsc actually recognizes that it is _any_ intrinsic element, so\n        // it can typecheck the HTML props!!\n        var _b = this.props, className = _b.className, disabled = _b.disabled, fill = _b.fill, placement = _b.placement, _c = _b.position, position = _c === void 0 ? \"auto\" : _c;\n        var isOpen = this.state.isOpen;\n        var wrapperTagName = this.props.wrapperTagName;\n        if (fill) {\n            wrapperTagName = \"div\";\n        }\n        var isContentEmpty = Utils.ensureElement(this.understandChildren().content) == null;\n        // need to do this check in render(), because `isOpen` is derived from\n        // state, and state can't necessarily be accessed in validateProps.\n        if (isContentEmpty && !disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n            console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n        }\n        var wrapperClasses = classnames_1.default(common_1.Classes.POPOVER_WRAPPER, className, (_a = {},\n            _a[common_1.Classes.FILL] = fill,\n            _a));\n        var wrapper = React.createElement(wrapperTagName, { className: wrapperClasses }, React.createElement(react_popper_1.Reference, { innerRef: this.handleTargetRef }, this.renderTarget), React.createElement(overlay_1.Overlay, { autoFocus: this.props.autoFocus, backdropClassName: common_1.Classes.POPOVER_BACKDROP, backdropProps: this.props.backdropProps, canEscapeKeyClose: this.props.canEscapeKeyClose, canOutsideClickClose: this.props.interactionKind === exports.PopoverInteractionKind.CLICK, className: this.props.portalClassName, enforceFocus: this.props.enforceFocus, hasBackdrop: this.props.hasBackdrop, isOpen: isOpen && !isContentEmpty, onClose: this.handleOverlayClose, onClosed: this.props.onClosed, onClosing: this.props.onClosing, onOpened: this.props.onOpened, onOpening: this.props.onOpening, transitionDuration: this.props.transitionDuration, transitionName: common_1.Classes.POPOVER, usePortal: this.props.usePortal, portalContainer: this.props.portalContainer },\n            React.createElement(react_popper_1.Popper, { innerRef: this.handlePopoverRef, placement: placement !== null && placement !== void 0 ? placement : popoverMigrationUtils_1.positionToPlacement(position), modifiers: this.getPopperModifiers() }, this.renderPopover)));\n        return React.createElement(react_popper_1.Manager, null, wrapper);\n    };\n    Popover.prototype.componentDidMount = function () {\n        this.updateDarkParent();\n    };\n    Popover.prototype.componentDidUpdate = function (prevProps, prevState) {\n        _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\n        if (prevProps.popoverRef !== this.props.popoverRef) {\n            common_1.setRef(prevProps.popoverRef, null);\n            this.handlePopoverRef = common_1.refHandler(this, \"popoverElement\", this.props.popoverRef);\n            common_1.setRef(this.props.popoverRef, this.popoverElement);\n        }\n        this.updateDarkParent();\n        var nextIsOpen = this.getIsOpen(this.props);\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        }\n        else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    };\n    Popover.prototype.validateProps = function (props) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== exports.PopoverInteractionKind.CLICK) {\n            console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n        }\n        if (props.placement !== undefined && props.position !== undefined) {\n            console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n        }\n        var childrenCount = React.Children.count(props.children);\n        var hasContentProp = props.content !== undefined;\n        var hasTargetProp = props.target !== undefined;\n        if (childrenCount === 0 && !hasTargetProp) {\n            console.error(Errors.POPOVER_REQUIRES_TARGET);\n        }\n        if (childrenCount > 2) {\n            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasTargetProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n        }\n        if (childrenCount === 2 && hasContentProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT);\n        }\n    };\n    Popover.prototype.updateDarkParent = function () {\n        if (this.props.usePortal && this.state.isOpen) {\n            var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\" + common_1.Classes.DARK) != null;\n            this.setState({ hasDarkParent: hasDarkParent });\n        }\n    };\n    // content and target can be specified as props or as children. this method\n    // normalizes the two approaches, preferring child over prop.\n    Popover.prototype.understandChildren = function () {\n        var _a = this.props, children = _a.children, contentProp = _a.content, targetProp = _a.target;\n        // #validateProps asserts that 1 <= children.length <= 2 so content is optional\n        var _b = React.Children.toArray(children), targetChild = _b[0], contentChild = _b[1];\n        return {\n            content: contentChild == null ? contentProp : contentChild,\n            target: targetChild == null ? targetProp : targetChild,\n        };\n    };\n    Popover.prototype.getIsOpen = function (props) {\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        }\n        else if (props.isOpen != null) {\n            return props.isOpen;\n        }\n        else {\n            return props.defaultIsOpen;\n        }\n    };\n    Popover.prototype.getPopperModifiers = function () {\n        var _a = this.props, boundary = _a.boundary, modifiers = _a.modifiers;\n        var _b = modifiers, _c = _b.flip, flip = _c === void 0 ? {} : _c, _d = _b.preventOverflow, preventOverflow = _d === void 0 ? {} : _d;\n        return tslib_1.__assign(tslib_1.__assign({}, modifiers), { arrowOffset: {\n                enabled: this.isArrowEnabled(),\n                fn: popperUtils_1.arrowOffsetModifier,\n                order: 510,\n            }, flip: tslib_1.__assign({ boundariesElement: boundary }, flip), preventOverflow: tslib_1.__assign({ boundariesElement: boundary }, preventOverflow), updatePopoverState: {\n                enabled: true,\n                fn: this.updatePopoverState,\n                order: 900,\n            } });\n    };\n    // a wrapper around setState({isOpen}) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    Popover.prototype.setOpenState = function (isOpen, e, timeout) {\n        var _this = this;\n        var _a, _b, _c, _d, _e;\n        // cancel any existing timeout because we have new state\n        (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n        if (timeout !== undefined && timeout > 0) {\n            this.cancelOpenTimeout = this.setTimeout(function () { return _this.setOpenState(isOpen, e); }, timeout);\n        }\n        else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen: isOpen });\n            }\n            else {\n                (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n            }\n        }\n    };\n    Popover.prototype.isArrowEnabled = function () {\n        var _a = this.props, minimal = _a.minimal, modifiers = _a.modifiers;\n        // omitting `arrow` from `modifiers` uses Popper default, which does show an arrow.\n        return !minimal && ((modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow) == null || modifiers.arrow.enabled);\n    };\n    Popover.prototype.isElementInPopover = function (element) {\n        var _a;\n        return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.contains(element);\n    };\n    Popover.prototype.isHoverInteractionKind = function () {\n        return (this.props.interactionKind === exports.PopoverInteractionKind.HOVER ||\n            this.props.interactionKind === exports.PopoverInteractionKind.HOVER_TARGET_ONLY);\n    };\n    Popover.displayName = props_1.DISPLAYNAME_PREFIX + \".Popover\";\n    Popover.defaultProps = {\n        boundary: \"scrollParent\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: exports.PopoverInteractionKind.CLICK,\n        minimal: false,\n        modifiers: {},\n        openOnTargetFocus: true,\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\n        // a warning in validateProps if the other prop is specified by a user of this component\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n        wrapperTagName: \"span\",\n    };\n    Popover = tslib_1.__decorate([\n        react_lifecycles_compat_1.polyfill\n    ], Popover);\n    return Popover;\n}(common_1.AbstractPureComponent2));\nexports.Popover = Popover;\n//# sourceMappingURL=popover.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$tslib$tslib","~$module$node_modules$$blueprintjs$core$lib$cjs$components$popover$popoverArrow","~$module$node_modules$react_lifecycles_compat$react_lifecycles_compat_cjs","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$$blueprintjs$core$lib$cjs$components$overlay$overlay","~$module$node_modules$$blueprintjs$core$lib$cjs$common$utils$index","~$module$node_modules$react_popper$lib$cjs$index","~$module$node_modules$$blueprintjs$core$lib$cjs$common$props","~$module$node_modules$classnames$index","~$module$node_modules$$blueprintjs$core$lib$cjs$common$errors","~$module$node_modules$$blueprintjs$core$lib$cjs$common$index","~$module$node_modules$$blueprintjs$core$lib$cjs$components$popover$popoverMigrationUtils","~$module$node_modules$$blueprintjs$core$lib$cjs$components$resize_sensor$resizeSensor","~$module$node_modules$$blueprintjs$core$lib$cjs$components$tooltip$tooltip","~$module$node_modules$$blueprintjs$core$lib$cjs$components$popover$popperUtils"]],"~:properties",["^5",["enforceFocus","arrowOffset","onClosing","CLICK_TARGET_ONLY","handleTargetBlur","boundariesElement","getIsOpen","onClose","PopoverInteractionKind","lostFocusOnSamePage","Popover","hasBackdrop","preventOverflow","tabIndex","targetTagName","isMouseInTargetOrPopover","className","updatePopoverState","displayName","setOpenState","placement","__esModule","minimal","popoverRef","enabled","fn","HOVER_TARGET_ONLY","flip","innerRef","inheritDarkTheme","handleTargetFocus","portalContainer","onMouseLeave","understandChildren","validateProps","handleMouseEnter","style","CLICK","value","renderPopover","boundary","isArrowEnabled","onFocus","defaultIsOpen","componentDidUpdate","handleOverlayClose","popoverElement","fill","backdropClassName","captureDismiss","canEscapeKeyClose","modifiers","content","handlePopoverRef","wrapperTagName","transitionName","usePortal","transformOrigin","updateDarkParent","onBlur","popperScheduleUpdate","componentDidMount","onClick","defaultProps","HOVER","order","isHoverInteractionKind","canOutsideClickClose","onOpened","backdropProps","reposition","render","onMouseEnter","onClosed","state","ref","handleTargetClick","getPopperModifiers","interactionKind","target","handleTargetRef","arrowProps","handlePopoverClick","hasDarkParent","isControlled","isOpen","handleMouseLeave","openOnTargetFocus","disabled","onOpening","hoverOpenDelay","transitionDuration","renderTarget","hoverCloseDelay","cancelOpenTimeout","isElementInPopover","targetElement","autoFocus","onResize"]],"~:compiled-at",1630405505034,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$blueprintjs$core$lib$cjs$components$popover$popover.js\",\n\"lineCount\":28,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@blueprintjs/core/lib/cjs/components/popover/popover.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$blueprintjs$core$lib$cjs$components$popover$popover\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n/*\\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.Popover = exports.PopoverInteractionKind = void 0;\\nvar tslib_1 = require(\\\"tslib\\\");\\nvar classnames_1 = tslib_1.__importDefault(require(\\\"classnames\\\"));\\nvar React = tslib_1.__importStar(require(\\\"react\\\"));\\nvar react_lifecycles_compat_1 = require(\\\"react-lifecycles-compat\\\");\\nvar react_popper_1 = require(\\\"react-popper\\\");\\nvar common_1 = require(\\\"../../common\\\");\\nvar Errors = tslib_1.__importStar(require(\\\"../../common/errors\\\"));\\nvar props_1 = require(\\\"../../common/props\\\");\\nvar Utils = tslib_1.__importStar(require(\\\"../../common/utils\\\"));\\nvar overlay_1 = require(\\\"../overlay/overlay\\\");\\nvar resizeSensor_1 = require(\\\"../resize-sensor/resizeSensor\\\");\\n// eslint-disable-next-line import/no-cycle\\nvar tooltip_1 = require(\\\"../tooltip/tooltip\\\");\\nvar popoverArrow_1 = require(\\\"./popoverArrow\\\");\\nvar popoverMigrationUtils_1 = require(\\\"./popoverMigrationUtils\\\");\\nvar popperUtils_1 = require(\\\"./popperUtils\\\");\\nexports.PopoverInteractionKind = {\\n    CLICK: \\\"click\\\",\\n    CLICK_TARGET_ONLY: \\\"click-target\\\",\\n    HOVER: \\\"hover\\\",\\n    HOVER_TARGET_ONLY: \\\"hover-target\\\",\\n};\\n/** @deprecated use { Popover2 } from \\\"@blueprintjs/popover2\\\" */\\nvar Popover = /** @class */ (function (_super) {\\n    tslib_1.__extends(Popover, _super);\\n    function Popover() {\\n        var _this = _super !== null && _super.apply(this, arguments) || this;\\n        // eslint-disable-next-line deprecation/deprecation\\n        _this.popoverRef = Utils.createReactRef();\\n        /**\\n         * DOM element that contains the popover.\\n         * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\\n         * so this reference can be very useful for testing.\\n         */\\n        _this.popoverElement = null;\\n        /** DOM element that contains the target. */\\n        _this.targetElement = null;\\n        _this.state = {\\n            hasDarkParent: false,\\n            isOpen: _this.getIsOpen(_this.props),\\n            transformOrigin: \\\"\\\",\\n        };\\n        // a flag that lets us detect mouse movement between the target and popover,\\n        // now that mouseleave is triggered when you cross the gap between the two.\\n        _this.isMouseInTargetOrPopover = false;\\n        // a flag that indicates whether the target previously lost focus to another\\n        // element on the same page.\\n        _this.lostFocusOnSamePage = true;\\n        _this.handlePopoverRef = common_1.refHandler(_this, \\\"popoverElement\\\", _this.props.popoverRef);\\n        _this.handleTargetRef = function (ref) { return (_this.targetElement = ref); };\\n        /**\\n         * Instance method to instruct the `Popover` to recompute its position.\\n         *\\n         * This method should only be used if you are updating the target in a way\\n         * that does not cause it to re-render, such as changing its _position_\\n         * without changing its _size_ (since `Popover` already repositions when it\\n         * detects a resize).\\n         */\\n        _this.reposition = function () { var _a; return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this); };\\n        _this.renderPopover = function (popperProps) {\\n            var _a;\\n            var _b = _this.props, usePortal = _b.usePortal, interactionKind = _b.interactionKind;\\n            var transformOrigin = _this.state.transformOrigin;\\n            // Need to update our reference to this on every render as it will change.\\n            _this.popperScheduleUpdate = popperProps.scheduleUpdate;\\n            var popoverHandlers = {\\n                // always check popover clicks for dismiss class\\n                onClick: _this.handlePopoverClick,\\n            };\\n            if (interactionKind === exports.PopoverInteractionKind.HOVER ||\\n                (!usePortal && interactionKind === exports.PopoverInteractionKind.HOVER_TARGET_ONLY)) {\\n                popoverHandlers.onMouseEnter = _this.handleMouseEnter;\\n                popoverHandlers.onMouseLeave = _this.handleMouseLeave;\\n            }\\n            var popoverClasses = classnames_1.default(common_1.Classes.POPOVER, (_a = {},\\n                _a[common_1.Classes.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent,\\n                _a[common_1.Classes.MINIMAL] = _this.props.minimal,\\n                _a[common_1.Classes.POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss,\\n                _a), _this.props.popoverClassName);\\n            return (React.createElement(\\\"div\\\", { className: common_1.Classes.TRANSITION_CONTAINER, ref: popperProps.ref, style: popperProps.style },\\n                React.createElement(resizeSensor_1.ResizeSensor, { onResize: _this.reposition },\\n                    React.createElement(\\\"div\\\", tslib_1.__assign({ className: popoverClasses, style: { transformOrigin: transformOrigin }, ref: _this.popoverRef }, popoverHandlers),\\n                        _this.isArrowEnabled() && (React.createElement(popoverArrow_1.PopoverArrow, { arrowProps: popperProps.arrowProps, placement: popperProps.placement })),\\n                        React.createElement(\\\"div\\\", { className: common_1.Classes.POPOVER_CONTENT }, _this.understandChildren().content)))));\\n        };\\n        _this.renderTarget = function (referenceProps) {\\n            var _a, _b;\\n            var _c = _this.props, fill = _c.fill, openOnTargetFocus = _c.openOnTargetFocus, targetClassName = _c.targetClassName, _d = _c.targetProps, targetProps = _d === void 0 ? {} : _d;\\n            var isOpen = _this.state.isOpen;\\n            var isControlled = _this.isControlled();\\n            var isHoverInteractionKind = _this.isHoverInteractionKind();\\n            var targetTagName = _this.props.targetTagName;\\n            if (fill) {\\n                targetTagName = \\\"div\\\";\\n            }\\n            var finalTargetProps = isHoverInteractionKind\\n                ? {\\n                    // HOVER handlers\\n                    onBlur: _this.handleTargetBlur,\\n                    onFocus: _this.handleTargetFocus,\\n                    onMouseEnter: _this.handleMouseEnter,\\n                    onMouseLeave: _this.handleMouseLeave,\\n                }\\n                : {\\n                    // CLICK needs only one handler\\n                    onClick: _this.handleTargetClick,\\n                };\\n            finalTargetProps[\\\"aria-haspopup\\\"] = \\\"true\\\";\\n            finalTargetProps.className = classnames_1.default(common_1.Classes.POPOVER_TARGET, (_a = {}, _a[common_1.Classes.POPOVER_OPEN] = isOpen, _a), targetProps.className, targetClassName);\\n            finalTargetProps.ref = referenceProps.ref;\\n            var rawTarget = Utils.ensureElement(_this.understandChildren().target);\\n            if (rawTarget === undefined) {\\n                return null;\\n            }\\n            var rawTabIndex = rawTarget.props.tabIndex;\\n            // ensure target is focusable if relevant prop enabled\\n            var tabIndex = rawTabIndex == null && openOnTargetFocus && isHoverInteractionKind ? 0 : rawTabIndex;\\n            var clonedTarget = React.cloneElement(rawTarget, {\\n                className: classnames_1.default(rawTarget.props.className, (_b = {},\\n                    // this class is mainly useful for button targets; we should only apply it for uncontrolled popovers\\n                    // when they are opened by a user interaction\\n                    _b[common_1.Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind,\\n                    _b)),\\n                // force disable single Tooltip child when popover is open (BLUEPRINT-552)\\n                /* eslint-disable-next-line deprecation/deprecation */\\n                disabled: isOpen && Utils.isElementOfType(rawTarget, tooltip_1.Tooltip) ? true : rawTarget.props.disabled,\\n                tabIndex: tabIndex,\\n            });\\n            var target = React.createElement(targetTagName, tslib_1.__assign(tslib_1.__assign({}, targetProps), finalTargetProps), clonedTarget);\\n            return React.createElement(resizeSensor_1.ResizeSensor, { onResize: _this.reposition }, target);\\n        };\\n        _this.isControlled = function () { return _this.props.isOpen !== undefined; };\\n        _this.handleTargetFocus = function (e) {\\n            var _a, _b;\\n            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\\n                if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\\n                    // ignore this focus event -- the target was already focused but the page itself\\n                    // lost focus (e.g. due to switching tabs).\\n                    return;\\n                }\\n                _this.handleMouseEnter(e);\\n            }\\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, e);\\n        };\\n        _this.handleTargetBlur = function (e) {\\n            var _a, _b;\\n            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\\n                // if the next element to receive focus is within the popover, we'll want to leave the\\n                // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\\n                // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\\n                // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\\n                // close the popover if necessary.\\n                if (e.relatedTarget != null && !_this.isElementInPopover(e.relatedTarget)) {\\n                    _this.handleMouseLeave(e);\\n                }\\n            }\\n            _this.lostFocusOnSamePage = e.relatedTarget != null;\\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, e);\\n        };\\n        _this.handleMouseEnter = function (e) {\\n            var _a, _b;\\n            _this.isMouseInTargetOrPopover = true;\\n            // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\\n            // trigger the mouse leave event, as hovering over the popover shouldn't count.\\n            if (!_this.props.usePortal &&\\n                _this.isElementInPopover(e.target) &&\\n                _this.props.interactionKind === exports.PopoverInteractionKind.HOVER_TARGET_ONLY &&\\n                !_this.props.openOnTargetFocus) {\\n                _this.handleMouseLeave(e);\\n            }\\n            else if (!_this.props.disabled) {\\n                // only begin opening popover when it is enabled\\n                _this.setOpenState(true, e, _this.props.hoverOpenDelay);\\n            }\\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, e);\\n        };\\n        _this.handleMouseLeave = function (e) {\\n            var _a, _b;\\n            _this.isMouseInTargetOrPopover = false;\\n            // wait until the event queue is flushed, because we want to leave the\\n            // popover open if the mouse entered the popover immediately after\\n            // leaving the target (or vice versa).\\n            _this.setTimeout(function () {\\n                if (_this.isMouseInTargetOrPopover) {\\n                    return;\\n                }\\n                // user-configurable closing delay is helpful when moving mouse from target to popover\\n                _this.setOpenState(false, e, _this.props.hoverCloseDelay);\\n            });\\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a, e);\\n        };\\n        _this.handlePopoverClick = function (e) {\\n            var eventTarget = e.target;\\n            var eventPopover = eventTarget.closest(\\\".\\\" + common_1.Classes.POPOVER);\\n            var isEventFromSelf = eventPopover === _this.popoverRef.current;\\n            var isEventPopoverCapturing = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(common_1.Classes.POPOVER_CAPTURING_DISMISS);\\n            // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\\n            var dismissElement = eventTarget.closest(\\\".\\\" + common_1.Classes.POPOVER_DISMISS + \\\", .\\\" + common_1.Classes.POPOVER_DISMISS_OVERRIDE);\\n            var shouldDismiss = dismissElement != null && dismissElement.classList.contains(common_1.Classes.POPOVER_DISMISS);\\n            var isDisabled = eventTarget.closest(\\\":disabled, .\\\" + common_1.Classes.DISABLED) != null;\\n            if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\\n                _this.setOpenState(false, e);\\n            }\\n        };\\n        _this.handleOverlayClose = function (e) {\\n            if (_this.targetElement === null || e === undefined) {\\n                return;\\n            }\\n            var eventTarget = e.target;\\n            // if click was in target, target event listener will handle things, so don't close\\n            if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\\n                _this.setOpenState(false, e);\\n            }\\n        };\\n        _this.handleTargetClick = function (e) {\\n            var _a, _b;\\n            // ensure click did not originate from within inline popover before closing\\n            if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\\n                if (_this.props.isOpen == null) {\\n                    _this.setState(function (prevState) { return ({ isOpen: !prevState.isOpen }); });\\n                }\\n                else {\\n                    _this.setOpenState(!_this.props.isOpen, e);\\n                }\\n            }\\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);\\n        };\\n        /** Popper modifier that updates React state (for style properties) based on latest data. */\\n        _this.updatePopoverState = function (data) {\\n            // always set string; let shouldComponentUpdate determine if update is necessary\\n            _this.setState({ transformOrigin: popperUtils_1.getTransformOrigin(data) });\\n            return data;\\n        };\\n        return _this;\\n    }\\n    Popover.prototype.render = function () {\\n        var _a;\\n        // rename wrapper tag to begin with uppercase letter so it's recognized\\n        // as JSX component instead of intrinsic element. but because of its\\n        // type, tsc actually recognizes that it is _any_ intrinsic element, so\\n        // it can typecheck the HTML props!!\\n        var _b = this.props, className = _b.className, disabled = _b.disabled, fill = _b.fill, placement = _b.placement, _c = _b.position, position = _c === void 0 ? \\\"auto\\\" : _c;\\n        var isOpen = this.state.isOpen;\\n        var wrapperTagName = this.props.wrapperTagName;\\n        if (fill) {\\n            wrapperTagName = \\\"div\\\";\\n        }\\n        var isContentEmpty = Utils.ensureElement(this.understandChildren().content) == null;\\n        // need to do this check in render(), because `isOpen` is derived from\\n        // state, and state can't necessarily be accessed in validateProps.\\n        if (isContentEmpty && !disabled && isOpen !== false && !Utils.isNodeEnv(\\\"production\\\")) {\\n            console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\\n        }\\n        var wrapperClasses = classnames_1.default(common_1.Classes.POPOVER_WRAPPER, className, (_a = {},\\n            _a[common_1.Classes.FILL] = fill,\\n            _a));\\n        var wrapper = React.createElement(wrapperTagName, { className: wrapperClasses }, React.createElement(react_popper_1.Reference, { innerRef: this.handleTargetRef }, this.renderTarget), React.createElement(overlay_1.Overlay, { autoFocus: this.props.autoFocus, backdropClassName: common_1.Classes.POPOVER_BACKDROP, backdropProps: this.props.backdropProps, canEscapeKeyClose: this.props.canEscapeKeyClose, canOutsideClickClose: this.props.interactionKind === exports.PopoverInteractionKind.CLICK, className: this.props.portalClassName, enforceFocus: this.props.enforceFocus, hasBackdrop: this.props.hasBackdrop, isOpen: isOpen && !isContentEmpty, onClose: this.handleOverlayClose, onClosed: this.props.onClosed, onClosing: this.props.onClosing, onOpened: this.props.onOpened, onOpening: this.props.onOpening, transitionDuration: this.props.transitionDuration, transitionName: common_1.Classes.POPOVER, usePortal: this.props.usePortal, portalContainer: this.props.portalContainer },\\n            React.createElement(react_popper_1.Popper, { innerRef: this.handlePopoverRef, placement: placement !== null && placement !== void 0 ? placement : popoverMigrationUtils_1.positionToPlacement(position), modifiers: this.getPopperModifiers() }, this.renderPopover)));\\n        return React.createElement(react_popper_1.Manager, null, wrapper);\\n    };\\n    Popover.prototype.componentDidMount = function () {\\n        this.updateDarkParent();\\n    };\\n    Popover.prototype.componentDidUpdate = function (prevProps, prevState) {\\n        _super.prototype.componentDidUpdate.call(this, prevProps, prevState);\\n        if (prevProps.popoverRef !== this.props.popoverRef) {\\n            common_1.setRef(prevProps.popoverRef, null);\\n            this.handlePopoverRef = common_1.refHandler(this, \\\"popoverElement\\\", this.props.popoverRef);\\n            common_1.setRef(this.props.popoverRef, this.popoverElement);\\n        }\\n        this.updateDarkParent();\\n        var nextIsOpen = this.getIsOpen(this.props);\\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\\n            this.setOpenState(nextIsOpen);\\n            // tricky: setOpenState calls setState only if this.props.isOpen is\\n            // not controlled, so we need to invoke setState manually here.\\n            this.setState({ isOpen: nextIsOpen });\\n        }\\n        else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\\n            // special case: close an uncontrolled popover when disabled is set to true\\n            this.setOpenState(false);\\n        }\\n    };\\n    Popover.prototype.validateProps = function (props) {\\n        if (props.isOpen == null && props.onInteraction != null) {\\n            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\\n        }\\n        if (props.hasBackdrop && !props.usePortal) {\\n            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\\n        }\\n        if (props.hasBackdrop && props.interactionKind !== exports.PopoverInteractionKind.CLICK) {\\n            console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\\n        }\\n        if (props.placement !== undefined && props.position !== undefined) {\\n            console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\\n        }\\n        var childrenCount = React.Children.count(props.children);\\n        var hasContentProp = props.content !== undefined;\\n        var hasTargetProp = props.target !== undefined;\\n        if (childrenCount === 0 && !hasTargetProp) {\\n            console.error(Errors.POPOVER_REQUIRES_TARGET);\\n        }\\n        if (childrenCount > 2) {\\n            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\\n        }\\n        if (childrenCount > 0 && hasTargetProp) {\\n            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\\n        }\\n        if (childrenCount === 2 && hasContentProp) {\\n            console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT);\\n        }\\n    };\\n    Popover.prototype.updateDarkParent = function () {\\n        if (this.props.usePortal && this.state.isOpen) {\\n            var hasDarkParent = this.targetElement != null && this.targetElement.closest(\\\".\\\" + common_1.Classes.DARK) != null;\\n            this.setState({ hasDarkParent: hasDarkParent });\\n        }\\n    };\\n    // content and target can be specified as props or as children. this method\\n    // normalizes the two approaches, preferring child over prop.\\n    Popover.prototype.understandChildren = function () {\\n        var _a = this.props, children = _a.children, contentProp = _a.content, targetProp = _a.target;\\n        // #validateProps asserts that 1 <= children.length <= 2 so content is optional\\n        var _b = React.Children.toArray(children), targetChild = _b[0], contentChild = _b[1];\\n        return {\\n            content: contentChild == null ? contentProp : contentChild,\\n            target: targetChild == null ? targetProp : targetChild,\\n        };\\n    };\\n    Popover.prototype.getIsOpen = function (props) {\\n        // disabled popovers should never be allowed to open.\\n        if (props.disabled) {\\n            return false;\\n        }\\n        else if (props.isOpen != null) {\\n            return props.isOpen;\\n        }\\n        else {\\n            return props.defaultIsOpen;\\n        }\\n    };\\n    Popover.prototype.getPopperModifiers = function () {\\n        var _a = this.props, boundary = _a.boundary, modifiers = _a.modifiers;\\n        var _b = modifiers, _c = _b.flip, flip = _c === void 0 ? {} : _c, _d = _b.preventOverflow, preventOverflow = _d === void 0 ? {} : _d;\\n        return tslib_1.__assign(tslib_1.__assign({}, modifiers), { arrowOffset: {\\n                enabled: this.isArrowEnabled(),\\n                fn: popperUtils_1.arrowOffsetModifier,\\n                order: 510,\\n            }, flip: tslib_1.__assign({ boundariesElement: boundary }, flip), preventOverflow: tslib_1.__assign({ boundariesElement: boundary }, preventOverflow), updatePopoverState: {\\n                enabled: true,\\n                fn: this.updatePopoverState,\\n                order: 900,\\n            } });\\n    };\\n    // a wrapper around setState({isOpen}) that will call props.onInteraction instead when in controlled mode.\\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\\n    Popover.prototype.setOpenState = function (isOpen, e, timeout) {\\n        var _this = this;\\n        var _a, _b, _c, _d, _e;\\n        // cancel any existing timeout because we have new state\\n        (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\\n        if (timeout !== undefined && timeout > 0) {\\n            this.cancelOpenTimeout = this.setTimeout(function () { return _this.setOpenState(isOpen, e); }, timeout);\\n        }\\n        else {\\n            if (this.props.isOpen == null) {\\n                this.setState({ isOpen: isOpen });\\n            }\\n            else {\\n                (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\\n            }\\n            if (!isOpen) {\\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\\n                (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\\n            }\\n        }\\n    };\\n    Popover.prototype.isArrowEnabled = function () {\\n        var _a = this.props, minimal = _a.minimal, modifiers = _a.modifiers;\\n        // omitting `arrow` from `modifiers` uses Popper default, which does show an arrow.\\n        return !minimal && ((modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow) == null || modifiers.arrow.enabled);\\n    };\\n    Popover.prototype.isElementInPopover = function (element) {\\n        var _a;\\n        return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.contains(element);\\n    };\\n    Popover.prototype.isHoverInteractionKind = function () {\\n        return (this.props.interactionKind === exports.PopoverInteractionKind.HOVER ||\\n            this.props.interactionKind === exports.PopoverInteractionKind.HOVER_TARGET_ONLY);\\n    };\\n    Popover.displayName = props_1.DISPLAYNAME_PREFIX + \\\".Popover\\\";\\n    Popover.defaultProps = {\\n        boundary: \\\"scrollParent\\\",\\n        captureDismiss: false,\\n        defaultIsOpen: false,\\n        disabled: false,\\n        fill: false,\\n        hasBackdrop: false,\\n        hoverCloseDelay: 300,\\n        hoverOpenDelay: 150,\\n        inheritDarkTheme: true,\\n        interactionKind: exports.PopoverInteractionKind.CLICK,\\n        minimal: false,\\n        modifiers: {},\\n        openOnTargetFocus: true,\\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\\n        // a warning in validateProps if the other prop is specified by a user of this component\\n        targetTagName: \\\"span\\\",\\n        transitionDuration: 300,\\n        usePortal: true,\\n        wrapperTagName: \\\"span\\\",\\n    };\\n    Popover = tslib_1.__decorate([\\n        react_lifecycles_compat_1.polyfill\\n    ], Popover);\\n    return Popover;\\n}(common_1.AbstractPureComponent2));\\nexports.Popover = Popover;\\n//# sourceMappingURL=popover.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"Popover\",\"PopoverInteractionKind\",\"tslib_1\",\"classnames_1\",\"__importDefault\",\"React\",\"__importStar\",\"react_lifecycles_compat_1\",\"react_popper_1\",\"common_1\",\"Errors\",\"props_1\",\"Utils\",\"overlay_1\",\"resizeSensor_1\",\"tooltip_1\",\"popoverArrow_1\",\"popoverMigrationUtils_1\",\"popperUtils_1\",\"CLICK\",\"CLICK_TARGET_ONLY\",\"HOVER\",\"HOVER_TARGET_ONLY\",\"_super\",\"_this\",\"apply\",\"arguments\",\"popoverRef\",\"createReactRef\",\"popoverElement\",\"targetElement\",\"state\",\"hasDarkParent\",\"isOpen\",\"getIsOpen\",\"props\",\"transformOrigin\",\"isMouseInTargetOrPopover\",\"lostFocusOnSamePage\",\"handlePopoverRef\",\"refHandler\",\"handleTargetRef\",\"_this.handleTargetRef\",\"ref\",\"reposition\",\"_this.reposition\",\"_a\",\"popperScheduleUpdate\",\"call\",\"renderPopover\",\"_this.renderPopover\",\"popperProps\",\"_b\",\"usePortal\",\"interactionKind\",\"scheduleUpdate\",\"popoverHandlers\",\"onClick\",\"handlePopoverClick\",\"onMouseEnter\",\"handleMouseEnter\",\"onMouseLeave\",\"handleMouseLeave\",\"popoverClasses\",\"default\",\"Classes\",\"POPOVER\",\"DARK\",\"inheritDarkTheme\",\"MINIMAL\",\"minimal\",\"POPOVER_CAPTURING_DISMISS\",\"captureDismiss\",\"popoverClassName\",\"createElement\",\"className\",\"TRANSITION_CONTAINER\",\"style\",\"ResizeSensor\",\"onResize\",\"__assign\",\"isArrowEnabled\",\"PopoverArrow\",\"arrowProps\",\"placement\",\"POPOVER_CONTENT\",\"understandChildren\",\"content\",\"renderTarget\",\"_this.renderTarget\",\"referenceProps\",\"_c\",\"fill\",\"openOnTargetFocus\",\"targetClassName\",\"_d\",\"targetProps\",\"isControlled\",\"isHoverInteractionKind\",\"targetTagName\",\"finalTargetProps\",\"onBlur\",\"handleTargetBlur\",\"onFocus\",\"handleTargetFocus\",\"handleTargetClick\",\"POPOVER_TARGET\",\"POPOVER_OPEN\",\"rawTarget\",\"ensureElement\",\"target\",\"undefined\",\"rawTabIndex\",\"tabIndex\",\"clonedTarget\",\"cloneElement\",\"ACTIVE\",\"disabled\",\"isElementOfType\",\"Tooltip\",\"_this.isControlled\",\"_this.handleTargetFocus\",\"e\",\"relatedTarget\",\"_this.handleTargetBlur\",\"isElementInPopover\",\"_this.handleMouseEnter\",\"setOpenState\",\"hoverOpenDelay\",\"_this.handleMouseLeave\",\"setTimeout\",\"hoverCloseDelay\",\"_this.handlePopoverClick\",\"eventTarget\",\"eventPopover\",\"closest\",\"isEventFromSelf\",\"current\",\"isEventPopoverCapturing\",\"classList\",\"contains\",\"dismissElement\",\"POPOVER_DISMISS\",\"POPOVER_DISMISS_OVERRIDE\",\"shouldDismiss\",\"isDisabled\",\"DISABLED\",\"handleOverlayClose\",\"_this.handleOverlayClose\",\"elementIsOrContains\",\"nativeEvent\",\"KeyboardEvent\",\"_this.handleTargetClick\",\"setState\",\"prevState\",\"updatePopoverState\",\"_this.updatePopoverState\",\"data\",\"getTransformOrigin\",\"__extends\",\"prototype\",\"render\",\"Popover.prototype.render\",\"position\",\"wrapperTagName\",\"isContentEmpty\",\"isNodeEnv\",\"console\",\"warn\",\"POPOVER_WARN_EMPTY_CONTENT\",\"wrapperClasses\",\"POPOVER_WRAPPER\",\"FILL\",\"wrapper\",\"Reference\",\"innerRef\",\"Overlay\",\"autoFocus\",\"backdropClassName\",\"POPOVER_BACKDROP\",\"backdropProps\",\"canEscapeKeyClose\",\"canOutsideClickClose\",\"portalClassName\",\"enforceFocus\",\"hasBackdrop\",\"onClose\",\"onClosed\",\"onClosing\",\"onOpened\",\"onOpening\",\"transitionDuration\",\"transitionName\",\"portalContainer\",\"Popper\",\"positionToPlacement\",\"modifiers\",\"getPopperModifiers\",\"Manager\",\"componentDidMount\",\"Popover.prototype.componentDidMount\",\"updateDarkParent\",\"componentDidUpdate\",\"Popover.prototype.componentDidUpdate\",\"prevProps\",\"setRef\",\"nextIsOpen\",\"validateProps\",\"Popover.prototype.validateProps\",\"onInteraction\",\"POPOVER_WARN_UNCONTROLLED_ONINTERACTION\",\"POPOVER_WARN_HAS_BACKDROP_INLINE\",\"error\",\"POPOVER_HAS_BACKDROP_INTERACTION\",\"POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX\",\"childrenCount\",\"Children\",\"count\",\"children\",\"hasContentProp\",\"hasTargetProp\",\"POPOVER_REQUIRES_TARGET\",\"POPOVER_WARN_TOO_MANY_CHILDREN\",\"POPOVER_WARN_DOUBLE_TARGET\",\"POPOVER_WARN_DOUBLE_CONTENT\",\"Popover.prototype.updateDarkParent\",\"Popover.prototype.understandChildren\",\"contentProp\",\"targetProp\",\"toArray\",\"targetChild\",\"contentChild\",\"Popover.prototype.getIsOpen\",\"defaultIsOpen\",\"Popover.prototype.getPopperModifiers\",\"boundary\",\"flip\",\"preventOverflow\",\"arrowOffset\",\"enabled\",\"fn\",\"arrowOffsetModifier\",\"order\",\"boundariesElement\",\"Popover.prototype.setOpenState\",\"timeout\",\"_e\",\"cancelOpenTimeout\",\"Popover.prototype.isArrowEnabled\",\"arrow\",\"Popover.prototype.isElementInPopover\",\"element\",\"Popover.prototype.isHoverInteractionKind\",\"displayName\",\"DISPLAYNAME_PREFIX\",\"defaultProps\",\"__decorate\",\"polyfill\",\"AbstractPureComponent2\"]\n}\n"]