["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@blueprintjs/core/lib/cjs/common/refs.js"],"~:js","shadow$provide.module$node_modules$$blueprintjs$core$lib$cjs$common$refs=function(global,require,module,exports){function isRefObject(value){return null!=value&&\"function\"!==typeof value}function isRefCallback(value){return\"function\"===typeof value}function setRef(refTarget,ref){isRefObject(refTarget)?refTarget.current=ref:isRefCallback(refTarget)&&refTarget(ref)}function mergeRefs(){for(var refs=[],_i=0;_i<arguments.length;_i++)refs[_i]=arguments[_i];return function(value){refs.forEach(function(ref){setRef(ref,\nvalue)})}}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.refHandler=exports.getRef=exports.mergeRefs=exports.combineRefs=exports.setRef=exports.isRefCallback=exports.isRefObject=void 0;exports.isRefObject=isRefObject;exports.isRefCallback=isRefCallback;exports.setRef=setRef;exports.combineRefs=function(ref1,ref2){return mergeRefs(ref1,ref2)};exports.mergeRefs=mergeRefs;exports.getRef=function(ref){var _a;return null===ref?null:null!==(_a=ref.current)&&void 0!==_a?_a:ref};exports.refHandler=\nfunction(refTargetParent,refTargetKey,refProp){return function(ref){refTargetParent[refTargetKey]=ref;setRef(refProp,ref)}}}","~:source","shadow$provide[\"module$node_modules$$blueprintjs$core$lib$cjs$common$refs\"] = function(global,require,module,exports) {\n\"use strict\";\n/*\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.refHandler = exports.getRef = exports.mergeRefs = exports.combineRefs = exports.setRef = exports.isRefCallback = exports.isRefObject = void 0;\nfunction isRefObject(value) {\n    return value != null && typeof value !== \"function\";\n}\nexports.isRefObject = isRefObject;\nfunction isRefCallback(value) {\n    return typeof value === \"function\";\n}\nexports.isRefCallback = isRefCallback;\n/**\n * Assign the given ref to a target, either a React ref object or a callback which takes the ref as its first argument.\n */\nfunction setRef(refTarget, ref) {\n    if (isRefObject(refTarget)) {\n        refTarget.current = ref;\n    }\n    else if (isRefCallback(refTarget)) {\n        refTarget(ref);\n    }\n}\nexports.setRef = setRef;\n/** @deprecated use mergeRefs() instead */\nfunction combineRefs(ref1, ref2) {\n    return mergeRefs(ref1, ref2);\n}\nexports.combineRefs = combineRefs;\n/**\n * Utility for merging refs into one singular callback ref.\n * If using in a functional component, would recomend using `useMemo` to preserve function identity.\n */\nfunction mergeRefs() {\n    var refs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        refs[_i] = arguments[_i];\n    }\n    return function (value) {\n        refs.forEach(function (ref) {\n            setRef(ref, value);\n        });\n    };\n}\nexports.mergeRefs = mergeRefs;\nfunction getRef(ref) {\n    var _a;\n    if (ref === null) {\n        return null;\n    }\n    return (_a = ref.current) !== null && _a !== void 0 ? _a : ref;\n}\nexports.getRef = getRef;\n/**\n * Creates a ref handler which assigns the ref returned by React for a mounted component to a field on the target object.\n * The target object is usually a component class.\n *\n * If provided, it will also update the given `refProp` with the value of the ref.\n */\nfunction refHandler(refTargetParent, refTargetKey, refProp) {\n    return function (ref) {\n        refTargetParent[refTargetKey] = ref;\n        setRef(refProp, ref);\n    };\n}\nexports.refHandler = refHandler;\n//# sourceMappingURL=refs.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["isRefCallback","getRef","__esModule","refHandler","value","setRef","current","combineRefs","isRefObject","mergeRefs"]],"~:compiled-at",1630405504914,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$blueprintjs$core$lib$cjs$common$refs.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,yDAAA,CAA8E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAmBtHC,QAASA,YAAW,CAACC,KAAD,CAAQ,CACxB,MAAgB,KAAhB,EAAOA,KAAP,EAAyC,UAAzC,GAAwB,MAAOA,MADP,CAI5BC,QAASA,cAAa,CAACD,KAAD,CAAQ,CAC1B,MAAwB,UAAxB,GAAO,MAAOA,MADY,CAO9BE,QAASA,OAAM,CAACC,SAAD,CAAYC,GAAZ,CAAiB,CACxBL,WAAA,CAAYI,SAAZ,CAAJ,CACIA,SAAUE,CAAAA,OADd,CACwBD,GADxB,CAGSH,aAAA,CAAcE,SAAd,CAHT,EAIIA,SAAA,CAAUC,GAAV,CALwB,CAkBhCE,QAASA,UAAS,EAAG,CAEjB,IADA,IAAIC,KAAO,EAAX,CACSC,GAAK,CAAd,CAAiBA,EAAjB,CAAsBC,SAAUC,CAAAA,MAAhC,CAAwCF,EAAA,EAAxC,CACID,IAAA,CAAKC,EAAL,CAAA,CAAWC,SAAA,CAAUD,EAAV,CAEf,OAAO,SAAS,CAACR,KAAD,CAAQ,CACpBO,IAAKI,CAAAA,OAAL,CAAa,QAAS,CAACP,GAAD,CAAM,CACxBF,MAAA,CAAOE,GAAP;AAAYJ,KAAZ,CADwB,CAA5B,CADoB,CALP,CA/BrBY,MAAOC,CAAAA,cAAP,CAAsBf,OAAtB,CAA+B,YAA/B,CAA6C,CAAEE,MAAO,CAAA,CAAT,CAA7C,CACAF,QAAQgB,CAAAA,UAAR,CAAqBhB,OAAQiB,CAAAA,MAA7B,CAAsCjB,OAAQQ,CAAAA,SAA9C,CAA0DR,OAAQkB,CAAAA,WAAlE,CAAgFlB,OAAQI,CAAAA,MAAxF,CAAiGJ,OAAQG,CAAAA,aAAzG,CAAyHH,OAAQC,CAAAA,WAAjI,CAA+I,IAAK,EAIpJD,QAAQC,CAAAA,WAAR,CAAsBA,WAItBD,QAAQG,CAAAA,aAAR,CAAwBA,aAYxBH,QAAQI,CAAAA,MAAR,CAAiBA,MAKjBJ,QAAQkB,CAAAA,WAAR,CAHAA,QAAoB,CAACC,IAAD,CAAOC,IAAP,CAAa,CAC7B,MAAOZ,UAAA,CAAUW,IAAV,CAAgBC,IAAhB,CADsB,CAmBjCpB,QAAQQ,CAAAA,SAAR,CAAoBA,SAQpBR,QAAQiB,CAAAA,MAAR,CAPAA,QAAe,CAACX,GAAD,CAAM,CACjB,IAAIe,EACJ,OAAY,KAAZ,GAAIf,GAAJ,CACW,IADX,CAG8B,IAAvB,IAACe,EAAD,CAAMf,GAAIC,CAAAA,OAAV,GAAsC,IAAK,EAA3C,GAA+Bc,EAA/B,CAA+CA,EAA/C,CAAoDf,GAL1C,CAoBrBN,QAAQgB,CAAAA,UAAR;AANAA,QAAmB,CAACM,eAAD,CAAkBC,YAAlB,CAAgCC,OAAhC,CAAyC,CACxD,MAAO,SAAS,CAAClB,GAAD,CAAM,CAClBgB,eAAA,CAAgBC,YAAhB,CAAA,CAAgCjB,GAChCF,OAAA,CAAOoB,OAAP,CAAgBlB,GAAhB,CAFkB,CADkC,CA1E0D;\",\n\"sources\":[\"node_modules/@blueprintjs/core/lib/cjs/common/refs.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$blueprintjs$core$lib$cjs$common$refs\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n/*\\n * Copyright 2020 Palantir Technologies, Inc. All rights reserved.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *     http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.refHandler = exports.getRef = exports.mergeRefs = exports.combineRefs = exports.setRef = exports.isRefCallback = exports.isRefObject = void 0;\\nfunction isRefObject(value) {\\n    return value != null && typeof value !== \\\"function\\\";\\n}\\nexports.isRefObject = isRefObject;\\nfunction isRefCallback(value) {\\n    return typeof value === \\\"function\\\";\\n}\\nexports.isRefCallback = isRefCallback;\\n/**\\n * Assign the given ref to a target, either a React ref object or a callback which takes the ref as its first argument.\\n */\\nfunction setRef(refTarget, ref) {\\n    if (isRefObject(refTarget)) {\\n        refTarget.current = ref;\\n    }\\n    else if (isRefCallback(refTarget)) {\\n        refTarget(ref);\\n    }\\n}\\nexports.setRef = setRef;\\n/** @deprecated use mergeRefs() instead */\\nfunction combineRefs(ref1, ref2) {\\n    return mergeRefs(ref1, ref2);\\n}\\nexports.combineRefs = combineRefs;\\n/**\\n * Utility for merging refs into one singular callback ref.\\n * If using in a functional component, would recomend using `useMemo` to preserve function identity.\\n */\\nfunction mergeRefs() {\\n    var refs = [];\\n    for (var _i = 0; _i < arguments.length; _i++) {\\n        refs[_i] = arguments[_i];\\n    }\\n    return function (value) {\\n        refs.forEach(function (ref) {\\n            setRef(ref, value);\\n        });\\n    };\\n}\\nexports.mergeRefs = mergeRefs;\\nfunction getRef(ref) {\\n    var _a;\\n    if (ref === null) {\\n        return null;\\n    }\\n    return (_a = ref.current) !== null && _a !== void 0 ? _a : ref;\\n}\\nexports.getRef = getRef;\\n/**\\n * Creates a ref handler which assigns the ref returned by React for a mounted component to a field on the target object.\\n * The target object is usually a component class.\\n *\\n * If provided, it will also update the given `refProp` with the value of the ref.\\n */\\nfunction refHandler(refTargetParent, refTargetKey, refProp) {\\n    return function (ref) {\\n        refTargetParent[refTargetKey] = ref;\\n        setRef(refProp, ref);\\n    };\\n}\\nexports.refHandler = refHandler;\\n//# sourceMappingURL=refs.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"isRefObject\",\"value\",\"isRefCallback\",\"setRef\",\"refTarget\",\"ref\",\"current\",\"mergeRefs\",\"refs\",\"_i\",\"arguments\",\"length\",\"forEach\",\"Object\",\"defineProperty\",\"refHandler\",\"getRef\",\"combineRefs\",\"ref1\",\"ref2\",\"_a\",\"refTargetParent\",\"refTargetKey\",\"refProp\"]\n}\n"]