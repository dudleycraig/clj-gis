["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/curves/NURBSUtils.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$curves$NURBSUtils=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.calcBSplineDerivatives=function(p,U,P,u,nd){var du=nd<p?nd:p,CK=[],span=this.findSpan(p,u,U);U=this.calcBasisFunctionDerivatives(span,u,p,du,U);u=[];for(var i=0;i<P.length;++i){var point=P[i].clone(),w=point.w;point.x*=w;point.y*=w;point.z*=w;u[i]=point}for(P=0;P<=du;++P){point=u[span-p].clone().multiplyScalar(U[P][0]);for(i=1;i<=\np;++i)point.add(u[span-p+i].clone().multiplyScalar(U[P][i]));CK[P]=point}for(p=du+1;p<=nd+1;++p)CK[p]=new _three.Vector4(0,0,0);return CK};exports.calcBSplinePoint=function(p,U,P,u){var span=this.findSpan(p,u,U);U=this.calcBasisFunctions(span,u,p,U);u=new _three.Vector4(0,0,0,0);for(var j=0;j<=p;++j){var point=P[span-p+j],Nj=U[j],wNj=point.w*Nj;u.x+=point.x*wNj;u.y+=point.y*wNj;u.z+=point.z*wNj;u.w+=point.w*Nj}return u};exports.calcBasisFunctionDerivatives=function(span,u,p,n,U){for(var zeroArr=[],\ni=0;i<=p;++i)zeroArr[i]=0;i=[];for(var _i=0;_i<=n;++_i)i[_i]=zeroArr.slice(0);_i=[];for(var _i2=0;_i2<=p;++_i2)_i[_i2]=zeroArr.slice(0);_i[0][0]=1;_i2=zeroArr.slice(0);for(var right=zeroArr.slice(0),_j=1;_j<=p;++_j){_i2[_j]=u-U[span+1-_j];right[_j]=U[span+_j]-u;for(var saved=0,_r=0;_r<_j;++_r){var rv=right[_r+1],lv=_i2[_j-_r];_i[_j][_r]=rv+lv;var temp=_i[_r][_j-1]/_i[_j][_r];_i[_r][_j]=saved+rv*temp;saved=lv*temp}_i[_j][_j]=saved}for(span=0;span<=p;++span)i[0][span]=_i[span][p];for(span=0;span<=p;++span){u=\n0;U=1;_i2=[];for(right=0;right<=p;++right)_i2[right]=zeroArr.slice(0);for(right=_i2[0][0]=1;right<=n;++right){_j=0;saved=span-right;_r=p-right;span>=right&&(_i2[U][0]=_i2[u][0]/_i[_r+1][saved],_j=_i2[U][0]*_i[saved][_r]);rv=span-1<=_r?right-1:p-span;for(lv=-1<=saved?1:-saved;lv<=rv;++lv)_i2[U][lv]=(_i2[u][lv]-_i2[u][lv-1])/_i[_r+1][saved+lv],_j+=_i2[U][lv]*_i[saved+lv][_r];span<=_r&&(_i2[U][right]=-_i2[u][right-1]/_i[_r+1][span],_j+=_i2[U][right]*_i[span][_r]);i[right][span]=_j;_j=u;u=U;U=_j}}zeroArr=\np;for(_i=1;_i<=n;++_i){for(span=0;span<=p;++span)i[_i][span]*=zeroArr;zeroArr*=p-_i}return i};exports.calcBasisFunctions=function(span,u,p,U){for(var N=[],left=[],right=[],j=N[0]=1;j<=p;++j){left[j]=u-U[span+1-j];right[j]=U[span+j]-u;for(var saved=0,r=0;r<j;++r){var rv=right[r+1],lv=left[j-r],temp=N[r]/(rv+lv);N[r]=saved+rv*temp;saved=lv*temp}N[j]=saved}return N};exports.calcKoverI=function(k,i){for(var nom=1,j=2;j<=k;++j)nom*=j;j=1;for(var _j5=2;_j5<=i;++_j5)j*=_j5;for(_j5=2;_j5<=k-i;++_j5)j*=_j5;\nreturn nom/j};exports.calcNURBSDerivatives=function(p,U,P,u,nd){p=this.calcBSplineDerivatives(p,U,P,u,nd);return this.calcRationalCurveDerivatives(p)};exports.calcRationalCurveDerivatives=function(Pders){for(var nd=Pders.length,Aders=[],wders=[],i=0;i<nd;++i){var point=Pders[i];Aders[i]=new _three.Vector3(point.x,point.y,point.z);wders[i]=point.w}Pders=[];for(i=0;i<nd;++i){point=Aders[i].clone();for(var _i4=1;_i4<=i;++_i4)point.sub(Pders[i-_i4].clone().multiplyScalar(this.calcKoverI(i,_i4)*wders[_i4]));\nPders[i]=point.divideScalar(wders[0])}return Pders};exports.calcSurfacePoint=function(p,q,U,V,P,u,v,target){var uspan=this.findSpan(p,u,U),vspan=this.findSpan(q,v,V);U=this.calcBasisFunctions(uspan,u,p,U);V=this.calcBasisFunctions(vspan,v,q,V);v=[];for(u=0;u<=q;++u){v[u]=new _three.Vector4(0,0,0,0);for(var k=0;k<=p;++k){var point=P[uspan-p+k][vspan-q+u].clone(),w=point.w;point.x*=w;point.y*=w;point.z*=w;v[u].add(point.multiplyScalar(U[k]))}}p=new _three.Vector4(0,0,0,0);for(P=0;P<=q;++P)p.add(v[P].multiplyScalar(V[P]));\np.divideScalar(p.w);target.set(p.x,p.y,p.z)};exports.findSpan=function(p,u,U){var n=U.length-p-1;if(u>=U[n])return n-1;if(u<=U[p])return p;for(var mid=Math.floor((p+n)/2);u<U[mid]||u>=U[mid+1];)u<U[mid]?n=mid:p=mid,mid=Math.floor((p+n)/2);return mid};var _three=require(\"module$node_modules$three$build$three_module\")}","~:source","shadow$provide[\"module$node_modules$three_stdlib$curves$NURBSUtils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcBSplineDerivatives = calcBSplineDerivatives;\nexports.calcBSplinePoint = calcBSplinePoint;\nexports.calcBasisFunctionDerivatives = calcBasisFunctionDerivatives;\nexports.calcBasisFunctions = calcBasisFunctions;\nexports.calcKoverI = calcKoverI;\nexports.calcNURBSDerivatives = calcNURBSDerivatives;\nexports.calcRationalCurveDerivatives = calcRationalCurveDerivatives;\nexports.calcSurfacePoint = calcSurfacePoint;\nexports.findSpan = findSpan;\n\nvar _three = require(\"three\");\n\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\n/*\n\tFinds knot vector span.\n\n\tp : degree\n\tu : parametric value\n\tU : knot vector\n\n\treturns the span\n\t*/\nfunction findSpan(p, u, U) {\n  var n = U.length - p - 1;\n\n  if (u >= U[n]) {\n    return n - 1;\n  }\n\n  if (u <= U[p]) {\n    return p;\n  }\n\n  var low = p;\n  var high = n;\n  var mid = Math.floor((low + high) / 2);\n\n  while (u < U[mid] || u >= U[mid + 1]) {\n    if (u < U[mid]) {\n      high = mid;\n    } else {\n      low = mid;\n    }\n\n    mid = Math.floor((low + high) / 2);\n  }\n\n  return mid;\n}\n/*\n\tCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tU    : knot vector\n\n\treturns array[p+1] with basis functions values.\n\t*/\n\n\nfunction calcBasisFunctions(span, u, p, U) {\n  var N = [];\n  var left = [];\n  var right = [];\n  N[0] = 1.0;\n\n  for (var j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j];\n    right[j] = U[span + j] - u;\n    var saved = 0.0;\n\n    for (var r = 0; r < j; ++r) {\n      var rv = right[r + 1];\n      var lv = left[j - r];\n      var temp = N[r] / (rv + lv);\n      N[r] = saved + rv * temp;\n      saved = lv * temp;\n    }\n\n    N[j] = saved;\n  }\n\n  return N;\n}\n/*\n\tCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\n\tp : degree of B-Spline\n\tU : knot vector\n\tP : control points (x, y, z, w)\n\tu : parametric point\n\n\treturns point for given u\n\t*/\n\n\nfunction calcBSplinePoint(p, U, P, u) {\n  var span = this.findSpan(p, u, U);\n  var N = this.calcBasisFunctions(span, u, p, U);\n  var C = new _three.Vector4(0, 0, 0, 0);\n\n  for (var j = 0; j <= p; ++j) {\n    var point = P[span - p + j];\n    var Nj = N[j];\n    var wNj = point.w * Nj;\n    C.x += point.x * wNj;\n    C.y += point.y * wNj;\n    C.z += point.z * wNj;\n    C.w += point.w * Nj;\n  }\n\n  return C;\n}\n/*\n\tCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\n\tspan : span in which u lies\n\tu    : parametric point\n\tp    : degree\n\tn    : number of derivatives to calculate\n\tU    : knot vector\n\n\treturns array[n+1][p+1] with basis functions derivatives\n\t*/\n\n\nfunction calcBasisFunctionDerivatives(span, u, p, n, U) {\n  var zeroArr = [];\n\n  for (var i = 0; i <= p; ++i) {\n    zeroArr[i] = 0.0;\n  }\n\n  var ders = [];\n\n  for (var _i = 0; _i <= n; ++_i) {\n    ders[_i] = zeroArr.slice(0);\n  }\n\n  var ndu = [];\n\n  for (var _i2 = 0; _i2 <= p; ++_i2) {\n    ndu[_i2] = zeroArr.slice(0);\n  }\n\n  ndu[0][0] = 1.0;\n  var left = zeroArr.slice(0);\n  var right = zeroArr.slice(0);\n\n  for (var _j = 1; _j <= p; ++_j) {\n    left[_j] = u - U[span + 1 - _j];\n    right[_j] = U[span + _j] - u;\n    var saved = 0.0;\n\n    for (var _r = 0; _r < _j; ++_r) {\n      var rv = right[_r + 1];\n      var lv = left[_j - _r];\n      ndu[_j][_r] = rv + lv;\n      var temp = ndu[_r][_j - 1] / ndu[_j][_r];\n      ndu[_r][_j] = saved + rv * temp;\n      saved = lv * temp;\n    }\n\n    ndu[_j][_j] = saved;\n  }\n\n  for (var _j2 = 0; _j2 <= p; ++_j2) {\n    ders[0][_j2] = ndu[_j2][p];\n  }\n\n  for (var _r2 = 0; _r2 <= p; ++_r2) {\n    var s1 = 0;\n    var s2 = 1;\n    var a = [];\n\n    for (var _i3 = 0; _i3 <= p; ++_i3) {\n      a[_i3] = zeroArr.slice(0);\n    }\n\n    a[0][0] = 1.0;\n\n    for (var k = 1; k <= n; ++k) {\n      var d = 0.0;\n      var rk = _r2 - k;\n      var pk = p - k;\n\n      if (_r2 >= k) {\n        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\n        d = a[s2][0] * ndu[rk][pk];\n      }\n\n      var j1 = rk >= -1 ? 1 : -rk;\n      var j2 = _r2 - 1 <= pk ? k - 1 : p - _r2;\n\n      for (var _j3 = j1; _j3 <= j2; ++_j3) {\n        a[s2][_j3] = (a[s1][_j3] - a[s1][_j3 - 1]) / ndu[pk + 1][rk + _j3];\n        d += a[s2][_j3] * ndu[rk + _j3][pk];\n      }\n\n      if (_r2 <= pk) {\n        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][_r2];\n        d += a[s2][k] * ndu[_r2][pk];\n      }\n\n      ders[k][_r2] = d;\n      var j = s1;\n      s1 = s2;\n      s2 = j;\n    }\n  }\n\n  var r = p;\n\n  for (var _k = 1; _k <= n; ++_k) {\n    for (var _j4 = 0; _j4 <= p; ++_j4) {\n      ders[_k][_j4] *= r;\n    }\n\n    r *= p - _k;\n  }\n\n  return ders;\n}\n/*\n\t\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\t\tp  : degree\n\t\tU  : knot vector\n\t\tP  : control points\n\t\tu  : Parametric points\n\t\tnd : number of derivatives\n\n\t\treturns array[d+1] with derivatives\n\t\t*/\n\n\nfunction calcBSplineDerivatives(p, U, P, u, nd) {\n  var du = nd < p ? nd : p;\n  var CK = [];\n  var span = this.findSpan(p, u, U);\n  var nders = this.calcBasisFunctionDerivatives(span, u, p, du, U);\n  var Pw = [];\n\n  for (var i = 0; i < P.length; ++i) {\n    var point = P[i].clone();\n    var w = point.w;\n    point.x *= w;\n    point.y *= w;\n    point.z *= w;\n    Pw[i] = point;\n  }\n\n  for (var k = 0; k <= du; ++k) {\n    var point = Pw[span - p].clone().multiplyScalar(nders[k][0]);\n\n    for (var j = 1; j <= p; ++j) {\n      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));\n    }\n\n    CK[k] = point;\n  }\n\n  for (var _k2 = du + 1; _k2 <= nd + 1; ++_k2) {\n    CK[_k2] = new _three.Vector4(0, 0, 0);\n  }\n\n  return CK;\n}\n/*\n\tCalculate \"K over I\"\n\n\treturns k!/(i!(k-i)!)\n\t*/\n\n\nfunction calcKoverI(k, i) {\n  var nom = 1;\n\n  for (var j = 2; j <= k; ++j) {\n    nom *= j;\n  }\n\n  var denom = 1;\n\n  for (var _j5 = 2; _j5 <= i; ++_j5) {\n    denom *= _j5;\n  }\n\n  for (var _j6 = 2; _j6 <= k - i; ++_j6) {\n    denom *= _j6;\n  }\n\n  return nom / denom;\n}\n/*\n\tCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\n\tPders : result of function calcBSplineDerivatives\n\n\treturns array with derivatives for rational curve.\n\t*/\n\n\nfunction calcRationalCurveDerivatives(Pders) {\n  var nd = Pders.length;\n  var Aders = [];\n  var wders = [];\n\n  for (var i = 0; i < nd; ++i) {\n    var point = Pders[i];\n    Aders[i] = new _three.Vector3(point.x, point.y, point.z);\n    wders[i] = point.w;\n  }\n\n  var CK = [];\n\n  for (var k = 0; k < nd; ++k) {\n    var v = Aders[k].clone();\n\n    for (var _i4 = 1; _i4 <= k; ++_i4) {\n      v.sub(CK[k - _i4].clone().multiplyScalar(this.calcKoverI(k, _i4) * wders[_i4]));\n    }\n\n    CK[k] = v.divideScalar(wders[0]);\n  }\n\n  return CK;\n}\n/*\n\tCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\n\tp  : degree\n\tU  : knot vector\n\tP  : control points in homogeneous space\n\tu  : parametric points\n\tnd : number of derivatives\n\n\treturns array with derivatives.\n\t*/\n\n\nfunction calcNURBSDerivatives(p, U, P, u, nd) {\n  var Pders = this.calcBSplineDerivatives(p, U, P, u, nd);\n  return this.calcRationalCurveDerivatives(Pders);\n}\n/*\n\tCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\n\tp1, p2 : degrees of B-Spline surface\n\tU1, U2 : knot vectors\n\tP      : control points (x, y, z, w)\n\tu, v   : parametric values\n\n\treturns point for given (u, v)\n\t*/\n\n\nfunction calcSurfacePoint(p, q, U, V, P, u, v, target) {\n  var uspan = this.findSpan(p, u, U);\n  var vspan = this.findSpan(q, v, V);\n  var Nu = this.calcBasisFunctions(uspan, u, p, U);\n  var Nv = this.calcBasisFunctions(vspan, v, q, V);\n  var temp = [];\n\n  for (var l = 0; l <= q; ++l) {\n    temp[l] = new _three.Vector4(0, 0, 0, 0);\n\n    for (var k = 0; k <= p; ++k) {\n      var point = P[uspan - p + k][vspan - q + l].clone();\n      var w = point.w;\n      point.x *= w;\n      point.y *= w;\n      point.z *= w;\n      temp[l].add(point.multiplyScalar(Nu[k]));\n    }\n  }\n\n  var Sw = new _three.Vector4(0, 0, 0, 0);\n\n  for (var _l = 0; _l <= q; ++_l) {\n    Sw.add(temp[_l].multiplyScalar(Nv[_l]));\n  }\n\n  Sw.divideScalar(Sw.w);\n  target.set(Sw.x, Sw.y, Sw.z);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["calcBasisFunctions","z","w","calcBSplineDerivatives","calcBSplinePoint","x","__esModule","calcBasisFunctionDerivatives","findSpan","calcSurfacePoint","value","calcNURBSDerivatives","y","calcRationalCurveDerivatives","calcKoverI"]],"~:compiled-at",1630917515543,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$curves$NURBSUtils.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/curves/NURBSUtils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$curves$NURBSUtils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.calcBSplineDerivatives = calcBSplineDerivatives;\\nexports.calcBSplinePoint = calcBSplinePoint;\\nexports.calcBasisFunctionDerivatives = calcBasisFunctionDerivatives;\\nexports.calcBasisFunctions = calcBasisFunctions;\\nexports.calcKoverI = calcKoverI;\\nexports.calcNURBSDerivatives = calcNURBSDerivatives;\\nexports.calcRationalCurveDerivatives = calcRationalCurveDerivatives;\\nexports.calcSurfacePoint = calcSurfacePoint;\\nexports.findSpan = findSpan;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * NURBS utils\\n *\\n * See NURBSCurve and NURBSSurface.\\n **/\\n\\n/**************************************************************\\n *\\tNURBS Utils\\n **************************************************************/\\n\\n/*\\n\\tFinds knot vector span.\\n\\n\\tp : degree\\n\\tu : parametric value\\n\\tU : knot vector\\n\\n\\treturns the span\\n\\t*/\\nfunction findSpan(p, u, U) {\\n  var n = U.length - p - 1;\\n\\n  if (u >= U[n]) {\\n    return n - 1;\\n  }\\n\\n  if (u <= U[p]) {\\n    return p;\\n  }\\n\\n  var low = p;\\n  var high = n;\\n  var mid = Math.floor((low + high) / 2);\\n\\n  while (u < U[mid] || u >= U[mid + 1]) {\\n    if (u < U[mid]) {\\n      high = mid;\\n    } else {\\n      low = mid;\\n    }\\n\\n    mid = Math.floor((low + high) / 2);\\n  }\\n\\n  return mid;\\n}\\n/*\\n\\tCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\\n\\n\\tspan : span in which u lies\\n\\tu    : parametric point\\n\\tp    : degree\\n\\tU    : knot vector\\n\\n\\treturns array[p+1] with basis functions values.\\n\\t*/\\n\\n\\nfunction calcBasisFunctions(span, u, p, U) {\\n  var N = [];\\n  var left = [];\\n  var right = [];\\n  N[0] = 1.0;\\n\\n  for (var j = 1; j <= p; ++j) {\\n    left[j] = u - U[span + 1 - j];\\n    right[j] = U[span + j] - u;\\n    var saved = 0.0;\\n\\n    for (var r = 0; r < j; ++r) {\\n      var rv = right[r + 1];\\n      var lv = left[j - r];\\n      var temp = N[r] / (rv + lv);\\n      N[r] = saved + rv * temp;\\n      saved = lv * temp;\\n    }\\n\\n    N[j] = saved;\\n  }\\n\\n  return N;\\n}\\n/*\\n\\tCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\\n\\n\\tp : degree of B-Spline\\n\\tU : knot vector\\n\\tP : control points (x, y, z, w)\\n\\tu : parametric point\\n\\n\\treturns point for given u\\n\\t*/\\n\\n\\nfunction calcBSplinePoint(p, U, P, u) {\\n  var span = this.findSpan(p, u, U);\\n  var N = this.calcBasisFunctions(span, u, p, U);\\n  var C = new _three.Vector4(0, 0, 0, 0);\\n\\n  for (var j = 0; j <= p; ++j) {\\n    var point = P[span - p + j];\\n    var Nj = N[j];\\n    var wNj = point.w * Nj;\\n    C.x += point.x * wNj;\\n    C.y += point.y * wNj;\\n    C.z += point.z * wNj;\\n    C.w += point.w * Nj;\\n  }\\n\\n  return C;\\n}\\n/*\\n\\tCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\\n\\n\\tspan : span in which u lies\\n\\tu    : parametric point\\n\\tp    : degree\\n\\tn    : number of derivatives to calculate\\n\\tU    : knot vector\\n\\n\\treturns array[n+1][p+1] with basis functions derivatives\\n\\t*/\\n\\n\\nfunction calcBasisFunctionDerivatives(span, u, p, n, U) {\\n  var zeroArr = [];\\n\\n  for (var i = 0; i <= p; ++i) {\\n    zeroArr[i] = 0.0;\\n  }\\n\\n  var ders = [];\\n\\n  for (var _i = 0; _i <= n; ++_i) {\\n    ders[_i] = zeroArr.slice(0);\\n  }\\n\\n  var ndu = [];\\n\\n  for (var _i2 = 0; _i2 <= p; ++_i2) {\\n    ndu[_i2] = zeroArr.slice(0);\\n  }\\n\\n  ndu[0][0] = 1.0;\\n  var left = zeroArr.slice(0);\\n  var right = zeroArr.slice(0);\\n\\n  for (var _j = 1; _j <= p; ++_j) {\\n    left[_j] = u - U[span + 1 - _j];\\n    right[_j] = U[span + _j] - u;\\n    var saved = 0.0;\\n\\n    for (var _r = 0; _r < _j; ++_r) {\\n      var rv = right[_r + 1];\\n      var lv = left[_j - _r];\\n      ndu[_j][_r] = rv + lv;\\n      var temp = ndu[_r][_j - 1] / ndu[_j][_r];\\n      ndu[_r][_j] = saved + rv * temp;\\n      saved = lv * temp;\\n    }\\n\\n    ndu[_j][_j] = saved;\\n  }\\n\\n  for (var _j2 = 0; _j2 <= p; ++_j2) {\\n    ders[0][_j2] = ndu[_j2][p];\\n  }\\n\\n  for (var _r2 = 0; _r2 <= p; ++_r2) {\\n    var s1 = 0;\\n    var s2 = 1;\\n    var a = [];\\n\\n    for (var _i3 = 0; _i3 <= p; ++_i3) {\\n      a[_i3] = zeroArr.slice(0);\\n    }\\n\\n    a[0][0] = 1.0;\\n\\n    for (var k = 1; k <= n; ++k) {\\n      var d = 0.0;\\n      var rk = _r2 - k;\\n      var pk = p - k;\\n\\n      if (_r2 >= k) {\\n        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\\n        d = a[s2][0] * ndu[rk][pk];\\n      }\\n\\n      var j1 = rk >= -1 ? 1 : -rk;\\n      var j2 = _r2 - 1 <= pk ? k - 1 : p - _r2;\\n\\n      for (var _j3 = j1; _j3 <= j2; ++_j3) {\\n        a[s2][_j3] = (a[s1][_j3] - a[s1][_j3 - 1]) / ndu[pk + 1][rk + _j3];\\n        d += a[s2][_j3] * ndu[rk + _j3][pk];\\n      }\\n\\n      if (_r2 <= pk) {\\n        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][_r2];\\n        d += a[s2][k] * ndu[_r2][pk];\\n      }\\n\\n      ders[k][_r2] = d;\\n      var j = s1;\\n      s1 = s2;\\n      s2 = j;\\n    }\\n  }\\n\\n  var r = p;\\n\\n  for (var _k = 1; _k <= n; ++_k) {\\n    for (var _j4 = 0; _j4 <= p; ++_j4) {\\n      ders[_k][_j4] *= r;\\n    }\\n\\n    r *= p - _k;\\n  }\\n\\n  return ders;\\n}\\n/*\\n\\t\\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\\n\\n\\t\\tp  : degree\\n\\t\\tU  : knot vector\\n\\t\\tP  : control points\\n\\t\\tu  : Parametric points\\n\\t\\tnd : number of derivatives\\n\\n\\t\\treturns array[d+1] with derivatives\\n\\t\\t*/\\n\\n\\nfunction calcBSplineDerivatives(p, U, P, u, nd) {\\n  var du = nd < p ? nd : p;\\n  var CK = [];\\n  var span = this.findSpan(p, u, U);\\n  var nders = this.calcBasisFunctionDerivatives(span, u, p, du, U);\\n  var Pw = [];\\n\\n  for (var i = 0; i < P.length; ++i) {\\n    var point = P[i].clone();\\n    var w = point.w;\\n    point.x *= w;\\n    point.y *= w;\\n    point.z *= w;\\n    Pw[i] = point;\\n  }\\n\\n  for (var k = 0; k <= du; ++k) {\\n    var point = Pw[span - p].clone().multiplyScalar(nders[k][0]);\\n\\n    for (var j = 1; j <= p; ++j) {\\n      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));\\n    }\\n\\n    CK[k] = point;\\n  }\\n\\n  for (var _k2 = du + 1; _k2 <= nd + 1; ++_k2) {\\n    CK[_k2] = new _three.Vector4(0, 0, 0);\\n  }\\n\\n  return CK;\\n}\\n/*\\n\\tCalculate \\\"K over I\\\"\\n\\n\\treturns k!/(i!(k-i)!)\\n\\t*/\\n\\n\\nfunction calcKoverI(k, i) {\\n  var nom = 1;\\n\\n  for (var j = 2; j <= k; ++j) {\\n    nom *= j;\\n  }\\n\\n  var denom = 1;\\n\\n  for (var _j5 = 2; _j5 <= i; ++_j5) {\\n    denom *= _j5;\\n  }\\n\\n  for (var _j6 = 2; _j6 <= k - i; ++_j6) {\\n    denom *= _j6;\\n  }\\n\\n  return nom / denom;\\n}\\n/*\\n\\tCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\\n\\n\\tPders : result of function calcBSplineDerivatives\\n\\n\\treturns array with derivatives for rational curve.\\n\\t*/\\n\\n\\nfunction calcRationalCurveDerivatives(Pders) {\\n  var nd = Pders.length;\\n  var Aders = [];\\n  var wders = [];\\n\\n  for (var i = 0; i < nd; ++i) {\\n    var point = Pders[i];\\n    Aders[i] = new _three.Vector3(point.x, point.y, point.z);\\n    wders[i] = point.w;\\n  }\\n\\n  var CK = [];\\n\\n  for (var k = 0; k < nd; ++k) {\\n    var v = Aders[k].clone();\\n\\n    for (var _i4 = 1; _i4 <= k; ++_i4) {\\n      v.sub(CK[k - _i4].clone().multiplyScalar(this.calcKoverI(k, _i4) * wders[_i4]));\\n    }\\n\\n    CK[k] = v.divideScalar(wders[0]);\\n  }\\n\\n  return CK;\\n}\\n/*\\n\\tCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\\n\\n\\tp  : degree\\n\\tU  : knot vector\\n\\tP  : control points in homogeneous space\\n\\tu  : parametric points\\n\\tnd : number of derivatives\\n\\n\\treturns array with derivatives.\\n\\t*/\\n\\n\\nfunction calcNURBSDerivatives(p, U, P, u, nd) {\\n  var Pders = this.calcBSplineDerivatives(p, U, P, u, nd);\\n  return this.calcRationalCurveDerivatives(Pders);\\n}\\n/*\\n\\tCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\\n\\n\\tp1, p2 : degrees of B-Spline surface\\n\\tU1, U2 : knot vectors\\n\\tP      : control points (x, y, z, w)\\n\\tu, v   : parametric values\\n\\n\\treturns point for given (u, v)\\n\\t*/\\n\\n\\nfunction calcSurfacePoint(p, q, U, V, P, u, v, target) {\\n  var uspan = this.findSpan(p, u, U);\\n  var vspan = this.findSpan(q, v, V);\\n  var Nu = this.calcBasisFunctions(uspan, u, p, U);\\n  var Nv = this.calcBasisFunctions(vspan, v, q, V);\\n  var temp = [];\\n\\n  for (var l = 0; l <= q; ++l) {\\n    temp[l] = new _three.Vector4(0, 0, 0, 0);\\n\\n    for (var k = 0; k <= p; ++k) {\\n      var point = P[uspan - p + k][vspan - q + l].clone();\\n      var w = point.w;\\n      point.x *= w;\\n      point.y *= w;\\n      point.z *= w;\\n      temp[l].add(point.multiplyScalar(Nu[k]));\\n    }\\n  }\\n\\n  var Sw = new _three.Vector4(0, 0, 0, 0);\\n\\n  for (var _l = 0; _l <= q; ++_l) {\\n    Sw.add(temp[_l].multiplyScalar(Nv[_l]));\\n  }\\n\\n  Sw.divideScalar(Sw.w);\\n  target.set(Sw.x, Sw.y, Sw.z);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"calcBSplineDerivatives\",\"p\",\"U\",\"P\",\"u\",\"nd\",\"du\",\"CK\",\"span\",\"findSpan\",\"nders\",\"calcBasisFunctionDerivatives\",\"Pw\",\"i\",\"length\",\"point\",\"clone\",\"w\",\"x\",\"y\",\"z\",\"k\",\"multiplyScalar\",\"j\",\"add\",\"_k2\",\"_three\",\"Vector4\",\"calcBSplinePoint\",\"N\",\"calcBasisFunctions\",\"C\",\"Nj\",\"wNj\",\"n\",\"zeroArr\",\"ders\",\"_i\",\"slice\",\"ndu\",\"_i2\",\"left\",\"right\",\"_j\",\"saved\",\"_r\",\"rv\",\"lv\",\"temp\",\"_j2\",\"_r2\",\"s1\",\"s2\",\"a\",\"_i3\",\"d\",\"rk\",\"pk\",\"j2\",\"_j3\",\"j1\",\"r\",\"_k\",\"_j4\",\"calcKoverI\",\"nom\",\"denom\",\"_j5\",\"_j6\",\"calcNURBSDerivatives\",\"Pders\",\"calcRationalCurveDerivatives\",\"Aders\",\"wders\",\"Vector3\",\"v\",\"_i4\",\"sub\",\"divideScalar\",\"calcSurfacePoint\",\"q\",\"V\",\"target\",\"uspan\",\"vspan\",\"Nu\",\"Nv\",\"l\",\"Sw\",\"_l\",\"set\",\"mid\",\"Math\",\"floor\",\"low\",\"high\"]\n}\n"]