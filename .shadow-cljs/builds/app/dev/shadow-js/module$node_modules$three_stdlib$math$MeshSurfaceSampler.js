["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/math/MeshSurfaceSampler.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$math$MeshSurfaceSampler=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.MeshSurfaceSampler=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(){function MeshSurfaceSampler(mesh){mesh=mesh.geometry;if(!mesh.isBufferGeometry||3!==mesh.attributes.position.itemSize)throw Error(\"THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.\");mesh.index&&(console.warn(\"THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.\"),\nmesh=mesh.toNonIndexed());this.geometry=mesh;this.randomFunction=Math.random;this.positionAttribute=this.geometry.getAttribute(\"position\");this.colorAttribute=this.geometry.getAttribute(\"color\");this.distribution=this.weightAttribute=null}var _face=new _three.Triangle,_color=new _three.Vector3;MeshSurfaceSampler.prototype={constructor:MeshSurfaceSampler,setWeightAttribute:function(name){this.weightAttribute=name?this.geometry.getAttribute(name):null;return this},build:function(){for(var positionAttribute=\nthis.positionAttribute,weightAttribute=this.weightAttribute,faceWeights=new Float32Array(positionAttribute.count/3),i=0;i<positionAttribute.count;i+=3){var faceWeight=1;weightAttribute&&(faceWeight=weightAttribute.getX(i)+weightAttribute.getX(i+1)+weightAttribute.getX(i+2));_face.a.fromBufferAttribute(positionAttribute,i);_face.b.fromBufferAttribute(positionAttribute,i+1);_face.c.fromBufferAttribute(positionAttribute,i+2);faceWeight*=_face.getArea();faceWeights[i/3]=faceWeight}this.distribution=new Float32Array(positionAttribute.count/\n3);for(weightAttribute=positionAttribute=0;weightAttribute<faceWeights.length;weightAttribute++)positionAttribute+=faceWeights[weightAttribute],this.distribution[weightAttribute]=positionAttribute;return this},setRandomGenerator:function(randomFunction){this.randomFunction=randomFunction;return this},sample:function(targetPosition,targetNormal,targetColor){var cumulativeTotal=this.distribution[this.distribution.length-1];cumulativeTotal=this.binarySearch(this.randomFunction()*cumulativeTotal);return this.sampleFace(cumulativeTotal,\ntargetPosition,targetNormal,targetColor)},binarySearch:function(x){for(var dist=this.distribution,start=0,end=dist.length-1,index=-1;start<=end;){var mid=Math.ceil((start+end)/2);if(0===mid||dist[mid-1]<=x&&dist[mid]>x){index=mid;break}else x<dist[mid]?end=mid-1:start=mid+1}return index},sampleFace:function(faceIndex,targetPosition,targetNormal,targetColor){var u=this.randomFunction(),v=this.randomFunction();1<u+v&&(u=1-u,v=1-v);_face.a.fromBufferAttribute(this.positionAttribute,3*faceIndex);_face.b.fromBufferAttribute(this.positionAttribute,\n3*faceIndex+1);_face.c.fromBufferAttribute(this.positionAttribute,3*faceIndex+2);targetPosition.set(0,0,0).addScaledVector(_face.a,u).addScaledVector(_face.b,v).addScaledVector(_face.c,1-(u+v));void 0!==targetNormal&&_face.getNormal(targetNormal);void 0!==targetColor&&void 0!==this.colorAttribute&&(_face.a.fromBufferAttribute(this.colorAttribute,3*faceIndex),_face.b.fromBufferAttribute(this.colorAttribute,3*faceIndex+1),_face.c.fromBufferAttribute(this.colorAttribute,3*faceIndex+2),_color.set(0,0,\n0).addScaledVector(_face.a,u).addScaledVector(_face.b,v).addScaledVector(_face.c,1-(u+v)),targetColor.r=_color.x,targetColor.g=_color.y,targetColor.b=_color.z);return this}};return MeshSurfaceSampler}();exports.MeshSurfaceSampler=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$math$MeshSurfaceSampler\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MeshSurfaceSampler = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\nvar MeshSurfaceSampler = function () {\n  var _face = new _three.Triangle();\n\n  var _color = new _three.Vector3();\n\n  function MeshSurfaceSampler(mesh) {\n    var geometry = mesh.geometry;\n\n    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\n      throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\n    }\n\n    if (geometry.index) {\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\n      geometry = geometry.toNonIndexed();\n    }\n\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute('position');\n    this.colorAttribute = this.geometry.getAttribute('color');\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n\n  MeshSurfaceSampler.prototype = {\n    constructor: MeshSurfaceSampler,\n    setWeightAttribute: function setWeightAttribute(name) {\n      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n      return this;\n    },\n    build: function build() {\n      var positionAttribute = this.positionAttribute;\n      var weightAttribute = this.weightAttribute;\n      var faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.\n\n      for (var i = 0; i < positionAttribute.count; i += 3) {\n        var faceWeight = 1;\n\n        if (weightAttribute) {\n          faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n        }\n\n        _face.a.fromBufferAttribute(positionAttribute, i);\n\n        _face.b.fromBufferAttribute(positionAttribute, i + 1);\n\n        _face.c.fromBufferAttribute(positionAttribute, i + 2);\n\n        faceWeight *= _face.getArea();\n        faceWeights[i / 3] = faceWeight;\n      } // Store cumulative total face weights in an array, where weight index\n      // corresponds to face index.\n\n\n      this.distribution = new Float32Array(positionAttribute.count / 3);\n      var cumulativeTotal = 0;\n\n      for (var _i = 0; _i < faceWeights.length; _i++) {\n        cumulativeTotal += faceWeights[_i];\n        this.distribution[_i] = cumulativeTotal;\n      }\n\n      return this;\n    },\n    setRandomGenerator: function setRandomGenerator(randomFunction) {\n      this.randomFunction = randomFunction;\n      return this;\n    },\n    sample: function sample(targetPosition, targetNormal, targetColor) {\n      var cumulativeTotal = this.distribution[this.distribution.length - 1];\n      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);\n      return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n    },\n    binarySearch: function binarySearch(x) {\n      var dist = this.distribution;\n      var start = 0;\n      var end = dist.length - 1;\n      var index = -1;\n\n      while (start <= end) {\n        var mid = Math.ceil((start + end) / 2);\n\n        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n          index = mid;\n          break;\n        } else if (x < dist[mid]) {\n          end = mid - 1;\n        } else {\n          start = mid + 1;\n        }\n      }\n\n      return index;\n    },\n    sampleFace: function sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n      var u = this.randomFunction();\n      var v = this.randomFunction();\n\n      if (u + v > 1) {\n        u = 1 - u;\n        v = 1 - v;\n      }\n\n      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n\n      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n\n      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n\n      targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n      if (targetNormal !== undefined) {\n        _face.getNormal(targetNormal);\n      }\n\n      if (targetColor !== undefined && this.colorAttribute !== undefined) {\n        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n\n        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n\n        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n\n        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n        targetColor.r = _color.x;\n        targetColor.g = _color.y;\n        targetColor.b = _color.z;\n      }\n\n      return this;\n    }\n  };\n  return MeshSurfaceSampler;\n}();\n\nexports.MeshSurfaceSampler = MeshSurfaceSampler;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["sampleFace","setRandomGenerator","colorAttribute","setWeightAttribute","prototype","distribution","weightAttribute","randomFunction","__esModule","MeshSurfaceSampler","binarySearch","value","geometry","build","positionAttribute","b","r","g","sample","constructor"]],"~:compiled-at",1630917515414,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$math$MeshSurfaceSampler.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/math/MeshSurfaceSampler.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$math$MeshSurfaceSampler\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.MeshSurfaceSampler = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Utility class for sampling weighted random points on the surface of a mesh.\\n *\\n * Building the sampler is a one-time O(n) operation. Once built, any number of\\n * random samples may be selected in O(logn) time. Memory usage is O(n).\\n *\\n * References:\\n * - http://www.joesfer.com/?p=84\\n * - https://stackoverflow.com/a/4322940/1314762\\n */\\nvar MeshSurfaceSampler = function () {\\n  var _face = new _three.Triangle();\\n\\n  var _color = new _three.Vector3();\\n\\n  function MeshSurfaceSampler(mesh) {\\n    var geometry = mesh.geometry;\\n\\n    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\\n      throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\\n    }\\n\\n    if (geometry.index) {\\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\\n      geometry = geometry.toNonIndexed();\\n    }\\n\\n    this.geometry = geometry;\\n    this.randomFunction = Math.random;\\n    this.positionAttribute = this.geometry.getAttribute('position');\\n    this.colorAttribute = this.geometry.getAttribute('color');\\n    this.weightAttribute = null;\\n    this.distribution = null;\\n  }\\n\\n  MeshSurfaceSampler.prototype = {\\n    constructor: MeshSurfaceSampler,\\n    setWeightAttribute: function setWeightAttribute(name) {\\n      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\\n      return this;\\n    },\\n    build: function build() {\\n      var positionAttribute = this.positionAttribute;\\n      var weightAttribute = this.weightAttribute;\\n      var faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.\\n\\n      for (var i = 0; i < positionAttribute.count; i += 3) {\\n        var faceWeight = 1;\\n\\n        if (weightAttribute) {\\n          faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\\n        }\\n\\n        _face.a.fromBufferAttribute(positionAttribute, i);\\n\\n        _face.b.fromBufferAttribute(positionAttribute, i + 1);\\n\\n        _face.c.fromBufferAttribute(positionAttribute, i + 2);\\n\\n        faceWeight *= _face.getArea();\\n        faceWeights[i / 3] = faceWeight;\\n      } // Store cumulative total face weights in an array, where weight index\\n      // corresponds to face index.\\n\\n\\n      this.distribution = new Float32Array(positionAttribute.count / 3);\\n      var cumulativeTotal = 0;\\n\\n      for (var _i = 0; _i < faceWeights.length; _i++) {\\n        cumulativeTotal += faceWeights[_i];\\n        this.distribution[_i] = cumulativeTotal;\\n      }\\n\\n      return this;\\n    },\\n    setRandomGenerator: function setRandomGenerator(randomFunction) {\\n      this.randomFunction = randomFunction;\\n      return this;\\n    },\\n    sample: function sample(targetPosition, targetNormal, targetColor) {\\n      var cumulativeTotal = this.distribution[this.distribution.length - 1];\\n      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);\\n      return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\\n    },\\n    binarySearch: function binarySearch(x) {\\n      var dist = this.distribution;\\n      var start = 0;\\n      var end = dist.length - 1;\\n      var index = -1;\\n\\n      while (start <= end) {\\n        var mid = Math.ceil((start + end) / 2);\\n\\n        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\\n          index = mid;\\n          break;\\n        } else if (x < dist[mid]) {\\n          end = mid - 1;\\n        } else {\\n          start = mid + 1;\\n        }\\n      }\\n\\n      return index;\\n    },\\n    sampleFace: function sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\\n      var u = this.randomFunction();\\n      var v = this.randomFunction();\\n\\n      if (u + v > 1) {\\n        u = 1 - u;\\n        v = 1 - v;\\n      }\\n\\n      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\\n\\n      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\\n\\n      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\\n\\n      targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\\n\\n      if (targetNormal !== undefined) {\\n        _face.getNormal(targetNormal);\\n      }\\n\\n      if (targetColor !== undefined && this.colorAttribute !== undefined) {\\n        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\\n\\n        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\\n\\n        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\\n\\n        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\\n\\n        targetColor.r = _color.x;\\n        targetColor.g = _color.y;\\n        targetColor.b = _color.z;\\n      }\\n\\n      return this;\\n    }\\n  };\\n  return MeshSurfaceSampler;\\n}();\\n\\nexports.MeshSurfaceSampler = MeshSurfaceSampler;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"MeshSurfaceSampler\",\"_three\",\"mesh\",\"geometry\",\"isBufferGeometry\",\"attributes\",\"position\",\"itemSize\",\"Error\",\"index\",\"console\",\"warn\",\"toNonIndexed\",\"randomFunction\",\"Math\",\"random\",\"positionAttribute\",\"getAttribute\",\"colorAttribute\",\"distribution\",\"weightAttribute\",\"_face\",\"Triangle\",\"_color\",\"Vector3\",\"prototype\",\"constructor\",\"setWeightAttribute\",\"name\",\"build\",\"faceWeights\",\"Float32Array\",\"count\",\"i\",\"faceWeight\",\"getX\",\"a\",\"fromBufferAttribute\",\"b\",\"c\",\"getArea\",\"_i\",\"cumulativeTotal\",\"length\",\"setRandomGenerator\",\"sample\",\"targetPosition\",\"targetNormal\",\"targetColor\",\"faceIndex\",\"binarySearch\",\"sampleFace\",\"x\",\"dist\",\"start\",\"end\",\"mid\",\"ceil\",\"u\",\"v\",\"set\",\"addScaledVector\",\"undefined\",\"getNormal\",\"r\",\"g\",\"y\",\"z\"]\n}\n"]