["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/postprocessing/UnrealBloomPass.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$postprocessing$UnrealBloomPass=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.UnrealBloomPass=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_Pass=require(\"module$node_modules$three_stdlib$postprocessing$Pass\"),_CopyShader=require(\"module$node_modules$three_stdlib$shaders$CopyShader\"),_LuminosityHighPassShader=require(\"module$node_modules$three_stdlib$shaders$LuminosityHighPassShader\"),\nUnrealBloomPass=function(resolution,strength,radius,threshold){this.strength=void 0!==strength?strength:1;this.radius=radius;this.threshold=threshold;this.resolution=void 0!==resolution?new _three.Vector2(resolution.x,resolution.y):new _three.Vector2(256,256);this.clearColor=new _three.Color(0,0,0);var pars={minFilter:_three.LinearFilter,magFilter:_three.LinearFilter,format:_three.RGBAFormat};this.renderTargetsHorizontal=[];this.renderTargetsVertical=[];this.nMips=5;resolution=Math.round(this.resolution.x/\n2);radius=Math.round(this.resolution.y/2);this.renderTargetBright=new _three.WebGLRenderTarget(resolution,radius,pars);this.renderTargetBright.texture.name=\"UnrealBloomPass.bright\";this.renderTargetBright.texture.generateMipmaps=!1;for(var i=0;i<this.nMips;i++){var renderTargetHorizonal=new _three.WebGLRenderTarget(resolution,radius,pars);renderTargetHorizonal.texture.name=\"UnrealBloomPass.h\"+i;renderTargetHorizonal.texture.generateMipmaps=!1;this.renderTargetsHorizontal.push(renderTargetHorizonal);\nrenderTargetHorizonal=new _three.WebGLRenderTarget(resolution,radius,pars);renderTargetHorizonal.texture.name=\"UnrealBloomPass.v\"+i;renderTargetHorizonal.texture.generateMipmaps=!1;this.renderTargetsVertical.push(renderTargetHorizonal);resolution=Math.round(resolution/2);radius=Math.round(radius/2)}void 0===_LuminosityHighPassShader.LuminosityHighPassShader&&console.error(\"THREE.UnrealBloomPass relies on LuminosityHighPassShader\");resolution=_LuminosityHighPassShader.LuminosityHighPassShader;this.highPassUniforms=\n_three.UniformsUtils.clone(resolution.uniforms);this.highPassUniforms.luminosityThreshold.value=threshold;this.highPassUniforms.smoothWidth.value=.01;this.materialHighPassFilter=new _three.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:resolution.vertexShader,fragmentShader:resolution.fragmentShader,defines:{}});this.separableBlurMaterials=[];threshold=[3,5,7,9,11];resolution=Math.round(this.resolution.x/2);radius=Math.round(this.resolution.y/2);for(pars=0;pars<this.nMips;pars++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(threshold[pars])),\nthis.separableBlurMaterials[pars].uniforms.texSize.value=new _three.Vector2(resolution,radius),resolution=Math.round(resolution/2),radius=Math.round(radius/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips);this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture;this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture;this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture;this.compositeMaterial.uniforms.blurTexture4.value=\nthis.renderTargetsVertical[3].texture;this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture;this.compositeMaterial.uniforms.bloomStrength.value=strength;this.compositeMaterial.uniforms.bloomRadius.value=.1;this.compositeMaterial.needsUpdate=!0;this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2];this.bloomTintColors=[new _three.Vector3(1,1,1),new _three.Vector3(1,1,1),new _three.Vector3(1,1,1),new _three.Vector3(1,1,1),new _three.Vector3(1,1,1)];this.compositeMaterial.uniforms.bloomTintColors.value=\nthis.bloomTintColors;void 0===_CopyShader.CopyShader&&console.error(\"THREE.UnrealBloomPass relies on CopyShader\");strength=_CopyShader.CopyShader;this.copyUniforms=_three.UniformsUtils.clone(strength.uniforms);this.copyUniforms.opacity.value=1;this.materialCopy=new _three.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:strength.vertexShader,fragmentShader:strength.fragmentShader,blending:_three.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0});this.enabled=!0;this.needsSwap=!1;\nthis._oldClearColor=new _three.Color;this.oldClearAlpha=1;this.basic=new _three.MeshBasicMaterial;this.fsQuad=new _Pass.FullScreenQuad(null)};exports.UnrealBloomPass=UnrealBloomPass;UnrealBloomPass.prototype=Object.assign(Object.create(_Pass.Pass.prototype),{constructor:UnrealBloomPass,dispose:function(){for(var i=0;i<this.renderTargetsHorizontal.length;i++)this.renderTargetsHorizontal[i].dispose();for(i=0;i<this.renderTargetsVertical.length;i++)this.renderTargetsVertical[i].dispose();this.renderTargetBright.dispose()},\nsetSize:function(width,height){width=Math.round(width/2);height=Math.round(height/2);this.renderTargetBright.setSize(width,height);for(var i=0;i<this.nMips;i++)this.renderTargetsHorizontal[i].setSize(width,height),this.renderTargetsVertical[i].setSize(width,height),this.separableBlurMaterials[i].uniforms.texSize.value=new _three.Vector2(width,height),width=Math.round(width/2),height=Math.round(height/2)},render:function(renderer,writeBuffer,readBuffer,deltaTime,maskActive){renderer.getClearColor(this._oldClearColor);\nthis.oldClearAlpha=renderer.getClearAlpha();writeBuffer=renderer.autoClear;renderer.autoClear=!1;renderer.setClearColor(this.clearColor,0);maskActive&&renderer.state.buffers.stencil.setTest(!1);this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=readBuffer.texture,renderer.setRenderTarget(null),renderer.clear(),this.fsQuad.render(renderer));this.highPassUniforms.tDiffuse.value=readBuffer.texture;this.highPassUniforms.luminosityThreshold.value=this.threshold;this.fsQuad.material=this.materialHighPassFilter;\nrenderer.setRenderTarget(this.renderTargetBright);renderer.clear();this.fsQuad.render(renderer);deltaTime=this.renderTargetBright;for(var i=0;i<this.nMips;i++)this.fsQuad.material=this.separableBlurMaterials[i],this.separableBlurMaterials[i].uniforms.colorTexture.value=deltaTime.texture,this.separableBlurMaterials[i].uniforms.direction.value=UnrealBloomPass.BlurDirectionX,renderer.setRenderTarget(this.renderTargetsHorizontal[i]),renderer.clear(),this.fsQuad.render(renderer),this.separableBlurMaterials[i].uniforms.colorTexture.value=\nthis.renderTargetsHorizontal[i].texture,this.separableBlurMaterials[i].uniforms.direction.value=UnrealBloomPass.BlurDirectionY,renderer.setRenderTarget(this.renderTargetsVertical[i]),renderer.clear(),this.fsQuad.render(renderer),deltaTime=this.renderTargetsVertical[i];this.fsQuad.material=this.compositeMaterial;this.compositeMaterial.uniforms.bloomStrength.value=this.strength;this.compositeMaterial.uniforms.bloomRadius.value=this.radius;this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors;\nrenderer.setRenderTarget(this.renderTargetsHorizontal[0]);renderer.clear();this.fsQuad.render(renderer);this.fsQuad.material=this.materialCopy;this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture;maskActive&&renderer.state.buffers.stencil.setTest(!0);this.renderToScreen?renderer.setRenderTarget(null):renderer.setRenderTarget(readBuffer);this.fsQuad.render(renderer);renderer.setClearColor(this._oldClearColor,this.oldClearAlpha);renderer.autoClear=writeBuffer},getSeperableBlurMaterial:function(kernelRadius){return new _three.ShaderMaterial({defines:{KERNEL_RADIUS:kernelRadius,\nSIGMA:kernelRadius},uniforms:{colorTexture:{value:null},texSize:{value:new _three.Vector2(.5,.5)},direction:{value:new _three.Vector2(.5,.5)}},vertexShader:\"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv \\x3d uv;\\n\\t\\t\\t\\t\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",fragmentShader:\"#include \\x3ccommon\\x3e\\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\t\\t\\t\\tuniform vec2 direction;\\t\\t\\t\\t\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\t\\t\\t\\t}\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize \\x3d 1.0 / texSize;\\t\\t\\t\\t\\tfloat fSigma \\x3d float(SIGMA);\\t\\t\\t\\t\\tfloat weightSum \\x3d gaussianPdf(0.0, fSigma);\\t\\t\\t\\t\\tvec3 diffuseSum \\x3d texture2D( colorTexture, vUv).rgb * weightSum;\\t\\t\\t\\t\\tfor( int i \\x3d 1; i \\x3c KERNEL_RADIUS; i ++ ) {\\t\\t\\t\\t\\t\\tfloat x \\x3d float(i);\\t\\t\\t\\t\\t\\tfloat w \\x3d gaussianPdf(x, fSigma);\\t\\t\\t\\t\\t\\tvec2 uvOffset \\x3d direction * invSize * x;\\t\\t\\t\\t\\t\\tvec3 sample1 \\x3d texture2D( colorTexture, vUv + uvOffset).rgb;\\t\\t\\t\\t\\t\\tvec3 sample2 \\x3d texture2D( colorTexture, vUv - uvOffset).rgb;\\t\\t\\t\\t\\t\\tdiffuseSum +\\x3d (sample1 + sample2) * w;\\t\\t\\t\\t\\t\\tweightSum +\\x3d 2.0 * w;\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\tgl_FragColor \\x3d vec4(diffuseSum/weightSum, 1.0);\\n\\t\\t\\t\\t}\"})},\ngetCompositeMaterial:function(nMips){return new _three.ShaderMaterial({defines:{NUM_MIPS:nMips},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:\"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv \\x3d uv;\\n\\t\\t\\t\\t\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\nfragmentShader:\"varying vec2 vUv;\\t\\t\\t\\tuniform sampler2D blurTexture1;\\t\\t\\t\\tuniform sampler2D blurTexture2;\\t\\t\\t\\tuniform sampler2D blurTexture3;\\t\\t\\t\\tuniform sampler2D blurTexture4;\\t\\t\\t\\tuniform sampler2D blurTexture5;\\t\\t\\t\\tuniform sampler2D dirtTexture;\\t\\t\\t\\tuniform float bloomStrength;\\t\\t\\t\\tuniform float bloomRadius;\\t\\t\\t\\tuniform float bloomFactors[NUM_MIPS];\\t\\t\\t\\tuniform vec3 bloomTintColors[NUM_MIPS];\\t\\t\\t\\t\\t\\t\\t\\tfloat lerpBloomFactor(const in float factor) { \\t\\t\\t\\t\\tfloat mirrorFactor \\x3d 1.2 - factor;\\t\\t\\t\\t\\treturn mix(factor, mirrorFactor, bloomRadius);\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\tvoid main() {\\t\\t\\t\\t\\tgl_FragColor \\x3d bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\t\\t\\t\\t}\"})}});\nUnrealBloomPass.BlurDirectionX=new _three.Vector2(1,0);UnrealBloomPass.BlurDirectionY=new _three.Vector2(0,1)}","~:source","shadow$provide[\"module$node_modules$three_stdlib$postprocessing$UnrealBloomPass\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnrealBloomPass = void 0;\n\nvar _three = require(\"three\");\n\nvar _Pass = require(\"./Pass.js\");\n\nvar _CopyShader = require(\"../shaders/CopyShader.js\");\n\nvar _LuminosityHighPassShader = require(\"../shaders/LuminosityHighPassShader.js\");\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nvar UnrealBloomPass = function UnrealBloomPass(resolution, strength, radius, threshold) {\n  this.strength = strength !== undefined ? strength : 1;\n  this.radius = radius;\n  this.threshold = threshold;\n  this.resolution = resolution !== undefined ? new _three.Vector2(resolution.x, resolution.y) : new _three.Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n  this.clearColor = new _three.Color(0, 0, 0); // render targets\n\n  var pars = {\n    minFilter: _three.LinearFilter,\n    magFilter: _three.LinearFilter,\n    format: _three.RGBAFormat\n  };\n  this.renderTargetsHorizontal = [];\n  this.renderTargetsVertical = [];\n  this.nMips = 5;\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n  this.renderTargetBright = new _three.WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n  this.renderTargetBright.texture.generateMipmaps = false;\n\n  for (var i = 0; i < this.nMips; i++) {\n    var renderTargetHorizonal = new _three.WebGLRenderTarget(resx, resy, pars);\n    renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n    renderTargetHorizonal.texture.generateMipmaps = false;\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\n    var renderTargetVertical = new _three.WebGLRenderTarget(resx, resy, pars);\n    renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n    renderTargetVertical.texture.generateMipmaps = false;\n    this.renderTargetsVertical.push(renderTargetVertical);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // luminosity high pass material\n\n\n  if (_LuminosityHighPassShader.LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\n  var highPassShader = _LuminosityHighPassShader.LuminosityHighPassShader;\n  this.highPassUniforms = _three.UniformsUtils.clone(highPassShader.uniforms);\n  this.highPassUniforms['luminosityThreshold'].value = threshold;\n  this.highPassUniforms['smoothWidth'].value = 0.01;\n  this.materialHighPassFilter = new _three.ShaderMaterial({\n    uniforms: this.highPassUniforms,\n    vertexShader: highPassShader.vertexShader,\n    fragmentShader: highPassShader.fragmentShader,\n    defines: {}\n  }); // Gaussian Blur Materials\n\n  this.separableBlurMaterials = [];\n  var kernelSizeArray = [3, 5, 7, 9, 11];\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n\n  for (var _i = 0; _i < this.nMips; _i++) {\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[_i]));\n    this.separableBlurMaterials[_i].uniforms['texSize'].value = new _three.Vector2(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // Composite material\n\n\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n  this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n  this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n  this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n  this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n  this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n  this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n  this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n  this.compositeMaterial.needsUpdate = true;\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n  this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n  this.bloomTintColors = [new _three.Vector3(1, 1, 1), new _three.Vector3(1, 1, 1), new _three.Vector3(1, 1, 1), new _three.Vector3(1, 1, 1), new _three.Vector3(1, 1, 1)];\n  this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\n\n  if (_CopyShader.CopyShader === undefined) {\n    console.error('THREE.UnrealBloomPass relies on CopyShader');\n  }\n\n  var copyShader = _CopyShader.CopyShader;\n  this.copyUniforms = _three.UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new _three.ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: _three.AdditiveBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new _three.Color();\n  this.oldClearAlpha = 1;\n  this.basic = new _three.MeshBasicMaterial();\n  this.fsQuad = new _Pass.FullScreenQuad(null);\n};\n\nexports.UnrealBloomPass = UnrealBloomPass;\nUnrealBloomPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {\n  constructor: UnrealBloomPass,\n  dispose: function dispose() {\n    for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n\n    for (var _i2 = 0; _i2 < this.renderTargetsVertical.length; _i2++) {\n      this.renderTargetsVertical[_i2].dispose();\n    }\n\n    this.renderTargetBright.dispose();\n  },\n  setSize: function setSize(width, height) {\n    var resx = Math.round(width / 2);\n    var resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n\n    for (var i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new _three.Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  },\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    } // 1. Extract Bright Areas\n\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n    var inputRenderTarget = this.renderTargetBright;\n\n    for (var i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    } // Composite All the mips\n\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    } // Restore renderer settings\n\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  },\n  getSeperableBlurMaterial: function getSeperableBlurMaterial(kernelRadius) {\n    return new _three.ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new _three.Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new _three.Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: '#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat x = float(i);\\\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\n\t\t\t\t}'\n    });\n  },\n  getCompositeMaterial: function getCompositeMaterial(nMips) {\n    return new _three.ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips\n      },\n      uniforms: {\n        blurTexture1: {\n          value: null\n        },\n        blurTexture2: {\n          value: null\n        },\n        blurTexture3: {\n          value: null\n        },\n        blurTexture4: {\n          value: null\n        },\n        blurTexture5: {\n          value: null\n        },\n        dirtTexture: {\n          value: null\n        },\n        bloomStrength: {\n          value: 1.0\n        },\n        bloomFactors: {\n          value: null\n        },\n        bloomTintColors: {\n          value: null\n        },\n        bloomRadius: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D blurTexture1;\\\n\t\t\t\tuniform sampler2D blurTexture2;\\\n\t\t\t\tuniform sampler2D blurTexture3;\\\n\t\t\t\tuniform sampler2D blurTexture4;\\\n\t\t\t\tuniform sampler2D blurTexture5;\\\n\t\t\t\tuniform sampler2D dirtTexture;\\\n\t\t\t\tuniform float bloomStrength;\\\n\t\t\t\tuniform float bloomRadius;\\\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\n\t\t\t\t\\\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\n\t\t\t\t}\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\n\t\t\t\t}'\n    });\n  }\n});\nUnrealBloomPass.BlurDirectionX = new _three.Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new _three.Vector2(0.0, 1.0);\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_stdlib$shaders$CopyShader","~$shadow.js","~$module$node_modules$three_stdlib$postprocessing$Pass","~$module$node_modules$three_stdlib$shaders$LuminosityHighPassShader"]],"~:properties",["^5",["fragmentShader","bloomRadius","map","depthTest","getCompositeMaterial","nMips","blending","clearColor","needsUpdate","prototype","KERNEL_RADIUS","transparent","texSize","blurTexture3","needsSwap","materialCopy","__esModule","radius","dispose","NUM_MIPS","enabled","defines","SIGMA","materialHighPassFilter","vertexShader","renderTargetsVertical","name","blurTexture5","separableBlurMaterials","blurTexture4","value","fsQuad","oldClearAlpha","direction","magFilter","threshold","copyUniforms","blurTexture1","compositeMaterial","autoClear","highPassUniforms","BlurDirectionX","renderTargetBright","render","_oldClearColor","setSize","bloomFactors","BlurDirectionY","blurTexture2","depthWrite","colorTexture","generateMipmaps","bloomStrength","uniforms","renderTargetsHorizontal","UnrealBloomPass","minFilter","getSeperableBlurMaterial","bloomTintColors","strength","dirtTexture","format","constructor","resolution","basic","material"]],"~:compiled-at",1630917515515,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$postprocessing$UnrealBloomPass.js\",\n\"lineCount\":18,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/postprocessing/UnrealBloomPass.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$postprocessing$UnrealBloomPass\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.UnrealBloomPass = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _Pass = require(\\\"./Pass.js\\\");\\n\\nvar _CopyShader = require(\\\"../shaders/CopyShader.js\\\");\\n\\nvar _LuminosityHighPassShader = require(\\\"../shaders/LuminosityHighPassShader.js\\\");\\n\\n/**\\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\\n * mip map chain of bloom textures and blurs them with different radii. Because\\n * of the weighted combination of mips, and because larger blurs are done on\\n * higher mips, this effect provides good quality and performance.\\n *\\n * Reference:\\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\\n */\\nvar UnrealBloomPass = function UnrealBloomPass(resolution, strength, radius, threshold) {\\n  this.strength = strength !== undefined ? strength : 1;\\n  this.radius = radius;\\n  this.threshold = threshold;\\n  this.resolution = resolution !== undefined ? new _three.Vector2(resolution.x, resolution.y) : new _three.Vector2(256, 256); // create color only once here, reuse it later inside the render function\\n\\n  this.clearColor = new _three.Color(0, 0, 0); // render targets\\n\\n  var pars = {\\n    minFilter: _three.LinearFilter,\\n    magFilter: _three.LinearFilter,\\n    format: _three.RGBAFormat\\n  };\\n  this.renderTargetsHorizontal = [];\\n  this.renderTargetsVertical = [];\\n  this.nMips = 5;\\n  var resx = Math.round(this.resolution.x / 2);\\n  var resy = Math.round(this.resolution.y / 2);\\n  this.renderTargetBright = new _three.WebGLRenderTarget(resx, resy, pars);\\n  this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\\n  this.renderTargetBright.texture.generateMipmaps = false;\\n\\n  for (var i = 0; i < this.nMips; i++) {\\n    var renderTargetHorizonal = new _three.WebGLRenderTarget(resx, resy, pars);\\n    renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\\n    renderTargetHorizonal.texture.generateMipmaps = false;\\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\\n    var renderTargetVertical = new _three.WebGLRenderTarget(resx, resy, pars);\\n    renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\\n    renderTargetVertical.texture.generateMipmaps = false;\\n    this.renderTargetsVertical.push(renderTargetVertical);\\n    resx = Math.round(resx / 2);\\n    resy = Math.round(resy / 2);\\n  } // luminosity high pass material\\n\\n\\n  if (_LuminosityHighPassShader.LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\\n  var highPassShader = _LuminosityHighPassShader.LuminosityHighPassShader;\\n  this.highPassUniforms = _three.UniformsUtils.clone(highPassShader.uniforms);\\n  this.highPassUniforms['luminosityThreshold'].value = threshold;\\n  this.highPassUniforms['smoothWidth'].value = 0.01;\\n  this.materialHighPassFilter = new _three.ShaderMaterial({\\n    uniforms: this.highPassUniforms,\\n    vertexShader: highPassShader.vertexShader,\\n    fragmentShader: highPassShader.fragmentShader,\\n    defines: {}\\n  }); // Gaussian Blur Materials\\n\\n  this.separableBlurMaterials = [];\\n  var kernelSizeArray = [3, 5, 7, 9, 11];\\n  var resx = Math.round(this.resolution.x / 2);\\n  var resy = Math.round(this.resolution.y / 2);\\n\\n  for (var _i = 0; _i < this.nMips; _i++) {\\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[_i]));\\n    this.separableBlurMaterials[_i].uniforms['texSize'].value = new _three.Vector2(resx, resy);\\n    resx = Math.round(resx / 2);\\n    resy = Math.round(resy / 2);\\n  } // Composite material\\n\\n\\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\\n  this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\\n  this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\\n  this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\\n  this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\\n  this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\\n  this.compositeMaterial.uniforms['bloomStrength'].value = strength;\\n  this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\\n  this.compositeMaterial.needsUpdate = true;\\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\\n  this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\\n  this.bloomTintColors = [new _three.Vector3(1, 1, 1), new _three.Vector3(1, 1, 1), new _three.Vector3(1, 1, 1), new _three.Vector3(1, 1, 1), new _three.Vector3(1, 1, 1)];\\n  this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\\n\\n  if (_CopyShader.CopyShader === undefined) {\\n    console.error('THREE.UnrealBloomPass relies on CopyShader');\\n  }\\n\\n  var copyShader = _CopyShader.CopyShader;\\n  this.copyUniforms = _three.UniformsUtils.clone(copyShader.uniforms);\\n  this.copyUniforms['opacity'].value = 1.0;\\n  this.materialCopy = new _three.ShaderMaterial({\\n    uniforms: this.copyUniforms,\\n    vertexShader: copyShader.vertexShader,\\n    fragmentShader: copyShader.fragmentShader,\\n    blending: _three.AdditiveBlending,\\n    depthTest: false,\\n    depthWrite: false,\\n    transparent: true\\n  });\\n  this.enabled = true;\\n  this.needsSwap = false;\\n  this._oldClearColor = new _three.Color();\\n  this.oldClearAlpha = 1;\\n  this.basic = new _three.MeshBasicMaterial();\\n  this.fsQuad = new _Pass.FullScreenQuad(null);\\n};\\n\\nexports.UnrealBloomPass = UnrealBloomPass;\\nUnrealBloomPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {\\n  constructor: UnrealBloomPass,\\n  dispose: function dispose() {\\n    for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\\n      this.renderTargetsHorizontal[i].dispose();\\n    }\\n\\n    for (var _i2 = 0; _i2 < this.renderTargetsVertical.length; _i2++) {\\n      this.renderTargetsVertical[_i2].dispose();\\n    }\\n\\n    this.renderTargetBright.dispose();\\n  },\\n  setSize: function setSize(width, height) {\\n    var resx = Math.round(width / 2);\\n    var resy = Math.round(height / 2);\\n    this.renderTargetBright.setSize(resx, resy);\\n\\n    for (var i = 0; i < this.nMips; i++) {\\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\\n      this.renderTargetsVertical[i].setSize(resx, resy);\\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new _three.Vector2(resx, resy);\\n      resx = Math.round(resx / 2);\\n      resy = Math.round(resy / 2);\\n    }\\n  },\\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\\n    renderer.getClearColor(this._oldClearColor);\\n    this.oldClearAlpha = renderer.getClearAlpha();\\n    var oldAutoClear = renderer.autoClear;\\n    renderer.autoClear = false;\\n    renderer.setClearColor(this.clearColor, 0);\\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\\n\\n    if (this.renderToScreen) {\\n      this.fsQuad.material = this.basic;\\n      this.basic.map = readBuffer.texture;\\n      renderer.setRenderTarget(null);\\n      renderer.clear();\\n      this.fsQuad.render(renderer);\\n    } // 1. Extract Bright Areas\\n\\n\\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\\n    this.fsQuad.material = this.materialHighPassFilter;\\n    renderer.setRenderTarget(this.renderTargetBright);\\n    renderer.clear();\\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\\n\\n    var inputRenderTarget = this.renderTargetBright;\\n\\n    for (var i = 0; i < this.nMips; i++) {\\n      this.fsQuad.material = this.separableBlurMaterials[i];\\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\\n      renderer.clear();\\n      this.fsQuad.render(renderer);\\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\\n      renderer.clear();\\n      this.fsQuad.render(renderer);\\n      inputRenderTarget = this.renderTargetsVertical[i];\\n    } // Composite All the mips\\n\\n\\n    this.fsQuad.material = this.compositeMaterial;\\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\\n    renderer.clear();\\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\\n\\n    this.fsQuad.material = this.materialCopy;\\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\\n\\n    if (this.renderToScreen) {\\n      renderer.setRenderTarget(null);\\n      this.fsQuad.render(renderer);\\n    } else {\\n      renderer.setRenderTarget(readBuffer);\\n      this.fsQuad.render(renderer);\\n    } // Restore renderer settings\\n\\n\\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\\n    renderer.autoClear = oldAutoClear;\\n  },\\n  getSeperableBlurMaterial: function getSeperableBlurMaterial(kernelRadius) {\\n    return new _three.ShaderMaterial({\\n      defines: {\\n        KERNEL_RADIUS: kernelRadius,\\n        SIGMA: kernelRadius\\n      },\\n      uniforms: {\\n        colorTexture: {\\n          value: null\\n        },\\n        texSize: {\\n          value: new _three.Vector2(0.5, 0.5)\\n        },\\n        direction: {\\n          value: new _three.Vector2(0.5, 0.5)\\n        }\\n      },\\n      vertexShader: 'varying vec2 vUv;\\\\n\\\\\\n\\t\\t\\t\\tvoid main() {\\\\n\\\\\\n\\t\\t\\t\\t\\tvUv = uv;\\\\n\\\\\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\\\n\\t\\t\\t\\t}',\\n      fragmentShader: '#include <common>\\\\\\n\\t\\t\\t\\tvarying vec2 vUv;\\\\n\\\\\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\\\n\\\\\\n\\t\\t\\t\\tuniform vec2 texSize;\\\\\\n\\t\\t\\t\\tuniform vec2 direction;\\\\\\n\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\\\\\n\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\\\\n\\t\\t\\t\\t}\\\\\\n\\t\\t\\t\\tvoid main() {\\\\n\\\\\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\\\\\n\\t\\t\\t\\t\\tfloat fSigma = float(SIGMA);\\\\\\n\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\\\\n\\t\\t\\t\\t\\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\\\\n\\t\\t\\t\\t\\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\\\\n\\t\\t\\t\\t\\t\\tfloat x = float(i);\\\\\\n\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(x, fSigma);\\\\\\n\\t\\t\\t\\t\\t\\tvec2 uvOffset = direction * invSize * x;\\\\\\n\\t\\t\\t\\t\\t\\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\\\\n\\t\\t\\t\\t\\t\\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\\\\n\\t\\t\\t\\t\\t\\tdiffuseSum += (sample1 + sample2) * w;\\\\\\n\\t\\t\\t\\t\\t\\tweightSum += 2.0 * w;\\\\\\n\\t\\t\\t\\t\\t}\\\\\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\\\n\\\\\\n\\t\\t\\t\\t}'\\n    });\\n  },\\n  getCompositeMaterial: function getCompositeMaterial(nMips) {\\n    return new _three.ShaderMaterial({\\n      defines: {\\n        NUM_MIPS: nMips\\n      },\\n      uniforms: {\\n        blurTexture1: {\\n          value: null\\n        },\\n        blurTexture2: {\\n          value: null\\n        },\\n        blurTexture3: {\\n          value: null\\n        },\\n        blurTexture4: {\\n          value: null\\n        },\\n        blurTexture5: {\\n          value: null\\n        },\\n        dirtTexture: {\\n          value: null\\n        },\\n        bloomStrength: {\\n          value: 1.0\\n        },\\n        bloomFactors: {\\n          value: null\\n        },\\n        bloomTintColors: {\\n          value: null\\n        },\\n        bloomRadius: {\\n          value: 0.0\\n        }\\n      },\\n      vertexShader: 'varying vec2 vUv;\\\\n\\\\\\n\\t\\t\\t\\tvoid main() {\\\\n\\\\\\n\\t\\t\\t\\t\\tvUv = uv;\\\\n\\\\\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\\\n\\t\\t\\t\\t}',\\n      fragmentShader: 'varying vec2 vUv;\\\\\\n\\t\\t\\t\\tuniform sampler2D blurTexture1;\\\\\\n\\t\\t\\t\\tuniform sampler2D blurTexture2;\\\\\\n\\t\\t\\t\\tuniform sampler2D blurTexture3;\\\\\\n\\t\\t\\t\\tuniform sampler2D blurTexture4;\\\\\\n\\t\\t\\t\\tuniform sampler2D blurTexture5;\\\\\\n\\t\\t\\t\\tuniform sampler2D dirtTexture;\\\\\\n\\t\\t\\t\\tuniform float bloomStrength;\\\\\\n\\t\\t\\t\\tuniform float bloomRadius;\\\\\\n\\t\\t\\t\\tuniform float bloomFactors[NUM_MIPS];\\\\\\n\\t\\t\\t\\tuniform vec3 bloomTintColors[NUM_MIPS];\\\\\\n\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\tfloat lerpBloomFactor(const in float factor) { \\\\\\n\\t\\t\\t\\t\\tfloat mirrorFactor = 1.2 - factor;\\\\\\n\\t\\t\\t\\t\\treturn mix(factor, mirrorFactor, bloomRadius);\\\\\\n\\t\\t\\t\\t}\\\\\\n\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\tvoid main() {\\\\\\n\\t\\t\\t\\t\\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\\\\n\\t\\t\\t\\t}'\\n    });\\n  }\\n});\\nUnrealBloomPass.BlurDirectionX = new _three.Vector2(1.0, 0.0);\\nUnrealBloomPass.BlurDirectionY = new _three.Vector2(0.0, 1.0);\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"UnrealBloomPass\",\"_three\",\"_Pass\",\"_CopyShader\",\"_LuminosityHighPassShader\",\"resolution\",\"strength\",\"radius\",\"threshold\",\"undefined\",\"Vector2\",\"x\",\"y\",\"clearColor\",\"Color\",\"pars\",\"minFilter\",\"LinearFilter\",\"magFilter\",\"format\",\"RGBAFormat\",\"renderTargetsHorizontal\",\"renderTargetsVertical\",\"nMips\",\"resx\",\"Math\",\"round\",\"resy\",\"renderTargetBright\",\"WebGLRenderTarget\",\"texture\",\"name\",\"generateMipmaps\",\"i\",\"renderTargetHorizonal\",\"push\",\"renderTargetVertical\",\"LuminosityHighPassShader\",\"console\",\"error\",\"highPassShader\",\"highPassUniforms\",\"UniformsUtils\",\"clone\",\"uniforms\",\"materialHighPassFilter\",\"ShaderMaterial\",\"vertexShader\",\"fragmentShader\",\"defines\",\"separableBlurMaterials\",\"kernelSizeArray\",\"_i\",\"getSeperableBlurMaterial\",\"compositeMaterial\",\"getCompositeMaterial\",\"needsUpdate\",\"bloomFactors\",\"bloomTintColors\",\"Vector3\",\"CopyShader\",\"copyShader\",\"copyUniforms\",\"materialCopy\",\"blending\",\"AdditiveBlending\",\"depthTest\",\"depthWrite\",\"transparent\",\"enabled\",\"needsSwap\",\"_oldClearColor\",\"oldClearAlpha\",\"basic\",\"MeshBasicMaterial\",\"fsQuad\",\"FullScreenQuad\",\"prototype\",\"assign\",\"create\",\"Pass\",\"constructor\",\"dispose\",\"length\",\"_i2\",\"setSize\",\"width\",\"height\",\"render\",\"renderer\",\"writeBuffer\",\"readBuffer\",\"deltaTime\",\"maskActive\",\"getClearColor\",\"getClearAlpha\",\"oldAutoClear\",\"autoClear\",\"setClearColor\",\"state\",\"buffers\",\"stencil\",\"setTest\",\"renderToScreen\",\"material\",\"map\",\"setRenderTarget\",\"clear\",\"inputRenderTarget\",\"BlurDirectionX\",\"BlurDirectionY\",\"kernelRadius\",\"KERNEL_RADIUS\",\"SIGMA\",\"colorTexture\",\"texSize\",\"direction\",\"NUM_MIPS\",\"blurTexture1\",\"blurTexture2\",\"blurTexture3\",\"blurTexture4\",\"blurTexture5\",\"dirtTexture\",\"bloomStrength\",\"bloomRadius\"]\n}\n"]