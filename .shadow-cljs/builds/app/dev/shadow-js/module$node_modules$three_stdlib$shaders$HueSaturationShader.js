["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/HueSaturationShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$HueSaturationShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.HueSaturationShader=void 0;exports.HueSaturationShader={uniforms:{tDiffuse:{value:null},hue:{value:0},saturation:{value:0}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform sampler2D tDiffuse;\\nuniform float hue;\\nuniform float saturation;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tgl_FragColor \\x3d texture2D( tDiffuse, vUv );\\n\\tfloat angle \\x3d hue * 3.14159265;\\n\\tfloat s \\x3d sin(angle), c \\x3d cos(angle);\\n\\tvec3 weights \\x3d (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\\n\\tfloat len \\x3d length(gl_FragColor.rgb);\\n\\tgl_FragColor.rgb \\x3d vec3(\\n\\t\\tdot(gl_FragColor.rgb, weights.xyz),\\n\\t\\tdot(gl_FragColor.rgb, weights.zxy),\\n\\t\\tdot(gl_FragColor.rgb, weights.yzx)\\n\\t);\\n\\tfloat average \\x3d (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\\n\\tif (saturation \\x3e 0.0) {\\n\\t\\tgl_FragColor.rgb +\\x3d (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\\n\\t} else {\\n\\t\\tgl_FragColor.rgb +\\x3d (average - gl_FragColor.rgb) * (-saturation);\\n\\t}\\n}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$HueSaturationShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HueSaturationShader = void 0;\n\n/**\n * Hue and saturation adjustment\n * https://github.com/evanw/glfx.js\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\nvar HueSaturationShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    hue: {\n      value: 0\n    },\n    saturation: {\n      value: 0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float hue;', 'uniform float saturation;', 'varying vec2 vUv;', 'void main() {', '\tgl_FragColor = texture2D( tDiffuse, vUv );', // hue\n  '\tfloat angle = hue * 3.14159265;', '\tfloat s = sin(angle), c = cos(angle);', '\tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;', '\tfloat len = length(gl_FragColor.rgb);', '\tgl_FragColor.rgb = vec3(', '\t\tdot(gl_FragColor.rgb, weights.xyz),', '\t\tdot(gl_FragColor.rgb, weights.zxy),', '\t\tdot(gl_FragColor.rgb, weights.yzx)', '\t);', // saturation\n  '\tfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;', '\tif (saturation > 0.0) {', '\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));', '\t} else {', '\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);', '\t}', '}'].join('\\n')\n};\nexports.HueSaturationShader = HueSaturationShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["fragmentShader","__esModule","saturation","tDiffuse","vertexShader","value","hue","HueSaturationShader","uniforms"]],"~:compiled-at",1630917515592,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$HueSaturationShader.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,CAAA,4DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGzHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,mBAAR,CAA8B,IAAK,EAyBnCJ,QAAQI,CAAAA,mBAAR,CAjB0BA,CACxBC,SAAU,CACRC,SAAU,CACRH,MAAO,IADC,CADF,CAIRI,IAAK,CACHJ,MAAO,CADJ,CAJG,CAORK,WAAY,CACVL,MAAO,CADG,CAPJ,CADcC,CAYxBK,aAAiJ,qIAZzHL,CAaxBM,eAEgS,m0BAfxQN,CAd+F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/HueSaturationShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$HueSaturationShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.HueSaturationShader = void 0;\\n\\n/**\\n * Hue and saturation adjustment\\n * https://github.com/evanw/glfx.js\\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\\n */\\nvar HueSaturationShader = {\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    hue: {\\n      value: 0\\n    },\\n    saturation: {\\n      value: 0\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform sampler2D tDiffuse;', 'uniform float hue;', 'uniform float saturation;', 'varying vec2 vUv;', 'void main() {', '\\tgl_FragColor = texture2D( tDiffuse, vUv );', // hue\\n  '\\tfloat angle = hue * 3.14159265;', '\\tfloat s = sin(angle), c = cos(angle);', '\\tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;', '\\tfloat len = length(gl_FragColor.rgb);', '\\tgl_FragColor.rgb = vec3(', '\\t\\tdot(gl_FragColor.rgb, weights.xyz),', '\\t\\tdot(gl_FragColor.rgb, weights.zxy),', '\\t\\tdot(gl_FragColor.rgb, weights.yzx)', '\\t);', // saturation\\n  '\\tfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;', '\\tif (saturation > 0.0) {', '\\t\\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));', '\\t} else {', '\\t\\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);', '\\t}', '}'].join('\\\\n')\\n};\\nexports.HueSaturationShader = HueSaturationShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"HueSaturationShader\",\"uniforms\",\"tDiffuse\",\"hue\",\"saturation\",\"vertexShader\",\"fragmentShader\"]\n}\n"]