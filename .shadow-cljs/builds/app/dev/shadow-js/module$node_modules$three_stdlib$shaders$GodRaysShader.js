["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/GodRaysShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$GodRaysShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.GodRaysGenerateShader=exports.GodRaysFakeSunShader=exports.GodRaysDepthMaskShader=exports.GodRaysCombineShader=void 0;global=require(\"module$node_modules$three$build$three_module\");exports.GodRaysDepthMaskShader={uniforms:{tInput:{value:null}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n vUv \\x3d uv;\\n gl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",\nfragmentShader:\"varying vec2 vUv;\\nuniform sampler2D tInput;\\nvoid main() {\\n\\tgl_FragColor \\x3d vec4( 1.0 ) - texture2D( tInput, vUv );\\n}\"};require={uniforms:{tInput:{value:null},fStepSize:{value:1},vSunPositionScreenSpace:{value:new global.Vector3}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n vUv \\x3d uv;\\n gl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"#define TAPS_PER_PASS 6.0\\nvarying vec2 vUv;\\nuniform sampler2D tInput;\\nuniform vec3 vSunPositionScreenSpace;\\nuniform float fStepSize;\\nvoid main() {\\n\\tvec2 delta \\x3d vSunPositionScreenSpace.xy - vUv;\\n\\tfloat dist \\x3d length( delta );\\n\\tvec2 stepv \\x3d fStepSize * delta / dist;\\n\\tfloat iters \\x3d dist/fStepSize;\\n\\tvec2 uv \\x3d vUv.xy;\\n\\tfloat col \\x3d 0.0;\\n\\tfloat f \\x3d min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );\\n\\tif ( 0.0 \\x3c\\x3d iters \\x26\\x26 uv.y \\x3c 1.0 ) col +\\x3d texture2D( tInput, uv ).r * f;\\n\\tuv +\\x3d stepv;\\n\\tif ( 1.0 \\x3c\\x3d iters \\x26\\x26 uv.y \\x3c 1.0 ) col +\\x3d texture2D( tInput, uv ).r * f;\\n\\tuv +\\x3d stepv;\\n\\tif ( 2.0 \\x3c\\x3d iters \\x26\\x26 uv.y \\x3c 1.0 ) col +\\x3d texture2D( tInput, uv ).r * f;\\n\\tuv +\\x3d stepv;\\n\\tif ( 3.0 \\x3c\\x3d iters \\x26\\x26 uv.y \\x3c 1.0 ) col +\\x3d texture2D( tInput, uv ).r * f;\\n\\tuv +\\x3d stepv;\\n\\tif ( 4.0 \\x3c\\x3d iters \\x26\\x26 uv.y \\x3c 1.0 ) col +\\x3d texture2D( tInput, uv ).r * f;\\n\\tuv +\\x3d stepv;\\n\\tif ( 5.0 \\x3c\\x3d iters \\x26\\x26 uv.y \\x3c 1.0 ) col +\\x3d texture2D( tInput, uv ).r * f;\\n\\tuv +\\x3d stepv;\\n\\tgl_FragColor \\x3d vec4( col/TAPS_PER_PASS );\\n\\tgl_FragColor.a \\x3d 1.0;\\n}\"};\nexports.GodRaysGenerateShader=require;exports.GodRaysCombineShader={uniforms:{tColors:{value:null},tGodRays:{value:null},fGodRayIntensity:{value:.69}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"varying vec2 vUv;\\nuniform sampler2D tColors;\\nuniform sampler2D tGodRays;\\nuniform float fGodRayIntensity;\\nvoid main() {\\n\\tgl_FragColor \\x3d texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\\n\\tgl_FragColor.a \\x3d 1.0;\\n}\"};\nglobal={uniforms:{vSunPositionScreenSpace:{value:new global.Vector3},fAspect:{value:1},sunColor:{value:new global.Color(16772608)},bgColor:{value:new global.Color(0)}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"varying vec2 vUv;\\nuniform vec3 vSunPositionScreenSpace;\\nuniform float fAspect;\\nuniform vec3 sunColor;\\nuniform vec3 bgColor;\\nvoid main() {\\n\\tvec2 diff \\x3d vUv - vSunPositionScreenSpace.xy;\\n\\tdiff.x *\\x3d fAspect;\\n\\tfloat prop \\x3d clamp( length( diff ) / 0.5, 0.0, 1.0 );\\n\\tprop \\x3d 0.35 * pow( 1.0 - prop, 3.0 );\\n\\tgl_FragColor.xyz \\x3d ( vSunPositionScreenSpace.z \\x3e 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;\\n\\tgl_FragColor.w \\x3d 1.0;\\n}\"};\nexports.GodRaysFakeSunShader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$GodRaysShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GodRaysGenerateShader = exports.GodRaysFakeSunShader = exports.GodRaysDepthMaskShader = exports.GodRaysCombineShader = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * God-rays (crepuscular rays)\n *\n * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\n * Blurs a mask generated from the depth map along radial lines emanating from the light\n * source. The blur repeatedly applies a blur filter of increasing support but constant\n * sample count to produce a blur filter with large support.\n *\n * My implementation performs 3 passes, similar to the implementation from Sousa. I found\n * just 6 samples per pass produced acceptible results. The blur is applied three times,\n * with decreasing filter support. The result is equivalent to a single pass with\n * 6*6*6 = 216 samples.\n *\n * References:\n *\n * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt\n */\nvar GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tInput;', 'void main() {', '\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );', '}'].join('\\n')\n};\n/**\n * The god-ray generation shader.\n *\n * First pass:\n *\n * The depth map is blurred along radial lines towards the \"sun\". The\n * output is written to a temporary render target (I used a 1/4 sized\n * target).\n *\n * Pass two & three:\n *\n * The results of the previous pass are re-blurred, each time with a\n * decreased distance between samples.\n */\n\nexports.GodRaysDepthMaskShader = GodRaysDepthMaskShader;\nvar GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    },\n    fStepSize: {\n      value: 1.0\n    },\n    vSunPositionScreenSpace: {\n      value: new _three.Vector3()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#define TAPS_PER_PASS 6.0', 'varying vec2 vUv;', 'uniform sampler2D tInput;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fStepSize;', // filter step size\n  'void main() {', // delta from current pixel to \"sun\" position\n  '\tvec2 delta = vSunPositionScreenSpace.xy - vUv;', '\tfloat dist = length( delta );', // Step vector (uv space)\n  '\tvec2 stepv = fStepSize * delta / dist;', // Number of iterations between pixel and sun\n  '\tfloat iters = dist/fStepSize;', '\tvec2 uv = vUv.xy;', '\tfloat col = 0.0;', // This breaks ANGLE in Chrome 22\n  //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n  /*\n  // Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n  // so i've just left the loop\n  \"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\n  // Accumulate samples, making sure we dont walk past the light source.\n  // The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n  // mode, with a black border color. I don't think this is currently\n  // exposed by three.js. As a result there might be artifacts when the\n  // sun is to the left, right or bottom of screen as these cases are\n  // not specifically handled.\n  \"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\n  \"\tuv += stepv;\",\n  \"}\",\n  */\n  // Unrolling loop manually makes it work in ANGLE\n  '\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );', // used to fade out godrays\n  '\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n  // objectionable artifacts, in particular near the sun position. The side\n  // effect is that the result is darker than it should be around the sun, as\n  // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n  // When the result is inverted (in the shader 'godrays_combine', this produces\n  // a slight bright spot at the position of the sun, even when it is occluded.\n  '\tgl_FragColor = vec4( col/TAPS_PER_PASS );', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\n};\n/**\n * Additively applies god rays from texture tGodRays to a background (tColors).\n * fGodRayIntensity attenuates the god rays.\n */\n\nexports.GodRaysGenerateShader = GodRaysGenerateShader;\nvar GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null\n    },\n    tGodRays: {\n      value: null\n    },\n    fGodRayIntensity: {\n      value: 0.69\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tColors;', 'uniform sampler2D tGodRays;', 'uniform float fGodRayIntensity;', 'void main() {', // Since THREE.MeshDepthMaterial renders foreground objects white and background\n  // objects black, the god-rays will be white streaks. Therefore value is inverted\n  // before being combined with tColors\n  '\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\n};\n/**\n * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\n * cheaper/faster/simpler to implement this as a simple sun sprite.\n */\n\nexports.GodRaysCombineShader = GodRaysCombineShader;\nvar GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: new _three.Vector3()\n    },\n    fAspect: {\n      value: 1.0\n    },\n    sunColor: {\n      value: new _three.Color(0xffee00)\n    },\n    bgColor: {\n      value: new _three.Color(0x000000)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['varying vec2 vUv;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fAspect;', 'uniform vec3 sunColor;', 'uniform vec3 bgColor;', 'void main() {', '\tvec2 diff = vUv - vSunPositionScreenSpace.xy;', // Correct for aspect ratio\n  '\tdiff.x *= fAspect;', '\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );', '\tprop = 0.35 * pow( 1.0 - prop, 3.0 );', '\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;', '\tgl_FragColor.w = 1.0;', '}'].join('\\n')\n};\nexports.GodRaysFakeSunShader = GodRaysFakeSunShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","GodRaysGenerateShader","__esModule","GodRaysFakeSunShader","vertexShader","fAspect","sunColor","value","GodRaysCombineShader","fStepSize","bgColor","GodRaysDepthMaskShader","tInput","tGodRays","vSunPositionScreenSpace","uniforms","tColors","fGodRayIntensity"]],"~:compiled-at",1630917515578,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$GodRaysShader.js\",\n\"lineCount\":5,\n\"mappings\":\"AAAAA,cAAA,CAAA,sDAAA,CAA2E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGnHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,qBAAR,CAAgCJ,OAAQK,CAAAA,oBAAxC,CAA+DL,OAAQM,CAAAA,sBAAvE,CAAgGN,OAAQO,CAAAA,oBAAxG,CAA+H,IAAK,EAEhIC,OAAAA,CAASV,OAAA,CAAQ,8CAAR,CA2CbE,QAAQM,CAAAA,sBAAR,CAxB6BA,CAC3BG,SAAU,CACRC,OAAQ,CACNP,MAAO,IADD,CADA,CADiBG,CAM3BK,aAAiJ,mIANtHL;AAO3BM,eAA+I,6HAPpHN,CAyBzBF,QAAAA,CAAwB,CAC1BK,SAAU,CACRC,OAAQ,CACNP,MAAO,IADD,CADA,CAIRU,UAAW,CACTV,MAAO,CADE,CAJH,CAORW,wBAAyB,CACvBX,MAAO,IAAIK,MAAOO,CAAAA,OADK,CAPjB,CADgB,CAY1BJ,aAAiJ,mIAZvH,CAa1BC,eA6BwE,6qCA1C9C,CAiD5BZ;OAAQI,CAAAA,qBAAR,CAAgCA,OAwBhCJ,QAAQO,CAAAA,oBAAR,CAvB2BA,CACzBE,SAAU,CACRO,QAAS,CACPb,MAAO,IADA,CADD,CAIRc,SAAU,CACRd,MAAO,IADC,CAJF,CAORe,iBAAkB,CAChBf,MAAO,GADS,CAPV,CADeI,CAYzBI,aAAiJ,qIAZxHJ,CAazBK,eAGwI,2QAhB/GL,CAwBvBF;MAAAA,CAAuB,CACzBI,SAAU,CACRK,wBAAyB,CACvBX,MAAO,IAAIK,MAAOO,CAAAA,OADK,CADjB,CAIRI,QAAS,CACPhB,MAAO,CADA,CAJD,CAORiB,SAAU,CACRjB,MAAO,IAAIK,MAAOa,CAAAA,KAAX,CAAiB,QAAjB,CADC,CAPF,CAURC,QAAS,CACPnB,MAAO,IAAIK,MAAOa,CAAAA,KAAX,CAAiB,CAAjB,CADA,CAVD,CADe,CAezBV,aAAiJ,qIAfxH,CAgBzBC,eACkQ,sdAjBzO,CAmB3BZ;OAAQK,CAAAA,oBAAR,CAA+BA,MAjJoF;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/GodRaysShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$GodRaysShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.GodRaysGenerateShader = exports.GodRaysFakeSunShader = exports.GodRaysDepthMaskShader = exports.GodRaysCombineShader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * God-rays (crepuscular rays)\\n *\\n * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\\n * Blurs a mask generated from the depth map along radial lines emanating from the light\\n * source. The blur repeatedly applies a blur filter of increasing support but constant\\n * sample count to produce a blur filter with large support.\\n *\\n * My implementation performs 3 passes, similar to the implementation from Sousa. I found\\n * just 6 samples per pass produced acceptible results. The blur is applied three times,\\n * with decreasing filter support. The result is equivalent to a single pass with\\n * 6*6*6 = 216 samples.\\n *\\n * References:\\n *\\n * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt\\n */\\nvar GodRaysDepthMaskShader = {\\n  uniforms: {\\n    tInput: {\\n      value: null\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tInput;', 'void main() {', '\\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );', '}'].join('\\\\n')\\n};\\n/**\\n * The god-ray generation shader.\\n *\\n * First pass:\\n *\\n * The depth map is blurred along radial lines towards the \\\"sun\\\". The\\n * output is written to a temporary render target (I used a 1/4 sized\\n * target).\\n *\\n * Pass two & three:\\n *\\n * The results of the previous pass are re-blurred, each time with a\\n * decreased distance between samples.\\n */\\n\\nexports.GodRaysDepthMaskShader = GodRaysDepthMaskShader;\\nvar GodRaysGenerateShader = {\\n  uniforms: {\\n    tInput: {\\n      value: null\\n    },\\n    fStepSize: {\\n      value: 1.0\\n    },\\n    vSunPositionScreenSpace: {\\n      value: new _three.Vector3()\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['#define TAPS_PER_PASS 6.0', 'varying vec2 vUv;', 'uniform sampler2D tInput;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fStepSize;', // filter step size\\n  'void main() {', // delta from current pixel to \\\"sun\\\" position\\n  '\\tvec2 delta = vSunPositionScreenSpace.xy - vUv;', '\\tfloat dist = length( delta );', // Step vector (uv space)\\n  '\\tvec2 stepv = fStepSize * delta / dist;', // Number of iterations between pixel and sun\\n  '\\tfloat iters = dist/fStepSize;', '\\tvec2 uv = vUv.xy;', '\\tfloat col = 0.0;', // This breaks ANGLE in Chrome 22\\n  //\\t- see http://code.google.com/p/chromium/issues/detail?id=153105\\n\\n  /*\\n  // Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\\n  // so i've just left the loop\\n  \\\"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\\\",\\n  // Accumulate samples, making sure we dont walk past the light source.\\n  // The check for uv.y < 1 would not be necessary with \\\"border\\\" UV wrap\\n  // mode, with a black border color. I don't think this is currently\\n  // exposed by three.js. As a result there might be artifacts when the\\n  // sun is to the left, right or bottom of screen as these cases are\\n  // not specifically handled.\\n  \\\"\\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\\\",\\n  \\\"\\tuv += stepv;\\\",\\n  \\\"}\\\",\\n  */\\n  // Unrolling loop manually makes it work in ANGLE\\n  '\\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );', // used to fade out godrays\\n  '\\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\\tuv += stepv;', '\\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\\tuv += stepv;', '\\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\\tuv += stepv;', '\\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\\tuv += stepv;', '\\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\\tuv += stepv;', '\\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\\tuv += stepv;', // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\\n  // objectionable artifacts, in particular near the sun position. The side\\n  // effect is that the result is darker than it should be around the sun, as\\n  // TAPS_PER_PASS is greater than the number of samples actually accumulated.\\n  // When the result is inverted (in the shader 'godrays_combine', this produces\\n  // a slight bright spot at the position of the sun, even when it is occluded.\\n  '\\tgl_FragColor = vec4( col/TAPS_PER_PASS );', '\\tgl_FragColor.a = 1.0;', '}'].join('\\\\n')\\n};\\n/**\\n * Additively applies god rays from texture tGodRays to a background (tColors).\\n * fGodRayIntensity attenuates the god rays.\\n */\\n\\nexports.GodRaysGenerateShader = GodRaysGenerateShader;\\nvar GodRaysCombineShader = {\\n  uniforms: {\\n    tColors: {\\n      value: null\\n    },\\n    tGodRays: {\\n      value: null\\n    },\\n    fGodRayIntensity: {\\n      value: 0.69\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tColors;', 'uniform sampler2D tGodRays;', 'uniform float fGodRayIntensity;', 'void main() {', // Since THREE.MeshDepthMaterial renders foreground objects white and background\\n  // objects black, the god-rays will be white streaks. Therefore value is inverted\\n  // before being combined with tColors\\n  '\\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );', '\\tgl_FragColor.a = 1.0;', '}'].join('\\\\n')\\n};\\n/**\\n * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\\n * cheaper/faster/simpler to implement this as a simple sun sprite.\\n */\\n\\nexports.GodRaysCombineShader = GodRaysCombineShader;\\nvar GodRaysFakeSunShader = {\\n  uniforms: {\\n    vSunPositionScreenSpace: {\\n      value: new _three.Vector3()\\n    },\\n    fAspect: {\\n      value: 1.0\\n    },\\n    sunColor: {\\n      value: new _three.Color(0xffee00)\\n    },\\n    bgColor: {\\n      value: new _three.Color(0x000000)\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['varying vec2 vUv;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fAspect;', 'uniform vec3 sunColor;', 'uniform vec3 bgColor;', 'void main() {', '\\tvec2 diff = vUv - vSunPositionScreenSpace.xy;', // Correct for aspect ratio\\n  '\\tdiff.x *= fAspect;', '\\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );', '\\tprop = 0.35 * pow( 1.0 - prop, 3.0 );', '\\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;', '\\tgl_FragColor.w = 1.0;', '}'].join('\\\\n')\\n};\\nexports.GodRaysFakeSunShader = GodRaysFakeSunShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"GodRaysGenerateShader\",\"GodRaysFakeSunShader\",\"GodRaysDepthMaskShader\",\"GodRaysCombineShader\",\"_three\",\"uniforms\",\"tInput\",\"vertexShader\",\"fragmentShader\",\"fStepSize\",\"vSunPositionScreenSpace\",\"Vector3\",\"tColors\",\"tGodRays\",\"fGodRayIntensity\",\"fAspect\",\"sunColor\",\"Color\",\"bgColor\"]\n}\n"]