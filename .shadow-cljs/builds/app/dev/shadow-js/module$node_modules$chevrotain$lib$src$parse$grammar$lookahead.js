["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/parse/grammar/lookahead.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$parse$grammar$lookahead=function(global,require,module,exports){function initializeArrayOfArrays(size){for(var result=Array(size),i=0;i<size;i++)result[i]=[];return result}function pathToHashKeys(path){for(var keys=[\"\"],i=0;i<path.length;i++){for(var tokType=path[i],longerKeys=[],j=0;j<keys.length;j++){var currShorterKey=keys[j];longerKeys.push(currShorterKey+\"_\"+tokType.tokenTypeIdx);for(var t=0;t<tokType.categoryMatches.length;t++)longerKeys.push(currShorterKey+\n(\"_\"+tokType.categoryMatches[t]))}keys=longerKeys}return keys}function isUniquePrefixHash(altKnownPathsKeys,searchPathKeys,idx){for(var currAltIdx=0;currAltIdx<altKnownPathsKeys.length;currAltIdx++)if(currAltIdx!==idx)for(var otherAltKnownPathsKeys=altKnownPathsKeys[currAltIdx],searchIdx=0;searchIdx<searchPathKeys.length;searchIdx++)if(!0===otherAltKnownPathsKeys[searchPathKeys[searchIdx]])return!1;return!0}function lookAheadSequenceFromAlternatives(altsDefs,k){altsDefs=utils_1.map(altsDefs,function(currAlt){return interpreter_1.possiblePathsFrom([currAlt],\n1)});for(var finalResult=initializeArrayOfArrays(altsDefs.length),altsHashes=utils_1.map(altsDefs,function(currAltPaths){var dict={};utils_1.forEach(currAltPaths,function(item){item=pathToHashKeys(item.partialPath);utils_1.forEach(item,function(currKey){dict[currKey]=!0})});return dict}),newData=altsDefs,pathLength=1;pathLength<=k;pathLength++){var currDataset=newData;newData=initializeArrayOfArrays(currDataset.length);altsDefs=function(altIdx){for(var currAltPathsAndSuffixes=currDataset[altIdx],\ncurrPathIdx=0;currPathIdx<currAltPathsAndSuffixes.length;currPathIdx++){var currPathPrefix=currAltPathsAndSuffixes[currPathIdx].partialPath,suffixDef=currAltPathsAndSuffixes[currPathIdx].suffixDef,prefixKeys=pathToHashKeys(currPathPrefix);if(isUniquePrefixHash(altsHashes,prefixKeys,altIdx)||utils_1.isEmpty(suffixDef)||currPathPrefix.length===k){if(suffixDef=finalResult[altIdx],!1===containsPath(suffixDef,currPathPrefix))for(suffixDef.push(currPathPrefix),currPathPrefix=0;currPathPrefix<prefixKeys.length;currPathPrefix++)altsHashes[altIdx][prefixKeys[currPathPrefix]]=\n!0}else prefixKeys=interpreter_1.possiblePathsFrom(suffixDef,pathLength+1,currPathPrefix),newData[altIdx]=newData[altIdx].concat(prefixKeys),utils_1.forEach(prefixKeys,function(item){item=pathToHashKeys(item.partialPath);utils_1.forEach(item,function(key){altsHashes[altIdx][key]=!0})})}};for(var altIdx=0;altIdx<currDataset.length;altIdx++)altsDefs(altIdx)}return finalResult}function getLookaheadPathsForOr(occurrence,ruleGrammar,k,orProd){occurrence=new InsideDefinitionFinderVisitor(occurrence,PROD_TYPE.ALTERNATION,\norProd);ruleGrammar.accept(occurrence);return lookAheadSequenceFromAlternatives(occurrence.result,k)}function getLookaheadPathsForOptionalProd(occurrence,ruleGrammar,prodType,k){var insideDefVisitor=new InsideDefinitionFinderVisitor(occurrence,prodType);ruleGrammar.accept(insideDefVisitor);insideDefVisitor=insideDefVisitor.result;occurrence=(new RestDefinitionFinderWalker(ruleGrammar,occurrence,prodType)).startWalking();ruleGrammar=new gast_public_1.Alternative({definition:insideDefVisitor});occurrence=\nnew gast_public_1.Alternative({definition:occurrence});return lookAheadSequenceFromAlternatives([ruleGrammar,occurrence],k)}function containsPath(alternative,searchPath){var i=0;a:for(;i<alternative.length;i++){var otherPath=alternative[i];if(otherPath.length===searchPath.length){for(var j=0;j<otherPath.length;j++){var searchTok=searchPath[j],otherTok=otherPath[j];if(!1===(searchTok===otherTok||void 0!==otherTok.categoryMatchesMap[searchTok.tokenTypeIdx]))continue a}return!0}}return!1}function areTokenCategoriesNotUsed(lookAheadPaths){return utils_1.every(lookAheadPaths,\nfunction(singleAltPaths){return utils_1.every(singleAltPaths,function(singlePath){return utils_1.every(singlePath,function(token){return utils_1.isEmpty(token.categoryMatches)})})})}var __extends=this&&this.__extends||function(){var extendStatics=function(d$jscomp$0,b$jscomp$0){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)Object.prototype.hasOwnProperty.call(b,p)&&(d[p]=b[p])};return extendStatics(d$jscomp$0,b$jscomp$0)};\nreturn function(d,b){function __(){this.constructor=d}if(\"function\"!==typeof b&&null!==b)throw new TypeError(\"Class extends value \"+String(b)+\" is not a constructor or null\");extendStatics(d,b);d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,\"__esModule\",{value:!0});exports.areTokenCategoriesNotUsed=exports.isStrictPrefixOfPath=exports.containsPath=exports.getLookaheadPathsForOptionalProd=exports.getLookaheadPathsForOr=exports.lookAheadSequenceFromAlternatives=\nexports.buildSingleAlternativeLookaheadFunction=exports.buildAlternativesLookAheadFunc=exports.buildLookaheadFuncForOptionalProd=exports.buildLookaheadFuncForOr=exports.getProdType=exports.PROD_TYPE=void 0;var utils_1=require(\"module$node_modules$$chevrotain$utils$lib$src$api\"),interpreter_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$interpreter\");global=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$rest\");var tokens_1=require(\"module$node_modules$chevrotain$lib$src$scan$tokens\"),\ngast_public_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_public\");require=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_visitor_public\");var PROD_TYPE;(function(PROD_TYPE){PROD_TYPE[PROD_TYPE.OPTION=0]=\"OPTION\";PROD_TYPE[PROD_TYPE.REPETITION=1]=\"REPETITION\";PROD_TYPE[PROD_TYPE.REPETITION_MANDATORY=2]=\"REPETITION_MANDATORY\";PROD_TYPE[PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR=3]=\"REPETITION_MANDATORY_WITH_SEPARATOR\";PROD_TYPE[PROD_TYPE.REPETITION_WITH_SEPARATOR=\n4]=\"REPETITION_WITH_SEPARATOR\";PROD_TYPE[PROD_TYPE.ALTERNATION=5]=\"ALTERNATION\"})(PROD_TYPE=exports.PROD_TYPE||(exports.PROD_TYPE={}));exports.getProdType=function(prod){if(prod instanceof gast_public_1.Option)return PROD_TYPE.OPTION;if(prod instanceof gast_public_1.Repetition)return PROD_TYPE.REPETITION;if(prod instanceof gast_public_1.RepetitionMandatory)return PROD_TYPE.REPETITION_MANDATORY;if(prod instanceof gast_public_1.RepetitionMandatoryWithSeparator)return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\nif(prod instanceof gast_public_1.RepetitionWithSeparator)return PROD_TYPE.REPETITION_WITH_SEPARATOR;if(prod instanceof gast_public_1.Alternation)return PROD_TYPE.ALTERNATION;throw Error(\"non exhaustive match\");};exports.buildLookaheadFuncForOr=function(occurrence,ruleGrammar,maxLookahead,hasPredicates,dynamicTokensEnabled,laFuncBuilder){occurrence=getLookaheadPathsForOr(occurrence,ruleGrammar,maxLookahead);ruleGrammar=areTokenCategoriesNotUsed(occurrence)?tokens_1.tokenStructuredMatcherNoCategories:\ntokens_1.tokenStructuredMatcher;return laFuncBuilder(occurrence,hasPredicates,ruleGrammar,dynamicTokensEnabled)};exports.buildLookaheadFuncForOptionalProd=function(occurrence,ruleGrammar,k,dynamicTokensEnabled,prodType,lookaheadBuilder){occurrence=getLookaheadPathsForOptionalProd(occurrence,ruleGrammar,prodType,k);ruleGrammar=areTokenCategoriesNotUsed(occurrence)?tokens_1.tokenStructuredMatcherNoCategories:tokens_1.tokenStructuredMatcher;return lookaheadBuilder(occurrence[0],ruleGrammar,dynamicTokensEnabled)};\nexports.buildAlternativesLookAheadFunc=function(alts,hasPredicates,tokenMatcher,dynamicTokensEnabled){var numOfAlts=alts.length,areAllOneTokenLookahead=utils_1.every(alts,function(currAlt){return utils_1.every(currAlt,function(currPath){return 1===currPath.length})});if(hasPredicates)return function(orAlts){orAlts=utils_1.map(orAlts,function(currAlt){return currAlt.GATE});for(var t=0;t<numOfAlts;t++){var currAlt$jscomp$0=alts[t],currNumOfPaths=currAlt$jscomp$0.length,currPredicate=orAlts[t];if(void 0===\ncurrPredicate||!1!==currPredicate.call(this))a:for(currPredicate=0;currPredicate<currNumOfPaths;currPredicate++){for(var currPath=currAlt$jscomp$0[currPredicate],currPathLength=currPath.length,i=0;i<currPathLength;i++){var nextToken=this.LA(i+1);if(!1===tokenMatcher(nextToken,currPath[i]))continue a}return t}}};if(areAllOneTokenLookahead&&!dynamicTokensEnabled){hasPredicates=utils_1.map(alts,function(currAlt){return utils_1.flatten(currAlt)});var choiceToAlt_1=utils_1.reduce(hasPredicates,function(result,\ncurrAlt,idx){utils_1.forEach(currAlt,function(currTokType){utils_1.has(result,currTokType.tokenTypeIdx)||(result[currTokType.tokenTypeIdx]=idx);utils_1.forEach(currTokType.categoryMatches,function(currExtendingType){utils_1.has(result,currExtendingType)||(result[currExtendingType]=idx)})});return result},[]);return function(){var nextToken=this.LA(1);return choiceToAlt_1[nextToken.tokenTypeIdx]}}return function(){for(var t=0;t<numOfAlts;t++){var currAlt=alts[t],currNumOfPaths=currAlt.length,j=0;a:for(;j<\ncurrNumOfPaths;j++){for(var currPath=currAlt[j],currPathLength=currPath.length,i=0;i<currPathLength;i++){var nextToken=this.LA(i+1);if(!1===tokenMatcher(nextToken,currPath[i]))continue a}return t}}}};exports.buildSingleAlternativeLookaheadFunction=function(alt,tokenMatcher,dynamicTokensEnabled){var areAllOneTokenLookahead=utils_1.every(alt,function(currPath){return 1===currPath.length}),numOfPaths=alt.length;if(areAllOneTokenLookahead&&!dynamicTokensEnabled){dynamicTokensEnabled=utils_1.flatten(alt);\nif(1===dynamicTokensEnabled.length&&utils_1.isEmpty(dynamicTokensEnabled[0].categoryMatches)){var expectedTokenUniqueKey_1=dynamicTokensEnabled[0].tokenTypeIdx;return function(){return this.LA(1).tokenTypeIdx===expectedTokenUniqueKey_1}}var choiceToAlt_2=utils_1.reduce(dynamicTokensEnabled,function(result,currTokType,idx){result[currTokType.tokenTypeIdx]=!0;utils_1.forEach(currTokType.categoryMatches,function(currExtendingType){result[currExtendingType]=!0});return result},[]);return function(){var nextToken=\nthis.LA(1);return!0===choiceToAlt_2[nextToken.tokenTypeIdx]}}return function(){var j=0;a:for(;j<numOfPaths;j++){for(var currPath=alt[j],currPathLength=currPath.length,i=0;i<currPathLength;i++){var nextToken=this.LA(i+1);if(!1===tokenMatcher(nextToken,currPath[i]))continue a}return!0}return!1}};var RestDefinitionFinderWalker=function(_super){function RestDefinitionFinderWalker(topProd,targetOccurrence,targetProdType){var _this=_super.call(this)||this;_this.topProd=topProd;_this.targetOccurrence=targetOccurrence;\n_this.targetProdType=targetProdType;return _this}__extends(RestDefinitionFinderWalker,_super);RestDefinitionFinderWalker.prototype.startWalking=function(){this.walk(this.topProd);return this.restDef};RestDefinitionFinderWalker.prototype.checkIsTarget=function(node,expectedProdType,currRest,prevRest){return node.idx===this.targetOccurrence&&this.targetProdType===expectedProdType?(this.restDef=currRest.concat(prevRest),!0):!1};RestDefinitionFinderWalker.prototype.walkOption=function(optionProd,currRest,\nprevRest){this.checkIsTarget(optionProd,PROD_TYPE.OPTION,currRest,prevRest)||_super.prototype.walkOption.call(this,optionProd,currRest,prevRest)};RestDefinitionFinderWalker.prototype.walkAtLeastOne=function(atLeastOneProd,currRest,prevRest){this.checkIsTarget(atLeastOneProd,PROD_TYPE.REPETITION_MANDATORY,currRest,prevRest)||_super.prototype.walkOption.call(this,atLeastOneProd,currRest,prevRest)};RestDefinitionFinderWalker.prototype.walkAtLeastOneSep=function(atLeastOneSepProd,currRest,prevRest){this.checkIsTarget(atLeastOneSepProd,\nPROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,currRest,prevRest)||_super.prototype.walkOption.call(this,atLeastOneSepProd,currRest,prevRest)};RestDefinitionFinderWalker.prototype.walkMany=function(manyProd,currRest,prevRest){this.checkIsTarget(manyProd,PROD_TYPE.REPETITION,currRest,prevRest)||_super.prototype.walkOption.call(this,manyProd,currRest,prevRest)};RestDefinitionFinderWalker.prototype.walkManySep=function(manySepProd,currRest,prevRest){this.checkIsTarget(manySepProd,PROD_TYPE.REPETITION_WITH_SEPARATOR,\ncurrRest,prevRest)||_super.prototype.walkOption.call(this,manySepProd,currRest,prevRest)};return RestDefinitionFinderWalker}(global.RestWalker),InsideDefinitionFinderVisitor=function(_super){function InsideDefinitionFinderVisitor(targetOccurrence,targetProdType,targetRef){var _this=_super.call(this)||this;_this.targetOccurrence=targetOccurrence;_this.targetProdType=targetProdType;_this.targetRef=targetRef;_this.result=[];return _this}__extends(InsideDefinitionFinderVisitor,_super);InsideDefinitionFinderVisitor.prototype.checkIsTarget=\nfunction(node,expectedProdName){node.idx!==this.targetOccurrence||this.targetProdType!==expectedProdName||void 0!==this.targetRef&&node!==this.targetRef||(this.result=node.definition)};InsideDefinitionFinderVisitor.prototype.visitOption=function(node){this.checkIsTarget(node,PROD_TYPE.OPTION)};InsideDefinitionFinderVisitor.prototype.visitRepetition=function(node){this.checkIsTarget(node,PROD_TYPE.REPETITION)};InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory=function(node){this.checkIsTarget(node,\nPROD_TYPE.REPETITION_MANDATORY)};InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator=function(node){this.checkIsTarget(node,PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)};InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator=function(node){this.checkIsTarget(node,PROD_TYPE.REPETITION_WITH_SEPARATOR)};InsideDefinitionFinderVisitor.prototype.visitAlternation=function(node){this.checkIsTarget(node,PROD_TYPE.ALTERNATION)};return InsideDefinitionFinderVisitor}(require.GAstVisitor);\nexports.lookAheadSequenceFromAlternatives=lookAheadSequenceFromAlternatives;exports.getLookaheadPathsForOr=getLookaheadPathsForOr;exports.getLookaheadPathsForOptionalProd=getLookaheadPathsForOptionalProd;exports.containsPath=containsPath;exports.isStrictPrefixOfPath=function(prefix,other){return prefix.length<other.length&&utils_1.every(prefix,function(tokType,idx){idx=other[idx];return tokType===idx||idx.categoryMatchesMap[tokType.tokenTypeIdx]})};exports.areTokenCategoriesNotUsed=areTokenCategoriesNotUsed}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$parse$grammar$lookahead\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.areTokenCategoriesNotUsed = exports.isStrictPrefixOfPath = exports.containsPath = exports.getLookaheadPathsForOptionalProd = exports.getLookaheadPathsForOr = exports.lookAheadSequenceFromAlternatives = exports.buildSingleAlternativeLookaheadFunction = exports.buildAlternativesLookAheadFunc = exports.buildLookaheadFuncForOptionalProd = exports.buildLookaheadFuncForOr = exports.getProdType = exports.PROD_TYPE = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar interpreter_1 = require(\"./interpreter\");\nvar rest_1 = require(\"./rest\");\nvar tokens_1 = require(\"../../scan/tokens\");\nvar gast_public_1 = require(\"./gast/gast_public\");\nvar gast_visitor_public_1 = require(\"./gast/gast_visitor_public\");\nvar PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n    PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE = exports.PROD_TYPE || (exports.PROD_TYPE = {}));\nfunction getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof gast_public_1.Option) {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof gast_public_1.Repetition) {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof gast_public_1.RepetitionMandatory) {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof gast_public_1.Alternation) {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexports.getProdType = getProdType;\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokens_1.tokenStructuredMatcherNoCategories\n        : tokens_1.tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\nexports.buildLookaheadFuncForOr = buildLookaheadFuncForOr;\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokens_1.tokenStructuredMatcherNoCategories\n        : tokens_1.tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nexports.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    var numOfAlts = alts.length;\n    var areAllOneTokenLookahead = utils_1.every(alts, function (currAlt) {\n        return utils_1.every(currAlt, function (currPath) {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            var predicates = utils_1.map(orAlts, function (currAlt) { return currAlt.GATE; });\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                var currPredicate = predicates[t];\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        var singleTokenAlts = utils_1.map(alts, function (currAlt) {\n            return utils_1.flatten(currAlt);\n        });\n        var choiceToAlt_1 = utils_1.reduce(singleTokenAlts, function (result, currAlt, idx) {\n            utils_1.forEach(currAlt, function (currTokType) {\n                if (!utils_1.has(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                utils_1.forEach(currTokType.categoryMatches, function (currExtendingType) {\n                    if (!utils_1.has(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, []);\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            var nextToken = this.LA(1);\n            return choiceToAlt_1[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (var t = 0; t < numOfAlts; t++) {\n                var currAlt = alts[t];\n                var currNumOfPaths = currAlt.length;\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n                    var currPath = currAlt[j];\n                    var currPathLength = currPath.length;\n                    for (var i = 0; i < currPathLength; i++) {\n                        var nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nexports.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    var areAllOneTokenLookahead = utils_1.every(alt, function (currPath) {\n        return currPath.length === 1;\n    });\n    var numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokensTypes = utils_1.flatten(alt);\n        if (singleTokensTypes.length === 1 &&\n            utils_1.isEmpty(singleTokensTypes[0].categoryMatches)) {\n            var expectedTokenType = singleTokensTypes[0];\n            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n            };\n        }\n        else {\n            var choiceToAlt_2 = utils_1.reduce(singleTokensTypes, function (result, currTokType, idx) {\n                result[currTokType.tokenTypeIdx] = true;\n                utils_1.forEach(currTokType.categoryMatches, function (currExtendingType) {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                var nextToken = this.LA(1);\n                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (var j = 0; j < numOfPaths; j++) {\n                var currPath = alt[j];\n                var currPathLength = currPath.length;\n                for (var i = 0; i < currPathLength; i++) {\n                    var nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nexports.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;\nvar RestDefinitionFinderWalker = /** @class */ (function (_super) {\n    __extends(RestDefinitionFinderWalker, _super);\n    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n        var _this = _super.call(this) || this;\n        _this.topProd = topProd;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        return _this;\n    }\n    RestDefinitionFinderWalker.prototype.startWalking = function () {\n        this.walk(this.topProd);\n        return this.restDef;\n    };\n    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    };\n    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n        }\n    };\n    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n        }\n    };\n    return RestDefinitionFinderWalker;\n}(rest_1.RestWalker));\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nvar InsideDefinitionFinderVisitor = /** @class */ (function (_super) {\n    __extends(InsideDefinitionFinderVisitor, _super);\n    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n        var _this = _super.call(this) || this;\n        _this.targetOccurrence = targetOccurrence;\n        _this.targetProdType = targetProdType;\n        _this.targetRef = targetRef;\n        _this.result = [];\n        return _this;\n    }\n    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    };\n    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    };\n    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    };\n    return InsideDefinitionFinderVisitor;\n}(gast_visitor_public_1.GAstVisitor));\nfunction initializeArrayOfArrays(size) {\n    var result = new Array(size);\n    for (var i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    var keys = [\"\"];\n    for (var i = 0; i < path.length; i++) {\n        var tokType = path[i];\n        var longerKeys = [];\n        for (var j = 0; j < keys.length; j++) {\n            var currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n            for (var t = 0; t < tokType.categoryMatches.length; t++) {\n                var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            var searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n    var partialAlts = utils_1.map(altsDefs, function (currAlt) {\n        return interpreter_1.possiblePathsFrom([currAlt], 1);\n    });\n    var finalResult = initializeArrayOfArrays(partialAlts.length);\n    var altsHashes = utils_1.map(partialAlts, function (currAltPaths) {\n        var dict = {};\n        utils_1.forEach(currAltPaths, function (item) {\n            var keys = pathToHashKeys(item.partialPath);\n            utils_1.forEach(keys, function (currKey) {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    var newData = partialAlts;\n    // maxLookahead loop\n    for (var pathLength = 1; pathLength <= k; pathLength++) {\n        var currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        var _loop_1 = function (altIdx) {\n            var currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                var prefixKeys = pathToHashKeys(currPathPrefix);\n                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique || utils_1.isEmpty(suffixDef) || currPathPrefix.length === k) {\n                    var currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (var j = 0; j < prefixKeys.length; j++) {\n                            var currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    var newPartialPathsAndSuffixes = interpreter_1.possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    utils_1.forEach(newPartialPathsAndSuffixes, function (item) {\n                        var prefixKeys = pathToHashKeys(item.partialPath);\n                        utils_1.forEach(prefixKeys, function (key) {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        };\n        // alternatives loop\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            _loop_1(altIdx);\n        }\n    }\n    return finalResult;\n}\nexports.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nexports.getLookaheadPathsForOr = getLookaheadPathsForOr;\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    var insideDef = insideDefVisitor.result;\n    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    var afterDef = afterDefWalker.startWalking();\n    var insideFlat = new gast_public_1.Alternative({ definition: insideDef });\n    var afterFlat = new gast_public_1.Alternative({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nexports.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;\nfunction containsPath(alternative, searchPath) {\n    compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n        var otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (var j = 0; j < otherPath.length; j++) {\n            var searchTok = searchPath[j];\n            var otherTok = otherPath[j];\n            var matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nexports.containsPath = containsPath;\nfunction isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        utils_1.every(prefix, function (tokType, idx) {\n            var otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nexports.isStrictPrefixOfPath = isStrictPrefixOfPath;\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n    return utils_1.every(lookAheadPaths, function (singleAltPaths) {\n        return utils_1.every(singleAltPaths, function (singlePath) {\n            return utils_1.every(singlePath, function (token) { return utils_1.isEmpty(token.categoryMatches); });\n        });\n    });\n}\nexports.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;\n//# sourceMappingURL=lookahead.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$chevrotain$utils$lib$src$api","~$module$node_modules$chevrotain$lib$src$parse$grammar$interpreter","~$module$node_modules$chevrotain$lib$src$scan$tokens","~$shadow.js","~$module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_public","~$module$node_modules$chevrotain$lib$src$parse$grammar$rest","~$module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_visitor_public"]],"~:properties",["^5",["getProdType","buildLookaheadFuncForOptionalProd","targetProdType","getLookaheadPathsForOr","visitRepetition","targetOccurrence","buildSingleAlternativeLookaheadFunction","walkAtLeastOneSep","walkMany","getLookaheadPathsForOptionalProd","prototype","walkManySep","containsPath","visitRepetitionMandatoryWithSeparator","__esModule","walkAtLeastOne","areTokenCategoriesNotUsed","value","restDef","targetRef","visitAlternation","lookAheadSequenceFromAlternatives","visitOption","definition","visitRepetitionWithSeparator","__proto__","startWalking","buildLookaheadFuncForOr","checkIsTarget","visitRepetitionMandatory","isStrictPrefixOfPath","walkOption","buildAlternativesLookAheadFunc","PROD_TYPE","result","constructor","topProd"]],"~:compiled-at",1630917515695,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$parse$grammar$lookahead.js\",\n\"lineCount\":27,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/chevrotain/lib/src/parse/grammar/lookahead.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$parse$grammar$lookahead\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        if (typeof b !== \\\"function\\\" && b !== null)\\n            throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.areTokenCategoriesNotUsed = exports.isStrictPrefixOfPath = exports.containsPath = exports.getLookaheadPathsForOptionalProd = exports.getLookaheadPathsForOr = exports.lookAheadSequenceFromAlternatives = exports.buildSingleAlternativeLookaheadFunction = exports.buildAlternativesLookAheadFunc = exports.buildLookaheadFuncForOptionalProd = exports.buildLookaheadFuncForOr = exports.getProdType = exports.PROD_TYPE = void 0;\\nvar utils_1 = require(\\\"@chevrotain/utils\\\");\\nvar interpreter_1 = require(\\\"./interpreter\\\");\\nvar rest_1 = require(\\\"./rest\\\");\\nvar tokens_1 = require(\\\"../../scan/tokens\\\");\\nvar gast_public_1 = require(\\\"./gast/gast_public\\\");\\nvar gast_visitor_public_1 = require(\\\"./gast/gast_visitor_public\\\");\\nvar PROD_TYPE;\\n(function (PROD_TYPE) {\\n    PROD_TYPE[PROD_TYPE[\\\"OPTION\\\"] = 0] = \\\"OPTION\\\";\\n    PROD_TYPE[PROD_TYPE[\\\"REPETITION\\\"] = 1] = \\\"REPETITION\\\";\\n    PROD_TYPE[PROD_TYPE[\\\"REPETITION_MANDATORY\\\"] = 2] = \\\"REPETITION_MANDATORY\\\";\\n    PROD_TYPE[PROD_TYPE[\\\"REPETITION_MANDATORY_WITH_SEPARATOR\\\"] = 3] = \\\"REPETITION_MANDATORY_WITH_SEPARATOR\\\";\\n    PROD_TYPE[PROD_TYPE[\\\"REPETITION_WITH_SEPARATOR\\\"] = 4] = \\\"REPETITION_WITH_SEPARATOR\\\";\\n    PROD_TYPE[PROD_TYPE[\\\"ALTERNATION\\\"] = 5] = \\\"ALTERNATION\\\";\\n})(PROD_TYPE = exports.PROD_TYPE || (exports.PROD_TYPE = {}));\\nfunction getProdType(prod) {\\n    /* istanbul ignore else */\\n    if (prod instanceof gast_public_1.Option) {\\n        return PROD_TYPE.OPTION;\\n    }\\n    else if (prod instanceof gast_public_1.Repetition) {\\n        return PROD_TYPE.REPETITION;\\n    }\\n    else if (prod instanceof gast_public_1.RepetitionMandatory) {\\n        return PROD_TYPE.REPETITION_MANDATORY;\\n    }\\n    else if (prod instanceof gast_public_1.RepetitionMandatoryWithSeparator) {\\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\\n    }\\n    else if (prod instanceof gast_public_1.RepetitionWithSeparator) {\\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\\n    }\\n    else if (prod instanceof gast_public_1.Alternation) {\\n        return PROD_TYPE.ALTERNATION;\\n    }\\n    else {\\n        throw Error(\\\"non exhaustive match\\\");\\n    }\\n}\\nexports.getProdType = getProdType;\\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\\n    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\\n        ? tokens_1.tokenStructuredMatcherNoCategories\\n        : tokens_1.tokenStructuredMatcher;\\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\\n}\\nexports.buildLookaheadFuncForOr = buildLookaheadFuncForOr;\\n/**\\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\\n *  the lookahead \\\"inside\\\" the production and the lookahead immediately \\\"after\\\" it in the same top level rule (context free).\\n *\\n *  Example: given a production:\\n *  ABC(DE)?DF\\n *\\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\\n *  alternatives.\\n *\\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\\n */\\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\\n    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\\n    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\\n        ? tokens_1.tokenStructuredMatcherNoCategories\\n        : tokens_1.tokenStructuredMatcher;\\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\\n}\\nexports.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;\\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\\n    var numOfAlts = alts.length;\\n    var areAllOneTokenLookahead = utils_1.every(alts, function (currAlt) {\\n        return utils_1.every(currAlt, function (currPath) {\\n            return currPath.length === 1;\\n        });\\n    });\\n    // This version takes into account the predicates as well.\\n    if (hasPredicates) {\\n        /**\\n         * @returns {number} - The chosen alternative index\\n         */\\n        return function (orAlts) {\\n            // unfortunately the predicates must be extracted every single time\\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\\n            var predicates = utils_1.map(orAlts, function (currAlt) { return currAlt.GATE; });\\n            for (var t = 0; t < numOfAlts; t++) {\\n                var currAlt = alts[t];\\n                var currNumOfPaths = currAlt.length;\\n                var currPredicate = predicates[t];\\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\\n                    // if the predicate does not match there is no point in checking the paths\\n                    continue;\\n                }\\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\\n                    var currPath = currAlt[j];\\n                    var currPathLength = currPath.length;\\n                    for (var i = 0; i < currPathLength; i++) {\\n                        var nextToken = this.LA(i + 1);\\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\\n                            // mismatch in current path\\n                            // try the next pth\\n                            continue nextPath;\\n                        }\\n                    }\\n                    // found a full path that matches.\\n                    // this will also work for an empty ALT as the loop will be skipped\\n                    return t;\\n                }\\n                // none of the paths for the current alternative matched\\n                // try the next alternative\\n            }\\n            // none of the alternatives could be matched\\n            return undefined;\\n        };\\n    }\\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\\n        // optimized (common) case of all the lookaheads paths requiring only\\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\\n        var singleTokenAlts = utils_1.map(alts, function (currAlt) {\\n            return utils_1.flatten(currAlt);\\n        });\\n        var choiceToAlt_1 = utils_1.reduce(singleTokenAlts, function (result, currAlt, idx) {\\n            utils_1.forEach(currAlt, function (currTokType) {\\n                if (!utils_1.has(result, currTokType.tokenTypeIdx)) {\\n                    result[currTokType.tokenTypeIdx] = idx;\\n                }\\n                utils_1.forEach(currTokType.categoryMatches, function (currExtendingType) {\\n                    if (!utils_1.has(result, currExtendingType)) {\\n                        result[currExtendingType] = idx;\\n                    }\\n                });\\n            });\\n            return result;\\n        }, []);\\n        /**\\n         * @returns {number} - The chosen alternative index\\n         */\\n        return function () {\\n            var nextToken = this.LA(1);\\n            return choiceToAlt_1[nextToken.tokenTypeIdx];\\n        };\\n    }\\n    else {\\n        // optimized lookahead without needing to check the predicates at all.\\n        // this causes code duplication which is intentional to improve performance.\\n        /**\\n         * @returns {number} - The chosen alternative index\\n         */\\n        return function () {\\n            for (var t = 0; t < numOfAlts; t++) {\\n                var currAlt = alts[t];\\n                var currNumOfPaths = currAlt.length;\\n                nextPath: for (var j = 0; j < currNumOfPaths; j++) {\\n                    var currPath = currAlt[j];\\n                    var currPathLength = currPath.length;\\n                    for (var i = 0; i < currPathLength; i++) {\\n                        var nextToken = this.LA(i + 1);\\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\\n                            // mismatch in current path\\n                            // try the next pth\\n                            continue nextPath;\\n                        }\\n                    }\\n                    // found a full path that matches.\\n                    // this will also work for an empty ALT as the loop will be skipped\\n                    return t;\\n                }\\n                // none of the paths for the current alternative matched\\n                // try the next alternative\\n            }\\n            // none of the alternatives could be matched\\n            return undefined;\\n        };\\n    }\\n}\\nexports.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;\\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\\n    var areAllOneTokenLookahead = utils_1.every(alt, function (currPath) {\\n        return currPath.length === 1;\\n    });\\n    var numOfPaths = alt.length;\\n    // optimized (common) case of all the lookaheads paths requiring only\\n    // a single token lookahead.\\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\\n        var singleTokensTypes = utils_1.flatten(alt);\\n        if (singleTokensTypes.length === 1 &&\\n            utils_1.isEmpty(singleTokensTypes[0].categoryMatches)) {\\n            var expectedTokenType = singleTokensTypes[0];\\n            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\\n            return function () {\\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\\n            };\\n        }\\n        else {\\n            var choiceToAlt_2 = utils_1.reduce(singleTokensTypes, function (result, currTokType, idx) {\\n                result[currTokType.tokenTypeIdx] = true;\\n                utils_1.forEach(currTokType.categoryMatches, function (currExtendingType) {\\n                    result[currExtendingType] = true;\\n                });\\n                return result;\\n            }, []);\\n            return function () {\\n                var nextToken = this.LA(1);\\n                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\\n            };\\n        }\\n    }\\n    else {\\n        return function () {\\n            nextPath: for (var j = 0; j < numOfPaths; j++) {\\n                var currPath = alt[j];\\n                var currPathLength = currPath.length;\\n                for (var i = 0; i < currPathLength; i++) {\\n                    var nextToken = this.LA(i + 1);\\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\\n                        // mismatch in current path\\n                        // try the next pth\\n                        continue nextPath;\\n                    }\\n                }\\n                // found a full path that matches.\\n                return true;\\n            }\\n            // none of the paths matched\\n            return false;\\n        };\\n    }\\n}\\nexports.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;\\nvar RestDefinitionFinderWalker = /** @class */ (function (_super) {\\n    __extends(RestDefinitionFinderWalker, _super);\\n    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\\n        var _this = _super.call(this) || this;\\n        _this.topProd = topProd;\\n        _this.targetOccurrence = targetOccurrence;\\n        _this.targetProdType = targetProdType;\\n        return _this;\\n    }\\n    RestDefinitionFinderWalker.prototype.startWalking = function () {\\n        this.walk(this.topProd);\\n        return this.restDef;\\n    };\\n    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\\n        if (node.idx === this.targetOccurrence &&\\n            this.targetProdType === expectedProdType) {\\n            this.restDef = currRest.concat(prevRest);\\n            return true;\\n        }\\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\\n        return false;\\n    };\\n    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\\n            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\\n        }\\n    };\\n    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\\n            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\\n        }\\n    };\\n    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\\n            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\\n        }\\n    };\\n    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\\n            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\\n        }\\n    };\\n    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\\n            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\\n        }\\n    };\\n    return RestDefinitionFinderWalker;\\n}(rest_1.RestWalker));\\n/**\\n * Returns the definition of a target production in a top level level rule.\\n */\\nvar InsideDefinitionFinderVisitor = /** @class */ (function (_super) {\\n    __extends(InsideDefinitionFinderVisitor, _super);\\n    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\\n        var _this = _super.call(this) || this;\\n        _this.targetOccurrence = targetOccurrence;\\n        _this.targetProdType = targetProdType;\\n        _this.targetRef = targetRef;\\n        _this.result = [];\\n        return _this;\\n    }\\n    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\\n        if (node.idx === this.targetOccurrence &&\\n            this.targetProdType === expectedProdName &&\\n            (this.targetRef === undefined || node === this.targetRef)) {\\n            this.result = node.definition;\\n        }\\n    };\\n    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\\n    };\\n    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\\n    };\\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\\n    };\\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\\n    };\\n    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\\n    };\\n    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\\n    };\\n    return InsideDefinitionFinderVisitor;\\n}(gast_visitor_public_1.GAstVisitor));\\nfunction initializeArrayOfArrays(size) {\\n    var result = new Array(size);\\n    for (var i = 0; i < size; i++) {\\n        result[i] = [];\\n    }\\n    return result;\\n}\\n/**\\n * A sort of hash function between a Path in the grammar and a string.\\n * Note that this returns multiple \\\"hashes\\\" to support the scenario of token categories.\\n * -  A single path with categories may match multiple **actual** paths.\\n */\\nfunction pathToHashKeys(path) {\\n    var keys = [\\\"\\\"];\\n    for (var i = 0; i < path.length; i++) {\\n        var tokType = path[i];\\n        var longerKeys = [];\\n        for (var j = 0; j < keys.length; j++) {\\n            var currShorterKey = keys[j];\\n            longerKeys.push(currShorterKey + \\\"_\\\" + tokType.tokenTypeIdx);\\n            for (var t = 0; t < tokType.categoryMatches.length; t++) {\\n                var categoriesKeySuffix = \\\"_\\\" + tokType.categoryMatches[t];\\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\\n            }\\n        }\\n        keys = longerKeys;\\n    }\\n    return keys;\\n}\\n/**\\n * Imperative style due to being called from a hot spot\\n */\\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\\n    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\\n        // We only want to test vs the other alternatives\\n        if (currAltIdx === idx) {\\n            continue;\\n        }\\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\\n            var searchKey = searchPathKeys[searchIdx];\\n            if (otherAltKnownPathsKeys[searchKey] === true) {\\n                return false;\\n            }\\n        }\\n    }\\n    // None of the SearchPathKeys were found in any of the other alternatives\\n    return true;\\n}\\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\\n    var partialAlts = utils_1.map(altsDefs, function (currAlt) {\\n        return interpreter_1.possiblePathsFrom([currAlt], 1);\\n    });\\n    var finalResult = initializeArrayOfArrays(partialAlts.length);\\n    var altsHashes = utils_1.map(partialAlts, function (currAltPaths) {\\n        var dict = {};\\n        utils_1.forEach(currAltPaths, function (item) {\\n            var keys = pathToHashKeys(item.partialPath);\\n            utils_1.forEach(keys, function (currKey) {\\n                dict[currKey] = true;\\n            });\\n        });\\n        return dict;\\n    });\\n    var newData = partialAlts;\\n    // maxLookahead loop\\n    for (var pathLength = 1; pathLength <= k; pathLength++) {\\n        var currDataset = newData;\\n        newData = initializeArrayOfArrays(currDataset.length);\\n        var _loop_1 = function (altIdx) {\\n            var currAltPathsAndSuffixes = currDataset[altIdx];\\n            // paths in current alternative loop\\n            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\\n                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\\n                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\\n                var prefixKeys = pathToHashKeys(currPathPrefix);\\n                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\\n                // End of the line for this path.\\n                if (isUnique || utils_1.isEmpty(suffixDef) || currPathPrefix.length === k) {\\n                    var currAltResult = finalResult[altIdx];\\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\\n                        currAltResult.push(currPathPrefix);\\n                        // Update all new  keys for the current path.\\n                        for (var j = 0; j < prefixKeys.length; j++) {\\n                            var currKey = prefixKeys[j];\\n                            altsHashes[altIdx][currKey] = true;\\n                        }\\n                    }\\n                }\\n                // Expand longer paths\\n                else {\\n                    var newPartialPathsAndSuffixes = interpreter_1.possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\\n                    // Update keys for new known paths\\n                    utils_1.forEach(newPartialPathsAndSuffixes, function (item) {\\n                        var prefixKeys = pathToHashKeys(item.partialPath);\\n                        utils_1.forEach(prefixKeys, function (key) {\\n                            altsHashes[altIdx][key] = true;\\n                        });\\n                    });\\n                }\\n            }\\n        };\\n        // alternatives loop\\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\\n            _loop_1(altIdx);\\n        }\\n    }\\n    return finalResult;\\n}\\nexports.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;\\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\\n    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\\n    ruleGrammar.accept(visitor);\\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\\n}\\nexports.getLookaheadPathsForOr = getLookaheadPathsForOr;\\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\\n    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\\n    ruleGrammar.accept(insideDefVisitor);\\n    var insideDef = insideDefVisitor.result;\\n    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\\n    var afterDef = afterDefWalker.startWalking();\\n    var insideFlat = new gast_public_1.Alternative({ definition: insideDef });\\n    var afterFlat = new gast_public_1.Alternative({ definition: afterDef });\\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\\n}\\nexports.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;\\nfunction containsPath(alternative, searchPath) {\\n    compareOtherPath: for (var i = 0; i < alternative.length; i++) {\\n        var otherPath = alternative[i];\\n        if (otherPath.length !== searchPath.length) {\\n            continue;\\n        }\\n        for (var j = 0; j < otherPath.length; j++) {\\n            var searchTok = searchPath[j];\\n            var otherTok = otherPath[j];\\n            var matchingTokens = searchTok === otherTok ||\\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\\n            if (matchingTokens === false) {\\n                continue compareOtherPath;\\n            }\\n        }\\n        return true;\\n    }\\n    return false;\\n}\\nexports.containsPath = containsPath;\\nfunction isStrictPrefixOfPath(prefix, other) {\\n    return (prefix.length < other.length &&\\n        utils_1.every(prefix, function (tokType, idx) {\\n            var otherTokType = other[idx];\\n            return (tokType === otherTokType ||\\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\\n        }));\\n}\\nexports.isStrictPrefixOfPath = isStrictPrefixOfPath;\\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\\n    return utils_1.every(lookAheadPaths, function (singleAltPaths) {\\n        return utils_1.every(singleAltPaths, function (singlePath) {\\n            return utils_1.every(singlePath, function (token) { return utils_1.isEmpty(token.categoryMatches); });\\n        });\\n    });\\n}\\nexports.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;\\n//# sourceMappingURL=lookahead.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"initializeArrayOfArrays\",\"size\",\"result\",\"Array\",\"i\",\"pathToHashKeys\",\"path\",\"keys\",\"length\",\"tokType\",\"longerKeys\",\"j\",\"currShorterKey\",\"push\",\"tokenTypeIdx\",\"t\",\"categoryMatches\",\"isUniquePrefixHash\",\"altKnownPathsKeys\",\"searchPathKeys\",\"idx\",\"currAltIdx\",\"otherAltKnownPathsKeys\",\"searchIdx\",\"searchKey\",\"lookAheadSequenceFromAlternatives\",\"altsDefs\",\"k\",\"partialAlts\",\"utils_1\",\"map\",\"currAlt\",\"interpreter_1\",\"possiblePathsFrom\",\"finalResult\",\"altsHashes\",\"currAltPaths\",\"dict\",\"forEach\",\"item\",\"partialPath\",\"currKey\",\"newData\",\"pathLength\",\"currDataset\",\"_loop_1\",\"altIdx\",\"currAltPathsAndSuffixes\",\"currPathIdx\",\"currPathPrefix\",\"suffixDef\",\"prefixKeys\",\"isUnique\",\"isEmpty\",\"currAltResult\",\"containsPath\",\"newPartialPathsAndSuffixes\",\"concat\",\"key\",\"getLookaheadPathsForOr\",\"occurrence\",\"ruleGrammar\",\"orProd\",\"visitor\",\"InsideDefinitionFinderVisitor\",\"PROD_TYPE\",\"ALTERNATION\",\"accept\",\"getLookaheadPathsForOptionalProd\",\"prodType\",\"insideDefVisitor\",\"insideDef\",\"afterDef\",\"startWalking\",\"afterDefWalker\",\"RestDefinitionFinderWalker\",\"insideFlat\",\"gast_public_1\",\"Alternative\",\"definition\",\"afterFlat\",\"alternative\",\"searchPath\",\"otherPath\",\"searchTok\",\"otherTok\",\"undefined\",\"categoryMatchesMap\",\"areTokenCategoriesNotUsed\",\"lookAheadPaths\",\"every\",\"singleAltPaths\",\"singlePath\",\"token\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"Object\",\"setPrototypeOf\",\"__proto__\",\"p\",\"prototype\",\"hasOwnProperty\",\"call\",\"__\",\"constructor\",\"TypeError\",\"String\",\"create\",\"defineProperty\",\"value\",\"isStrictPrefixOfPath\",\"buildSingleAlternativeLookaheadFunction\",\"buildAlternativesLookAheadFunc\",\"buildLookaheadFuncForOptionalProd\",\"buildLookaheadFuncForOr\",\"getProdType\",\"rest_1\",\"tokens_1\",\"gast_visitor_public_1\",\"prod\",\"Option\",\"OPTION\",\"Repetition\",\"REPETITION\",\"RepetitionMandatory\",\"REPETITION_MANDATORY\",\"RepetitionMandatoryWithSeparator\",\"REPETITION_MANDATORY_WITH_SEPARATOR\",\"RepetitionWithSeparator\",\"REPETITION_WITH_SEPARATOR\",\"Alternation\",\"Error\",\"maxLookahead\",\"hasPredicates\",\"dynamicTokensEnabled\",\"laFuncBuilder\",\"tokenMatcher\",\"tokenStructuredMatcherNoCategories\",\"tokenStructuredMatcher\",\"lookaheadBuilder\",\"alts\",\"numOfAlts\",\"areAllOneTokenLookahead\",\"currPath\",\"orAlts\",\"predicates\",\"GATE\",\"currNumOfPaths\",\"currPredicate\",\"currPathLength\",\"nextToken\",\"LA\",\"singleTokenAlts\",\"flatten\",\"choiceToAlt_1\",\"reduce\",\"currTokType\",\"has\",\"currExtendingType\",\"alt\",\"numOfPaths\",\"singleTokensTypes\",\"expectedTokenUniqueKey_1\",\"expectedTokenType\",\"choiceToAlt_2\",\"_super\",\"topProd\",\"targetOccurrence\",\"targetProdType\",\"_this\",\"RestDefinitionFinderWalker.prototype.startWalking\",\"walk\",\"restDef\",\"checkIsTarget\",\"RestDefinitionFinderWalker.prototype.checkIsTarget\",\"node\",\"expectedProdType\",\"currRest\",\"prevRest\",\"walkOption\",\"RestDefinitionFinderWalker.prototype.walkOption\",\"optionProd\",\"walkAtLeastOne\",\"RestDefinitionFinderWalker.prototype.walkAtLeastOne\",\"atLeastOneProd\",\"walkAtLeastOneSep\",\"RestDefinitionFinderWalker.prototype.walkAtLeastOneSep\",\"atLeastOneSepProd\",\"walkMany\",\"RestDefinitionFinderWalker.prototype.walkMany\",\"manyProd\",\"walkManySep\",\"RestDefinitionFinderWalker.prototype.walkManySep\",\"manySepProd\",\"RestWalker\",\"targetRef\",\"InsideDefinitionFinderVisitor.prototype.checkIsTarget\",\"expectedProdName\",\"visitOption\",\"InsideDefinitionFinderVisitor.prototype.visitOption\",\"visitRepetition\",\"InsideDefinitionFinderVisitor.prototype.visitRepetition\",\"visitRepetitionMandatory\",\"InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory\",\"visitRepetitionMandatoryWithSeparator\",\"InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator\",\"visitRepetitionWithSeparator\",\"InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator\",\"visitAlternation\",\"InsideDefinitionFinderVisitor.prototype.visitAlternation\",\"GAstVisitor\",\"prefix\",\"other\",\"otherTokType\"]\n}\n"]