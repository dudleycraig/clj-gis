["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/geometries/LightningStrike.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$geometries$LightningStrike=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=\ndescriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _get(target$jscomp$0,property$jscomp$0,receiver$jscomp$0){_get=\"undefined\"!==typeof Reflect&&Reflect.get?Reflect.get:function(target,property,\nreceiver){for(;!Object.prototype.hasOwnProperty.call(target,property)&&(target=_getPrototypeOf(target),null!==target););if(target)return property=Object.getOwnPropertyDescriptor(target,property),property.get?property.get.call(receiver):property.value};return _get(target$jscomp$0,property$jscomp$0,receiver$jscomp$0||target$jscomp$0)}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}\nfunction _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,\np$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.LightningStrike=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_SimplexNoise=require(\"module$node_modules$three_stdlib$math$SimplexNoise\");global=function(_BufferGeometry){function LightningStrike(rayParameters){if(!(this instanceof LightningStrike))throw new TypeError(\"Cannot call a class as a function\");var _this=_getPrototypeOf(LightningStrike).call(this);if(!_this||\"object\"!==_typeof(_this)&&\n\"function\"!==typeof _this){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");_this=this}_this.type=\"LightningStrike\";rayParameters=rayParameters||{};_this.init(LightningStrike.copyParameters(rayParameters,rayParameters));_this.createMesh();return _this}_inherits(LightningStrike,_BufferGeometry);_createClass(LightningStrike,[{key:\"update\",value:function(time){this.isStatic||(this.rayParameters.isEternal||this.rayParameters.birthTime<=time&&time<=\nthis.rayParameters.deathTime?(this.updateMesh(time),this.state=time<this.subrays[0].endPropagationTime?LightningStrike.RAY_PROPAGATING:time>this.subrays[0].beginVanishingTime?LightningStrike.RAY_VANISHING:LightningStrike.RAY_STEADY,this.visible=!0):(this.visible=!1,this.state=time<this.rayParameters.birthTime?LightningStrike.RAY_UNBORN:LightningStrike.RAY_EXTINGUISHED))}},{key:\"init\",value:function(rayParameters){this.rayParameters=rayParameters;this.maxIterations=void 0!==rayParameters.maxIterations?\nMath.floor(rayParameters.maxIterations):9;rayParameters.maxIterations=this.maxIterations;this.isStatic=void 0!==rayParameters.isStatic?rayParameters.isStatic:!1;rayParameters.isStatic=this.isStatic;this.ramification=void 0!==rayParameters.ramification?Math.floor(rayParameters.ramification):5;rayParameters.ramification=this.ramification;this.maxSubrayRecursion=void 0!==rayParameters.maxSubrayRecursion?Math.floor(rayParameters.maxSubrayRecursion):3;rayParameters.maxSubrayRecursion=this.maxSubrayRecursion;\nthis.recursionProbability=void 0!==rayParameters.recursionProbability?rayParameters.recursionProbability:.6;rayParameters.recursionProbability=this.recursionProbability;this.generateUVs=void 0!==rayParameters.generateUVs?rayParameters.generateUVs:!1;rayParameters.generateUVs=this.generateUVs;void 0!==rayParameters.randomGenerator?(this.seedGenerator=this.randomGenerator=rayParameters.randomGenerator,void 0!==rayParameters.noiseSeed&&this.seedGenerator.setSeed(rayParameters.noiseSeed)):(this.randomGenerator=\nLightningStrike.createRandomGenerator(),this.seedGenerator=Math);void 0!==rayParameters.onDecideSubrayCreation?this.onDecideSubrayCreation=rayParameters.onDecideSubrayCreation:(this.createDefaultSubrayCreationCallbacks(),void 0!==rayParameters.onSubrayCreation&&(this.onSubrayCreation=rayParameters.onSubrayCreation));this.state=LightningStrike.RAY_INITIALIZED;this.maxSubrays=Math.ceil(1+Math.pow(this.ramification,Math.max(0,this.maxSubrayRecursion-1)));rayParameters.maxSubrays=this.maxSubrays;this.maxRaySegments=\n2*(1<<this.maxIterations);this.subrays=[];for(rayParameters=0;rayParameters<this.maxSubrays;rayParameters++)this.subrays.push(this.createSubray());this.raySegments=[];for(rayParameters=0;rayParameters<this.maxRaySegments;rayParameters++)this.raySegments.push(this.createSegment());this.timeFraction=this.time=0;this.currentSegmentCallback=null;this.currentCreateTriangleVertices=this.generateUVs?this.createTriangleVerticesWithUVs:this.createTriangleVerticesWithoutUVs;this.numSubrays=0;this.currentSubray=\nnull;this.currentSegmentIndex=0;this.isInitialSegment=!1;this.currentUVCoordinate=this.currentCoordinate=this.currentIndex=this.currentVertex=this.subrayProbability=0;this.uvsAttribute=this.positionAttribute=this.indices=this.uvs=this.vertices=null;this.simplexX=new _SimplexNoise.SimplexNoise(this.seedGenerator);this.simplexY=new _SimplexNoise.SimplexNoise(this.seedGenerator);this.simplexZ=new _SimplexNoise.SimplexNoise(this.seedGenerator);this.forwards=new _three.Vector3;this.forwardsFill=new _three.Vector3;\nthis.side=new _three.Vector3;this.down=new _three.Vector3;this.middlePos=new _three.Vector3;this.middleLinPos=new _three.Vector3;this.newPos=new _three.Vector3;this.vPos=new _three.Vector3;this.cross1=new _three.Vector3}},{key:\"createMesh\",value:function(){var maxDrawableSegmentsPerSubRay=1<<this.maxIterations,maxVerts=3*(maxDrawableSegmentsPerSubRay+1)*this.maxSubrays;maxDrawableSegmentsPerSubRay=18*maxDrawableSegmentsPerSubRay*this.maxSubrays;this.vertices=new Float32Array(3*maxVerts);this.indices=\nnew Uint32Array(maxDrawableSegmentsPerSubRay);this.generateUVs&&(this.uvs=new Float32Array(2*maxVerts));this.fillMesh(0);this.setIndex(new _three.Uint32BufferAttribute(this.indices,1));this.positionAttribute=new _three.Float32BufferAttribute(this.vertices,3);this.setAttribute(\"position\",this.positionAttribute);this.generateUVs&&(this.uvsAttribute=new _three.Float32BufferAttribute(new Float32Array(this.uvs),2),this.setAttribute(\"uv\",this.uvsAttribute));this.isStatic||(this.index.usage=_three.DynamicDrawUsage,\nthis.positionAttribute.usage=_three.DynamicDrawUsage,this.generateUVs&&(this.uvsAttribute.usage=_three.DynamicDrawUsage));this.vertices=this.positionAttribute.array;this.indices=this.index.array;this.generateUVs&&(this.uvs=this.uvsAttribute.array)}},{key:\"updateMesh\",value:function(time){this.fillMesh(time);this.drawRange.count=this.currentIndex;this.index.needsUpdate=!0;this.positionAttribute.needsUpdate=!0;this.generateUVs&&(this.uvsAttribute.needsUpdate=!0)}},{key:\"fillMesh\",value:function(time){var scope=\nthis;this.currentUVCoordinate=this.currentCoordinate=this.currentIndex=this.currentVertex=0;this.fractalRay(time,function(segment){var subray=scope.currentSubray;time<subray.birthTime||(this.rayParameters.isEternal&&0==scope.currentSubray.recursion?(scope.createPrism(segment),scope.onDecideSubrayCreation(segment,scope)):time<subray.endPropagationTime?scope.timeFraction>=segment.fraction0*subray.propagationTimeFactor&&(scope.createPrism(segment),scope.onDecideSubrayCreation(segment,scope)):(time<subray.beginVanishingTime?\nscope.createPrism(segment):scope.timeFraction<=subray.vanishingTimeFactor+segment.fraction1*(1-subray.vanishingTimeFactor)&&scope.createPrism(segment),scope.onDecideSubrayCreation(segment,scope)))})}},{key:\"addNewSubray\",value:function(){return this.subrays[this.numSubrays++]}},{key:\"initSubray\",value:function(subray,rayParameters){subray.pos0.copy(rayParameters.sourceOffset);subray.pos1.copy(rayParameters.destOffset);subray.up0.copy(rayParameters.up0);subray.up1.copy(rayParameters.up1);subray.radius0=\nrayParameters.radius0;subray.radius1=rayParameters.radius1;subray.birthTime=rayParameters.birthTime;subray.deathTime=rayParameters.deathTime;subray.timeScale=rayParameters.timeScale;subray.roughness=rayParameters.roughness;subray.straightness=rayParameters.straightness;subray.propagationTimeFactor=rayParameters.propagationTimeFactor;subray.vanishingTimeFactor=rayParameters.vanishingTimeFactor;subray.maxIterations=this.maxIterations;subray.seed=void 0!==rayParameters.noiseSeed?rayParameters.noiseSeed:\n0;subray.recursion=0}},{key:\"fractalRay\",value:function(time,segmentCallback){this.time=time;this.currentSegmentCallback=segmentCallback;this.numSubrays=0;this.initSubray(this.addNewSubray(),this.rayParameters);for(segmentCallback=0;segmentCallback<this.numSubrays;segmentCallback++){var subray=this.subrays[segmentCallback];this.currentSubray=subray;this.randomGenerator.setSeed(subray.seed);subray.endPropagationTime=_three.MathUtils.lerp(subray.birthTime,subray.deathTime,subray.propagationTimeFactor);\nsubray.beginVanishingTime=_three.MathUtils.lerp(subray.deathTime,subray.birthTime,1-subray.vanishingTimeFactor);var random1=this.randomGenerator.random;subray.linPos0.set(random1(),random1(),random1()).multiplyScalar(1E3);subray.linPos1.set(random1(),random1(),random1()).multiplyScalar(1E3);this.timeFraction=(time-subray.birthTime)/(subray.deathTime-subray.birthTime);this.currentSegmentIndex=0;this.isInitialSegment=!0;random1=this.getNewSegment();random1.iteration=0;random1.pos0.copy(subray.pos0);\nrandom1.pos1.copy(subray.pos1);random1.linPos0.copy(subray.linPos0);random1.linPos1.copy(subray.linPos1);random1.up0.copy(subray.up0);random1.up1.copy(subray.up1);random1.radius0=subray.radius0;random1.radius1=subray.radius1;random1.fraction0=0;random1.fraction1=1;random1.positionVariationFactor=1-subray.straightness;this.subrayProbability=this.ramification*Math.pow(this.recursionProbability,subray.recursion)/(1<<subray.maxIterations);this.fractalRayRecursive(random1)}this.currentSubray=this.currentSegmentCallback=\nnull}},{key:\"fractalRayRecursive\",value:function(segment){if(segment.iteration>=this.currentSubray.maxIterations)this.currentSegmentCallback(segment);else{this.forwards.subVectors(segment.pos1,segment.pos0);var lForwards=this.forwards.length();1E-6>lForwards&&(this.forwards.set(0,0,.01),lForwards=this.forwards.length());var middleRadius=.5*(segment.radius0+segment.radius1),middleFraction=.5*(segment.fraction0+segment.fraction1),timeDimension=this.time*this.currentSubray.timeScale*Math.pow(2,segment.iteration);\nthis.middlePos.lerpVectors(segment.pos0,segment.pos1,.5);this.middleLinPos.lerpVectors(segment.linPos0,segment.linPos1,.5);var p=this.middleLinPos;this.newPos.set(this.simplexX.noise4d(p.x,p.y,p.z,timeDimension),this.simplexY.noise4d(p.x,p.y,p.z,timeDimension),this.simplexZ.noise4d(p.x,p.y,p.z,timeDimension));this.newPos.multiplyScalar(segment.positionVariationFactor*lForwards);this.newPos.add(this.middlePos);lForwards=this.getNewSegment();lForwards.pos0.copy(segment.pos0);lForwards.pos1.copy(this.newPos);\nlForwards.linPos0.copy(segment.linPos0);lForwards.linPos1.copy(this.middleLinPos);lForwards.up0.copy(segment.up0);lForwards.up1.copy(segment.up1);lForwards.radius0=segment.radius0;lForwards.radius1=middleRadius;lForwards.fraction0=segment.fraction0;lForwards.fraction1=middleFraction;lForwards.positionVariationFactor=segment.positionVariationFactor*this.currentSubray.roughness;lForwards.iteration=segment.iteration+1;timeDimension=this.getNewSegment();timeDimension.pos0.copy(this.newPos);timeDimension.pos1.copy(segment.pos1);\ntimeDimension.linPos0.copy(this.middleLinPos);timeDimension.linPos1.copy(segment.linPos1);this.cross1.crossVectors(segment.up0,this.forwards.normalize());timeDimension.up0.crossVectors(this.forwards,this.cross1).normalize();timeDimension.up1.copy(segment.up1);timeDimension.radius0=middleRadius;timeDimension.radius1=segment.radius1;timeDimension.fraction0=middleFraction;timeDimension.fraction1=segment.fraction1;timeDimension.positionVariationFactor=segment.positionVariationFactor*this.currentSubray.roughness;\ntimeDimension.iteration=segment.iteration+1;this.fractalRayRecursive(lForwards);this.fractalRayRecursive(timeDimension)}}},{key:\"createPrism\",value:function(segment){this.forwardsFill.subVectors(segment.pos1,segment.pos0).normalize();this.isInitialSegment&&(this.currentCreateTriangleVertices(segment.pos0,segment.up0,this.forwardsFill,segment.radius0,0),this.isInitialSegment=!1);this.currentCreateTriangleVertices(segment.pos1,segment.up0,this.forwardsFill,segment.radius1,segment.fraction1);this.createPrismFaces()}},\n{key:\"createTriangleVerticesWithoutUVs\",value:function(pos,up,forwards,radius){this.side.crossVectors(up,forwards).multiplyScalar(radius*LightningStrike.COS30DEG);this.down.copy(up).multiplyScalar(-radius*LightningStrike.SIN30DEG);forwards=this.vPos;var v=this.vertices;forwards.copy(pos).sub(this.side).add(this.down);v[this.currentCoordinate++]=forwards.x;v[this.currentCoordinate++]=forwards.y;v[this.currentCoordinate++]=forwards.z;forwards.copy(pos).add(this.side).add(this.down);v[this.currentCoordinate++]=\nforwards.x;v[this.currentCoordinate++]=forwards.y;v[this.currentCoordinate++]=forwards.z;forwards.copy(up).multiplyScalar(radius).add(pos);v[this.currentCoordinate++]=forwards.x;v[this.currentCoordinate++]=forwards.y;v[this.currentCoordinate++]=forwards.z;this.currentVertex+=3}},{key:\"createTriangleVerticesWithUVs\",value:function(pos,up,forwards,radius,u){this.side.crossVectors(up,forwards).multiplyScalar(radius*LightningStrike.COS30DEG);this.down.copy(up).multiplyScalar(-radius*LightningStrike.SIN30DEG);\nforwards=this.vPos;var v=this.vertices,uv=this.uvs;forwards.copy(pos).sub(this.side).add(this.down);v[this.currentCoordinate++]=forwards.x;v[this.currentCoordinate++]=forwards.y;v[this.currentCoordinate++]=forwards.z;uv[this.currentUVCoordinate++]=u;uv[this.currentUVCoordinate++]=0;forwards.copy(pos).add(this.side).add(this.down);v[this.currentCoordinate++]=forwards.x;v[this.currentCoordinate++]=forwards.y;v[this.currentCoordinate++]=forwards.z;uv[this.currentUVCoordinate++]=u;uv[this.currentUVCoordinate++]=\n.5;forwards.copy(up).multiplyScalar(radius).add(pos);v[this.currentCoordinate++]=forwards.x;v[this.currentCoordinate++]=forwards.y;v[this.currentCoordinate++]=forwards.z;uv[this.currentUVCoordinate++]=u;uv[this.currentUVCoordinate++]=1;this.currentVertex+=3}},{key:\"createPrismFaces\",value:function(vertex){var indices=this.indices;vertex=this.currentVertex-6;indices[this.currentIndex++]=vertex+1;indices[this.currentIndex++]=vertex+2;indices[this.currentIndex++]=vertex+5;indices[this.currentIndex++]=\nvertex+1;indices[this.currentIndex++]=vertex+5;indices[this.currentIndex++]=vertex+4;indices[this.currentIndex++]=vertex+0;indices[this.currentIndex++]=vertex+1;indices[this.currentIndex++]=vertex+4;indices[this.currentIndex++]=vertex+0;indices[this.currentIndex++]=vertex+4;indices[this.currentIndex++]=vertex+3;indices[this.currentIndex++]=vertex+2;indices[this.currentIndex++]=vertex+0;indices[this.currentIndex++]=vertex+3;indices[this.currentIndex++]=vertex+2;indices[this.currentIndex++]=vertex+\n3;indices[this.currentIndex++]=vertex+5}},{key:\"createDefaultSubrayCreationCallbacks\",value:function(){var random1=this.randomGenerator.random;this.onDecideSubrayCreation=function(segment,lightningStrike){var subray=lightningStrike.currentSubray,period=lightningStrike.rayParameters.subrayPeriod,dutyCycle=lightningStrike.rayParameters.subrayDutyCycle,phase0=lightningStrike.rayParameters.isEternal&&0==subray.recursion?-random1()*period:_three.MathUtils.lerp(subray.birthTime,subray.endPropagationTime,\nsegment.fraction0)-random1()*period,phase=lightningStrike.time-phase0,currentCycle=Math.floor(phase/period),childSubraySeed=random1()*(currentCycle+1),probability=0;phase%period<=dutyCycle*period&&(probability=lightningStrike.subrayProbability);subray.recursion<lightningStrike.maxSubrayRecursion&&lightningStrike.numSubrays<lightningStrike.maxSubrays&&random1()<probability&&(phase=lightningStrike.addNewSubray(),probability=lightningStrike.randomGenerator.getSeed(),phase.seed=childSubraySeed,lightningStrike.randomGenerator.setSeed(childSubraySeed),\nphase.recursion=subray.recursion+1,phase.maxIterations=Math.max(1,subray.maxIterations-1),phase.linPos0.set(random1(),random1(),random1()).multiplyScalar(1E3),phase.linPos1.set(random1(),random1(),random1()).multiplyScalar(1E3),phase.up0.copy(subray.up0),phase.up1.copy(subray.up1),phase.radius0=segment.radius0*lightningStrike.rayParameters.radius0Factor,phase.radius1=Math.min(lightningStrike.rayParameters.minRadius,segment.radius1*lightningStrike.rayParameters.radius1Factor),phase.birthTime=phase0+\ncurrentCycle*period,phase.deathTime=phase.birthTime+period*dutyCycle,lightningStrike.rayParameters.isEternal||0!=subray.recursion||(phase.birthTime=Math.max(phase.birthTime,subray.birthTime),phase.deathTime=Math.min(phase.deathTime,subray.deathTime)),phase.timeScale=2*subray.timeScale,phase.roughness=subray.roughness,phase.straightness=subray.straightness,phase.propagationTimeFactor=subray.propagationTimeFactor,phase.vanishingTimeFactor=subray.vanishingTimeFactor,lightningStrike.onSubrayCreation(segment,\nsubray,phase,lightningStrike),lightningStrike.randomGenerator.setSeed(probability))};var vec1Pos=new _three.Vector3,vec2Forward=new _three.Vector3,vec3Side=new _three.Vector3,vec4Up=new _three.Vector3;this.onSubrayCreation=function(segment,parentSubray,childSubray,lightningStrike){lightningStrike.subrayCylinderPosition(segment,parentSubray,childSubray,.5,.6,.2)};this.subrayConePosition=function(segment,parentSubray,childSubray,heightFactor,sideWidthFactor,minSideWidthFactor){childSubray.pos0.copy(segment.pos0);\nvec1Pos.subVectors(parentSubray.pos1,parentSubray.pos0);vec2Forward.copy(vec1Pos).normalize();vec1Pos.multiplyScalar(segment.fraction0+(1-segment.fraction0)*random1()*heightFactor);segment=vec1Pos.length();vec3Side.crossVectors(parentSubray.up0,vec2Forward);heightFactor=2*Math.PI*random1();vec3Side.multiplyScalar(Math.cos(heightFactor));vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(heightFactor));childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(segment*sideWidthFactor*(minSideWidthFactor+\nrandom1()*(1-minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0)};this.subrayCylinderPosition=function(segment,parentSubray,childSubray,heightFactor,sideWidthFactor,minSideWidthFactor){childSubray.pos0.copy(segment.pos0);vec1Pos.subVectors(parentSubray.pos1,parentSubray.pos0);vec2Forward.copy(vec1Pos).normalize();vec1Pos.multiplyScalar(segment.fraction0+(1-segment.fraction0)*(2*random1()-1)*heightFactor);segment=vec1Pos.length();vec3Side.crossVectors(parentSubray.up0,vec2Forward);heightFactor=\n2*Math.PI*random1();vec3Side.multiplyScalar(Math.cos(heightFactor));vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(heightFactor));childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(segment*sideWidthFactor*(minSideWidthFactor+random1()*(1-minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0)}}},{key:\"createSubray\",value:function(){return{seed:0,maxIterations:0,recursion:0,pos0:new _three.Vector3,pos1:new _three.Vector3,linPos0:new _three.Vector3,linPos1:new _three.Vector3,up0:new _three.Vector3,\nup1:new _three.Vector3,radius0:0,radius1:0,birthTime:0,deathTime:0,timeScale:0,roughness:0,straightness:0,propagationTimeFactor:0,vanishingTimeFactor:0,endPropagationTime:0,beginVanishingTime:0}}},{key:\"createSegment\",value:function(){return{iteration:0,pos0:new _three.Vector3,pos1:new _three.Vector3,linPos0:new _three.Vector3,linPos1:new _three.Vector3,up0:new _three.Vector3,up1:new _three.Vector3,radius0:0,radius1:0,fraction0:0,fraction1:0,positionVariationFactor:0}}},{key:\"getNewSegment\",value:function(){return this.raySegments[this.currentSegmentIndex++]}},\n{key:\"copy\",value:function(source){_get(_getPrototypeOf(LightningStrike.prototype),\"copy\",this).call(this,source);this.init(LightningStrike.copyParameters({},source.rayParameters));return this}},{key:\"clone\",value:function(){return new this.constructor(LightningStrike.copyParameters({},this.rayParameters))}}]);return LightningStrike}(_three.BufferGeometry);exports.LightningStrike=global;global.prototype.isLightningStrike=!0;global.RAY_INITIALIZED=0;global.RAY_UNBORN=1;global.RAY_PROPAGATING=2;global.RAY_STEADY=\n3;global.RAY_VANISHING=4;global.RAY_EXTINGUISHED=5;global.COS30DEG=Math.cos(30*Math.PI/180);global.SIN30DEG=Math.sin(30*Math.PI/180);global.createRandomGenerator=function(){for(var seeds=[],i=0;2053>i;i++)seeds.push(Math.random());var generator={currentSeed:0,random:function(){var value=seeds[generator.currentSeed];generator.currentSeed=(generator.currentSeed+1)%2053;return value},getSeed:function(){return generator.currentSeed/2053},setSeed:function(seed){generator.currentSeed=Math.floor(2053*seed)%\n2053}};return generator};global.copyParameters=function(dest,source){source=source||{};dest=dest||{};var vecCopy=function(v){return source===dest?v:v.clone()};dest.sourceOffset=void 0!==source.sourceOffset?vecCopy(source.sourceOffset):new _three.Vector3(0,100,0);dest.destOffset=void 0!==source.destOffset?vecCopy(source.destOffset):new _three.Vector3(0,0,0);dest.timeScale=void 0!==source.timeScale?source.timeScale:1;dest.roughness=void 0!==source.roughness?source.roughness:.9;dest.straightness=void 0!==\nsource.straightness?source.straightness:.7;dest.up0=void 0!==source.up0?vecCopy(source.up0):new _three.Vector3(0,0,1);dest.up1=void 0!==source.up1?vecCopy(source.up1):new _three.Vector3(0,0,1);dest.radius0=void 0!==source.radius0?source.radius0:1;dest.radius1=void 0!==source.radius1?source.radius1:1;dest.radius0Factor=void 0!==source.radius0Factor?source.radius0Factor:.5;dest.radius1Factor=void 0!==source.radius1Factor?source.radius1Factor:.2;dest.minRadius=void 0!==source.minRadius?source.minRadius:\n.2;dest.isEternal=void 0!==source.isEternal?source.isEternal:void 0===source.birthTime||void 0===source.deathTime;dest.birthTime=source.birthTime;dest.deathTime=source.deathTime;dest.propagationTimeFactor=void 0!==source.propagationTimeFactor?source.propagationTimeFactor:.1;dest.vanishingTimeFactor=void 0!==source.vanishingTimeFactor?source.vanishingTimeFactor:.9;dest.subrayPeriod=void 0!==source.subrayPeriod?source.subrayPeriod:4;dest.subrayDutyCycle=void 0!==source.subrayDutyCycle?source.subrayDutyCycle:\n.6;dest.maxIterations=void 0!==source.maxIterations?source.maxIterations:9;dest.isStatic=void 0!==source.isStatic?source.isStatic:!1;dest.ramification=void 0!==source.ramification?source.ramification:5;dest.maxSubrayRecursion=void 0!==source.maxSubrayRecursion?source.maxSubrayRecursion:3;dest.recursionProbability=void 0!==source.recursionProbability?source.recursionProbability:.6;dest.generateUVs=void 0!==source.generateUVs?source.generateUVs:!1;dest.randomGenerator=source.randomGenerator;dest.noiseSeed=\nsource.noiseSeed;dest.onDecideSubrayCreation=source.onDecideSubrayCreation;dest.onSubrayCreation=source.onSubrayCreation;return dest}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$geometries$LightningStrike\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LightningStrike = void 0;\n\nvar _three = require(\"three\");\n\nvar _SimplexNoise = require(\"../math/SimplexNoise.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\n *\n *\n * Usage\n *\n * var myRay = new LightningStrike( paramsObject );\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\n * scene.add( myRayMesh );\n * ...\n * myRay.update( currentTime );\n *\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\n *\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\n *\n *\n * LightningStrike parameters\n *\n * The paramsObject can contain any of the following parameters.\n *\n * Legend:\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\n * 'Segment': A linear segment piece of a subray.\n * 'Leaf segment': A ray segment which cannot be smaller.\n *\n *\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\n *\n * @param {Vector3} sourceOffset The point where the ray starts.\n *\n * @param {Vector3} destOffset The point where the ray ends.\n *\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\n *\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\n *\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\n *\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\n *\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\n *\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\n *\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\n *\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\n *\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\n *\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\n *\n *\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n *\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\n *\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\n *\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\n *\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\n *\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\n *\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\n *\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\n *\n *\n * These parameters cannot change after lightning creation:\n *\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\n *\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\n *\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\n *\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\n *\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\n *\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\n *\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\n *\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\n *\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\n *\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\n *\n *\n */\nvar LightningStrike =\n/*#__PURE__*/\nfunction (_BufferGeometry) {\n  _inherits(LightningStrike, _BufferGeometry);\n\n  function LightningStrike(rayParameters) {\n    var _this;\n\n    _classCallCheck(this, LightningStrike);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LightningStrike).call(this));\n    _this.type = 'LightningStrike'; // Set parameters, and set undefined parameters to default values\n\n    rayParameters = rayParameters || {};\n\n    _this.init(LightningStrike.copyParameters(rayParameters, rayParameters)); // Creates and populates the mesh\n\n\n    _this.createMesh();\n\n    return _this;\n  }\n\n  _createClass(LightningStrike, [{\n    key: \"update\",\n    value: function update(time) {\n      if (this.isStatic) return;\n\n      if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n        this.updateMesh(time);\n\n        if (time < this.subrays[0].endPropagationTime) {\n          this.state = LightningStrike.RAY_PROPAGATING;\n        } else if (time > this.subrays[0].beginVanishingTime) {\n          this.state = LightningStrike.RAY_VANISHING;\n        } else {\n          this.state = LightningStrike.RAY_STEADY;\n        }\n\n        this.visible = true;\n      } else {\n        this.visible = false;\n\n        if (time < this.rayParameters.birthTime) {\n          this.state = LightningStrike.RAY_UNBORN;\n        } else {\n          this.state = LightningStrike.RAY_EXTINGUISHED;\n        }\n      }\n    }\n  }, {\n    key: \"init\",\n    value: function init(rayParameters) {\n      // Init all the state from the parameters\n      this.rayParameters = rayParameters; // These parameters cannot change after lightning creation:\n\n      this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9;\n      rayParameters.maxIterations = this.maxIterations;\n      this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;\n      rayParameters.isStatic = this.isStatic;\n      this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5;\n      rayParameters.ramification = this.ramification;\n      this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n      rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n      this.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;\n      rayParameters.recursionProbability = this.recursionProbability;\n      this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;\n      rayParameters.generateUVs = this.generateUVs; // Random generator\n\n      if (rayParameters.randomGenerator !== undefined) {\n        this.randomGenerator = rayParameters.randomGenerator;\n        this.seedGenerator = rayParameters.randomGenerator;\n\n        if (rayParameters.noiseSeed !== undefined) {\n          this.seedGenerator.setSeed(rayParameters.noiseSeed);\n        }\n      } else {\n        this.randomGenerator = LightningStrike.createRandomGenerator();\n        this.seedGenerator = Math;\n      } // Ray creation callbacks\n\n\n      if (rayParameters.onDecideSubrayCreation !== undefined) {\n        this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n      } else {\n        this.createDefaultSubrayCreationCallbacks();\n\n        if (rayParameters.onSubrayCreation !== undefined) {\n          this.onSubrayCreation = rayParameters.onSubrayCreation;\n        }\n      } // Internal state\n\n\n      this.state = LightningStrike.RAY_INITIALIZED;\n      this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n      rayParameters.maxSubrays = this.maxSubrays;\n      this.maxRaySegments = 2 * (1 << this.maxIterations);\n      this.subrays = [];\n\n      for (var i = 0; i < this.maxSubrays; i++) {\n        this.subrays.push(this.createSubray());\n      }\n\n      this.raySegments = [];\n\n      for (var _i = 0; _i < this.maxRaySegments; _i++) {\n        this.raySegments.push(this.createSegment());\n      }\n\n      this.time = 0;\n      this.timeFraction = 0;\n      this.currentSegmentCallback = null;\n      this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n      this.numSubrays = 0;\n      this.currentSubray = null;\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = false;\n      this.subrayProbability = 0;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.vertices = null;\n      this.uvs = null;\n      this.indices = null;\n      this.positionAttribute = null;\n      this.uvsAttribute = null;\n      this.simplexX = new _SimplexNoise.SimplexNoise(this.seedGenerator);\n      this.simplexY = new _SimplexNoise.SimplexNoise(this.seedGenerator);\n      this.simplexZ = new _SimplexNoise.SimplexNoise(this.seedGenerator); // Temp vectors\n\n      this.forwards = new _three.Vector3();\n      this.forwardsFill = new _three.Vector3();\n      this.side = new _three.Vector3();\n      this.down = new _three.Vector3();\n      this.middlePos = new _three.Vector3();\n      this.middleLinPos = new _three.Vector3();\n      this.newPos = new _three.Vector3();\n      this.vPos = new _three.Vector3();\n      this.cross1 = new _three.Vector3();\n    }\n  }, {\n    key: \"createMesh\",\n    value: function createMesh() {\n      var maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n      var maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n      var maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n      this.vertices = new Float32Array(maxVerts * 3);\n      this.indices = new Uint32Array(maxIndices);\n\n      if (this.generateUVs) {\n        this.uvs = new Float32Array(maxVerts * 2);\n      } // Populate the mesh\n\n\n      this.fillMesh(0);\n      this.setIndex(new _three.Uint32BufferAttribute(this.indices, 1));\n      this.positionAttribute = new _three.Float32BufferAttribute(this.vertices, 3);\n      this.setAttribute('position', this.positionAttribute);\n\n      if (this.generateUVs) {\n        this.uvsAttribute = new _three.Float32BufferAttribute(new Float32Array(this.uvs), 2);\n        this.setAttribute('uv', this.uvsAttribute);\n      }\n\n      if (!this.isStatic) {\n        this.index.usage = _three.DynamicDrawUsage;\n        this.positionAttribute.usage = _three.DynamicDrawUsage;\n\n        if (this.generateUVs) {\n          this.uvsAttribute.usage = _three.DynamicDrawUsage;\n        }\n      } // Store buffers for later modification\n\n\n      this.vertices = this.positionAttribute.array;\n      this.indices = this.index.array;\n\n      if (this.generateUVs) {\n        this.uvs = this.uvsAttribute.array;\n      }\n    }\n  }, {\n    key: \"updateMesh\",\n    value: function updateMesh(time) {\n      this.fillMesh(time);\n      this.drawRange.count = this.currentIndex;\n      this.index.needsUpdate = true;\n      this.positionAttribute.needsUpdate = true;\n\n      if (this.generateUVs) {\n        this.uvsAttribute.needsUpdate = true;\n      }\n    }\n  }, {\n    key: \"fillMesh\",\n    value: function fillMesh(time) {\n      var scope = this;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.fractalRay(time, function fillVertices(segment) {\n        var subray = scope.currentSubray;\n\n        if (time < subray.birthTime) {\n          //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n          return;\n        } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n          // Eternal rays don't propagate nor vanish, but its subrays do\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else if (time < subray.endPropagationTime) {\n          if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n            // Ray propagation has arrived to this segment\n            scope.createPrism(segment);\n            scope.onDecideSubrayCreation(segment, scope);\n          }\n        } else if (time < subray.beginVanishingTime) {\n          // Ray is steady (nor propagating nor vanishing)\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else {\n          if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n            // Segment has not yet vanished\n            scope.createPrism(segment);\n          }\n\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      });\n    }\n  }, {\n    key: \"addNewSubray\",\n    value: function addNewSubray()\n    /*rayParameters*/\n    {\n      return this.subrays[this.numSubrays++];\n    }\n  }, {\n    key: \"initSubray\",\n    value: function initSubray(subray, rayParameters) {\n      subray.pos0.copy(rayParameters.sourceOffset);\n      subray.pos1.copy(rayParameters.destOffset);\n      subray.up0.copy(rayParameters.up0);\n      subray.up1.copy(rayParameters.up1);\n      subray.radius0 = rayParameters.radius0;\n      subray.radius1 = rayParameters.radius1;\n      subray.birthTime = rayParameters.birthTime;\n      subray.deathTime = rayParameters.deathTime;\n      subray.timeScale = rayParameters.timeScale;\n      subray.roughness = rayParameters.roughness;\n      subray.straightness = rayParameters.straightness;\n      subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n      subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n      subray.maxIterations = this.maxIterations;\n      subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;\n      subray.recursion = 0;\n    }\n  }, {\n    key: \"fractalRay\",\n    value: function fractalRay(time, segmentCallback) {\n      this.time = time;\n      this.currentSegmentCallback = segmentCallback;\n      this.numSubrays = 0; // Add the top level subray\n\n      this.initSubray(this.addNewSubray(), this.rayParameters); // Process all subrays that are being generated until consuming all of them\n\n      for (var subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n        var subray = this.subrays[subrayIndex];\n        this.currentSubray = subray;\n        this.randomGenerator.setSeed(subray.seed);\n        subray.endPropagationTime = _three.MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n        subray.beginVanishingTime = _three.MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n        var random1 = this.randomGenerator.random;\n        subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n        subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n        this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n        this.currentSegmentIndex = 0;\n        this.isInitialSegment = true;\n        var segment = this.getNewSegment();\n        segment.iteration = 0;\n        segment.pos0.copy(subray.pos0);\n        segment.pos1.copy(subray.pos1);\n        segment.linPos0.copy(subray.linPos0);\n        segment.linPos1.copy(subray.linPos1);\n        segment.up0.copy(subray.up0);\n        segment.up1.copy(subray.up1);\n        segment.radius0 = subray.radius0;\n        segment.radius1 = subray.radius1;\n        segment.fraction0 = 0;\n        segment.fraction1 = 1;\n        segment.positionVariationFactor = 1 - subray.straightness;\n        this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n        this.fractalRayRecursive(segment);\n      }\n\n      this.currentSegmentCallback = null;\n      this.currentSubray = null;\n    }\n  }, {\n    key: \"fractalRayRecursive\",\n    value: function fractalRayRecursive(segment) {\n      // Leave recursion condition\n      if (segment.iteration >= this.currentSubray.maxIterations) {\n        this.currentSegmentCallback(segment);\n        return;\n      } // Interpolation\n\n\n      this.forwards.subVectors(segment.pos1, segment.pos0);\n      var lForwards = this.forwards.length();\n\n      if (lForwards < 0.000001) {\n        this.forwards.set(0, 0, 0.01);\n        lForwards = this.forwards.length();\n      }\n\n      var middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n      var middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n      var timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n      this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n      this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n      var p = this.middleLinPos; // Noise\n\n      this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n      this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n      this.newPos.add(this.middlePos); // Recursion\n\n      var newSegment1 = this.getNewSegment();\n      newSegment1.pos0.copy(segment.pos0);\n      newSegment1.pos1.copy(this.newPos);\n      newSegment1.linPos0.copy(segment.linPos0);\n      newSegment1.linPos1.copy(this.middleLinPos);\n      newSegment1.up0.copy(segment.up0);\n      newSegment1.up1.copy(segment.up1);\n      newSegment1.radius0 = segment.radius0;\n      newSegment1.radius1 = middleRadius;\n      newSegment1.fraction0 = segment.fraction0;\n      newSegment1.fraction1 = middleFraction;\n      newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment1.iteration = segment.iteration + 1;\n      var newSegment2 = this.getNewSegment();\n      newSegment2.pos0.copy(this.newPos);\n      newSegment2.pos1.copy(segment.pos1);\n      newSegment2.linPos0.copy(this.middleLinPos);\n      newSegment2.linPos1.copy(segment.linPos1);\n      this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n      newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n      newSegment2.up1.copy(segment.up1);\n      newSegment2.radius0 = middleRadius;\n      newSegment2.radius1 = segment.radius1;\n      newSegment2.fraction0 = middleFraction;\n      newSegment2.fraction1 = segment.fraction1;\n      newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment2.iteration = segment.iteration + 1;\n      this.fractalRayRecursive(newSegment1);\n      this.fractalRayRecursive(newSegment2);\n    }\n  }, {\n    key: \"createPrism\",\n    value: function createPrism(segment) {\n      // Creates one triangular prism and its vertices at the segment\n      this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n\n      if (this.isInitialSegment) {\n        this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n        this.isInitialSegment = false;\n      }\n\n      this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n      this.createPrismFaces();\n    }\n  }, {\n    key: \"createTriangleVerticesWithoutUVs\",\n    value: function createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n      // Create an equilateral triangle (only vertices)\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n      var p = this.vPos;\n      var v = this.vertices;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      this.currentVertex += 3;\n    }\n  }, {\n    key: \"createTriangleVerticesWithUVs\",\n    value: function createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n      // Create an equilateral triangle (only vertices)\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n      var p = this.vPos;\n      var v = this.vertices;\n      var uv = this.uvs;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0.5;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 1;\n      this.currentVertex += 3;\n    }\n  }, {\n    key: \"createPrismFaces\",\n    value: function createPrismFaces(vertex\n    /*, index*/\n    ) {\n      var indices = this.indices;\n      var vertex = this.currentVertex - 6;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 5;\n    }\n  }, {\n    key: \"createDefaultSubrayCreationCallbacks\",\n    value: function createDefaultSubrayCreationCallbacks() {\n      var random1 = this.randomGenerator.random;\n\n      this.onDecideSubrayCreation = function (segment, lightningStrike) {\n        // Decide subrays creation at parent (sub)ray segment\n        var subray = lightningStrike.currentSubray;\n        var period = lightningStrike.rayParameters.subrayPeriod;\n        var dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n        var phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : _three.MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n        var phase = lightningStrike.time - phase0;\n        var currentCycle = Math.floor(phase / period);\n        var childSubraySeed = random1() * (currentCycle + 1);\n        var isActive = phase % period <= dutyCycle * period;\n        var probability = 0;\n\n        if (isActive) {\n          probability = lightningStrike.subrayProbability; // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n        }\n\n        if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n          var childSubray = lightningStrike.addNewSubray();\n          var parentSeed = lightningStrike.randomGenerator.getSeed();\n          childSubray.seed = childSubraySeed;\n          lightningStrike.randomGenerator.setSeed(childSubraySeed);\n          childSubray.recursion = subray.recursion + 1;\n          childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n          childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n          childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n          childSubray.up0.copy(subray.up0);\n          childSubray.up1.copy(subray.up1);\n          childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n          childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n          childSubray.birthTime = phase0 + currentCycle * period;\n          childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n\n          if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n            childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n            childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n          }\n\n          childSubray.timeScale = subray.timeScale * 2;\n          childSubray.roughness = subray.roughness;\n          childSubray.straightness = subray.straightness;\n          childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n          childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n          lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n          lightningStrike.randomGenerator.setSeed(parentSeed);\n        }\n      };\n\n      var vec1Pos = new _three.Vector3();\n      var vec2Forward = new _three.Vector3();\n      var vec3Side = new _three.Vector3();\n      var vec4Up = new _three.Vector3();\n\n      this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n        // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n        // Just use the default cone position generator\n        lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n      };\n\n      this.subrayConePosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        // Sets childSubray pos0 and pos1 in a cone\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n        var length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        var angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n\n      this.subrayCylinderPosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        // Sets childSubray pos0 and pos1 in a cylinder\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n        var length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        var angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n    }\n  }, {\n    key: \"createSubray\",\n    value: function createSubray() {\n      return {\n        seed: 0,\n        maxIterations: 0,\n        recursion: 0,\n        pos0: new _three.Vector3(),\n        pos1: new _three.Vector3(),\n        linPos0: new _three.Vector3(),\n        linPos1: new _three.Vector3(),\n        up0: new _three.Vector3(),\n        up1: new _three.Vector3(),\n        radius0: 0,\n        radius1: 0,\n        birthTime: 0,\n        deathTime: 0,\n        timeScale: 0,\n        roughness: 0,\n        straightness: 0,\n        propagationTimeFactor: 0,\n        vanishingTimeFactor: 0,\n        endPropagationTime: 0,\n        beginVanishingTime: 0\n      };\n    }\n  }, {\n    key: \"createSegment\",\n    value: function createSegment() {\n      return {\n        iteration: 0,\n        pos0: new _three.Vector3(),\n        pos1: new _three.Vector3(),\n        linPos0: new _three.Vector3(),\n        linPos1: new _three.Vector3(),\n        up0: new _three.Vector3(),\n        up1: new _three.Vector3(),\n        radius0: 0,\n        radius1: 0,\n        fraction0: 0,\n        fraction1: 0,\n        positionVariationFactor: 0\n      };\n    }\n  }, {\n    key: \"getNewSegment\",\n    value: function getNewSegment() {\n      return this.raySegments[this.currentSegmentIndex++];\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(LightningStrike.prototype), \"copy\", this).call(this, source);\n\n      this.init(LightningStrike.copyParameters({}, source.rayParameters));\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));\n    }\n  }]);\n\n  return LightningStrike;\n}(_three.BufferGeometry);\n\nexports.LightningStrike = LightningStrike;\nLightningStrike.prototype.isLightningStrike = true; // Ray states\n\nLightningStrike.RAY_INITIALIZED = 0;\nLightningStrike.RAY_UNBORN = 1;\nLightningStrike.RAY_PROPAGATING = 2;\nLightningStrike.RAY_STEADY = 3;\nLightningStrike.RAY_VANISHING = 4;\nLightningStrike.RAY_EXTINGUISHED = 5;\nLightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);\nLightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);\n\nLightningStrike.createRandomGenerator = function () {\n  var numSeeds = 2053;\n  var seeds = [];\n\n  for (var i = 0; i < numSeeds; i++) {\n    seeds.push(Math.random());\n  }\n\n  var generator = {\n    currentSeed: 0,\n    random: function random() {\n      var value = seeds[generator.currentSeed];\n      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n      return value;\n    },\n    getSeed: function getSeed() {\n      return generator.currentSeed / numSeeds;\n    },\n    setSeed: function setSeed(seed) {\n      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n    }\n  };\n  return generator;\n};\n\nLightningStrike.copyParameters = function (dest, source) {\n  source = source || {};\n  dest = dest || {};\n\n  var vecCopy = function vecCopy(v) {\n    if (source === dest) {\n      return v;\n    } else {\n      return v.clone();\n    }\n  };\n\n  dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new _three.Vector3(0, 100, 0), dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new _three.Vector3(0, 0, 0), dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1, dest.roughness = source.roughness !== undefined ? source.roughness : 0.9, dest.straightness = source.straightness !== undefined ? source.straightness : 0.7, dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new _three.Vector3(0, 0, 1);\n  dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new _three.Vector3(0, 0, 1), dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1, dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n  dest.isEternal = source.isEternal !== undefined ? source.isEternal : source.birthTime === undefined || source.deathTime === undefined, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6; // These parameters cannot change after lightning creation:\n\n  dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9;\n  dest.isStatic = source.isStatic !== undefined ? source.isStatic : false;\n  dest.ramification = source.ramification !== undefined ? source.ramification : 5;\n  dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;\n  dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;\n  dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;\n  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n  return dest;\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$three_stdlib$math$SimplexNoise"]],"~:properties",["^5",["generateUVs","numSubrays","maxRaySegments","usage","subrayPeriod","isInitialSegment","random","vanishingTimeFactor","RAY_UNBORN","needsUpdate","LightningStrike","destOffset","prototype","RAY_PROPAGATING","isEternal","currentSeed","subrayDutyCycle","onSubrayCreation","endPropagationTime","uvs","side","SIN30DEG","copyParameters","randomGenerator","setSeed","isStatic","uvsAttribute","recursion","key","maxIterations","__esModule","pos1","up0","linPos1","straightness","simplexX","ramification","up1","timeScale","count","currentSubray","propagationTimeFactor","simplexZ","radius1","radius0Factor","deathTime","cross1","configurable","maxSubrayRecursion","value","currentCoordinate","radius0","visible","maxSubrays","onDecideSubrayCreation","positionVariationFactor","middlePos","enumerable","vertices","seed","beginVanishingTime","fraction0","iteration","writable","isLightningStrike","forwardsFill","timeFraction","time","currentVertex","simplexY","currentSegmentCallback","currentCreateTriangleVertices","RAY_STEADY","positionAttribute","RAY_EXTINGUISHED","currentSegmentIndex","down","type","subrayProbability","sourceOffset","newPos","forwards","state","__proto__","subrays","RAY_INITIALIZED","createRandomGenerator","COS30DEG","fraction1","seedGenerator","getSeed","minRadius","vPos","raySegments","noiseSeed","pos0","RAY_VANISHING","radius1Factor","birthTime","roughness","middleLinPos","linPos0","subrayCylinderPosition","constructor","indices","currentIndex","recursionProbability","currentUVCoordinate","rayParameters","subrayConePosition"]],"~:compiled-at",1630917515383,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$geometries$LightningStrike.js\",\n\"lineCount\":47,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/geometries/LightningStrike.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$geometries$LightningStrike\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.LightningStrike = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _SimplexNoise = require(\\\"../math/SimplexNoise.js\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _get(target, property, receiver) { if (typeof Reflect !== \\\"undefined\\\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\\n\\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\\n *\\n *\\n * Usage\\n *\\n * var myRay = new LightningStrike( paramsObject );\\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\\n * scene.add( myRayMesh );\\n * ...\\n * myRay.update( currentTime );\\n *\\n * The \\\"currentTime\\\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\\n *\\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\\n *\\n *\\n * LightningStrike parameters\\n *\\n * The paramsObject can contain any of the following parameters.\\n *\\n * Legend:\\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\\n * 'Segment': A linear segment piece of a subray.\\n * 'Leaf segment': A ray segment which cannot be smaller.\\n *\\n *\\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\\n *\\n * @param {Vector3} sourceOffset The point where the ray starts.\\n *\\n * @param {Vector3} destOffset The point where the ray ends.\\n *\\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\\n *\\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\\n *\\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\\n *\\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\\n *\\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\\n *\\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\\n *\\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\\n *\\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\\n *\\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\\n *\\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\\n *\\n *\\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\\n *\\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\\n *\\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\\n *\\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\\n *\\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\\n *\\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\\n *\\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\\n *\\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\\n *\\n *\\n * These parameters cannot change after lightning creation:\\n *\\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\\n *\\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\\n *\\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\\n *\\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\\n *\\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\\n *\\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\\n *\\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\\n *\\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\\n *\\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\\n *\\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\\n *\\n *\\n */\\nvar LightningStrike =\\n/*#__PURE__*/\\nfunction (_BufferGeometry) {\\n  _inherits(LightningStrike, _BufferGeometry);\\n\\n  function LightningStrike(rayParameters) {\\n    var _this;\\n\\n    _classCallCheck(this, LightningStrike);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LightningStrike).call(this));\\n    _this.type = 'LightningStrike'; // Set parameters, and set undefined parameters to default values\\n\\n    rayParameters = rayParameters || {};\\n\\n    _this.init(LightningStrike.copyParameters(rayParameters, rayParameters)); // Creates and populates the mesh\\n\\n\\n    _this.createMesh();\\n\\n    return _this;\\n  }\\n\\n  _createClass(LightningStrike, [{\\n    key: \\\"update\\\",\\n    value: function update(time) {\\n      if (this.isStatic) return;\\n\\n      if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\\n        this.updateMesh(time);\\n\\n        if (time < this.subrays[0].endPropagationTime) {\\n          this.state = LightningStrike.RAY_PROPAGATING;\\n        } else if (time > this.subrays[0].beginVanishingTime) {\\n          this.state = LightningStrike.RAY_VANISHING;\\n        } else {\\n          this.state = LightningStrike.RAY_STEADY;\\n        }\\n\\n        this.visible = true;\\n      } else {\\n        this.visible = false;\\n\\n        if (time < this.rayParameters.birthTime) {\\n          this.state = LightningStrike.RAY_UNBORN;\\n        } else {\\n          this.state = LightningStrike.RAY_EXTINGUISHED;\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"init\\\",\\n    value: function init(rayParameters) {\\n      // Init all the state from the parameters\\n      this.rayParameters = rayParameters; // These parameters cannot change after lightning creation:\\n\\n      this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9;\\n      rayParameters.maxIterations = this.maxIterations;\\n      this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;\\n      rayParameters.isStatic = this.isStatic;\\n      this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5;\\n      rayParameters.ramification = this.ramification;\\n      this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\\n      rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\\n      this.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;\\n      rayParameters.recursionProbability = this.recursionProbability;\\n      this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;\\n      rayParameters.generateUVs = this.generateUVs; // Random generator\\n\\n      if (rayParameters.randomGenerator !== undefined) {\\n        this.randomGenerator = rayParameters.randomGenerator;\\n        this.seedGenerator = rayParameters.randomGenerator;\\n\\n        if (rayParameters.noiseSeed !== undefined) {\\n          this.seedGenerator.setSeed(rayParameters.noiseSeed);\\n        }\\n      } else {\\n        this.randomGenerator = LightningStrike.createRandomGenerator();\\n        this.seedGenerator = Math;\\n      } // Ray creation callbacks\\n\\n\\n      if (rayParameters.onDecideSubrayCreation !== undefined) {\\n        this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\\n      } else {\\n        this.createDefaultSubrayCreationCallbacks();\\n\\n        if (rayParameters.onSubrayCreation !== undefined) {\\n          this.onSubrayCreation = rayParameters.onSubrayCreation;\\n        }\\n      } // Internal state\\n\\n\\n      this.state = LightningStrike.RAY_INITIALIZED;\\n      this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\\n      rayParameters.maxSubrays = this.maxSubrays;\\n      this.maxRaySegments = 2 * (1 << this.maxIterations);\\n      this.subrays = [];\\n\\n      for (var i = 0; i < this.maxSubrays; i++) {\\n        this.subrays.push(this.createSubray());\\n      }\\n\\n      this.raySegments = [];\\n\\n      for (var _i = 0; _i < this.maxRaySegments; _i++) {\\n        this.raySegments.push(this.createSegment());\\n      }\\n\\n      this.time = 0;\\n      this.timeFraction = 0;\\n      this.currentSegmentCallback = null;\\n      this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\\n      this.numSubrays = 0;\\n      this.currentSubray = null;\\n      this.currentSegmentIndex = 0;\\n      this.isInitialSegment = false;\\n      this.subrayProbability = 0;\\n      this.currentVertex = 0;\\n      this.currentIndex = 0;\\n      this.currentCoordinate = 0;\\n      this.currentUVCoordinate = 0;\\n      this.vertices = null;\\n      this.uvs = null;\\n      this.indices = null;\\n      this.positionAttribute = null;\\n      this.uvsAttribute = null;\\n      this.simplexX = new _SimplexNoise.SimplexNoise(this.seedGenerator);\\n      this.simplexY = new _SimplexNoise.SimplexNoise(this.seedGenerator);\\n      this.simplexZ = new _SimplexNoise.SimplexNoise(this.seedGenerator); // Temp vectors\\n\\n      this.forwards = new _three.Vector3();\\n      this.forwardsFill = new _three.Vector3();\\n      this.side = new _three.Vector3();\\n      this.down = new _three.Vector3();\\n      this.middlePos = new _three.Vector3();\\n      this.middleLinPos = new _three.Vector3();\\n      this.newPos = new _three.Vector3();\\n      this.vPos = new _three.Vector3();\\n      this.cross1 = new _three.Vector3();\\n    }\\n  }, {\\n    key: \\\"createMesh\\\",\\n    value: function createMesh() {\\n      var maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\\n      var maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\\n      var maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\\n      this.vertices = new Float32Array(maxVerts * 3);\\n      this.indices = new Uint32Array(maxIndices);\\n\\n      if (this.generateUVs) {\\n        this.uvs = new Float32Array(maxVerts * 2);\\n      } // Populate the mesh\\n\\n\\n      this.fillMesh(0);\\n      this.setIndex(new _three.Uint32BufferAttribute(this.indices, 1));\\n      this.positionAttribute = new _three.Float32BufferAttribute(this.vertices, 3);\\n      this.setAttribute('position', this.positionAttribute);\\n\\n      if (this.generateUVs) {\\n        this.uvsAttribute = new _three.Float32BufferAttribute(new Float32Array(this.uvs), 2);\\n        this.setAttribute('uv', this.uvsAttribute);\\n      }\\n\\n      if (!this.isStatic) {\\n        this.index.usage = _three.DynamicDrawUsage;\\n        this.positionAttribute.usage = _three.DynamicDrawUsage;\\n\\n        if (this.generateUVs) {\\n          this.uvsAttribute.usage = _three.DynamicDrawUsage;\\n        }\\n      } // Store buffers for later modification\\n\\n\\n      this.vertices = this.positionAttribute.array;\\n      this.indices = this.index.array;\\n\\n      if (this.generateUVs) {\\n        this.uvs = this.uvsAttribute.array;\\n      }\\n    }\\n  }, {\\n    key: \\\"updateMesh\\\",\\n    value: function updateMesh(time) {\\n      this.fillMesh(time);\\n      this.drawRange.count = this.currentIndex;\\n      this.index.needsUpdate = true;\\n      this.positionAttribute.needsUpdate = true;\\n\\n      if (this.generateUVs) {\\n        this.uvsAttribute.needsUpdate = true;\\n      }\\n    }\\n  }, {\\n    key: \\\"fillMesh\\\",\\n    value: function fillMesh(time) {\\n      var scope = this;\\n      this.currentVertex = 0;\\n      this.currentIndex = 0;\\n      this.currentCoordinate = 0;\\n      this.currentUVCoordinate = 0;\\n      this.fractalRay(time, function fillVertices(segment) {\\n        var subray = scope.currentSubray;\\n\\n        if (time < subray.birthTime) {\\n          //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\\n          return;\\n        } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\\n          // Eternal rays don't propagate nor vanish, but its subrays do\\n          scope.createPrism(segment);\\n          scope.onDecideSubrayCreation(segment, scope);\\n        } else if (time < subray.endPropagationTime) {\\n          if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\\n            // Ray propagation has arrived to this segment\\n            scope.createPrism(segment);\\n            scope.onDecideSubrayCreation(segment, scope);\\n          }\\n        } else if (time < subray.beginVanishingTime) {\\n          // Ray is steady (nor propagating nor vanishing)\\n          scope.createPrism(segment);\\n          scope.onDecideSubrayCreation(segment, scope);\\n        } else {\\n          if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\\n            // Segment has not yet vanished\\n            scope.createPrism(segment);\\n          }\\n\\n          scope.onDecideSubrayCreation(segment, scope);\\n        }\\n      });\\n    }\\n  }, {\\n    key: \\\"addNewSubray\\\",\\n    value: function addNewSubray()\\n    /*rayParameters*/\\n    {\\n      return this.subrays[this.numSubrays++];\\n    }\\n  }, {\\n    key: \\\"initSubray\\\",\\n    value: function initSubray(subray, rayParameters) {\\n      subray.pos0.copy(rayParameters.sourceOffset);\\n      subray.pos1.copy(rayParameters.destOffset);\\n      subray.up0.copy(rayParameters.up0);\\n      subray.up1.copy(rayParameters.up1);\\n      subray.radius0 = rayParameters.radius0;\\n      subray.radius1 = rayParameters.radius1;\\n      subray.birthTime = rayParameters.birthTime;\\n      subray.deathTime = rayParameters.deathTime;\\n      subray.timeScale = rayParameters.timeScale;\\n      subray.roughness = rayParameters.roughness;\\n      subray.straightness = rayParameters.straightness;\\n      subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\\n      subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\\n      subray.maxIterations = this.maxIterations;\\n      subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;\\n      subray.recursion = 0;\\n    }\\n  }, {\\n    key: \\\"fractalRay\\\",\\n    value: function fractalRay(time, segmentCallback) {\\n      this.time = time;\\n      this.currentSegmentCallback = segmentCallback;\\n      this.numSubrays = 0; // Add the top level subray\\n\\n      this.initSubray(this.addNewSubray(), this.rayParameters); // Process all subrays that are being generated until consuming all of them\\n\\n      for (var subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\\n        var subray = this.subrays[subrayIndex];\\n        this.currentSubray = subray;\\n        this.randomGenerator.setSeed(subray.seed);\\n        subray.endPropagationTime = _three.MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\\n        subray.beginVanishingTime = _three.MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\\n        var random1 = this.randomGenerator.random;\\n        subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\\n        subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\\n        this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\\n        this.currentSegmentIndex = 0;\\n        this.isInitialSegment = true;\\n        var segment = this.getNewSegment();\\n        segment.iteration = 0;\\n        segment.pos0.copy(subray.pos0);\\n        segment.pos1.copy(subray.pos1);\\n        segment.linPos0.copy(subray.linPos0);\\n        segment.linPos1.copy(subray.linPos1);\\n        segment.up0.copy(subray.up0);\\n        segment.up1.copy(subray.up1);\\n        segment.radius0 = subray.radius0;\\n        segment.radius1 = subray.radius1;\\n        segment.fraction0 = 0;\\n        segment.fraction1 = 1;\\n        segment.positionVariationFactor = 1 - subray.straightness;\\n        this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\\n        this.fractalRayRecursive(segment);\\n      }\\n\\n      this.currentSegmentCallback = null;\\n      this.currentSubray = null;\\n    }\\n  }, {\\n    key: \\\"fractalRayRecursive\\\",\\n    value: function fractalRayRecursive(segment) {\\n      // Leave recursion condition\\n      if (segment.iteration >= this.currentSubray.maxIterations) {\\n        this.currentSegmentCallback(segment);\\n        return;\\n      } // Interpolation\\n\\n\\n      this.forwards.subVectors(segment.pos1, segment.pos0);\\n      var lForwards = this.forwards.length();\\n\\n      if (lForwards < 0.000001) {\\n        this.forwards.set(0, 0, 0.01);\\n        lForwards = this.forwards.length();\\n      }\\n\\n      var middleRadius = (segment.radius0 + segment.radius1) * 0.5;\\n      var middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\\n      var timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\\n      this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\\n      this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\\n      var p = this.middleLinPos; // Noise\\n\\n      this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\\n      this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\\n      this.newPos.add(this.middlePos); // Recursion\\n\\n      var newSegment1 = this.getNewSegment();\\n      newSegment1.pos0.copy(segment.pos0);\\n      newSegment1.pos1.copy(this.newPos);\\n      newSegment1.linPos0.copy(segment.linPos0);\\n      newSegment1.linPos1.copy(this.middleLinPos);\\n      newSegment1.up0.copy(segment.up0);\\n      newSegment1.up1.copy(segment.up1);\\n      newSegment1.radius0 = segment.radius0;\\n      newSegment1.radius1 = middleRadius;\\n      newSegment1.fraction0 = segment.fraction0;\\n      newSegment1.fraction1 = middleFraction;\\n      newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\\n      newSegment1.iteration = segment.iteration + 1;\\n      var newSegment2 = this.getNewSegment();\\n      newSegment2.pos0.copy(this.newPos);\\n      newSegment2.pos1.copy(segment.pos1);\\n      newSegment2.linPos0.copy(this.middleLinPos);\\n      newSegment2.linPos1.copy(segment.linPos1);\\n      this.cross1.crossVectors(segment.up0, this.forwards.normalize());\\n      newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\\n      newSegment2.up1.copy(segment.up1);\\n      newSegment2.radius0 = middleRadius;\\n      newSegment2.radius1 = segment.radius1;\\n      newSegment2.fraction0 = middleFraction;\\n      newSegment2.fraction1 = segment.fraction1;\\n      newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\\n      newSegment2.iteration = segment.iteration + 1;\\n      this.fractalRayRecursive(newSegment1);\\n      this.fractalRayRecursive(newSegment2);\\n    }\\n  }, {\\n    key: \\\"createPrism\\\",\\n    value: function createPrism(segment) {\\n      // Creates one triangular prism and its vertices at the segment\\n      this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\\n\\n      if (this.isInitialSegment) {\\n        this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\\n        this.isInitialSegment = false;\\n      }\\n\\n      this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\\n      this.createPrismFaces();\\n    }\\n  }, {\\n    key: \\\"createTriangleVerticesWithoutUVs\\\",\\n    value: function createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\\n      // Create an equilateral triangle (only vertices)\\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\\n      this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\\n      var p = this.vPos;\\n      var v = this.vertices;\\n      p.copy(pos).sub(this.side).add(this.down);\\n      v[this.currentCoordinate++] = p.x;\\n      v[this.currentCoordinate++] = p.y;\\n      v[this.currentCoordinate++] = p.z;\\n      p.copy(pos).add(this.side).add(this.down);\\n      v[this.currentCoordinate++] = p.x;\\n      v[this.currentCoordinate++] = p.y;\\n      v[this.currentCoordinate++] = p.z;\\n      p.copy(up).multiplyScalar(radius).add(pos);\\n      v[this.currentCoordinate++] = p.x;\\n      v[this.currentCoordinate++] = p.y;\\n      v[this.currentCoordinate++] = p.z;\\n      this.currentVertex += 3;\\n    }\\n  }, {\\n    key: \\\"createTriangleVerticesWithUVs\\\",\\n    value: function createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\\n      // Create an equilateral triangle (only vertices)\\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\\n      this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\\n      var p = this.vPos;\\n      var v = this.vertices;\\n      var uv = this.uvs;\\n      p.copy(pos).sub(this.side).add(this.down);\\n      v[this.currentCoordinate++] = p.x;\\n      v[this.currentCoordinate++] = p.y;\\n      v[this.currentCoordinate++] = p.z;\\n      uv[this.currentUVCoordinate++] = u;\\n      uv[this.currentUVCoordinate++] = 0;\\n      p.copy(pos).add(this.side).add(this.down);\\n      v[this.currentCoordinate++] = p.x;\\n      v[this.currentCoordinate++] = p.y;\\n      v[this.currentCoordinate++] = p.z;\\n      uv[this.currentUVCoordinate++] = u;\\n      uv[this.currentUVCoordinate++] = 0.5;\\n      p.copy(up).multiplyScalar(radius).add(pos);\\n      v[this.currentCoordinate++] = p.x;\\n      v[this.currentCoordinate++] = p.y;\\n      v[this.currentCoordinate++] = p.z;\\n      uv[this.currentUVCoordinate++] = u;\\n      uv[this.currentUVCoordinate++] = 1;\\n      this.currentVertex += 3;\\n    }\\n  }, {\\n    key: \\\"createPrismFaces\\\",\\n    value: function createPrismFaces(vertex\\n    /*, index*/\\n    ) {\\n      var indices = this.indices;\\n      var vertex = this.currentVertex - 6;\\n      indices[this.currentIndex++] = vertex + 1;\\n      indices[this.currentIndex++] = vertex + 2;\\n      indices[this.currentIndex++] = vertex + 5;\\n      indices[this.currentIndex++] = vertex + 1;\\n      indices[this.currentIndex++] = vertex + 5;\\n      indices[this.currentIndex++] = vertex + 4;\\n      indices[this.currentIndex++] = vertex + 0;\\n      indices[this.currentIndex++] = vertex + 1;\\n      indices[this.currentIndex++] = vertex + 4;\\n      indices[this.currentIndex++] = vertex + 0;\\n      indices[this.currentIndex++] = vertex + 4;\\n      indices[this.currentIndex++] = vertex + 3;\\n      indices[this.currentIndex++] = vertex + 2;\\n      indices[this.currentIndex++] = vertex + 0;\\n      indices[this.currentIndex++] = vertex + 3;\\n      indices[this.currentIndex++] = vertex + 2;\\n      indices[this.currentIndex++] = vertex + 3;\\n      indices[this.currentIndex++] = vertex + 5;\\n    }\\n  }, {\\n    key: \\\"createDefaultSubrayCreationCallbacks\\\",\\n    value: function createDefaultSubrayCreationCallbacks() {\\n      var random1 = this.randomGenerator.random;\\n\\n      this.onDecideSubrayCreation = function (segment, lightningStrike) {\\n        // Decide subrays creation at parent (sub)ray segment\\n        var subray = lightningStrike.currentSubray;\\n        var period = lightningStrike.rayParameters.subrayPeriod;\\n        var dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\\n        var phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : _three.MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\\n        var phase = lightningStrike.time - phase0;\\n        var currentCycle = Math.floor(phase / period);\\n        var childSubraySeed = random1() * (currentCycle + 1);\\n        var isActive = phase % period <= dutyCycle * period;\\n        var probability = 0;\\n\\n        if (isActive) {\\n          probability = lightningStrike.subrayProbability; // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\\n        }\\n\\n        if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\\n          var childSubray = lightningStrike.addNewSubray();\\n          var parentSeed = lightningStrike.randomGenerator.getSeed();\\n          childSubray.seed = childSubraySeed;\\n          lightningStrike.randomGenerator.setSeed(childSubraySeed);\\n          childSubray.recursion = subray.recursion + 1;\\n          childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\\n          childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\\n          childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\\n          childSubray.up0.copy(subray.up0);\\n          childSubray.up1.copy(subray.up1);\\n          childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\\n          childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\\n          childSubray.birthTime = phase0 + currentCycle * period;\\n          childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\\n\\n          if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\\n            childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\\n            childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\\n          }\\n\\n          childSubray.timeScale = subray.timeScale * 2;\\n          childSubray.roughness = subray.roughness;\\n          childSubray.straightness = subray.straightness;\\n          childSubray.propagationTimeFactor = subray.propagationTimeFactor;\\n          childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\\n          lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\\n          lightningStrike.randomGenerator.setSeed(parentSeed);\\n        }\\n      };\\n\\n      var vec1Pos = new _three.Vector3();\\n      var vec2Forward = new _three.Vector3();\\n      var vec3Side = new _three.Vector3();\\n      var vec4Up = new _three.Vector3();\\n\\n      this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\\n        // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\\n        // Just use the default cone position generator\\n        lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\\n      };\\n\\n      this.subrayConePosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\\n        // Sets childSubray pos0 and pos1 in a cone\\n        childSubray.pos0.copy(segment.pos0);\\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\\n        vec2Forward.copy(vec1Pos).normalize();\\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\\n        var length = vec1Pos.length();\\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\\n        var angle = 2 * Math.PI * random1();\\n        vec3Side.multiplyScalar(Math.cos(angle));\\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\\n      };\\n\\n      this.subrayCylinderPosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\\n        // Sets childSubray pos0 and pos1 in a cylinder\\n        childSubray.pos0.copy(segment.pos0);\\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\\n        vec2Forward.copy(vec1Pos).normalize();\\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\\n        var length = vec1Pos.length();\\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\\n        var angle = 2 * Math.PI * random1();\\n        vec3Side.multiplyScalar(Math.cos(angle));\\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\\n      };\\n    }\\n  }, {\\n    key: \\\"createSubray\\\",\\n    value: function createSubray() {\\n      return {\\n        seed: 0,\\n        maxIterations: 0,\\n        recursion: 0,\\n        pos0: new _three.Vector3(),\\n        pos1: new _three.Vector3(),\\n        linPos0: new _three.Vector3(),\\n        linPos1: new _three.Vector3(),\\n        up0: new _three.Vector3(),\\n        up1: new _three.Vector3(),\\n        radius0: 0,\\n        radius1: 0,\\n        birthTime: 0,\\n        deathTime: 0,\\n        timeScale: 0,\\n        roughness: 0,\\n        straightness: 0,\\n        propagationTimeFactor: 0,\\n        vanishingTimeFactor: 0,\\n        endPropagationTime: 0,\\n        beginVanishingTime: 0\\n      };\\n    }\\n  }, {\\n    key: \\\"createSegment\\\",\\n    value: function createSegment() {\\n      return {\\n        iteration: 0,\\n        pos0: new _three.Vector3(),\\n        pos1: new _three.Vector3(),\\n        linPos0: new _three.Vector3(),\\n        linPos1: new _three.Vector3(),\\n        up0: new _three.Vector3(),\\n        up1: new _three.Vector3(),\\n        radius0: 0,\\n        radius1: 0,\\n        fraction0: 0,\\n        fraction1: 0,\\n        positionVariationFactor: 0\\n      };\\n    }\\n  }, {\\n    key: \\\"getNewSegment\\\",\\n    value: function getNewSegment() {\\n      return this.raySegments[this.currentSegmentIndex++];\\n    }\\n  }, {\\n    key: \\\"copy\\\",\\n    value: function copy(source) {\\n      _get(_getPrototypeOf(LightningStrike.prototype), \\\"copy\\\", this).call(this, source);\\n\\n      this.init(LightningStrike.copyParameters({}, source.rayParameters));\\n      return this;\\n    }\\n  }, {\\n    key: \\\"clone\\\",\\n    value: function clone() {\\n      return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));\\n    }\\n  }]);\\n\\n  return LightningStrike;\\n}(_three.BufferGeometry);\\n\\nexports.LightningStrike = LightningStrike;\\nLightningStrike.prototype.isLightningStrike = true; // Ray states\\n\\nLightningStrike.RAY_INITIALIZED = 0;\\nLightningStrike.RAY_UNBORN = 1;\\nLightningStrike.RAY_PROPAGATING = 2;\\nLightningStrike.RAY_STEADY = 3;\\nLightningStrike.RAY_VANISHING = 4;\\nLightningStrike.RAY_EXTINGUISHED = 5;\\nLightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);\\nLightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);\\n\\nLightningStrike.createRandomGenerator = function () {\\n  var numSeeds = 2053;\\n  var seeds = [];\\n\\n  for (var i = 0; i < numSeeds; i++) {\\n    seeds.push(Math.random());\\n  }\\n\\n  var generator = {\\n    currentSeed: 0,\\n    random: function random() {\\n      var value = seeds[generator.currentSeed];\\n      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\\n      return value;\\n    },\\n    getSeed: function getSeed() {\\n      return generator.currentSeed / numSeeds;\\n    },\\n    setSeed: function setSeed(seed) {\\n      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\\n    }\\n  };\\n  return generator;\\n};\\n\\nLightningStrike.copyParameters = function (dest, source) {\\n  source = source || {};\\n  dest = dest || {};\\n\\n  var vecCopy = function vecCopy(v) {\\n    if (source === dest) {\\n      return v;\\n    } else {\\n      return v.clone();\\n    }\\n  };\\n\\n  dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new _three.Vector3(0, 100, 0), dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new _three.Vector3(0, 0, 0), dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1, dest.roughness = source.roughness !== undefined ? source.roughness : 0.9, dest.straightness = source.straightness !== undefined ? source.straightness : 0.7, dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new _three.Vector3(0, 0, 1);\\n  dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new _three.Vector3(0, 0, 1), dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1, dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\\n  dest.isEternal = source.isEternal !== undefined ? source.isEternal : source.birthTime === undefined || source.deathTime === undefined, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6; // These parameters cannot change after lightning creation:\\n\\n  dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9;\\n  dest.isStatic = source.isStatic !== undefined ? source.isStatic : false;\\n  dest.ramification = source.ramification !== undefined ? source.ramification : 5;\\n  dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;\\n  dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;\\n  dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;\\n  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\\n  return dest;\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_get\",\"property\",\"receiver\",\"Reflect\",\"get\",\"hasOwnProperty\",\"call\",\"object\",\"_getPrototypeOf\",\"base\",\"desc\",\"getOwnPropertyDescriptor\",\"value\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"_setPrototypeOf\",\"p\",\"LightningStrike\",\"_three\",\"_SimplexNoise\",\"_BufferGeometry\",\"rayParameters\",\"instance\",\"self\",\"ReferenceError\",\"_this\",\"type\",\"init\",\"copyParameters\",\"createMesh\",\"update\",\"time\",\"isStatic\",\"isEternal\",\"birthTime\",\"deathTime\",\"updateMesh\",\"state\",\"subrays\",\"endPropagationTime\",\"RAY_PROPAGATING\",\"beginVanishingTime\",\"RAY_VANISHING\",\"RAY_STEADY\",\"visible\",\"RAY_UNBORN\",\"RAY_EXTINGUISHED\",\"maxIterations\",\"undefined\",\"Math\",\"floor\",\"ramification\",\"maxSubrayRecursion\",\"recursionProbability\",\"generateUVs\",\"randomGenerator\",\"seedGenerator\",\"noiseSeed\",\"setSeed\",\"createRandomGenerator\",\"onDecideSubrayCreation\",\"createDefaultSubrayCreationCallbacks\",\"onSubrayCreation\",\"RAY_INITIALIZED\",\"maxSubrays\",\"ceil\",\"pow\",\"max\",\"maxRaySegments\",\"push\",\"createSubray\",\"raySegments\",\"_i\",\"createSegment\",\"timeFraction\",\"currentSegmentCallback\",\"currentCreateTriangleVertices\",\"createTriangleVerticesWithUVs\",\"createTriangleVerticesWithoutUVs\",\"numSubrays\",\"currentSubray\",\"currentSegmentIndex\",\"isInitialSegment\",\"currentUVCoordinate\",\"currentCoordinate\",\"currentIndex\",\"currentVertex\",\"subrayProbability\",\"uvsAttribute\",\"positionAttribute\",\"indices\",\"uvs\",\"vertices\",\"simplexX\",\"SimplexNoise\",\"simplexY\",\"simplexZ\",\"forwards\",\"Vector3\",\"forwardsFill\",\"side\",\"down\",\"middlePos\",\"middleLinPos\",\"newPos\",\"vPos\",\"cross1\",\"maxDrawableSegmentsPerSubRay\",\"maxVerts\",\"maxIndices\",\"Float32Array\",\"Uint32Array\",\"fillMesh\",\"setIndex\",\"Uint32BufferAttribute\",\"Float32BufferAttribute\",\"setAttribute\",\"index\",\"usage\",\"DynamicDrawUsage\",\"array\",\"drawRange\",\"count\",\"needsUpdate\",\"scope\",\"fractalRay\",\"fillVertices\",\"segment\",\"subray\",\"recursion\",\"createPrism\",\"fraction0\",\"propagationTimeFactor\",\"vanishingTimeFactor\",\"fraction1\",\"addNewSubray\",\"initSubray\",\"pos0\",\"copy\",\"sourceOffset\",\"pos1\",\"destOffset\",\"up0\",\"up1\",\"radius0\",\"radius1\",\"timeScale\",\"roughness\",\"straightness\",\"seed\",\"segmentCallback\",\"subrayIndex\",\"MathUtils\",\"lerp\",\"random1\",\"random\",\"linPos0\",\"set\",\"multiplyScalar\",\"linPos1\",\"getNewSegment\",\"iteration\",\"positionVariationFactor\",\"fractalRayRecursive\",\"subVectors\",\"lForwards\",\"middleRadius\",\"middleFraction\",\"timeDimension\",\"lerpVectors\",\"noise4d\",\"x\",\"y\",\"z\",\"add\",\"newSegment1\",\"newSegment2\",\"crossVectors\",\"normalize\",\"createPrismFaces\",\"pos\",\"up\",\"radius\",\"COS30DEG\",\"SIN30DEG\",\"v\",\"sub\",\"u\",\"uv\",\"vertex\",\"this.onDecideSubrayCreation\",\"lightningStrike\",\"period\",\"subrayPeriod\",\"dutyCycle\",\"subrayDutyCycle\",\"phase0\",\"phase\",\"currentCycle\",\"childSubraySeed\",\"probability\",\"childSubray\",\"parentSeed\",\"getSeed\",\"radius0Factor\",\"min\",\"minRadius\",\"radius1Factor\",\"vec1Pos\",\"vec2Forward\",\"vec3Side\",\"vec4Up\",\"this.onSubrayCreation\",\"parentSubray\",\"subrayCylinderPosition\",\"subrayConePosition\",\"this.subrayConePosition\",\"heightFactor\",\"sideWidthFactor\",\"minSideWidthFactor\",\"angle\",\"PI\",\"cos\",\"sin\",\"this.subrayCylinderPosition\",\"source\",\"clone\",\"BufferGeometry\",\"isLightningStrike\",\"LightningStrike.createRandomGenerator\",\"seeds\",\"numSeeds\",\"generator\",\"currentSeed\",\"LightningStrike.copyParameters\",\"dest\",\"vecCopy\"]\n}\n"]