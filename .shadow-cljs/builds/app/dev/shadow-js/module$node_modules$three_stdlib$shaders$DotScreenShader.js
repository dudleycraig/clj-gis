["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/DotScreenShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$DotScreenShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.DotScreenShader=void 0;global=require(\"module$node_modules$three$build$three_module\");global={uniforms:{tDiffuse:{value:null},tSize:{value:new global.Vector2(256,256)},center:{value:new global.Vector2(.5,.5)},angle:{value:1.57},scale:{value:1}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",\nfragmentShader:\"uniform vec2 center;\\nuniform float angle;\\nuniform float scale;\\nuniform vec2 tSize;\\nuniform sampler2D tDiffuse;\\nvarying vec2 vUv;\\nfloat pattern() {\\n\\tfloat s \\x3d sin( angle ), c \\x3d cos( angle );\\n\\tvec2 tex \\x3d vUv * tSize - center;\\n\\tvec2 point \\x3d vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\\n\\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\\n}\\nvoid main() {\\n\\tvec4 color \\x3d texture2D( tDiffuse, vUv );\\n\\tfloat average \\x3d ( color.r + color.g + color.b ) / 3.0;\\n\\tgl_FragColor \\x3d vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\\n}\"};\nexports.DotScreenShader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$DotScreenShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DotScreenShader = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Dot screen shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\nvar DotScreenShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    tSize: {\n      value: new _three.Vector2(256, 256)\n    },\n    center: {\n      value: new _three.Vector2(0.5, 0.5)\n    },\n    angle: {\n      value: 1.57\n    },\n    scale: {\n      value: 1.0\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform vec2 center;', 'uniform float angle;', 'uniform float scale;', 'uniform vec2 tSize;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'float pattern() {', '\tfloat s = sin( angle ), c = cos( angle );', '\tvec2 tex = vUv * tSize - center;', '\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;', '\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;', '}', 'void main() {', '\tvec4 color = texture2D( tDiffuse, vUv );', '\tfloat average = ( color.r + color.g + color.b ) / 3.0;', '\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );', '}'].join('\\n')\n};\nexports.DotScreenShader = DotScreenShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","scale","__esModule","tSize","tDiffuse","DotScreenShader","angle","vertexShader","value","center","uniforms"]],"~:compiled-at",1630917515530,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$DotScreenShader.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,wDAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGrHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,eAAR,CAA0B,IAAK,EAE3BC,OAAAA,CAASP,OAAA,CAAQ,8CAAR,CAOTM,OAAAA,CAAkB,CACpBE,SAAU,CACRC,SAAU,CACRJ,MAAO,IADC,CADF,CAIRK,MAAO,CACLL,MAAO,IAAIE,MAAOI,CAAAA,OAAX,CAAmB,GAAnB,CAAwB,GAAxB,CADF,CAJC,CAORC,OAAQ,CACNP,MAAO,IAAIE,MAAOI,CAAAA,OAAX,CAAmB,EAAnB,CAAwB,EAAxB,CADD,CAPA,CAURE,MAAO,CACLR,MAAO,IADF,CAVC,CAaRS,MAAO,CACLT,MAAO,CADF,CAbC,CADU,CAkBpBU,aAAiJ,qIAlB7H;AAmBpBC,eAA6lB,2kBAnBzkB,CAqBtBd;OAAQI,CAAAA,eAAR,CAA0BA,MApC2F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/DotScreenShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$DotScreenShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.DotScreenShader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Dot screen shader\\n * based on glfx.js sepia shader\\n * https://github.com/evanw/glfx.js\\n */\\nvar DotScreenShader = {\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    tSize: {\\n      value: new _three.Vector2(256, 256)\\n    },\\n    center: {\\n      value: new _three.Vector2(0.5, 0.5)\\n    },\\n    angle: {\\n      value: 1.57\\n    },\\n    scale: {\\n      value: 1.0\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform vec2 center;', 'uniform float angle;', 'uniform float scale;', 'uniform vec2 tSize;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'float pattern() {', '\\tfloat s = sin( angle ), c = cos( angle );', '\\tvec2 tex = vUv * tSize - center;', '\\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;', '\\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;', '}', 'void main() {', '\\tvec4 color = texture2D( tDiffuse, vUv );', '\\tfloat average = ( color.r + color.g + color.b ) / 3.0;', '\\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );', '}'].join('\\\\n')\\n};\\nexports.DotScreenShader = DotScreenShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"DotScreenShader\",\"_three\",\"uniforms\",\"tDiffuse\",\"tSize\",\"Vector2\",\"center\",\"angle\",\"scale\",\"vertexShader\",\"fragmentShader\"]\n}\n"]