["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/effects/PeppersGhostEffect.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$effects$PeppersGhostEffect=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.PeppersGhostEffect=void 0;var _three=require(\"module$node_modules$three$build$three_module\");exports.PeppersGhostEffect=function(renderer){var scope=this;scope.cameraDistance=15;scope.reflectFromAbove=!1;var _halfWidth,_width,_height,_cameraF=new _three.PerspectiveCamera,_cameraB=new _three.PerspectiveCamera,_cameraL=new _three.PerspectiveCamera,\n_cameraR=new _three.PerspectiveCamera,_position=new _three.Vector3,_quaternion=new _three.Quaternion,_scale=new _three.Vector3;renderer.autoClear=!1;this.setSize=function(width,height){_halfWidth=width/2;width<height?(_width=width/3,_height=width/3):(_width=height/3,_height=height/3);renderer.setSize(width,height)};this.render=function(scene,camera){scene.updateMatrixWorld();null===camera.parent&&camera.updateMatrixWorld();camera.matrixWorld.decompose(_position,_quaternion,_scale);_cameraF.position.copy(_position);\n_cameraF.quaternion.copy(_quaternion);_cameraF.translateZ(scope.cameraDistance);_cameraF.lookAt(scene.position);_cameraB.position.copy(_position);_cameraB.quaternion.copy(_quaternion);_cameraB.translateZ(-scope.cameraDistance);_cameraB.lookAt(scene.position);_cameraB.rotation.z+=Math.PI/180*180;_cameraL.position.copy(_position);_cameraL.quaternion.copy(_quaternion);_cameraL.translateX(-scope.cameraDistance);_cameraL.lookAt(scene.position);_cameraL.rotation.x+=Math.PI/180*90;_cameraR.position.copy(_position);\n_cameraR.quaternion.copy(_quaternion);_cameraR.translateX(scope.cameraDistance);_cameraR.lookAt(scene.position);_cameraR.rotation.x+=Math.PI/180*90;renderer.clear();renderer.setScissorTest(!0);renderer.setScissor(_halfWidth-_width/2,2*_height,_width,_height);renderer.setViewport(_halfWidth-_width/2,2*_height,_width,_height);scope.reflectFromAbove?renderer.render(scene,_cameraB):renderer.render(scene,_cameraF);renderer.setScissor(_halfWidth-_width/2,0,_width,_height);renderer.setViewport(_halfWidth-\n_width/2,0,_width,_height);scope.reflectFromAbove?renderer.render(scene,_cameraF):renderer.render(scene,_cameraB);renderer.setScissor(_halfWidth-_width/2-_width,_height,_width,_height);renderer.setViewport(_halfWidth-_width/2-_width,_height,_width,_height);scope.reflectFromAbove?renderer.render(scene,_cameraR):renderer.render(scene,_cameraL);renderer.setScissor(_halfWidth+_width/2,_height,_width,_height);renderer.setViewport(_halfWidth+_width/2,_height,_width,_height);scope.reflectFromAbove?renderer.render(scene,\n_cameraL):renderer.render(scene,_cameraR);renderer.setScissorTest(!1)}}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$effects$PeppersGhostEffect\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PeppersGhostEffect = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * peppers ghost effect based on http://www.instructables.com/id/Reflective-Prism/?ALLSTEPS\n */\nvar PeppersGhostEffect = function PeppersGhostEffect(renderer) {\n  var scope = this;\n  scope.cameraDistance = 15;\n  scope.reflectFromAbove = false; // Internals\n\n  var _halfWidth, _width, _height;\n\n  var _cameraF = new _three.PerspectiveCamera(); //front\n\n\n  var _cameraB = new _three.PerspectiveCamera(); //back\n\n\n  var _cameraL = new _three.PerspectiveCamera(); //left\n\n\n  var _cameraR = new _three.PerspectiveCamera(); //right\n\n\n  var _position = new _three.Vector3();\n\n  var _quaternion = new _three.Quaternion();\n\n  var _scale = new _three.Vector3(); // Initialization\n\n\n  renderer.autoClear = false;\n\n  this.setSize = function (width, height) {\n    _halfWidth = width / 2;\n\n    if (width < height) {\n      _width = width / 3;\n      _height = width / 3;\n    } else {\n      _width = height / 3;\n      _height = height / 3;\n    }\n\n    renderer.setSize(width, height);\n  };\n\n  this.render = function (scene, camera) {\n    scene.updateMatrixWorld();\n    if (camera.parent === null) camera.updateMatrixWorld();\n    camera.matrixWorld.decompose(_position, _quaternion, _scale); // front\n\n    _cameraF.position.copy(_position);\n\n    _cameraF.quaternion.copy(_quaternion);\n\n    _cameraF.translateZ(scope.cameraDistance);\n\n    _cameraF.lookAt(scene.position); // back\n\n\n    _cameraB.position.copy(_position);\n\n    _cameraB.quaternion.copy(_quaternion);\n\n    _cameraB.translateZ(-scope.cameraDistance);\n\n    _cameraB.lookAt(scene.position);\n\n    _cameraB.rotation.z += 180 * (Math.PI / 180); // left\n\n    _cameraL.position.copy(_position);\n\n    _cameraL.quaternion.copy(_quaternion);\n\n    _cameraL.translateX(-scope.cameraDistance);\n\n    _cameraL.lookAt(scene.position);\n\n    _cameraL.rotation.x += 90 * (Math.PI / 180); // right\n\n    _cameraR.position.copy(_position);\n\n    _cameraR.quaternion.copy(_quaternion);\n\n    _cameraR.translateX(scope.cameraDistance);\n\n    _cameraR.lookAt(scene.position);\n\n    _cameraR.rotation.x += 90 * (Math.PI / 180);\n    renderer.clear();\n    renderer.setScissorTest(true);\n    renderer.setScissor(_halfWidth - _width / 2, _height * 2, _width, _height);\n    renderer.setViewport(_halfWidth - _width / 2, _height * 2, _width, _height);\n\n    if (scope.reflectFromAbove) {\n      renderer.render(scene, _cameraB);\n    } else {\n      renderer.render(scene, _cameraF);\n    }\n\n    renderer.setScissor(_halfWidth - _width / 2, 0, _width, _height);\n    renderer.setViewport(_halfWidth - _width / 2, 0, _width, _height);\n\n    if (scope.reflectFromAbove) {\n      renderer.render(scene, _cameraF);\n    } else {\n      renderer.render(scene, _cameraB);\n    }\n\n    renderer.setScissor(_halfWidth - _width / 2 - _width, _height, _width, _height);\n    renderer.setViewport(_halfWidth - _width / 2 - _width, _height, _width, _height);\n\n    if (scope.reflectFromAbove) {\n      renderer.render(scene, _cameraR);\n    } else {\n      renderer.render(scene, _cameraL);\n    }\n\n    renderer.setScissor(_halfWidth + _width / 2, _height, _width, _height);\n    renderer.setViewport(_halfWidth + _width / 2, _height, _width, _height);\n\n    if (scope.reflectFromAbove) {\n      renderer.render(scene, _cameraL);\n    } else {\n      renderer.render(scene, _cameraR);\n    }\n\n    renderer.setScissorTest(false);\n  };\n};\n\nexports.PeppersGhostEffect = PeppersGhostEffect;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["z","cameraDistance","x","__esModule","value","autoClear","render","setSize","PeppersGhostEffect","reflectFromAbove"]],"~:compiled-at",1630917515597,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$effects$PeppersGhostEffect.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/effects/PeppersGhostEffect.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$effects$PeppersGhostEffect\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.PeppersGhostEffect = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * peppers ghost effect based on http://www.instructables.com/id/Reflective-Prism/?ALLSTEPS\\n */\\nvar PeppersGhostEffect = function PeppersGhostEffect(renderer) {\\n  var scope = this;\\n  scope.cameraDistance = 15;\\n  scope.reflectFromAbove = false; // Internals\\n\\n  var _halfWidth, _width, _height;\\n\\n  var _cameraF = new _three.PerspectiveCamera(); //front\\n\\n\\n  var _cameraB = new _three.PerspectiveCamera(); //back\\n\\n\\n  var _cameraL = new _three.PerspectiveCamera(); //left\\n\\n\\n  var _cameraR = new _three.PerspectiveCamera(); //right\\n\\n\\n  var _position = new _three.Vector3();\\n\\n  var _quaternion = new _three.Quaternion();\\n\\n  var _scale = new _three.Vector3(); // Initialization\\n\\n\\n  renderer.autoClear = false;\\n\\n  this.setSize = function (width, height) {\\n    _halfWidth = width / 2;\\n\\n    if (width < height) {\\n      _width = width / 3;\\n      _height = width / 3;\\n    } else {\\n      _width = height / 3;\\n      _height = height / 3;\\n    }\\n\\n    renderer.setSize(width, height);\\n  };\\n\\n  this.render = function (scene, camera) {\\n    scene.updateMatrixWorld();\\n    if (camera.parent === null) camera.updateMatrixWorld();\\n    camera.matrixWorld.decompose(_position, _quaternion, _scale); // front\\n\\n    _cameraF.position.copy(_position);\\n\\n    _cameraF.quaternion.copy(_quaternion);\\n\\n    _cameraF.translateZ(scope.cameraDistance);\\n\\n    _cameraF.lookAt(scene.position); // back\\n\\n\\n    _cameraB.position.copy(_position);\\n\\n    _cameraB.quaternion.copy(_quaternion);\\n\\n    _cameraB.translateZ(-scope.cameraDistance);\\n\\n    _cameraB.lookAt(scene.position);\\n\\n    _cameraB.rotation.z += 180 * (Math.PI / 180); // left\\n\\n    _cameraL.position.copy(_position);\\n\\n    _cameraL.quaternion.copy(_quaternion);\\n\\n    _cameraL.translateX(-scope.cameraDistance);\\n\\n    _cameraL.lookAt(scene.position);\\n\\n    _cameraL.rotation.x += 90 * (Math.PI / 180); // right\\n\\n    _cameraR.position.copy(_position);\\n\\n    _cameraR.quaternion.copy(_quaternion);\\n\\n    _cameraR.translateX(scope.cameraDistance);\\n\\n    _cameraR.lookAt(scene.position);\\n\\n    _cameraR.rotation.x += 90 * (Math.PI / 180);\\n    renderer.clear();\\n    renderer.setScissorTest(true);\\n    renderer.setScissor(_halfWidth - _width / 2, _height * 2, _width, _height);\\n    renderer.setViewport(_halfWidth - _width / 2, _height * 2, _width, _height);\\n\\n    if (scope.reflectFromAbove) {\\n      renderer.render(scene, _cameraB);\\n    } else {\\n      renderer.render(scene, _cameraF);\\n    }\\n\\n    renderer.setScissor(_halfWidth - _width / 2, 0, _width, _height);\\n    renderer.setViewport(_halfWidth - _width / 2, 0, _width, _height);\\n\\n    if (scope.reflectFromAbove) {\\n      renderer.render(scene, _cameraF);\\n    } else {\\n      renderer.render(scene, _cameraB);\\n    }\\n\\n    renderer.setScissor(_halfWidth - _width / 2 - _width, _height, _width, _height);\\n    renderer.setViewport(_halfWidth - _width / 2 - _width, _height, _width, _height);\\n\\n    if (scope.reflectFromAbove) {\\n      renderer.render(scene, _cameraR);\\n    } else {\\n      renderer.render(scene, _cameraL);\\n    }\\n\\n    renderer.setScissor(_halfWidth + _width / 2, _height, _width, _height);\\n    renderer.setViewport(_halfWidth + _width / 2, _height, _width, _height);\\n\\n    if (scope.reflectFromAbove) {\\n      renderer.render(scene, _cameraL);\\n    } else {\\n      renderer.render(scene, _cameraR);\\n    }\\n\\n    renderer.setScissorTest(false);\\n  };\\n};\\n\\nexports.PeppersGhostEffect = PeppersGhostEffect;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"PeppersGhostEffect\",\"_three\",\"renderer\",\"scope\",\"cameraDistance\",\"reflectFromAbove\",\"_halfWidth\",\"_width\",\"_height\",\"_cameraF\",\"PerspectiveCamera\",\"_cameraB\",\"_cameraL\",\"_cameraR\",\"_position\",\"Vector3\",\"_quaternion\",\"Quaternion\",\"_scale\",\"autoClear\",\"setSize\",\"this.setSize\",\"width\",\"height\",\"render\",\"this.render\",\"scene\",\"camera\",\"updateMatrixWorld\",\"parent\",\"matrixWorld\",\"decompose\",\"position\",\"copy\",\"quaternion\",\"translateZ\",\"lookAt\",\"rotation\",\"z\",\"Math\",\"PI\",\"translateX\",\"x\",\"clear\",\"setScissorTest\",\"setScissor\",\"setViewport\"]\n}\n"]