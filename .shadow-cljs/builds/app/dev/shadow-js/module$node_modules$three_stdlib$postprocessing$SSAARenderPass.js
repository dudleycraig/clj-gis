["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/postprocessing/SSAARenderPass.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$postprocessing$SSAARenderPass=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.SSAARenderPass=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_Pass=require(\"module$node_modules$three_stdlib$postprocessing$Pass\"),_CopyShader=require(\"module$node_modules$three_stdlib$shaders$CopyShader\"),SSAARenderPass=function(scene,camera,clearColor,clearAlpha){this.scene=scene;this.camera=\ncamera;this.sampleLevel=4;this.unbiased=!0;this.clearColor=void 0!==clearColor?clearColor:0;this.clearAlpha=void 0!==clearAlpha?clearAlpha:0;this._oldClearColor=new _three.Color;void 0===_CopyShader.CopyShader&&console.error(\"THREE.SSAARenderPass relies on CopyShader\");scene=_CopyShader.CopyShader;this.copyUniforms=_three.UniformsUtils.clone(scene.uniforms);this.copyMaterial=new _three.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:scene.vertexShader,fragmentShader:scene.fragmentShader,premultipliedAlpha:!0,\ntransparent:!0,blending:_three.AdditiveBlending,depthTest:!1,depthWrite:!1});this.fsQuad=new _Pass.FullScreenQuad(this.copyMaterial)};exports.SSAARenderPass=SSAARenderPass;SSAARenderPass.prototype=Object.assign(Object.create(_Pass.Pass.prototype),{constructor:SSAARenderPass,dispose:function(){this.sampleRenderTarget&&(this.sampleRenderTarget.dispose(),this.sampleRenderTarget=null)},setSize:function(width,height){this.sampleRenderTarget&&this.sampleRenderTarget.setSize(width,height)},render:function(renderer,\nwriteBuffer,readBuffer){this.sampleRenderTarget||(this.sampleRenderTarget=new _three.WebGLRenderTarget(readBuffer.width,readBuffer.height,{minFilter:_three.LinearFilter,magFilter:_three.LinearFilter,format:_three.RGBAFormat}),this.sampleRenderTarget.texture.name=\"SSAARenderPass.sample\");var jitterOffsets=SSAARenderPass.JitterVectors[Math.max(0,Math.min(this.sampleLevel,5))],autoClear=renderer.autoClear;renderer.autoClear=!1;renderer.getClearColor(this._oldClearColor);var oldClearAlpha=renderer.getClearAlpha(),\nbaseSampleWeight=1/jitterOffsets.length;this.copyUniforms.tDiffuse.value=this.sampleRenderTarget.texture;var width=readBuffer.width;readBuffer=readBuffer.height;for(var i=0;i<jitterOffsets.length;i++){var jitterOffset=jitterOffsets[i];this.camera.setViewOffset&&this.camera.setViewOffset(width,readBuffer,.0625*jitterOffset[0],.0625*jitterOffset[1],width,readBuffer);jitterOffset=baseSampleWeight;this.unbiased&&(jitterOffset+=.03125*(-.5+(i+.5)/jitterOffsets.length));this.copyUniforms.opacity.value=\njitterOffset;renderer.setClearColor(this.clearColor,this.clearAlpha);renderer.setRenderTarget(this.sampleRenderTarget);renderer.clear();renderer.render(this.scene,this.camera);renderer.setRenderTarget(this.renderToScreen?null:writeBuffer);0===i&&(renderer.setClearColor(0,0),renderer.clear());this.fsQuad.render(renderer)}this.camera.clearViewOffset&&this.camera.clearViewOffset();renderer.autoClear=autoClear;renderer.setClearColor(this._oldClearColor,oldClearAlpha)}});SSAARenderPass.JitterVectors=[[[0,\n0]],[[4,4],[-4,-4]],[[-2,-6],[6,-2],[-6,2],[2,6]],[[1,-3],[-1,3],[5,1],[-3,-5],[-5,5],[-7,-1],[3,7],[7,-7]],[[1,1],[-1,-3],[-3,2],[4,-1],[-5,-2],[2,5],[5,3],[3,-5],[-2,6],[0,-7],[-4,-6],[-6,4],[-8,0],[7,-4],[6,7],[-7,-8]],[[-4,-7],[-7,-5],[-3,-5],[-5,-4],[-1,-4],[-2,-2],[-6,-1],[-4,0],[-7,1],[-1,2],[-6,3],[-3,3],[-7,6],[-3,6],[-5,7],[-1,7],[5,-7],[1,-6],[6,-5],[4,-4],[2,-3],[7,-2],[1,-1],[4,-1],[2,1],[6,2],[0,4],[4,4],[2,5],[7,5],[5,6],[3,7]]]}","~:source","shadow$provide[\"module$node_modules$three_stdlib$postprocessing$SSAARenderPass\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SSAARenderPass = void 0;\n\nvar _three = require(\"three\");\n\nvar _Pass = require(\"./Pass.js\");\n\nvar _CopyShader = require(\"../shaders/CopyShader.js\");\n\n/**\n *\n * Supersample Anti-Aliasing Render Pass\n *\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n *\n * References: https://en.wikipedia.org/wiki/Supersampling\n *\n */\nvar SSAARenderPass = function SSAARenderPass(scene, camera, clearColor, clearAlpha) {\n  this.scene = scene;\n  this.camera = camera;\n  this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\n  this.unbiased = true; // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\n  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n  this._oldClearColor = new _three.Color();\n  if (_CopyShader.CopyShader === undefined) console.error('THREE.SSAARenderPass relies on CopyShader');\n  var copyShader = _CopyShader.CopyShader;\n  this.copyUniforms = _three.UniformsUtils.clone(copyShader.uniforms);\n  this.copyMaterial = new _three.ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    premultipliedAlpha: true,\n    transparent: true,\n    blending: _three.AdditiveBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  this.fsQuad = new _Pass.FullScreenQuad(this.copyMaterial);\n};\n\nexports.SSAARenderPass = SSAARenderPass;\nSSAARenderPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {\n  constructor: SSAARenderPass,\n  dispose: function dispose() {\n    if (this.sampleRenderTarget) {\n      this.sampleRenderTarget.dispose();\n      this.sampleRenderTarget = null;\n    }\n  },\n  setSize: function setSize(width, height) {\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n  },\n  render: function render(renderer, writeBuffer, readBuffer) {\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new _three.WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n        minFilter: _three.LinearFilter,\n        magFilter: _three.LinearFilter,\n        format: _three.RGBAFormat\n      });\n      this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\n    }\n\n    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.getClearColor(this._oldClearColor);\n    var oldClearAlpha = renderer.getClearAlpha();\n    var baseSampleWeight = 1.0 / jitterOffsets.length;\n    var roundingRange = 1 / 32;\n    this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n    var width = readBuffer.width,\n        height = readBuffer.height; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n    for (var i = 0; i < jitterOffsets.length; i++) {\n      var jitterOffset = jitterOffsets[i];\n\n      if (this.camera.setViewOffset) {\n        this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n        width, height);\n      }\n\n      var sampleWeight = baseSampleWeight;\n\n      if (this.unbiased) {\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\n        // across a range of values whose rounding errors cancel each other out.\n        var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n        sampleWeight += roundingRange * uniformCenteredDistribution;\n      }\n\n      this.copyUniforms['opacity'].value = sampleWeight;\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      renderer.setRenderTarget(this.sampleRenderTarget);\n      renderer.clear();\n      renderer.render(this.scene, this.camera);\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n\n      if (i === 0) {\n        renderer.setClearColor(0x000000, 0.0);\n        renderer.clear();\n      }\n\n      this.fsQuad.render(renderer);\n    }\n\n    if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    renderer.autoClear = autoClear;\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n  }\n}); // These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_stdlib$shaders$CopyShader","~$shadow.js","~$module$node_modules$three_stdlib$postprocessing$Pass"]],"~:properties",["^5",["fragmentShader","JitterVectors","copyMaterial","depthTest","blending","clearColor","prototype","transparent","__esModule","dispose","camera","premultipliedAlpha","unbiased","vertexShader","name","value","fsQuad","magFilter","copyUniforms","autoClear","render","_oldClearColor","setSize","depthWrite","clearAlpha","uniforms","minFilter","SSAARenderPass","sampleLevel","format","constructor","scene","sampleRenderTarget"]],"~:compiled-at",1630917515537,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$postprocessing$SSAARenderPass.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/postprocessing/SSAARenderPass.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$postprocessing$SSAARenderPass\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.SSAARenderPass = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _Pass = require(\\\"./Pass.js\\\");\\n\\nvar _CopyShader = require(\\\"../shaders/CopyShader.js\\\");\\n\\n/**\\n *\\n * Supersample Anti-Aliasing Render Pass\\n *\\n * This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\\n *\\n * References: https://en.wikipedia.org/wiki/Supersampling\\n *\\n */\\nvar SSAARenderPass = function SSAARenderPass(scene, camera, clearColor, clearAlpha) {\\n  this.scene = scene;\\n  this.camera = camera;\\n  this.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\\n\\n  this.unbiased = true; // as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\\n\\n  this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\\n  this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\\n  this._oldClearColor = new _three.Color();\\n  if (_CopyShader.CopyShader === undefined) console.error('THREE.SSAARenderPass relies on CopyShader');\\n  var copyShader = _CopyShader.CopyShader;\\n  this.copyUniforms = _three.UniformsUtils.clone(copyShader.uniforms);\\n  this.copyMaterial = new _three.ShaderMaterial({\\n    uniforms: this.copyUniforms,\\n    vertexShader: copyShader.vertexShader,\\n    fragmentShader: copyShader.fragmentShader,\\n    premultipliedAlpha: true,\\n    transparent: true,\\n    blending: _three.AdditiveBlending,\\n    depthTest: false,\\n    depthWrite: false\\n  });\\n  this.fsQuad = new _Pass.FullScreenQuad(this.copyMaterial);\\n};\\n\\nexports.SSAARenderPass = SSAARenderPass;\\nSSAARenderPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {\\n  constructor: SSAARenderPass,\\n  dispose: function dispose() {\\n    if (this.sampleRenderTarget) {\\n      this.sampleRenderTarget.dispose();\\n      this.sampleRenderTarget = null;\\n    }\\n  },\\n  setSize: function setSize(width, height) {\\n    if (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\\n  },\\n  render: function render(renderer, writeBuffer, readBuffer) {\\n    if (!this.sampleRenderTarget) {\\n      this.sampleRenderTarget = new _three.WebGLRenderTarget(readBuffer.width, readBuffer.height, {\\n        minFilter: _three.LinearFilter,\\n        magFilter: _three.LinearFilter,\\n        format: _three.RGBAFormat\\n      });\\n      this.sampleRenderTarget.texture.name = 'SSAARenderPass.sample';\\n    }\\n\\n    var jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\\n    var autoClear = renderer.autoClear;\\n    renderer.autoClear = false;\\n    renderer.getClearColor(this._oldClearColor);\\n    var oldClearAlpha = renderer.getClearAlpha();\\n    var baseSampleWeight = 1.0 / jitterOffsets.length;\\n    var roundingRange = 1 / 32;\\n    this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\\n    var width = readBuffer.width,\\n        height = readBuffer.height; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\\n\\n    for (var i = 0; i < jitterOffsets.length; i++) {\\n      var jitterOffset = jitterOffsets[i];\\n\\n      if (this.camera.setViewOffset) {\\n        this.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\\n        width, height);\\n      }\\n\\n      var sampleWeight = baseSampleWeight;\\n\\n      if (this.unbiased) {\\n        // the theory is that equal weights for each sample lead to an accumulation of rounding errors.\\n        // The following equation varies the sampleWeight per sample so that it is uniformly distributed\\n        // across a range of values whose rounding errors cancel each other out.\\n        var uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\\n        sampleWeight += roundingRange * uniformCenteredDistribution;\\n      }\\n\\n      this.copyUniforms['opacity'].value = sampleWeight;\\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\\n      renderer.setRenderTarget(this.sampleRenderTarget);\\n      renderer.clear();\\n      renderer.render(this.scene, this.camera);\\n      renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\\n\\n      if (i === 0) {\\n        renderer.setClearColor(0x000000, 0.0);\\n        renderer.clear();\\n      }\\n\\n      this.fsQuad.render(renderer);\\n    }\\n\\n    if (this.camera.clearViewOffset) this.camera.clearViewOffset();\\n    renderer.autoClear = autoClear;\\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha);\\n  }\\n}); // These jitter vectors are specified in integers because it is easier.\\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\\n// before being used, thus these integers need to be scaled by 1/16.\\n//\\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\\n\\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"SSAARenderPass\",\"_three\",\"_Pass\",\"_CopyShader\",\"scene\",\"camera\",\"clearColor\",\"clearAlpha\",\"sampleLevel\",\"unbiased\",\"undefined\",\"_oldClearColor\",\"Color\",\"CopyShader\",\"console\",\"error\",\"copyShader\",\"copyUniforms\",\"UniformsUtils\",\"clone\",\"uniforms\",\"copyMaterial\",\"ShaderMaterial\",\"vertexShader\",\"fragmentShader\",\"premultipliedAlpha\",\"transparent\",\"blending\",\"AdditiveBlending\",\"depthTest\",\"depthWrite\",\"fsQuad\",\"FullScreenQuad\",\"prototype\",\"assign\",\"create\",\"Pass\",\"constructor\",\"dispose\",\"sampleRenderTarget\",\"setSize\",\"width\",\"height\",\"render\",\"renderer\",\"writeBuffer\",\"readBuffer\",\"WebGLRenderTarget\",\"minFilter\",\"LinearFilter\",\"magFilter\",\"format\",\"RGBAFormat\",\"texture\",\"name\",\"jitterOffsets\",\"JitterVectors\",\"Math\",\"max\",\"min\",\"autoClear\",\"getClearColor\",\"oldClearAlpha\",\"getClearAlpha\",\"baseSampleWeight\",\"length\",\"i\",\"jitterOffset\",\"setViewOffset\",\"sampleWeight\",\"roundingRange\",\"setClearColor\",\"setRenderTarget\",\"clear\",\"renderToScreen\",\"clearViewOffset\"]\n}\n"]