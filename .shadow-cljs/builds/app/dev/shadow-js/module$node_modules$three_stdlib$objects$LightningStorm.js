["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/objects/LightningStorm.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$objects$LightningStorm=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=\ndescriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _possibleConstructorReturn(self,call){if(call&&(\"object\"===_typeof(call)||\"function\"===typeof call))return call;if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\nreturn self}function _get(target$jscomp$0,property$jscomp$0,receiver$jscomp$0){_get=\"undefined\"!==typeof Reflect&&Reflect.get?Reflect.get:function(target,property,receiver){for(;!Object.prototype.hasOwnProperty.call(target,property)&&(target=_getPrototypeOf(target),null!==target););if(target)return property=Object.getOwnPropertyDescriptor(target,property),property.get?property.get.call(receiver):property.value};return _get(target$jscomp$0,property$jscomp$0,receiver$jscomp$0||target$jscomp$0)}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=\nObject.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,\np$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.LightningStorm=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_LightningStrike=require(\"module$node_modules$three_stdlib$geometries$LightningStrike\");global=function(_Object3D){function LightningStorm(){var stormParams=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};\nif(!(this instanceof LightningStorm))throw new TypeError(\"Cannot call a class as a function\");var _this=_possibleConstructorReturn(this,_getPrototypeOf(LightningStorm).call(this));_this.stormParams=stormParams;stormParams.size=void 0!==stormParams.size?stormParams.size:1E3;stormParams.minHeight=void 0!==stormParams.minHeight?stormParams.minHeight:80;stormParams.maxHeight=void 0!==stormParams.maxHeight?stormParams.maxHeight:100;stormParams.maxSlope=void 0!==stormParams.maxSlope?stormParams.maxSlope:\n1.1;stormParams.maxLightnings=void 0!==stormParams.maxLightnings?stormParams.maxLightnings:3;stormParams.lightningMinPeriod=void 0!==stormParams.lightningMinPeriod?stormParams.lightningMinPeriod:3;stormParams.lightningMaxPeriod=void 0!==stormParams.lightningMaxPeriod?stormParams.lightningMaxPeriod:7;stormParams.lightningMinDuration=void 0!==stormParams.lightningMinDuration?stormParams.lightningMinDuration:1;stormParams.lightningMaxDuration=void 0!==stormParams.lightningMaxDuration?stormParams.lightningMaxDuration:\n2.5;_this.lightningParameters=_LightningStrike.LightningStrike.copyParameters(stormParams.lightningParameters,stormParams.lightningParameters);_this.lightningParameters.isEternal=!1;_this.lightningMaterial=void 0!==stormParams.lightningMaterial?stormParams.lightningMaterial:new _three.MeshBasicMaterial({color:11599871});_this.onRayPosition=void 0!==stormParams.onRayPosition?stormParams.onRayPosition:function(source,dest){dest.set((Math.random()-.5)*stormParams.size,0,(Math.random()-.5)*stormParams.size);\nvar height=_three.MathUtils.lerp(stormParams.minHeight,stormParams.maxHeight,Math.random());source.set(stormParams.maxSlope*(2*Math.random()-1),1,stormParams.maxSlope*(2*Math.random()-1)).multiplyScalar(height).add(dest)};_this.onLightningDown=stormParams.onLightningDown;_this.inited=!1;_this.nextLightningTime=0;_this.lightningsMeshes=[];_this.deadLightningsMeshes=[];for(var i=0;i<_this.stormParams.maxLightnings;i++){var lightning=new _LightningStrike.LightningStrike(_LightningStrike.LightningStrike.copyParameters({},\n_this.lightningParameters));lightning=new _three.Mesh(lightning,_this.lightningMaterial);_this.deadLightningsMeshes.push(lightning)}return _this}_inherits(LightningStorm,_Object3D);_createClass(LightningStorm,[{key:\"update\",value:function(time){this.inited||(this.nextLightningTime=this.getNextLightningTime(time)*Math.random(),this.inited=!0);if(time>=this.nextLightningTime){var lightningMesh=this.deadLightningsMeshes.pop();if(lightningMesh){var lightningParams1=_LightningStrike.LightningStrike.copyParameters(lightningMesh.geometry.rayParameters,\nthis.lightningParameters);lightningParams1.birthTime=time;lightningParams1.deathTime=time+_three.MathUtils.lerp(this.stormParams.lightningMinDuration,this.stormParams.lightningMaxDuration,Math.random());this.onRayPosition(lightningParams1.sourceOffset,lightningParams1.destOffset);lightningParams1.noiseSeed=Math.random();this.add(lightningMesh);this.lightningsMeshes.push(lightningMesh)}this.nextLightningTime=this.getNextLightningTime(time)}lightningMesh=0;for(lightningParams1=this.lightningsMeshes.length;lightningMesh<\nlightningParams1;){var mesh=this.lightningsMeshes[lightningMesh],lightning=mesh.geometry,prevState=lightning.state;lightning.update(time);if(prevState===_LightningStrike.LightningStrike.RAY_PROPAGATING&&lightning.state>prevState&&this.onLightningDown)this.onLightningDown(lightning);lightning.state===_LightningStrike.LightningStrike.RAY_EXTINGUISHED?(this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh),1),this.deadLightningsMeshes.push(mesh),this.remove(mesh),lightningParams1--):lightningMesh++}}},\n{key:\"getNextLightningTime\",value:function(currentTime){return currentTime+_three.MathUtils.lerp(this.stormParams.lightningMinPeriod,this.stormParams.lightningMaxPeriod,Math.random())/(this.stormParams.maxLightnings+1)}},{key:\"copy\",value:function(source){_get(_getPrototypeOf(LightningStorm.prototype),\"copy\",this).call(this,source);this.stormParams.size=source.stormParams.size;this.stormParams.minHeight=source.stormParams.minHeight;this.stormParams.maxHeight=source.stormParams.maxHeight;this.stormParams.maxSlope=\nsource.stormParams.maxSlope;this.stormParams.maxLightnings=source.stormParams.maxLightnings;this.stormParams.lightningMinPeriod=source.stormParams.lightningMinPeriod;this.stormParams.lightningMaxPeriod=source.stormParams.lightningMaxPeriod;this.stormParams.lightningMinDuration=source.stormParams.lightningMinDuration;this.stormParams.lightningMaxDuration=source.stormParams.lightningMaxDuration;this.lightningParameters=_LightningStrike.LightningStrike.copyParameters({},source.lightningParameters);this.lightningMaterial=\nsource.stormParams.lightningMaterial;this.onLightningDown=source.onLightningDown;return this}},{key:\"clone\",value:function(){return(new this.constructor(this.stormParams)).copy(this)}}]);return LightningStorm}(_three.Object3D);exports.LightningStorm=global;global.prototype.isLightningStorm=!0}","~:source","shadow$provide[\"module$node_modules$three_stdlib$objects$LightningStorm\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LightningStorm = void 0;\n\nvar _three = require(\"three\");\n\nvar _LightningStrike = require(\"../geometries/LightningStrike.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @fileoverview Lightning strike object generator\n *\n *\n * Usage\n *\n * const myStorm = new LightningStorm( paramsObject );\n * myStorm.position.set( ... );\n * scene.add( myStorm );\n * ...\n * myStorm.update( currentTime );\n *\n * The \"currentTime\" can only go forwards or be stopped.\n *\n *\n * LightningStorm parameters:\n *\n * @param {double} size Size of the storm. If no 'onRayPosition' parameter is defined, it means the side of the rectangle the storm covers.\n *\n * @param {double} minHeight Minimum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxHeight Maximum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxSlope The maximum inclination slope of a ray. If no 'onRayPosition' parameter is defined, it means the slope relative to plane y = 0.\n *\n * @param {integer} maxLightnings Greater than 0. The maximum number of simultaneous rays.\n *\n * @param {double} lightningMinPeriod minimum time between two consecutive rays.\n *\n * @param {double} lightningMaxPeriod maximum time between two consecutive rays.\n *\n * @param {double} lightningMinDuration The minimum time a ray can last.\n *\n * @param {double} lightningMaxDuration The maximum time a ray can last.\n *\n * @param {Object} lightningParameters The parameters for created rays. See LightningStrike (geometry)\n *\n * @param {Material} lightningMaterial The THREE.Material used for the created rays.\n *\n * @param {function} onRayPosition Optional callback with two Vector3 parameters (source, dest). You can set here the start and end points for each created ray, using the standard size, minHeight, etc parameters and other values in your algorithm.\n *\n * @param {function} onLightningDown This optional callback is called with one parameter (lightningStrike) when a ray ends propagating, so it has hit the ground.\n *\n *\n */\nvar LightningStorm =\n/*#__PURE__*/\nfunction (_Object3D) {\n  _inherits(LightningStorm, _Object3D);\n\n  function LightningStorm() {\n    var _this;\n\n    var stormParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LightningStorm);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LightningStorm).call(this)); // Parameters\n\n    _this.stormParams = stormParams;\n    stormParams.size = stormParams.size !== undefined ? stormParams.size : 1000.0;\n    stormParams.minHeight = stormParams.minHeight !== undefined ? stormParams.minHeight : 80.0;\n    stormParams.maxHeight = stormParams.maxHeight !== undefined ? stormParams.maxHeight : 100.0;\n    stormParams.maxSlope = stormParams.maxSlope !== undefined ? stormParams.maxSlope : 1.1;\n    stormParams.maxLightnings = stormParams.maxLightnings !== undefined ? stormParams.maxLightnings : 3;\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== undefined ? stormParams.lightningMinPeriod : 3.0;\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== undefined ? stormParams.lightningMaxPeriod : 7.0;\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== undefined ? stormParams.lightningMinDuration : 1.0;\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== undefined ? stormParams.lightningMaxDuration : 2.5;\n    _this.lightningParameters = _LightningStrike.LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);\n    _this.lightningParameters.isEternal = false;\n    _this.lightningMaterial = stormParams.lightningMaterial !== undefined ? stormParams.lightningMaterial : new _three.MeshBasicMaterial({\n      color: 0xb0ffff\n    });\n\n    if (stormParams.onRayPosition !== undefined) {\n      _this.onRayPosition = stormParams.onRayPosition;\n    } else {\n      _this.onRayPosition = function (source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\n\n        var height = _three.MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\n\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\n      };\n    }\n\n    _this.onLightningDown = stormParams.onLightningDown; // Internal state\n\n    _this.inited = false;\n    _this.nextLightningTime = 0;\n    _this.lightningsMeshes = [];\n    _this.deadLightningsMeshes = [];\n\n    for (var i = 0; i < _this.stormParams.maxLightnings; i++) {\n      var lightning = new _LightningStrike.LightningStrike(_LightningStrike.LightningStrike.copyParameters({}, _this.lightningParameters));\n      var mesh = new _three.Mesh(lightning, _this.lightningMaterial);\n\n      _this.deadLightningsMeshes.push(mesh);\n    }\n\n    return _this;\n  }\n\n  _createClass(LightningStorm, [{\n    key: \"update\",\n    value: function update(time) {\n      if (!this.inited) {\n        this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\n        this.inited = true;\n      }\n\n      if (time >= this.nextLightningTime) {\n        // Lightning creation\n        var lightningMesh = this.deadLightningsMeshes.pop();\n\n        if (lightningMesh) {\n          var lightningParams1 = _LightningStrike.LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);\n\n          lightningParams1.birthTime = time;\n          lightningParams1.deathTime = time + _three.MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\n          this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\n          lightningParams1.noiseSeed = Math.random();\n          this.add(lightningMesh);\n          this.lightningsMeshes.push(lightningMesh);\n        } // Schedule next lightning\n\n\n        this.nextLightningTime = this.getNextLightningTime(time);\n      }\n\n      var i = 0,\n          il = this.lightningsMeshes.length;\n\n      while (i < il) {\n        var mesh = this.lightningsMeshes[i];\n        var lightning = mesh.geometry;\n        var prevState = lightning.state;\n        lightning.update(time);\n\n        if (prevState === _LightningStrike.LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n          if (this.onLightningDown) {\n            this.onLightningDown(lightning);\n          }\n        }\n\n        if (lightning.state === _LightningStrike.LightningStrike.RAY_EXTINGUISHED) {\n          // Lightning is to be destroyed\n          this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\n          this.deadLightningsMeshes.push(mesh);\n          this.remove(mesh);\n          il--;\n        } else {\n          i++;\n        }\n      }\n    }\n  }, {\n    key: \"getNextLightningTime\",\n    value: function getNextLightningTime(currentTime) {\n      return currentTime + _three.MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(LightningStorm.prototype), \"copy\", this).call(this, source);\n\n      this.stormParams.size = source.stormParams.size;\n      this.stormParams.minHeight = source.stormParams.minHeight;\n      this.stormParams.maxHeight = source.stormParams.maxHeight;\n      this.stormParams.maxSlope = source.stormParams.maxSlope;\n      this.stormParams.maxLightnings = source.stormParams.maxLightnings;\n      this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\n      this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\n      this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\n      this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\n      this.lightningParameters = _LightningStrike.LightningStrike.copyParameters({}, source.lightningParameters);\n      this.lightningMaterial = source.stormParams.lightningMaterial;\n      this.onLightningDown = source.onLightningDown;\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this.stormParams).copy(this);\n    }\n  }]);\n\n  return LightningStorm;\n}(_three.Object3D);\n\nexports.LightningStorm = LightningStorm;\nLightningStorm.prototype.isLightningStorm = true;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$three_stdlib$geometries$LightningStrike"]],"~:properties",["^5",["maxSlope","inited","nextLightningTime","lightningMinDuration","minHeight","prototype","isEternal","lightningParameters","lightningMaterial","key","__esModule","lightningMaxPeriod","maxHeight","deadLightningsMeshes","maxLightnings","deathTime","configurable","value","onLightningDown","enumerable","writable","onRayPosition","__proto__","LightningStorm","isLightningStorm","size","stormParams","noiseSeed","birthTime","lightningMaxDuration","color","lightningsMeshes","constructor","lightningMinPeriod"]],"~:compiled-at",1630917515385,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$objects$LightningStorm.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/objects/LightningStorm.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$objects$LightningStorm\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.LightningStorm = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _LightningStrike = require(\\\"../geometries/LightningStrike.js\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _get(target, property, receiver) { if (typeof Reflect !== \\\"undefined\\\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\\n\\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * @fileoverview Lightning strike object generator\\n *\\n *\\n * Usage\\n *\\n * const myStorm = new LightningStorm( paramsObject );\\n * myStorm.position.set( ... );\\n * scene.add( myStorm );\\n * ...\\n * myStorm.update( currentTime );\\n *\\n * The \\\"currentTime\\\" can only go forwards or be stopped.\\n *\\n *\\n * LightningStorm parameters:\\n *\\n * @param {double} size Size of the storm. If no 'onRayPosition' parameter is defined, it means the side of the rectangle the storm covers.\\n *\\n * @param {double} minHeight Minimum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\\n *\\n * @param {double} maxHeight Maximum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\\n *\\n * @param {double} maxSlope The maximum inclination slope of a ray. If no 'onRayPosition' parameter is defined, it means the slope relative to plane y = 0.\\n *\\n * @param {integer} maxLightnings Greater than 0. The maximum number of simultaneous rays.\\n *\\n * @param {double} lightningMinPeriod minimum time between two consecutive rays.\\n *\\n * @param {double} lightningMaxPeriod maximum time between two consecutive rays.\\n *\\n * @param {double} lightningMinDuration The minimum time a ray can last.\\n *\\n * @param {double} lightningMaxDuration The maximum time a ray can last.\\n *\\n * @param {Object} lightningParameters The parameters for created rays. See LightningStrike (geometry)\\n *\\n * @param {Material} lightningMaterial The THREE.Material used for the created rays.\\n *\\n * @param {function} onRayPosition Optional callback with two Vector3 parameters (source, dest). You can set here the start and end points for each created ray, using the standard size, minHeight, etc parameters and other values in your algorithm.\\n *\\n * @param {function} onLightningDown This optional callback is called with one parameter (lightningStrike) when a ray ends propagating, so it has hit the ground.\\n *\\n *\\n */\\nvar LightningStorm =\\n/*#__PURE__*/\\nfunction (_Object3D) {\\n  _inherits(LightningStorm, _Object3D);\\n\\n  function LightningStorm() {\\n    var _this;\\n\\n    var stormParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n    _classCallCheck(this, LightningStorm);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LightningStorm).call(this)); // Parameters\\n\\n    _this.stormParams = stormParams;\\n    stormParams.size = stormParams.size !== undefined ? stormParams.size : 1000.0;\\n    stormParams.minHeight = stormParams.minHeight !== undefined ? stormParams.minHeight : 80.0;\\n    stormParams.maxHeight = stormParams.maxHeight !== undefined ? stormParams.maxHeight : 100.0;\\n    stormParams.maxSlope = stormParams.maxSlope !== undefined ? stormParams.maxSlope : 1.1;\\n    stormParams.maxLightnings = stormParams.maxLightnings !== undefined ? stormParams.maxLightnings : 3;\\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== undefined ? stormParams.lightningMinPeriod : 3.0;\\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== undefined ? stormParams.lightningMaxPeriod : 7.0;\\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== undefined ? stormParams.lightningMinDuration : 1.0;\\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== undefined ? stormParams.lightningMaxDuration : 2.5;\\n    _this.lightningParameters = _LightningStrike.LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);\\n    _this.lightningParameters.isEternal = false;\\n    _this.lightningMaterial = stormParams.lightningMaterial !== undefined ? stormParams.lightningMaterial : new _three.MeshBasicMaterial({\\n      color: 0xb0ffff\\n    });\\n\\n    if (stormParams.onRayPosition !== undefined) {\\n      _this.onRayPosition = stormParams.onRayPosition;\\n    } else {\\n      _this.onRayPosition = function (source, dest) {\\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\\n\\n        var height = _three.MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\\n\\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\\n      };\\n    }\\n\\n    _this.onLightningDown = stormParams.onLightningDown; // Internal state\\n\\n    _this.inited = false;\\n    _this.nextLightningTime = 0;\\n    _this.lightningsMeshes = [];\\n    _this.deadLightningsMeshes = [];\\n\\n    for (var i = 0; i < _this.stormParams.maxLightnings; i++) {\\n      var lightning = new _LightningStrike.LightningStrike(_LightningStrike.LightningStrike.copyParameters({}, _this.lightningParameters));\\n      var mesh = new _three.Mesh(lightning, _this.lightningMaterial);\\n\\n      _this.deadLightningsMeshes.push(mesh);\\n    }\\n\\n    return _this;\\n  }\\n\\n  _createClass(LightningStorm, [{\\n    key: \\\"update\\\",\\n    value: function update(time) {\\n      if (!this.inited) {\\n        this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\\n        this.inited = true;\\n      }\\n\\n      if (time >= this.nextLightningTime) {\\n        // Lightning creation\\n        var lightningMesh = this.deadLightningsMeshes.pop();\\n\\n        if (lightningMesh) {\\n          var lightningParams1 = _LightningStrike.LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);\\n\\n          lightningParams1.birthTime = time;\\n          lightningParams1.deathTime = time + _three.MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\\n          this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\\n          lightningParams1.noiseSeed = Math.random();\\n          this.add(lightningMesh);\\n          this.lightningsMeshes.push(lightningMesh);\\n        } // Schedule next lightning\\n\\n\\n        this.nextLightningTime = this.getNextLightningTime(time);\\n      }\\n\\n      var i = 0,\\n          il = this.lightningsMeshes.length;\\n\\n      while (i < il) {\\n        var mesh = this.lightningsMeshes[i];\\n        var lightning = mesh.geometry;\\n        var prevState = lightning.state;\\n        lightning.update(time);\\n\\n        if (prevState === _LightningStrike.LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\\n          if (this.onLightningDown) {\\n            this.onLightningDown(lightning);\\n          }\\n        }\\n\\n        if (lightning.state === _LightningStrike.LightningStrike.RAY_EXTINGUISHED) {\\n          // Lightning is to be destroyed\\n          this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\\n          this.deadLightningsMeshes.push(mesh);\\n          this.remove(mesh);\\n          il--;\\n        } else {\\n          i++;\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"getNextLightningTime\\\",\\n    value: function getNextLightningTime(currentTime) {\\n      return currentTime + _three.MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\\n    }\\n  }, {\\n    key: \\\"copy\\\",\\n    value: function copy(source) {\\n      _get(_getPrototypeOf(LightningStorm.prototype), \\\"copy\\\", this).call(this, source);\\n\\n      this.stormParams.size = source.stormParams.size;\\n      this.stormParams.minHeight = source.stormParams.minHeight;\\n      this.stormParams.maxHeight = source.stormParams.maxHeight;\\n      this.stormParams.maxSlope = source.stormParams.maxSlope;\\n      this.stormParams.maxLightnings = source.stormParams.maxLightnings;\\n      this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\\n      this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\\n      this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\\n      this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\\n      this.lightningParameters = _LightningStrike.LightningStrike.copyParameters({}, source.lightningParameters);\\n      this.lightningMaterial = source.stormParams.lightningMaterial;\\n      this.onLightningDown = source.onLightningDown;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"clone\\\",\\n    value: function clone() {\\n      return new this.constructor(this.stormParams).copy(this);\\n    }\\n  }]);\\n\\n  return LightningStorm;\\n}(_three.Object3D);\\n\\nexports.LightningStorm = LightningStorm;\\nLightningStorm.prototype.isLightningStorm = true;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_possibleConstructorReturn\",\"self\",\"call\",\"ReferenceError\",\"_get\",\"property\",\"receiver\",\"Reflect\",\"get\",\"hasOwnProperty\",\"object\",\"_getPrototypeOf\",\"base\",\"desc\",\"getOwnPropertyDescriptor\",\"value\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"_setPrototypeOf\",\"p\",\"LightningStorm\",\"_three\",\"_LightningStrike\",\"_Object3D\",\"stormParams\",\"arguments\",\"undefined\",\"instance\",\"_this\",\"size\",\"minHeight\",\"maxHeight\",\"maxSlope\",\"maxLightnings\",\"lightningMinPeriod\",\"lightningMaxPeriod\",\"lightningMinDuration\",\"lightningMaxDuration\",\"lightningParameters\",\"LightningStrike\",\"copyParameters\",\"isEternal\",\"lightningMaterial\",\"MeshBasicMaterial\",\"color\",\"onRayPosition\",\"_this.onRayPosition\",\"source\",\"dest\",\"set\",\"Math\",\"random\",\"height\",\"MathUtils\",\"lerp\",\"multiplyScalar\",\"add\",\"onLightningDown\",\"inited\",\"nextLightningTime\",\"lightningsMeshes\",\"deadLightningsMeshes\",\"lightning\",\"mesh\",\"Mesh\",\"push\",\"update\",\"time\",\"getNextLightningTime\",\"lightningMesh\",\"pop\",\"lightningParams1\",\"geometry\",\"rayParameters\",\"birthTime\",\"deathTime\",\"sourceOffset\",\"destOffset\",\"noiseSeed\",\"il\",\"prevState\",\"state\",\"RAY_PROPAGATING\",\"RAY_EXTINGUISHED\",\"splice\",\"indexOf\",\"remove\",\"currentTime\",\"copy\",\"clone\",\"Object3D\",\"isLightningStorm\"]\n}\n"]