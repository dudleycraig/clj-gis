["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/utils/GeometryCompressionUtils.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$utils$GeometryCompressionUtils=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:\nfunction(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||\nfunction(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.PackedPhongMaterial=exports.GeometryCompressionUtils=void 0;var _three=require(\"module$node_modules$three$build$three_module\");exports.GeometryCompressionUtils={compressNormals:function(mesh,encodeMethod){mesh.geometry||console.error(\"Mesh must contain geometry. \");var normal=mesh.geometry.attributes.normal;normal||console.error(\"Geometry must contain normal attribute. \");\nif(!normal.isPacked){3!=normal.itemSize&&console.error(\"normal.itemSize is not 3, which cannot be encoded. \");var array=normal.array;normal=normal.count;if(\"DEFAULT\"==encodeMethod){normal=new Uint8Array(3*normal);for(var idx=0;idx<array.length;idx+=3){var encoded=this.EncodingFuncs.defaultEncode(array[idx],array[idx+1],array[idx+2],1);normal[idx+0]=encoded[0];normal[idx+1]=encoded[1];normal[idx+2]=encoded[2]}mesh.geometry.setAttribute(\"normal\",new _three.BufferAttribute(normal,3,!0));mesh.geometry.attributes.normal.bytes=\n1*normal.length}else if(\"OCT1Byte\"==encodeMethod){normal=new Int8Array(2*normal);for(idx=0;idx<array.length;idx+=3)encoded=this.EncodingFuncs.octEncodeBest(array[idx],array[idx+1],array[idx+2],1),normal[idx/3*2]=encoded[0],normal[idx/3*2+1]=encoded[1];mesh.geometry.setAttribute(\"normal\",new _three.BufferAttribute(normal,2,!0));mesh.geometry.attributes.normal.bytes=1*normal.length}else if(\"OCT2Byte\"==encodeMethod){normal=new Int16Array(2*normal);for(idx=0;idx<array.length;idx+=3)encoded=this.EncodingFuncs.octEncodeBest(array[idx],\narray[idx+1],array[idx+2],2),normal[idx/3*2]=encoded[0],normal[idx/3*2+1]=encoded[1];mesh.geometry.setAttribute(\"normal\",new _three.BufferAttribute(normal,2,!0));mesh.geometry.attributes.normal.bytes=2*normal.length}else if(\"ANGLES\"==encodeMethod){normal=new Uint16Array(2*normal);for(idx=0;idx<array.length;idx+=3)encoded=this.EncodingFuncs.anglesEncode(array[idx],array[idx+1],array[idx+2]),normal[idx/3*2]=encoded[0],normal[idx/3*2+1]=encoded[1];mesh.geometry.setAttribute(\"normal\",new _three.BufferAttribute(normal,\n2,!0));mesh.geometry.attributes.normal.bytes=2*normal.length}else console.error(\"Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. \");mesh.geometry.attributes.normal.needsUpdate=!0;mesh.geometry.attributes.normal.isPacked=!0;mesh.geometry.attributes.normal.packingMethod=encodeMethod;mesh.material instanceof PackedPhongMaterial||(mesh.material=(new PackedPhongMaterial).copy(mesh.material));\"ANGLES\"==encodeMethod&&(mesh.material.defines.USE_PACKED_NORMAL=0);\"OCT1Byte\"==encodeMethod&&\n(mesh.material.defines.USE_PACKED_NORMAL=1);\"OCT2Byte\"==encodeMethod&&(mesh.material.defines.USE_PACKED_NORMAL=1);\"DEFAULT\"==encodeMethod&&(mesh.material.defines.USE_PACKED_NORMAL=2)}},compressPositions:function(mesh){mesh.geometry||console.error(\"Mesh must contain geometry. \");var position=mesh.geometry.attributes.position;position||console.error(\"Geometry must contain position attribute. \");if(!position.isPacked){3!=position.itemSize&&console.error(\"position.itemSize is not 3, which cannot be packed. \");\nvar result=this.EncodingFuncs.quantizedEncode(position.array,2);position=result.quantized;result=result.decodeMat;null==mesh.geometry.boundingBox&&mesh.geometry.computeBoundingBox();null==mesh.geometry.boundingSphere&&mesh.geometry.computeBoundingSphere();mesh.geometry.setAttribute(\"position\",new _three.BufferAttribute(position,3));mesh.geometry.attributes.position.isPacked=!0;mesh.geometry.attributes.position.needsUpdate=!0;mesh.geometry.attributes.position.bytes=2*position.length;mesh.material instanceof\nPackedPhongMaterial||(mesh.material=(new PackedPhongMaterial).copy(mesh.material));mesh.material.defines.USE_PACKED_POSITION=0;mesh.material.uniforms.quantizeMatPos.value=result;mesh.material.uniforms.quantizeMatPos.needsUpdate=!0}},compressUvs:function(mesh){mesh.geometry||console.error(\"Mesh must contain geometry property. \");var uvs=mesh.geometry.attributes.uv;uvs||console.error(\"Geometry must contain uv attribute. \");if(!uvs.isPacked){var JSCompiler_object_inline_min_6551=Infinity,JSCompiler_object_inline_max_6552=\n-Infinity;uvs=uvs.array;for(var i=0;i<uvs.length;i++)JSCompiler_object_inline_min_6551=Math.min(JSCompiler_object_inline_min_6551,uvs[i]),JSCompiler_object_inline_max_6552=Math.max(JSCompiler_object_inline_max_6552,uvs[i]);if(-1<=JSCompiler_object_inline_min_6551&&1>=JSCompiler_object_inline_max_6552){JSCompiler_object_inline_min_6551=new Uint16Array(uvs.length);for(JSCompiler_object_inline_max_6552=0;JSCompiler_object_inline_max_6552<uvs.length;JSCompiler_object_inline_max_6552+=2)i=this.EncodingFuncs.defaultEncode(uvs[JSCompiler_object_inline_max_6552],\nuvs[JSCompiler_object_inline_max_6552+1],0,2),JSCompiler_object_inline_min_6551[JSCompiler_object_inline_max_6552]=i[0],JSCompiler_object_inline_min_6551[JSCompiler_object_inline_max_6552+1]=i[1];mesh.geometry.setAttribute(\"uv\",new _three.BufferAttribute(JSCompiler_object_inline_min_6551,2,!0));mesh.geometry.attributes.uv.isPacked=!0;mesh.geometry.attributes.uv.needsUpdate=!0;mesh.geometry.attributes.uv.bytes=2*JSCompiler_object_inline_min_6551.length;mesh.material instanceof PackedPhongMaterial||\n(mesh.material=(new PackedPhongMaterial).copy(mesh.material));mesh.material.defines.USE_PACKED_UV=0}else JSCompiler_object_inline_min_6551=this.EncodingFuncs.quantizedEncodeUV(uvs,2),mesh.geometry.setAttribute(\"uv\",new _three.BufferAttribute(JSCompiler_object_inline_min_6551.quantized,2)),mesh.geometry.attributes.uv.isPacked=!0,mesh.geometry.attributes.uv.needsUpdate=!0,mesh.geometry.attributes.uv.bytes=2*JSCompiler_object_inline_min_6551.quantized.length,mesh.material instanceof PackedPhongMaterial||\n(mesh.material=(new PackedPhongMaterial).copy(mesh.material)),mesh.material.defines.USE_PACKED_UV=1,mesh.material.uniforms.quantizeMatUV.value=JSCompiler_object_inline_min_6551.decodeMat,mesh.material.uniforms.quantizeMatUV.needsUpdate=!0}},EncodingFuncs:{defaultEncode:function(x,y,z,bytes){if(1==bytes)return new Uint8Array([Math.round(127.5*(x+1)),Math.round(127.5*(y+1)),Math.round(127.5*(z+1))]);if(2==bytes)return new Uint16Array([Math.round(32767.5*(x+1)),Math.round(32767.5*(y+1)),Math.round(32767.5*\n(z+1))]);console.error(\"number of bytes must be 1 or 2\")},defaultDecode:function(array,bytes){if(1==bytes)return[array[0]/255*2-1,array[1]/255*2-1,array[2]/255*2-1];if(2==bytes)return[array[0]/65535*2-1,array[1]/65535*2-1,array[2]/65535*2-1];console.error(\"number of bytes must be 1 or 2\")},anglesEncode:function(x,y,z){x=parseInt(32767.5*(1+Math.atan2(y,x)/Math.PI));z=parseInt(32767.5*(1+z));return new Uint16Array([x,z])},octEncodeBest:function(x$jscomp$0,y,z$jscomp$0,bytes){function octEncodeVec3(x0,\ny0,z0,xfunc,yfunc){var x=x0/(Math.abs(x0)+Math.abs(y0)+Math.abs(z0));x0=y0/(Math.abs(x0)+Math.abs(y0)+Math.abs(z0));0>z$jscomp$0&&(y0=(1-Math.abs(x))*(0<=x0?1:-1),x=(1-Math.abs(x0))*(0<=x?1:-1),x0=y0,y0=1-Math.abs(x)-Math.abs(x0),0<y0&&(y0+=.001,x+=0<x?y0/2:-y0/2,x0+=0<x0?y0/2:-y0/2));if(1==bytes)return new Int8Array([Math[xfunc](127.5*x+(0>x?1:0)),Math[yfunc](127.5*x0+(0>x0?1:0))]);if(2==bytes)return new Int16Array([Math[xfunc](32767.5*x+(0>x?1:0)),Math[yfunc](32767.5*x0+(0>x0?1:0))])}function octDecodeVec2(oct){var x=\noct[0];oct=oct[1];1==bytes?(x/=0>x?127:128,oct/=0>oct?127:128):2==bytes&&(x/=0>x?32767:32768,oct/=0>oct?32767:32768);var z=1-Math.abs(x)-Math.abs(oct);if(0>z){var tmpx=x;x=(1-Math.abs(oct))*(0<=x?1:-1);oct=(1-Math.abs(tmpx))*(0<=oct?1:-1)}tmpx=Math.sqrt(x*x+oct*oct+z*z);return[x/tmpx,oct/tmpx,z/tmpx]}var oct;var best=oct=octEncodeVec3(x$jscomp$0,y,z$jscomp$0,\"floor\",\"floor\");var dec=octDecodeVec2(oct);var bestCos=x$jscomp$0*dec[0]+y*dec[1]+z$jscomp$0*dec[2];oct=octEncodeVec3(x$jscomp$0,y,z$jscomp$0,\n\"ceil\",\"floor\");dec=octDecodeVec2(oct);dec=x$jscomp$0*dec[0]+y*dec[1]+z$jscomp$0*dec[2];dec>bestCos&&(best=oct,bestCos=dec);oct=octEncodeVec3(x$jscomp$0,y,z$jscomp$0,\"floor\",\"ceil\");dec=octDecodeVec2(oct);dec=x$jscomp$0*dec[0]+y*dec[1]+z$jscomp$0*dec[2];dec>bestCos&&(best=oct,bestCos=dec);oct=octEncodeVec3(x$jscomp$0,y,z$jscomp$0,\"ceil\",\"ceil\");dec=octDecodeVec2(oct);dec=x$jscomp$0*dec[0]+y*dec[1]+z$jscomp$0*dec[2];dec>bestCos&&(best=oct);return best},quantizedEncode:function(array,bytes){if(1==bytes){var quantized=\nnew Uint8Array(array.length);var segments=255}else 2==bytes?(quantized=new Uint16Array(array.length),segments=65535):console.error(\"number of bytes error! \");bytes=new _three.Matrix4;var min=new Float32Array(3),max=new Float32Array(3);min[0]=min[1]=min[2]=Number.MAX_VALUE;max[0]=max[1]=max[2]=-Number.MAX_VALUE;for(var i=0;i<array.length;i+=3)min[0]=Math.min(min[0],array[i+0]),min[1]=Math.min(min[1],array[i+1]),min[2]=Math.min(min[2],array[i+2]),max[0]=Math.max(max[0],array[i+0]),max[1]=Math.max(max[1],\narray[i+1]),max[2]=Math.max(max[2],array[i+2]);bytes.scale(new _three.Vector3((max[0]-min[0])/segments,(max[1]-min[1])/segments,(max[2]-min[2])/segments));bytes.elements[12]=min[0];bytes.elements[13]=min[1];bytes.elements[14]=min[2];bytes.transpose();segments=new Float32Array([max[0]!==min[0]?segments/(max[0]-min[0]):0,max[1]!==min[1]?segments/(max[1]-min[1]):0,max[2]!==min[2]?segments/(max[2]-min[2]):0]);for(max=0;max<array.length;max+=3)quantized[max+0]=Math.floor((array[max+0]-min[0])*segments[0]),\nquantized[max+1]=Math.floor((array[max+1]-min[1])*segments[1]),quantized[max+2]=Math.floor((array[max+2]-min[2])*segments[2]);return{quantized,decodeMat:bytes}},quantizedEncodeUV:function(array,bytes){if(1==bytes){var quantized=new Uint8Array(array.length);var segments=255}else 2==bytes?(quantized=new Uint16Array(array.length),segments=65535):console.error(\"number of bytes error! \");bytes=new _three.Matrix3;var min=new Float32Array(2),max=new Float32Array(2);min[0]=min[1]=Number.MAX_VALUE;max[0]=\nmax[1]=-Number.MAX_VALUE;for(var i=0;i<array.length;i+=2)min[0]=Math.min(min[0],array[i+0]),min[1]=Math.min(min[1],array[i+1]),max[0]=Math.max(max[0],array[i+0]),max[1]=Math.max(max[1],array[i+1]);bytes.scale((max[0]-min[0])/segments,(max[1]-min[1])/segments);bytes.elements[6]=min[0];bytes.elements[7]=min[1];bytes.transpose();segments=new Float32Array([max[0]!==min[0]?segments/(max[0]-min[0]):0,max[1]!==min[1]?segments/(max[1]-min[1]):0]);for(max=0;max<array.length;max+=2)quantized[max+0]=Math.floor((array[max+\n0]-min[0])*segments[0]),quantized[max+1]=Math.floor((array[max+1]-min[1])*segments[1]);return{quantized,decodeMat:bytes}}}};var PackedPhongMaterial=function(_MeshPhongMaterial){function PackedPhongMaterial(parameters){if(!(this instanceof PackedPhongMaterial))throw new TypeError(\"Cannot call a class as a function\");var _this=_getPrototypeOf(PackedPhongMaterial).call(this);if(!_this||\"object\"!==_typeof(_this)&&\"function\"!==typeof _this){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n_this=this}_this.defines={};_this.type=\"PackedPhongMaterial\";_this.uniforms=_three.UniformsUtils.merge([_three.ShaderLib.phong.uniforms,{quantizeMatPos:{value:null},quantizeMatUV:{value:null}}]);_this.vertexShader=[\"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\nvarying vec3 vNormal;\\n#endif\",_three.ShaderChunk.common,_three.ShaderChunk.uv_pars_vertex,_three.ShaderChunk.uv2_pars_vertex,_three.ShaderChunk.displacementmap_pars_vertex,_three.ShaderChunk.envmap_pars_vertex,_three.ShaderChunk.color_pars_vertex,\n_three.ShaderChunk.fog_pars_vertex,_three.ShaderChunk.morphtarget_pars_vertex,_three.ShaderChunk.skinning_pars_vertex,_three.ShaderChunk.shadowmap_pars_vertex,_three.ShaderChunk.logdepthbuf_pars_vertex,_three.ShaderChunk.clipping_planes_pars_vertex,\"#ifdef USE_PACKED_NORMAL\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL \\x3d\\x3d 0\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tfloat x \\x3d packedNormal.x * 2.0 - 1.0;\\n\\t\\t\\t\\t\\t\\t\\tfloat y \\x3d packedNormal.y * 2.0 - 1.0;\\n\\t\\t\\t\\t\\t\\t\\tvec2 scth \\x3d vec2(sin(x * PI), cos(x * PI));\\n\\t\\t\\t\\t\\t\\t\\tvec2 scphi \\x3d vec2(sqrt(1.0 - y * y), y);\\n\\t\\t\\t\\t\\t\\t\\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL \\x3d\\x3d 1\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec3 v \\x3d vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\\n\\t\\t\\t\\t\\t\\t\\tif (v.z \\x3c 0.0)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tv.xy \\x3d (1.0 - abs(v.yx)) * vec2((v.x \\x3e\\x3d 0.0) ? +1.0 : -1.0, (v.y \\x3e\\x3d 0.0) ? +1.0 : -1.0);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn normalize(v);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL \\x3d\\x3d 2\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec3 v \\x3d (packedNormal * 2.0) - 1.0;\\n\\t\\t\\t\\t\\t\\t\\treturn normalize(v);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\\n#ifdef USE_PACKED_POSITION\\n\\t\\t\\t\\t\\t#if USE_PACKED_POSITION \\x3d\\x3d 0\\n\\t\\t\\t\\t\\t\\tuniform mat4 quantizeMatPos;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\\n#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV \\x3d\\x3d 1\\n\\t\\t\\t\\t\\t\\tuniform mat3 quantizeMatUV;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\\n#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV \\x3d\\x3d 0\\n\\t\\t\\t\\t\\t\\tvec2 decodeUV(vec2 packedUV)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec2 uv \\x3d (packedUV * 2.0) - 1.0;\\n\\t\\t\\t\\t\\t\\t\\treturn uv;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV \\x3d\\x3d 1\\n\\t\\t\\t\\t\\t\\tvec2 decodeUV(vec2 packedUV)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec2 uv \\x3d ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\\n\\t\\t\\t\\t\\t\\t\\treturn uv;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\\nvoid main() {\",\n_three.ShaderChunk.uv_vertex,\"#ifdef USE_UV\\n\\t\\t\\t\\t\\t#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t\\tvUv \\x3d decodeUV(vUv);\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\",_three.ShaderChunk.uv2_vertex,_three.ShaderChunk.color_vertex,_three.ShaderChunk.beginnormal_vertex,\"#ifdef USE_PACKED_NORMAL\\n\\t\\t\\t\\t\\tobjectNormal \\x3d decodeNormal(objectNormal);\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t#ifdef USE_TANGENT\\n\\t\\t\\t\\t\\tvec3 objectTangent \\x3d vec3( tangent.xyz );\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\",_three.ShaderChunk.morphnormal_vertex,_three.ShaderChunk.skinbase_vertex,\n_three.ShaderChunk.skinnormal_vertex,_three.ShaderChunk.defaultnormal_vertex,\"#ifndef FLAT_SHADED\\n\\tvNormal \\x3d normalize( transformedNormal );\\n#endif\",_three.ShaderChunk.begin_vertex,\"#ifdef USE_PACKED_POSITION\\n\\t\\t\\t\\t\\t#if USE_PACKED_POSITION \\x3d\\x3d 0\\n\\t\\t\\t\\t\\t\\ttransformed \\x3d ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\",_three.ShaderChunk.morphtarget_vertex,_three.ShaderChunk.skinning_vertex,_three.ShaderChunk.displacementmap_vertex,_three.ShaderChunk.project_vertex,\n_three.ShaderChunk.logdepthbuf_vertex,_three.ShaderChunk.clipping_planes_vertex,\"vViewPosition \\x3d - mvPosition.xyz;\",_three.ShaderChunk.worldpos_vertex,_three.ShaderChunk.envmap_vertex,_three.ShaderChunk.shadowmap_vertex,_three.ShaderChunk.fog_vertex,\"}\"].join(\"\\n\");_this.fragmentShader=[\"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\",_three.ShaderChunk.common,_three.ShaderChunk.packing,_three.ShaderChunk.dithering_pars_fragment,\n_three.ShaderChunk.color_pars_fragment,_three.ShaderChunk.uv_pars_fragment,_three.ShaderChunk.uv2_pars_fragment,_three.ShaderChunk.map_pars_fragment,_three.ShaderChunk.alphamap_pars_fragment,_three.ShaderChunk.aomap_pars_fragment,_three.ShaderChunk.lightmap_pars_fragment,_three.ShaderChunk.emissivemap_pars_fragment,_three.ShaderChunk.envmap_common_pars_fragment,_three.ShaderChunk.envmap_pars_fragment,_three.ShaderChunk.cube_uv_reflection_fragment,_three.ShaderChunk.fog_pars_fragment,_three.ShaderChunk.bsdfs,\n_three.ShaderChunk.lights_pars_begin,_three.ShaderChunk.lights_phong_pars_fragment,_three.ShaderChunk.shadowmap_pars_fragment,_three.ShaderChunk.bumpmap_pars_fragment,_three.ShaderChunk.normalmap_pars_fragment,_three.ShaderChunk.specularmap_pars_fragment,_three.ShaderChunk.logdepthbuf_pars_fragment,_three.ShaderChunk.clipping_planes_pars_fragment,\"void main() {\",_three.ShaderChunk.clipping_planes_fragment,\"vec4 diffuseColor \\x3d vec4( diffuse, opacity );\\nReflectedLight reflectedLight \\x3d ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\nvec3 totalEmissiveRadiance \\x3d emissive;\",\n_three.ShaderChunk.logdepthbuf_fragment,_three.ShaderChunk.map_fragment,_three.ShaderChunk.color_fragment,_three.ShaderChunk.alphamap_fragment,_three.ShaderChunk.alphatest_fragment,_three.ShaderChunk.specularmap_fragment,_three.ShaderChunk.normal_fragment_begin,_three.ShaderChunk.normal_fragment_maps,_three.ShaderChunk.emissivemap_fragment,_three.ShaderChunk.lights_phong_fragment,_three.ShaderChunk.lights_fragment_begin,_three.ShaderChunk.lights_fragment_maps,_three.ShaderChunk.lights_fragment_end,\n_three.ShaderChunk.aomap_fragment,\"vec3 outgoingLight \\x3d reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\",_three.ShaderChunk.envmap_fragment,\"gl_FragColor \\x3d vec4( outgoingLight, diffuseColor.a );\",_three.ShaderChunk.tonemapping_fragment,_three.ShaderChunk.encodings_fragment,_three.ShaderChunk.fog_fragment,_three.ShaderChunk.premultiplied_alpha_fragment,_three.ShaderChunk.dithering_fragment,\n\"}\"].join(\"\\n\");_this.setValues(parameters);return _this}_inherits(PackedPhongMaterial,_MeshPhongMaterial);return PackedPhongMaterial}(_three.MeshPhongMaterial);exports.PackedPhongMaterial=PackedPhongMaterial}","~:source","shadow$provide[\"module$node_modules$three_stdlib$utils$GeometryCompressionUtils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PackedPhongMaterial = exports.GeometryCompressionUtils = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Octahedron and Quantization encodings based on work by:\n *\n * @link https://github.com/tsherif/mesh-quantization-example\n *\n */\nvar GeometryCompressionUtils = {\n  /**\n   * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\n   *\n   * @param {THREE.Mesh} mesh\n   * @param {String} encodeMethod\t\t\"DEFAULT\" || \"OCT1Byte\" || \"OCT2Byte\" || \"ANGLES\"\n   *\n   */\n  compressNormals: function compressNormals(mesh, encodeMethod) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n\n    var normal = mesh.geometry.attributes.normal;\n\n    if (!normal) {\n      console.error('Geometry must contain normal attribute. ');\n    }\n\n    if (normal.isPacked) return;\n\n    if (normal.itemSize != 3) {\n      console.error('normal.itemSize is not 3, which cannot be encoded. ');\n    }\n\n    var array = normal.array;\n    var count = normal.count;\n    var result;\n\n    if (encodeMethod == 'DEFAULT') {\n      // TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\n      result = new Uint8Array(count * 3);\n\n      for (var idx = 0; idx < array.length; idx += 3) {\n        var encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);\n        result[idx + 0] = encoded[0];\n        result[idx + 1] = encoded[1];\n        result[idx + 2] = encoded[2];\n      }\n\n      mesh.geometry.setAttribute('normal', new _three.BufferAttribute(result, 3, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT1Byte') {\n      /**\n       * It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\n       * As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\n       * Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\n       */\n      result = new Int8Array(count * 2);\n\n      for (var _idx = 0; _idx < array.length; _idx += 3) {\n        var _encoded = this.EncodingFuncs.octEncodeBest(array[_idx], array[_idx + 1], array[_idx + 2], 1);\n\n        result[_idx / 3 * 2 + 0] = _encoded[0];\n        result[_idx / 3 * 2 + 1] = _encoded[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new _three.BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\n    } else if (encodeMethod == 'OCT2Byte') {\n      result = new Int16Array(count * 2);\n\n      for (var _idx2 = 0; _idx2 < array.length; _idx2 += 3) {\n        var _encoded2 = this.EncodingFuncs.octEncodeBest(array[_idx2], array[_idx2 + 1], array[_idx2 + 2], 2);\n\n        result[_idx2 / 3 * 2 + 0] = _encoded2[0];\n        result[_idx2 / 3 * 2 + 1] = _encoded2[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new _three.BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else if (encodeMethod == 'ANGLES') {\n      result = new Uint16Array(count * 2);\n\n      for (var _idx3 = 0; _idx3 < array.length; _idx3 += 3) {\n        var _encoded3 = this.EncodingFuncs.anglesEncode(array[_idx3], array[_idx3 + 1], array[_idx3 + 2]);\n\n        result[_idx3 / 3 * 2 + 0] = _encoded3[0];\n        result[_idx3 / 3 * 2 + 1] = _encoded3[1];\n      }\n\n      mesh.geometry.setAttribute('normal', new _three.BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\n    } else {\n      console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');\n    }\n\n    mesh.geometry.attributes.normal.needsUpdate = true;\n    mesh.geometry.attributes.normal.isPacked = true;\n    mesh.geometry.attributes.normal.packingMethod = encodeMethod; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n\n    if (encodeMethod == 'ANGLES') {\n      mesh.material.defines.USE_PACKED_NORMAL = 0;\n    }\n\n    if (encodeMethod == 'OCT1Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n\n    if (encodeMethod == 'OCT2Byte') {\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\n    }\n\n    if (encodeMethod == 'DEFAULT') {\n      mesh.material.defines.USE_PACKED_NORMAL = 2;\n    }\n  },\n\n  /**\n   * Make the input mesh.geometry's position attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressPositions: function compressPositions(mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry. ');\n    }\n\n    var position = mesh.geometry.attributes.position;\n\n    if (!position) {\n      console.error('Geometry must contain position attribute. ');\n    }\n\n    if (position.isPacked) return;\n\n    if (position.itemSize != 3) {\n      console.error('position.itemSize is not 3, which cannot be packed. ');\n    }\n\n    var array = position.array;\n    var encodingBytes = 2;\n    var result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);\n    var quantized = result.quantized;\n    var decodeMat = result.decodeMat; // IMPORTANT: calculate original geometry bounding info first, before updating packed positions\n\n    if (mesh.geometry.boundingBox == null) mesh.geometry.computeBoundingBox();\n    if (mesh.geometry.boundingSphere == null) mesh.geometry.computeBoundingSphere();\n    mesh.geometry.setAttribute('position', new _three.BufferAttribute(quantized, 3));\n    mesh.geometry.attributes.position.isPacked = true;\n    mesh.geometry.attributes.position.needsUpdate = true;\n    mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes; // modify material\n\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\n    }\n\n    mesh.material.defines.USE_PACKED_POSITION = 0;\n    mesh.material.uniforms.quantizeMatPos.value = decodeMat;\n    mesh.material.uniforms.quantizeMatPos.needsUpdate = true;\n  },\n\n  /**\n   * Make the input mesh.geometry's uv attribute encoded and compressed.\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\n   *\n   * @param {THREE.Mesh} mesh\n   *\n   */\n  compressUvs: function compressUvs(mesh) {\n    if (!mesh.geometry) {\n      console.error('Mesh must contain geometry property. ');\n    }\n\n    var uvs = mesh.geometry.attributes.uv;\n\n    if (!uvs) {\n      console.error('Geometry must contain uv attribute. ');\n    }\n\n    if (uvs.isPacked) return;\n    var range = {\n      min: Infinity,\n      max: -Infinity\n    };\n    var array = uvs.array;\n\n    for (var i = 0; i < array.length; i++) {\n      range.min = Math.min(range.min, array[i]);\n      range.max = Math.max(range.max, array[i]);\n    }\n\n    var result;\n\n    if (range.min >= -1.0 && range.max <= 1.0) {\n      // use default encoding method\n      result = new Uint16Array(array.length);\n\n      for (var _i = 0; _i < array.length; _i += 2) {\n        var encoded = this.EncodingFuncs.defaultEncode(array[_i], array[_i + 1], 0, 2);\n        result[_i] = encoded[0];\n        result[_i + 1] = encoded[1];\n      }\n\n      mesh.geometry.setAttribute('uv', new _three.BufferAttribute(result, 2, true));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.length * 2;\n\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n\n      mesh.material.defines.USE_PACKED_UV = 0;\n    } else {\n      // use quantized encoding method\n      result = this.EncodingFuncs.quantizedEncodeUV(array, 2);\n      mesh.geometry.setAttribute('uv', new _three.BufferAttribute(result.quantized, 2));\n      mesh.geometry.attributes.uv.isPacked = true;\n      mesh.geometry.attributes.uv.needsUpdate = true;\n      mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\n\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\n      }\n\n      mesh.material.defines.USE_PACKED_UV = 1;\n      mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\n      mesh.material.uniforms.quantizeMatUV.needsUpdate = true;\n    }\n  },\n  EncodingFuncs: {\n    defaultEncode: function defaultEncode(x, y, z, bytes) {\n      if (bytes == 1) {\n        var tmpx = Math.round((x + 1) * 0.5 * 255);\n        var tmpy = Math.round((y + 1) * 0.5 * 255);\n        var tmpz = Math.round((z + 1) * 0.5 * 255);\n        return new Uint8Array([tmpx, tmpy, tmpz]);\n      } else if (bytes == 2) {\n        var _tmpx = Math.round((x + 1) * 0.5 * 65535);\n\n        var _tmpy = Math.round((y + 1) * 0.5 * 65535);\n\n        var _tmpz = Math.round((z + 1) * 0.5 * 65535);\n\n        return new Uint16Array([_tmpx, _tmpy, _tmpz]);\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    defaultDecode: function defaultDecode(array, bytes) {\n      if (bytes == 1) {\n        return [array[0] / 255 * 2.0 - 1.0, array[1] / 255 * 2.0 - 1.0, array[2] / 255 * 2.0 - 1.0];\n      } else if (bytes == 2) {\n        return [array[0] / 65535 * 2.0 - 1.0, array[1] / 65535 * 2.0 - 1.0, array[2] / 65535 * 2.0 - 1.0];\n      } else {\n        console.error('number of bytes must be 1 or 2');\n      }\n    },\n    // for `Angles` encoding\n    anglesEncode: function anglesEncode(x, y, z) {\n      var normal0 = parseInt(0.5 * (1.0 + Math.atan2(y, x) / Math.PI) * 65535);\n      var normal1 = parseInt(0.5 * (1.0 + z) * 65535);\n      return new Uint16Array([normal0, normal1]);\n    },\n    // for `Octahedron` encoding\n    octEncodeBest: function octEncodeBest(x, y, z, bytes) {\n      var oct, dec, best, currentCos, bestCos; // Test various combinations of ceil and floor\n      // to minimize rounding errors\n\n      best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');\n      dec = octDecodeVec2(oct);\n      bestCos = dot(x, y, z, dec);\n      oct = octEncodeVec3(x, y, z, 'ceil', 'floor');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n\n      oct = octEncodeVec3(x, y, z, 'floor', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n        bestCos = currentCos;\n      }\n\n      oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');\n      dec = octDecodeVec2(oct);\n      currentCos = dot(x, y, z, dec);\n\n      if (currentCos > bestCos) {\n        best = oct;\n      }\n\n      return best;\n\n      function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {\n        var x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n        var y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n\n        if (z < 0) {\n          var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n          x = tempx;\n          y = tempy;\n          var diff = 1 - Math.abs(x) - Math.abs(y);\n\n          if (diff > 0) {\n            diff += 0.001;\n            x += x > 0 ? diff / 2 : -diff / 2;\n            y += y > 0 ? diff / 2 : -diff / 2;\n          }\n        }\n\n        if (bytes == 1) {\n          return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))]);\n        }\n\n        if (bytes == 2) {\n          return new Int16Array([Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))]);\n        }\n      }\n\n      function octDecodeVec2(oct) {\n        var x = oct[0];\n        var y = oct[1];\n\n        if (bytes == 1) {\n          x /= x < 0 ? 127 : 128;\n          y /= y < 0 ? 127 : 128;\n        } else if (bytes == 2) {\n          x /= x < 0 ? 32767 : 32768;\n          y /= y < 0 ? 32767 : 32768;\n        }\n\n        var z = 1 - Math.abs(x) - Math.abs(y);\n\n        if (z < 0) {\n          var tmpx = x;\n          x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n          y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);\n        }\n\n        var length = Math.sqrt(x * x + y * y + z * z);\n        return [x / length, y / length, z / length];\n      }\n\n      function dot(x, y, z, vec3) {\n        return x * vec3[0] + y * vec3[1] + z * vec3[2];\n      }\n    },\n    quantizedEncode: function quantizedEncode(array, bytes) {\n      var quantized, segments;\n\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n\n      var decodeMat = new _three.Matrix4();\n      var min = new Float32Array(3);\n      var max = new Float32Array(3);\n      min[0] = min[1] = min[2] = Number.MAX_VALUE;\n      max[0] = max[1] = max[2] = -Number.MAX_VALUE;\n\n      for (var i = 0; i < array.length; i += 3) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        min[2] = Math.min(min[2], array[i + 2]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n        max[2] = Math.max(max[2], array[i + 2]);\n      }\n\n      decodeMat.scale(new _three.Vector3((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));\n      decodeMat.elements[12] = min[0];\n      decodeMat.elements[13] = min[1];\n      decodeMat.elements[14] = min[2];\n      decodeMat.transpose();\n      var multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0, max[2] !== min[2] ? segments / (max[2] - min[2]) : 0]);\n\n      for (var _i2 = 0; _i2 < array.length; _i2 += 3) {\n        quantized[_i2 + 0] = Math.floor((array[_i2 + 0] - min[0]) * multiplier[0]);\n        quantized[_i2 + 1] = Math.floor((array[_i2 + 1] - min[1]) * multiplier[1]);\n        quantized[_i2 + 2] = Math.floor((array[_i2 + 2] - min[2]) * multiplier[2]);\n      }\n\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    },\n    quantizedEncodeUV: function quantizedEncodeUV(array, bytes) {\n      var quantized, segments;\n\n      if (bytes == 1) {\n        quantized = new Uint8Array(array.length);\n        segments = 255;\n      } else if (bytes == 2) {\n        quantized = new Uint16Array(array.length);\n        segments = 65535;\n      } else {\n        console.error('number of bytes error! ');\n      }\n\n      var decodeMat = new _three.Matrix3();\n      var min = new Float32Array(2);\n      var max = new Float32Array(2);\n      min[0] = min[1] = Number.MAX_VALUE;\n      max[0] = max[1] = -Number.MAX_VALUE;\n\n      for (var i = 0; i < array.length; i += 2) {\n        min[0] = Math.min(min[0], array[i + 0]);\n        min[1] = Math.min(min[1], array[i + 1]);\n        max[0] = Math.max(max[0], array[i + 0]);\n        max[1] = Math.max(max[1], array[i + 1]);\n      }\n\n      decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);\n      decodeMat.elements[6] = min[0];\n      decodeMat.elements[7] = min[1];\n      decodeMat.transpose();\n      var multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0]);\n\n      for (var _i3 = 0; _i3 < array.length; _i3 += 2) {\n        quantized[_i3 + 0] = Math.floor((array[_i3 + 0] - min[0]) * multiplier[0]);\n        quantized[_i3 + 1] = Math.floor((array[_i3 + 1] - min[1]) * multiplier[1]);\n      }\n\n      return {\n        quantized: quantized,\n        decodeMat: decodeMat\n      };\n    }\n  }\n};\n/**\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\n *\n * @param {Object} parameters\n */\n\nexports.GeometryCompressionUtils = GeometryCompressionUtils;\n\nvar PackedPhongMaterial =\n/*#__PURE__*/\nfunction (_MeshPhongMaterial) {\n  _inherits(PackedPhongMaterial, _MeshPhongMaterial);\n\n  function PackedPhongMaterial(parameters) {\n    var _this;\n\n    _classCallCheck(this, PackedPhongMaterial);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PackedPhongMaterial).call(this));\n    _this.defines = {};\n    _this.type = 'PackedPhongMaterial';\n    _this.uniforms = _three.UniformsUtils.merge([_three.ShaderLib.phong.uniforms, {\n      quantizeMatPos: {\n        value: null\n      },\n      quantizeMatUV: {\n        value: null\n      }\n    }]);\n    _this.vertexShader = ['#define PHONG', 'varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', 'varying vec3 vNormal;', '#endif', _three.ShaderChunk.common, _three.ShaderChunk.uv_pars_vertex, _three.ShaderChunk.uv2_pars_vertex, _three.ShaderChunk.displacementmap_pars_vertex, _three.ShaderChunk.envmap_pars_vertex, _three.ShaderChunk.color_pars_vertex, _three.ShaderChunk.fog_pars_vertex, _three.ShaderChunk.morphtarget_pars_vertex, _three.ShaderChunk.skinning_pars_vertex, _three.ShaderChunk.shadowmap_pars_vertex, _three.ShaderChunk.logdepthbuf_pars_vertex, _three.ShaderChunk.clipping_planes_pars_vertex, \"#ifdef USE_PACKED_NORMAL\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL == 0\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tfloat x = packedNormal.x * 2.0 - 1.0;\\n\\t\\t\\t\\t\\t\\t\\tfloat y = packedNormal.y * 2.0 - 1.0;\\n\\t\\t\\t\\t\\t\\t\\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\\n\\t\\t\\t\\t\\t\\t\\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\\n\\t\\t\\t\\t\\t\\t\\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL == 1\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\\n\\t\\t\\t\\t\\t\\t\\tif (v.z < 0.0)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn normalize(v);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_NORMAL == 2\\n\\t\\t\\t\\t\\t\\tvec3 decodeNormal(vec3 packedNormal)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec3 v = (packedNormal * 2.0) - 1.0;\\n\\t\\t\\t\\t\\t\\t\\treturn normalize(v);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", \"#ifdef USE_PACKED_POSITION\\n\\t\\t\\t\\t\\t#if USE_PACKED_POSITION == 0\\n\\t\\t\\t\\t\\t\\tuniform mat4 quantizeMatPos;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", \"#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV == 1\\n\\t\\t\\t\\t\\t\\tuniform mat3 quantizeMatUV;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", \"#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV == 0\\n\\t\\t\\t\\t\\t\\tvec2 decodeUV(vec2 packedUV)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec2 uv = (packedUV * 2.0) - 1.0;\\n\\t\\t\\t\\t\\t\\t\\treturn uv;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t\\t#if USE_PACKED_UV == 1\\n\\t\\t\\t\\t\\t\\tvec2 decodeUV(vec2 packedUV)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\\n\\t\\t\\t\\t\\t\\t\\treturn uv;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", 'void main() {', _three.ShaderChunk.uv_vertex, \"#ifdef USE_UV\\n\\t\\t\\t\\t\\t#ifdef USE_PACKED_UV\\n\\t\\t\\t\\t\\t\\tvUv = decodeUV(vUv);\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", _three.ShaderChunk.uv2_vertex, _three.ShaderChunk.color_vertex, _three.ShaderChunk.beginnormal_vertex, \"#ifdef USE_PACKED_NORMAL\\n\\t\\t\\t\\t\\tobjectNormal = decodeNormal(objectNormal);\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\t#ifdef USE_TANGENT\\n\\t\\t\\t\\t\\tvec3 objectTangent = vec3( tangent.xyz );\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t\", _three.ShaderChunk.morphnormal_vertex, _three.ShaderChunk.skinbase_vertex, _three.ShaderChunk.skinnormal_vertex, _three.ShaderChunk.defaultnormal_vertex, '#ifndef FLAT_SHADED', '\tvNormal = normalize( transformedNormal );', '#endif', _three.ShaderChunk.begin_vertex, \"#ifdef USE_PACKED_POSITION\\n\\t\\t\\t\\t\\t#if USE_PACKED_POSITION == 0\\n\\t\\t\\t\\t\\t\\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\\n\\t\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#endif\", _three.ShaderChunk.morphtarget_vertex, _three.ShaderChunk.skinning_vertex, _three.ShaderChunk.displacementmap_vertex, _three.ShaderChunk.project_vertex, _three.ShaderChunk.logdepthbuf_vertex, _three.ShaderChunk.clipping_planes_vertex, 'vViewPosition = - mvPosition.xyz;', _three.ShaderChunk.worldpos_vertex, _three.ShaderChunk.envmap_vertex, _three.ShaderChunk.shadowmap_vertex, _three.ShaderChunk.fog_vertex, '}'].join('\\n'); // Use the original MeshPhongMaterial's fragmentShader.\n\n    _this.fragmentShader = ['#define PHONG', 'uniform vec3 diffuse;', 'uniform vec3 emissive;', 'uniform vec3 specular;', 'uniform float shininess;', 'uniform float opacity;', _three.ShaderChunk.common, _three.ShaderChunk.packing, _three.ShaderChunk.dithering_pars_fragment, _three.ShaderChunk.color_pars_fragment, _three.ShaderChunk.uv_pars_fragment, _three.ShaderChunk.uv2_pars_fragment, _three.ShaderChunk.map_pars_fragment, _three.ShaderChunk.alphamap_pars_fragment, _three.ShaderChunk.aomap_pars_fragment, _three.ShaderChunk.lightmap_pars_fragment, _three.ShaderChunk.emissivemap_pars_fragment, _three.ShaderChunk.envmap_common_pars_fragment, _three.ShaderChunk.envmap_pars_fragment, _three.ShaderChunk.cube_uv_reflection_fragment, _three.ShaderChunk.fog_pars_fragment, _three.ShaderChunk.bsdfs, _three.ShaderChunk.lights_pars_begin, _three.ShaderChunk.lights_phong_pars_fragment, _three.ShaderChunk.shadowmap_pars_fragment, _three.ShaderChunk.bumpmap_pars_fragment, _three.ShaderChunk.normalmap_pars_fragment, _three.ShaderChunk.specularmap_pars_fragment, _three.ShaderChunk.logdepthbuf_pars_fragment, _three.ShaderChunk.clipping_planes_pars_fragment, 'void main() {', _three.ShaderChunk.clipping_planes_fragment, 'vec4 diffuseColor = vec4( diffuse, opacity );', 'ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', 'vec3 totalEmissiveRadiance = emissive;', _three.ShaderChunk.logdepthbuf_fragment, _three.ShaderChunk.map_fragment, _three.ShaderChunk.color_fragment, _three.ShaderChunk.alphamap_fragment, _three.ShaderChunk.alphatest_fragment, _three.ShaderChunk.specularmap_fragment, _three.ShaderChunk.normal_fragment_begin, _three.ShaderChunk.normal_fragment_maps, _three.ShaderChunk.emissivemap_fragment, // accumulation\n    _three.ShaderChunk.lights_phong_fragment, _three.ShaderChunk.lights_fragment_begin, _three.ShaderChunk.lights_fragment_maps, _three.ShaderChunk.lights_fragment_end, // modulation\n    _three.ShaderChunk.aomap_fragment, 'vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;', _three.ShaderChunk.envmap_fragment, 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', _three.ShaderChunk.tonemapping_fragment, _three.ShaderChunk.encodings_fragment, _three.ShaderChunk.fog_fragment, _three.ShaderChunk.premultiplied_alpha_fragment, _three.ShaderChunk.dithering_fragment, '}'].join('\\n');\n\n    _this.setValues(parameters);\n\n    return _this;\n  }\n\n  return PackedPhongMaterial;\n}(_three.MeshPhongMaterial);\n\nexports.PackedPhongMaterial = PackedPhongMaterial;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","octEncodeBest","defaultEncode","needsUpdate","compressUvs","prototype","quantizeMatPos","EncodingFuncs","isPacked","__esModule","USE_PACKED_NORMAL","defines","vertexShader","configurable","value","quantizedEncodeUV","defaultDecode","compressNormals","GeometryCompressionUtils","writable","anglesEncode","compressPositions","bytes","PackedPhongMaterial","type","__proto__","packingMethod","uniforms","quantizedEncode","quantized","quantizeMatUV","USE_PACKED_UV","decodeMat","constructor","USE_PACKED_POSITION","material"]],"~:compiled-at",1630917515409,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$utils$GeometryCompressionUtils.js\",\n\"lineCount\":33,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/utils/GeometryCompressionUtils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$utils$GeometryCompressionUtils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.PackedPhongMaterial = exports.GeometryCompressionUtils = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * Octahedron and Quantization encodings based on work by:\\n *\\n * @link https://github.com/tsherif/mesh-quantization-example\\n *\\n */\\nvar GeometryCompressionUtils = {\\n  /**\\n   * Make the input mesh.geometry's normal attribute encoded and compressed by 3 different methods.\\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the normal data.\\n   *\\n   * @param {THREE.Mesh} mesh\\n   * @param {String} encodeMethod\\t\\t\\\"DEFAULT\\\" || \\\"OCT1Byte\\\" || \\\"OCT2Byte\\\" || \\\"ANGLES\\\"\\n   *\\n   */\\n  compressNormals: function compressNormals(mesh, encodeMethod) {\\n    if (!mesh.geometry) {\\n      console.error('Mesh must contain geometry. ');\\n    }\\n\\n    var normal = mesh.geometry.attributes.normal;\\n\\n    if (!normal) {\\n      console.error('Geometry must contain normal attribute. ');\\n    }\\n\\n    if (normal.isPacked) return;\\n\\n    if (normal.itemSize != 3) {\\n      console.error('normal.itemSize is not 3, which cannot be encoded. ');\\n    }\\n\\n    var array = normal.array;\\n    var count = normal.count;\\n    var result;\\n\\n    if (encodeMethod == 'DEFAULT') {\\n      // TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.\\n      result = new Uint8Array(count * 3);\\n\\n      for (var idx = 0; idx < array.length; idx += 3) {\\n        var encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);\\n        result[idx + 0] = encoded[0];\\n        result[idx + 1] = encoded[1];\\n        result[idx + 2] = encoded[2];\\n      }\\n\\n      mesh.geometry.setAttribute('normal', new _three.BufferAttribute(result, 3, true));\\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\\n    } else if (encodeMethod == 'OCT1Byte') {\\n      /**\\n       * It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage\\n       * As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible\\n       * Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208\\n       */\\n      result = new Int8Array(count * 2);\\n\\n      for (var _idx = 0; _idx < array.length; _idx += 3) {\\n        var _encoded = this.EncodingFuncs.octEncodeBest(array[_idx], array[_idx + 1], array[_idx + 2], 1);\\n\\n        result[_idx / 3 * 2 + 0] = _encoded[0];\\n        result[_idx / 3 * 2 + 1] = _encoded[1];\\n      }\\n\\n      mesh.geometry.setAttribute('normal', new _three.BufferAttribute(result, 2, true));\\n      mesh.geometry.attributes.normal.bytes = result.length * 1;\\n    } else if (encodeMethod == 'OCT2Byte') {\\n      result = new Int16Array(count * 2);\\n\\n      for (var _idx2 = 0; _idx2 < array.length; _idx2 += 3) {\\n        var _encoded2 = this.EncodingFuncs.octEncodeBest(array[_idx2], array[_idx2 + 1], array[_idx2 + 2], 2);\\n\\n        result[_idx2 / 3 * 2 + 0] = _encoded2[0];\\n        result[_idx2 / 3 * 2 + 1] = _encoded2[1];\\n      }\\n\\n      mesh.geometry.setAttribute('normal', new _three.BufferAttribute(result, 2, true));\\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\\n    } else if (encodeMethod == 'ANGLES') {\\n      result = new Uint16Array(count * 2);\\n\\n      for (var _idx3 = 0; _idx3 < array.length; _idx3 += 3) {\\n        var _encoded3 = this.EncodingFuncs.anglesEncode(array[_idx3], array[_idx3 + 1], array[_idx3 + 2]);\\n\\n        result[_idx3 / 3 * 2 + 0] = _encoded3[0];\\n        result[_idx3 / 3 * 2 + 1] = _encoded3[1];\\n      }\\n\\n      mesh.geometry.setAttribute('normal', new _three.BufferAttribute(result, 2, true));\\n      mesh.geometry.attributes.normal.bytes = result.length * 2;\\n    } else {\\n      console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');\\n    }\\n\\n    mesh.geometry.attributes.normal.needsUpdate = true;\\n    mesh.geometry.attributes.normal.isPacked = true;\\n    mesh.geometry.attributes.normal.packingMethod = encodeMethod; // modify material\\n\\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\\n    }\\n\\n    if (encodeMethod == 'ANGLES') {\\n      mesh.material.defines.USE_PACKED_NORMAL = 0;\\n    }\\n\\n    if (encodeMethod == 'OCT1Byte') {\\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\\n    }\\n\\n    if (encodeMethod == 'OCT2Byte') {\\n      mesh.material.defines.USE_PACKED_NORMAL = 1;\\n    }\\n\\n    if (encodeMethod == 'DEFAULT') {\\n      mesh.material.defines.USE_PACKED_NORMAL = 2;\\n    }\\n  },\\n\\n  /**\\n   * Make the input mesh.geometry's position attribute encoded and compressed.\\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the position data.\\n   *\\n   * @param {THREE.Mesh} mesh\\n   *\\n   */\\n  compressPositions: function compressPositions(mesh) {\\n    if (!mesh.geometry) {\\n      console.error('Mesh must contain geometry. ');\\n    }\\n\\n    var position = mesh.geometry.attributes.position;\\n\\n    if (!position) {\\n      console.error('Geometry must contain position attribute. ');\\n    }\\n\\n    if (position.isPacked) return;\\n\\n    if (position.itemSize != 3) {\\n      console.error('position.itemSize is not 3, which cannot be packed. ');\\n    }\\n\\n    var array = position.array;\\n    var encodingBytes = 2;\\n    var result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);\\n    var quantized = result.quantized;\\n    var decodeMat = result.decodeMat; // IMPORTANT: calculate original geometry bounding info first, before updating packed positions\\n\\n    if (mesh.geometry.boundingBox == null) mesh.geometry.computeBoundingBox();\\n    if (mesh.geometry.boundingSphere == null) mesh.geometry.computeBoundingSphere();\\n    mesh.geometry.setAttribute('position', new _three.BufferAttribute(quantized, 3));\\n    mesh.geometry.attributes.position.isPacked = true;\\n    mesh.geometry.attributes.position.needsUpdate = true;\\n    mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes; // modify material\\n\\n    if (!(mesh.material instanceof PackedPhongMaterial)) {\\n      mesh.material = new PackedPhongMaterial().copy(mesh.material);\\n    }\\n\\n    mesh.material.defines.USE_PACKED_POSITION = 0;\\n    mesh.material.uniforms.quantizeMatPos.value = decodeMat;\\n    mesh.material.uniforms.quantizeMatPos.needsUpdate = true;\\n  },\\n\\n  /**\\n   * Make the input mesh.geometry's uv attribute encoded and compressed.\\n   * Also will change the mesh.material to `PackedPhongMaterial` which let the vertex shader program decode the uv data.\\n   *\\n   * @param {THREE.Mesh} mesh\\n   *\\n   */\\n  compressUvs: function compressUvs(mesh) {\\n    if (!mesh.geometry) {\\n      console.error('Mesh must contain geometry property. ');\\n    }\\n\\n    var uvs = mesh.geometry.attributes.uv;\\n\\n    if (!uvs) {\\n      console.error('Geometry must contain uv attribute. ');\\n    }\\n\\n    if (uvs.isPacked) return;\\n    var range = {\\n      min: Infinity,\\n      max: -Infinity\\n    };\\n    var array = uvs.array;\\n\\n    for (var i = 0; i < array.length; i++) {\\n      range.min = Math.min(range.min, array[i]);\\n      range.max = Math.max(range.max, array[i]);\\n    }\\n\\n    var result;\\n\\n    if (range.min >= -1.0 && range.max <= 1.0) {\\n      // use default encoding method\\n      result = new Uint16Array(array.length);\\n\\n      for (var _i = 0; _i < array.length; _i += 2) {\\n        var encoded = this.EncodingFuncs.defaultEncode(array[_i], array[_i + 1], 0, 2);\\n        result[_i] = encoded[0];\\n        result[_i + 1] = encoded[1];\\n      }\\n\\n      mesh.geometry.setAttribute('uv', new _three.BufferAttribute(result, 2, true));\\n      mesh.geometry.attributes.uv.isPacked = true;\\n      mesh.geometry.attributes.uv.needsUpdate = true;\\n      mesh.geometry.attributes.uv.bytes = result.length * 2;\\n\\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\\n      }\\n\\n      mesh.material.defines.USE_PACKED_UV = 0;\\n    } else {\\n      // use quantized encoding method\\n      result = this.EncodingFuncs.quantizedEncodeUV(array, 2);\\n      mesh.geometry.setAttribute('uv', new _three.BufferAttribute(result.quantized, 2));\\n      mesh.geometry.attributes.uv.isPacked = true;\\n      mesh.geometry.attributes.uv.needsUpdate = true;\\n      mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\\n\\n      if (!(mesh.material instanceof PackedPhongMaterial)) {\\n        mesh.material = new PackedPhongMaterial().copy(mesh.material);\\n      }\\n\\n      mesh.material.defines.USE_PACKED_UV = 1;\\n      mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\\n      mesh.material.uniforms.quantizeMatUV.needsUpdate = true;\\n    }\\n  },\\n  EncodingFuncs: {\\n    defaultEncode: function defaultEncode(x, y, z, bytes) {\\n      if (bytes == 1) {\\n        var tmpx = Math.round((x + 1) * 0.5 * 255);\\n        var tmpy = Math.round((y + 1) * 0.5 * 255);\\n        var tmpz = Math.round((z + 1) * 0.5 * 255);\\n        return new Uint8Array([tmpx, tmpy, tmpz]);\\n      } else if (bytes == 2) {\\n        var _tmpx = Math.round((x + 1) * 0.5 * 65535);\\n\\n        var _tmpy = Math.round((y + 1) * 0.5 * 65535);\\n\\n        var _tmpz = Math.round((z + 1) * 0.5 * 65535);\\n\\n        return new Uint16Array([_tmpx, _tmpy, _tmpz]);\\n      } else {\\n        console.error('number of bytes must be 1 or 2');\\n      }\\n    },\\n    defaultDecode: function defaultDecode(array, bytes) {\\n      if (bytes == 1) {\\n        return [array[0] / 255 * 2.0 - 1.0, array[1] / 255 * 2.0 - 1.0, array[2] / 255 * 2.0 - 1.0];\\n      } else if (bytes == 2) {\\n        return [array[0] / 65535 * 2.0 - 1.0, array[1] / 65535 * 2.0 - 1.0, array[2] / 65535 * 2.0 - 1.0];\\n      } else {\\n        console.error('number of bytes must be 1 or 2');\\n      }\\n    },\\n    // for `Angles` encoding\\n    anglesEncode: function anglesEncode(x, y, z) {\\n      var normal0 = parseInt(0.5 * (1.0 + Math.atan2(y, x) / Math.PI) * 65535);\\n      var normal1 = parseInt(0.5 * (1.0 + z) * 65535);\\n      return new Uint16Array([normal0, normal1]);\\n    },\\n    // for `Octahedron` encoding\\n    octEncodeBest: function octEncodeBest(x, y, z, bytes) {\\n      var oct, dec, best, currentCos, bestCos; // Test various combinations of ceil and floor\\n      // to minimize rounding errors\\n\\n      best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');\\n      dec = octDecodeVec2(oct);\\n      bestCos = dot(x, y, z, dec);\\n      oct = octEncodeVec3(x, y, z, 'ceil', 'floor');\\n      dec = octDecodeVec2(oct);\\n      currentCos = dot(x, y, z, dec);\\n\\n      if (currentCos > bestCos) {\\n        best = oct;\\n        bestCos = currentCos;\\n      }\\n\\n      oct = octEncodeVec3(x, y, z, 'floor', 'ceil');\\n      dec = octDecodeVec2(oct);\\n      currentCos = dot(x, y, z, dec);\\n\\n      if (currentCos > bestCos) {\\n        best = oct;\\n        bestCos = currentCos;\\n      }\\n\\n      oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');\\n      dec = octDecodeVec2(oct);\\n      currentCos = dot(x, y, z, dec);\\n\\n      if (currentCos > bestCos) {\\n        best = oct;\\n      }\\n\\n      return best;\\n\\n      function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {\\n        var x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\\n        var y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\\n\\n        if (z < 0) {\\n          var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\\n          var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\\n          x = tempx;\\n          y = tempy;\\n          var diff = 1 - Math.abs(x) - Math.abs(y);\\n\\n          if (diff > 0) {\\n            diff += 0.001;\\n            x += x > 0 ? diff / 2 : -diff / 2;\\n            y += y > 0 ? diff / 2 : -diff / 2;\\n          }\\n        }\\n\\n        if (bytes == 1) {\\n          return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))]);\\n        }\\n\\n        if (bytes == 2) {\\n          return new Int16Array([Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))]);\\n        }\\n      }\\n\\n      function octDecodeVec2(oct) {\\n        var x = oct[0];\\n        var y = oct[1];\\n\\n        if (bytes == 1) {\\n          x /= x < 0 ? 127 : 128;\\n          y /= y < 0 ? 127 : 128;\\n        } else if (bytes == 2) {\\n          x /= x < 0 ? 32767 : 32768;\\n          y /= y < 0 ? 32767 : 32768;\\n        }\\n\\n        var z = 1 - Math.abs(x) - Math.abs(y);\\n\\n        if (z < 0) {\\n          var tmpx = x;\\n          x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\\n          y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);\\n        }\\n\\n        var length = Math.sqrt(x * x + y * y + z * z);\\n        return [x / length, y / length, z / length];\\n      }\\n\\n      function dot(x, y, z, vec3) {\\n        return x * vec3[0] + y * vec3[1] + z * vec3[2];\\n      }\\n    },\\n    quantizedEncode: function quantizedEncode(array, bytes) {\\n      var quantized, segments;\\n\\n      if (bytes == 1) {\\n        quantized = new Uint8Array(array.length);\\n        segments = 255;\\n      } else if (bytes == 2) {\\n        quantized = new Uint16Array(array.length);\\n        segments = 65535;\\n      } else {\\n        console.error('number of bytes error! ');\\n      }\\n\\n      var decodeMat = new _three.Matrix4();\\n      var min = new Float32Array(3);\\n      var max = new Float32Array(3);\\n      min[0] = min[1] = min[2] = Number.MAX_VALUE;\\n      max[0] = max[1] = max[2] = -Number.MAX_VALUE;\\n\\n      for (var i = 0; i < array.length; i += 3) {\\n        min[0] = Math.min(min[0], array[i + 0]);\\n        min[1] = Math.min(min[1], array[i + 1]);\\n        min[2] = Math.min(min[2], array[i + 2]);\\n        max[0] = Math.max(max[0], array[i + 0]);\\n        max[1] = Math.max(max[1], array[i + 1]);\\n        max[2] = Math.max(max[2], array[i + 2]);\\n      }\\n\\n      decodeMat.scale(new _three.Vector3((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));\\n      decodeMat.elements[12] = min[0];\\n      decodeMat.elements[13] = min[1];\\n      decodeMat.elements[14] = min[2];\\n      decodeMat.transpose();\\n      var multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0, max[2] !== min[2] ? segments / (max[2] - min[2]) : 0]);\\n\\n      for (var _i2 = 0; _i2 < array.length; _i2 += 3) {\\n        quantized[_i2 + 0] = Math.floor((array[_i2 + 0] - min[0]) * multiplier[0]);\\n        quantized[_i2 + 1] = Math.floor((array[_i2 + 1] - min[1]) * multiplier[1]);\\n        quantized[_i2 + 2] = Math.floor((array[_i2 + 2] - min[2]) * multiplier[2]);\\n      }\\n\\n      return {\\n        quantized: quantized,\\n        decodeMat: decodeMat\\n      };\\n    },\\n    quantizedEncodeUV: function quantizedEncodeUV(array, bytes) {\\n      var quantized, segments;\\n\\n      if (bytes == 1) {\\n        quantized = new Uint8Array(array.length);\\n        segments = 255;\\n      } else if (bytes == 2) {\\n        quantized = new Uint16Array(array.length);\\n        segments = 65535;\\n      } else {\\n        console.error('number of bytes error! ');\\n      }\\n\\n      var decodeMat = new _three.Matrix3();\\n      var min = new Float32Array(2);\\n      var max = new Float32Array(2);\\n      min[0] = min[1] = Number.MAX_VALUE;\\n      max[0] = max[1] = -Number.MAX_VALUE;\\n\\n      for (var i = 0; i < array.length; i += 2) {\\n        min[0] = Math.min(min[0], array[i + 0]);\\n        min[1] = Math.min(min[1], array[i + 1]);\\n        max[0] = Math.max(max[0], array[i + 0]);\\n        max[1] = Math.max(max[1], array[i + 1]);\\n      }\\n\\n      decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);\\n      decodeMat.elements[6] = min[0];\\n      decodeMat.elements[7] = min[1];\\n      decodeMat.transpose();\\n      var multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0]);\\n\\n      for (var _i3 = 0; _i3 < array.length; _i3 += 2) {\\n        quantized[_i3 + 0] = Math.floor((array[_i3 + 0] - min[0]) * multiplier[0]);\\n        quantized[_i3 + 1] = Math.floor((array[_i3 + 1] - min[1]) * multiplier[1]);\\n      }\\n\\n      return {\\n        quantized: quantized,\\n        decodeMat: decodeMat\\n      };\\n    }\\n  }\\n};\\n/**\\n * `PackedPhongMaterial` inherited from THREE.MeshPhongMaterial\\n *\\n * @param {Object} parameters\\n */\\n\\nexports.GeometryCompressionUtils = GeometryCompressionUtils;\\n\\nvar PackedPhongMaterial =\\n/*#__PURE__*/\\nfunction (_MeshPhongMaterial) {\\n  _inherits(PackedPhongMaterial, _MeshPhongMaterial);\\n\\n  function PackedPhongMaterial(parameters) {\\n    var _this;\\n\\n    _classCallCheck(this, PackedPhongMaterial);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PackedPhongMaterial).call(this));\\n    _this.defines = {};\\n    _this.type = 'PackedPhongMaterial';\\n    _this.uniforms = _three.UniformsUtils.merge([_three.ShaderLib.phong.uniforms, {\\n      quantizeMatPos: {\\n        value: null\\n      },\\n      quantizeMatUV: {\\n        value: null\\n      }\\n    }]);\\n    _this.vertexShader = ['#define PHONG', 'varying vec3 vViewPosition;', '#ifndef FLAT_SHADED', 'varying vec3 vNormal;', '#endif', _three.ShaderChunk.common, _three.ShaderChunk.uv_pars_vertex, _three.ShaderChunk.uv2_pars_vertex, _three.ShaderChunk.displacementmap_pars_vertex, _three.ShaderChunk.envmap_pars_vertex, _three.ShaderChunk.color_pars_vertex, _three.ShaderChunk.fog_pars_vertex, _three.ShaderChunk.morphtarget_pars_vertex, _three.ShaderChunk.skinning_pars_vertex, _three.ShaderChunk.shadowmap_pars_vertex, _three.ShaderChunk.logdepthbuf_pars_vertex, _three.ShaderChunk.clipping_planes_pars_vertex, \\\"#ifdef USE_PACKED_NORMAL\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#if USE_PACKED_NORMAL == 0\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec3 decodeNormal(vec3 packedNormal)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t{\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfloat x = packedNormal.x * 2.0 - 1.0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfloat y = packedNormal.y * 2.0 - 1.0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#if USE_PACKED_NORMAL == 1\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec3 decodeNormal(vec3 packedNormal)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t{\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (v.z < 0.0)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t{\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn normalize(v);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#if USE_PACKED_NORMAL == 2\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec3 decodeNormal(vec3 packedNormal)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t{\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec3 v = (packedNormal * 2.0) - 1.0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn normalize(v);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\", \\\"#ifdef USE_PACKED_POSITION\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#if USE_PACKED_POSITION == 0\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuniform mat4 quantizeMatPos;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\", \\\"#ifdef USE_PACKED_UV\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#if USE_PACKED_UV == 1\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuniform mat3 quantizeMatUV;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\", \\\"#ifdef USE_PACKED_UV\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#if USE_PACKED_UV == 0\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec2 decodeUV(vec2 packedUV)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t{\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec2 uv = (packedUV * 2.0) - 1.0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn uv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#if USE_PACKED_UV == 1\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec2 decodeUV(vec2 packedUV)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t{\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn uv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\", 'void main() {', _three.ShaderChunk.uv_vertex, \\\"#ifdef USE_UV\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#ifdef USE_PACKED_UV\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvUv = decodeUV(vUv);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\", _three.ShaderChunk.uv2_vertex, _three.ShaderChunk.color_vertex, _three.ShaderChunk.beginnormal_vertex, \\\"#ifdef USE_PACKED_NORMAL\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tobjectNormal = decodeNormal(objectNormal);\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t#ifdef USE_TANGENT\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 objectTangent = vec3( tangent.xyz );\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\t\\\\t\\\", _three.ShaderChunk.morphnormal_vertex, _three.ShaderChunk.skinbase_vertex, _three.ShaderChunk.skinnormal_vertex, _three.ShaderChunk.defaultnormal_vertex, '#ifndef FLAT_SHADED', '\\tvNormal = normalize( transformedNormal );', '#endif', _three.ShaderChunk.begin_vertex, \\\"#ifdef USE_PACKED_POSITION\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#if USE_PACKED_POSITION == 0\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\t\\\\t#endif\\\", _three.ShaderChunk.morphtarget_vertex, _three.ShaderChunk.skinning_vertex, _three.ShaderChunk.displacementmap_vertex, _three.ShaderChunk.project_vertex, _three.ShaderChunk.logdepthbuf_vertex, _three.ShaderChunk.clipping_planes_vertex, 'vViewPosition = - mvPosition.xyz;', _three.ShaderChunk.worldpos_vertex, _three.ShaderChunk.envmap_vertex, _three.ShaderChunk.shadowmap_vertex, _three.ShaderChunk.fog_vertex, '}'].join('\\\\n'); // Use the original MeshPhongMaterial's fragmentShader.\\n\\n    _this.fragmentShader = ['#define PHONG', 'uniform vec3 diffuse;', 'uniform vec3 emissive;', 'uniform vec3 specular;', 'uniform float shininess;', 'uniform float opacity;', _three.ShaderChunk.common, _three.ShaderChunk.packing, _three.ShaderChunk.dithering_pars_fragment, _three.ShaderChunk.color_pars_fragment, _three.ShaderChunk.uv_pars_fragment, _three.ShaderChunk.uv2_pars_fragment, _three.ShaderChunk.map_pars_fragment, _three.ShaderChunk.alphamap_pars_fragment, _three.ShaderChunk.aomap_pars_fragment, _three.ShaderChunk.lightmap_pars_fragment, _three.ShaderChunk.emissivemap_pars_fragment, _three.ShaderChunk.envmap_common_pars_fragment, _three.ShaderChunk.envmap_pars_fragment, _three.ShaderChunk.cube_uv_reflection_fragment, _three.ShaderChunk.fog_pars_fragment, _three.ShaderChunk.bsdfs, _three.ShaderChunk.lights_pars_begin, _three.ShaderChunk.lights_phong_pars_fragment, _three.ShaderChunk.shadowmap_pars_fragment, _three.ShaderChunk.bumpmap_pars_fragment, _three.ShaderChunk.normalmap_pars_fragment, _three.ShaderChunk.specularmap_pars_fragment, _three.ShaderChunk.logdepthbuf_pars_fragment, _three.ShaderChunk.clipping_planes_pars_fragment, 'void main() {', _three.ShaderChunk.clipping_planes_fragment, 'vec4 diffuseColor = vec4( diffuse, opacity );', 'ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', 'vec3 totalEmissiveRadiance = emissive;', _three.ShaderChunk.logdepthbuf_fragment, _three.ShaderChunk.map_fragment, _three.ShaderChunk.color_fragment, _three.ShaderChunk.alphamap_fragment, _three.ShaderChunk.alphatest_fragment, _three.ShaderChunk.specularmap_fragment, _three.ShaderChunk.normal_fragment_begin, _three.ShaderChunk.normal_fragment_maps, _three.ShaderChunk.emissivemap_fragment, // accumulation\\n    _three.ShaderChunk.lights_phong_fragment, _three.ShaderChunk.lights_fragment_begin, _three.ShaderChunk.lights_fragment_maps, _three.ShaderChunk.lights_fragment_end, // modulation\\n    _three.ShaderChunk.aomap_fragment, 'vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;', _three.ShaderChunk.envmap_fragment, 'gl_FragColor = vec4( outgoingLight, diffuseColor.a );', _three.ShaderChunk.tonemapping_fragment, _three.ShaderChunk.encodings_fragment, _three.ShaderChunk.fog_fragment, _three.ShaderChunk.premultiplied_alpha_fragment, _three.ShaderChunk.dithering_fragment, '}'].join('\\\\n');\\n\\n    _this.setValues(parameters);\\n\\n    return _this;\\n  }\\n\\n  return PackedPhongMaterial;\\n}(_three.MeshPhongMaterial);\\n\\nexports.PackedPhongMaterial = PackedPhongMaterial;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"defineProperty\",\"PackedPhongMaterial\",\"GeometryCompressionUtils\",\"_three\",\"compressNormals\",\"mesh\",\"encodeMethod\",\"geometry\",\"console\",\"error\",\"normal\",\"attributes\",\"isPacked\",\"itemSize\",\"array\",\"count\",\"result\",\"Uint8Array\",\"idx\",\"length\",\"encoded\",\"EncodingFuncs\",\"defaultEncode\",\"setAttribute\",\"BufferAttribute\",\"bytes\",\"Int8Array\",\"_idx\",\"_encoded\",\"octEncodeBest\",\"Int16Array\",\"_idx2\",\"_encoded2\",\"Uint16Array\",\"_idx3\",\"_encoded3\",\"anglesEncode\",\"needsUpdate\",\"packingMethod\",\"material\",\"copy\",\"defines\",\"USE_PACKED_NORMAL\",\"compressPositions\",\"position\",\"quantizedEncode\",\"encodingBytes\",\"quantized\",\"decodeMat\",\"boundingBox\",\"computeBoundingBox\",\"boundingSphere\",\"computeBoundingSphere\",\"USE_PACKED_POSITION\",\"uniforms\",\"quantizeMatPos\",\"compressUvs\",\"uvs\",\"uv\",\"Infinity\",\"i\",\"min\",\"Math\",\"max\",\"_i\",\"USE_PACKED_UV\",\"quantizedEncodeUV\",\"quantizeMatUV\",\"x\",\"y\",\"z\",\"round\",\"tmpx\",\"tmpy\",\"tmpz\",\"_tmpx\",\"_tmpy\",\"_tmpz\",\"defaultDecode\",\"normal0\",\"parseInt\",\"atan2\",\"PI\",\"normal1\",\"octEncodeVec3\",\"x0\",\"y0\",\"z0\",\"xfunc\",\"yfunc\",\"abs\",\"tempy\",\"diff\",\"octDecodeVec2\",\"oct\",\"sqrt\",\"best\",\"dec\",\"bestCos\",\"currentCos\",\"segments\",\"Matrix4\",\"Float32Array\",\"Number\",\"MAX_VALUE\",\"scale\",\"Vector3\",\"elements\",\"transpose\",\"multiplier\",\"_i2\",\"floor\",\"Matrix3\",\"_i3\",\"_MeshPhongMaterial\",\"parameters\",\"instance\",\"call\",\"self\",\"ReferenceError\",\"_this\",\"type\",\"UniformsUtils\",\"merge\",\"ShaderLib\",\"phong\",\"vertexShader\",\"ShaderChunk\",\"common\",\"uv_pars_vertex\",\"uv2_pars_vertex\",\"displacementmap_pars_vertex\",\"envmap_pars_vertex\",\"color_pars_vertex\",\"fog_pars_vertex\",\"morphtarget_pars_vertex\",\"skinning_pars_vertex\",\"shadowmap_pars_vertex\",\"logdepthbuf_pars_vertex\",\"clipping_planes_pars_vertex\",\"uv_vertex\",\"uv2_vertex\",\"color_vertex\",\"beginnormal_vertex\",\"morphnormal_vertex\",\"skinbase_vertex\",\"skinnormal_vertex\",\"defaultnormal_vertex\",\"begin_vertex\",\"morphtarget_vertex\",\"skinning_vertex\",\"displacementmap_vertex\",\"project_vertex\",\"logdepthbuf_vertex\",\"clipping_planes_vertex\",\"worldpos_vertex\",\"envmap_vertex\",\"shadowmap_vertex\",\"fog_vertex\",\"join\",\"fragmentShader\",\"packing\",\"dithering_pars_fragment\",\"color_pars_fragment\",\"uv_pars_fragment\",\"uv2_pars_fragment\",\"map_pars_fragment\",\"alphamap_pars_fragment\",\"aomap_pars_fragment\",\"lightmap_pars_fragment\",\"emissivemap_pars_fragment\",\"envmap_common_pars_fragment\",\"envmap_pars_fragment\",\"cube_uv_reflection_fragment\",\"fog_pars_fragment\",\"bsdfs\",\"lights_pars_begin\",\"lights_phong_pars_fragment\",\"shadowmap_pars_fragment\",\"bumpmap_pars_fragment\",\"normalmap_pars_fragment\",\"specularmap_pars_fragment\",\"logdepthbuf_pars_fragment\",\"clipping_planes_pars_fragment\",\"clipping_planes_fragment\",\"logdepthbuf_fragment\",\"map_fragment\",\"color_fragment\",\"alphamap_fragment\",\"alphatest_fragment\",\"specularmap_fragment\",\"normal_fragment_begin\",\"normal_fragment_maps\",\"emissivemap_fragment\",\"lights_phong_fragment\",\"lights_fragment_begin\",\"lights_fragment_maps\",\"lights_fragment_end\",\"aomap_fragment\",\"envmap_fragment\",\"tonemapping_fragment\",\"encodings_fragment\",\"fog_fragment\",\"premultiplied_alpha_fragment\",\"dithering_fragment\",\"setValues\",\"MeshPhongMaterial\"]\n}\n"]