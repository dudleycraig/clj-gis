["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-mesh-bvh/src/Utils/ArrayBoxUtilities.js"],"~:js","shadow$provide.module$node_modules$three_mesh_bvh$src$Utils$ArrayBoxUtilities=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.boxToArray=function(bx){var arr=new Float32Array(6);arr[0]=bx.min.x;arr[1]=bx.min.y;arr[2]=bx.min.z;arr[3]=bx.max.x;arr[4]=bx.max.y;arr[5]=bx.max.z;return arr};exports.arrayToBox=function(arr,target){target.min.x=arr[0];target.min.y=arr[1];target.min.z=arr[2];target.max.x=arr[3];target.max.y=arr[4];target.max.z=arr[5];\nreturn target};exports.getLongestEdgeIndex=function(bounds){for(var splitDimIdx=-1,splitDist=-Infinity,i=0;3>i;i++){var dist=bounds[i+3]-bounds[i];dist>splitDist&&(splitDist=dist,splitDimIdx=i)}return splitDimIdx};exports.copyBounds=function(source,target){target.set(source)};exports.unionBounds=function(a,b,target){for(var aVal,bVal,d=0;3>d;d++){var d3=d+3;aVal=a[d];bVal=b[d];target[d]=aVal<bVal?aVal:bVal;aVal=a[d3];bVal=b[d3];target[d3]=aVal>bVal?aVal:bVal}};exports.computeSurfaceArea=function(bounds){var d0=\nbounds[3]-bounds[0],d1=bounds[4]-bounds[1];bounds=bounds[5]-bounds[2];return 2*(d0*d1+d1*bounds+bounds*d0)}}","~:source","shadow$provide[\"module$node_modules$three_mesh_bvh$src$Utils$ArrayBoxUtilities\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boxToArray = boxToArray;\nexports.arrayToBox = arrayToBox;\nexports.getLongestEdgeIndex = getLongestEdgeIndex;\nexports.copyBounds = copyBounds;\nexports.unionBounds = unionBounds;\nexports.computeSurfaceArea = computeSurfaceArea;\n\n// Returns a Float32Array representing the bounds data for box.\nfunction boxToArray(bx) {\n  var arr = new Float32Array(6);\n  arr[0] = bx.min.x;\n  arr[1] = bx.min.y;\n  arr[2] = bx.min.z;\n  arr[3] = bx.max.x;\n  arr[4] = bx.max.y;\n  arr[5] = bx.max.z;\n  return arr;\n}\n\nfunction arrayToBox(arr, target) {\n  target.min.x = arr[0];\n  target.min.y = arr[1];\n  target.min.z = arr[2];\n  target.max.x = arr[3];\n  target.max.y = arr[4];\n  target.max.z = arr[5];\n  return target;\n}\n\nfunction getLongestEdgeIndex(bounds) {\n  var splitDimIdx = -1;\n  var splitDist = -Infinity;\n\n  for (var i = 0; i < 3; i++) {\n    var dist = bounds[i + 3] - bounds[i];\n\n    if (dist > splitDist) {\n      splitDist = dist;\n      splitDimIdx = i;\n    }\n  }\n\n  return splitDimIdx;\n} // copys bounds a into bounds b\n\n\nfunction copyBounds(source, target) {\n  target.set(source);\n} // sets bounds target to the union of bounds a and b\n\n\nfunction unionBounds(a, b, target) {\n  var aVal, bVal;\n\n  for (var d = 0; d < 3; d++) {\n    var d3 = d + 3; // set the minimum values\n\n    aVal = a[d];\n    bVal = b[d];\n    target[d] = aVal < bVal ? aVal : bVal; // set the max values\n\n    aVal = a[d3];\n    bVal = b[d3];\n    target[d3] = aVal > bVal ? aVal : bVal;\n  }\n} // compute bounds surface area\n\n\nfunction computeSurfaceArea(bounds) {\n  var d0 = bounds[3] - bounds[0];\n  var d1 = bounds[4] - bounds[1];\n  var d2 = bounds[5] - bounds[2];\n  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["z","arrayToBox","copyBounds","getLongestEdgeIndex","x","__esModule","value","y","unionBounds","boxToArray","computeSurfaceArea"]],"~:compiled-at",1630917516167,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_mesh_bvh$src$Utils$ArrayBoxUtilities.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-mesh-bvh/src/Utils/ArrayBoxUtilities.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_mesh_bvh$src$Utils$ArrayBoxUtilities\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.boxToArray = boxToArray;\\nexports.arrayToBox = arrayToBox;\\nexports.getLongestEdgeIndex = getLongestEdgeIndex;\\nexports.copyBounds = copyBounds;\\nexports.unionBounds = unionBounds;\\nexports.computeSurfaceArea = computeSurfaceArea;\\n\\n// Returns a Float32Array representing the bounds data for box.\\nfunction boxToArray(bx) {\\n  var arr = new Float32Array(6);\\n  arr[0] = bx.min.x;\\n  arr[1] = bx.min.y;\\n  arr[2] = bx.min.z;\\n  arr[3] = bx.max.x;\\n  arr[4] = bx.max.y;\\n  arr[5] = bx.max.z;\\n  return arr;\\n}\\n\\nfunction arrayToBox(arr, target) {\\n  target.min.x = arr[0];\\n  target.min.y = arr[1];\\n  target.min.z = arr[2];\\n  target.max.x = arr[3];\\n  target.max.y = arr[4];\\n  target.max.z = arr[5];\\n  return target;\\n}\\n\\nfunction getLongestEdgeIndex(bounds) {\\n  var splitDimIdx = -1;\\n  var splitDist = -Infinity;\\n\\n  for (var i = 0; i < 3; i++) {\\n    var dist = bounds[i + 3] - bounds[i];\\n\\n    if (dist > splitDist) {\\n      splitDist = dist;\\n      splitDimIdx = i;\\n    }\\n  }\\n\\n  return splitDimIdx;\\n} // copys bounds a into bounds b\\n\\n\\nfunction copyBounds(source, target) {\\n  target.set(source);\\n} // sets bounds target to the union of bounds a and b\\n\\n\\nfunction unionBounds(a, b, target) {\\n  var aVal, bVal;\\n\\n  for (var d = 0; d < 3; d++) {\\n    var d3 = d + 3; // set the minimum values\\n\\n    aVal = a[d];\\n    bVal = b[d];\\n    target[d] = aVal < bVal ? aVal : bVal; // set the max values\\n\\n    aVal = a[d3];\\n    bVal = b[d3];\\n    target[d3] = aVal > bVal ? aVal : bVal;\\n  }\\n} // compute bounds surface area\\n\\n\\nfunction computeSurfaceArea(bounds) {\\n  var d0 = bounds[3] - bounds[0];\\n  var d1 = bounds[4] - bounds[1];\\n  var d2 = bounds[5] - bounds[2];\\n  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"boxToArray\",\"bx\",\"arr\",\"Float32Array\",\"min\",\"x\",\"y\",\"z\",\"max\",\"arrayToBox\",\"target\",\"getLongestEdgeIndex\",\"bounds\",\"splitDimIdx\",\"splitDist\",\"Infinity\",\"i\",\"dist\",\"copyBounds\",\"source\",\"set\",\"unionBounds\",\"a\",\"b\",\"aVal\",\"bVal\",\"d\",\"d3\",\"computeSurfaceArea\",\"d0\",\"d1\",\"d2\"]\n}\n"]