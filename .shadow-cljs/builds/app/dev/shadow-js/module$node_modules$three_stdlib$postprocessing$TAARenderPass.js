["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/postprocessing/TAARenderPass.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$postprocessing$TAARenderPass=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.TAARenderPass=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_SSAARenderPass=require(\"module$node_modules$three_stdlib$postprocessing$SSAARenderPass\"),TAARenderPass=function(scene,camera,clearColor,clearAlpha){void 0===_SSAARenderPass.SSAARenderPass&&console.error(\"THREE.TAARenderPass relies on SSAARenderPass\");\n_SSAARenderPass.SSAARenderPass.call(this,scene,camera,clearColor,clearAlpha);this.sampleLevel=0;this.accumulate=!1};exports.TAARenderPass=TAARenderPass;TAARenderPass.JitterVectors=_SSAARenderPass.SSAARenderPass.JitterVectors;TAARenderPass.prototype=Object.assign(Object.create(_SSAARenderPass.SSAARenderPass.prototype),{constructor:TAARenderPass,render:function(renderer,writeBuffer,readBuffer,deltaTime){if(this.accumulate){var jitterOffsets=TAARenderPass.JitterVectors[5];this.sampleRenderTarget||(this.sampleRenderTarget=\nnew _three.WebGLRenderTarget(readBuffer.width,readBuffer.height,this.params),this.sampleRenderTarget.texture.name=\"TAARenderPass.sample\");this.holdRenderTarget||(this.holdRenderTarget=new _three.WebGLRenderTarget(readBuffer.width,readBuffer.height,this.params),this.holdRenderTarget.texture.name=\"TAARenderPass.hold\");this.accumulate&&-1===this.accumulateIndex&&(_SSAARenderPass.SSAARenderPass.prototype.render.call(this,renderer,this.holdRenderTarget,readBuffer,deltaTime),this.accumulateIndex=0);deltaTime=\nrenderer.autoClear;renderer.autoClear=!1;var sampleWeight=1/jitterOffsets.length;if(0<=this.accumulateIndex&&this.accumulateIndex<jitterOffsets.length){this.copyUniforms.opacity.value=sampleWeight;this.copyUniforms.tDiffuse.value=writeBuffer.texture;for(var numSamplesPerFrame=Math.pow(2,this.sampleLevel),i=0;i<numSamplesPerFrame;i++){var jitterOffset=jitterOffsets[this.accumulateIndex];this.camera.setViewOffset&&this.camera.setViewOffset(readBuffer.width,readBuffer.height,.0625*jitterOffset[0],.0625*\njitterOffset[1],readBuffer.width,readBuffer.height);renderer.setRenderTarget(writeBuffer);renderer.clear();renderer.render(this.scene,this.camera);renderer.setRenderTarget(this.sampleRenderTarget);0===this.accumulateIndex&&renderer.clear();this.fsQuad.render(renderer);this.accumulateIndex++;if(this.accumulateIndex>=jitterOffsets.length)break}this.camera.clearViewOffset&&this.camera.clearViewOffset()}readBuffer=this.accumulateIndex*sampleWeight;0<readBuffer&&(this.copyUniforms.opacity.value=1,this.copyUniforms.tDiffuse.value=\nthis.sampleRenderTarget.texture,renderer.setRenderTarget(writeBuffer),renderer.clear(),this.fsQuad.render(renderer));1>readBuffer&&(this.copyUniforms.opacity.value=1-readBuffer,this.copyUniforms.tDiffuse.value=this.holdRenderTarget.texture,renderer.setRenderTarget(writeBuffer),0===readBuffer&&renderer.clear(),this.fsQuad.render(renderer));renderer.autoClear=deltaTime}else _SSAARenderPass.SSAARenderPass.prototype.render.call(this,renderer,writeBuffer,readBuffer,deltaTime),this.accumulateIndex=-1}})}","~:source","shadow$provide[\"module$node_modules$three_stdlib$postprocessing$TAARenderPass\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TAARenderPass = void 0;\n\nvar _three = require(\"three\");\n\nvar _SSAARenderPass = require(\"./SSAARenderPass.js\");\n\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\nvar TAARenderPass = function TAARenderPass(scene, camera, clearColor, clearAlpha) {\n  if (_SSAARenderPass.SSAARenderPass === undefined) {\n    console.error('THREE.TAARenderPass relies on SSAARenderPass');\n  }\n\n  _SSAARenderPass.SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\n\n  this.sampleLevel = 0;\n  this.accumulate = false;\n};\n\nexports.TAARenderPass = TAARenderPass;\nTAARenderPass.JitterVectors = _SSAARenderPass.SSAARenderPass.JitterVectors;\nTAARenderPass.prototype = Object.assign(Object.create(_SSAARenderPass.SSAARenderPass.prototype), {\n  constructor: TAARenderPass,\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime) {\n    if (!this.accumulate) {\n      _SSAARenderPass.SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\n\n      this.accumulateIndex = -1;\n      return;\n    }\n\n    var jitterOffsets = TAARenderPass.JitterVectors[5];\n\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new _three.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\n    }\n\n    if (!this.holdRenderTarget) {\n      this.holdRenderTarget = new _three.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\n    }\n\n    if (this.accumulate && this.accumulateIndex === -1) {\n      _SSAARenderPass.SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\n\n      this.accumulateIndex = 0;\n    }\n\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    var sampleWeight = 1.0 / jitterOffsets.length;\n\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n      this.copyUniforms['opacity'].value = sampleWeight;\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n\n      for (var i = 0; i < numSamplesPerFrame; i++) {\n        var j = this.accumulateIndex;\n        var jitterOffset = jitterOffsets[j];\n\n        if (this.camera.setViewOffset) {\n          this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n          readBuffer.width, readBuffer.height);\n        }\n\n        renderer.setRenderTarget(writeBuffer);\n        renderer.clear();\n        renderer.render(this.scene, this.camera);\n        renderer.setRenderTarget(this.sampleRenderTarget);\n        if (this.accumulateIndex === 0) renderer.clear();\n        this.fsQuad.render(renderer);\n        this.accumulateIndex++;\n        if (this.accumulateIndex >= jitterOffsets.length) break;\n      }\n\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    }\n\n    var accumulationWeight = this.accumulateIndex * sampleWeight;\n\n    if (accumulationWeight > 0) {\n      this.copyUniforms['opacity'].value = 1.0;\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    if (accumulationWeight < 1.0) {\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight;\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      if (accumulationWeight === 0) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n});\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_stdlib$postprocessing$SSAARenderPass","~$shadow.js"]],"~:properties",["^5",["JitterVectors","prototype","__esModule","name","value","autoClear","render","accumulate","holdRenderTarget","accumulateIndex","sampleLevel","TAARenderPass","constructor","sampleRenderTarget"]],"~:compiled-at",1630917515538,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$postprocessing$TAARenderPass.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/postprocessing/TAARenderPass.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$postprocessing$TAARenderPass\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.TAARenderPass = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _SSAARenderPass = require(\\\"./SSAARenderPass.js\\\");\\n\\n/**\\n *\\n * Temporal Anti-Aliasing Render Pass\\n *\\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\\n *\\n * References:\\n *\\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\\n *\\n */\\nvar TAARenderPass = function TAARenderPass(scene, camera, clearColor, clearAlpha) {\\n  if (_SSAARenderPass.SSAARenderPass === undefined) {\\n    console.error('THREE.TAARenderPass relies on SSAARenderPass');\\n  }\\n\\n  _SSAARenderPass.SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\\n\\n  this.sampleLevel = 0;\\n  this.accumulate = false;\\n};\\n\\nexports.TAARenderPass = TAARenderPass;\\nTAARenderPass.JitterVectors = _SSAARenderPass.SSAARenderPass.JitterVectors;\\nTAARenderPass.prototype = Object.assign(Object.create(_SSAARenderPass.SSAARenderPass.prototype), {\\n  constructor: TAARenderPass,\\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime) {\\n    if (!this.accumulate) {\\n      _SSAARenderPass.SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\\n\\n      this.accumulateIndex = -1;\\n      return;\\n    }\\n\\n    var jitterOffsets = TAARenderPass.JitterVectors[5];\\n\\n    if (!this.sampleRenderTarget) {\\n      this.sampleRenderTarget = new _three.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\\n    }\\n\\n    if (!this.holdRenderTarget) {\\n      this.holdRenderTarget = new _three.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\\n    }\\n\\n    if (this.accumulate && this.accumulateIndex === -1) {\\n      _SSAARenderPass.SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\\n\\n      this.accumulateIndex = 0;\\n    }\\n\\n    var autoClear = renderer.autoClear;\\n    renderer.autoClear = false;\\n    var sampleWeight = 1.0 / jitterOffsets.length;\\n\\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\\n      this.copyUniforms['opacity'].value = sampleWeight;\\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\\n\\n      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\\n\\n      for (var i = 0; i < numSamplesPerFrame; i++) {\\n        var j = this.accumulateIndex;\\n        var jitterOffset = jitterOffsets[j];\\n\\n        if (this.camera.setViewOffset) {\\n          this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\\n          readBuffer.width, readBuffer.height);\\n        }\\n\\n        renderer.setRenderTarget(writeBuffer);\\n        renderer.clear();\\n        renderer.render(this.scene, this.camera);\\n        renderer.setRenderTarget(this.sampleRenderTarget);\\n        if (this.accumulateIndex === 0) renderer.clear();\\n        this.fsQuad.render(renderer);\\n        this.accumulateIndex++;\\n        if (this.accumulateIndex >= jitterOffsets.length) break;\\n      }\\n\\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset();\\n    }\\n\\n    var accumulationWeight = this.accumulateIndex * sampleWeight;\\n\\n    if (accumulationWeight > 0) {\\n      this.copyUniforms['opacity'].value = 1.0;\\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\\n      renderer.setRenderTarget(writeBuffer);\\n      renderer.clear();\\n      this.fsQuad.render(renderer);\\n    }\\n\\n    if (accumulationWeight < 1.0) {\\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight;\\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\\n      renderer.setRenderTarget(writeBuffer);\\n      if (accumulationWeight === 0) renderer.clear();\\n      this.fsQuad.render(renderer);\\n    }\\n\\n    renderer.autoClear = autoClear;\\n  }\\n});\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"TAARenderPass\",\"_three\",\"_SSAARenderPass\",\"scene\",\"camera\",\"clearColor\",\"clearAlpha\",\"undefined\",\"SSAARenderPass\",\"console\",\"error\",\"call\",\"sampleLevel\",\"accumulate\",\"JitterVectors\",\"prototype\",\"assign\",\"create\",\"constructor\",\"render\",\"renderer\",\"writeBuffer\",\"readBuffer\",\"deltaTime\",\"jitterOffsets\",\"sampleRenderTarget\",\"WebGLRenderTarget\",\"width\",\"height\",\"params\",\"texture\",\"name\",\"holdRenderTarget\",\"accumulateIndex\",\"autoClear\",\"sampleWeight\",\"length\",\"copyUniforms\",\"numSamplesPerFrame\",\"Math\",\"pow\",\"i\",\"jitterOffset\",\"setViewOffset\",\"setRenderTarget\",\"clear\",\"fsQuad\",\"clearViewOffset\",\"accumulationWeight\"]\n}\n"]