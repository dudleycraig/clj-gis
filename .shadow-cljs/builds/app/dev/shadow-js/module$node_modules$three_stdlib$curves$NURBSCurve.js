["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/curves/NURBSCurve.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$curves$NURBSCurve=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=\ndescriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};\nreturn _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};\nreturn _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.NURBSCurve=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_NURBSUtils=require(\"module$node_modules$three_stdlib$curves$NURBSUtils\");global=function(_Curve){function NURBSCurve(degree,knots,controlPoints,startKnot,endKnot){if(!(this instanceof NURBSCurve))throw new TypeError(\"Cannot call a class as a function\");var _this=_getPrototypeOf(NURBSCurve).call(this);if(!_this||\n\"object\"!==_typeof(_this)&&\"function\"!==typeof _this){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");_this=this}_this.degree=degree;_this.knots=knots;_this.controlPoints=[];_this.startKnot=startKnot||0;_this.endKnot=endKnot||_this.knots.length-1;for(degree=0;degree<controlPoints.length;++degree)knots=controlPoints[degree],_this.controlPoints[degree]=new _three.Vector4(knots.x,knots.y,knots.z,knots.w);return _this}_inherits(NURBSCurve,_Curve);\n_createClass(NURBSCurve,[{key:\"getPoint\",value:function(t,optionalTarget){optionalTarget=optionalTarget||new _three.Vector3;t=this.knots[this.startKnot]+t*(this.knots[this.endKnot]-this.knots[this.startKnot]);t=(0,_NURBSUtils.calcBSplinePoint)(this.degree,this.knots,this.controlPoints,t);1!=t.w&&t.divideScalar(t.w);return optionalTarget.set(t.x,t.y,t.z)}},{key:\"getTangent\",value:function(t,optionalTarget){optionalTarget=optionalTarget||new _three.Vector3;t=this.knots[0]+t*(this.knots[this.knots.length-\n1]-this.knots[0]);t=(0,_NURBSUtils.calcNURBSDerivatives)(this.degree,this.knots,this.controlPoints,t,1);optionalTarget.copy(t[1]).normalize();return optionalTarget}}]);return NURBSCurve}(_three.Curve);exports.NURBSCurve=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$curves$NURBSCurve\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NURBSCurve = void 0;\n\nvar _three = require(\"three\");\n\nvar _NURBSUtils = require(\"./NURBSUtils.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * NURBS curve object\n *\n * Derives from Curve, overriding getPoint and getTangent.\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\nvar NURBSCurve =\n/*#__PURE__*/\nfunction (_Curve) {\n  _inherits(NURBSCurve, _Curve);\n\n  function NURBSCurve(degree, knots\n  /* array of reals */\n  , controlPoints\n  /* array of Vector(2|3|4) */\n  , startKnot\n  /* index in knots */\n  , endKnot\n  /* index in knots */\n  ) {\n    var _this;\n\n    _classCallCheck(this, NURBSCurve);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NURBSCurve).call(this));\n    _this.degree = degree;\n    _this.knots = knots;\n    _this.controlPoints = []; // Used by periodic NURBS to remove hidden spans\n\n    _this.startKnot = startKnot || 0;\n    _this.endKnot = endKnot || _this.knots.length - 1;\n\n    for (var i = 0; i < controlPoints.length; ++i) {\n      // ensure Vector4 for control points\n      var point = controlPoints[i];\n      _this.controlPoints[i] = new _three.Vector4(point.x, point.y, point.z, point.w);\n    }\n\n    return _this;\n  }\n\n  _createClass(NURBSCurve, [{\n    key: \"getPoint\",\n    value: function getPoint(t, optionalTarget) {\n      var point = optionalTarget || new _three.Vector3();\n      var u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]); // linear mapping t->u\n      // following results in (wx, wy, wz, w) homogeneous point\n\n      var hpoint = (0, _NURBSUtils.calcBSplinePoint)(this.degree, this.knots, this.controlPoints, u);\n\n      if (hpoint.w != 1.0) {\n        // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n        hpoint.divideScalar(hpoint.w);\n      }\n\n      return point.set(hpoint.x, hpoint.y, hpoint.z);\n    }\n  }, {\n    key: \"getTangent\",\n    value: function getTangent(t, optionalTarget) {\n      var tangent = optionalTarget || new _three.Vector3();\n      var u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\n      var ders = (0, _NURBSUtils.calcNURBSDerivatives)(this.degree, this.knots, this.controlPoints, u, 1);\n      tangent.copy(ders[1]).normalize();\n      return tangent;\n    }\n  }]);\n\n  return NURBSCurve;\n}(_three.Curve);\n\nexports.NURBSCurve = NURBSCurve;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_stdlib$curves$NURBSUtils","~$shadow.js"]],"~:properties",["^5",["NURBSCurve","endKnot","degree","prototype","key","__esModule","controlPoints","configurable","startKnot","value","enumerable","knots","writable","__proto__","constructor"]],"~:compiled-at",1630917515543,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$curves$NURBSCurve.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/curves/NURBSCurve.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$curves$NURBSCurve\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.NURBSCurve = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _NURBSUtils = require(\\\"./NURBSUtils.js\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * NURBS curve object\\n *\\n * Derives from Curve, overriding getPoint and getTangent.\\n *\\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\\n *\\n **/\\nvar NURBSCurve =\\n/*#__PURE__*/\\nfunction (_Curve) {\\n  _inherits(NURBSCurve, _Curve);\\n\\n  function NURBSCurve(degree, knots\\n  /* array of reals */\\n  , controlPoints\\n  /* array of Vector(2|3|4) */\\n  , startKnot\\n  /* index in knots */\\n  , endKnot\\n  /* index in knots */\\n  ) {\\n    var _this;\\n\\n    _classCallCheck(this, NURBSCurve);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NURBSCurve).call(this));\\n    _this.degree = degree;\\n    _this.knots = knots;\\n    _this.controlPoints = []; // Used by periodic NURBS to remove hidden spans\\n\\n    _this.startKnot = startKnot || 0;\\n    _this.endKnot = endKnot || _this.knots.length - 1;\\n\\n    for (var i = 0; i < controlPoints.length; ++i) {\\n      // ensure Vector4 for control points\\n      var point = controlPoints[i];\\n      _this.controlPoints[i] = new _three.Vector4(point.x, point.y, point.z, point.w);\\n    }\\n\\n    return _this;\\n  }\\n\\n  _createClass(NURBSCurve, [{\\n    key: \\\"getPoint\\\",\\n    value: function getPoint(t, optionalTarget) {\\n      var point = optionalTarget || new _three.Vector3();\\n      var u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]); // linear mapping t->u\\n      // following results in (wx, wy, wz, w) homogeneous point\\n\\n      var hpoint = (0, _NURBSUtils.calcBSplinePoint)(this.degree, this.knots, this.controlPoints, u);\\n\\n      if (hpoint.w != 1.0) {\\n        // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\\n        hpoint.divideScalar(hpoint.w);\\n      }\\n\\n      return point.set(hpoint.x, hpoint.y, hpoint.z);\\n    }\\n  }, {\\n    key: \\\"getTangent\\\",\\n    value: function getTangent(t, optionalTarget) {\\n      var tangent = optionalTarget || new _three.Vector3();\\n      var u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);\\n      var ders = (0, _NURBSUtils.calcNURBSDerivatives)(this.degree, this.knots, this.controlPoints, u, 1);\\n      tangent.copy(ders[1]).normalize();\\n      return tangent;\\n    }\\n  }]);\\n\\n  return NURBSCurve;\\n}(_three.Curve);\\n\\nexports.NURBSCurve = NURBSCurve;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"NURBSCurve\",\"_three\",\"_NURBSUtils\",\"_Curve\",\"degree\",\"knots\",\"controlPoints\",\"startKnot\",\"endKnot\",\"instance\",\"call\",\"self\",\"ReferenceError\",\"_this\",\"point\",\"Vector4\",\"x\",\"y\",\"z\",\"w\",\"getPoint\",\"t\",\"optionalTarget\",\"Vector3\",\"u\",\"hpoint\",\"calcBSplinePoint\",\"divideScalar\",\"set\",\"getTangent\",\"tangent\",\"ders\",\"calcNURBSDerivatives\",\"copy\",\"normalize\",\"Curve\"]\n}\n"]