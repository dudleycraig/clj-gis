["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/objects/Reflector.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$objects$Reflector=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _possibleConstructorReturn(self,call){return!call||\"object\"!==_typeof(call)&&\"function\"!==typeof call?\n_assertThisInitialized(self):call}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");\nsubClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.Reflector=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_Mesh){function Reflector(geometry){var options=\n1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!(this instanceof Reflector))throw new TypeError(\"Cannot call a class as a function\");var _this=_possibleConstructorReturn(this,_getPrototypeOf(Reflector).call(this,geometry));_this.type=\"Reflector\";var scope=_assertThisInitialized(_this),color=void 0!==options.color?new _three.Color(options.color):new _three.Color(8355711),textureWidth=options.textureWidth||512,textureHeight=options.textureHeight||512,clipBias=options.clipBias||0;options=\noptions.shader||Reflector.ReflectorShader;var reflectorPlane=new _three.Plane,normal=new _three.Vector3,reflectorWorldPosition=new _three.Vector3,cameraWorldPosition=new _three.Vector3,rotationMatrix=new _three.Matrix4,lookAtPosition=new _three.Vector3(0,0,-1),clipPlane=new _three.Vector4,view=new _three.Vector3,target=new _three.Vector3,q=new _three.Vector4,textureMatrix=new _three.Matrix4,virtualCamera=new _three.PerspectiveCamera,renderTarget=new _three.WebGLRenderTarget(textureWidth,textureHeight,\n{minFilter:_three.LinearFilter,magFilter:_three.LinearFilter,format:_three.RGBFormat});_three.MathUtils.isPowerOfTwo(textureWidth)&&_three.MathUtils.isPowerOfTwo(textureHeight)||(renderTarget.texture.generateMipmaps=!1);textureWidth=new _three.ShaderMaterial({uniforms:_three.UniformsUtils.clone(options.uniforms),fragmentShader:options.fragmentShader,vertexShader:options.vertexShader});textureWidth.uniforms.tDiffuse.value=renderTarget.texture;textureWidth.uniforms.color.value=color;textureWidth.uniforms.textureMatrix.value=\ntextureMatrix;_this.material=textureWidth;_this.onBeforeRender=function(renderer,scene,camera){reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);rotationMatrix.extractRotation(scope.matrixWorld);normal.set(0,0,1);normal.applyMatrix4(rotationMatrix);view.subVectors(reflectorWorldPosition,cameraWorldPosition);if(!(0<view.dot(normal))){view.reflect(normal).negate();view.add(reflectorWorldPosition);rotationMatrix.extractRotation(camera.matrixWorld);\nlookAtPosition.set(0,0,-1);lookAtPosition.applyMatrix4(rotationMatrix);lookAtPosition.add(cameraWorldPosition);target.subVectors(reflectorWorldPosition,lookAtPosition);target.reflect(normal).negate();target.add(reflectorWorldPosition);virtualCamera.position.copy(view);virtualCamera.up.set(0,1,0);virtualCamera.up.applyMatrix4(rotationMatrix);virtualCamera.up.reflect(normal);virtualCamera.lookAt(target);virtualCamera.far=camera.far;virtualCamera.updateMatrixWorld();virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\ntextureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);textureMatrix.multiply(virtualCamera.projectionMatrix);textureMatrix.multiply(virtualCamera.matrixWorldInverse);textureMatrix.multiply(scope.matrixWorld);reflectorPlane.setFromNormalAndCoplanarPoint(normal,reflectorWorldPosition);reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);clipPlane.set(reflectorPlane.normal.x,reflectorPlane.normal.y,reflectorPlane.normal.z,reflectorPlane.constant);var projectionMatrix=virtualCamera.projectionMatrix;\nq.x=(Math.sign(clipPlane.x)+projectionMatrix.elements[8])/projectionMatrix.elements[0];q.y=(Math.sign(clipPlane.y)+projectionMatrix.elements[9])/projectionMatrix.elements[5];q.z=-1;q.w=(1+projectionMatrix.elements[10])/projectionMatrix.elements[14];clipPlane.multiplyScalar(2/clipPlane.dot(q));projectionMatrix.elements[2]=clipPlane.x;projectionMatrix.elements[6]=clipPlane.y;projectionMatrix.elements[10]=clipPlane.z+1-clipBias;projectionMatrix.elements[14]=clipPlane.w;renderTarget.texture.encoding=\nrenderer.outputEncoding;scope.visible=!1;projectionMatrix=renderer.getRenderTarget();var currentXrEnabled=renderer.xr.enabled,currentShadowAutoUpdate=renderer.shadowMap.autoUpdate;renderer.xr.enabled=!1;renderer.shadowMap.autoUpdate=!1;renderer.setRenderTarget(renderTarget);renderer.state.buffers.depth.setMask(!0);!1===renderer.autoClear&&renderer.clear();renderer.render(scene,virtualCamera);renderer.xr.enabled=currentXrEnabled;renderer.shadowMap.autoUpdate=currentShadowAutoUpdate;renderer.setRenderTarget(projectionMatrix);\nscene=camera.viewport;void 0!==scene&&renderer.state.viewport(scene);scope.visible=!0}};_this.getRenderTarget=function(){return renderTarget};return _this}_inherits(Reflector,_Mesh);return Reflector}(_three.Mesh);exports.Reflector=global;global.prototype.isReflector=!0;global.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:\"\\n\\t\\tuniform mat4 textureMatrix;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv \\x3d textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\nfragmentShader:\"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base \\x3c 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvec4 base \\x3d texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor \\x3d vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$objects$Reflector\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Reflector = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Reflector =\n/*#__PURE__*/\nfunction (_Mesh) {\n  _inherits(Reflector, _Mesh);\n\n  function Reflector(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Reflector);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Reflector).call(this, geometry));\n    _this.type = 'Reflector';\n\n    var scope = _assertThisInitialized(_this);\n\n    var color = options.color !== undefined ? new _three.Color(options.color) : new _three.Color(0x7f7f7f);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || Reflector.ReflectorShader; //\n\n    var reflectorPlane = new _three.Plane();\n    var normal = new _three.Vector3();\n    var reflectorWorldPosition = new _three.Vector3();\n    var cameraWorldPosition = new _three.Vector3();\n    var rotationMatrix = new _three.Matrix4();\n    var lookAtPosition = new _three.Vector3(0, 0, -1);\n    var clipPlane = new _three.Vector4();\n    var view = new _three.Vector3();\n    var target = new _three.Vector3();\n    var q = new _three.Vector4();\n    var textureMatrix = new _three.Matrix4();\n    var virtualCamera = new _three.PerspectiveCamera();\n    var parameters = {\n      minFilter: _three.LinearFilter,\n      magFilter: _three.LinearFilter,\n      format: _three.RGBFormat\n    };\n    var renderTarget = new _three.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n    if (!_three.MathUtils.isPowerOfTwo(textureWidth) || !_three.MathUtils.isPowerOfTwo(textureHeight)) {\n      renderTarget.texture.generateMipmaps = false;\n    }\n\n    var material = new _three.ShaderMaterial({\n      uniforms: _three.UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\n    material.uniforms['color'].value = color;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    _this.material = material;\n\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far; // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n      var projectionMatrix = virtualCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w; // Render\n\n      renderTarget.texture.encoding = renderer.outputEncoding;\n      scope.visible = false;\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // Avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      var viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    };\n\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    return _this;\n  }\n\n  return Reflector;\n}(_three.Mesh);\n\nexports.Reflector = Reflector;\nReflector.prototype.isReflector = true;\nReflector.ReflectorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\t\\tuniform mat4 textureMatrix;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t}\"\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","z","w","ReflectorShader","textureMatrix","prototype","autoUpdate","far","x","__esModule","onBeforeRender","encoding","enabled","tDiffuse","getRenderTarget","vertexShader","configurable","value","isReflector","visible","magFilter","writable","type","y","__proto__","Reflector","generateMipmaps","uniforms","minFilter","color","format","constructor","material"]],"~:compiled-at",1630917515362,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$objects$Reflector.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/objects/Reflector.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$objects$Reflector\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.Reflector = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar Reflector =\\n/*#__PURE__*/\\nfunction (_Mesh) {\\n  _inherits(Reflector, _Mesh);\\n\\n  function Reflector(geometry) {\\n    var _this;\\n\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n    _classCallCheck(this, Reflector);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Reflector).call(this, geometry));\\n    _this.type = 'Reflector';\\n\\n    var scope = _assertThisInitialized(_this);\\n\\n    var color = options.color !== undefined ? new _three.Color(options.color) : new _three.Color(0x7f7f7f);\\n    var textureWidth = options.textureWidth || 512;\\n    var textureHeight = options.textureHeight || 512;\\n    var clipBias = options.clipBias || 0;\\n    var shader = options.shader || Reflector.ReflectorShader; //\\n\\n    var reflectorPlane = new _three.Plane();\\n    var normal = new _three.Vector3();\\n    var reflectorWorldPosition = new _three.Vector3();\\n    var cameraWorldPosition = new _three.Vector3();\\n    var rotationMatrix = new _three.Matrix4();\\n    var lookAtPosition = new _three.Vector3(0, 0, -1);\\n    var clipPlane = new _three.Vector4();\\n    var view = new _three.Vector3();\\n    var target = new _three.Vector3();\\n    var q = new _three.Vector4();\\n    var textureMatrix = new _three.Matrix4();\\n    var virtualCamera = new _three.PerspectiveCamera();\\n    var parameters = {\\n      minFilter: _three.LinearFilter,\\n      magFilter: _three.LinearFilter,\\n      format: _three.RGBFormat\\n    };\\n    var renderTarget = new _three.WebGLRenderTarget(textureWidth, textureHeight, parameters);\\n\\n    if (!_three.MathUtils.isPowerOfTwo(textureWidth) || !_three.MathUtils.isPowerOfTwo(textureHeight)) {\\n      renderTarget.texture.generateMipmaps = false;\\n    }\\n\\n    var material = new _three.ShaderMaterial({\\n      uniforms: _three.UniformsUtils.clone(shader.uniforms),\\n      fragmentShader: shader.fragmentShader,\\n      vertexShader: shader.vertexShader\\n    });\\n    material.uniforms['tDiffuse'].value = renderTarget.texture;\\n    material.uniforms['color'].value = color;\\n    material.uniforms['textureMatrix'].value = textureMatrix;\\n    _this.material = material;\\n\\n    _this.onBeforeRender = function (renderer, scene, camera) {\\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\\n      rotationMatrix.extractRotation(scope.matrixWorld);\\n      normal.set(0, 0, 1);\\n      normal.applyMatrix4(rotationMatrix);\\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition); // Avoid rendering when reflector is facing away\\n\\n      if (view.dot(normal) > 0) return;\\n      view.reflect(normal).negate();\\n      view.add(reflectorWorldPosition);\\n      rotationMatrix.extractRotation(camera.matrixWorld);\\n      lookAtPosition.set(0, 0, -1);\\n      lookAtPosition.applyMatrix4(rotationMatrix);\\n      lookAtPosition.add(cameraWorldPosition);\\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\\n      target.reflect(normal).negate();\\n      target.add(reflectorWorldPosition);\\n      virtualCamera.position.copy(view);\\n      virtualCamera.up.set(0, 1, 0);\\n      virtualCamera.up.applyMatrix4(rotationMatrix);\\n      virtualCamera.up.reflect(normal);\\n      virtualCamera.lookAt(target);\\n      virtualCamera.far = camera.far; // Used in WebGLBackground\\n\\n      virtualCamera.updateMatrixWorld();\\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\\n\\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\\n      textureMatrix.multiply(scope.matrixWorld); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\\n\\n      reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\\n      reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\\n      clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\\n      var projectionMatrix = virtualCamera.projectionMatrix;\\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\\n      q.z = -1.0;\\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\\n\\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\\n\\n      projectionMatrix.elements[2] = clipPlane.x;\\n      projectionMatrix.elements[6] = clipPlane.y;\\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\\n      projectionMatrix.elements[14] = clipPlane.w; // Render\\n\\n      renderTarget.texture.encoding = renderer.outputEncoding;\\n      scope.visible = false;\\n      var currentRenderTarget = renderer.getRenderTarget();\\n      var currentXrEnabled = renderer.xr.enabled;\\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\\n      renderer.xr.enabled = false; // Avoid camera modification\\n\\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\\n\\n      renderer.setRenderTarget(renderTarget);\\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\\n\\n      if (renderer.autoClear === false) renderer.clear();\\n      renderer.render(scene, virtualCamera);\\n      renderer.xr.enabled = currentXrEnabled;\\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\\n\\n      var viewport = camera.viewport;\\n\\n      if (viewport !== undefined) {\\n        renderer.state.viewport(viewport);\\n      }\\n\\n      scope.visible = true;\\n    };\\n\\n    _this.getRenderTarget = function () {\\n      return renderTarget;\\n    };\\n\\n    return _this;\\n  }\\n\\n  return Reflector;\\n}(_three.Mesh);\\n\\nexports.Reflector = Reflector;\\nReflector.prototype.isReflector = true;\\nReflector.ReflectorShader = {\\n  uniforms: {\\n    color: {\\n      value: null\\n    },\\n    tDiffuse: {\\n      value: null\\n    },\\n    textureMatrix: {\\n      value: null\\n    }\\n  },\\n  vertexShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\t\\\\tuniform mat4 textureMatrix;\\\\n\\\\t\\\\tvarying vec4 vUv;\\\\n\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\tvUv = textureMatrix * vec4( position, 1.0 );\\\\n\\\\n\\\\t\\\\t\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\n\\\\t\\\\t}\\\",\\n  fragmentShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\t\\\\tuniform vec3 color;\\\\n\\\\t\\\\tuniform sampler2D tDiffuse;\\\\n\\\\t\\\\tvarying vec4 vUv;\\\\n\\\\n\\\\t\\\\tfloat blendOverlay( float base, float blend ) {\\\\n\\\\n\\\\t\\\\t\\\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\\\n\\\\n\\\\t\\\\t\\\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\tvec4 base = texture2DProj( tDiffuse, vUv );\\\\n\\\\t\\\\t\\\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\\\n\\\\n\\\\t\\\\t}\\\"\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_possibleConstructorReturn\",\"self\",\"call\",\"_assertThisInitialized\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"ReferenceError\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"defineProperty\",\"Reflector\",\"_three\",\"_Mesh\",\"geometry\",\"options\",\"arguments\",\"length\",\"undefined\",\"instance\",\"_this\",\"type\",\"scope\",\"color\",\"Color\",\"textureWidth\",\"textureHeight\",\"clipBias\",\"shader\",\"ReflectorShader\",\"reflectorPlane\",\"Plane\",\"normal\",\"Vector3\",\"reflectorWorldPosition\",\"cameraWorldPosition\",\"rotationMatrix\",\"Matrix4\",\"lookAtPosition\",\"clipPlane\",\"Vector4\",\"view\",\"target\",\"q\",\"textureMatrix\",\"virtualCamera\",\"PerspectiveCamera\",\"renderTarget\",\"WebGLRenderTarget\",\"parameters\",\"minFilter\",\"LinearFilter\",\"magFilter\",\"format\",\"RGBFormat\",\"MathUtils\",\"isPowerOfTwo\",\"texture\",\"generateMipmaps\",\"material\",\"ShaderMaterial\",\"uniforms\",\"UniformsUtils\",\"clone\",\"fragmentShader\",\"vertexShader\",\"onBeforeRender\",\"_this.onBeforeRender\",\"renderer\",\"scene\",\"camera\",\"setFromMatrixPosition\",\"matrixWorld\",\"extractRotation\",\"set\",\"applyMatrix4\",\"subVectors\",\"dot\",\"reflect\",\"negate\",\"add\",\"position\",\"copy\",\"up\",\"lookAt\",\"far\",\"updateMatrixWorld\",\"projectionMatrix\",\"multiply\",\"matrixWorldInverse\",\"setFromNormalAndCoplanarPoint\",\"x\",\"y\",\"z\",\"constant\",\"Math\",\"sign\",\"elements\",\"w\",\"multiplyScalar\",\"encoding\",\"outputEncoding\",\"visible\",\"currentRenderTarget\",\"getRenderTarget\",\"currentXrEnabled\",\"xr\",\"enabled\",\"currentShadowAutoUpdate\",\"shadowMap\",\"autoUpdate\",\"setRenderTarget\",\"state\",\"buffers\",\"depth\",\"setMask\",\"autoClear\",\"clear\",\"render\",\"viewport\",\"_this.getRenderTarget\",\"Mesh\",\"isReflector\",\"tDiffuse\"]\n}\n"]