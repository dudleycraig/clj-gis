["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/postprocessing/CubeTexturePass.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$postprocessing$CubeTexturePass=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.CubeTexturePass=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=require(\"module$node_modules$three_stdlib$postprocessing$Pass\");require=function(camera,envMap,opacity){this.camera=camera;this.needsSwap=!1;this.cubeShader=_three.ShaderLib.cube;this.cubeMesh=new _three.Mesh(new _three.BoxGeometry(10,\n10,10),new _three.ShaderMaterial({uniforms:_three.UniformsUtils.clone(this.cubeShader.uniforms),vertexShader:this.cubeShader.vertexShader,fragmentShader:this.cubeShader.fragmentShader,depthTest:!1,depthWrite:!1,side:_three.BackSide}));Object.defineProperty(this.cubeMesh.material,\"envMap\",{get:function(){return this.uniforms.envMap.value}});this.envMap=envMap;this.opacity=void 0!==opacity?opacity:1;this.cubeScene=new _three.Scene;this.cubeCamera=new _three.PerspectiveCamera;this.cubeScene.add(this.cubeMesh)};\nexports.CubeTexturePass=require;require.prototype=Object.assign(Object.create(global.Pass.prototype),{constructor:require,render:function(renderer,writeBuffer,readBuffer){writeBuffer=renderer.autoClear;renderer.autoClear=!1;this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);this.cubeMesh.material.uniforms.envMap.value=this.envMap;this.cubeMesh.material.uniforms.flipEnvMap.value=this.envMap.isCubeTexture&&this.envMap._needsFlipEnvMap?\n-1:1;this.cubeMesh.material.uniforms.opacity.value=this.opacity;this.cubeMesh.material.transparent=1>this.opacity;renderer.setRenderTarget(this.renderToScreen?null:readBuffer);this.clear&&renderer.clear();renderer.render(this.cubeScene,this.cubeCamera);renderer.autoClear=writeBuffer}})}","~:source","shadow$provide[\"module$node_modules$three_stdlib$postprocessing$CubeTexturePass\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CubeTexturePass = void 0;\n\nvar _three = require(\"three\");\n\nvar _Pass = require(\"./Pass.js\");\n\nvar CubeTexturePass = function CubeTexturePass(camera, envMap, opacity) {\n  this.camera = camera;\n  this.needsSwap = false;\n  this.cubeShader = _three.ShaderLib['cube'];\n  this.cubeMesh = new _three.Mesh(new _three.BoxGeometry(10, 10, 10), new _three.ShaderMaterial({\n    uniforms: _three.UniformsUtils.clone(this.cubeShader.uniforms),\n    vertexShader: this.cubeShader.vertexShader,\n    fragmentShader: this.cubeShader.fragmentShader,\n    depthTest: false,\n    depthWrite: false,\n    side: _three.BackSide\n  }));\n  Object.defineProperty(this.cubeMesh.material, 'envMap', {\n    get: function get() {\n      return this.uniforms.envMap.value;\n    }\n  });\n  this.envMap = envMap;\n  this.opacity = opacity !== undefined ? opacity : 1.0;\n  this.cubeScene = new _three.Scene();\n  this.cubeCamera = new _three.PerspectiveCamera();\n  this.cubeScene.add(this.cubeMesh);\n};\n\nexports.CubeTexturePass = CubeTexturePass;\nCubeTexturePass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {\n  constructor: CubeTexturePass,\n  render: function render(renderer, writeBuffer, readBuffer\n  /*, deltaTime, maskActive*/\n  ) {\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n    this.cubeMesh.material.uniforms.envMap.value = this.envMap;\n    this.cubeMesh.material.uniforms.flipEnvMap.value = this.envMap.isCubeTexture && this.envMap._needsFlipEnvMap ? -1 : 1;\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\n    this.cubeMesh.material.transparent = this.opacity < 1.0;\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.cubeScene, this.cubeCamera);\n    renderer.autoClear = oldAutoClear;\n  }\n});\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$three_stdlib$postprocessing$Pass"]],"~:properties",["^5",["fragmentShader","CubeTexturePass","depthTest","prototype","transparent","side","needsSwap","__esModule","cubeScene","camera","vertexShader","value","autoClear","cubeCamera","render","depthWrite","envMap","uniforms","cubeShader","cubeMesh","get","opacity","constructor"]],"~:compiled-at",1630917515516,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$postprocessing$CubeTexturePass.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/postprocessing/CubeTexturePass.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$postprocessing$CubeTexturePass\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.CubeTexturePass = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _Pass = require(\\\"./Pass.js\\\");\\n\\nvar CubeTexturePass = function CubeTexturePass(camera, envMap, opacity) {\\n  this.camera = camera;\\n  this.needsSwap = false;\\n  this.cubeShader = _three.ShaderLib['cube'];\\n  this.cubeMesh = new _three.Mesh(new _three.BoxGeometry(10, 10, 10), new _three.ShaderMaterial({\\n    uniforms: _three.UniformsUtils.clone(this.cubeShader.uniforms),\\n    vertexShader: this.cubeShader.vertexShader,\\n    fragmentShader: this.cubeShader.fragmentShader,\\n    depthTest: false,\\n    depthWrite: false,\\n    side: _three.BackSide\\n  }));\\n  Object.defineProperty(this.cubeMesh.material, 'envMap', {\\n    get: function get() {\\n      return this.uniforms.envMap.value;\\n    }\\n  });\\n  this.envMap = envMap;\\n  this.opacity = opacity !== undefined ? opacity : 1.0;\\n  this.cubeScene = new _three.Scene();\\n  this.cubeCamera = new _three.PerspectiveCamera();\\n  this.cubeScene.add(this.cubeMesh);\\n};\\n\\nexports.CubeTexturePass = CubeTexturePass;\\nCubeTexturePass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {\\n  constructor: CubeTexturePass,\\n  render: function render(renderer, writeBuffer, readBuffer\\n  /*, deltaTime, maskActive*/\\n  ) {\\n    var oldAutoClear = renderer.autoClear;\\n    renderer.autoClear = false;\\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\\n    this.cubeMesh.material.uniforms.envMap.value = this.envMap;\\n    this.cubeMesh.material.uniforms.flipEnvMap.value = this.envMap.isCubeTexture && this.envMap._needsFlipEnvMap ? -1 : 1;\\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\\n    this.cubeMesh.material.transparent = this.opacity < 1.0;\\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\\n    if (this.clear) renderer.clear();\\n    renderer.render(this.cubeScene, this.cubeCamera);\\n    renderer.autoClear = oldAutoClear;\\n  }\\n});\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"CubeTexturePass\",\"_three\",\"_Pass\",\"camera\",\"envMap\",\"opacity\",\"needsSwap\",\"cubeShader\",\"ShaderLib\",\"cubeMesh\",\"Mesh\",\"BoxGeometry\",\"ShaderMaterial\",\"uniforms\",\"UniformsUtils\",\"clone\",\"vertexShader\",\"fragmentShader\",\"depthTest\",\"depthWrite\",\"side\",\"BackSide\",\"material\",\"get\",\"undefined\",\"cubeScene\",\"Scene\",\"cubeCamera\",\"PerspectiveCamera\",\"add\",\"prototype\",\"assign\",\"create\",\"Pass\",\"constructor\",\"render\",\"renderer\",\"writeBuffer\",\"readBuffer\",\"oldAutoClear\",\"autoClear\",\"projectionMatrix\",\"copy\",\"quaternion\",\"setFromRotationMatrix\",\"matrixWorld\",\"flipEnvMap\",\"isCubeTexture\",\"_needsFlipEnvMap\",\"transparent\",\"setRenderTarget\",\"renderToScreen\",\"clear\"]\n}\n"]