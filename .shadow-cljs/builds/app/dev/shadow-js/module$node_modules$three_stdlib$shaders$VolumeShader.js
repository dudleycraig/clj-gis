["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/VolumeShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$VolumeShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.VolumeRenderShader1=void 0;global=require(\"module$node_modules$three$build$three_module\");global={uniforms:{u_size:{value:new global.Vector3(1,1,1)},u_renderstyle:{value:0},u_renderthreshold:{value:.5},u_clim:{value:new global.Vector2(1,1)},u_data:{value:null},u_cmdata:{value:null}},vertexShader:\"\\t\\tvarying vec4 v_nearpos;\\n\\t\\tvarying vec4 v_farpos;\\n\\t\\tvarying vec3 v_position;\\n\\t\\tvoid main() {\\n\\t\\t\\t\\tmat4 viewtransformf \\x3d modelViewMatrix;\\n\\t\\t\\t\\tmat4 viewtransformi \\x3d inverse(modelViewMatrix);\\n\\t\\t\\t\\tvec4 position4 \\x3d vec4(position, 1.0);\\n\\t\\t\\t\\tvec4 pos_in_cam \\x3d viewtransformf * position4;\\n\\t\\t\\t\\tpos_in_cam.z \\x3d -pos_in_cam.w;\\n\\t\\t\\t\\tv_nearpos \\x3d viewtransformi * pos_in_cam;\\n\\t\\t\\t\\tpos_in_cam.z \\x3d pos_in_cam.w;\\n\\t\\t\\t\\tv_farpos \\x3d viewtransformi * pos_in_cam;\\n\\t\\t\\t\\tv_position \\x3d position;\\n\\t\\t\\t\\tgl_Position \\x3d projectionMatrix * viewMatrix * modelMatrix * position4;\\n\\t\\t}\",\nfragmentShader:\"\\t\\tprecision highp float;\\n\\t\\tprecision mediump sampler3D;\\n\\t\\tuniform vec3 u_size;\\n\\t\\tuniform int u_renderstyle;\\n\\t\\tuniform float u_renderthreshold;\\n\\t\\tuniform vec2 u_clim;\\n\\t\\tuniform sampler3D u_data;\\n\\t\\tuniform sampler2D u_cmdata;\\n\\t\\tvarying vec3 v_position;\\n\\t\\tvarying vec4 v_nearpos;\\n\\t\\tvarying vec4 v_farpos;\\n\\t\\tconst int MAX_STEPS \\x3d 887;\\t// 887 for 512^3, 1774 for 1024^3\\n\\t\\tconst int REFINEMENT_STEPS \\x3d 4;\\n\\t\\tconst float relative_step_size \\x3d 1.0;\\n\\t\\tconst vec4 ambient_color \\x3d vec4(0.2, 0.4, 0.2, 1.0);\\n\\t\\tconst vec4 diffuse_color \\x3d vec4(0.8, 0.2, 0.2, 1.0);\\n\\t\\tconst vec4 specular_color \\x3d vec4(1.0, 1.0, 1.0, 1.0);\\n\\t\\tconst float shininess \\x3d 40.0;\\n\\t\\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\\n\\t\\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\\n\\t\\tfloat sample1(vec3 texcoords);\\n\\t\\tvec4 apply_colormap(float val);\\n\\t\\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);\\n\\t\\tvoid main() {\\n\\t\\t\\t\\tvec3 farpos \\x3d v_farpos.xyz / v_farpos.w;\\n\\t\\t\\t\\tvec3 nearpos \\x3d v_nearpos.xyz / v_nearpos.w;\\n\\t\\t\\t\\tvec3 view_ray \\x3d normalize(nearpos.xyz - farpos.xyz);\\n\\t\\t\\t\\tfloat distance \\x3d dot(nearpos - v_position, view_ray);\\n\\t\\t\\t\\tdistance \\x3d max(distance, min((-0.5 - v_position.x) / view_ray.x,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.x - 0.5 - v_position.x) / view_ray.x));\\n\\t\\t\\t\\tdistance \\x3d max(distance, min((-0.5 - v_position.y) / view_ray.y,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.y - 0.5 - v_position.y) / view_ray.y));\\n\\t\\t\\t\\tdistance \\x3d max(distance, min((-0.5 - v_position.z) / view_ray.z,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.z - 0.5 - v_position.z) / view_ray.z));\\n\\t\\t\\t\\tvec3 front \\x3d v_position + view_ray * distance;\\n\\t\\t\\t\\tint nsteps \\x3d int(-distance / relative_step_size + 0.5);\\n\\t\\t\\t\\tif ( nsteps \\x3c 1 )\\n\\t\\t\\t\\t\\t\\tdiscard;\\n\\t\\t\\t\\tvec3 step \\x3d ((v_position - front) / u_size) / float(nsteps);\\n\\t\\t\\t\\tvec3 start_loc \\x3d front / u_size;\\n\\t\\t\\t\\tif (u_renderstyle \\x3d\\x3d 0)\\n\\t\\t\\t\\t\\t\\tcast_mip(start_loc, step, nsteps, view_ray);\\n\\t\\t\\t\\telse if (u_renderstyle \\x3d\\x3d 1)\\n\\t\\t\\t\\t\\t\\tcast_iso(start_loc, step, nsteps, view_ray);\\n\\t\\t\\t\\tif (gl_FragColor.a \\x3c 0.05)\\n\\t\\t\\t\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t\\tfloat sample1(vec3 texcoords) {\\n\\t\\t\\t\\t/* Sample float value from a 3D texture. Assumes intensity data. */\\n\\t\\t\\t\\treturn texture(u_data, texcoords.xyz).r;\\n\\t\\t}\\n\\t\\tvec4 apply_colormap(float val) {\\n\\t\\t\\t\\tval \\x3d (val - u_clim[0]) / (u_clim[1] - u_clim[0]);\\n\\t\\t\\t\\treturn texture2D(u_cmdata, vec2(val, 0.5));\\n\\t\\t}\\n\\t\\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\\n\\t\\t\\t\\tfloat max_val \\x3d -1e6;\\n\\t\\t\\t\\tint max_i \\x3d 100;\\n\\t\\t\\t\\tvec3 loc \\x3d start_loc;\\n\\t\\t\\t\\tfor (int iter\\x3d0; iter\\x3cMAX_STEPS; iter++) {\\n\\t\\t\\t\\t\\t\\tif (iter \\x3e\\x3d nsteps)\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tfloat val \\x3d sample1(loc);\\n\\t\\t\\t\\t\\t\\tif (val \\x3e max_val) {\\n\\t\\t\\t\\t\\t\\t\\t\\tmax_val \\x3d val;\\n\\t\\t\\t\\t\\t\\t\\t\\tmax_i \\x3d iter;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tloc +\\x3d step;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvec3 iloc \\x3d start_loc + step * (float(max_i) - 0.5);\\n\\t\\t\\t\\tvec3 istep \\x3d step / float(REFINEMENT_STEPS);\\n\\t\\t\\t\\tfor (int i\\x3d0; i\\x3cREFINEMENT_STEPS; i++) {\\n\\t\\t\\t\\t\\t\\tmax_val \\x3d max(max_val, sample1(iloc));\\n\\t\\t\\t\\t\\t\\tiloc +\\x3d istep;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgl_FragColor \\x3d apply_colormap(max_val);\\n\\t\\t}\\n\\t\\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\\n\\t\\t\\t\\tgl_FragColor \\x3d vec4(0.0);\\t// init transparent\\n\\t\\t\\t\\tvec4 color3 \\x3d vec4(0.0);\\t// final color\\n\\t\\t\\t\\tvec3 dstep \\x3d 1.5 / u_size;\\t// step to sample derivative\\n\\t\\t\\t\\tvec3 loc \\x3d start_loc;\\n\\t\\t\\t\\tfloat low_threshold \\x3d u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);\\n\\t\\t\\t\\tfor (int iter\\x3d0; iter\\x3cMAX_STEPS; iter++) {\\n\\t\\t\\t\\t\\t\\tif (iter \\x3e\\x3d nsteps)\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tfloat val \\x3d sample1(loc);\\n\\t\\t\\t\\t\\t\\tif (val \\x3e low_threshold) {\\n\\t\\t\\t\\t\\t\\t\\t\\tvec3 iloc \\x3d loc - 0.5 * step;\\n\\t\\t\\t\\t\\t\\t\\t\\tvec3 istep \\x3d step / float(REFINEMENT_STEPS);\\n\\t\\t\\t\\t\\t\\t\\t\\tfor (int i\\x3d0; i\\x3cREFINEMENT_STEPS; i++) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tval \\x3d sample1(iloc);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (val \\x3e u_renderthreshold) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tgl_FragColor \\x3d add_lighting(val, iloc, dstep, view_ray);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tiloc +\\x3d istep;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tloc +\\x3d step;\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)\\n\\t\\t{\\n\\t\\t\\t\\tvec3 V \\x3d normalize(view_ray);\\n\\t\\t\\t\\tvec3 N;\\n\\t\\t\\t\\tfloat val1, val2;\\n\\t\\t\\t\\tval1 \\x3d sample1(loc + vec3(-step[0], 0.0, 0.0));\\n\\t\\t\\t\\tval2 \\x3d sample1(loc + vec3(+step[0], 0.0, 0.0));\\n\\t\\t\\t\\tN[0] \\x3d val1 - val2;\\n\\t\\t\\t\\tval \\x3d max(max(val1, val2), val);\\n\\t\\t\\t\\tval1 \\x3d sample1(loc + vec3(0.0, -step[1], 0.0));\\n\\t\\t\\t\\tval2 \\x3d sample1(loc + vec3(0.0, +step[1], 0.0));\\n\\t\\t\\t\\tN[1] \\x3d val1 - val2;\\n\\t\\t\\t\\tval \\x3d max(max(val1, val2), val);\\n\\t\\t\\t\\tval1 \\x3d sample1(loc + vec3(0.0, 0.0, -step[2]));\\n\\t\\t\\t\\tval2 \\x3d sample1(loc + vec3(0.0, 0.0, +step[2]));\\n\\t\\t\\t\\tN[2] \\x3d val1 - val2;\\n\\t\\t\\t\\tval \\x3d max(max(val1, val2), val);\\n\\t\\t\\t\\tfloat gm \\x3d length(N); // gradient magnitude\\n\\t\\t\\t\\tN \\x3d normalize(N);\\n\\t\\t\\t\\tfloat Nselect \\x3d float(dot(N, V) \\x3e 0.0);\\n\\t\\t\\t\\tN \\x3d (2.0 * Nselect - 1.0) * N;\\t// \\x3d\\x3d\\tNselect * N - (1.0-Nselect)*N;\\n\\t\\t\\t\\tvec4 ambient_color \\x3d vec4(0.0, 0.0, 0.0, 0.0);\\n\\t\\t\\t\\tvec4 diffuse_color \\x3d vec4(0.0, 0.0, 0.0, 0.0);\\n\\t\\t\\t\\tvec4 specular_color \\x3d vec4(0.0, 0.0, 0.0, 0.0);\\n\\t\\t\\t\\tfor (int i\\x3d0; i\\x3c1; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvec3 L \\x3d normalize(view_ray);\\t//lightDirs[i];\\n\\t\\t\\t\\t\\t\\tfloat lightEnabled \\x3d float( length(L) \\x3e 0.0 );\\n\\t\\t\\t\\t\\t\\tL \\x3d normalize(L + (1.0 - lightEnabled));\\n\\t\\t\\t\\t\\t\\tfloat lambertTerm \\x3d clamp(dot(N, L), 0.0, 1.0);\\n\\t\\t\\t\\t\\t\\tvec3 H \\x3d normalize(L+V); // Halfway vector\\n\\t\\t\\t\\t\\t\\tfloat specularTerm \\x3d pow(max(dot(H, N), 0.0), shininess);\\n\\t\\t\\t\\t\\t\\tfloat mask1 \\x3d lightEnabled;\\n\\t\\t\\t\\t\\t\\tambient_color +\\x3d\\tmask1 * ambient_color;\\t// * gl_LightSource[i].ambient;\\n\\t\\t\\t\\t\\t\\tdiffuse_color +\\x3d\\tmask1 * lambertTerm;\\n\\t\\t\\t\\t\\t\\tspecular_color +\\x3d mask1 * specularTerm * specular_color;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvec4 final_color;\\n\\t\\t\\t\\tvec4 color \\x3d apply_colormap(val);\\n\\t\\t\\t\\tfinal_color \\x3d color * (ambient_color + diffuse_color) + specular_color;\\n\\t\\t\\t\\tfinal_color.a \\x3d color.a;\\n\\t\\t\\t\\treturn final_color;\\n\\t\\t}\"};\nexports.VolumeRenderShader1=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$VolumeShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VolumeRenderShader1 = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Shaders to render 3D volumes using raycasting.\n * The applied techniques are based on similar implementations in the Visvis and Vispy projects.\n * This is not the only approach, therefore it's marked 1.\n */\nvar VolumeRenderShader1 = {\n  uniforms: {\n    u_size: {\n      value: new _three.Vector3(1, 1, 1)\n    },\n    u_renderstyle: {\n      value: 0\n    },\n    u_renderthreshold: {\n      value: 0.5\n    },\n    u_clim: {\n      value: new _three.Vector2(1, 1)\n    },\n    u_data: {\n      value: null\n    },\n    u_cmdata: {\n      value: null\n    }\n  },\n  vertexShader: ['\t\tvarying vec4 v_nearpos;', '\t\tvarying vec4 v_farpos;', '\t\tvarying vec3 v_position;', '\t\tvoid main() {', // Prepare transforms to map to \"camera view\". See also:\n  // https://threejs.org/docs/#api/renderers/webgl/WebGLProgram\n  '\t\t\t\tmat4 viewtransformf = modelViewMatrix;', '\t\t\t\tmat4 viewtransformi = inverse(modelViewMatrix);', // Project local vertex coordinate to camera position. Then do a step\n  // backward (in cam coords) to the near clipping plane, and project back. Do\n  // the same for the far clipping plane. This gives us all the information we\n  // need to calculate the ray and truncate it to the viewing cone.\n  '\t\t\t\tvec4 position4 = vec4(position, 1.0);', '\t\t\t\tvec4 pos_in_cam = viewtransformf * position4;', // Intersection of ray and near clipping plane (z = -1 in clip coords)\n  '\t\t\t\tpos_in_cam.z = -pos_in_cam.w;', '\t\t\t\tv_nearpos = viewtransformi * pos_in_cam;', // Intersection of ray and far clipping plane (z = +1 in clip coords)\n  '\t\t\t\tpos_in_cam.z = pos_in_cam.w;', '\t\t\t\tv_farpos = viewtransformi * pos_in_cam;', // Set varyings and output pos\n  '\t\t\t\tv_position = position;', '\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;', '\t\t}'].join('\\n'),\n  fragmentShader: ['\t\tprecision highp float;', '\t\tprecision mediump sampler3D;', '\t\tuniform vec3 u_size;', '\t\tuniform int u_renderstyle;', '\t\tuniform float u_renderthreshold;', '\t\tuniform vec2 u_clim;', '\t\tuniform sampler3D u_data;', '\t\tuniform sampler2D u_cmdata;', '\t\tvarying vec3 v_position;', '\t\tvarying vec4 v_nearpos;', '\t\tvarying vec4 v_farpos;', // The maximum distance through our rendering volume is sqrt(3).\n  '\t\tconst int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3', '\t\tconst int REFINEMENT_STEPS = 4;', '\t\tconst float relative_step_size = 1.0;', '\t\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);', '\t\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);', '\t\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);', '\t\tconst float shininess = 40.0;', '\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);', '\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);', '\t\tfloat sample1(vec3 texcoords);', '\t\tvec4 apply_colormap(float val);', '\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);', '\t\tvoid main() {', // Normalize clipping plane info\n  '\t\t\t\tvec3 farpos = v_farpos.xyz / v_farpos.w;', '\t\t\t\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;', // Calculate unit vector pointing in the view direction through this fragment.\n  '\t\t\t\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);', // Compute the (negative) distance to the front surface or near clipping plane.\n  // v_position is the back face of the cuboid, so the initial distance calculated in the dot\n  // product below is the distance from near clip plane to the back of the cuboid\n  '\t\t\t\tfloat distance = dot(nearpos - v_position, view_ray);', '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.x - 0.5 - v_position.x) / view_ray.x));', '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.y - 0.5 - v_position.y) / view_ray.y));', '\t\t\t\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,', '\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.z - 0.5 - v_position.z) / view_ray.z));', // Now we have the starting position on the front surface\n  '\t\t\t\tvec3 front = v_position + view_ray * distance;', // Decide how many steps to take\n  '\t\t\t\tint nsteps = int(-distance / relative_step_size + 0.5);', '\t\t\t\tif ( nsteps < 1 )', '\t\t\t\t\t\tdiscard;', // Get starting location and step vector in texture coordinates\n  '\t\t\t\tvec3 step = ((v_position - front) / u_size) / float(nsteps);', '\t\t\t\tvec3 start_loc = front / u_size;', // For testing: show the number of steps. This helps to establish\n  // whether the rays are correctly oriented\n  //'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);',\n  //'return;',\n  '\t\t\t\tif (u_renderstyle == 0)', '\t\t\t\t\t\tcast_mip(start_loc, step, nsteps, view_ray);', '\t\t\t\telse if (u_renderstyle == 1)', '\t\t\t\t\t\tcast_iso(start_loc, step, nsteps, view_ray);', '\t\t\t\tif (gl_FragColor.a < 0.05)', '\t\t\t\t\t\tdiscard;', '\t\t}', '\t\tfloat sample1(vec3 texcoords) {', '\t\t\t\t/* Sample float value from a 3D texture. Assumes intensity data. */', '\t\t\t\treturn texture(u_data, texcoords.xyz).r;', '\t\t}', '\t\tvec4 apply_colormap(float val) {', '\t\t\t\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);', '\t\t\t\treturn texture2D(u_cmdata, vec2(val, 0.5));', '\t\t}', '\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {', '\t\t\t\tfloat max_val = -1e6;', '\t\t\t\tint max_i = 100;', '\t\t\t\tvec3 loc = start_loc;', // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n  // non-constant expression. So we use a hard-coded max, and an additional condition\n  // inside the loop.\n  '\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {', '\t\t\t\t\t\tif (iter >= nsteps)', '\t\t\t\t\t\t\t\tbreak;', // Sample from the 3D texture\n  '\t\t\t\t\t\tfloat val = sample1(loc);', // Apply MIP operation\n  '\t\t\t\t\t\tif (val > max_val) {', '\t\t\t\t\t\t\t\tmax_val = val;', '\t\t\t\t\t\t\t\tmax_i = iter;', '\t\t\t\t\t\t}', // Advance location deeper into the volume\n  '\t\t\t\t\t\tloc += step;', '\t\t\t\t}', // Refine location, gives crispier images\n  '\t\t\t\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);', '\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);', '\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {', '\t\t\t\t\t\tmax_val = max(max_val, sample1(iloc));', '\t\t\t\t\t\tiloc += istep;', '\t\t\t\t}', // Resolve final color\n  '\t\t\t\tgl_FragColor = apply_colormap(max_val);', '\t\t}', '\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {', '\t\t\t\tgl_FragColor = vec4(0.0);\t// init transparent', '\t\t\t\tvec4 color3 = vec4(0.0);\t// final color', '\t\t\t\tvec3 dstep = 1.5 / u_size;\t// step to sample derivative', '\t\t\t\tvec3 loc = start_loc;', '\t\t\t\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);', // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n  // non-constant expression. So we use a hard-coded max, and an additional condition\n  // inside the loop.\n  '\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {', '\t\t\t\t\t\tif (iter >= nsteps)', '\t\t\t\t\t\t\t\tbreak;', // Sample from the 3D texture\n  '\t\t\t\t\t\tfloat val = sample1(loc);', '\t\t\t\t\t\tif (val > low_threshold) {', // Take the last interval in smaller steps\n  '\t\t\t\t\t\t\t\tvec3 iloc = loc - 0.5 * step;', '\t\t\t\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);', '\t\t\t\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {', '\t\t\t\t\t\t\t\t\t\tval = sample1(iloc);', '\t\t\t\t\t\t\t\t\t\tif (val > u_renderthreshold) {', '\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);', '\t\t\t\t\t\t\t\t\t\t\t\treturn;', '\t\t\t\t\t\t\t\t\t\t}', '\t\t\t\t\t\t\t\t\t\tiloc += istep;', '\t\t\t\t\t\t\t\t}', '\t\t\t\t\t\t}', // Advance location deeper into the volume\n  '\t\t\t\t\t\tloc += step;', '\t\t\t\t}', '\t\t}', '\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)', '\t\t{', // Calculate color by incorporating lighting\n  // View direction\n  '\t\t\t\tvec3 V = normalize(view_ray);', // calculate normal vector from gradient\n  '\t\t\t\tvec3 N;', '\t\t\t\tfloat val1, val2;', '\t\t\t\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));', '\t\t\t\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));', '\t\t\t\tN[0] = val1 - val2;', '\t\t\t\tval = max(max(val1, val2), val);', '\t\t\t\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));', '\t\t\t\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));', '\t\t\t\tN[1] = val1 - val2;', '\t\t\t\tval = max(max(val1, val2), val);', '\t\t\t\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));', '\t\t\t\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));', '\t\t\t\tN[2] = val1 - val2;', '\t\t\t\tval = max(max(val1, val2), val);', '\t\t\t\tfloat gm = length(N); // gradient magnitude', '\t\t\t\tN = normalize(N);', // Flip normal so it points towards viewer\n  '\t\t\t\tfloat Nselect = float(dot(N, V) > 0.0);', '\t\t\t\tN = (2.0 * Nselect - 1.0) * N;\t// ==\tNselect * N - (1.0-Nselect)*N;', // Init colors\n  '\t\t\t\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);', '\t\t\t\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);', '\t\t\t\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);', // note: could allow multiple lights\n  '\t\t\t\tfor (int i=0; i<1; i++)', '\t\t\t\t{', // Get light direction (make sure to prevent zero devision)\n  '\t\t\t\t\t\tvec3 L = normalize(view_ray);\t//lightDirs[i];', '\t\t\t\t\t\tfloat lightEnabled = float( length(L) > 0.0 );', '\t\t\t\t\t\tL = normalize(L + (1.0 - lightEnabled));', // Calculate lighting properties\n  '\t\t\t\t\t\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);', '\t\t\t\t\t\tvec3 H = normalize(L+V); // Halfway vector', '\t\t\t\t\t\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);', // Calculate mask\n  '\t\t\t\t\t\tfloat mask1 = lightEnabled;', // Calculate colors\n  '\t\t\t\t\t\tambient_color +=\tmask1 * ambient_color;\t// * gl_LightSource[i].ambient;', '\t\t\t\t\t\tdiffuse_color +=\tmask1 * lambertTerm;', '\t\t\t\t\t\tspecular_color += mask1 * specularTerm * specular_color;', '\t\t\t\t}', // Calculate final color by componing different components\n  '\t\t\t\tvec4 final_color;', '\t\t\t\tvec4 color = apply_colormap(val);', '\t\t\t\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;', '\t\t\t\tfinal_color.a = color.a;', '\t\t\t\treturn final_color;', '\t\t}'].join('\\n')\n};\nexports.VolumeRenderShader1 = VolumeRenderShader1;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","u_renderstyle","VolumeRenderShader1","u_size","u_data","__esModule","u_renderthreshold","vertexShader","value","u_cmdata","uniforms","u_clim"]],"~:compiled-at",1630917515588,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$VolumeShader.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,qDAAA,CAA0E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGlHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,mBAAR,CAA8B,IAAK,EAE/BC,OAAAA,CAASP,OAAA,CAAQ,8CAAR,CAOTM,OAAAA,CAAsB,CACxBE,SAAU,CACRC,OAAQ,CACNJ,MAAO,IAAIE,MAAOG,CAAAA,OAAX,CAAmB,CAAnB,CAAsB,CAAtB,CAAyB,CAAzB,CADD,CADA,CAIRC,cAAe,CACbN,MAAO,CADM,CAJP,CAORO,kBAAmB,CACjBP,MAAO,EADU,CAPX,CAURQ,OAAQ,CACNR,MAAO,IAAIE,MAAOO,CAAAA,OAAX,CAAmB,CAAnB,CAAsB,CAAtB,CADD,CAVA,CAaRC,OAAQ,CACNV,MAAO,IADD,CAbA,CAgBRW,SAAU,CACRX,MAAO,IADC,CAhBF,CADc,CAqBxBY,aAS4G,8nBA9BpF;AA+BxBC,eAsC4M,uiNArEpL,CAuE1BhB;OAAQI,CAAAA,mBAAR,CAA8BA,MAtFoF;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/VolumeShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$VolumeShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.VolumeRenderShader1 = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Shaders to render 3D volumes using raycasting.\\n * The applied techniques are based on similar implementations in the Visvis and Vispy projects.\\n * This is not the only approach, therefore it's marked 1.\\n */\\nvar VolumeRenderShader1 = {\\n  uniforms: {\\n    u_size: {\\n      value: new _three.Vector3(1, 1, 1)\\n    },\\n    u_renderstyle: {\\n      value: 0\\n    },\\n    u_renderthreshold: {\\n      value: 0.5\\n    },\\n    u_clim: {\\n      value: new _three.Vector2(1, 1)\\n    },\\n    u_data: {\\n      value: null\\n    },\\n    u_cmdata: {\\n      value: null\\n    }\\n  },\\n  vertexShader: ['\\t\\tvarying vec4 v_nearpos;', '\\t\\tvarying vec4 v_farpos;', '\\t\\tvarying vec3 v_position;', '\\t\\tvoid main() {', // Prepare transforms to map to \\\"camera view\\\". See also:\\n  // https://threejs.org/docs/#api/renderers/webgl/WebGLProgram\\n  '\\t\\t\\t\\tmat4 viewtransformf = modelViewMatrix;', '\\t\\t\\t\\tmat4 viewtransformi = inverse(modelViewMatrix);', // Project local vertex coordinate to camera position. Then do a step\\n  // backward (in cam coords) to the near clipping plane, and project back. Do\\n  // the same for the far clipping plane. This gives us all the information we\\n  // need to calculate the ray and truncate it to the viewing cone.\\n  '\\t\\t\\t\\tvec4 position4 = vec4(position, 1.0);', '\\t\\t\\t\\tvec4 pos_in_cam = viewtransformf * position4;', // Intersection of ray and near clipping plane (z = -1 in clip coords)\\n  '\\t\\t\\t\\tpos_in_cam.z = -pos_in_cam.w;', '\\t\\t\\t\\tv_nearpos = viewtransformi * pos_in_cam;', // Intersection of ray and far clipping plane (z = +1 in clip coords)\\n  '\\t\\t\\t\\tpos_in_cam.z = pos_in_cam.w;', '\\t\\t\\t\\tv_farpos = viewtransformi * pos_in_cam;', // Set varyings and output pos\\n  '\\t\\t\\t\\tv_position = position;', '\\t\\t\\t\\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;', '\\t\\t}'].join('\\\\n'),\\n  fragmentShader: ['\\t\\tprecision highp float;', '\\t\\tprecision mediump sampler3D;', '\\t\\tuniform vec3 u_size;', '\\t\\tuniform int u_renderstyle;', '\\t\\tuniform float u_renderthreshold;', '\\t\\tuniform vec2 u_clim;', '\\t\\tuniform sampler3D u_data;', '\\t\\tuniform sampler2D u_cmdata;', '\\t\\tvarying vec3 v_position;', '\\t\\tvarying vec4 v_nearpos;', '\\t\\tvarying vec4 v_farpos;', // The maximum distance through our rendering volume is sqrt(3).\\n  '\\t\\tconst int MAX_STEPS = 887;\\t// 887 for 512^3, 1774 for 1024^3', '\\t\\tconst int REFINEMENT_STEPS = 4;', '\\t\\tconst float relative_step_size = 1.0;', '\\t\\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);', '\\t\\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);', '\\t\\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);', '\\t\\tconst float shininess = 40.0;', '\\t\\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);', '\\t\\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);', '\\t\\tfloat sample1(vec3 texcoords);', '\\t\\tvec4 apply_colormap(float val);', '\\t\\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);', '\\t\\tvoid main() {', // Normalize clipping plane info\\n  '\\t\\t\\t\\tvec3 farpos = v_farpos.xyz / v_farpos.w;', '\\t\\t\\t\\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;', // Calculate unit vector pointing in the view direction through this fragment.\\n  '\\t\\t\\t\\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);', // Compute the (negative) distance to the front surface or near clipping plane.\\n  // v_position is the back face of the cuboid, so the initial distance calculated in the dot\\n  // product below is the distance from near clip plane to the back of the cuboid\\n  '\\t\\t\\t\\tfloat distance = dot(nearpos - v_position, view_ray);', '\\t\\t\\t\\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.x - 0.5 - v_position.x) / view_ray.x));', '\\t\\t\\t\\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.y - 0.5 - v_position.y) / view_ray.y));', '\\t\\t\\t\\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.z - 0.5 - v_position.z) / view_ray.z));', // Now we have the starting position on the front surface\\n  '\\t\\t\\t\\tvec3 front = v_position + view_ray * distance;', // Decide how many steps to take\\n  '\\t\\t\\t\\tint nsteps = int(-distance / relative_step_size + 0.5);', '\\t\\t\\t\\tif ( nsteps < 1 )', '\\t\\t\\t\\t\\t\\tdiscard;', // Get starting location and step vector in texture coordinates\\n  '\\t\\t\\t\\tvec3 step = ((v_position - front) / u_size) / float(nsteps);', '\\t\\t\\t\\tvec3 start_loc = front / u_size;', // For testing: show the number of steps. This helps to establish\\n  // whether the rays are correctly oriented\\n  //'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);',\\n  //'return;',\\n  '\\t\\t\\t\\tif (u_renderstyle == 0)', '\\t\\t\\t\\t\\t\\tcast_mip(start_loc, step, nsteps, view_ray);', '\\t\\t\\t\\telse if (u_renderstyle == 1)', '\\t\\t\\t\\t\\t\\tcast_iso(start_loc, step, nsteps, view_ray);', '\\t\\t\\t\\tif (gl_FragColor.a < 0.05)', '\\t\\t\\t\\t\\t\\tdiscard;', '\\t\\t}', '\\t\\tfloat sample1(vec3 texcoords) {', '\\t\\t\\t\\t/* Sample float value from a 3D texture. Assumes intensity data. */', '\\t\\t\\t\\treturn texture(u_data, texcoords.xyz).r;', '\\t\\t}', '\\t\\tvec4 apply_colormap(float val) {', '\\t\\t\\t\\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);', '\\t\\t\\t\\treturn texture2D(u_cmdata, vec2(val, 0.5));', '\\t\\t}', '\\t\\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {', '\\t\\t\\t\\tfloat max_val = -1e6;', '\\t\\t\\t\\tint max_i = 100;', '\\t\\t\\t\\tvec3 loc = start_loc;', // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\\n  // non-constant expression. So we use a hard-coded max, and an additional condition\\n  // inside the loop.\\n  '\\t\\t\\t\\tfor (int iter=0; iter<MAX_STEPS; iter++) {', '\\t\\t\\t\\t\\t\\tif (iter >= nsteps)', '\\t\\t\\t\\t\\t\\t\\t\\tbreak;', // Sample from the 3D texture\\n  '\\t\\t\\t\\t\\t\\tfloat val = sample1(loc);', // Apply MIP operation\\n  '\\t\\t\\t\\t\\t\\tif (val > max_val) {', '\\t\\t\\t\\t\\t\\t\\t\\tmax_val = val;', '\\t\\t\\t\\t\\t\\t\\t\\tmax_i = iter;', '\\t\\t\\t\\t\\t\\t}', // Advance location deeper into the volume\\n  '\\t\\t\\t\\t\\t\\tloc += step;', '\\t\\t\\t\\t}', // Refine location, gives crispier images\\n  '\\t\\t\\t\\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);', '\\t\\t\\t\\tvec3 istep = step / float(REFINEMENT_STEPS);', '\\t\\t\\t\\tfor (int i=0; i<REFINEMENT_STEPS; i++) {', '\\t\\t\\t\\t\\t\\tmax_val = max(max_val, sample1(iloc));', '\\t\\t\\t\\t\\t\\tiloc += istep;', '\\t\\t\\t\\t}', // Resolve final color\\n  '\\t\\t\\t\\tgl_FragColor = apply_colormap(max_val);', '\\t\\t}', '\\t\\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {', '\\t\\t\\t\\tgl_FragColor = vec4(0.0);\\t// init transparent', '\\t\\t\\t\\tvec4 color3 = vec4(0.0);\\t// final color', '\\t\\t\\t\\tvec3 dstep = 1.5 / u_size;\\t// step to sample derivative', '\\t\\t\\t\\tvec3 loc = start_loc;', '\\t\\t\\t\\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);', // Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\\n  // non-constant expression. So we use a hard-coded max, and an additional condition\\n  // inside the loop.\\n  '\\t\\t\\t\\tfor (int iter=0; iter<MAX_STEPS; iter++) {', '\\t\\t\\t\\t\\t\\tif (iter >= nsteps)', '\\t\\t\\t\\t\\t\\t\\t\\tbreak;', // Sample from the 3D texture\\n  '\\t\\t\\t\\t\\t\\tfloat val = sample1(loc);', '\\t\\t\\t\\t\\t\\tif (val > low_threshold) {', // Take the last interval in smaller steps\\n  '\\t\\t\\t\\t\\t\\t\\t\\tvec3 iloc = loc - 0.5 * step;', '\\t\\t\\t\\t\\t\\t\\t\\tvec3 istep = step / float(REFINEMENT_STEPS);', '\\t\\t\\t\\t\\t\\t\\t\\tfor (int i=0; i<REFINEMENT_STEPS; i++) {', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tval = sample1(iloc);', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (val > u_renderthreshold) {', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}', '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tiloc += istep;', '\\t\\t\\t\\t\\t\\t\\t\\t}', '\\t\\t\\t\\t\\t\\t}', // Advance location deeper into the volume\\n  '\\t\\t\\t\\t\\t\\tloc += step;', '\\t\\t\\t\\t}', '\\t\\t}', '\\t\\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)', '\\t\\t{', // Calculate color by incorporating lighting\\n  // View direction\\n  '\\t\\t\\t\\tvec3 V = normalize(view_ray);', // calculate normal vector from gradient\\n  '\\t\\t\\t\\tvec3 N;', '\\t\\t\\t\\tfloat val1, val2;', '\\t\\t\\t\\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));', '\\t\\t\\t\\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));', '\\t\\t\\t\\tN[0] = val1 - val2;', '\\t\\t\\t\\tval = max(max(val1, val2), val);', '\\t\\t\\t\\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));', '\\t\\t\\t\\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));', '\\t\\t\\t\\tN[1] = val1 - val2;', '\\t\\t\\t\\tval = max(max(val1, val2), val);', '\\t\\t\\t\\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));', '\\t\\t\\t\\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));', '\\t\\t\\t\\tN[2] = val1 - val2;', '\\t\\t\\t\\tval = max(max(val1, val2), val);', '\\t\\t\\t\\tfloat gm = length(N); // gradient magnitude', '\\t\\t\\t\\tN = normalize(N);', // Flip normal so it points towards viewer\\n  '\\t\\t\\t\\tfloat Nselect = float(dot(N, V) > 0.0);', '\\t\\t\\t\\tN = (2.0 * Nselect - 1.0) * N;\\t// ==\\tNselect * N - (1.0-Nselect)*N;', // Init colors\\n  '\\t\\t\\t\\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);', '\\t\\t\\t\\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);', '\\t\\t\\t\\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);', // note: could allow multiple lights\\n  '\\t\\t\\t\\tfor (int i=0; i<1; i++)', '\\t\\t\\t\\t{', // Get light direction (make sure to prevent zero devision)\\n  '\\t\\t\\t\\t\\t\\tvec3 L = normalize(view_ray);\\t//lightDirs[i];', '\\t\\t\\t\\t\\t\\tfloat lightEnabled = float( length(L) > 0.0 );', '\\t\\t\\t\\t\\t\\tL = normalize(L + (1.0 - lightEnabled));', // Calculate lighting properties\\n  '\\t\\t\\t\\t\\t\\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);', '\\t\\t\\t\\t\\t\\tvec3 H = normalize(L+V); // Halfway vector', '\\t\\t\\t\\t\\t\\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);', // Calculate mask\\n  '\\t\\t\\t\\t\\t\\tfloat mask1 = lightEnabled;', // Calculate colors\\n  '\\t\\t\\t\\t\\t\\tambient_color +=\\tmask1 * ambient_color;\\t// * gl_LightSource[i].ambient;', '\\t\\t\\t\\t\\t\\tdiffuse_color +=\\tmask1 * lambertTerm;', '\\t\\t\\t\\t\\t\\tspecular_color += mask1 * specularTerm * specular_color;', '\\t\\t\\t\\t}', // Calculate final color by componing different components\\n  '\\t\\t\\t\\tvec4 final_color;', '\\t\\t\\t\\tvec4 color = apply_colormap(val);', '\\t\\t\\t\\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;', '\\t\\t\\t\\tfinal_color.a = color.a;', '\\t\\t\\t\\treturn final_color;', '\\t\\t}'].join('\\\\n')\\n};\\nexports.VolumeRenderShader1 = VolumeRenderShader1;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"VolumeRenderShader1\",\"_three\",\"uniforms\",\"u_size\",\"Vector3\",\"u_renderstyle\",\"u_renderthreshold\",\"u_clim\",\"Vector2\",\"u_data\",\"u_cmdata\",\"vertexShader\",\"fragmentShader\"]\n}\n"]