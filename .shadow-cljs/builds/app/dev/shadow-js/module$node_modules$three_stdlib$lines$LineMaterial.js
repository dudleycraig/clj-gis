["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/lines/LineMaterial.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$lines$LineMaterial=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _possibleConstructorReturn(self,call){return!call||\"object\"!==_typeof(call)&&\"function\"!==typeof call?\n_assertThisInitialized(self):call}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");\nsubClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.LineMaterial=void 0;var _defineProperty2=function(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}(require(\"module$node_modules$$babel$runtime$helpers$esm$defineProperty\")),\n_three=require(\"module$node_modules$three$build$three_module\");global={linewidth:{value:1},resolution:{value:new _three.Vector2(1,1)},dashScale:{value:1},dashSize:{value:1},dashOffset:{value:0},gapSize:{value:1},opacity:{value:1}};_three.ShaderLib.line={uniforms:_three.UniformsUtils.merge([_three.UniformsLib.common,_three.UniformsLib.fog,global]),vertexShader:\"\\n\\t\\t#include \\x3ccommon\\x3e\\n\\t\\t#include \\x3ccolor_pars_vertex\\x3e\\n\\t\\t#include \\x3cfog_pars_vertex\\x3e\\n\\t\\t#include \\x3clogdepthbuf_pars_vertex\\x3e\\n\\t\\t#include \\x3cclipping_planes_pars_vertex\\x3e\\n\\n\\t\\tuniform float linewidth;\\n\\t\\tuniform vec2 resolution;\\n\\n\\t\\tattribute vec3 instanceStart;\\n\\t\\tattribute vec3 instanceEnd;\\n\\n\\t\\tattribute vec3 instanceColorStart;\\n\\t\\tattribute vec3 instanceColorEnd;\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\tuniform float dashScale;\\n\\t\\t\\tattribute float instanceDistanceStart;\\n\\t\\t\\tattribute float instanceDistanceEnd;\\n\\t\\t\\tvarying float vLineDistance;\\n\\n\\t\\t#endif\\n\\n\\t\\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\\n\\n\\t\\t\\t// trim end segment so it terminates between the camera plane and the near plane\\n\\n\\t\\t\\t// conservative estimate of the near plane\\n\\t\\t\\tfloat a \\x3d projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\\n\\t\\t\\tfloat b \\x3d projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\\n\\t\\t\\tfloat nearEstimate \\x3d - 0.5 * b / a;\\n\\n\\t\\t\\tfloat alpha \\x3d ( nearEstimate - start.z ) / ( end.z - start.z );\\n\\n\\t\\t\\tend.xyz \\x3d mix( start.xyz, end.xyz, alpha );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#ifdef USE_COLOR\\n\\n\\t\\t\\t\\tvColor.xyz \\x3d ( position.y \\x3c 0.5 ) ? instanceColorStart : instanceColorEnd;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\t\\tvLineDistance \\x3d ( position.y \\x3c 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat aspect \\x3d resolution.x / resolution.y;\\n\\n\\t\\t\\tvUv \\x3d uv;\\n\\n\\t\\t\\t// camera space\\n\\t\\t\\tvec4 start \\x3d modelViewMatrix * vec4( instanceStart, 1.0 );\\n\\t\\t\\tvec4 end \\x3d modelViewMatrix * vec4( instanceEnd, 1.0 );\\n\\n\\t\\t\\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\\n\\t\\t\\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\\n\\t\\t\\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\\n\\t\\t\\t// perhaps there is a more elegant solution -- WestLangley\\n\\n\\t\\t\\tbool perspective \\x3d ( projectionMatrix[ 2 ][ 3 ] \\x3d\\x3d - 1.0 ); // 4th entry in the 3rd column\\n\\n\\t\\t\\tif ( perspective ) {\\n\\n\\t\\t\\t\\tif ( start.z \\x3c 0.0 \\x26\\x26 end.z \\x3e\\x3d 0.0 ) {\\n\\n\\t\\t\\t\\t\\ttrimSegment( start, end );\\n\\n\\t\\t\\t\\t} else if ( end.z \\x3c 0.0 \\x26\\x26 start.z \\x3e\\x3d 0.0 ) {\\n\\n\\t\\t\\t\\t\\ttrimSegment( end, start );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// clip space\\n\\t\\t\\tvec4 clipStart \\x3d projectionMatrix * start;\\n\\t\\t\\tvec4 clipEnd \\x3d projectionMatrix * end;\\n\\n\\t\\t\\t// ndc space\\n\\t\\t\\tvec2 ndcStart \\x3d clipStart.xy / clipStart.w;\\n\\t\\t\\tvec2 ndcEnd \\x3d clipEnd.xy / clipEnd.w;\\n\\n\\t\\t\\t// direction\\n\\t\\t\\tvec2 dir \\x3d ndcEnd - ndcStart;\\n\\n\\t\\t\\t// account for clip-space aspect ratio\\n\\t\\t\\tdir.x *\\x3d aspect;\\n\\t\\t\\tdir \\x3d normalize( dir );\\n\\n\\t\\t\\t// perpendicular to dir\\n\\t\\t\\tvec2 offset \\x3d vec2( dir.y, - dir.x );\\n\\n\\t\\t\\t// undo aspect ratio adjustment\\n\\t\\t\\tdir.x /\\x3d aspect;\\n\\t\\t\\toffset.x /\\x3d aspect;\\n\\n\\t\\t\\t// sign flip\\n\\t\\t\\tif ( position.x \\x3c 0.0 ) offset *\\x3d - 1.0;\\n\\n\\t\\t\\t// endcaps\\n\\t\\t\\tif ( position.y \\x3c 0.0 ) {\\n\\n\\t\\t\\t\\toffset +\\x3d - dir;\\n\\n\\t\\t\\t} else if ( position.y \\x3e 1.0 ) {\\n\\n\\t\\t\\t\\toffset +\\x3d dir;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// adjust for linewidth\\n\\t\\t\\toffset *\\x3d linewidth;\\n\\n\\t\\t\\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\\n\\t\\t\\toffset /\\x3d resolution.y;\\n\\n\\t\\t\\t// select end\\n\\t\\t\\tvec4 clip \\x3d ( position.y \\x3c 0.5 ) ? clipStart : clipEnd;\\n\\n\\t\\t\\t// back to clip space\\n\\t\\t\\toffset *\\x3d clip.w;\\n\\n\\t\\t\\tclip.xy +\\x3d offset;\\n\\n\\t\\t\\tgl_Position \\x3d clip;\\n\\n\\t\\t\\tvec4 mvPosition \\x3d ( position.y \\x3c 0.5 ) ? start : end; // this is an approximation\\n\\n\\t\\t\\t#include \\x3clogdepthbuf_vertex\\x3e\\n\\t\\t\\t#include \\x3cclipping_planes_vertex\\x3e\\n\\t\\t\\t#include \\x3cfog_vertex\\x3e\\n\\n\\t\\t}\\n\\t\\t\",\nfragmentShader:\"\\n\\t\\tuniform vec3 diffuse;\\n\\t\\tuniform float opacity;\\n\\n\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\tuniform float dashSize;\\n\\t\\t\\tuniform float dashOffset;\\n\\t\\t\\tuniform float gapSize;\\n\\n\\t\\t#endif\\n\\n\\t\\tvarying float vLineDistance;\\n\\n\\t\\t#include \\x3ccommon\\x3e\\n\\t\\t#include \\x3ccolor_pars_fragment\\x3e\\n\\t\\t#include \\x3cfog_pars_fragment\\x3e\\n\\t\\t#include \\x3clogdepthbuf_pars_fragment\\x3e\\n\\t\\t#include \\x3cclipping_planes_pars_fragment\\x3e\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include \\x3cclipping_planes_fragment\\x3e\\n\\n\\t\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\t\\tif ( vUv.y \\x3c - 1.0 || vUv.y \\x3e 1.0 ) discard; // discard endcaps\\n\\n\\t\\t\\t\\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) \\x3e dashSize ) discard; // todo - FIX\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat alpha \\x3d opacity;\\n\\n\\t\\t\\t#ifdef ALPHA_TO_COVERAGE\\n\\n\\t\\t\\t// artifacts appear on some hardware if a derivative is taken within a conditional\\n\\t\\t\\tfloat a \\x3d vUv.x;\\n\\t\\t\\tfloat b \\x3d ( vUv.y \\x3e 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\n\\t\\t\\tfloat len2 \\x3d a * a + b * b;\\n\\t\\t\\tfloat dlen \\x3d fwidth( len2 );\\n\\n\\t\\t\\tif ( abs( vUv.y ) \\x3e 1.0 ) {\\n\\n\\t\\t\\t\\talpha \\x3d 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t#else\\n\\n\\t\\t\\tif ( abs( vUv.y ) \\x3e 1.0 ) {\\n\\n\\t\\t\\t\\tfloat a \\x3d vUv.x;\\n\\t\\t\\t\\tfloat b \\x3d ( vUv.y \\x3e 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\n\\t\\t\\t\\tfloat len2 \\x3d a * a + b * b;\\n\\n\\t\\t\\t\\tif ( len2 \\x3e 1.0 ) discard;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tvec4 diffuseColor \\x3d vec4( diffuse, alpha );\\n\\n\\t\\t\\t#include \\x3clogdepthbuf_fragment\\x3e\\n\\t\\t\\t#include \\x3ccolor_fragment\\x3e\\n\\n\\t\\t\\tgl_FragColor \\x3d vec4( diffuseColor.rgb, alpha );\\n\\n\\t\\t\\t#include \\x3ctonemapping_fragment\\x3e\\n\\t\\t\\t#include \\x3cencodings_fragment\\x3e\\n\\t\\t\\t#include \\x3cfog_fragment\\x3e\\n\\t\\t\\t#include \\x3cpremultiplied_alpha_fragment\\x3e\\n\\n\\t\\t}\\n\\t\\t\"};\nglobal=function(_ShaderMaterial){function LineMaterial(){var parameters=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(!(this instanceof LineMaterial))throw new TypeError(\"Cannot call a class as a function\");var _this=_possibleConstructorReturn(this,_getPrototypeOf(LineMaterial).call(this,{uniforms:_three.UniformsUtils.clone(_three.ShaderLib.line.uniforms),vertexShader:_three.ShaderLib.line.vertexShader,fragmentShader:_three.ShaderLib.line.fragmentShader,clipping:!0}));(0,_defineProperty2[\"default\"])(_assertThisInitialized(_this),\n\"isLineMaterial\",!0);(0,_defineProperty2[\"default\"])(_assertThisInitialized(_this),\"dashed\",!1);(0,_defineProperty2[\"default\"])(_assertThisInitialized(_this),\"color\",new _three.Color(0));(0,_defineProperty2[\"default\"])(_assertThisInitialized(_this),\"lineWidth\",0);(0,_defineProperty2[\"default\"])(_assertThisInitialized(_this),\"dashScale\",0);(0,_defineProperty2[\"default\"])(_assertThisInitialized(_this),\"dashOffset\",0);(0,_defineProperty2[\"default\"])(_assertThisInitialized(_this),\"dashSize\",0);(0,_defineProperty2[\"default\"])(_assertThisInitialized(_this),\n\"opacity\",0);(0,_defineProperty2[\"default\"])(_assertThisInitialized(_this),\"resolution\",new _three.Vector2);(0,_defineProperty2[\"default\"])(_assertThisInitialized(_this),\"alphaToCoverage\",!1);Object.defineProperties(_assertThisInitialized(_this),{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(value){value=new _three.Color(value);this.uniforms.diffuse.value=value.getHex()}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(value){this.uniforms.linewidth.value=\nvalue}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(value){this.uniforms.dashScale.value=value}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(value){this.uniforms.dashSize.value=value}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(value){this.uniforms.dashOffset.value=value}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(value){this.uniforms.gapSize.value=\nvalue}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(value){this.uniforms.opacity.value=value}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(value){this.uniforms.resolution.value.copy(value)}},alphaToCoverage:{enumerable:!0,get:function(){return\"ALPHA_TO_COVERAGE\"in this.defines},set:function(value){!!value!==\"ALPHA_TO_COVERAGE\"in this.defines&&(this.needsUpdate=!0);value?(this.defines.ALPHA_TO_COVERAGE=\"\",this.extensions.derivatives=\n!0):(delete this.defines.ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}},dashed:{enumerable:!0,get:function(){return\"USE_DASH\"in this.defines},set:function(value){!!value!==\"USE_DASH\"in this.defines&&(this.needsUpdate=!0);value?this.defines.USE_DASH=\"\":delete this.defines.USE_DASH}}});_this.setValues(parameters);return _this}_inherits(LineMaterial,_ShaderMaterial);return LineMaterial}(_three.ShaderMaterial);exports.LineMaterial=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$lines$LineMaterial\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LineMaterial = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/esm/defineProperty\"));\n\nvar _three = require(\"three\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nvar LineUniforms = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new _three.Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\n_three.ShaderLib['line'] = {\n  uniforms: _three.UniformsUtils.merge([_three.UniformsLib.common, _three.UniformsLib.fog, LineUniforms]),\n  vertexShader:\n  /* glsl */\n  \"\\n\\t\\t#include <common>\\n\\t\\t#include <color_pars_vertex>\\n\\t\\t#include <fog_pars_vertex>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\t\\t#include <clipping_planes_pars_vertex>\\n\\n\\t\\tuniform float linewidth;\\n\\t\\tuniform vec2 resolution;\\n\\n\\t\\tattribute vec3 instanceStart;\\n\\t\\tattribute vec3 instanceEnd;\\n\\n\\t\\tattribute vec3 instanceColorStart;\\n\\t\\tattribute vec3 instanceColorEnd;\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\tuniform float dashScale;\\n\\t\\t\\tattribute float instanceDistanceStart;\\n\\t\\t\\tattribute float instanceDistanceEnd;\\n\\t\\t\\tvarying float vLineDistance;\\n\\n\\t\\t#endif\\n\\n\\t\\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\\n\\n\\t\\t\\t// trim end segment so it terminates between the camera plane and the near plane\\n\\n\\t\\t\\t// conservative estimate of the near plane\\n\\t\\t\\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\\n\\t\\t\\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\\n\\t\\t\\tfloat nearEstimate = - 0.5 * b / a;\\n\\n\\t\\t\\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\\n\\n\\t\\t\\tend.xyz = mix( start.xyz, end.xyz, alpha );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#ifdef USE_COLOR\\n\\n\\t\\t\\t\\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\t\\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat aspect = resolution.x / resolution.y;\\n\\n\\t\\t\\tvUv = uv;\\n\\n\\t\\t\\t// camera space\\n\\t\\t\\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\\n\\t\\t\\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\\n\\n\\t\\t\\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\\n\\t\\t\\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\\n\\t\\t\\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\\n\\t\\t\\t// perhaps there is a more elegant solution -- WestLangley\\n\\n\\t\\t\\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\\n\\n\\t\\t\\tif ( perspective ) {\\n\\n\\t\\t\\t\\tif ( start.z < 0.0 && end.z >= 0.0 ) {\\n\\n\\t\\t\\t\\t\\ttrimSegment( start, end );\\n\\n\\t\\t\\t\\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\\n\\n\\t\\t\\t\\t\\ttrimSegment( end, start );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// clip space\\n\\t\\t\\tvec4 clipStart = projectionMatrix * start;\\n\\t\\t\\tvec4 clipEnd = projectionMatrix * end;\\n\\n\\t\\t\\t// ndc space\\n\\t\\t\\tvec2 ndcStart = clipStart.xy / clipStart.w;\\n\\t\\t\\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\\n\\n\\t\\t\\t// direction\\n\\t\\t\\tvec2 dir = ndcEnd - ndcStart;\\n\\n\\t\\t\\t// account for clip-space aspect ratio\\n\\t\\t\\tdir.x *= aspect;\\n\\t\\t\\tdir = normalize( dir );\\n\\n\\t\\t\\t// perpendicular to dir\\n\\t\\t\\tvec2 offset = vec2( dir.y, - dir.x );\\n\\n\\t\\t\\t// undo aspect ratio adjustment\\n\\t\\t\\tdir.x /= aspect;\\n\\t\\t\\toffset.x /= aspect;\\n\\n\\t\\t\\t// sign flip\\n\\t\\t\\tif ( position.x < 0.0 ) offset *= - 1.0;\\n\\n\\t\\t\\t// endcaps\\n\\t\\t\\tif ( position.y < 0.0 ) {\\n\\n\\t\\t\\t\\toffset += - dir;\\n\\n\\t\\t\\t} else if ( position.y > 1.0 ) {\\n\\n\\t\\t\\t\\toffset += dir;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// adjust for linewidth\\n\\t\\t\\toffset *= linewidth;\\n\\n\\t\\t\\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\\n\\t\\t\\toffset /= resolution.y;\\n\\n\\t\\t\\t// select end\\n\\t\\t\\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\\n\\n\\t\\t\\t// back to clip space\\n\\t\\t\\toffset *= clip.w;\\n\\n\\t\\t\\tclip.xy += offset;\\n\\n\\t\\t\\tgl_Position = clip;\\n\\n\\t\\t\\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t#include <clipping_planes_vertex>\\n\\t\\t\\t#include <fog_vertex>\\n\\n\\t\\t}\\n\\t\\t\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\t\\tuniform vec3 diffuse;\\n\\t\\tuniform float opacity;\\n\\n\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\tuniform float dashSize;\\n\\t\\t\\tuniform float dashOffset;\\n\\t\\t\\tuniform float gapSize;\\n\\n\\t\\t#endif\\n\\n\\t\\tvarying float vLineDistance;\\n\\n\\t\\t#include <common>\\n\\t\\t#include <color_pars_fragment>\\n\\t\\t#include <fog_pars_fragment>\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\t\\t#include <clipping_planes_pars_fragment>\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <clipping_planes_fragment>\\n\\n\\t\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\t\\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\\n\\n\\t\\t\\t\\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat alpha = opacity;\\n\\n\\t\\t\\t#ifdef ALPHA_TO_COVERAGE\\n\\n\\t\\t\\t// artifacts appear on some hardware if a derivative is taken within a conditional\\n\\t\\t\\tfloat a = vUv.x;\\n\\t\\t\\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\n\\t\\t\\tfloat len2 = a * a + b * b;\\n\\t\\t\\tfloat dlen = fwidth( len2 );\\n\\n\\t\\t\\tif ( abs( vUv.y ) > 1.0 ) {\\n\\n\\t\\t\\t\\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t#else\\n\\n\\t\\t\\tif ( abs( vUv.y ) > 1.0 ) {\\n\\n\\t\\t\\t\\tfloat a = vUv.x;\\n\\t\\t\\t\\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\n\\t\\t\\t\\tfloat len2 = a * a + b * b;\\n\\n\\t\\t\\t\\tif ( len2 > 1.0 ) discard;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tvec4 diffuseColor = vec4( diffuse, alpha );\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\t\\t\\t#include <color_fragment>\\n\\n\\t\\t\\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <encodings_fragment>\\n\\t\\t\\t#include <fog_fragment>\\n\\t\\t\\t#include <premultiplied_alpha_fragment>\\n\\n\\t\\t}\\n\\t\\t\"\n};\n\nvar LineMaterial =\n/*#__PURE__*/\nfunction (_ShaderMaterial) {\n  _inherits(LineMaterial, _ShaderMaterial);\n\n  function LineMaterial() {\n    var _this;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LineMaterial);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineMaterial).call(this, {\n      uniforms: _three.UniformsUtils.clone(_three.ShaderLib['line'].uniforms),\n      vertexShader: _three.ShaderLib['line'].vertexShader,\n      fragmentShader: _three.ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    }));\n    /**\n     * Everytime I remove this, everything just breaks,\n     * so I'm just gonna leave it here.\n     */\n\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"isLineMaterial\", true);\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"dashed\", false);\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"color\", new _three.Color(0x000000));\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"lineWidth\", 0);\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"dashScale\", 0);\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"dashOffset\", 0);\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"dashSize\", 0);\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"opacity\", 0);\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"resolution\", new _three.Vector2());\n    (0, _defineProperty2[\"default\"])(_assertThisInitialized(_this), \"alphaToCoverage\", false);\n    Object.defineProperties(_assertThisInitialized(_this), {\n      color: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.diffuse.value;\n        },\n        set: function set(value) {\n          var colorObj = new _three.Color(value);\n          this.uniforms.diffuse.value = colorObj.getHex();\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.linewidth.value;\n        },\n        set: function set(value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashScale.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashSize.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.gapSize.value;\n        },\n        set: function set(value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.resolution.value;\n        },\n        set: function set(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function get() {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function set(value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function get() {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set: function set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      }\n    });\n\n    _this.setValues(parameters);\n\n    return _this;\n  }\n\n  return LineMaterial;\n}(_three.ShaderMaterial);\n\nexports.LineMaterial = LineMaterial;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$$babel$runtime$helpers$esm$defineProperty"]],"~:properties",["^5",["fragmentShader","dashed","needsUpdate","gapSize","prototype","ALPHA_TO_COVERAGE","__esModule","USE_DASH","dashSize","derivatives","vertexShader","configurable","LineMaterial","value","enumerable","writable","linewidth","clipping","dashScale","alphaToCoverage","__proto__","set","uniforms","dashOffset","get","color","opacity","constructor","resolution"]],"~:compiled-at",1630917515963,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$lines$LineMaterial.js\",\n\"lineCount\":11,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/lines/LineMaterial.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$lines$LineMaterial\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.LineMaterial = void 0;\\n\\nvar _defineProperty2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/esm/defineProperty\\\"));\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \\\"default\\\": obj }; }\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * parameters = {\\n *  color: <hex>,\\n *  linewidth: <float>,\\n *  dashed: <boolean>,\\n *  dashScale: <float>,\\n *  dashSize: <float>,\\n *  dashOffset: <float>,\\n *  gapSize: <float>,\\n *  resolution: <Vector2>, // to be set by renderer\\n * }\\n */\\nvar LineUniforms = {\\n  linewidth: {\\n    value: 1\\n  },\\n  resolution: {\\n    value: new _three.Vector2(1, 1)\\n  },\\n  dashScale: {\\n    value: 1\\n  },\\n  dashSize: {\\n    value: 1\\n  },\\n  dashOffset: {\\n    value: 0\\n  },\\n  gapSize: {\\n    value: 1\\n  },\\n  // todo FIX - maybe change to totalSize\\n  opacity: {\\n    value: 1\\n  }\\n};\\n_three.ShaderLib['line'] = {\\n  uniforms: _three.UniformsUtils.merge([_three.UniformsLib.common, _three.UniformsLib.fog, LineUniforms]),\\n  vertexShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\t\\\\t#include <common>\\\\n\\\\t\\\\t#include <color_pars_vertex>\\\\n\\\\t\\\\t#include <fog_pars_vertex>\\\\n\\\\t\\\\t#include <logdepthbuf_pars_vertex>\\\\n\\\\t\\\\t#include <clipping_planes_pars_vertex>\\\\n\\\\n\\\\t\\\\tuniform float linewidth;\\\\n\\\\t\\\\tuniform vec2 resolution;\\\\n\\\\n\\\\t\\\\tattribute vec3 instanceStart;\\\\n\\\\t\\\\tattribute vec3 instanceEnd;\\\\n\\\\n\\\\t\\\\tattribute vec3 instanceColorStart;\\\\n\\\\t\\\\tattribute vec3 instanceColorEnd;\\\\n\\\\n\\\\t\\\\tvarying vec2 vUv;\\\\n\\\\n\\\\t\\\\t#ifdef USE_DASH\\\\n\\\\n\\\\t\\\\t\\\\tuniform float dashScale;\\\\n\\\\t\\\\t\\\\tattribute float instanceDistanceStart;\\\\n\\\\t\\\\t\\\\tattribute float instanceDistanceEnd;\\\\n\\\\t\\\\t\\\\tvarying float vLineDistance;\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\\\\n\\\\n\\\\t\\\\t\\\\t// trim end segment so it terminates between the camera plane and the near plane\\\\n\\\\n\\\\t\\\\t\\\\t// conservative estimate of the near plane\\\\n\\\\t\\\\t\\\\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\\\\n\\\\t\\\\t\\\\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\\\\n\\\\t\\\\t\\\\tfloat nearEstimate = - 0.5 * b / a;\\\\n\\\\n\\\\t\\\\t\\\\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\\\\n\\\\n\\\\t\\\\t\\\\tend.xyz = mix( start.xyz, end.xyz, alpha );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef USE_COLOR\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef USE_DASH\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\tfloat aspect = resolution.x / resolution.y;\\\\n\\\\n\\\\t\\\\t\\\\tvUv = uv;\\\\n\\\\n\\\\t\\\\t\\\\t// camera space\\\\n\\\\t\\\\t\\\\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\\\\n\\\\t\\\\t\\\\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\\\\n\\\\n\\\\t\\\\t\\\\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\\\\n\\\\t\\\\t\\\\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\\\\n\\\\t\\\\t\\\\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\\\\n\\\\t\\\\t\\\\t// perhaps there is a more elegant solution -- WestLangley\\\\n\\\\n\\\\t\\\\t\\\\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\\\\n\\\\n\\\\t\\\\t\\\\tif ( perspective ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tif ( start.z < 0.0 && end.z >= 0.0 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\ttrimSegment( start, end );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\ttrimSegment( end, start );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// clip space\\\\n\\\\t\\\\t\\\\tvec4 clipStart = projectionMatrix * start;\\\\n\\\\t\\\\t\\\\tvec4 clipEnd = projectionMatrix * end;\\\\n\\\\n\\\\t\\\\t\\\\t// ndc space\\\\n\\\\t\\\\t\\\\tvec2 ndcStart = clipStart.xy / clipStart.w;\\\\n\\\\t\\\\t\\\\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\\\\n\\\\n\\\\t\\\\t\\\\t// direction\\\\n\\\\t\\\\t\\\\tvec2 dir = ndcEnd - ndcStart;\\\\n\\\\n\\\\t\\\\t\\\\t// account for clip-space aspect ratio\\\\n\\\\t\\\\t\\\\tdir.x *= aspect;\\\\n\\\\t\\\\t\\\\tdir = normalize( dir );\\\\n\\\\n\\\\t\\\\t\\\\t// perpendicular to dir\\\\n\\\\t\\\\t\\\\tvec2 offset = vec2( dir.y, - dir.x );\\\\n\\\\n\\\\t\\\\t\\\\t// undo aspect ratio adjustment\\\\n\\\\t\\\\t\\\\tdir.x /= aspect;\\\\n\\\\t\\\\t\\\\toffset.x /= aspect;\\\\n\\\\n\\\\t\\\\t\\\\t// sign flip\\\\n\\\\t\\\\t\\\\tif ( position.x < 0.0 ) offset *= - 1.0;\\\\n\\\\n\\\\t\\\\t\\\\t// endcaps\\\\n\\\\t\\\\t\\\\tif ( position.y < 0.0 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\toffset += - dir;\\\\n\\\\n\\\\t\\\\t\\\\t} else if ( position.y > 1.0 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\toffset += dir;\\\\n\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// adjust for linewidth\\\\n\\\\t\\\\t\\\\toffset *= linewidth;\\\\n\\\\n\\\\t\\\\t\\\\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\\\\n\\\\t\\\\t\\\\toffset /= resolution.y;\\\\n\\\\n\\\\t\\\\t\\\\t// select end\\\\n\\\\t\\\\t\\\\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\\\\n\\\\n\\\\t\\\\t\\\\t// back to clip space\\\\n\\\\t\\\\t\\\\toffset *= clip.w;\\\\n\\\\n\\\\t\\\\t\\\\tclip.xy += offset;\\\\n\\\\n\\\\t\\\\t\\\\tgl_Position = clip;\\\\n\\\\n\\\\t\\\\t\\\\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\\\\n\\\\n\\\\t\\\\t\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t\\\\t\\\\t#include <clipping_planes_vertex>\\\\n\\\\t\\\\t\\\\t#include <fog_vertex>\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\t\\\",\\n  fragmentShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\t\\\\tuniform vec3 diffuse;\\\\n\\\\t\\\\tuniform float opacity;\\\\n\\\\n\\\\t\\\\t#ifdef USE_DASH\\\\n\\\\n\\\\t\\\\t\\\\tuniform float dashSize;\\\\n\\\\t\\\\t\\\\tuniform float dashOffset;\\\\n\\\\t\\\\t\\\\tuniform float gapSize;\\\\n\\\\n\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\tvarying float vLineDistance;\\\\n\\\\n\\\\t\\\\t#include <common>\\\\n\\\\t\\\\t#include <color_pars_fragment>\\\\n\\\\t\\\\t#include <fog_pars_fragment>\\\\n\\\\t\\\\t#include <logdepthbuf_pars_fragment>\\\\n\\\\t\\\\t#include <clipping_planes_pars_fragment>\\\\n\\\\n\\\\t\\\\tvarying vec2 vUv;\\\\n\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\t#include <clipping_planes_fragment>\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef USE_DASH\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\tfloat alpha = opacity;\\\\n\\\\n\\\\t\\\\t\\\\t#ifdef ALPHA_TO_COVERAGE\\\\n\\\\n\\\\t\\\\t\\\\t// artifacts appear on some hardware if a derivative is taken within a conditional\\\\n\\\\t\\\\t\\\\tfloat a = vUv.x;\\\\n\\\\t\\\\t\\\\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\\\n\\\\t\\\\t\\\\tfloat len2 = a * a + b * b;\\\\n\\\\t\\\\t\\\\tfloat dlen = fwidth( len2 );\\\\n\\\\n\\\\t\\\\t\\\\tif ( abs( vUv.y ) > 1.0 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\\\\n\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\n\\\\t\\\\t\\\\tif ( abs( vUv.y ) > 1.0 ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfloat a = vUv.x;\\\\n\\\\t\\\\t\\\\t\\\\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\\\n\\\\t\\\\t\\\\t\\\\tfloat len2 = a * a + b * b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tif ( len2 > 1.0 ) discard;\\\\n\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\n\\\\t\\\\t\\\\tvec4 diffuseColor = vec4( diffuse, alpha );\\\\n\\\\n\\\\t\\\\t\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t\\\\t\\\\t#include <color_fragment>\\\\n\\\\n\\\\t\\\\t\\\\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\\\\n\\\\n\\\\t\\\\t\\\\t#include <tonemapping_fragment>\\\\n\\\\t\\\\t\\\\t#include <encodings_fragment>\\\\n\\\\t\\\\t\\\\t#include <fog_fragment>\\\\n\\\\t\\\\t\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\t\\\"\\n};\\n\\nvar LineMaterial =\\n/*#__PURE__*/\\nfunction (_ShaderMaterial) {\\n  _inherits(LineMaterial, _ShaderMaterial);\\n\\n  function LineMaterial() {\\n    var _this;\\n\\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n    _classCallCheck(this, LineMaterial);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineMaterial).call(this, {\\n      uniforms: _three.UniformsUtils.clone(_three.ShaderLib['line'].uniforms),\\n      vertexShader: _three.ShaderLib['line'].vertexShader,\\n      fragmentShader: _three.ShaderLib['line'].fragmentShader,\\n      clipping: true // required for clipping support\\n\\n    }));\\n    /**\\n     * Everytime I remove this, everything just breaks,\\n     * so I'm just gonna leave it here.\\n     */\\n\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"isLineMaterial\\\", true);\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"dashed\\\", false);\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"color\\\", new _three.Color(0x000000));\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"lineWidth\\\", 0);\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"dashScale\\\", 0);\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"dashOffset\\\", 0);\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"dashSize\\\", 0);\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"opacity\\\", 0);\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"resolution\\\", new _three.Vector2());\\n    (0, _defineProperty2[\\\"default\\\"])(_assertThisInitialized(_this), \\\"alphaToCoverage\\\", false);\\n    Object.defineProperties(_assertThisInitialized(_this), {\\n      color: {\\n        enumerable: true,\\n        get: function get() {\\n          return this.uniforms.diffuse.value;\\n        },\\n        set: function set(value) {\\n          var colorObj = new _three.Color(value);\\n          this.uniforms.diffuse.value = colorObj.getHex();\\n        }\\n      },\\n      linewidth: {\\n        enumerable: true,\\n        get: function get() {\\n          return this.uniforms.linewidth.value;\\n        },\\n        set: function set(value) {\\n          this.uniforms.linewidth.value = value;\\n        }\\n      },\\n      dashScale: {\\n        enumerable: true,\\n        get: function get() {\\n          return this.uniforms.dashScale.value;\\n        },\\n        set: function set(value) {\\n          this.uniforms.dashScale.value = value;\\n        }\\n      },\\n      dashSize: {\\n        enumerable: true,\\n        get: function get() {\\n          return this.uniforms.dashSize.value;\\n        },\\n        set: function set(value) {\\n          this.uniforms.dashSize.value = value;\\n        }\\n      },\\n      dashOffset: {\\n        enumerable: true,\\n        get: function get() {\\n          return this.uniforms.dashOffset.value;\\n        },\\n        set: function set(value) {\\n          this.uniforms.dashOffset.value = value;\\n        }\\n      },\\n      gapSize: {\\n        enumerable: true,\\n        get: function get() {\\n          return this.uniforms.gapSize.value;\\n        },\\n        set: function set(value) {\\n          this.uniforms.gapSize.value = value;\\n        }\\n      },\\n      opacity: {\\n        enumerable: true,\\n        get: function get() {\\n          return this.uniforms.opacity.value;\\n        },\\n        set: function set(value) {\\n          this.uniforms.opacity.value = value;\\n        }\\n      },\\n      resolution: {\\n        enumerable: true,\\n        get: function get() {\\n          return this.uniforms.resolution.value;\\n        },\\n        set: function set(value) {\\n          this.uniforms.resolution.value.copy(value);\\n        }\\n      },\\n      alphaToCoverage: {\\n        enumerable: true,\\n        get: function get() {\\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\\n        },\\n        set: function set(value) {\\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\\n            this.needsUpdate = true;\\n          }\\n\\n          if (value) {\\n            this.defines.ALPHA_TO_COVERAGE = '';\\n            this.extensions.derivatives = true;\\n          } else {\\n            delete this.defines.ALPHA_TO_COVERAGE;\\n            this.extensions.derivatives = false;\\n          }\\n        }\\n      },\\n      dashed: {\\n        enumerable: true,\\n        get: function get() {\\n          return Boolean('USE_DASH' in this.defines);\\n        },\\n        set: function set(value) {\\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\\n            this.needsUpdate = true;\\n          }\\n\\n          if (value) {\\n            this.defines.USE_DASH = '';\\n          } else {\\n            delete this.defines.USE_DASH;\\n          }\\n        }\\n      }\\n    });\\n\\n    _this.setValues(parameters);\\n\\n    return _this;\\n  }\\n\\n  return LineMaterial;\\n}(_three.ShaderMaterial);\\n\\nexports.LineMaterial = LineMaterial;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_possibleConstructorReturn\",\"self\",\"call\",\"_assertThisInitialized\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"ReferenceError\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"defineProperty\",\"LineMaterial\",\"_defineProperty2\",\"_interopRequireDefault\",\"__esModule\",\"_three\",\"LineUniforms\",\"linewidth\",\"resolution\",\"Vector2\",\"dashScale\",\"dashSize\",\"dashOffset\",\"gapSize\",\"opacity\",\"ShaderLib\",\"uniforms\",\"UniformsUtils\",\"merge\",\"UniformsLib\",\"common\",\"fog\",\"vertexShader\",\"fragmentShader\",\"_ShaderMaterial\",\"parameters\",\"arguments\",\"length\",\"undefined\",\"instance\",\"_this\",\"clone\",\"clipping\",\"Color\",\"defineProperties\",\"color\",\"enumerable\",\"get\",\"diffuse\",\"set\",\"colorObj\",\"getHex\",\"copy\",\"alphaToCoverage\",\"defines\",\"needsUpdate\",\"ALPHA_TO_COVERAGE\",\"extensions\",\"derivatives\",\"dashed\",\"USE_DASH\",\"setValues\",\"ShaderMaterial\"]\n}\n"]