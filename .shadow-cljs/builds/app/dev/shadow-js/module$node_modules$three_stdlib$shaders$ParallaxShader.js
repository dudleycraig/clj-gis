["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/ParallaxShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$ParallaxShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ParallaxShader=void 0;exports.ParallaxShader={modes:{none:\"NO_PARALLAX\",basic:\"USE_BASIC_PARALLAX\",steep:\"USE_STEEP_PARALLAX\",occlusion:\"USE_OCLUSION_PARALLAX\",relief:\"USE_RELIEF_PARALLAX\"},uniforms:{bumpMap:{value:null},map:{value:null},parallaxScale:{value:null},parallaxMinLayers:{value:null},parallaxMaxLayers:{value:null}},\nvertexShader:\"varying vec2 vUv;\\nvarying vec3 vViewPosition;\\nvarying vec3 vNormal;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tvec4 mvPosition \\x3d modelViewMatrix * vec4( position, 1.0 );\\n\\tvViewPosition \\x3d -mvPosition.xyz;\\n\\tvNormal \\x3d normalize( normalMatrix * normal );\\n\\tgl_Position \\x3d projectionMatrix * mvPosition;\\n}\",fragmentShader:\"uniform sampler2D bumpMap;\\nuniform sampler2D map;\\nuniform float parallaxScale;\\nuniform float parallaxMinLayers;\\nuniform float parallaxMaxLayers;\\nvarying vec2 vUv;\\nvarying vec3 vViewPosition;\\nvarying vec3 vNormal;\\n#ifdef USE_BASIC_PARALLAX\\n\\tvec2 parallaxMap( in vec3 V ) {\\n\\t\\tfloat initialHeight \\x3d texture2D( bumpMap, vUv ).r;\\n\\t\\tvec2 texCoordOffset \\x3d parallaxScale * V.xy * initialHeight;\\n\\t\\treturn vUv - texCoordOffset;\\n\\t}\\n#else\\n\\tvec2 parallaxMap( in vec3 V ) {\\n\\t\\tfloat numLayers \\x3d mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\\n\\t\\tfloat layerHeight \\x3d 1.0 / numLayers;\\n\\t\\tfloat currentLayerHeight \\x3d 0.0;\\n\\t\\tvec2 dtex \\x3d parallaxScale * V.xy / V.z / numLayers;\\n\\t\\tvec2 currentTextureCoords \\x3d vUv;\\n\\t\\tfloat heightFromTexture \\x3d texture2D( bumpMap, currentTextureCoords ).r;\\n\\t\\tfor ( int i \\x3d 0; i \\x3c 30; i +\\x3d 1 ) {\\n\\t\\t\\tif ( heightFromTexture \\x3c\\x3d currentLayerHeight ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tcurrentLayerHeight +\\x3d layerHeight;\\n\\t\\t\\tcurrentTextureCoords -\\x3d dtex;\\n\\t\\t\\theightFromTexture \\x3d texture2D( bumpMap, currentTextureCoords ).r;\\n\\t\\t}\\n\\t\\t#ifdef USE_STEEP_PARALLAX\\n\\t\\t\\treturn currentTextureCoords;\\n\\t\\t#elif defined( USE_RELIEF_PARALLAX )\\n\\t\\t\\tvec2 deltaTexCoord \\x3d dtex / 2.0;\\n\\t\\t\\tfloat deltaHeight \\x3d layerHeight / 2.0;\\n\\t\\t\\tcurrentTextureCoords +\\x3d deltaTexCoord;\\n\\t\\t\\tcurrentLayerHeight -\\x3d deltaHeight;\\n\\t\\t\\tconst int numSearches \\x3d 5;\\n\\t\\t\\tfor ( int i \\x3d 0; i \\x3c numSearches; i +\\x3d 1 ) {\\n\\t\\t\\t\\tdeltaTexCoord /\\x3d 2.0;\\n\\t\\t\\t\\tdeltaHeight /\\x3d 2.0;\\n\\t\\t\\t\\theightFromTexture \\x3d texture2D( bumpMap, currentTextureCoords ).r;\\n\\t\\t\\t\\tif( heightFromTexture \\x3e currentLayerHeight ) {\\n\\t\\t\\t\\t\\tcurrentTextureCoords -\\x3d deltaTexCoord;\\n\\t\\t\\t\\t\\tcurrentLayerHeight +\\x3d deltaHeight;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcurrentTextureCoords +\\x3d deltaTexCoord;\\n\\t\\t\\t\\t\\tcurrentLayerHeight -\\x3d deltaHeight;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn currentTextureCoords;\\n\\t\\t#elif defined( USE_OCLUSION_PARALLAX )\\n\\t\\t\\tvec2 prevTCoords \\x3d currentTextureCoords + dtex;\\n\\t\\t\\tfloat nextH \\x3d heightFromTexture - currentLayerHeight;\\n\\t\\t\\tfloat prevH \\x3d texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\\n\\t\\t\\tfloat weight \\x3d nextH / ( nextH - prevH );\\n\\t\\t\\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\\n\\t\\t#else\\n\\t\\t\\treturn vUv;\\n\\t\\t#endif\\n\\t}\\n#endif\\nvec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\\n\\tvec2 texDx \\x3d dFdx( vUv );\\n\\tvec2 texDy \\x3d dFdy( vUv );\\n\\tvec3 vSigmaX \\x3d dFdx( surfPosition );\\n\\tvec3 vSigmaY \\x3d dFdy( surfPosition );\\n\\tvec3 vR1 \\x3d cross( vSigmaY, surfNormal );\\n\\tvec3 vR2 \\x3d cross( surfNormal, vSigmaX );\\n\\tfloat fDet \\x3d dot( vSigmaX, vR1 );\\n\\tvec2 vProjVscr \\x3d ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\\n\\tvec3 vProjVtex;\\n\\tvProjVtex.xy \\x3d texDx * vProjVscr.x + texDy * vProjVscr.y;\\n\\tvProjVtex.z \\x3d dot( surfNormal, viewPosition );\\n\\treturn parallaxMap( vProjVtex );\\n}\\nvoid main() {\\n\\tvec2 mapUv \\x3d perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\\n\\tgl_FragColor \\x3d texture2D( map, mapUv );\\n}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$ParallaxShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParallaxShader = void 0;\n// Parallax Occlusion shaders from\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\n// No tangent-space transforms logic based on\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\nvar ParallaxShader = {\n  // Ordered from fastest to best quality.\n  modes: {\n    none: 'NO_PARALLAX',\n    basic: 'USE_BASIC_PARALLAX',\n    steep: 'USE_STEEP_PARALLAX',\n    occlusion: 'USE_OCLUSION_PARALLAX',\n    // a.k.a. POM\n    relief: 'USE_RELIEF_PARALLAX'\n  },\n  uniforms: {\n    bumpMap: {\n      value: null\n    },\n    map: {\n      value: null\n    },\n    parallaxScale: {\n      value: null\n    },\n    parallaxMinLayers: {\n      value: null\n    },\n    parallaxMaxLayers: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', 'void main() {', '\tvUv = uv;', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvViewPosition = -mvPosition.xyz;', '\tvNormal = normalize( normalMatrix * normal );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D bumpMap;', 'uniform sampler2D map;', 'uniform float parallaxScale;', 'uniform float parallaxMinLayers;', 'uniform float parallaxMaxLayers;', 'varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', '#ifdef USE_BASIC_PARALLAX', '\tvec2 parallaxMap( in vec3 V ) {', '\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;', // No Offset Limitting: messy, floating output at grazing angles.\n  //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n  // Offset Limiting\n  '\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;', '\t\treturn vUv - texCoordOffset;', '\t}', '#else', '\tvec2 parallaxMap( in vec3 V ) {', // Determine number of layers from angle between V and N\n  '\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );', '\t\tfloat layerHeight = 1.0 / numLayers;', '\t\tfloat currentLayerHeight = 0.0;', // Shift of texture coordinates for each iteration\n  '\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;', '\t\tvec2 currentTextureCoords = vUv;', '\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // while ( heightFromTexture > currentLayerHeight )\n  // Infinite loops are not well supported. Do a \"large\" finite\n  // loop, but not too large, as it slows down some compilers.\n  '\t\tfor ( int i = 0; i < 30; i += 1 ) {', '\t\t\tif ( heightFromTexture <= currentLayerHeight ) {', '\t\t\t\tbreak;', '\t\t\t}', '\t\t\tcurrentLayerHeight += layerHeight;', // Shift texture coordinates along vector V\n  '\t\t\tcurrentTextureCoords -= dtex;', '\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', '\t\t}', '\t\t#ifdef USE_STEEP_PARALLAX', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_RELIEF_PARALLAX )', '\t\t\tvec2 deltaTexCoord = dtex / 2.0;', '\t\t\tfloat deltaHeight = layerHeight / 2.0;', // Return to the mid point of previous layer\n  '\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\tcurrentLayerHeight -= deltaHeight;', // Binary search to increase precision of Steep Parallax Mapping\n  '\t\t\tconst int numSearches = 5;', '\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {', '\t\t\t\tdeltaTexCoord /= 2.0;', '\t\t\t\tdeltaHeight /= 2.0;', '\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // Shift along or against vector V\n  '\t\t\t\tif( heightFromTexture > currentLayerHeight ) {', // Below the surface\n  '\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight += deltaHeight;', '\t\t\t\t} else {', // above the surface\n  '\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight -= deltaHeight;', '\t\t\t\t}', '\t\t\t}', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_OCLUSION_PARALLAX )', '\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;', // Heights for linear interpolation\n  '\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;', '\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;', // Proportions for linear interpolation\n  '\t\t\tfloat weight = nextH / ( nextH - prevH );', // Interpolation of texture coordinates\n  '\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );', '\t\t#else', // NO_PARALLAX\n  '\t\t\treturn vUv;', '\t\t#endif', '\t}', '#endif', 'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {', '\tvec2 texDx = dFdx( vUv );', '\tvec2 texDy = dFdy( vUv );', '\tvec3 vSigmaX = dFdx( surfPosition );', '\tvec3 vSigmaY = dFdy( surfPosition );', '\tvec3 vR1 = cross( vSigmaY, surfNormal );', '\tvec3 vR2 = cross( surfNormal, vSigmaX );', '\tfloat fDet = dot( vSigmaX, vR1 );', '\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );', '\tvec3 vProjVtex;', '\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;', '\tvProjVtex.z = dot( surfNormal, viewPosition );', '\treturn parallaxMap( vProjVtex );', '}', 'void main() {', '\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );', '\tgl_FragColor = texture2D( map, mapUv );', '}'].join('\\n')\n};\nexports.ParallaxShader = ParallaxShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["fragmentShader","map","none","relief","parallaxScale","__esModule","bumpMap","vertexShader","value","steep","parallaxMinLayers","occlusion","parallaxMaxLayers","ParallaxShader","modes","uniforms","basic"]],"~:compiled-at",1630917515579,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$ParallaxShader.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,uDAAA,CAA4E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGpHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,cAAR,CAAyB,IAAK,EAqD9BJ,QAAQI,CAAAA,cAAR,CAhDqBA,CAEnBC,MAAO,CACLC,KAAM,aADD,CAELC,MAAO,oBAFF,CAGLC,MAAO,oBAHF,CAILC,UAAW,uBAJN,CAMLC,OAAQ,qBANH,CAFYN,CAUnBO,SAAU,CACRC,QAAS,CACPT,MAAO,IADA,CADD,CAIRU,IAAK,CACHV,MAAO,IADJ,CAJG,CAORW,cAAe,CACbX,MAAO,IADM,CAPP,CAURY,kBAAmB,CACjBZ,MAAO,IADU,CAVX,CAaRa,kBAAmB,CACjBb,MAAO,IADU,CAbX,CAVSC;AA2BnBa,aAAkU,wTA3B/Sb,CA4BnBc,eAkBuzB,0tGA9CpyBd,CAX+F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/ParallaxShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$ParallaxShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ParallaxShader = void 0;\\n// Parallax Occlusion shaders from\\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\\n// No tangent-space transforms logic based on\\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\\nvar ParallaxShader = {\\n  // Ordered from fastest to best quality.\\n  modes: {\\n    none: 'NO_PARALLAX',\\n    basic: 'USE_BASIC_PARALLAX',\\n    steep: 'USE_STEEP_PARALLAX',\\n    occlusion: 'USE_OCLUSION_PARALLAX',\\n    // a.k.a. POM\\n    relief: 'USE_RELIEF_PARALLAX'\\n  },\\n  uniforms: {\\n    bumpMap: {\\n      value: null\\n    },\\n    map: {\\n      value: null\\n    },\\n    parallaxScale: {\\n      value: null\\n    },\\n    parallaxMinLayers: {\\n      value: null\\n    },\\n    parallaxMaxLayers: {\\n      value: null\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', 'void main() {', '\\tvUv = uv;', '\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\\tvViewPosition = -mvPosition.xyz;', '\\tvNormal = normalize( normalMatrix * normal );', '\\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform sampler2D bumpMap;', 'uniform sampler2D map;', 'uniform float parallaxScale;', 'uniform float parallaxMinLayers;', 'uniform float parallaxMaxLayers;', 'varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', '#ifdef USE_BASIC_PARALLAX', '\\tvec2 parallaxMap( in vec3 V ) {', '\\t\\tfloat initialHeight = texture2D( bumpMap, vUv ).r;', // No Offset Limitting: messy, floating output at grazing angles.\\n  //\\\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\\\",\\n  // Offset Limiting\\n  '\\t\\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;', '\\t\\treturn vUv - texCoordOffset;', '\\t}', '#else', '\\tvec2 parallaxMap( in vec3 V ) {', // Determine number of layers from angle between V and N\\n  '\\t\\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );', '\\t\\tfloat layerHeight = 1.0 / numLayers;', '\\t\\tfloat currentLayerHeight = 0.0;', // Shift of texture coordinates for each iteration\\n  '\\t\\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;', '\\t\\tvec2 currentTextureCoords = vUv;', '\\t\\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // while ( heightFromTexture > currentLayerHeight )\\n  // Infinite loops are not well supported. Do a \\\"large\\\" finite\\n  // loop, but not too large, as it slows down some compilers.\\n  '\\t\\tfor ( int i = 0; i < 30; i += 1 ) {', '\\t\\t\\tif ( heightFromTexture <= currentLayerHeight ) {', '\\t\\t\\t\\tbreak;', '\\t\\t\\t}', '\\t\\t\\tcurrentLayerHeight += layerHeight;', // Shift texture coordinates along vector V\\n  '\\t\\t\\tcurrentTextureCoords -= dtex;', '\\t\\t\\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', '\\t\\t}', '\\t\\t#ifdef USE_STEEP_PARALLAX', '\\t\\t\\treturn currentTextureCoords;', '\\t\\t#elif defined( USE_RELIEF_PARALLAX )', '\\t\\t\\tvec2 deltaTexCoord = dtex / 2.0;', '\\t\\t\\tfloat deltaHeight = layerHeight / 2.0;', // Return to the mid point of previous layer\\n  '\\t\\t\\tcurrentTextureCoords += deltaTexCoord;', '\\t\\t\\tcurrentLayerHeight -= deltaHeight;', // Binary search to increase precision of Steep Parallax Mapping\\n  '\\t\\t\\tconst int numSearches = 5;', '\\t\\t\\tfor ( int i = 0; i < numSearches; i += 1 ) {', '\\t\\t\\t\\tdeltaTexCoord /= 2.0;', '\\t\\t\\t\\tdeltaHeight /= 2.0;', '\\t\\t\\t\\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // Shift along or against vector V\\n  '\\t\\t\\t\\tif( heightFromTexture > currentLayerHeight ) {', // Below the surface\\n  '\\t\\t\\t\\t\\tcurrentTextureCoords -= deltaTexCoord;', '\\t\\t\\t\\t\\tcurrentLayerHeight += deltaHeight;', '\\t\\t\\t\\t} else {', // above the surface\\n  '\\t\\t\\t\\t\\tcurrentTextureCoords += deltaTexCoord;', '\\t\\t\\t\\t\\tcurrentLayerHeight -= deltaHeight;', '\\t\\t\\t\\t}', '\\t\\t\\t}', '\\t\\t\\treturn currentTextureCoords;', '\\t\\t#elif defined( USE_OCLUSION_PARALLAX )', '\\t\\t\\tvec2 prevTCoords = currentTextureCoords + dtex;', // Heights for linear interpolation\\n  '\\t\\t\\tfloat nextH = heightFromTexture - currentLayerHeight;', '\\t\\t\\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;', // Proportions for linear interpolation\\n  '\\t\\t\\tfloat weight = nextH / ( nextH - prevH );', // Interpolation of texture coordinates\\n  '\\t\\t\\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );', '\\t\\t#else', // NO_PARALLAX\\n  '\\t\\t\\treturn vUv;', '\\t\\t#endif', '\\t}', '#endif', 'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {', '\\tvec2 texDx = dFdx( vUv );', '\\tvec2 texDy = dFdy( vUv );', '\\tvec3 vSigmaX = dFdx( surfPosition );', '\\tvec3 vSigmaY = dFdy( surfPosition );', '\\tvec3 vR1 = cross( vSigmaY, surfNormal );', '\\tvec3 vR2 = cross( surfNormal, vSigmaX );', '\\tfloat fDet = dot( vSigmaX, vR1 );', '\\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );', '\\tvec3 vProjVtex;', '\\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;', '\\tvProjVtex.z = dot( surfNormal, viewPosition );', '\\treturn parallaxMap( vProjVtex );', '}', 'void main() {', '\\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );', '\\tgl_FragColor = texture2D( map, mapUv );', '}'].join('\\\\n')\\n};\\nexports.ParallaxShader = ParallaxShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"ParallaxShader\",\"modes\",\"none\",\"basic\",\"steep\",\"occlusion\",\"relief\",\"uniforms\",\"bumpMap\",\"map\",\"parallaxScale\",\"parallaxMinLayers\",\"parallaxMaxLayers\",\"vertexShader\",\"fragmentShader\"]\n}\n"]