["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/FBXLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$FBXLoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");\n}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=\nObject.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,\np$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}function getFbxVersion(text){if(text=text.match(/FBXVersion: (\\d+)/))return parseInt(text[1]);throw Error(\"THREE.FBXLoader: Cannot find the version number for the file given.\");}function convertFBXTimeToSeconds(time){return time/46186158E3}function getData(polygonVertexIndex,polygonIndex,vertexIndex,infoObject){switch(infoObject.mappingType){case \"ByPolygonVertex\":var index=\npolygonVertexIndex;break;case \"ByPolygon\":index=polygonIndex;break;case \"ByVertice\":index=vertexIndex;break;case \"AllSame\":index=infoObject.indices[0];break;default:console.warn(\"THREE.FBXLoader: unknown attribute mapping type \"+infoObject.mappingType)}\"IndexToDirect\"===infoObject.referenceType&&(index=infoObject.indices[index]);vertexIndex=index*infoObject.dataSize;polygonVertexIndex=dataArray;polygonIndex=infoObject.buffer;infoObject=vertexIndex+infoObject.dataSize;for(index=0;vertexIndex<infoObject;vertexIndex++,\nindex++)polygonVertexIndex[index]=polygonIndex[vertexIndex];return polygonVertexIndex}function generateTransform(transformData){var lTranslationM=new _three.Matrix4,lPreRotationM=new _three.Matrix4,lRotationM=new _three.Matrix4,lPostRotationM=new _three.Matrix4,lScalingM=new _three.Matrix4,lScalingPivotM=new _three.Matrix4,lScalingOffsetM=new _three.Matrix4,lRotationOffsetM=new _three.Matrix4,lRotationPivotM=new _three.Matrix4,lParentGX=new _three.Matrix4,lParentLX=new _three.Matrix4,lGlobalT=new _three.Matrix4,\ninheritType=transformData.inheritType?transformData.inheritType:0;transformData.translation&&lTranslationM.setPosition(tempVec.fromArray(transformData.translation));if(transformData.preRotation){var array=transformData.preRotation.map(_three.MathUtils.degToRad);array.push(transformData.eulerOrder);lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array))}transformData.rotation&&(array=transformData.rotation.map(_three.MathUtils.degToRad),array.push(transformData.eulerOrder),lRotationM.makeRotationFromEuler(tempEuler.fromArray(array)));\ntransformData.postRotation&&(array=transformData.postRotation.map(_three.MathUtils.degToRad),array.push(transformData.eulerOrder),lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array)),lPostRotationM.invert());transformData.scale&&lScalingM.scale(tempVec.fromArray(transformData.scale));transformData.scalingOffset&&lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));transformData.scalingPivot&&lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));\ntransformData.rotationOffset&&lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));transformData.rotationPivot&&lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));transformData.parentMatrixWorld&&(lParentLX.copy(transformData.parentMatrix),lParentGX.copy(transformData.parentMatrixWorld));array=(new _three.Matrix4).copy(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM);var lParentGRM=new _three.Matrix4;lParentGRM.extractRotation(lParentGX);\ntransformData=new _three.Matrix4;transformData.copyPosition(lParentGX);var lParentGSM=new _three.Matrix4;transformData=(new _three.Matrix4).copy(transformData).invert().multiply(lParentGX);lParentGSM.copy(lParentGRM).invert().multiply(transformData);transformData=new _three.Matrix4;0===inheritType?transformData.copy(lParentGRM).multiply(array).multiply(lParentGSM).multiply(lScalingM):1===inheritType?transformData.copy(lParentGRM).multiply(lParentGSM).multiply(array).multiply(lScalingM):(lParentLX=\n(new _three.Matrix4).scale((new _three.Vector3).setFromMatrixScale(lParentLX)),lParentLX=(new _three.Matrix4).copy(lParentLX).invert(),lParentLX=(new _three.Matrix4).copy(lParentGSM).multiply(lParentLX),transformData.copy(lParentGRM).multiply(array).multiply(lParentLX).multiply(lScalingM));lParentLX=new _three.Matrix4;lParentLX.copy(lRotationPivotM).invert();inheritType=new _three.Matrix4;inheritType.copy(lScalingPivotM).invert();array=new _three.Matrix4;array.copy(lTranslationM).multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lParentLX).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(inheritType);\nlTranslationM=(new _three.Matrix4).copyPosition(array);lTranslationM=(new _three.Matrix4).copy(lParentGX).multiply(lTranslationM);lGlobalT.copyPosition(lTranslationM);array=(new _three.Matrix4).copy(lGlobalT).multiply(transformData);array.premultiply(lParentGX.invert());return array}function getEulerOrder(order){order=order||0;var enums=\"ZYX YZX XZY ZXY YXZ XYZ\".split(\" \");return 6===order?(console.warn(\"THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.\"),\nenums[0]):enums[order]}function parseNumberArray(value){return value.split(\",\").map(function(val){return parseFloat(val)})}function convertArrayBufferToString(buffer,from,to){void 0===from&&(from=0);void 0===to&&(to=buffer.byteLength);return _three.LoaderUtils.decodeText(new Uint8Array(buffer,from,to))}function append(a,b){for(var i=0,j=a.length,l=b.length;i<l;i++,j++)a[j]=b[i]}function inject(a1,index,a2){return a1.slice(0,index).concat(a2).concat(a1.slice(index))}Object.defineProperty(exports,\"__esModule\",\n{value:!0});exports.FBXLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_fflate=require(\"module$node_modules$fflate$esm$browser\"),_NURBSCurve=require(\"module$node_modules$three_stdlib$curves$NURBSCurve\"),fbxTree,connections,sceneGraph;global=function(_Loader){function FBXLoader(manager){_classCallCheck(this,FBXLoader);manager=_getPrototypeOf(FBXLoader).call(this,manager);if(!manager||\"object\"!==_typeof(manager)&&\"function\"!==typeof manager){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\nmanager=this}return manager}_inherits(FBXLoader,_Loader);_createClass(FBXLoader,[{key:\"load\",value:function(url,onLoad,onProgress,onError){var scope=this,path=\"\"===scope.path?_three.LoaderUtils.extractUrlBase(url):scope.path,loader=new _three.FileLoader(this.manager);loader.setPath(scope.path);loader.setResponseType(\"arraybuffer\");loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(buffer){try{onLoad(scope.parse(buffer,path))}catch(e){onError?\nonError(e):console.error(e),scope.manager.itemError(url)}},onProgress,onError)}},{key:\"parse\",value:function(FBXBuffer,path){if(21<=FBXBuffer.byteLength&&\"Kaydara FBX Binary  \\x00\"===convertArrayBufferToString(FBXBuffer,0,21))fbxTree=(new BinaryParser).parse(FBXBuffer);else{FBXBuffer=convertArrayBufferToString(FBXBuffer);a:{var JSCompiler_inline_result=FBXBuffer;for(var CORRECT=\"Kaydara\\\\FBX\\\\Binary\\\\\\\\\".split(\"\"),cursor=0,i=0;i<CORRECT.length;++i){var result=JSCompiler_inline_result[0];JSCompiler_inline_result=\nJSCompiler_inline_result.slice(cursor+1);cursor++;if(result===CORRECT[i]){JSCompiler_inline_result=!1;break a}}JSCompiler_inline_result=!0}if(!JSCompiler_inline_result)throw Error(\"THREE.FBXLoader: Unknown format.\");if(7E3>getFbxVersion(FBXBuffer))throw Error(\"THREE.FBXLoader: FBX version not supported, FileVersion: \"+getFbxVersion(FBXBuffer));fbxTree=(new TextParser).parse(FBXBuffer)}path=(new _three.TextureLoader(this.manager)).setPath(this.resourcePath||path).setCrossOrigin(this.crossOrigin);return(new FBXTreeParser(path,\nthis.manager)).parse(fbxTree)}}]);return FBXLoader}(_three.Loader);exports.FBXLoader=global;var FBXTreeParser=function(){function FBXTreeParser(textureLoader,manager){_classCallCheck(this,FBXTreeParser);this.textureLoader=textureLoader;this.manager=manager}_createClass(FBXTreeParser,[{key:\"parse\",value:function(){connections=this.parseConnections();var images=this.parseImages();images=this.parseTextures(images);images=this.parseMaterials(images);var deformers=this.parseDeformers(),geometryMap=(new GeometryParser).parse(deformers);\nthis.parseScene(deformers,geometryMap,images);return sceneGraph}},{key:\"parseConnections\",value:function(){var connectionMap=new Map;\"Connections\"in fbxTree&&fbxTree.Connections.connections.forEach(function(rawConnection){var fromID=rawConnection[0],toID=rawConnection[1];rawConnection=rawConnection[2];connectionMap.has(fromID)||connectionMap.set(fromID,{parents:[],children:[]});var parentRelationship={ID:toID,relationship:rawConnection};connectionMap.get(fromID).parents.push(parentRelationship);connectionMap.has(toID)||\nconnectionMap.set(toID,{parents:[],children:[]});fromID={ID:fromID,relationship:rawConnection};connectionMap.get(toID).children.push(fromID)});return connectionMap}},{key:\"parseImages\",value:function(){var images={},blobs={};if(\"Video\"in fbxTree.Objects){var videoNodes=fbxTree.Objects.Video,nodeID;for(nodeID in videoNodes){var videoNode=videoNodes[nodeID],id=parseInt(nodeID);images[id]=videoNode.RelativeFilename||videoNode.Filename;\"Content\"in videoNode&&(id=\"string\"===typeof videoNode.Content&&\"\"!==\nvideoNode.Content,videoNode.Content instanceof ArrayBuffer&&0<videoNode.Content.byteLength||id)&&(id=this.parseImage(videoNodes[nodeID]),blobs[videoNode.RelativeFilename||videoNode.Filename]=id)}}for(var _id in images)videoNodes=images[_id],images[_id]=void 0!==blobs[videoNodes]?blobs[videoNodes]:images[_id].split(\"\\\\\").pop();return images}},{key:\"parseImage\",value:function(videoNode){var content=videoNode.Content;videoNode=videoNode.RelativeFilename||videoNode.Filename;var extension=videoNode.slice(videoNode.lastIndexOf(\".\")+\n1).toLowerCase();switch(extension){case \"bmp\":videoNode=\"image/bmp\";break;case \"jpg\":case \"jpeg\":videoNode=\"image/jpeg\";break;case \"png\":videoNode=\"image/png\";break;case \"tif\":videoNode=\"image/tiff\";break;case \"tga\":null===this.manager.getHandler(\".tga\")&&console.warn(\"FBXLoader: TGA loader not found, skipping \",videoNode);videoNode=\"image/tga\";break;default:console.warn('FBXLoader: Image type \"'+extension+'\" is not supported.');return}if(\"string\"===typeof content)return\"data:\"+videoNode+\";base64,\"+\ncontent;content=new Uint8Array(content);return window.URL.createObjectURL(new Blob([content],{type:videoNode}))}},{key:\"parseTextures\",value:function(images){var textureMap=new Map;if(\"Texture\"in fbxTree.Objects){var textureNodes=fbxTree.Objects.Texture,nodeID;for(nodeID in textureNodes){var texture=this.parseTexture(textureNodes[nodeID],images);textureMap.set(parseInt(nodeID),texture)}}return textureMap}},{key:\"parseTexture\",value:function(textureNode,images){images=this.loadTexture(textureNode,\nimages);images.ID=textureNode.id;images.name=textureNode.attrName;var wrapModeU=textureNode.WrapModeU,wrapModeV=textureNode.WrapModeV;wrapModeV=void 0!==wrapModeV?wrapModeV.value:0;images.wrapS=0===(void 0!==wrapModeU?wrapModeU.value:0)?_three.RepeatWrapping:_three.ClampToEdgeWrapping;images.wrapT=0===wrapModeV?_three.RepeatWrapping:_three.ClampToEdgeWrapping;\"Scaling\"in textureNode&&(textureNode=textureNode.Scaling.value,images.repeat.x=textureNode[0],images.repeat.y=textureNode[1]);return images}},\n{key:\"loadTexture\",value:function(textureNode,images){var currentPath=this.textureLoader.path,children=connections.get(textureNode.id).children;if(void 0!==children&&0<children.length&&void 0!==images[children[0].ID]){var fileName=images[children[0].ID];0!==fileName.indexOf(\"blob:\")&&0!==fileName.indexOf(\"data:\")||this.textureLoader.setPath(void 0)}images=textureNode.FileName.slice(-3).toLowerCase();\"tga\"===images?(images=this.manager.getHandler(\".tga\"),null===images?(console.warn(\"FBXLoader: TGA loader not found, creating placeholder texture for\",\ntextureNode.RelativeFilename),textureNode=new _three.Texture):textureNode=images.load(fileName)):\"psd\"===images?(console.warn(\"FBXLoader: PSD textures are not supported, creating placeholder texture for\",textureNode.RelativeFilename),textureNode=new _three.Texture):textureNode=this.textureLoader.load(fileName);this.textureLoader.setPath(currentPath);return textureNode}},{key:\"parseMaterials\",value:function(textureMap){var materialMap=new Map;if(\"Material\"in fbxTree.Objects){var materialNodes=fbxTree.Objects.Material,\nnodeID;for(nodeID in materialNodes){var material=this.parseMaterial(materialNodes[nodeID],textureMap);null!==material&&materialMap.set(parseInt(nodeID),material)}}return materialMap}},{key:\"parseMaterial\",value:function(materialNode,textureMap){var ID=materialNode.id,name=materialNode.attrName,type=materialNode.ShadingModel;\"object\"===_typeof(type)&&(type=type.value);if(!connections.has(ID))return null;materialNode=this.parseParameters(materialNode,textureMap,ID);switch(type.toLowerCase()){case \"phong\":type=\nnew _three.MeshPhongMaterial;break;case \"lambert\":type=new _three.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.',type),type=new _three.MeshPhongMaterial}type.setValues(materialNode);type.name=name;return type}},{key:\"parseParameters\",value:function(materialNode,textureMap,ID){var parameters={};materialNode.BumpFactor&&(parameters.bumpScale=materialNode.BumpFactor.value);materialNode.Diffuse?parameters.color=(new _three.Color).fromArray(materialNode.Diffuse.value):\n!materialNode.DiffuseColor||\"Color\"!==materialNode.DiffuseColor.type&&\"ColorRGB\"!==materialNode.DiffuseColor.type||(parameters.color=(new _three.Color).fromArray(materialNode.DiffuseColor.value));materialNode.DisplacementFactor&&(parameters.displacementScale=materialNode.DisplacementFactor.value);materialNode.Emissive?parameters.emissive=(new _three.Color).fromArray(materialNode.Emissive.value):!materialNode.EmissiveColor||\"Color\"!==materialNode.EmissiveColor.type&&\"ColorRGB\"!==materialNode.EmissiveColor.type||\n(parameters.emissive=(new _three.Color).fromArray(materialNode.EmissiveColor.value));materialNode.EmissiveFactor&&(parameters.emissiveIntensity=parseFloat(materialNode.EmissiveFactor.value));materialNode.Opacity&&(parameters.opacity=parseFloat(materialNode.Opacity.value));1>parameters.opacity&&(parameters.transparent=!0);materialNode.ReflectionFactor&&(parameters.reflectivity=materialNode.ReflectionFactor.value);materialNode.Shininess&&(parameters.shininess=materialNode.Shininess.value);materialNode.Specular?\nparameters.specular=(new _three.Color).fromArray(materialNode.Specular.value):materialNode.SpecularColor&&\"Color\"===materialNode.SpecularColor.type&&(parameters.specular=(new _three.Color).fromArray(materialNode.SpecularColor.value));var scope=this;connections.get(ID).children.forEach(function(child){var type=child.relationship;switch(type){case \"Bump\":parameters.bumpMap=scope.getTexture(textureMap,child.ID);break;case \"Maya|TEX_ao_map\":parameters.aoMap=scope.getTexture(textureMap,child.ID);break;\ncase \"DiffuseColor\":case \"Maya|TEX_color_map\":parameters.map=scope.getTexture(textureMap,child.ID);parameters.map.encoding=_three.sRGBEncoding;break;case \"DisplacementColor\":parameters.displacementMap=scope.getTexture(textureMap,child.ID);break;case \"EmissiveColor\":parameters.emissiveMap=scope.getTexture(textureMap,child.ID);parameters.emissiveMap.encoding=_three.sRGBEncoding;break;case \"NormalMap\":case \"Maya|TEX_normal_map\":parameters.normalMap=scope.getTexture(textureMap,child.ID);break;case \"ReflectionColor\":parameters.envMap=\nscope.getTexture(textureMap,child.ID);parameters.envMap.mapping=_three.EquirectangularReflectionMapping;parameters.envMap.encoding=_three.sRGBEncoding;break;case \"SpecularColor\":parameters.specularMap=scope.getTexture(textureMap,child.ID);parameters.specularMap.encoding=_three.sRGBEncoding;break;case \"TransparentColor\":case \"TransparencyFactor\":parameters.alphaMap=scope.getTexture(textureMap,child.ID);parameters.transparent=!0;break;default:console.warn(\"THREE.FBXLoader: %s map is not supported in three.js, skipping texture.\",\ntype)}});return parameters}},{key:\"getTexture\",value:function(textureMap,id){\"LayeredTexture\"in fbxTree.Objects&&id in fbxTree.Objects.LayeredTexture&&(console.warn(\"THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.\"),id=connections.get(id).children[0].ID);return textureMap.get(id)}},{key:\"parseDeformers\",value:function(){var skeletons={},morphTargets={};if(\"Deformer\"in fbxTree.Objects){var DeformerNodes=fbxTree.Objects.Deformer,nodeID;for(nodeID in DeformerNodes){var deformerNode=\nDeformerNodes[nodeID],relationships=connections.get(parseInt(nodeID));\"Skin\"===deformerNode.attrType?(deformerNode=this.parseSkeleton(relationships,DeformerNodes),deformerNode.ID=nodeID,1<relationships.parents.length&&console.warn(\"THREE.FBXLoader: skeleton attached to more than one geometry is not supported.\"),deformerNode.geometryID=relationships.parents[0].ID,skeletons[nodeID]=deformerNode):\"BlendShape\"===deformerNode.attrType&&(deformerNode={id:nodeID},deformerNode.rawTargets=this.parseMorphTargets(relationships,\nDeformerNodes),deformerNode.id=nodeID,1<relationships.parents.length&&console.warn(\"THREE.FBXLoader: morph target attached to more than one geometry is not supported.\"),morphTargets[nodeID]=deformerNode)}}return{skeletons,morphTargets}}},{key:\"parseSkeleton\",value:function(relationships,deformerNodes){var rawBones=[];relationships.children.forEach(function(child){var boneNode=deformerNodes[child.ID];\"Cluster\"===boneNode.attrType&&(child={ID:child.ID,indices:[],weights:[],transformLink:(new _three.Matrix4).fromArray(boneNode.TransformLink.a)},\n\"Indexes\"in boneNode&&(child.indices=boneNode.Indexes.a,child.weights=boneNode.Weights.a),rawBones.push(child))});return{rawBones,bones:[]}}},{key:\"parseMorphTargets\",value:function(relationships,deformerNodes){for(var rawMorphTargets=[],i=0;i<relationships.children.length;i++){var child$jscomp$0=relationships.children[i],morphTargetNode=deformerNodes[child$jscomp$0.ID],rawMorphTarget={name:morphTargetNode.attrName,initialWeight:morphTargetNode.DeformPercent,id:morphTargetNode.id,fullWeights:morphTargetNode.FullWeights.a};\nif(\"BlendShapeChannel\"!==morphTargetNode.attrType)return;rawMorphTarget.geoID=connections.get(parseInt(child$jscomp$0.ID)).children.filter(function(child){return void 0===child.relationship})[0].ID;rawMorphTargets.push(rawMorphTarget)}return rawMorphTargets}},{key:\"parseScene\",value:function(deformers,geometryMap,materialMap){sceneGraph=new _three.Group;var modelMap=this.parseModels(deformers.skeletons,geometryMap,materialMap),modelNodes=fbxTree.Objects.Model,scope=this;modelMap.forEach(function(model){scope.setLookAtProperties(model,\nmodelNodes[model.ID]);connections.get(model.ID).parents.forEach(function(connection){connection=modelMap.get(connection.ID);void 0!==connection&&connection.add(model)});null===model.parent&&sceneGraph.add(model)});this.bindSkeleton(deformers.skeletons,geometryMap,modelMap);this.createAmbientLight();this.setupMorphMaterials();sceneGraph.traverse(function(node){if(node.userData.transformData){node.parent&&(node.userData.transformData.parentMatrix=node.parent.matrix,node.userData.transformData.parentMatrixWorld=\nnode.parent.matrixWorld);var transform=generateTransform(node.userData.transformData);node.applyMatrix4(transform);node.updateWorldMatrix()}});deformers=(new AnimationParser).parse();1===sceneGraph.children.length&&sceneGraph.children[0].isGroup&&(sceneGraph.children[0].animations=deformers,sceneGraph=sceneGraph.children[0]);sceneGraph.animations=deformers}},{key:\"parseModels\",value:function(skeletons,geometryMap,materialMap){var modelMap=new Map,modelNodes=fbxTree.Objects.Model,nodeID;for(nodeID in modelNodes){var id=\nparseInt(nodeID),node=modelNodes[nodeID],relationships=connections.get(id),model=this.buildSkeleton(relationships,skeletons,id,node.attrName);if(!model){switch(node.attrType){case \"Camera\":model=this.createCamera(relationships);break;case \"Light\":model=this.createLight(relationships);break;case \"Mesh\":model=this.createMesh(relationships,geometryMap,materialMap);break;case \"NurbsCurve\":model=this.createCurve(relationships,geometryMap);break;case \"LimbNode\":case \"Root\":model=new _three.Bone;break;default:model=\nnew _three.Group}model.name=node.attrName?_three.PropertyBinding.sanitizeNodeName(node.attrName):\"\";model.ID=id}this.getTransformData(model,node);modelMap.set(id,model)}return modelMap}},{key:\"buildSkeleton\",value:function(relationships,skeletons,id,name){var bone=null;relationships.parents.forEach(function(parent){var _loop=function(ID){var skeleton=skeletons[ID];skeleton.rawBones.forEach(function(rawBone,i){if(rawBone.ID===parent.ID){var subBone=bone;bone=new _three.Bone;bone.matrixWorld.copy(rawBone.transformLink);\nbone.name=name?_three.PropertyBinding.sanitizeNodeName(name):\"\";bone.ID=id;skeleton.bones[i]=bone;null!==subBone&&bone.add(subBone)}})},ID$jscomp$0;for(ID$jscomp$0 in skeletons)_loop(ID$jscomp$0)});return bone}},{key:\"createCamera\",value:function(relationships){var cameraAttribute;relationships.children.forEach(function(child){child=fbxTree.Objects.NodeAttribute[child.ID];void 0!==child&&(cameraAttribute=child)});if(void 0===cameraAttribute)var model=new _three.Object3D;else{model=0;void 0!==cameraAttribute.CameraProjectionType&&\n1===cameraAttribute.CameraProjectionType.value&&(model=1);var nearClippingPlane=1;void 0!==cameraAttribute.NearPlane&&(nearClippingPlane=cameraAttribute.NearPlane.value/1E3);var farClippingPlane=1E3;void 0!==cameraAttribute.FarPlane&&(farClippingPlane=cameraAttribute.FarPlane.value/1E3);var width=window.innerWidth,height=window.innerHeight;void 0!==cameraAttribute.AspectWidth&&void 0!==cameraAttribute.AspectHeight&&(width=cameraAttribute.AspectWidth.value,height=cameraAttribute.AspectHeight.value);\nvar aspect=width/height,fov=45;void 0!==cameraAttribute.FieldOfView&&(fov=cameraAttribute.FieldOfView.value);relationships=cameraAttribute.FocalLength?cameraAttribute.FocalLength.value:null;switch(model){case 0:model=new _three.PerspectiveCamera(fov,aspect,nearClippingPlane,farClippingPlane);null!==relationships&&model.setFocalLength(relationships);break;case 1:model=new _three.OrthographicCamera(-width/2,width/2,height/2,-height/2,nearClippingPlane,farClippingPlane);break;default:console.warn(\"THREE.FBXLoader: Unknown camera type \"+\nmodel+\".\"),model=new _three.Object3D}}return model}},{key:\"createLight\",value:function(relationships){var lightAttribute;relationships.children.forEach(function(child){child=fbxTree.Objects.NodeAttribute[child.ID];void 0!==child&&(lightAttribute=child)});if(void 0===lightAttribute)relationships=new _three.Object3D;else{var type=void 0===lightAttribute.LightType?0:lightAttribute.LightType.value;relationships=16777215;void 0!==lightAttribute.Color&&(relationships=(new _three.Color).fromArray(lightAttribute.Color.value));\nvar intensity=void 0===lightAttribute.Intensity?1:lightAttribute.Intensity.value/100;void 0!==lightAttribute.CastLightOnObject&&0===lightAttribute.CastLightOnObject.value&&(intensity=0);var distance=0;void 0!==lightAttribute.FarAttenuationEnd&&(distance=void 0!==lightAttribute.EnableFarAttenuation&&0===lightAttribute.EnableFarAttenuation.value?0:lightAttribute.FarAttenuationEnd.value);switch(type){case 0:relationships=new _three.PointLight(relationships,intensity,distance,1);break;case 1:relationships=\nnew _three.DirectionalLight(relationships,intensity);break;case 2:type=Math.PI/3;void 0!==lightAttribute.InnerAngle&&(type=_three.MathUtils.degToRad(lightAttribute.InnerAngle.value));var penumbra=0;void 0!==lightAttribute.OuterAngle&&(penumbra=_three.MathUtils.degToRad(lightAttribute.OuterAngle.value),penumbra=Math.max(penumbra,1));relationships=new _three.SpotLight(relationships,intensity,distance,type,penumbra,1);break;default:console.warn(\"THREE.FBXLoader: Unknown light type \"+lightAttribute.LightType.value+\n\", defaulting to a PointLight.\"),relationships=new _three.PointLight(relationships,intensity)}void 0!==lightAttribute.CastShadows&&1===lightAttribute.CastShadows.value&&(relationships.castShadow=!0)}return relationships}},{key:\"createMesh\",value:function(relationships,geometryMap,materialMap){var geometry=null,material$jscomp$0=null,materials=[];relationships.children.forEach(function(child){geometryMap.has(child.ID)&&(geometry=geometryMap.get(child.ID));materialMap.has(child.ID)&&materials.push(materialMap.get(child.ID))});\n1<materials.length?material$jscomp$0=materials:0<materials.length?material$jscomp$0=materials[0]:(material$jscomp$0=new _three.MeshPhongMaterial({color:13421772}),materials.push(material$jscomp$0));\"color\"in geometry.attributes&&materials.forEach(function(material){material.vertexColors=!0});geometry.FBX_Deformer?(materials.forEach(function(material){material.skinning=!0}),relationships=new _three.SkinnedMesh(geometry,material$jscomp$0),relationships.normalizeSkinWeights()):relationships=new _three.Mesh(geometry,\nmaterial$jscomp$0);return relationships}},{key:\"createCurve\",value:function(relationships,geometryMap){relationships=relationships.children.reduce(function(geo,child){geometryMap.has(child.ID)&&(geo=geometryMap.get(child.ID));return geo},null);var material=new _three.LineBasicMaterial({color:3342591,linewidth:1});return new _three.Line(relationships,material)}},{key:\"getTransformData\",value:function(model,modelNode){var transformData={};\"InheritType\"in modelNode&&(transformData.inheritType=parseInt(modelNode.InheritType.value));\ntransformData.eulerOrder=\"RotationOrder\"in modelNode?getEulerOrder(modelNode.RotationOrder.value):\"ZYX\";\"Lcl_Translation\"in modelNode&&(transformData.translation=modelNode.Lcl_Translation.value);\"PreRotation\"in modelNode&&(transformData.preRotation=modelNode.PreRotation.value);\"Lcl_Rotation\"in modelNode&&(transformData.rotation=modelNode.Lcl_Rotation.value);\"PostRotation\"in modelNode&&(transformData.postRotation=modelNode.PostRotation.value);\"Lcl_Scaling\"in modelNode&&(transformData.scale=modelNode.Lcl_Scaling.value);\n\"ScalingOffset\"in modelNode&&(transformData.scalingOffset=modelNode.ScalingOffset.value);\"ScalingPivot\"in modelNode&&(transformData.scalingPivot=modelNode.ScalingPivot.value);\"RotationOffset\"in modelNode&&(transformData.rotationOffset=modelNode.RotationOffset.value);\"RotationPivot\"in modelNode&&(transformData.rotationPivot=modelNode.RotationPivot.value);model.userData.transformData=transformData}},{key:\"setLookAtProperties\",value:function(model,modelNode){\"LookAtProperty\"in modelNode&&connections.get(model.ID).children.forEach(function(child){\"LookAtProperty\"===\nchild.relationship&&(child=fbxTree.Objects.Model[child.ID],\"Lcl_Translation\"in child&&(child=child.Lcl_Translation.value,void 0!==model.target?(model.target.position.fromArray(child),sceneGraph.add(model.target)):model.lookAt((new _three.Vector3).fromArray(child))))})}},{key:\"bindSkeleton\",value:function(skeletons,geometryMap,modelMap){var bindMatrices=this.parsePoseNodes(),_loop2=function(ID){var skeleton=skeletons[ID];connections.get(parseInt(skeleton.ID)).parents.forEach(function(parent){geometryMap.has(parent.ID)&&\nconnections.get(parent.ID).parents.forEach(function(geoConnParent){modelMap.has(geoConnParent.ID)&&modelMap.get(geoConnParent.ID).bind(new _three.Skeleton(skeleton.bones),bindMatrices[geoConnParent.ID])})})},ID$jscomp$0;for(ID$jscomp$0 in skeletons)_loop2(ID$jscomp$0)}},{key:\"parsePoseNodes\",value:function(){var bindMatrices={};if(\"Pose\"in fbxTree.Objects){var BindPoseNode=fbxTree.Objects.Pose,nodeID;for(nodeID in BindPoseNode)if(\"BindPose\"===BindPoseNode[nodeID].attrType){var poseNodes=BindPoseNode[nodeID].PoseNode;\nArray.isArray(poseNodes)?poseNodes.forEach(function(poseNode){bindMatrices[poseNode.Node]=(new _three.Matrix4).fromArray(poseNode.Matrix.a)}):bindMatrices[poseNodes.Node]=(new _three.Matrix4).fromArray(poseNodes.Matrix.a)}}return bindMatrices}},{key:\"createAmbientLight\",value:function(){if(\"GlobalSettings\"in fbxTree&&\"AmbientColor\"in fbxTree.GlobalSettings){var ambientColor=fbxTree.GlobalSettings.AmbientColor.value,r=ambientColor[0],g=ambientColor[1];ambientColor=ambientColor[2];if(0!==r||0!==g||\n0!==ambientColor)r=new _three.Color(r,g,ambientColor),sceneGraph.add(new _three.AmbientLight(r,1))}}},{key:\"setupMorphMaterials\",value:function(){var scope=this;sceneGraph.traverse(function(child){child.isMesh&&child.geometry.morphAttributes.position&&child.geometry.morphAttributes.position.length&&(Array.isArray(child.material)?child.material.forEach(function(material,i){scope.setupMorphMaterial(child,material,i)}):scope.setupMorphMaterial(child,child.material))})}},{key:\"setupMorphMaterial\",value:function(child,\nmaterial,index){var uuid=child.uuid,matUuid=material.uuid,sharedMat=!1;sceneGraph.traverse(function(node){node.isMesh&&(Array.isArray(node.material)?node.material.forEach(function(mat){mat.uuid===matUuid&&node.uuid!==uuid&&(sharedMat=!0)}):node.material.uuid===matUuid&&node.uuid!==uuid&&(sharedMat=!0))});!0===sharedMat?(material=material.clone(),material.morphTargets=!0,void 0===index?child.material=material:child.material[index]=material):material.morphTargets=!0}}]);return FBXTreeParser}(),GeometryParser=\nfunction(){function GeometryParser(){_classCallCheck(this,GeometryParser)}_createClass(GeometryParser,[{key:\"parse\",value:function(deformers){var geometryMap=new Map;if(\"Geometry\"in fbxTree.Objects){var geoNodes=fbxTree.Objects.Geometry,nodeID;for(nodeID in geoNodes){var relationships=connections.get(parseInt(nodeID));relationships=this.parseGeometry(relationships,geoNodes[nodeID],deformers);geometryMap.set(parseInt(nodeID),relationships)}}return geometryMap}},{key:\"parseGeometry\",value:function(relationships,\ngeoNode,deformers){switch(geoNode.attrType){case \"Mesh\":return this.parseMeshGeometry(relationships,geoNode,deformers);case \"NurbsCurve\":return this.parseNurbsGeometry(geoNode)}}},{key:\"parseMeshGeometry\",value:function(relationships,geoNode,deformers){var skeletons=deformers.skeletons,morphTargets=[],modelNodes=relationships.parents.map(function(parent){return fbxTree.Objects.Model[parent.ID]});if(0!==modelNodes.length){var skeleton$jscomp$0=relationships.children.reduce(function(skeleton,child){void 0!==\nskeletons[child.ID]&&(skeleton=skeletons[child.ID]);return skeleton},null);relationships.children.forEach(function(child){void 0!==deformers.morphTargets[child.ID]&&morphTargets.push(deformers.morphTargets[child.ID])});relationships=modelNodes[0];modelNodes={};\"RotationOrder\"in relationships&&(modelNodes.eulerOrder=getEulerOrder(relationships.RotationOrder.value));\"InheritType\"in relationships&&(modelNodes.inheritType=parseInt(relationships.InheritType.value));\"GeometricTranslation\"in relationships&&\n(modelNodes.translation=relationships.GeometricTranslation.value);\"GeometricRotation\"in relationships&&(modelNodes.rotation=relationships.GeometricRotation.value);\"GeometricScaling\"in relationships&&(modelNodes.scale=relationships.GeometricScaling.value);relationships=generateTransform(modelNodes);return this.genGeometry(geoNode,skeleton$jscomp$0,morphTargets,relationships)}}},{key:\"genGeometry\",value:function(geoNode,skeleton,morphTargets,preTransform){var geo=new _three.BufferGeometry;geoNode.attrName&&\n(geo.name=geoNode.attrName);var geoInfo=this.parseGeoNode(geoNode,skeleton),buffers=this.genBuffers(geoInfo),positionAttribute=new _three.Float32BufferAttribute(buffers.vertex,3);positionAttribute.applyMatrix4(preTransform);geo.setAttribute(\"position\",positionAttribute);0<buffers.colors.length&&geo.setAttribute(\"color\",new _three.Float32BufferAttribute(buffers.colors,3));skeleton&&(geo.setAttribute(\"skinIndex\",new _three.Uint16BufferAttribute(buffers.weightsIndices,4)),geo.setAttribute(\"skinWeight\",\nnew _three.Float32BufferAttribute(buffers.vertexWeights,4)),geo.FBX_Deformer=skeleton);0<buffers.normal.length&&(skeleton=(new _three.Matrix3).getNormalMatrix(preTransform),positionAttribute=new _three.Float32BufferAttribute(buffers.normal,3),positionAttribute.applyNormalMatrix(skeleton),geo.setAttribute(\"normal\",positionAttribute));buffers.uvs.forEach(function(uvBuffer,i){uvBuffer=\"uv\"+(i+1).toString();0===i&&(uvBuffer=\"uv\");geo.setAttribute(uvBuffer,new _three.Float32BufferAttribute(buffers.uvs[i],\n2))});if(geoInfo.material&&\"AllSame\"!==geoInfo.material.mappingType){var prevMaterialIndex=buffers.materialIndex[0],startIndex=0;buffers.materialIndex.forEach(function(currentIndex,i){currentIndex!==prevMaterialIndex&&(geo.addGroup(startIndex,i-startIndex,prevMaterialIndex),prevMaterialIndex=currentIndex,startIndex=i)});0<geo.groups.length&&(geoInfo=geo.groups[geo.groups.length-1],geoInfo=geoInfo.start+geoInfo.count,geoInfo!==buffers.materialIndex.length&&geo.addGroup(geoInfo,buffers.materialIndex.length-\ngeoInfo,prevMaterialIndex));0===geo.groups.length&&geo.addGroup(0,buffers.materialIndex.length,buffers.materialIndex[0])}this.addMorphTargets(geo,geoNode,morphTargets,preTransform);return geo}},{key:\"parseGeoNode\",value:function(geoNode,skeleton){var geoInfo={};geoInfo.vertexPositions=void 0!==geoNode.Vertices?geoNode.Vertices.a:[];geoInfo.vertexIndices=void 0!==geoNode.PolygonVertexIndex?geoNode.PolygonVertexIndex.a:[];geoNode.LayerElementColor&&(geoInfo.color=this.parseVertexColors(geoNode.LayerElementColor[0]));\ngeoNode.LayerElementMaterial&&(geoInfo.material=this.parseMaterialIndices(geoNode.LayerElementMaterial[0]));geoNode.LayerElementNormal&&(geoInfo.normal=this.parseNormals(geoNode.LayerElementNormal[0]));if(geoNode.LayerElementUV){geoInfo.uv=[];for(var i$jscomp$0=0;geoNode.LayerElementUV[i$jscomp$0];)geoNode.LayerElementUV[i$jscomp$0].UV&&geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i$jscomp$0])),i$jscomp$0++}geoInfo.weightTable={};null!==skeleton&&(geoInfo.skeleton=skeleton,skeleton.rawBones.forEach(function(rawBone,\ni){rawBone.indices.forEach(function(index,j){void 0===geoInfo.weightTable[index]&&(geoInfo.weightTable[index]=[]);geoInfo.weightTable[index].push({id:i,weight:rawBone.weights[j]})})}));return geoInfo}},{key:\"genBuffers\",value:function(geoInfo){var buffers={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]},polygonIndex=0,faceLength=0,displayedWeightsWarning=!1,facePositionIndexes=[],faceNormals=[],faceColors=[],faceUVs=[],faceWeights=[],faceWeightIndices=[],\nscope=this;geoInfo.vertexIndices.forEach(function(vertexIndex,polygonVertexIndex){var materialIndex,endOfFace=!1;0>vertexIndex&&(vertexIndex^=-1,endOfFace=!0);var weightIndices=[],weights=[];facePositionIndexes.push(3*vertexIndex,3*vertexIndex+1,3*vertexIndex+2);if(geoInfo.color){var data=getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.color);faceColors.push(data[0],data[1],data[2])}if(geoInfo.skeleton){void 0!==geoInfo.weightTable[vertexIndex]&&geoInfo.weightTable[vertexIndex].forEach(function(wt){weights.push(wt.weight);\nweightIndices.push(wt.id)});if(4<weights.length){displayedWeightsWarning||(console.warn(\"THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.\"),displayedWeightsWarning=!0);var wIndex=[0,0,0,0],Weight=[0,0,0,0];weights.forEach(function(weight,weightIndex){var currentWeight=weight,currentIndex=weightIndices[weightIndex];Weight.forEach(function(comparedWeight,comparedWeightIndex,comparedWeightArray){currentWeight>comparedWeight&&(comparedWeightArray[comparedWeightIndex]=\ncurrentWeight,currentWeight=comparedWeight,comparedWeight=wIndex[comparedWeightIndex],wIndex[comparedWeightIndex]=currentIndex,currentIndex=comparedWeight)})});weightIndices=wIndex;weights=Weight}for(;4>weights.length;)weights.push(0),weightIndices.push(0);for(data=0;4>data;++data)faceWeights.push(weights[data]),faceWeightIndices.push(weightIndices[data])}geoInfo.normal&&(data=getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.normal),faceNormals.push(data[0],data[1],data[2]));geoInfo.material&&\n\"AllSame\"!==geoInfo.material.mappingType&&(materialIndex=getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.material)[0]);geoInfo.uv&&geoInfo.uv.forEach(function(uv,i){uv=getData(polygonVertexIndex,polygonIndex,vertexIndex,uv);void 0===faceUVs[i]&&(faceUVs[i]=[]);faceUVs[i].push(uv[0]);faceUVs[i].push(uv[1])});faceLength++;endOfFace&&(scope.genFace(buffers,geoInfo,facePositionIndexes,materialIndex,faceNormals,faceColors,faceUVs,faceWeights,faceWeightIndices,faceLength),polygonIndex++,faceLength=\n0,facePositionIndexes=[],faceNormals=[],faceColors=[],faceUVs=[],faceWeights=[],faceWeightIndices=[])});return buffers}},{key:\"genFace\",value:function(buffers,geoInfo,facePositionIndexes,materialIndex,faceNormals,faceColors,faceUVs,faceWeights,faceWeightIndices,faceLength){for(var _loop3=function(i){buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\nbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*(i-1)]]);buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*(i-1)+1]]);buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*(i-1)+2]]);buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*i]]);buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*i+1]]);buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[3*i+2]]);geoInfo.skeleton&&(buffers.vertexWeights.push(faceWeights[0]),\nbuffers.vertexWeights.push(faceWeights[1]),buffers.vertexWeights.push(faceWeights[2]),buffers.vertexWeights.push(faceWeights[3]),buffers.vertexWeights.push(faceWeights[4*(i-1)]),buffers.vertexWeights.push(faceWeights[4*(i-1)+1]),buffers.vertexWeights.push(faceWeights[4*(i-1)+2]),buffers.vertexWeights.push(faceWeights[4*(i-1)+3]),buffers.vertexWeights.push(faceWeights[4*i]),buffers.vertexWeights.push(faceWeights[4*i+1]),buffers.vertexWeights.push(faceWeights[4*i+2]),buffers.vertexWeights.push(faceWeights[4*\ni+3]),buffers.weightsIndices.push(faceWeightIndices[0]),buffers.weightsIndices.push(faceWeightIndices[1]),buffers.weightsIndices.push(faceWeightIndices[2]),buffers.weightsIndices.push(faceWeightIndices[3]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)+1]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)+2]),buffers.weightsIndices.push(faceWeightIndices[4*(i-1)+3]),buffers.weightsIndices.push(faceWeightIndices[4*i]),buffers.weightsIndices.push(faceWeightIndices[4*\ni+1]),buffers.weightsIndices.push(faceWeightIndices[4*i+2]),buffers.weightsIndices.push(faceWeightIndices[4*i+3]));geoInfo.color&&(buffers.colors.push(faceColors[0]),buffers.colors.push(faceColors[1]),buffers.colors.push(faceColors[2]),buffers.colors.push(faceColors[3*(i-1)]),buffers.colors.push(faceColors[3*(i-1)+1]),buffers.colors.push(faceColors[3*(i-1)+2]),buffers.colors.push(faceColors[3*i]),buffers.colors.push(faceColors[3*i+1]),buffers.colors.push(faceColors[3*i+2]));geoInfo.material&&\"AllSame\"!==\ngeoInfo.material.mappingType&&(buffers.materialIndex.push(materialIndex),buffers.materialIndex.push(materialIndex),buffers.materialIndex.push(materialIndex));geoInfo.normal&&(buffers.normal.push(faceNormals[0]),buffers.normal.push(faceNormals[1]),buffers.normal.push(faceNormals[2]),buffers.normal.push(faceNormals[3*(i-1)]),buffers.normal.push(faceNormals[3*(i-1)+1]),buffers.normal.push(faceNormals[3*(i-1)+2]),buffers.normal.push(faceNormals[3*i]),buffers.normal.push(faceNormals[3*i+1]),buffers.normal.push(faceNormals[3*\ni+2]));geoInfo.uv&&geoInfo.uv.forEach(function(uv,j){void 0===buffers.uvs[j]&&(buffers.uvs[j]=[]);buffers.uvs[j].push(faceUVs[j][0]);buffers.uvs[j].push(faceUVs[j][1]);buffers.uvs[j].push(faceUVs[j][2*(i-1)]);buffers.uvs[j].push(faceUVs[j][2*(i-1)+1]);buffers.uvs[j].push(faceUVs[j][2*i]);buffers.uvs[j].push(faceUVs[j][2*i+1])})},i$jscomp$0=2;i$jscomp$0<faceLength;i$jscomp$0++)_loop3(i$jscomp$0)}},{key:\"addMorphTargets\",value:function(parentGeo,parentGeoNode,morphTargets,preTransform){if(0!==morphTargets.length){parentGeo.morphTargetsRelative=\n!0;parentGeo.morphAttributes.position=[];var scope=this;morphTargets.forEach(function(morphTarget){morphTarget.rawTargets.forEach(function(rawTarget){var morphGeoNode=fbxTree.Objects.Geometry[rawTarget.geoID];void 0!==morphGeoNode&&scope.genMorphGeometry(parentGeo,parentGeoNode,morphGeoNode,preTransform,rawTarget.name)})})}}},{key:\"genMorphGeometry\",value:function(parentGeo,parentGeoNode,morphGeoNode,preTransform,name){parentGeoNode=void 0!==parentGeoNode.PolygonVertexIndex?parentGeoNode.PolygonVertexIndex.a:\n[];for(var morphPositionsSparse=void 0!==morphGeoNode.Vertices?morphGeoNode.Vertices.a:[],indices=void 0!==morphGeoNode.Indexes?morphGeoNode.Indexes.a:[],morphPositions=new Float32Array(3*parentGeo.attributes.position.count),i=0;i<indices.length;i++){var morphIndex=3*indices[i];morphPositions[morphIndex]=morphPositionsSparse[3*i];morphPositions[morphIndex+1]=morphPositionsSparse[3*i+1];morphPositions[morphIndex+2]=morphPositionsSparse[3*i+2]}parentGeoNode=this.genBuffers({vertexIndices:parentGeoNode,\nvertexPositions:morphPositions});parentGeoNode=new _three.Float32BufferAttribute(parentGeoNode.vertex,3);parentGeoNode.name=name||morphGeoNode.attrName;parentGeoNode.applyMatrix4(preTransform);parentGeo.morphAttributes.position.push(parentGeoNode)}},{key:\"parseNormals\",value:function(NormalNode){var mappingType=NormalNode.MappingInformationType,referenceType=NormalNode.ReferenceInformationType,buffer=NormalNode.Normals.a,indexBuffer=[];\"IndexToDirect\"===referenceType&&(\"NormalIndex\"in NormalNode?\nindexBuffer=NormalNode.NormalIndex.a:\"NormalsIndex\"in NormalNode&&(indexBuffer=NormalNode.NormalsIndex.a));return{dataSize:3,buffer,indices:indexBuffer,mappingType,referenceType}}},{key:\"parseUVs\",value:function(UVNode){var mappingType=UVNode.MappingInformationType,referenceType=UVNode.ReferenceInformationType,buffer=UVNode.UV.a,indexBuffer=[];\"IndexToDirect\"===referenceType&&(indexBuffer=UVNode.UVIndex.a);return{dataSize:2,buffer,indices:indexBuffer,mappingType,referenceType}}},{key:\"parseVertexColors\",\nvalue:function(ColorNode){var mappingType=ColorNode.MappingInformationType,referenceType=ColorNode.ReferenceInformationType,buffer=ColorNode.Colors.a,indexBuffer=[];\"IndexToDirect\"===referenceType&&(indexBuffer=ColorNode.ColorIndex.a);return{dataSize:4,buffer,indices:indexBuffer,mappingType,referenceType}}},{key:\"parseMaterialIndices\",value:function(MaterialNode){var mappingType=MaterialNode.MappingInformationType,referenceType=MaterialNode.ReferenceInformationType;if(\"NoMappingInformation\"===mappingType)return{dataSize:1,\nbuffer:[0],indices:[0],mappingType:\"AllSame\",referenceType};MaterialNode=MaterialNode.Materials.a;for(var materialIndices=[],i=0;i<MaterialNode.length;++i)materialIndices.push(i);return{dataSize:1,buffer:MaterialNode,indices:materialIndices,mappingType,referenceType}}},{key:\"parseNurbsGeometry\",value:function(geoNode){if(void 0===_NURBSCurve.NURBSCurve)return console.error(\"THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.\"),\nnew _three.BufferGeometry;var order=parseInt(geoNode.Order);if(isNaN(order))return console.error(\"THREE.FBXLoader: Invalid Order %s given for geometry ID: %s\",geoNode.Order,geoNode.id),new _three.BufferGeometry;--order;for(var knots=geoNode.KnotVector.a,controlPoints=[],pointsValues=geoNode.Points.a,i$jscomp$0=0,l=pointsValues.length;i$jscomp$0<l;i$jscomp$0+=4)controlPoints.push((new _three.Vector4).fromArray(pointsValues,i$jscomp$0));if(\"Closed\"===geoNode.Form)controlPoints.push(controlPoints[0]);\nelse if(\"Periodic\"===geoNode.Form){var startKnot=order;var endKnot=knots.length-1-startKnot;for(geoNode=0;geoNode<order;++geoNode)controlPoints.push(controlPoints[geoNode])}startKnot=(new _NURBSCurve.NURBSCurve(order,knots,controlPoints,startKnot,endKnot)).getPoints(7*controlPoints.length);var positions=new Float32Array(3*startKnot.length);startKnot.forEach(function(vertex,i){vertex.toArray(positions,3*i)});startKnot=new _three.BufferGeometry;startKnot.setAttribute(\"position\",new _three.BufferAttribute(positions,\n3));return startKnot}}]);return GeometryParser}(),AnimationParser=function(){function AnimationParser(){_classCallCheck(this,AnimationParser)}_createClass(AnimationParser,[{key:\"parse\",value:function(){var animationClips=[],rawClips=this.parseClips();if(void 0!==rawClips)for(var key in rawClips){var clip=this.addClip(rawClips[key]);animationClips.push(clip)}return animationClips}},{key:\"parseClips\",value:function(){if(void 0!==fbxTree.Objects.AnimationCurve){var curveNodesMap=this.parseAnimationCurveNodes();\nthis.parseAnimationCurves(curveNodesMap);curveNodesMap=this.parseAnimationLayers(curveNodesMap);return this.parseAnimStacks(curveNodesMap)}}},{key:\"parseAnimationCurveNodes\",value:function(){var rawCurveNodes=fbxTree.Objects.AnimationCurveNode,curveNodesMap=new Map,nodeID;for(nodeID in rawCurveNodes){var rawCurveNode=rawCurveNodes[nodeID];null!==rawCurveNode.attrName.match(/S|R|T|DeformPercent/)&&(rawCurveNode={id:rawCurveNode.id,attr:rawCurveNode.attrName,curves:{}},curveNodesMap.set(rawCurveNode.id,\nrawCurveNode))}return curveNodesMap}},{key:\"parseAnimationCurves\",value:function(curveNodesMap){var rawCurves=fbxTree.Objects.AnimationCurve,nodeID;for(nodeID in rawCurves){var animationCurve={id:rawCurves[nodeID].id,times:rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),values:rawCurves[nodeID].KeyValueFloat.a},relationships=connections.get(animationCurve.id);if(void 0!==relationships){var animationCurveID=relationships.parents[0].ID;relationships=relationships.parents[0].relationship;relationships.match(/X/)?\ncurveNodesMap.get(animationCurveID).curves.x=animationCurve:relationships.match(/Y/)?curveNodesMap.get(animationCurveID).curves.y=animationCurve:relationships.match(/Z/)?curveNodesMap.get(animationCurveID).curves.z=animationCurve:relationships.match(/d|DeformPercent/)&&curveNodesMap.has(animationCurveID)&&(curveNodesMap.get(animationCurveID).curves.morph=animationCurve)}}}},{key:\"parseAnimationLayers\",value:function(curveNodesMap){var rawLayers=fbxTree.Objects.AnimationLayer,layersMap=new Map,_loop4=\nfunction(nodeID){var layerCurveNodes=[],connection=connections.get(parseInt(nodeID));void 0!==connection&&(connection.children.forEach(function(child$jscomp$0,i){if(curveNodesMap.has(child$jscomp$0.ID)){var curveNode=curveNodesMap.get(child$jscomp$0.ID);if(void 0!==curveNode.curves.x||void 0!==curveNode.curves.y||void 0!==curveNode.curves.z){if(void 0===layerCurveNodes[i]){var modelID=connections.get(child$jscomp$0.ID).parents.filter(function(parent){return void 0!==parent.relationship})[0].ID;if(void 0!==\nmodelID){var rawModel=fbxTree.Objects.Model[modelID.toString()];if(void 0===rawModel){console.warn(\"THREE.FBXLoader: Encountered a unused curve.\",child$jscomp$0);return}var node={modelName:rawModel.attrName?_three.PropertyBinding.sanitizeNodeName(rawModel.attrName):\"\",ID:rawModel.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};sceneGraph.traverse(function(child){child.ID===rawModel.id&&(node.transform=child.matrix,child.userData.transformData&&(node.eulerOrder=child.userData.transformData.eulerOrder))});\nnode.transform||(node.transform=new _three.Matrix4);\"PreRotation\"in rawModel&&(node.preRotation=rawModel.PreRotation.value);\"PostRotation\"in rawModel&&(node.postRotation=rawModel.PostRotation.value);layerCurveNodes[i]=node}}layerCurveNodes[i]&&(layerCurveNodes[i][curveNode.attr]=curveNode)}else void 0!==curveNode.curves.morph&&(void 0===layerCurveNodes[i]&&(child$jscomp$0=connections.get(child$jscomp$0.ID).parents.filter(function(parent){return void 0!==parent.relationship})[0].ID,modelID=connections.get(child$jscomp$0).parents[0].ID,\nmodelID=connections.get(modelID).parents[0].ID,modelID=connections.get(modelID).parents[0].ID,modelID=fbxTree.Objects.Model[modelID],child$jscomp$0={modelName:modelID.attrName?_three.PropertyBinding.sanitizeNodeName(modelID.attrName):\"\",morphName:fbxTree.Objects.Deformer[child$jscomp$0].attrName},layerCurveNodes[i]=child$jscomp$0),layerCurveNodes[i][curveNode.attr]=curveNode)}}),layersMap.set(parseInt(nodeID),layerCurveNodes))},nodeID$jscomp$0;for(nodeID$jscomp$0 in rawLayers)_loop4(nodeID$jscomp$0);\nreturn layersMap}},{key:\"parseAnimStacks\",value:function(layersMap){var rawStacks=fbxTree.Objects.AnimationStack,rawClips={},nodeID;for(nodeID in rawStacks){var children=connections.get(parseInt(nodeID)).children;1<children.length&&console.warn(\"THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.\");children=layersMap.get(children[0].ID);rawClips[nodeID]={name:rawStacks[nodeID].attrName,layer:children}}return rawClips}},\n{key:\"addClip\",value:function(rawClip){var tracks=[],scope=this;rawClip.layer.forEach(function(rawTracks){tracks=tracks.concat(scope.generateTracks(rawTracks))});return new _three.AnimationClip(rawClip.name,-1,tracks)}},{key:\"generateTracks\",value:function(rawTracks){var tracks=[],initialPosition=new _three.Vector3,initialRotation=new _three.Quaternion,initialScale=new _three.Vector3;rawTracks.transform&&rawTracks.transform.decompose(initialPosition,initialRotation,initialScale);initialPosition=initialPosition.toArray();\ninitialRotation=(new _three.Euler).setFromQuaternion(initialRotation,rawTracks.eulerOrder).toArray();initialScale=initialScale.toArray();void 0!==rawTracks.T&&0<Object.keys(rawTracks.T.curves).length&&(initialPosition=this.generateVectorTrack(rawTracks.modelName,rawTracks.T.curves,initialPosition,\"position\"),void 0!==initialPosition&&tracks.push(initialPosition));void 0!==rawTracks.R&&0<Object.keys(rawTracks.R.curves).length&&(initialRotation=this.generateRotationTrack(rawTracks.modelName,rawTracks.R.curves,\ninitialRotation,rawTracks.preRotation,rawTracks.postRotation,rawTracks.eulerOrder),void 0!==initialRotation&&tracks.push(initialRotation));void 0!==rawTracks.S&&0<Object.keys(rawTracks.S.curves).length&&(initialScale=this.generateVectorTrack(rawTracks.modelName,rawTracks.S.curves,initialScale,\"scale\"),void 0!==initialScale&&tracks.push(initialScale));void 0!==rawTracks.DeformPercent&&(rawTracks=this.generateMorphTrack(rawTracks),void 0!==rawTracks&&tracks.push(rawTracks));return tracks}},{key:\"generateVectorTrack\",\nvalue:function(modelName,curves,initialValue,type){var times=this.getTimesForAllAxes(curves);curves=this.getKeyframeTrackValues(times,curves,initialValue);return new _three.VectorKeyframeTrack(modelName+\".\"+type,times,curves)}},{key:\"generateRotationTrack\",value:function(modelName,curves,initialValue,preRotation,postRotation,eulerOrder){void 0!==curves.x&&(this.interpolateRotations(curves.x),curves.x.values=curves.x.values.map(_three.MathUtils.degToRad));void 0!==curves.y&&(this.interpolateRotations(curves.y),\ncurves.y.values=curves.y.values.map(_three.MathUtils.degToRad));void 0!==curves.z&&(this.interpolateRotations(curves.z),curves.z.values=curves.z.values.map(_three.MathUtils.degToRad));var times=this.getTimesForAllAxes(curves);curves=this.getKeyframeTrackValues(times,curves,initialValue);void 0!==preRotation&&(preRotation=preRotation.map(_three.MathUtils.degToRad),preRotation.push(eulerOrder),preRotation=(new _three.Euler).fromArray(preRotation),preRotation=(new _three.Quaternion).setFromEuler(preRotation));\nvoid 0!==postRotation&&(postRotation=postRotation.map(_three.MathUtils.degToRad),postRotation.push(eulerOrder),postRotation=(new _three.Euler).fromArray(postRotation),postRotation=(new _three.Quaternion).setFromEuler(postRotation).invert());initialValue=new _three.Quaternion;for(var euler=new _three.Euler,quaternionValues=[],i=0;i<curves.length;i+=3)euler.set(curves[i],curves[i+1],curves[i+2],eulerOrder),initialValue.setFromEuler(euler),void 0!==preRotation&&initialValue.premultiply(preRotation),\nvoid 0!==postRotation&&initialValue.multiply(postRotation),initialValue.toArray(quaternionValues,i/3*4);return new _three.QuaternionKeyframeTrack(modelName+\".quaternion\",times,quaternionValues)}},{key:\"generateMorphTrack\",value:function(rawTracks){var curves=rawTracks.DeformPercent.curves.morph,values=curves.values.map(function(val){return val/100}),morphNum=sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];return new _three.NumberKeyframeTrack(rawTracks.modelName+\n\".morphTargetInfluences[\"+morphNum+\"]\",curves.times,values)}},{key:\"getTimesForAllAxes\",value:function(curves){var times=[];void 0!==curves.x&&(times=times.concat(curves.x.times));void 0!==curves.y&&(times=times.concat(curves.y.times));void 0!==curves.z&&(times=times.concat(curves.z.times));times=times.sort(function(a,b){return a-b});if(1<times.length){curves=1;for(var lastValue=times[0],i=1;i<times.length;i++){var currentValue=times[i];currentValue!==lastValue&&(lastValue=times[curves]=currentValue,\ncurves++)}times=times.slice(0,curves)}return times}},{key:\"getKeyframeTrackValues\",value:function(times,curves,initialValue){var values=[],xIndex=-1,yIndex=-1,zIndex=-1;times.forEach(function(time){curves.x&&(xIndex=curves.x.times.indexOf(time));curves.y&&(yIndex=curves.y.times.indexOf(time));curves.z&&(zIndex=curves.z.times.indexOf(time));-1!==xIndex?(time=curves.x.values[xIndex],values.push(time),initialValue[0]=time):values.push(initialValue[0]);-1!==yIndex?(time=curves.y.values[yIndex],values.push(time),\ninitialValue[1]=time):values.push(initialValue[1]);-1!==zIndex?(time=curves.z.values[zIndex],values.push(time),initialValue[2]=time):values.push(initialValue[2])});return values}},{key:\"interpolateRotations\",value:function(curve){for(var i=1;i<curve.values.length;i++){var initialValue=curve.values[i-1],valuesSpan=curve.values[i]-initialValue,absoluteSpan=Math.abs(valuesSpan);if(180<=absoluteSpan){absoluteSpan/=180;valuesSpan/=absoluteSpan;initialValue+=valuesSpan;var initialTime=curve.times[i-1];\nabsoluteSpan=(curve.times[i]-initialTime)/absoluteSpan;initialTime+=absoluteSpan;for(var interpolatedTimes=[],interpolatedValues=[];initialTime<curve.times[i];)interpolatedTimes.push(initialTime),initialTime+=absoluteSpan,interpolatedValues.push(initialValue),initialValue+=valuesSpan;curve.times=inject(curve.times,i,interpolatedTimes);curve.values=inject(curve.values,i,interpolatedValues)}}}}]);return AnimationParser}(),TextParser=function(){function TextParser(){_classCallCheck(this,TextParser)}\n_createClass(TextParser,[{key:\"getPrevNode\",value:function(){return this.nodeStack[this.currentIndent-2]}},{key:\"getCurrentNode\",value:function(){return this.nodeStack[this.currentIndent-1]}},{key:\"getCurrentProp\",value:function(){return this.currentProp}},{key:\"pushStack\",value:function(node){this.nodeStack.push(node);this.currentIndent+=1}},{key:\"popStack\",value:function(){this.nodeStack.pop();--this.currentIndent}},{key:\"setCurrentProp\",value:function(val,name){this.currentProp=val;this.currentPropName=\nname}},{key:\"parse\",value:function(text){this.currentIndent=0;this.allNodes=new FBXTree;this.nodeStack=[];this.currentProp=[];this.currentPropName=\"\";var scope=this,split=text.split(/[\\r\\n]+/);split.forEach(function(line,i){var matchComment=line.match(/^[\\s\\t]*;/),matchEmpty=line.match(/^[\\s\\t]*$/);if(!matchComment&&!matchEmpty){matchComment=line.match(\"^\\\\t{\"+scope.currentIndent+\"}(\\\\w+):(.*){\",\"\");matchEmpty=line.match(\"^\\\\t{\"+scope.currentIndent+\"}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)\");var matchEnd=line.match(\"^\\\\t{\"+\n(scope.currentIndent-1)+\"}}\");matchComment?scope.parseNodeBegin(line,matchComment):matchEmpty?scope.parseNodeProperty(line,matchEmpty,split[++i]):matchEnd?scope.popStack():line.match(/^[^\\s\\t}]/)&&scope.parseNodePropertyContinued(line)}});return this.allNodes}},{key:\"parseNodeBegin\",value:function(line,property){line=property[1].trim().replace(/^\"/,\"\").replace(/\"$/,\"\");var nodeAttrs=property[2].split(\",\").map(function(attr){return attr.trim().replace(/^\"/,\"\").replace(/\"$/,\"\")});property={name:line};\nnodeAttrs=this.parseNodeAttr(nodeAttrs);var currentNode=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(line,property):line in currentNode?(\"PoseNode\"===line?currentNode.PoseNode.push(property):void 0!==currentNode[line].id&&(currentNode[line]={},currentNode[line][currentNode[line].id]=currentNode[line]),\"\"!==nodeAttrs.id&&(currentNode[line][nodeAttrs.id]=property)):\"number\"===typeof nodeAttrs.id?(currentNode[line]={},currentNode[line][nodeAttrs.id]=property):\"Properties70\"!==line&&\n(currentNode[line]=\"PoseNode\"===line?[property]:property);\"number\"===typeof nodeAttrs.id&&(property.id=nodeAttrs.id);\"\"!==nodeAttrs.name&&(property.attrName=nodeAttrs.name);\"\"!==nodeAttrs.type&&(property.attrType=nodeAttrs.type);this.pushStack(property)}},{key:\"parseNodeAttr\",value:function(attrs){var id=attrs[0];\"\"!==attrs[0]&&(id=parseInt(attrs[0]),isNaN(id)&&(id=attrs[0]));var name=\"\",type=\"\";1<attrs.length&&(name=attrs[1].replace(/^(\\w+)::/,\"\"),type=attrs[2]);return{id,name,type}}},{key:\"parseNodeProperty\",\nvalue:function(line,property,contentLine){var propName=property[1].replace(/^\"/,\"\").replace(/\"$/,\"\").trim();property=property[2].replace(/^\"/,\"\").replace(/\"$/,\"\").trim();\"Content\"===propName&&\",\"===property&&(property=contentLine.replace(/\"/g,\"\").replace(/,$/,\"\").trim());contentLine=this.getCurrentNode();if(\"Properties70\"===contentLine.name)this.parseNodeSpecialProperty(line,propName,property);else{if(\"C\"===propName){propName=property.split(\",\").slice(1);line=parseInt(propName[0]);var to=parseInt(propName[1]),\nrest=property.split(\",\").slice(3);rest=rest.map(function(elem){return elem.trim().replace(/^\"/,\"\")});propName=\"connections\";property=[line,to];append(property,rest);void 0===contentLine[propName]&&(contentLine[propName]=[])}\"Node\"===propName&&(contentLine.id=property);propName in contentLine&&Array.isArray(contentLine[propName])?contentLine[propName].push(property):\"a\"!==propName?contentLine[propName]=property:contentLine.a=property;this.setCurrentProp(contentLine,propName);\"a\"===propName&&\",\"!==\nproperty.slice(-1)&&(contentLine.a=parseNumberArray(property))}}},{key:\"parseNodePropertyContinued\",value:function(line){var currentNode=this.getCurrentNode();currentNode.a+=line;\",\"!==line.slice(-1)&&(currentNode.a=parseNumberArray(currentNode.a))}},{key:\"parseNodeSpecialProperty\",value:function(line,propName,propValue){var props=propValue.split('\",').map(function(prop){return prop.trim().replace(/^\"/,\"\").replace(/\\s/,\"_\")});line=props[0];propName=props[1];propValue=props[2];var innerPropFlag=props[3];\nprops=props[4];switch(propName){case \"int\":case \"enum\":case \"bool\":case \"ULongLong\":case \"double\":case \"Number\":case \"FieldOfView\":props=parseFloat(props);break;case \"Color\":case \"ColorRGB\":case \"Vector3D\":case \"Lcl_Translation\":case \"Lcl_Rotation\":case \"Lcl_Scaling\":props=parseNumberArray(props)}this.getPrevNode()[line]={type:propName,type2:propValue,flag:innerPropFlag,value:props};this.setCurrentProp(this.getPrevNode(),line)}}]);return TextParser}(),BinaryParser=function(){function BinaryParser(){_classCallCheck(this,\nBinaryParser)}_createClass(BinaryParser,[{key:\"parse\",value:function(buffer){buffer=new BinaryReader(buffer);buffer.skip(23);var version=buffer.getUint32();if(6400>version)throw Error(\"THREE.FBXLoader: FBX version not supported, FileVersion: \"+version);for(var allNodes=new FBXTree;!this.endOfContent(buffer);){var node=this.parseNode(buffer,version);null!==node&&allNodes.add(node.name,node)}return allNodes}},{key:\"endOfContent\",value:function(reader){return 0===reader.size()%16?(reader.getOffset()+\n160+16&-16)>=reader.size():reader.getOffset()+160+16>=reader.size()}},{key:\"parseNode\",value:function(reader,version){var node={},endOffset=7500<=version?reader.getUint64():reader.getUint32(),numProperties=7500<=version?reader.getUint64():reader.getUint32();7500<=version?reader.getUint64():reader.getUint32();var nameLen=reader.getUint8();nameLen=reader.getString(nameLen);if(0===endOffset)return null;for(var propertyList=[],i=0;i<numProperties;i++)propertyList.push(this.parseProperty(reader));i=0<\npropertyList.length?propertyList[0]:\"\";var attrName=1<propertyList.length?propertyList[1]:\"\",attrType=2<propertyList.length?propertyList[2]:\"\";for(node.singleProperty=1===numProperties&&reader.getOffset()===endOffset?!0:!1;endOffset>reader.getOffset();)numProperties=this.parseNode(reader,version),null!==numProperties&&this.parseSubNode(nameLen,node,numProperties);node.propertyList=propertyList;\"number\"===typeof i&&(node.id=i);\"\"!==attrName&&(node.attrName=attrName);\"\"!==attrType&&(node.attrType=attrType);\n\"\"!==nameLen&&(node.name=nameLen);return node}},{key:\"parseSubNode\",value:function(name,node,subNode){if(!0===subNode.singleProperty)name=subNode.propertyList[0],Array.isArray(name)?(node[subNode.name]=subNode,subNode.a=name):node[subNode.name]=name;else if(\"Connections\"===name&&\"C\"===subNode.name){var array=[];subNode.propertyList.forEach(function(property,i){0!==i&&array.push(property)});void 0===node.connections&&(node.connections=[]);node.connections.push(array)}else if(\"Properties70\"===subNode.name)Object.keys(subNode).forEach(function(key){node[key]=\nsubNode[key]});else if(\"Properties70\"===name&&\"P\"===subNode.name){name=subNode.propertyList[0];var innerPropType1=subNode.propertyList[1],innerPropType2=subNode.propertyList[2],innerPropFlag=subNode.propertyList[3];0===name.indexOf(\"Lcl \")&&(name=name.replace(\"Lcl \",\"Lcl_\"));0===innerPropType1.indexOf(\"Lcl \")&&(innerPropType1=innerPropType1.replace(\"Lcl \",\"Lcl_\"));var innerPropValue=\"Color\"===innerPropType1||\"ColorRGB\"===innerPropType1||\"Vector\"===innerPropType1||\"Vector3D\"===innerPropType1||0===\ninnerPropType1.indexOf(\"Lcl_\")?[subNode.propertyList[4],subNode.propertyList[5],subNode.propertyList[6]]:subNode.propertyList[4];node[name]={type:innerPropType1,type2:innerPropType2,flag:innerPropFlag,value:innerPropValue}}else void 0===node[subNode.name]?\"number\"===typeof subNode.id?(node[subNode.name]={},node[subNode.name][subNode.id]=subNode):node[subNode.name]=subNode:\"PoseNode\"===subNode.name?(Array.isArray(node[subNode.name])||(node[subNode.name]=[node[subNode.name]]),node[subNode.name].push(subNode)):\nvoid 0===node[subNode.name][subNode.id]&&(node[subNode.name][subNode.id]=subNode)}},{key:\"parseProperty\",value:function(reader){var type=reader.getString(1);switch(type){case \"C\":return reader.getBoolean();case \"D\":return reader.getFloat64();case \"F\":return reader.getFloat32();case \"I\":return reader.getInt32();case \"L\":return reader.getInt64();case \"R\":return type=reader.getUint32(),reader.getArrayBuffer(type);case \"S\":return type=reader.getUint32(),reader.getString(type);case \"Y\":return reader.getInt16();\ncase \"b\":case \"c\":case \"d\":case \"f\":case \"i\":case \"l\":var arrayLength=reader.getUint32(),encoding=reader.getUint32(),compressedLength=reader.getUint32();if(0===encoding)switch(type){case \"b\":case \"c\":return reader.getBooleanArray(arrayLength);case \"d\":return reader.getFloat64Array(arrayLength);case \"f\":return reader.getFloat32Array(arrayLength);case \"i\":return reader.getInt32Array(arrayLength);case \"l\":return reader.getInt64Array(arrayLength)}reader=(0,_fflate.unzlibSync)(new Uint8Array(reader.getArrayBuffer(compressedLength)));\nreader=new BinaryReader(reader.buffer);switch(type){case \"b\":case \"c\":return reader.getBooleanArray(arrayLength);case \"d\":return reader.getFloat64Array(arrayLength);case \"f\":return reader.getFloat32Array(arrayLength);case \"i\":return reader.getInt32Array(arrayLength);case \"l\":return reader.getInt64Array(arrayLength)}default:throw Error(\"THREE.FBXLoader: Unknown property type \"+type);}}}]);return BinaryParser}(),BinaryReader=function(){function BinaryReader(buffer,littleEndian){_classCallCheck(this,\nBinaryReader);this.dv=new DataView(buffer);this.offset=0;this.littleEndian=void 0!==littleEndian?littleEndian:!0}_createClass(BinaryReader,[{key:\"getOffset\",value:function(){return this.offset}},{key:\"size\",value:function(){return this.dv.buffer.byteLength}},{key:\"skip\",value:function(length){this.offset+=length}},{key:\"getBoolean\",value:function(){return 1===(this.getUint8()&1)}},{key:\"getBooleanArray\",value:function(size){for(var a=[],i=0;i<size;i++)a.push(this.getBoolean());return a}},{key:\"getUint8\",\nvalue:function(){var value=this.dv.getUint8(this.offset);this.offset+=1;return value}},{key:\"getInt16\",value:function(){var value=this.dv.getInt16(this.offset,this.littleEndian);this.offset+=2;return value}},{key:\"getInt32\",value:function(){var value=this.dv.getInt32(this.offset,this.littleEndian);this.offset+=4;return value}},{key:\"getInt32Array\",value:function(size){for(var a=[],i=0;i<size;i++)a.push(this.getInt32());return a}},{key:\"getUint32\",value:function(){var value=this.dv.getUint32(this.offset,\nthis.littleEndian);this.offset+=4;return value}},{key:\"getInt64\",value:function(){if(this.littleEndian){var low=this.getUint32();var high=this.getUint32()}else high=this.getUint32(),low=this.getUint32();return high&2147483648?(high=~high&4294967295,low=~low&4294967295,4294967295===low&&(high=high+1&4294967295),-(4294967296*high+(low+1&4294967295))):4294967296*high+low}},{key:\"getInt64Array\",value:function(size){for(var a=[],i=0;i<size;i++)a.push(this.getInt64());return a}},{key:\"getUint64\",value:function(){if(this.littleEndian){var low=\nthis.getUint32();var high=this.getUint32()}else high=this.getUint32(),low=this.getUint32();return 4294967296*high+low}},{key:\"getFloat32\",value:function(){var value=this.dv.getFloat32(this.offset,this.littleEndian);this.offset+=4;return value}},{key:\"getFloat32Array\",value:function(size){for(var a=[],i=0;i<size;i++)a.push(this.getFloat32());return a}},{key:\"getFloat64\",value:function(){var value=this.dv.getFloat64(this.offset,this.littleEndian);this.offset+=8;return value}},{key:\"getFloat64Array\",\nvalue:function(size){for(var a=[],i=0;i<size;i++)a.push(this.getFloat64());return a}},{key:\"getArrayBuffer\",value:function(size){var value=this.dv.buffer.slice(this.offset,this.offset+size);this.offset+=size;return value}},{key:\"getString\",value:function(size){for(var a=[],i=0;i<size;i++)a[i]=this.getUint8();size=a.indexOf(0);0<=size&&(a=a.slice(0,size));return _three.LoaderUtils.decodeText(new Uint8Array(a))}}]);return BinaryReader}(),FBXTree=function(){function FBXTree(){_classCallCheck(this,FBXTree)}\n_createClass(FBXTree,[{key:\"add\",value:function(key,val){this[key]=val}}]);return FBXTree}(),dataArray=[],tempEuler=new _three.Euler,tempVec=new _three.Vector3}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$FBXLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FBXLoader = void 0;\n\nvar _three = require(\"three\");\n\nvar _fflate = require(\"fflate\");\n\nvar _NURBSCurve = require(\"../curves/NURBSCurve.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\nvar fbxTree;\nvar connections;\nvar sceneGraph;\n\nvar FBXLoader =\n/*#__PURE__*/\nfunction (_Loader) {\n  _inherits(FBXLoader, _Loader);\n\n  function FBXLoader(manager) {\n    _classCallCheck(this, FBXLoader);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FBXLoader).call(this, manager));\n  }\n\n  _createClass(FBXLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? _three.LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new _three.FileLoader(this.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(FBXBuffer, path) {\n      if (isFbxFormatBinary(FBXBuffer)) {\n        fbxTree = new BinaryParser().parse(FBXBuffer);\n      } else {\n        var FBXText = convertArrayBufferToString(FBXBuffer);\n\n        if (!isFbxFormatASCII(FBXText)) {\n          throw new Error('THREE.FBXLoader: Unknown format.');\n        }\n\n        if (getFbxVersion(FBXText) < 7000) {\n          throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\n        }\n\n        fbxTree = new TextParser().parse(FBXText);\n      } // console.log( fbxTree );\n\n\n      var textureLoader = new _three.TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);\n    }\n  }]);\n\n  return FBXLoader;\n}(_three.Loader); // Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\n\n\nexports.FBXLoader = FBXLoader;\n\nvar FBXTreeParser =\n/*#__PURE__*/\nfunction () {\n  function FBXTreeParser(textureLoader, manager) {\n    _classCallCheck(this, FBXTreeParser);\n\n    this.textureLoader = textureLoader;\n    this.manager = manager;\n  }\n\n  _createClass(FBXTreeParser, [{\n    key: \"parse\",\n    value: function parse() {\n      connections = this.parseConnections();\n      var images = this.parseImages();\n      var textures = this.parseTextures(images);\n      var materials = this.parseMaterials(textures);\n      var deformers = this.parseDeformers();\n      var geometryMap = new GeometryParser().parse(deformers);\n      this.parseScene(deformers, geometryMap, materials);\n      return sceneGraph;\n    } // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n    // and details the connection type\n\n  }, {\n    key: \"parseConnections\",\n    value: function parseConnections() {\n      var connectionMap = new Map();\n\n      if ('Connections' in fbxTree) {\n        var rawConnections = fbxTree.Connections.connections;\n        rawConnections.forEach(function (rawConnection) {\n          var fromID = rawConnection[0];\n          var toID = rawConnection[1];\n          var relationship = rawConnection[2];\n\n          if (!connectionMap.has(fromID)) {\n            connectionMap.set(fromID, {\n              parents: [],\n              children: []\n            });\n          }\n\n          var parentRelationship = {\n            ID: toID,\n            relationship: relationship\n          };\n          connectionMap.get(fromID).parents.push(parentRelationship);\n\n          if (!connectionMap.has(toID)) {\n            connectionMap.set(toID, {\n              parents: [],\n              children: []\n            });\n          }\n\n          var childRelationship = {\n            ID: fromID,\n            relationship: relationship\n          };\n          connectionMap.get(toID).children.push(childRelationship);\n        });\n      }\n\n      return connectionMap;\n    } // Parse FBXTree.Objects.Video for embedded image data\n    // These images are connected to textures in FBXTree.Objects.Textures\n    // via FBXTree.Connections.\n\n  }, {\n    key: \"parseImages\",\n    value: function parseImages() {\n      var images = {};\n      var blobs = {};\n\n      if ('Video' in fbxTree.Objects) {\n        var videoNodes = fbxTree.Objects.Video;\n\n        for (var nodeID in videoNodes) {\n          var videoNode = videoNodes[nodeID];\n          var id = parseInt(nodeID);\n          images[id] = videoNode.RelativeFilename || videoNode.Filename; // raw image data is in videoNode.Content\n\n          if ('Content' in videoNode) {\n            var arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n            var base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';\n\n            if (arrayBufferContent || base64Content) {\n              var image = this.parseImage(videoNodes[nodeID]);\n              blobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n            }\n          }\n        }\n      }\n\n      for (var _id in images) {\n        var filename = images[_id];\n        if (blobs[filename] !== undefined) images[_id] = blobs[filename];else images[_id] = images[_id].split('\\\\').pop();\n      }\n\n      return images;\n    } // Parse embedded image data in FBXTree.Video.Content\n\n  }, {\n    key: \"parseImage\",\n    value: function parseImage(videoNode) {\n      var content = videoNode.Content;\n      var fileName = videoNode.RelativeFilename || videoNode.Filename;\n      var extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n      var type;\n\n      switch (extension) {\n        case 'bmp':\n          type = 'image/bmp';\n          break;\n\n        case 'jpg':\n        case 'jpeg':\n          type = 'image/jpeg';\n          break;\n\n        case 'png':\n          type = 'image/png';\n          break;\n\n        case 'tif':\n          type = 'image/tiff';\n          break;\n\n        case 'tga':\n          if (this.manager.getHandler('.tga') === null) {\n            console.warn('FBXLoader: TGA loader not found, skipping ', fileName);\n          }\n\n          type = 'image/tga';\n          break;\n\n        default:\n          console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n          return;\n      }\n\n      if (typeof content === 'string') {\n        // ASCII format\n        return 'data:' + type + ';base64,' + content;\n      } else {\n        // Binary Format\n        var array = new Uint8Array(content);\n        return window.URL.createObjectURL(new Blob([array], {\n          type: type\n        }));\n      }\n    } // Parse nodes in FBXTree.Objects.Texture\n    // These contain details such as UV scaling, cropping, rotation etc and are connected\n    // to images in FBXTree.Objects.Video\n\n  }, {\n    key: \"parseTextures\",\n    value: function parseTextures(images) {\n      var textureMap = new Map();\n\n      if ('Texture' in fbxTree.Objects) {\n        var textureNodes = fbxTree.Objects.Texture;\n\n        for (var nodeID in textureNodes) {\n          var texture = this.parseTexture(textureNodes[nodeID], images);\n          textureMap.set(parseInt(nodeID), texture);\n        }\n      }\n\n      return textureMap;\n    } // Parse individual node in FBXTree.Objects.Texture\n\n  }, {\n    key: \"parseTexture\",\n    value: function parseTexture(textureNode, images) {\n      var texture = this.loadTexture(textureNode, images);\n      texture.ID = textureNode.id;\n      texture.name = textureNode.attrName;\n      var wrapModeU = textureNode.WrapModeU;\n      var wrapModeV = textureNode.WrapModeV;\n      var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n      var valueV = wrapModeV !== undefined ? wrapModeV.value : 0; // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n      // 0: repeat(default), 1: clamp\n\n      texture.wrapS = valueU === 0 ? _three.RepeatWrapping : _three.ClampToEdgeWrapping;\n      texture.wrapT = valueV === 0 ? _three.RepeatWrapping : _three.ClampToEdgeWrapping;\n\n      if ('Scaling' in textureNode) {\n        var values = textureNode.Scaling.value;\n        texture.repeat.x = values[0];\n        texture.repeat.y = values[1];\n      }\n\n      return texture;\n    } // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture(textureNode, images) {\n      var fileName;\n      var currentPath = this.textureLoader.path;\n      var children = connections.get(textureNode.id).children;\n\n      if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n        fileName = images[children[0].ID];\n\n        if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n          this.textureLoader.setPath(undefined);\n        }\n      }\n\n      var texture;\n      var extension = textureNode.FileName.slice(-3).toLowerCase();\n\n      if (extension === 'tga') {\n        var loader = this.manager.getHandler('.tga');\n\n        if (loader === null) {\n          console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename);\n          texture = new _three.Texture();\n        } else {\n          texture = loader.load(fileName);\n        }\n      } else if (extension === 'psd') {\n        console.warn('FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename);\n        texture = new _three.Texture();\n      } else {\n        texture = this.textureLoader.load(fileName);\n      }\n\n      this.textureLoader.setPath(currentPath);\n      return texture;\n    } // Parse nodes in FBXTree.Objects.Material\n\n  }, {\n    key: \"parseMaterials\",\n    value: function parseMaterials(textureMap) {\n      var materialMap = new Map();\n\n      if ('Material' in fbxTree.Objects) {\n        var materialNodes = fbxTree.Objects.Material;\n\n        for (var nodeID in materialNodes) {\n          var material = this.parseMaterial(materialNodes[nodeID], textureMap);\n          if (material !== null) materialMap.set(parseInt(nodeID), material);\n        }\n      }\n\n      return materialMap;\n    } // Parse single node in FBXTree.Objects.Material\n    // Materials are connected to texture maps in FBXTree.Objects.Textures\n    // FBX format currently only supports Lambert and Phong shading models\n\n  }, {\n    key: \"parseMaterial\",\n    value: function parseMaterial(materialNode, textureMap) {\n      var ID = materialNode.id;\n      var name = materialNode.attrName;\n      var type = materialNode.ShadingModel; // Case where FBX wraps shading model in property object.\n\n      if (_typeof(type) === 'object') {\n        type = type.value;\n      } // Ignore unused materials which don't have any connections.\n\n\n      if (!connections.has(ID)) return null;\n      var parameters = this.parseParameters(materialNode, textureMap, ID);\n      var material;\n\n      switch (type.toLowerCase()) {\n        case 'phong':\n          material = new _three.MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new _three.MeshLambertMaterial();\n          break;\n\n        default:\n          console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n          material = new _three.MeshPhongMaterial();\n          break;\n      }\n\n      material.setValues(parameters);\n      material.name = name;\n      return material;\n    } // Parse FBX material and return parameters suitable for a three.js material\n    // Also parse the texture map and return any textures associated with the material\n\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(materialNode, textureMap, ID) {\n      var parameters = {};\n\n      if (materialNode.BumpFactor) {\n        parameters.bumpScale = materialNode.BumpFactor.value;\n      }\n\n      if (materialNode.Diffuse) {\n        parameters.color = new _three.Color().fromArray(materialNode.Diffuse.value);\n      } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')) {\n        // The blender exporter exports diffuse here instead of in materialNode.Diffuse\n        parameters.color = new _three.Color().fromArray(materialNode.DiffuseColor.value);\n      }\n\n      if (materialNode.DisplacementFactor) {\n        parameters.displacementScale = materialNode.DisplacementFactor.value;\n      }\n\n      if (materialNode.Emissive) {\n        parameters.emissive = new _three.Color().fromArray(materialNode.Emissive.value);\n      } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')) {\n        // The blender exporter exports emissive color here instead of in materialNode.Emissive\n        parameters.emissive = new _three.Color().fromArray(materialNode.EmissiveColor.value);\n      }\n\n      if (materialNode.EmissiveFactor) {\n        parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);\n      }\n\n      if (materialNode.Opacity) {\n        parameters.opacity = parseFloat(materialNode.Opacity.value);\n      }\n\n      if (parameters.opacity < 1.0) {\n        parameters.transparent = true;\n      }\n\n      if (materialNode.ReflectionFactor) {\n        parameters.reflectivity = materialNode.ReflectionFactor.value;\n      }\n\n      if (materialNode.Shininess) {\n        parameters.shininess = materialNode.Shininess.value;\n      }\n\n      if (materialNode.Specular) {\n        parameters.specular = new _three.Color().fromArray(materialNode.Specular.value);\n      } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {\n        // The blender exporter exports specular color here instead of in materialNode.Specular\n        parameters.specular = new _three.Color().fromArray(materialNode.SpecularColor.value);\n      }\n\n      var scope = this;\n      connections.get(ID).children.forEach(function (child) {\n        var type = child.relationship;\n\n        switch (type) {\n          case 'Bump':\n            parameters.bumpMap = scope.getTexture(textureMap, child.ID);\n            break;\n\n          case 'Maya|TEX_ao_map':\n            parameters.aoMap = scope.getTexture(textureMap, child.ID);\n            break;\n\n          case 'DiffuseColor':\n          case 'Maya|TEX_color_map':\n            parameters.map = scope.getTexture(textureMap, child.ID);\n            parameters.map.encoding = _three.sRGBEncoding;\n            break;\n\n          case 'DisplacementColor':\n            parameters.displacementMap = scope.getTexture(textureMap, child.ID);\n            break;\n\n          case 'EmissiveColor':\n            parameters.emissiveMap = scope.getTexture(textureMap, child.ID);\n            parameters.emissiveMap.encoding = _three.sRGBEncoding;\n            break;\n\n          case 'NormalMap':\n          case 'Maya|TEX_normal_map':\n            parameters.normalMap = scope.getTexture(textureMap, child.ID);\n            break;\n\n          case 'ReflectionColor':\n            parameters.envMap = scope.getTexture(textureMap, child.ID);\n            parameters.envMap.mapping = _three.EquirectangularReflectionMapping;\n            parameters.envMap.encoding = _three.sRGBEncoding;\n            break;\n\n          case 'SpecularColor':\n            parameters.specularMap = scope.getTexture(textureMap, child.ID);\n            parameters.specularMap.encoding = _three.sRGBEncoding;\n            break;\n\n          case 'TransparentColor':\n          case 'TransparencyFactor':\n            parameters.alphaMap = scope.getTexture(textureMap, child.ID);\n            parameters.transparent = true;\n            break;\n\n          case 'AmbientColor':\n          case 'ShininessExponent': // AKA glossiness map\n\n          case 'SpecularFactor': // AKA specularLevel\n\n          case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\n          default:\n            console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\n            break;\n        }\n      });\n      return parameters;\n    } // get a texture from the textureMap for use by a material.\n\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(textureMap, id) {\n      // if the texture is a layered texture, just use the first layer and issue a warning\n      if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {\n        console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');\n        id = connections.get(id).children[0].ID;\n      }\n\n      return textureMap.get(id);\n    } // Parse nodes in FBXTree.Objects.Deformer\n    // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n    // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\n  }, {\n    key: \"parseDeformers\",\n    value: function parseDeformers() {\n      var skeletons = {};\n      var morphTargets = {};\n\n      if ('Deformer' in fbxTree.Objects) {\n        var DeformerNodes = fbxTree.Objects.Deformer;\n\n        for (var nodeID in DeformerNodes) {\n          var deformerNode = DeformerNodes[nodeID];\n          var relationships = connections.get(parseInt(nodeID));\n\n          if (deformerNode.attrType === 'Skin') {\n            var skeleton = this.parseSkeleton(relationships, DeformerNodes);\n            skeleton.ID = nodeID;\n\n            if (relationships.parents.length > 1) {\n              console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');\n            }\n\n            skeleton.geometryID = relationships.parents[0].ID;\n            skeletons[nodeID] = skeleton;\n          } else if (deformerNode.attrType === 'BlendShape') {\n            var morphTarget = {\n              id: nodeID\n            };\n            morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);\n            morphTarget.id = nodeID;\n\n            if (relationships.parents.length > 1) {\n              console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');\n            }\n\n            morphTargets[nodeID] = morphTarget;\n          }\n        }\n      }\n\n      return {\n        skeletons: skeletons,\n        morphTargets: morphTargets\n      };\n    } // Parse single nodes in FBXTree.Objects.Deformer\n    // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n    // Each skin node represents a skeleton and each cluster node represents a bone\n\n  }, {\n    key: \"parseSkeleton\",\n    value: function parseSkeleton(relationships, deformerNodes) {\n      var rawBones = [];\n      relationships.children.forEach(function (child) {\n        var boneNode = deformerNodes[child.ID];\n        if (boneNode.attrType !== 'Cluster') return;\n        var rawBone = {\n          ID: child.ID,\n          indices: [],\n          weights: [],\n          transformLink: new _three.Matrix4().fromArray(boneNode.TransformLink.a) // transform: new Matrix4().fromArray( boneNode.Transform.a ),\n          // linkMode: boneNode.Mode,\n\n        };\n\n        if ('Indexes' in boneNode) {\n          rawBone.indices = boneNode.Indexes.a;\n          rawBone.weights = boneNode.Weights.a;\n        }\n\n        rawBones.push(rawBone);\n      });\n      return {\n        rawBones: rawBones,\n        bones: []\n      };\n    } // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\n  }, {\n    key: \"parseMorphTargets\",\n    value: function parseMorphTargets(relationships, deformerNodes) {\n      var rawMorphTargets = [];\n\n      for (var i = 0; i < relationships.children.length; i++) {\n        var child = relationships.children[i];\n        var morphTargetNode = deformerNodes[child.ID];\n        var rawMorphTarget = {\n          name: morphTargetNode.attrName,\n          initialWeight: morphTargetNode.DeformPercent,\n          id: morphTargetNode.id,\n          fullWeights: morphTargetNode.FullWeights.a\n        };\n        if (morphTargetNode.attrType !== 'BlendShapeChannel') return;\n        rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {\n          return child.relationship === undefined;\n        })[0].ID;\n        rawMorphTargets.push(rawMorphTarget);\n      }\n\n      return rawMorphTargets;\n    } // create the main Group() to be returned by the loader\n\n  }, {\n    key: \"parseScene\",\n    value: function parseScene(deformers, geometryMap, materialMap) {\n      sceneGraph = new _three.Group();\n      var modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);\n      var modelNodes = fbxTree.Objects.Model;\n      var scope = this;\n      modelMap.forEach(function (model) {\n        var modelNode = modelNodes[model.ID];\n        scope.setLookAtProperties(model, modelNode);\n        var parentConnections = connections.get(model.ID).parents;\n        parentConnections.forEach(function (connection) {\n          var parent = modelMap.get(connection.ID);\n          if (parent !== undefined) parent.add(model);\n        });\n\n        if (model.parent === null) {\n          sceneGraph.add(model);\n        }\n      });\n      this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);\n      this.createAmbientLight();\n      this.setupMorphMaterials();\n      sceneGraph.traverse(function (node) {\n        if (node.userData.transformData) {\n          if (node.parent) {\n            node.userData.transformData.parentMatrix = node.parent.matrix;\n            node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n          }\n\n          var transform = generateTransform(node.userData.transformData);\n          node.applyMatrix4(transform);\n          node.updateWorldMatrix();\n        }\n      });\n      var animations = new AnimationParser().parse(); // if all the models where already combined in a single group, just return that\n\n      if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\n        sceneGraph.children[0].animations = animations;\n        sceneGraph = sceneGraph.children[0];\n      }\n\n      sceneGraph.animations = animations;\n    } // parse nodes in FBXTree.Objects.Model\n\n  }, {\n    key: \"parseModels\",\n    value: function parseModels(skeletons, geometryMap, materialMap) {\n      var modelMap = new Map();\n      var modelNodes = fbxTree.Objects.Model;\n\n      for (var nodeID in modelNodes) {\n        var id = parseInt(nodeID);\n        var node = modelNodes[nodeID];\n        var relationships = connections.get(id);\n        var model = this.buildSkeleton(relationships, skeletons, id, node.attrName);\n\n        if (!model) {\n          switch (node.attrType) {\n            case 'Camera':\n              model = this.createCamera(relationships);\n              break;\n\n            case 'Light':\n              model = this.createLight(relationships);\n              break;\n\n            case 'Mesh':\n              model = this.createMesh(relationships, geometryMap, materialMap);\n              break;\n\n            case 'NurbsCurve':\n              model = this.createCurve(relationships, geometryMap);\n              break;\n\n            case 'LimbNode':\n            case 'Root':\n              model = new _three.Bone();\n              break;\n\n            case 'Null':\n            default:\n              model = new _three.Group();\n              break;\n          }\n\n          model.name = node.attrName ? _three.PropertyBinding.sanitizeNodeName(node.attrName) : '';\n          model.ID = id;\n        }\n\n        this.getTransformData(model, node);\n        modelMap.set(id, model);\n      }\n\n      return modelMap;\n    }\n  }, {\n    key: \"buildSkeleton\",\n    value: function buildSkeleton(relationships, skeletons, id, name) {\n      var bone = null;\n      relationships.parents.forEach(function (parent) {\n        var _loop = function _loop(ID) {\n          var skeleton = skeletons[ID];\n          skeleton.rawBones.forEach(function (rawBone, i) {\n            if (rawBone.ID === parent.ID) {\n              var subBone = bone;\n              bone = new _three.Bone();\n              bone.matrixWorld.copy(rawBone.transformLink); // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n              bone.name = name ? _three.PropertyBinding.sanitizeNodeName(name) : '';\n              bone.ID = id;\n              skeleton.bones[i] = bone; // In cases where a bone is shared between multiple meshes\n              // duplicate the bone here and and it as a child of the first bone\n\n              if (subBone !== null) {\n                bone.add(subBone);\n              }\n            }\n          });\n        };\n\n        for (var ID in skeletons) {\n          _loop(ID);\n        }\n      });\n      return bone;\n    } // create a PerspectiveCamera or OrthographicCamera\n\n  }, {\n    key: \"createCamera\",\n    value: function createCamera(relationships) {\n      var model;\n      var cameraAttribute;\n      relationships.children.forEach(function (child) {\n        var attr = fbxTree.Objects.NodeAttribute[child.ID];\n\n        if (attr !== undefined) {\n          cameraAttribute = attr;\n        }\n      });\n\n      if (cameraAttribute === undefined) {\n        model = new _three.Object3D();\n      } else {\n        var type = 0;\n\n        if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n          type = 1;\n        }\n\n        var nearClippingPlane = 1;\n\n        if (cameraAttribute.NearPlane !== undefined) {\n          nearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n        }\n\n        var farClippingPlane = 1000;\n\n        if (cameraAttribute.FarPlane !== undefined) {\n          farClippingPlane = cameraAttribute.FarPlane.value / 1000;\n        }\n\n        var width = window.innerWidth;\n        var height = window.innerHeight;\n\n        if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n          width = cameraAttribute.AspectWidth.value;\n          height = cameraAttribute.AspectHeight.value;\n        }\n\n        var aspect = width / height;\n        var fov = 45;\n\n        if (cameraAttribute.FieldOfView !== undefined) {\n          fov = cameraAttribute.FieldOfView.value;\n        }\n\n        var focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n        switch (type) {\n          case 0:\n            // Perspective\n            model = new _three.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n            if (focalLength !== null) model.setFocalLength(focalLength);\n            break;\n\n          case 1:\n            // Orthographic\n            model = new _three.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n            break;\n\n          default:\n            console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\n            model = new _three.Object3D();\n            break;\n        }\n      }\n\n      return model;\n    } // Create a DirectionalLight, PointLight or SpotLight\n\n  }, {\n    key: \"createLight\",\n    value: function createLight(relationships) {\n      var model;\n      var lightAttribute;\n      relationships.children.forEach(function (child) {\n        var attr = fbxTree.Objects.NodeAttribute[child.ID];\n\n        if (attr !== undefined) {\n          lightAttribute = attr;\n        }\n      });\n\n      if (lightAttribute === undefined) {\n        model = new _three.Object3D();\n      } else {\n        var type; // LightType can be undefined for Point lights\n\n        if (lightAttribute.LightType === undefined) {\n          type = 0;\n        } else {\n          type = lightAttribute.LightType.value;\n        }\n\n        var color = 0xffffff;\n\n        if (lightAttribute.Color !== undefined) {\n          color = new _three.Color().fromArray(lightAttribute.Color.value);\n        }\n\n        var intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100; // light disabled\n\n        if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n          intensity = 0;\n        }\n\n        var distance = 0;\n\n        if (lightAttribute.FarAttenuationEnd !== undefined) {\n          if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n            distance = 0;\n          } else {\n            distance = lightAttribute.FarAttenuationEnd.value;\n          }\n        } // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\n\n        var decay = 1;\n\n        switch (type) {\n          case 0:\n            // Point\n            model = new _three.PointLight(color, intensity, distance, decay);\n            break;\n\n          case 1:\n            // Directional\n            model = new _three.DirectionalLight(color, intensity);\n            break;\n\n          case 2:\n            // Spot\n            var angle = Math.PI / 3;\n\n            if (lightAttribute.InnerAngle !== undefined) {\n              angle = _three.MathUtils.degToRad(lightAttribute.InnerAngle.value);\n            }\n\n            var penumbra = 0;\n\n            if (lightAttribute.OuterAngle !== undefined) {\n              // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n              // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n              // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n              penumbra = _three.MathUtils.degToRad(lightAttribute.OuterAngle.value);\n              penumbra = Math.max(penumbra, 1);\n            }\n\n            model = new _three.SpotLight(color, intensity, distance, angle, penumbra, decay);\n            break;\n\n          default:\n            console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.');\n            model = new _three.PointLight(color, intensity);\n            break;\n        }\n\n        if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n          model.castShadow = true;\n        }\n      }\n\n      return model;\n    }\n  }, {\n    key: \"createMesh\",\n    value: function createMesh(relationships, geometryMap, materialMap) {\n      var model;\n      var geometry = null;\n      var material = null;\n      var materials = []; // get geometry and materials(s) from connections\n\n      relationships.children.forEach(function (child) {\n        if (geometryMap.has(child.ID)) {\n          geometry = geometryMap.get(child.ID);\n        }\n\n        if (materialMap.has(child.ID)) {\n          materials.push(materialMap.get(child.ID));\n        }\n      });\n\n      if (materials.length > 1) {\n        material = materials;\n      } else if (materials.length > 0) {\n        material = materials[0];\n      } else {\n        material = new _three.MeshPhongMaterial({\n          color: 0xcccccc\n        });\n        materials.push(material);\n      }\n\n      if ('color' in geometry.attributes) {\n        materials.forEach(function (material) {\n          material.vertexColors = true;\n        });\n      }\n\n      if (geometry.FBX_Deformer) {\n        materials.forEach(function (material) {\n          material.skinning = true;\n        });\n        model = new _three.SkinnedMesh(geometry, material);\n        model.normalizeSkinWeights();\n      } else {\n        model = new _three.Mesh(geometry, material);\n      }\n\n      return model;\n    }\n  }, {\n    key: \"createCurve\",\n    value: function createCurve(relationships, geometryMap) {\n      var geometry = relationships.children.reduce(function (geo, child) {\n        if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\n        return geo;\n      }, null); // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\n      var material = new _three.LineBasicMaterial({\n        color: 0x3300ff,\n        linewidth: 1\n      });\n      return new _three.Line(geometry, material);\n    } // parse the model node for transform data\n\n  }, {\n    key: \"getTransformData\",\n    value: function getTransformData(model, modelNode) {\n      var transformData = {};\n      if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\n      if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);else transformData.eulerOrder = 'ZYX';\n      if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value;\n      if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value;\n      if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;\n      if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value;\n      if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;\n      if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;\n      if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;\n      if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;\n      if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;\n      model.userData.transformData = transformData;\n    }\n  }, {\n    key: \"setLookAtProperties\",\n    value: function setLookAtProperties(model, modelNode) {\n      if ('LookAtProperty' in modelNode) {\n        var children = connections.get(model.ID).children;\n        children.forEach(function (child) {\n          if (child.relationship === 'LookAtProperty') {\n            var lookAtTarget = fbxTree.Objects.Model[child.ID];\n\n            if ('Lcl_Translation' in lookAtTarget) {\n              var pos = lookAtTarget.Lcl_Translation.value; // DirectionalLight, SpotLight\n\n              if (model.target !== undefined) {\n                model.target.position.fromArray(pos);\n                sceneGraph.add(model.target);\n              } else {\n                // Cameras and other Object3Ds\n                model.lookAt(new _three.Vector3().fromArray(pos));\n              }\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: \"bindSkeleton\",\n    value: function bindSkeleton(skeletons, geometryMap, modelMap) {\n      var bindMatrices = this.parsePoseNodes();\n\n      var _loop2 = function _loop2(ID) {\n        var skeleton = skeletons[ID];\n        var parents = connections.get(parseInt(skeleton.ID)).parents;\n        parents.forEach(function (parent) {\n          if (geometryMap.has(parent.ID)) {\n            var geoID = parent.ID;\n            var geoRelationships = connections.get(geoID);\n            geoRelationships.parents.forEach(function (geoConnParent) {\n              if (modelMap.has(geoConnParent.ID)) {\n                var model = modelMap.get(geoConnParent.ID);\n                model.bind(new _three.Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\n              }\n            });\n          }\n        });\n      };\n\n      for (var ID in skeletons) {\n        _loop2(ID);\n      }\n    }\n  }, {\n    key: \"parsePoseNodes\",\n    value: function parsePoseNodes() {\n      var bindMatrices = {};\n\n      if ('Pose' in fbxTree.Objects) {\n        var BindPoseNode = fbxTree.Objects.Pose;\n\n        for (var nodeID in BindPoseNode) {\n          if (BindPoseNode[nodeID].attrType === 'BindPose') {\n            var poseNodes = BindPoseNode[nodeID].PoseNode;\n\n            if (Array.isArray(poseNodes)) {\n              poseNodes.forEach(function (poseNode) {\n                bindMatrices[poseNode.Node] = new _three.Matrix4().fromArray(poseNode.Matrix.a);\n              });\n            } else {\n              bindMatrices[poseNodes.Node] = new _three.Matrix4().fromArray(poseNodes.Matrix.a);\n            }\n          }\n        }\n      }\n\n      return bindMatrices;\n    } // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\n  }, {\n    key: \"createAmbientLight\",\n    value: function createAmbientLight() {\n      if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {\n        var ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n        var r = ambientColor[0];\n        var g = ambientColor[1];\n        var b = ambientColor[2];\n\n        if (r !== 0 || g !== 0 || b !== 0) {\n          var color = new _three.Color(r, g, b);\n          sceneGraph.add(new _three.AmbientLight(color, 1));\n        }\n      }\n    }\n  }, {\n    key: \"setupMorphMaterials\",\n    value: function setupMorphMaterials() {\n      var scope = this;\n      sceneGraph.traverse(function (child) {\n        if (child.isMesh) {\n          if (child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length) {\n            if (Array.isArray(child.material)) {\n              child.material.forEach(function (material, i) {\n                scope.setupMorphMaterial(child, material, i);\n              });\n            } else {\n              scope.setupMorphMaterial(child, child.material);\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"setupMorphMaterial\",\n    value: function setupMorphMaterial(child, material, index) {\n      var uuid = child.uuid;\n      var matUuid = material.uuid; // if a geometry has morph targets, it cannot share the material with other geometries\n\n      var sharedMat = false;\n      sceneGraph.traverse(function (node) {\n        if (node.isMesh) {\n          if (Array.isArray(node.material)) {\n            node.material.forEach(function (mat) {\n              if (mat.uuid === matUuid && node.uuid !== uuid) sharedMat = true;\n            });\n          } else if (node.material.uuid === matUuid && node.uuid !== uuid) {\n            sharedMat = true;\n          }\n        }\n      });\n\n      if (sharedMat === true) {\n        var clonedMat = material.clone();\n        clonedMat.morphTargets = true;\n        if (index === undefined) child.material = clonedMat;else child.material[index] = clonedMat;\n      } else {\n        material.morphTargets = true;\n      }\n    }\n  }]);\n\n  return FBXTreeParser;\n}(); // parse Geometry data from FBXTree and return map of BufferGeometries\n\n\nvar GeometryParser =\n/*#__PURE__*/\nfunction () {\n  function GeometryParser() {\n    _classCallCheck(this, GeometryParser);\n  }\n\n  _createClass(GeometryParser, [{\n    key: \"parse\",\n    // Parse nodes in FBXTree.Objects.Geometry\n    value: function parse(deformers) {\n      var geometryMap = new Map();\n\n      if ('Geometry' in fbxTree.Objects) {\n        var geoNodes = fbxTree.Objects.Geometry;\n\n        for (var nodeID in geoNodes) {\n          var relationships = connections.get(parseInt(nodeID));\n          var geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);\n          geometryMap.set(parseInt(nodeID), geo);\n        }\n      }\n\n      return geometryMap;\n    } // Parse single node in FBXTree.Objects.Geometry\n\n  }, {\n    key: \"parseGeometry\",\n    value: function parseGeometry(relationships, geoNode, deformers) {\n      switch (geoNode.attrType) {\n        case 'Mesh':\n          return this.parseMeshGeometry(relationships, geoNode, deformers);\n\n        case 'NurbsCurve':\n          return this.parseNurbsGeometry(geoNode);\n      }\n    } // Parse single node mesh geometry in FBXTree.Objects.Geometry\n\n  }, {\n    key: \"parseMeshGeometry\",\n    value: function parseMeshGeometry(relationships, geoNode, deformers) {\n      var skeletons = deformers.skeletons;\n      var morphTargets = [];\n      var modelNodes = relationships.parents.map(function (parent) {\n        return fbxTree.Objects.Model[parent.ID];\n      }); // don't create geometry if it is not associated with any models\n\n      if (modelNodes.length === 0) return;\n      var skeleton = relationships.children.reduce(function (skeleton, child) {\n        if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\n        return skeleton;\n      }, null);\n      relationships.children.forEach(function (child) {\n        if (deformers.morphTargets[child.ID] !== undefined) {\n          morphTargets.push(deformers.morphTargets[child.ID]);\n        }\n      }); // Assume one model and get the preRotation from that\n      // if there is more than one model associated with the geometry this may cause problems\n\n      var modelNode = modelNodes[0];\n      var transformData = {};\n      if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);\n      if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\n      if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value;\n      if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value;\n      if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value;\n      var transform = generateTransform(transformData);\n      return this.genGeometry(geoNode, skeleton, morphTargets, transform);\n    } // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n\n  }, {\n    key: \"genGeometry\",\n    value: function genGeometry(geoNode, skeleton, morphTargets, preTransform) {\n      var geo = new _three.BufferGeometry();\n      if (geoNode.attrName) geo.name = geoNode.attrName;\n      var geoInfo = this.parseGeoNode(geoNode, skeleton);\n      var buffers = this.genBuffers(geoInfo);\n      var positionAttribute = new _three.Float32BufferAttribute(buffers.vertex, 3);\n      positionAttribute.applyMatrix4(preTransform);\n      geo.setAttribute('position', positionAttribute);\n\n      if (buffers.colors.length > 0) {\n        geo.setAttribute('color', new _three.Float32BufferAttribute(buffers.colors, 3));\n      }\n\n      if (skeleton) {\n        geo.setAttribute('skinIndex', new _three.Uint16BufferAttribute(buffers.weightsIndices, 4));\n        geo.setAttribute('skinWeight', new _three.Float32BufferAttribute(buffers.vertexWeights, 4)); // used later to bind the skeleton to the model\n\n        geo.FBX_Deformer = skeleton;\n      }\n\n      if (buffers.normal.length > 0) {\n        var normalMatrix = new _three.Matrix3().getNormalMatrix(preTransform);\n        var normalAttribute = new _three.Float32BufferAttribute(buffers.normal, 3);\n        normalAttribute.applyNormalMatrix(normalMatrix);\n        geo.setAttribute('normal', normalAttribute);\n      }\n\n      buffers.uvs.forEach(function (uvBuffer, i) {\n        // subsequent uv buffers are called 'uv1', 'uv2', ...\n        var name = 'uv' + (i + 1).toString(); // the first uv buffer is just called 'uv'\n\n        if (i === 0) {\n          name = 'uv';\n        }\n\n        geo.setAttribute(name, new _three.Float32BufferAttribute(buffers.uvs[i], 2));\n      });\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        // Convert the material indices of each vertex into rendering groups on the geometry.\n        var prevMaterialIndex = buffers.materialIndex[0];\n        var startIndex = 0;\n        buffers.materialIndex.forEach(function (currentIndex, i) {\n          if (currentIndex !== prevMaterialIndex) {\n            geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n            prevMaterialIndex = currentIndex;\n            startIndex = i;\n          }\n        }); // the loop above doesn't add the last group, do that here.\n\n        if (geo.groups.length > 0) {\n          var lastGroup = geo.groups[geo.groups.length - 1];\n          var lastIndex = lastGroup.start + lastGroup.count;\n\n          if (lastIndex !== buffers.materialIndex.length) {\n            geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n          }\n        } // case where there are multiple materials but the whole geometry is only\n        // using one of them\n\n\n        if (geo.groups.length === 0) {\n          geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n        }\n      }\n\n      this.addMorphTargets(geo, geoNode, morphTargets, preTransform);\n      return geo;\n    }\n  }, {\n    key: \"parseGeoNode\",\n    value: function parseGeoNode(geoNode, skeleton) {\n      var geoInfo = {};\n      geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\n      geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\n\n      if (geoNode.LayerElementColor) {\n        geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);\n      }\n\n      if (geoNode.LayerElementMaterial) {\n        geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);\n      }\n\n      if (geoNode.LayerElementNormal) {\n        geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);\n      }\n\n      if (geoNode.LayerElementUV) {\n        geoInfo.uv = [];\n        var i = 0;\n\n        while (geoNode.LayerElementUV[i]) {\n          if (geoNode.LayerElementUV[i].UV) {\n            geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));\n          }\n\n          i++;\n        }\n      }\n\n      geoInfo.weightTable = {};\n\n      if (skeleton !== null) {\n        geoInfo.skeleton = skeleton;\n        skeleton.rawBones.forEach(function (rawBone, i) {\n          // loop over the bone's vertex indices and weights\n          rawBone.indices.forEach(function (index, j) {\n            if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\n            geoInfo.weightTable[index].push({\n              id: i,\n              weight: rawBone.weights[j]\n            });\n          });\n        });\n      }\n\n      return geoInfo;\n    }\n  }, {\n    key: \"genBuffers\",\n    value: function genBuffers(geoInfo) {\n      var buffers = {\n        vertex: [],\n        normal: [],\n        colors: [],\n        uvs: [],\n        materialIndex: [],\n        vertexWeights: [],\n        weightsIndices: []\n      };\n      var polygonIndex = 0;\n      var faceLength = 0;\n      var displayedWeightsWarning = false; // these will hold data for a single face\n\n      var facePositionIndexes = [];\n      var faceNormals = [];\n      var faceColors = [];\n      var faceUVs = [];\n      var faceWeights = [];\n      var faceWeightIndices = [];\n      var scope = this;\n      geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n        var materialIndex;\n        var endOfFace = false; // Face index and vertex index arrays are combined in a single array\n        // A cube with quad faces looks like this:\n        // PolygonVertexIndex: *24 {\n        //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n        //  }\n        // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n        // to find index of last vertex bit shift the index: ^ - 1\n\n        if (vertexIndex < 0) {\n          vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n\n          endOfFace = true;\n        }\n\n        var weightIndices = [];\n        var weights = [];\n        facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n\n        if (geoInfo.color) {\n          var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n          faceColors.push(data[0], data[1], data[2]);\n        }\n\n        if (geoInfo.skeleton) {\n          if (geoInfo.weightTable[vertexIndex] !== undefined) {\n            geoInfo.weightTable[vertexIndex].forEach(function (wt) {\n              weights.push(wt.weight);\n              weightIndices.push(wt.id);\n            });\n          }\n\n          if (weights.length > 4) {\n            if (!displayedWeightsWarning) {\n              console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\n              displayedWeightsWarning = true;\n            }\n\n            var wIndex = [0, 0, 0, 0];\n            var Weight = [0, 0, 0, 0];\n            weights.forEach(function (weight, weightIndex) {\n              var currentWeight = weight;\n              var currentIndex = weightIndices[weightIndex];\n              Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n                if (currentWeight > comparedWeight) {\n                  comparedWeightArray[comparedWeightIndex] = currentWeight;\n                  currentWeight = comparedWeight;\n                  var tmp = wIndex[comparedWeightIndex];\n                  wIndex[comparedWeightIndex] = currentIndex;\n                  currentIndex = tmp;\n                }\n              });\n            });\n            weightIndices = wIndex;\n            weights = Weight;\n          } // if the weight array is shorter than 4 pad with 0s\n\n\n          while (weights.length < 4) {\n            weights.push(0);\n            weightIndices.push(0);\n          }\n\n          for (var i = 0; i < 4; ++i) {\n            faceWeights.push(weights[i]);\n            faceWeightIndices.push(weightIndices[i]);\n          }\n        }\n\n        if (geoInfo.normal) {\n          var _data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n\n          faceNormals.push(_data[0], _data[1], _data[2]);\n        }\n\n        if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n          materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n        }\n\n        if (geoInfo.uv) {\n          geoInfo.uv.forEach(function (uv, i) {\n            var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n\n            if (faceUVs[i] === undefined) {\n              faceUVs[i] = [];\n            }\n\n            faceUVs[i].push(data[0]);\n            faceUVs[i].push(data[1]);\n          });\n        }\n\n        faceLength++;\n\n        if (endOfFace) {\n          scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\n          polygonIndex++;\n          faceLength = 0; // reset arrays for the next face\n\n          facePositionIndexes = [];\n          faceNormals = [];\n          faceColors = [];\n          faceUVs = [];\n          faceWeights = [];\n          faceWeightIndices = [];\n        }\n      });\n      return buffers;\n    } // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\n  }, {\n    key: \"genFace\",\n    value: function genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n      var _loop3 = function _loop3(i) {\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\n\n        if (geoInfo.skeleton) {\n          buffers.vertexWeights.push(faceWeights[0]);\n          buffers.vertexWeights.push(faceWeights[1]);\n          buffers.vertexWeights.push(faceWeights[2]);\n          buffers.vertexWeights.push(faceWeights[3]);\n          buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\n          buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\n          buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\n          buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\n          buffers.vertexWeights.push(faceWeights[i * 4]);\n          buffers.vertexWeights.push(faceWeights[i * 4 + 1]);\n          buffers.vertexWeights.push(faceWeights[i * 4 + 2]);\n          buffers.vertexWeights.push(faceWeights[i * 4 + 3]);\n          buffers.weightsIndices.push(faceWeightIndices[0]);\n          buffers.weightsIndices.push(faceWeightIndices[1]);\n          buffers.weightsIndices.push(faceWeightIndices[2]);\n          buffers.weightsIndices.push(faceWeightIndices[3]);\n          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\n          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\n          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\n          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\n          buffers.weightsIndices.push(faceWeightIndices[i * 4]);\n          buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\n          buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\n          buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\n        }\n\n        if (geoInfo.color) {\n          buffers.colors.push(faceColors[0]);\n          buffers.colors.push(faceColors[1]);\n          buffers.colors.push(faceColors[2]);\n          buffers.colors.push(faceColors[(i - 1) * 3]);\n          buffers.colors.push(faceColors[(i - 1) * 3 + 1]);\n          buffers.colors.push(faceColors[(i - 1) * 3 + 2]);\n          buffers.colors.push(faceColors[i * 3]);\n          buffers.colors.push(faceColors[i * 3 + 1]);\n          buffers.colors.push(faceColors[i * 3 + 2]);\n        }\n\n        if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n          buffers.materialIndex.push(materialIndex);\n          buffers.materialIndex.push(materialIndex);\n          buffers.materialIndex.push(materialIndex);\n        }\n\n        if (geoInfo.normal) {\n          buffers.normal.push(faceNormals[0]);\n          buffers.normal.push(faceNormals[1]);\n          buffers.normal.push(faceNormals[2]);\n          buffers.normal.push(faceNormals[(i - 1) * 3]);\n          buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\n          buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\n          buffers.normal.push(faceNormals[i * 3]);\n          buffers.normal.push(faceNormals[i * 3 + 1]);\n          buffers.normal.push(faceNormals[i * 3 + 2]);\n        }\n\n        if (geoInfo.uv) {\n          geoInfo.uv.forEach(function (uv, j) {\n            if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\n            buffers.uvs[j].push(faceUVs[j][0]);\n            buffers.uvs[j].push(faceUVs[j][1]);\n            buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\n            buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n            buffers.uvs[j].push(faceUVs[j][i * 2]);\n            buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\n          });\n        }\n      };\n\n      for (var i = 2; i < faceLength; i++) {\n        _loop3(i);\n      }\n    }\n  }, {\n    key: \"addMorphTargets\",\n    value: function addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\n      if (morphTargets.length === 0) return;\n      parentGeo.morphTargetsRelative = true;\n      parentGeo.morphAttributes.position = []; // parentGeo.morphAttributes.normal = []; // not implemented\n\n      var scope = this;\n      morphTargets.forEach(function (morphTarget) {\n        morphTarget.rawTargets.forEach(function (rawTarget) {\n          var morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];\n\n          if (morphGeoNode !== undefined) {\n            scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);\n          }\n        });\n      });\n    } // a morph geometry node is similar to a standard  node, and the node is also contained\n    // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n    // and a special attribute Index defining which vertices of the original geometry are affected\n    // Normal and position attributes only have data for the vertices that are affected by the morph\n\n  }, {\n    key: \"genMorphGeometry\",\n    value: function genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\n      var vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];\n      var morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\n      var indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\n      var length = parentGeo.attributes.position.count * 3;\n      var morphPositions = new Float32Array(length);\n\n      for (var i = 0; i < indices.length; i++) {\n        var morphIndex = indices[i] * 3;\n        morphPositions[morphIndex] = morphPositionsSparse[i * 3];\n        morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];\n        morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];\n      } // TODO: add morph normal support\n\n\n      var morphGeoInfo = {\n        vertexIndices: vertexIndices,\n        vertexPositions: morphPositions\n      };\n      var morphBuffers = this.genBuffers(morphGeoInfo);\n      var positionAttribute = new _three.Float32BufferAttribute(morphBuffers.vertex, 3);\n      positionAttribute.name = name || morphGeoNode.attrName;\n      positionAttribute.applyMatrix4(preTransform);\n      parentGeo.morphAttributes.position.push(positionAttribute);\n    } // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\n  }, {\n    key: \"parseNormals\",\n    value: function parseNormals(NormalNode) {\n      var mappingType = NormalNode.MappingInformationType;\n      var referenceType = NormalNode.ReferenceInformationType;\n      var buffer = NormalNode.Normals.a;\n      var indexBuffer = [];\n\n      if (referenceType === 'IndexToDirect') {\n        if ('NormalIndex' in NormalNode) {\n          indexBuffer = NormalNode.NormalIndex.a;\n        } else if ('NormalsIndex' in NormalNode) {\n          indexBuffer = NormalNode.NormalsIndex.a;\n        }\n      }\n\n      return {\n        dataSize: 3,\n        buffer: buffer,\n        indices: indexBuffer,\n        mappingType: mappingType,\n        referenceType: referenceType\n      };\n    } // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\n  }, {\n    key: \"parseUVs\",\n    value: function parseUVs(UVNode) {\n      var mappingType = UVNode.MappingInformationType;\n      var referenceType = UVNode.ReferenceInformationType;\n      var buffer = UVNode.UV.a;\n      var indexBuffer = [];\n\n      if (referenceType === 'IndexToDirect') {\n        indexBuffer = UVNode.UVIndex.a;\n      }\n\n      return {\n        dataSize: 2,\n        buffer: buffer,\n        indices: indexBuffer,\n        mappingType: mappingType,\n        referenceType: referenceType\n      };\n    } // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\n  }, {\n    key: \"parseVertexColors\",\n    value: function parseVertexColors(ColorNode) {\n      var mappingType = ColorNode.MappingInformationType;\n      var referenceType = ColorNode.ReferenceInformationType;\n      var buffer = ColorNode.Colors.a;\n      var indexBuffer = [];\n\n      if (referenceType === 'IndexToDirect') {\n        indexBuffer = ColorNode.ColorIndex.a;\n      }\n\n      return {\n        dataSize: 4,\n        buffer: buffer,\n        indices: indexBuffer,\n        mappingType: mappingType,\n        referenceType: referenceType\n      };\n    } // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\n  }, {\n    key: \"parseMaterialIndices\",\n    value: function parseMaterialIndices(MaterialNode) {\n      var mappingType = MaterialNode.MappingInformationType;\n      var referenceType = MaterialNode.ReferenceInformationType;\n\n      if (mappingType === 'NoMappingInformation') {\n        return {\n          dataSize: 1,\n          buffer: [0],\n          indices: [0],\n          mappingType: 'AllSame',\n          referenceType: referenceType\n        };\n      }\n\n      var materialIndexBuffer = MaterialNode.Materials.a; // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n      // we expect.So we create an intermediate buffer that points to the index in the buffer,\n      // for conforming with the other functions we've written for other data.\n\n      var materialIndices = [];\n\n      for (var i = 0; i < materialIndexBuffer.length; ++i) {\n        materialIndices.push(i);\n      }\n\n      return {\n        dataSize: 1,\n        buffer: materialIndexBuffer,\n        indices: materialIndices,\n        mappingType: mappingType,\n        referenceType: referenceType\n      };\n    } // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\n  }, {\n    key: \"parseNurbsGeometry\",\n    value: function parseNurbsGeometry(geoNode) {\n      if (_NURBSCurve.NURBSCurve === undefined) {\n        console.error('THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\n        return new _three.BufferGeometry();\n      }\n\n      var order = parseInt(geoNode.Order);\n\n      if (isNaN(order)) {\n        console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);\n        return new _three.BufferGeometry();\n      }\n\n      var degree = order - 1;\n      var knots = geoNode.KnotVector.a;\n      var controlPoints = [];\n      var pointsValues = geoNode.Points.a;\n\n      for (var i = 0, l = pointsValues.length; i < l; i += 4) {\n        controlPoints.push(new _three.Vector4().fromArray(pointsValues, i));\n      }\n\n      var startKnot, endKnot;\n\n      if (geoNode.Form === 'Closed') {\n        controlPoints.push(controlPoints[0]);\n      } else if (geoNode.Form === 'Periodic') {\n        startKnot = degree;\n        endKnot = knots.length - 1 - startKnot;\n\n        for (var _i = 0; _i < degree; ++_i) {\n          controlPoints.push(controlPoints[_i]);\n        }\n      }\n\n      var curve = new _NURBSCurve.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n      var vertices = curve.getPoints(controlPoints.length * 7);\n      var positions = new Float32Array(vertices.length * 3);\n      vertices.forEach(function (vertex, i) {\n        vertex.toArray(positions, i * 3);\n      });\n      var geometry = new _three.BufferGeometry();\n      geometry.setAttribute('position', new _three.BufferAttribute(positions, 3));\n      return geometry;\n    }\n  }]);\n\n  return GeometryParser;\n}(); // parse animation data from FBXTree\n\n\nvar AnimationParser =\n/*#__PURE__*/\nfunction () {\n  function AnimationParser() {\n    _classCallCheck(this, AnimationParser);\n  }\n\n  _createClass(AnimationParser, [{\n    key: \"parse\",\n    // take raw animation clips and turn them into three.js animation clips\n    value: function parse() {\n      var animationClips = [];\n      var rawClips = this.parseClips();\n\n      if (rawClips !== undefined) {\n        for (var key in rawClips) {\n          var rawClip = rawClips[key];\n          var clip = this.addClip(rawClip);\n          animationClips.push(clip);\n        }\n      }\n\n      return animationClips;\n    }\n  }, {\n    key: \"parseClips\",\n    value: function parseClips() {\n      // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n      // if this is undefined we can safely assume there are no animations\n      if (fbxTree.Objects.AnimationCurve === undefined) return undefined;\n      var curveNodesMap = this.parseAnimationCurveNodes();\n      this.parseAnimationCurves(curveNodesMap);\n      var layersMap = this.parseAnimationLayers(curveNodesMap);\n      var rawClips = this.parseAnimStacks(layersMap);\n      return rawClips;\n    } // parse nodes in FBXTree.Objects.AnimationCurveNode\n    // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n    // and is referenced by an AnimationLayer\n\n  }, {\n    key: \"parseAnimationCurveNodes\",\n    value: function parseAnimationCurveNodes() {\n      var rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n      var curveNodesMap = new Map();\n\n      for (var nodeID in rawCurveNodes) {\n        var rawCurveNode = rawCurveNodes[nodeID];\n\n        if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\n          var curveNode = {\n            id: rawCurveNode.id,\n            attr: rawCurveNode.attrName,\n            curves: {}\n          };\n          curveNodesMap.set(curveNode.id, curveNode);\n        }\n      }\n\n      return curveNodesMap;\n    } // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n    // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n    // axis ( e.g. times and values of x rotation)\n\n  }, {\n    key: \"parseAnimationCurves\",\n    value: function parseAnimationCurves(curveNodesMap) {\n      var rawCurves = fbxTree.Objects.AnimationCurve; // TODO: Many values are identical up to roundoff error, but won't be optimised\n      // e.g. position times: [0, 0.4, 0. 8]\n      // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n      // clearly, this should be optimised to\n      // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n      // this shows up in nearly every FBX file, and generally time array is length > 100\n\n      for (var nodeID in rawCurves) {\n        var animationCurve = {\n          id: rawCurves[nodeID].id,\n          times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n          values: rawCurves[nodeID].KeyValueFloat.a\n        };\n        var relationships = connections.get(animationCurve.id);\n\n        if (relationships !== undefined) {\n          var animationCurveID = relationships.parents[0].ID;\n          var animationCurveRelationship = relationships.parents[0].relationship;\n\n          if (animationCurveRelationship.match(/X/)) {\n            curveNodesMap.get(animationCurveID).curves['x'] = animationCurve;\n          } else if (animationCurveRelationship.match(/Y/)) {\n            curveNodesMap.get(animationCurveID).curves['y'] = animationCurve;\n          } else if (animationCurveRelationship.match(/Z/)) {\n            curveNodesMap.get(animationCurveID).curves['z'] = animationCurve;\n          } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {\n            curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve;\n          }\n        }\n      }\n    } // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n    // to various AnimationCurveNodes and is referenced by an AnimationStack node\n    // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\n  }, {\n    key: \"parseAnimationLayers\",\n    value: function parseAnimationLayers(curveNodesMap) {\n      var rawLayers = fbxTree.Objects.AnimationLayer;\n      var layersMap = new Map();\n\n      var _loop4 = function _loop4(nodeID) {\n        var layerCurveNodes = [];\n        var connection = connections.get(parseInt(nodeID));\n\n        if (connection !== undefined) {\n          // all the animationCurveNodes used in the layer\n          var children = connection.children;\n          children.forEach(function (child, i) {\n            if (curveNodesMap.has(child.ID)) {\n              var curveNode = curveNodesMap.get(child.ID); // check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\n              if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\n                if (layerCurveNodes[i] === undefined) {\n                  var modelID = connections.get(child.ID).parents.filter(function (parent) {\n                    return parent.relationship !== undefined;\n                  })[0].ID;\n\n                  if (modelID !== undefined) {\n                    var rawModel = fbxTree.Objects.Model[modelID.toString()];\n\n                    if (rawModel === undefined) {\n                      console.warn('THREE.FBXLoader: Encountered a unused curve.', child);\n                      return;\n                    }\n\n                    var node = {\n                      modelName: rawModel.attrName ? _three.PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\n                      ID: rawModel.id,\n                      initialPosition: [0, 0, 0],\n                      initialRotation: [0, 0, 0],\n                      initialScale: [1, 1, 1]\n                    };\n                    sceneGraph.traverse(function (child) {\n                      if (child.ID === rawModel.id) {\n                        node.transform = child.matrix;\n                        if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder;\n                      }\n                    });\n                    if (!node.transform) node.transform = new _three.Matrix4(); // if the animated model is pre rotated, we'll have to apply the pre rotations to every\n                    // animation value as well\n\n                    if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value;\n                    if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value;\n                    layerCurveNodes[i] = node;\n                  }\n                }\n\n                if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;\n              } else if (curveNode.curves.morph !== undefined) {\n                if (layerCurveNodes[i] === undefined) {\n                  var deformerID = connections.get(child.ID).parents.filter(function (parent) {\n                    return parent.relationship !== undefined;\n                  })[0].ID;\n                  var morpherID = connections.get(deformerID).parents[0].ID;\n                  var geoID = connections.get(morpherID).parents[0].ID; // assuming geometry is not used in more than one model\n\n                  var _modelID = connections.get(geoID).parents[0].ID;\n                  var _rawModel = fbxTree.Objects.Model[_modelID];\n                  var _node = {\n                    modelName: _rawModel.attrName ? _three.PropertyBinding.sanitizeNodeName(_rawModel.attrName) : '',\n                    morphName: fbxTree.Objects.Deformer[deformerID].attrName\n                  };\n                  layerCurveNodes[i] = _node;\n                }\n\n                layerCurveNodes[i][curveNode.attr] = curveNode;\n              }\n            }\n          });\n          layersMap.set(parseInt(nodeID), layerCurveNodes);\n        }\n      };\n\n      for (var nodeID in rawLayers) {\n        _loop4(nodeID);\n      }\n\n      return layersMap;\n    } // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n    // hierarchy. Each Stack node will be used to create a AnimationClip\n\n  }, {\n    key: \"parseAnimStacks\",\n    value: function parseAnimStacks(layersMap) {\n      var rawStacks = fbxTree.Objects.AnimationStack; // connect the stacks (clips) up to the layers\n\n      var rawClips = {};\n\n      for (var nodeID in rawStacks) {\n        var children = connections.get(parseInt(nodeID)).children;\n\n        if (children.length > 1) {\n          // it seems like stacks will always be associated with a single layer. But just in case there are files\n          // where there are multiple layers per stack, we'll display a warning\n          console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');\n        }\n\n        var layer = layersMap.get(children[0].ID);\n        rawClips[nodeID] = {\n          name: rawStacks[nodeID].attrName,\n          layer: layer\n        };\n      }\n\n      return rawClips;\n    }\n  }, {\n    key: \"addClip\",\n    value: function addClip(rawClip) {\n      var tracks = [];\n      var scope = this;\n      rawClip.layer.forEach(function (rawTracks) {\n        tracks = tracks.concat(scope.generateTracks(rawTracks));\n      });\n      return new _three.AnimationClip(rawClip.name, -1, tracks);\n    }\n  }, {\n    key: \"generateTracks\",\n    value: function generateTracks(rawTracks) {\n      var tracks = [];\n      var initialPosition = new _three.Vector3();\n      var initialRotation = new _three.Quaternion();\n      var initialScale = new _three.Vector3();\n      if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);\n      initialPosition = initialPosition.toArray();\n      initialRotation = new _three.Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();\n      initialScale = initialScale.toArray();\n\n      if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n        var positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position');\n        if (positionTrack !== undefined) tracks.push(positionTrack);\n      }\n\n      if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n        var rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);\n        if (rotationTrack !== undefined) tracks.push(rotationTrack);\n      }\n\n      if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n        var scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale');\n        if (scaleTrack !== undefined) tracks.push(scaleTrack);\n      }\n\n      if (rawTracks.DeformPercent !== undefined) {\n        var morphTrack = this.generateMorphTrack(rawTracks);\n        if (morphTrack !== undefined) tracks.push(morphTrack);\n      }\n\n      return tracks;\n    }\n  }, {\n    key: \"generateVectorTrack\",\n    value: function generateVectorTrack(modelName, curves, initialValue, type) {\n      var times = this.getTimesForAllAxes(curves);\n      var values = this.getKeyframeTrackValues(times, curves, initialValue);\n      return new _three.VectorKeyframeTrack(modelName + '.' + type, times, values);\n    }\n  }, {\n    key: \"generateRotationTrack\",\n    value: function generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\n      if (curves.x !== undefined) {\n        this.interpolateRotations(curves.x);\n        curves.x.values = curves.x.values.map(_three.MathUtils.degToRad);\n      }\n\n      if (curves.y !== undefined) {\n        this.interpolateRotations(curves.y);\n        curves.y.values = curves.y.values.map(_three.MathUtils.degToRad);\n      }\n\n      if (curves.z !== undefined) {\n        this.interpolateRotations(curves.z);\n        curves.z.values = curves.z.values.map(_three.MathUtils.degToRad);\n      }\n\n      var times = this.getTimesForAllAxes(curves);\n      var values = this.getKeyframeTrackValues(times, curves, initialValue);\n\n      if (preRotation !== undefined) {\n        preRotation = preRotation.map(_three.MathUtils.degToRad);\n        preRotation.push(eulerOrder);\n        preRotation = new _three.Euler().fromArray(preRotation);\n        preRotation = new _three.Quaternion().setFromEuler(preRotation);\n      }\n\n      if (postRotation !== undefined) {\n        postRotation = postRotation.map(_three.MathUtils.degToRad);\n        postRotation.push(eulerOrder);\n        postRotation = new _three.Euler().fromArray(postRotation);\n        postRotation = new _three.Quaternion().setFromEuler(postRotation).invert();\n      }\n\n      var quaternion = new _three.Quaternion();\n      var euler = new _three.Euler();\n      var quaternionValues = [];\n\n      for (var i = 0; i < values.length; i += 3) {\n        euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);\n        quaternion.setFromEuler(euler);\n        if (preRotation !== undefined) quaternion.premultiply(preRotation);\n        if (postRotation !== undefined) quaternion.multiply(postRotation);\n        quaternion.toArray(quaternionValues, i / 3 * 4);\n      }\n\n      return new _three.QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);\n    }\n  }, {\n    key: \"generateMorphTrack\",\n    value: function generateMorphTrack(rawTracks) {\n      var curves = rawTracks.DeformPercent.curves.morph;\n      var values = curves.values.map(function (val) {\n        return val / 100;\n      });\n      var morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];\n      return new _three.NumberKeyframeTrack(rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values);\n    } // For all animated objects, times are defined separately for each axis\n    // Here we'll combine the times into one sorted array without duplicates\n\n  }, {\n    key: \"getTimesForAllAxes\",\n    value: function getTimesForAllAxes(curves) {\n      var times = []; // first join together the times for each axis, if defined\n\n      if (curves.x !== undefined) times = times.concat(curves.x.times);\n      if (curves.y !== undefined) times = times.concat(curves.y.times);\n      if (curves.z !== undefined) times = times.concat(curves.z.times); // then sort them\n\n      times = times.sort(function (a, b) {\n        return a - b;\n      }); // and remove duplicates\n\n      if (times.length > 1) {\n        var targetIndex = 1;\n        var lastValue = times[0];\n\n        for (var i = 1; i < times.length; i++) {\n          var currentValue = times[i];\n\n          if (currentValue !== lastValue) {\n            times[targetIndex] = currentValue;\n            lastValue = currentValue;\n            targetIndex++;\n          }\n        }\n\n        times = times.slice(0, targetIndex);\n      }\n\n      return times;\n    }\n  }, {\n    key: \"getKeyframeTrackValues\",\n    value: function getKeyframeTrackValues(times, curves, initialValue) {\n      var prevValue = initialValue;\n      var values = [];\n      var xIndex = -1;\n      var yIndex = -1;\n      var zIndex = -1;\n      times.forEach(function (time) {\n        if (curves.x) xIndex = curves.x.times.indexOf(time);\n        if (curves.y) yIndex = curves.y.times.indexOf(time);\n        if (curves.z) zIndex = curves.z.times.indexOf(time); // if there is an x value defined for this frame, use that\n\n        if (xIndex !== -1) {\n          var xValue = curves.x.values[xIndex];\n          values.push(xValue);\n          prevValue[0] = xValue;\n        } else {\n          // otherwise use the x value from the previous frame\n          values.push(prevValue[0]);\n        }\n\n        if (yIndex !== -1) {\n          var yValue = curves.y.values[yIndex];\n          values.push(yValue);\n          prevValue[1] = yValue;\n        } else {\n          values.push(prevValue[1]);\n        }\n\n        if (zIndex !== -1) {\n          var zValue = curves.z.values[zIndex];\n          values.push(zValue);\n          prevValue[2] = zValue;\n        } else {\n          values.push(prevValue[2]);\n        }\n      });\n      return values;\n    } // Rotations are defined as Euler angles which can have values  of any size\n    // These will be converted to quaternions which don't support values greater than\n    // PI, so we'll interpolate large rotations\n\n  }, {\n    key: \"interpolateRotations\",\n    value: function interpolateRotations(curve) {\n      for (var i = 1; i < curve.values.length; i++) {\n        var initialValue = curve.values[i - 1];\n        var valuesSpan = curve.values[i] - initialValue;\n        var absoluteSpan = Math.abs(valuesSpan);\n\n        if (absoluteSpan >= 180) {\n          var numSubIntervals = absoluteSpan / 180;\n          var step = valuesSpan / numSubIntervals;\n          var nextValue = initialValue + step;\n          var initialTime = curve.times[i - 1];\n          var timeSpan = curve.times[i] - initialTime;\n          var interval = timeSpan / numSubIntervals;\n          var nextTime = initialTime + interval;\n          var interpolatedTimes = [];\n          var interpolatedValues = [];\n\n          while (nextTime < curve.times[i]) {\n            interpolatedTimes.push(nextTime);\n            nextTime += interval;\n            interpolatedValues.push(nextValue);\n            nextValue += step;\n          }\n\n          curve.times = inject(curve.times, i, interpolatedTimes);\n          curve.values = inject(curve.values, i, interpolatedValues);\n        }\n      }\n    }\n  }]);\n\n  return AnimationParser;\n}(); // parse an FBX file in ASCII format\n\n\nvar TextParser =\n/*#__PURE__*/\nfunction () {\n  function TextParser() {\n    _classCallCheck(this, TextParser);\n  }\n\n  _createClass(TextParser, [{\n    key: \"getPrevNode\",\n    value: function getPrevNode() {\n      return this.nodeStack[this.currentIndent - 2];\n    }\n  }, {\n    key: \"getCurrentNode\",\n    value: function getCurrentNode() {\n      return this.nodeStack[this.currentIndent - 1];\n    }\n  }, {\n    key: \"getCurrentProp\",\n    value: function getCurrentProp() {\n      return this.currentProp;\n    }\n  }, {\n    key: \"pushStack\",\n    value: function pushStack(node) {\n      this.nodeStack.push(node);\n      this.currentIndent += 1;\n    }\n  }, {\n    key: \"popStack\",\n    value: function popStack() {\n      this.nodeStack.pop();\n      this.currentIndent -= 1;\n    }\n  }, {\n    key: \"setCurrentProp\",\n    value: function setCurrentProp(val, name) {\n      this.currentProp = val;\n      this.currentPropName = name;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      this.currentIndent = 0;\n      this.allNodes = new FBXTree();\n      this.nodeStack = [];\n      this.currentProp = [];\n      this.currentPropName = '';\n      var scope = this;\n      var split = text.split(/[\\r\\n]+/);\n      split.forEach(function (line, i) {\n        var matchComment = line.match(/^[\\s\\t]*;/);\n        var matchEmpty = line.match(/^[\\s\\t]*$/);\n        if (matchComment || matchEmpty) return;\n        var matchBeginning = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):(.*){', '');\n        var matchProperty = line.match('^\\\\t{' + scope.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\n        var matchEnd = line.match('^\\\\t{' + (scope.currentIndent - 1) + '}}');\n\n        if (matchBeginning) {\n          scope.parseNodeBegin(line, matchBeginning);\n        } else if (matchProperty) {\n          scope.parseNodeProperty(line, matchProperty, split[++i]);\n        } else if (matchEnd) {\n          scope.popStack();\n        } else if (line.match(/^[^\\s\\t}]/)) {\n          // large arrays are split over multiple lines terminated with a ',' character\n          // if this is encountered the line needs to be joined to the previous line\n          scope.parseNodePropertyContinued(line);\n        }\n      });\n      return this.allNodes;\n    }\n  }, {\n    key: \"parseNodeBegin\",\n    value: function parseNodeBegin(line, property) {\n      var nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '');\n      var nodeAttrs = property[2].split(',').map(function (attr) {\n        return attr.trim().replace(/^\"/, '').replace(/\"$/, '');\n      });\n      var node = {\n        name: nodeName\n      };\n      var attrs = this.parseNodeAttr(nodeAttrs);\n      var currentNode = this.getCurrentNode(); // a top node\n\n      if (this.currentIndent === 0) {\n        this.allNodes.add(nodeName, node);\n      } else {\n        // a subnode\n        // if the subnode already exists, append it\n        if (nodeName in currentNode) {\n          // special case Pose needs PoseNodes as an array\n          if (nodeName === 'PoseNode') {\n            currentNode.PoseNode.push(node);\n          } else if (currentNode[nodeName].id !== undefined) {\n            currentNode[nodeName] = {};\n            currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n          }\n\n          if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;\n        } else if (typeof attrs.id === 'number') {\n          currentNode[nodeName] = {};\n          currentNode[nodeName][attrs.id] = node;\n        } else if (nodeName !== 'Properties70') {\n          if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;\n        }\n      }\n\n      if (typeof attrs.id === 'number') node.id = attrs.id;\n      if (attrs.name !== '') node.attrName = attrs.name;\n      if (attrs.type !== '') node.attrType = attrs.type;\n      this.pushStack(node);\n    }\n  }, {\n    key: \"parseNodeAttr\",\n    value: function parseNodeAttr(attrs) {\n      var id = attrs[0];\n\n      if (attrs[0] !== '') {\n        id = parseInt(attrs[0]);\n\n        if (isNaN(id)) {\n          id = attrs[0];\n        }\n      }\n\n      var name = '',\n          type = '';\n\n      if (attrs.length > 1) {\n        name = attrs[1].replace(/^(\\w+)::/, '');\n        type = attrs[2];\n      }\n\n      return {\n        id: id,\n        name: name,\n        type: type\n      };\n    }\n  }, {\n    key: \"parseNodeProperty\",\n    value: function parseNodeProperty(line, property, contentLine) {\n      var propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim();\n      var propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim(); // for special case: base64 image data follows \"Content: ,\" line\n      //\tContent: ,\n      //\t \"/9j/4RDaRXhpZgAATU0A...\"\n\n      if (propName === 'Content' && propValue === ',') {\n        propValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim();\n      }\n\n      var currentNode = this.getCurrentNode();\n      var parentName = currentNode.name;\n\n      if (parentName === 'Properties70') {\n        this.parseNodeSpecialProperty(line, propName, propValue);\n        return;\n      } // Connections\n\n\n      if (propName === 'C') {\n        var connProps = propValue.split(',').slice(1);\n        var from = parseInt(connProps[0]);\n        var to = parseInt(connProps[1]);\n        var rest = propValue.split(',').slice(3);\n        rest = rest.map(function (elem) {\n          return elem.trim().replace(/^\"/, '');\n        });\n        propName = 'connections';\n        propValue = [from, to];\n        append(propValue, rest);\n\n        if (currentNode[propName] === undefined) {\n          currentNode[propName] = [];\n        }\n      } // Node\n\n\n      if (propName === 'Node') currentNode.id = propValue; // connections\n\n      if (propName in currentNode && Array.isArray(currentNode[propName])) {\n        currentNode[propName].push(propValue);\n      } else {\n        if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;\n      }\n\n      this.setCurrentProp(currentNode, propName); // convert string to array, unless it ends in ',' in which case more will be added to it\n\n      if (propName === 'a' && propValue.slice(-1) !== ',') {\n        currentNode.a = parseNumberArray(propValue);\n      }\n    }\n  }, {\n    key: \"parseNodePropertyContinued\",\n    value: function parseNodePropertyContinued(line) {\n      var currentNode = this.getCurrentNode();\n      currentNode.a += line; // if the line doesn't end in ',' we have reached the end of the property value\n      // so convert the string to an array\n\n      if (line.slice(-1) !== ',') {\n        currentNode.a = parseNumberArray(currentNode.a);\n      }\n    } // parse \"Property70\"\n\n  }, {\n    key: \"parseNodeSpecialProperty\",\n    value: function parseNodeSpecialProperty(line, propName, propValue) {\n      // split this\n      // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n      // into array like below\n      // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n      var props = propValue.split('\",').map(function (prop) {\n        return prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n      });\n      var innerPropName = props[0];\n      var innerPropType1 = props[1];\n      var innerPropType2 = props[2];\n      var innerPropFlag = props[3];\n      var innerPropValue = props[4]; // cast values where needed, otherwise leave as strings\n\n      switch (innerPropType1) {\n        case 'int':\n        case 'enum':\n        case 'bool':\n        case 'ULongLong':\n        case 'double':\n        case 'Number':\n        case 'FieldOfView':\n          innerPropValue = parseFloat(innerPropValue);\n          break;\n\n        case 'Color':\n        case 'ColorRGB':\n        case 'Vector3D':\n        case 'Lcl_Translation':\n        case 'Lcl_Rotation':\n        case 'Lcl_Scaling':\n          innerPropValue = parseNumberArray(innerPropValue);\n          break;\n      } // CAUTION: these props must append to parent's parent\n\n\n      this.getPrevNode()[innerPropName] = {\n        type: innerPropType1,\n        type2: innerPropType2,\n        flag: innerPropFlag,\n        value: innerPropValue\n      };\n      this.setCurrentProp(this.getPrevNode(), innerPropName);\n    }\n  }]);\n\n  return TextParser;\n}(); // Parse an FBX file in Binary format\n\n\nvar BinaryParser =\n/*#__PURE__*/\nfunction () {\n  function BinaryParser() {\n    _classCallCheck(this, BinaryParser);\n  }\n\n  _createClass(BinaryParser, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      var reader = new BinaryReader(buffer);\n      reader.skip(23); // skip magic 23 bytes\n\n      var version = reader.getUint32();\n\n      if (version < 6400) {\n        throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version);\n      }\n\n      var allNodes = new FBXTree();\n\n      while (!this.endOfContent(reader)) {\n        var node = this.parseNode(reader, version);\n        if (node !== null) allNodes.add(node.name, node);\n      }\n\n      return allNodes;\n    } // Check if reader has reached the end of content.\n\n  }, {\n    key: \"endOfContent\",\n    value: function endOfContent(reader) {\n      // footer size: 160bytes + 16-byte alignment padding\n      // - 16bytes: magic\n      // - padding til 16-byte alignment (at least 1byte?)\n      //\t(seems like some exporters embed fixed 15 or 16bytes?)\n      // - 4bytes: magic\n      // - 4bytes: version\n      // - 120bytes: zero\n      // - 16bytes: magic\n      if (reader.size() % 16 === 0) {\n        return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\n      } else {\n        return reader.getOffset() + 160 + 16 >= reader.size();\n      }\n    } // recursively parse nodes until the end of the file is reached\n\n  }, {\n    key: \"parseNode\",\n    value: function parseNode(reader, version) {\n      var node = {}; // The first three data sizes depends on version.\n\n      var endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n      var numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\n      version >= 7500 ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\n\n      var nameLen = reader.getUint8();\n      var name = reader.getString(nameLen); // Regards this node as NULL-record if endOffset is zero\n\n      if (endOffset === 0) return null;\n      var propertyList = [];\n\n      for (var i = 0; i < numProperties; i++) {\n        propertyList.push(this.parseProperty(reader));\n      } // Regards the first three elements in propertyList as id, attrName, and attrType\n\n\n      var id = propertyList.length > 0 ? propertyList[0] : '';\n      var attrName = propertyList.length > 1 ? propertyList[1] : '';\n      var attrType = propertyList.length > 2 ? propertyList[2] : ''; // check if this node represents just a single property\n      // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\n      node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n\n      while (endOffset > reader.getOffset()) {\n        var subNode = this.parseNode(reader, version);\n        if (subNode !== null) this.parseSubNode(name, node, subNode);\n      }\n\n      node.propertyList = propertyList; // raw property list used by parent\n\n      if (typeof id === 'number') node.id = id;\n      if (attrName !== '') node.attrName = attrName;\n      if (attrType !== '') node.attrType = attrType;\n      if (name !== '') node.name = name;\n      return node;\n    }\n  }, {\n    key: \"parseSubNode\",\n    value: function parseSubNode(name, node, subNode) {\n      // special case: child node is single property\n      if (subNode.singleProperty === true) {\n        var value = subNode.propertyList[0];\n\n        if (Array.isArray(value)) {\n          node[subNode.name] = subNode;\n          subNode.a = value;\n        } else {\n          node[subNode.name] = value;\n        }\n      } else if (name === 'Connections' && subNode.name === 'C') {\n        var array = [];\n        subNode.propertyList.forEach(function (property, i) {\n          // first Connection is FBX type (OO, OP, etc.). We'll discard these\n          if (i !== 0) array.push(property);\n        });\n\n        if (node.connections === undefined) {\n          node.connections = [];\n        }\n\n        node.connections.push(array);\n      } else if (subNode.name === 'Properties70') {\n        var keys = Object.keys(subNode);\n        keys.forEach(function (key) {\n          node[key] = subNode[key];\n        });\n      } else if (name === 'Properties70' && subNode.name === 'P') {\n        var innerPropName = subNode.propertyList[0];\n        var innerPropType1 = subNode.propertyList[1];\n        var innerPropType2 = subNode.propertyList[2];\n        var innerPropFlag = subNode.propertyList[3];\n        var innerPropValue;\n        if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n        if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n\n        if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n          innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\n        } else {\n          innerPropValue = subNode.propertyList[4];\n        } // this will be copied to parent, see above\n\n\n        node[innerPropName] = {\n          type: innerPropType1,\n          type2: innerPropType2,\n          flag: innerPropFlag,\n          value: innerPropValue\n        };\n      } else if (node[subNode.name] === undefined) {\n        if (typeof subNode.id === 'number') {\n          node[subNode.name] = {};\n          node[subNode.name][subNode.id] = subNode;\n        } else {\n          node[subNode.name] = subNode;\n        }\n      } else {\n        if (subNode.name === 'PoseNode') {\n          if (!Array.isArray(node[subNode.name])) {\n            node[subNode.name] = [node[subNode.name]];\n          }\n\n          node[subNode.name].push(subNode);\n        } else if (node[subNode.name][subNode.id] === undefined) {\n          node[subNode.name][subNode.id] = subNode;\n        }\n      }\n    }\n  }, {\n    key: \"parseProperty\",\n    value: function parseProperty(reader) {\n      var type = reader.getString(1);\n      var length;\n\n      switch (type) {\n        case 'C':\n          return reader.getBoolean();\n\n        case 'D':\n          return reader.getFloat64();\n\n        case 'F':\n          return reader.getFloat32();\n\n        case 'I':\n          return reader.getInt32();\n\n        case 'L':\n          return reader.getInt64();\n\n        case 'R':\n          length = reader.getUint32();\n          return reader.getArrayBuffer(length);\n\n        case 'S':\n          length = reader.getUint32();\n          return reader.getString(length);\n\n        case 'Y':\n          return reader.getInt16();\n\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'f':\n        case 'i':\n        case 'l':\n          var arrayLength = reader.getUint32();\n          var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\n          var compressedLength = reader.getUint32();\n\n          if (encoding === 0) {\n            switch (type) {\n              case 'b':\n              case 'c':\n                return reader.getBooleanArray(arrayLength);\n\n              case 'd':\n                return reader.getFloat64Array(arrayLength);\n\n              case 'f':\n                return reader.getFloat32Array(arrayLength);\n\n              case 'i':\n                return reader.getInt32Array(arrayLength);\n\n              case 'l':\n                return reader.getInt64Array(arrayLength);\n            }\n          }\n\n          var data = (0, _fflate.unzlibSync)(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\n\n          var reader2 = new BinaryReader(data.buffer);\n\n          switch (type) {\n            case 'b':\n            case 'c':\n              return reader2.getBooleanArray(arrayLength);\n\n            case 'd':\n              return reader2.getFloat64Array(arrayLength);\n\n            case 'f':\n              return reader2.getFloat32Array(arrayLength);\n\n            case 'i':\n              return reader2.getInt32Array(arrayLength);\n\n            case 'l':\n              return reader2.getInt64Array(arrayLength);\n          }\n\n        default:\n          throw new Error('THREE.FBXLoader: Unknown property type ' + type);\n      }\n    }\n  }]);\n\n  return BinaryParser;\n}();\n\nvar BinaryReader =\n/*#__PURE__*/\nfunction () {\n  function BinaryReader(buffer, littleEndian) {\n    _classCallCheck(this, BinaryReader);\n\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true;\n  }\n\n  _createClass(BinaryReader, [{\n    key: \"getOffset\",\n    value: function getOffset() {\n      return this.offset;\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.dv.buffer.byteLength;\n    }\n  }, {\n    key: \"skip\",\n    value: function skip(length) {\n      this.offset += length;\n    } // seems like true/false representation depends on exporter.\n    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n    // then sees LSB.\n\n  }, {\n    key: \"getBoolean\",\n    value: function getBoolean() {\n      return (this.getUint8() & 1) === 1;\n    }\n  }, {\n    key: \"getBooleanArray\",\n    value: function getBooleanArray(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getBoolean());\n      }\n\n      return a;\n    }\n  }, {\n    key: \"getUint8\",\n    value: function getUint8() {\n      var value = this.dv.getUint8(this.offset);\n      this.offset += 1;\n      return value;\n    }\n  }, {\n    key: \"getInt16\",\n    value: function getInt16() {\n      var value = this.dv.getInt16(this.offset, this.littleEndian);\n      this.offset += 2;\n      return value;\n    }\n  }, {\n    key: \"getInt32\",\n    value: function getInt32() {\n      var value = this.dv.getInt32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    }\n  }, {\n    key: \"getInt32Array\",\n    value: function getInt32Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt32());\n      }\n\n      return a;\n    }\n  }, {\n    key: \"getUint32\",\n    value: function getUint32() {\n      var value = this.dv.getUint32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    } // JavaScript doesn't support 64-bit integer so calculate this here\n    // 1 << 32 will return 1 so using multiply operation instead here.\n    // There's a possibility that this method returns wrong value if the value\n    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n    // TODO: safely handle 64-bit integer\n\n  }, {\n    key: \"getInt64\",\n    value: function getInt64() {\n      var low, high;\n\n      if (this.littleEndian) {\n        low = this.getUint32();\n        high = this.getUint32();\n      } else {\n        high = this.getUint32();\n        low = this.getUint32();\n      } // calculate negative value\n\n\n      if (high & 0x80000000) {\n        high = ~high & 0xffffffff;\n        low = ~low & 0xffffffff;\n        if (low === 0xffffffff) high = high + 1 & 0xffffffff;\n        low = low + 1 & 0xffffffff;\n        return -(high * 0x100000000 + low);\n      }\n\n      return high * 0x100000000 + low;\n    }\n  }, {\n    key: \"getInt64Array\",\n    value: function getInt64Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt64());\n      }\n\n      return a;\n    } // Note: see getInt64() comment\n\n  }, {\n    key: \"getUint64\",\n    value: function getUint64() {\n      var low, high;\n\n      if (this.littleEndian) {\n        low = this.getUint32();\n        high = this.getUint32();\n      } else {\n        high = this.getUint32();\n        low = this.getUint32();\n      }\n\n      return high * 0x100000000 + low;\n    }\n  }, {\n    key: \"getFloat32\",\n    value: function getFloat32() {\n      var value = this.dv.getFloat32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    }\n  }, {\n    key: \"getFloat32Array\",\n    value: function getFloat32Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat32());\n      }\n\n      return a;\n    }\n  }, {\n    key: \"getFloat64\",\n    value: function getFloat64() {\n      var value = this.dv.getFloat64(this.offset, this.littleEndian);\n      this.offset += 8;\n      return value;\n    }\n  }, {\n    key: \"getFloat64Array\",\n    value: function getFloat64Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat64());\n      }\n\n      return a;\n    }\n  }, {\n    key: \"getArrayBuffer\",\n    value: function getArrayBuffer(size) {\n      var value = this.dv.buffer.slice(this.offset, this.offset + size);\n      this.offset += size;\n      return value;\n    }\n  }, {\n    key: \"getString\",\n    value: function getString(size) {\n      // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a[i] = this.getUint8();\n      }\n\n      var nullByte = a.indexOf(0);\n      if (nullByte >= 0) a = a.slice(0, nullByte);\n      return _three.LoaderUtils.decodeText(new Uint8Array(a));\n    }\n  }]);\n\n  return BinaryReader;\n}(); // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n// and BinaryParser( FBX Binary format)\n\n\nvar FBXTree =\n/*#__PURE__*/\nfunction () {\n  function FBXTree() {\n    _classCallCheck(this, FBXTree);\n  }\n\n  _createClass(FBXTree, [{\n    key: \"add\",\n    value: function add(key, val) {\n      this[key] = val;\n    }\n  }]);\n\n  return FBXTree;\n}(); // ************** UTILITY FUNCTIONS **************\n\n\nfunction isFbxFormatBinary(buffer) {\n  var CORRECT = \"Kaydara FBX Binary  \\0\";\n  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n}\n\nfunction isFbxFormatASCII(text) {\n  var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n  var cursor = 0;\n\n  function read(offset) {\n    var result = text[offset - 1];\n    text = text.slice(cursor + offset);\n    cursor++;\n    return result;\n  }\n\n  for (var i = 0; i < CORRECT.length; ++i) {\n    var num = read(1);\n\n    if (num === CORRECT[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getFbxVersion(text) {\n  var versionRegExp = /FBXVersion: (\\d+)/;\n  var match = text.match(versionRegExp);\n\n  if (match) {\n    var version = parseInt(match[1]);\n    return version;\n  }\n\n  throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\n} // Converts FBX ticks into real time seconds.\n\n\nfunction convertFBXTimeToSeconds(time) {\n  return time / 46186158000;\n}\n\nvar dataArray = []; // extracts the data from the correct position in the FBX array based on indexing type\n\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n  var index;\n\n  switch (infoObject.mappingType) {\n    case 'ByPolygonVertex':\n      index = polygonVertexIndex;\n      break;\n\n    case 'ByPolygon':\n      index = polygonIndex;\n      break;\n\n    case 'ByVertice':\n      index = vertexIndex;\n      break;\n\n    case 'AllSame':\n      index = infoObject.indices[0];\n      break;\n\n    default:\n      console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);\n  }\n\n  if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];\n  var from = index * infoObject.dataSize;\n  var to = from + infoObject.dataSize;\n  return slice(dataArray, infoObject.buffer, from, to);\n}\n\nvar tempEuler = new _three.Euler();\nvar tempVec = new _three.Vector3(); // generate transformation from FBX transform data\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\n\nfunction generateTransform(transformData) {\n  var lTranslationM = new _three.Matrix4();\n  var lPreRotationM = new _three.Matrix4();\n  var lRotationM = new _three.Matrix4();\n  var lPostRotationM = new _three.Matrix4();\n  var lScalingM = new _three.Matrix4();\n  var lScalingPivotM = new _three.Matrix4();\n  var lScalingOffsetM = new _three.Matrix4();\n  var lRotationOffsetM = new _three.Matrix4();\n  var lRotationPivotM = new _three.Matrix4();\n  var lParentGX = new _three.Matrix4();\n  var lParentLX = new _three.Matrix4();\n  var lGlobalT = new _three.Matrix4();\n  var inheritType = transformData.inheritType ? transformData.inheritType : 0;\n  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));\n\n  if (transformData.preRotation) {\n    var array = transformData.preRotation.map(_three.MathUtils.degToRad);\n    array.push(transformData.eulerOrder);\n    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n  }\n\n  if (transformData.rotation) {\n    var _array = transformData.rotation.map(_three.MathUtils.degToRad);\n\n    _array.push(transformData.eulerOrder);\n\n    lRotationM.makeRotationFromEuler(tempEuler.fromArray(_array));\n  }\n\n  if (transformData.postRotation) {\n    var _array2 = transformData.postRotation.map(_three.MathUtils.degToRad);\n\n    _array2.push(transformData.eulerOrder);\n\n    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(_array2));\n    lPostRotationM.invert();\n  }\n\n  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale)); // Pivots and offsets\n\n  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));\n  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));\n  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));\n  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot)); // parent transform\n\n  if (transformData.parentMatrixWorld) {\n    lParentLX.copy(transformData.parentMatrix);\n    lParentGX.copy(transformData.parentMatrixWorld);\n  }\n\n  var lLRM = new _three.Matrix4().copy(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM); // Global Rotation\n\n  var lParentGRM = new _three.Matrix4();\n  lParentGRM.extractRotation(lParentGX); // Global Shear*Scaling\n\n  var lParentTM = new _three.Matrix4();\n  lParentTM.copyPosition(lParentGX);\n  var lParentGSM = new _three.Matrix4();\n  var lParentGRSM = new _three.Matrix4().copy(lParentTM).invert().multiply(lParentGX);\n  lParentGSM.copy(lParentGRM).invert().multiply(lParentGRSM);\n  var lLSM = lScalingM;\n  var lGlobalRS = new _three.Matrix4();\n\n  if (inheritType === 0) {\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);\n  } else if (inheritType === 1) {\n    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);\n  } else {\n    var lParentLSM = new _three.Matrix4().scale(new _three.Vector3().setFromMatrixScale(lParentLX));\n    var lParentLSM_inv = new _three.Matrix4().copy(lParentLSM).invert();\n    var lParentGSM_noLocal = new _three.Matrix4().copy(lParentGSM).multiply(lParentLSM_inv);\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);\n  }\n\n  var lRotationPivotM_inv = new _three.Matrix4();\n  lRotationPivotM_inv.copy(lRotationPivotM).invert();\n  var lScalingPivotM_inv = new _three.Matrix4();\n  lScalingPivotM_inv.copy(lScalingPivotM).invert(); // Calculate the local transform matrix\n\n  var lTransform = new _three.Matrix4();\n  lTransform.copy(lTranslationM).multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);\n  var lLocalTWithAllPivotAndOffsetInfo = new _three.Matrix4().copyPosition(lTransform);\n  var lGlobalTranslation = new _three.Matrix4().copy(lParentGX).multiply(lLocalTWithAllPivotAndOffsetInfo);\n  lGlobalT.copyPosition(lGlobalTranslation);\n  lTransform = new _three.Matrix4().copy(lGlobalT).multiply(lGlobalRS); // from global to local\n\n  lTransform.premultiply(lParentGX.invert());\n  return lTransform;\n} // Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\n\nfunction getEulerOrder(order) {\n  order = order || 0;\n  var enums = ['ZYX', // -> XYZ extrinsic\n  'YZX', // -> XZY extrinsic\n  'XZY', // -> YZX extrinsic\n  'ZXY', // -> YXZ extrinsic\n  'YXZ', // -> ZXY extrinsic\n  'XYZ' // -> ZYX extrinsic\n  //'SphericXYZ', // not possible to support\n  ];\n\n  if (order === 6) {\n    console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');\n    return enums[0];\n  }\n\n  return enums[order];\n} // Parses comma separated list of numbers and returns them an array.\n// Used internally by the TextParser\n\n\nfunction parseNumberArray(value) {\n  var array = value.split(',').map(function (val) {\n    return parseFloat(val);\n  });\n  return array;\n}\n\nfunction convertArrayBufferToString(buffer, from, to) {\n  if (from === undefined) from = 0;\n  if (to === undefined) to = buffer.byteLength;\n  return _three.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\n}\n\nfunction append(a, b) {\n  for (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n    a[j] = b[i];\n  }\n}\n\nfunction slice(a, b, from, to) {\n  for (var i = from, j = 0; i < to; i++, j++) {\n    a[j] = b[i];\n  }\n\n  return a;\n} // inject array a2 into array a1 at index\n\n\nfunction inject(a1, index, a2) {\n  return a1.slice(0, index).concat(a2).concat(a1.slice(index));\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$fflate$esm$browser","~$module$node_modules$three_stdlib$curves$NURBSCurve"]],"~:properties",["^5",["mappingType","map","nodeStack","weights","rawBones","initialPosition","wrapS","eulerOrder","reflectivity","values","currentIndent","attrType","offset","allNodes","displacementMap","prototype","skinning","scale","transparent","textureLoader","uvs","rotationPivot","modelName","scalingPivot","emissive","castShadow","rotationOffset","key","littleEndian","transformData","children","skeleton","x","__esModule","parentMatrixWorld","parentMatrix","alphaMap","vertexWeights","encoding","attr","id","transform","normalMap","aoMap","fullWeights","weightsIndices","bumpMap","transformLink","normal","preRotation","specular","buffer","times","position","parents","relationship","geometryID","name","configurable","rawTargets","emissiveMap","value","dv","morphName","enumerable","materialIndex","referenceType","vertexColors","ID","initialRotation","a","writable","shininess","skeletons","vertexIndices","rotation","linewidth","attrName","singleProperty","animations","uv","bones","scalingOffset","type2","type","y","wrapT","postRotation","mapping","dataSize","__proto__","currentProp","propertyList","initialWeight","envMap","manager","specularMap","vertex","bumpScale","morphTargetsRelative","morphTargets","layer","initialScale","geoID","colors","displacementScale","currentPropName","emissiveIntensity","color","weightTable","opacity","flag","inheritType","vertexPositions","FBXLoader","weight","translation","FBX_Deformer","constructor","indices","connections","material","curves"]],"~:compiled-at",1630917515557,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$FBXLoader.js\",\n\"lineCount\":131,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/FBXLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$FBXLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.FBXLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _fflate = require(\\\"fflate\\\");\\n\\nvar _NURBSCurve = require(\\\"../curves/NURBSCurve.js\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * Loader loads FBX file and generates Group representing FBX scene.\\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\\n * Versions lower than this may load but will probably have errors\\n *\\n * Needs Support:\\n *  Morph normals / blend shape normals\\n *\\n * FBX format references:\\n * \\thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\\n * \\thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\\n *\\n * \\tBinary format specification:\\n *\\t\\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\\n */\\nvar fbxTree;\\nvar connections;\\nvar sceneGraph;\\n\\nvar FBXLoader =\\n/*#__PURE__*/\\nfunction (_Loader) {\\n  _inherits(FBXLoader, _Loader);\\n\\n  function FBXLoader(manager) {\\n    _classCallCheck(this, FBXLoader);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(FBXLoader).call(this, manager));\\n  }\\n\\n  _createClass(FBXLoader, [{\\n    key: \\\"load\\\",\\n    value: function load(url, onLoad, onProgress, onError) {\\n      var scope = this;\\n      var path = scope.path === '' ? _three.LoaderUtils.extractUrlBase(url) : scope.path;\\n      var loader = new _three.FileLoader(this.manager);\\n      loader.setPath(scope.path);\\n      loader.setResponseType('arraybuffer');\\n      loader.setRequestHeader(scope.requestHeader);\\n      loader.setWithCredentials(scope.withCredentials);\\n      loader.load(url, function (buffer) {\\n        try {\\n          onLoad(scope.parse(buffer, path));\\n        } catch (e) {\\n          if (onError) {\\n            onError(e);\\n          } else {\\n            console.error(e);\\n          }\\n\\n          scope.manager.itemError(url);\\n        }\\n      }, onProgress, onError);\\n    }\\n  }, {\\n    key: \\\"parse\\\",\\n    value: function parse(FBXBuffer, path) {\\n      if (isFbxFormatBinary(FBXBuffer)) {\\n        fbxTree = new BinaryParser().parse(FBXBuffer);\\n      } else {\\n        var FBXText = convertArrayBufferToString(FBXBuffer);\\n\\n        if (!isFbxFormatASCII(FBXText)) {\\n          throw new Error('THREE.FBXLoader: Unknown format.');\\n        }\\n\\n        if (getFbxVersion(FBXText) < 7000) {\\n          throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\\n        }\\n\\n        fbxTree = new TextParser().parse(FBXText);\\n      } // console.log( fbxTree );\\n\\n\\n      var textureLoader = new _three.TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\\n      return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);\\n    }\\n  }]);\\n\\n  return FBXLoader;\\n}(_three.Loader); // Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\\n\\n\\nexports.FBXLoader = FBXLoader;\\n\\nvar FBXTreeParser =\\n/*#__PURE__*/\\nfunction () {\\n  function FBXTreeParser(textureLoader, manager) {\\n    _classCallCheck(this, FBXTreeParser);\\n\\n    this.textureLoader = textureLoader;\\n    this.manager = manager;\\n  }\\n\\n  _createClass(FBXTreeParser, [{\\n    key: \\\"parse\\\",\\n    value: function parse() {\\n      connections = this.parseConnections();\\n      var images = this.parseImages();\\n      var textures = this.parseTextures(images);\\n      var materials = this.parseMaterials(textures);\\n      var deformers = this.parseDeformers();\\n      var geometryMap = new GeometryParser().parse(deformers);\\n      this.parseScene(deformers, geometryMap, materials);\\n      return sceneGraph;\\n    } // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\\n    // and details the connection type\\n\\n  }, {\\n    key: \\\"parseConnections\\\",\\n    value: function parseConnections() {\\n      var connectionMap = new Map();\\n\\n      if ('Connections' in fbxTree) {\\n        var rawConnections = fbxTree.Connections.connections;\\n        rawConnections.forEach(function (rawConnection) {\\n          var fromID = rawConnection[0];\\n          var toID = rawConnection[1];\\n          var relationship = rawConnection[2];\\n\\n          if (!connectionMap.has(fromID)) {\\n            connectionMap.set(fromID, {\\n              parents: [],\\n              children: []\\n            });\\n          }\\n\\n          var parentRelationship = {\\n            ID: toID,\\n            relationship: relationship\\n          };\\n          connectionMap.get(fromID).parents.push(parentRelationship);\\n\\n          if (!connectionMap.has(toID)) {\\n            connectionMap.set(toID, {\\n              parents: [],\\n              children: []\\n            });\\n          }\\n\\n          var childRelationship = {\\n            ID: fromID,\\n            relationship: relationship\\n          };\\n          connectionMap.get(toID).children.push(childRelationship);\\n        });\\n      }\\n\\n      return connectionMap;\\n    } // Parse FBXTree.Objects.Video for embedded image data\\n    // These images are connected to textures in FBXTree.Objects.Textures\\n    // via FBXTree.Connections.\\n\\n  }, {\\n    key: \\\"parseImages\\\",\\n    value: function parseImages() {\\n      var images = {};\\n      var blobs = {};\\n\\n      if ('Video' in fbxTree.Objects) {\\n        var videoNodes = fbxTree.Objects.Video;\\n\\n        for (var nodeID in videoNodes) {\\n          var videoNode = videoNodes[nodeID];\\n          var id = parseInt(nodeID);\\n          images[id] = videoNode.RelativeFilename || videoNode.Filename; // raw image data is in videoNode.Content\\n\\n          if ('Content' in videoNode) {\\n            var arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\\n            var base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';\\n\\n            if (arrayBufferContent || base64Content) {\\n              var image = this.parseImage(videoNodes[nodeID]);\\n              blobs[videoNode.RelativeFilename || videoNode.Filename] = image;\\n            }\\n          }\\n        }\\n      }\\n\\n      for (var _id in images) {\\n        var filename = images[_id];\\n        if (blobs[filename] !== undefined) images[_id] = blobs[filename];else images[_id] = images[_id].split('\\\\\\\\').pop();\\n      }\\n\\n      return images;\\n    } // Parse embedded image data in FBXTree.Video.Content\\n\\n  }, {\\n    key: \\\"parseImage\\\",\\n    value: function parseImage(videoNode) {\\n      var content = videoNode.Content;\\n      var fileName = videoNode.RelativeFilename || videoNode.Filename;\\n      var extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\\n      var type;\\n\\n      switch (extension) {\\n        case 'bmp':\\n          type = 'image/bmp';\\n          break;\\n\\n        case 'jpg':\\n        case 'jpeg':\\n          type = 'image/jpeg';\\n          break;\\n\\n        case 'png':\\n          type = 'image/png';\\n          break;\\n\\n        case 'tif':\\n          type = 'image/tiff';\\n          break;\\n\\n        case 'tga':\\n          if (this.manager.getHandler('.tga') === null) {\\n            console.warn('FBXLoader: TGA loader not found, skipping ', fileName);\\n          }\\n\\n          type = 'image/tga';\\n          break;\\n\\n        default:\\n          console.warn('FBXLoader: Image type \\\"' + extension + '\\\" is not supported.');\\n          return;\\n      }\\n\\n      if (typeof content === 'string') {\\n        // ASCII format\\n        return 'data:' + type + ';base64,' + content;\\n      } else {\\n        // Binary Format\\n        var array = new Uint8Array(content);\\n        return window.URL.createObjectURL(new Blob([array], {\\n          type: type\\n        }));\\n      }\\n    } // Parse nodes in FBXTree.Objects.Texture\\n    // These contain details such as UV scaling, cropping, rotation etc and are connected\\n    // to images in FBXTree.Objects.Video\\n\\n  }, {\\n    key: \\\"parseTextures\\\",\\n    value: function parseTextures(images) {\\n      var textureMap = new Map();\\n\\n      if ('Texture' in fbxTree.Objects) {\\n        var textureNodes = fbxTree.Objects.Texture;\\n\\n        for (var nodeID in textureNodes) {\\n          var texture = this.parseTexture(textureNodes[nodeID], images);\\n          textureMap.set(parseInt(nodeID), texture);\\n        }\\n      }\\n\\n      return textureMap;\\n    } // Parse individual node in FBXTree.Objects.Texture\\n\\n  }, {\\n    key: \\\"parseTexture\\\",\\n    value: function parseTexture(textureNode, images) {\\n      var texture = this.loadTexture(textureNode, images);\\n      texture.ID = textureNode.id;\\n      texture.name = textureNode.attrName;\\n      var wrapModeU = textureNode.WrapModeU;\\n      var wrapModeV = textureNode.WrapModeV;\\n      var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\\n      var valueV = wrapModeV !== undefined ? wrapModeV.value : 0; // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\\n      // 0: repeat(default), 1: clamp\\n\\n      texture.wrapS = valueU === 0 ? _three.RepeatWrapping : _three.ClampToEdgeWrapping;\\n      texture.wrapT = valueV === 0 ? _three.RepeatWrapping : _three.ClampToEdgeWrapping;\\n\\n      if ('Scaling' in textureNode) {\\n        var values = textureNode.Scaling.value;\\n        texture.repeat.x = values[0];\\n        texture.repeat.y = values[1];\\n      }\\n\\n      return texture;\\n    } // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\\n\\n  }, {\\n    key: \\\"loadTexture\\\",\\n    value: function loadTexture(textureNode, images) {\\n      var fileName;\\n      var currentPath = this.textureLoader.path;\\n      var children = connections.get(textureNode.id).children;\\n\\n      if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\\n        fileName = images[children[0].ID];\\n\\n        if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\\n          this.textureLoader.setPath(undefined);\\n        }\\n      }\\n\\n      var texture;\\n      var extension = textureNode.FileName.slice(-3).toLowerCase();\\n\\n      if (extension === 'tga') {\\n        var loader = this.manager.getHandler('.tga');\\n\\n        if (loader === null) {\\n          console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename);\\n          texture = new _three.Texture();\\n        } else {\\n          texture = loader.load(fileName);\\n        }\\n      } else if (extension === 'psd') {\\n        console.warn('FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename);\\n        texture = new _three.Texture();\\n      } else {\\n        texture = this.textureLoader.load(fileName);\\n      }\\n\\n      this.textureLoader.setPath(currentPath);\\n      return texture;\\n    } // Parse nodes in FBXTree.Objects.Material\\n\\n  }, {\\n    key: \\\"parseMaterials\\\",\\n    value: function parseMaterials(textureMap) {\\n      var materialMap = new Map();\\n\\n      if ('Material' in fbxTree.Objects) {\\n        var materialNodes = fbxTree.Objects.Material;\\n\\n        for (var nodeID in materialNodes) {\\n          var material = this.parseMaterial(materialNodes[nodeID], textureMap);\\n          if (material !== null) materialMap.set(parseInt(nodeID), material);\\n        }\\n      }\\n\\n      return materialMap;\\n    } // Parse single node in FBXTree.Objects.Material\\n    // Materials are connected to texture maps in FBXTree.Objects.Textures\\n    // FBX format currently only supports Lambert and Phong shading models\\n\\n  }, {\\n    key: \\\"parseMaterial\\\",\\n    value: function parseMaterial(materialNode, textureMap) {\\n      var ID = materialNode.id;\\n      var name = materialNode.attrName;\\n      var type = materialNode.ShadingModel; // Case where FBX wraps shading model in property object.\\n\\n      if (_typeof(type) === 'object') {\\n        type = type.value;\\n      } // Ignore unused materials which don't have any connections.\\n\\n\\n      if (!connections.has(ID)) return null;\\n      var parameters = this.parseParameters(materialNode, textureMap, ID);\\n      var material;\\n\\n      switch (type.toLowerCase()) {\\n        case 'phong':\\n          material = new _three.MeshPhongMaterial();\\n          break;\\n\\n        case 'lambert':\\n          material = new _three.MeshLambertMaterial();\\n          break;\\n\\n        default:\\n          console.warn('THREE.FBXLoader: unknown material type \\\"%s\\\". Defaulting to MeshPhongMaterial.', type);\\n          material = new _three.MeshPhongMaterial();\\n          break;\\n      }\\n\\n      material.setValues(parameters);\\n      material.name = name;\\n      return material;\\n    } // Parse FBX material and return parameters suitable for a three.js material\\n    // Also parse the texture map and return any textures associated with the material\\n\\n  }, {\\n    key: \\\"parseParameters\\\",\\n    value: function parseParameters(materialNode, textureMap, ID) {\\n      var parameters = {};\\n\\n      if (materialNode.BumpFactor) {\\n        parameters.bumpScale = materialNode.BumpFactor.value;\\n      }\\n\\n      if (materialNode.Diffuse) {\\n        parameters.color = new _three.Color().fromArray(materialNode.Diffuse.value);\\n      } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')) {\\n        // The blender exporter exports diffuse here instead of in materialNode.Diffuse\\n        parameters.color = new _three.Color().fromArray(materialNode.DiffuseColor.value);\\n      }\\n\\n      if (materialNode.DisplacementFactor) {\\n        parameters.displacementScale = materialNode.DisplacementFactor.value;\\n      }\\n\\n      if (materialNode.Emissive) {\\n        parameters.emissive = new _three.Color().fromArray(materialNode.Emissive.value);\\n      } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')) {\\n        // The blender exporter exports emissive color here instead of in materialNode.Emissive\\n        parameters.emissive = new _three.Color().fromArray(materialNode.EmissiveColor.value);\\n      }\\n\\n      if (materialNode.EmissiveFactor) {\\n        parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);\\n      }\\n\\n      if (materialNode.Opacity) {\\n        parameters.opacity = parseFloat(materialNode.Opacity.value);\\n      }\\n\\n      if (parameters.opacity < 1.0) {\\n        parameters.transparent = true;\\n      }\\n\\n      if (materialNode.ReflectionFactor) {\\n        parameters.reflectivity = materialNode.ReflectionFactor.value;\\n      }\\n\\n      if (materialNode.Shininess) {\\n        parameters.shininess = materialNode.Shininess.value;\\n      }\\n\\n      if (materialNode.Specular) {\\n        parameters.specular = new _three.Color().fromArray(materialNode.Specular.value);\\n      } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {\\n        // The blender exporter exports specular color here instead of in materialNode.Specular\\n        parameters.specular = new _three.Color().fromArray(materialNode.SpecularColor.value);\\n      }\\n\\n      var scope = this;\\n      connections.get(ID).children.forEach(function (child) {\\n        var type = child.relationship;\\n\\n        switch (type) {\\n          case 'Bump':\\n            parameters.bumpMap = scope.getTexture(textureMap, child.ID);\\n            break;\\n\\n          case 'Maya|TEX_ao_map':\\n            parameters.aoMap = scope.getTexture(textureMap, child.ID);\\n            break;\\n\\n          case 'DiffuseColor':\\n          case 'Maya|TEX_color_map':\\n            parameters.map = scope.getTexture(textureMap, child.ID);\\n            parameters.map.encoding = _three.sRGBEncoding;\\n            break;\\n\\n          case 'DisplacementColor':\\n            parameters.displacementMap = scope.getTexture(textureMap, child.ID);\\n            break;\\n\\n          case 'EmissiveColor':\\n            parameters.emissiveMap = scope.getTexture(textureMap, child.ID);\\n            parameters.emissiveMap.encoding = _three.sRGBEncoding;\\n            break;\\n\\n          case 'NormalMap':\\n          case 'Maya|TEX_normal_map':\\n            parameters.normalMap = scope.getTexture(textureMap, child.ID);\\n            break;\\n\\n          case 'ReflectionColor':\\n            parameters.envMap = scope.getTexture(textureMap, child.ID);\\n            parameters.envMap.mapping = _three.EquirectangularReflectionMapping;\\n            parameters.envMap.encoding = _three.sRGBEncoding;\\n            break;\\n\\n          case 'SpecularColor':\\n            parameters.specularMap = scope.getTexture(textureMap, child.ID);\\n            parameters.specularMap.encoding = _three.sRGBEncoding;\\n            break;\\n\\n          case 'TransparentColor':\\n          case 'TransparencyFactor':\\n            parameters.alphaMap = scope.getTexture(textureMap, child.ID);\\n            parameters.transparent = true;\\n            break;\\n\\n          case 'AmbientColor':\\n          case 'ShininessExponent': // AKA glossiness map\\n\\n          case 'SpecularFactor': // AKA specularLevel\\n\\n          case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\\n\\n          default:\\n            console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\\n            break;\\n        }\\n      });\\n      return parameters;\\n    } // get a texture from the textureMap for use by a material.\\n\\n  }, {\\n    key: \\\"getTexture\\\",\\n    value: function getTexture(textureMap, id) {\\n      // if the texture is a layered texture, just use the first layer and issue a warning\\n      if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {\\n        console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');\\n        id = connections.get(id).children[0].ID;\\n      }\\n\\n      return textureMap.get(id);\\n    } // Parse nodes in FBXTree.Objects.Deformer\\n    // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\\n    // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\\n\\n  }, {\\n    key: \\\"parseDeformers\\\",\\n    value: function parseDeformers() {\\n      var skeletons = {};\\n      var morphTargets = {};\\n\\n      if ('Deformer' in fbxTree.Objects) {\\n        var DeformerNodes = fbxTree.Objects.Deformer;\\n\\n        for (var nodeID in DeformerNodes) {\\n          var deformerNode = DeformerNodes[nodeID];\\n          var relationships = connections.get(parseInt(nodeID));\\n\\n          if (deformerNode.attrType === 'Skin') {\\n            var skeleton = this.parseSkeleton(relationships, DeformerNodes);\\n            skeleton.ID = nodeID;\\n\\n            if (relationships.parents.length > 1) {\\n              console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');\\n            }\\n\\n            skeleton.geometryID = relationships.parents[0].ID;\\n            skeletons[nodeID] = skeleton;\\n          } else if (deformerNode.attrType === 'BlendShape') {\\n            var morphTarget = {\\n              id: nodeID\\n            };\\n            morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);\\n            morphTarget.id = nodeID;\\n\\n            if (relationships.parents.length > 1) {\\n              console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');\\n            }\\n\\n            morphTargets[nodeID] = morphTarget;\\n          }\\n        }\\n      }\\n\\n      return {\\n        skeletons: skeletons,\\n        morphTargets: morphTargets\\n      };\\n    } // Parse single nodes in FBXTree.Objects.Deformer\\n    // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\\n    // Each skin node represents a skeleton and each cluster node represents a bone\\n\\n  }, {\\n    key: \\\"parseSkeleton\\\",\\n    value: function parseSkeleton(relationships, deformerNodes) {\\n      var rawBones = [];\\n      relationships.children.forEach(function (child) {\\n        var boneNode = deformerNodes[child.ID];\\n        if (boneNode.attrType !== 'Cluster') return;\\n        var rawBone = {\\n          ID: child.ID,\\n          indices: [],\\n          weights: [],\\n          transformLink: new _three.Matrix4().fromArray(boneNode.TransformLink.a) // transform: new Matrix4().fromArray( boneNode.Transform.a ),\\n          // linkMode: boneNode.Mode,\\n\\n        };\\n\\n        if ('Indexes' in boneNode) {\\n          rawBone.indices = boneNode.Indexes.a;\\n          rawBone.weights = boneNode.Weights.a;\\n        }\\n\\n        rawBones.push(rawBone);\\n      });\\n      return {\\n        rawBones: rawBones,\\n        bones: []\\n      };\\n    } // The top level morph deformer node has type \\\"BlendShape\\\" and sub nodes have type \\\"BlendShapeChannel\\\"\\n\\n  }, {\\n    key: \\\"parseMorphTargets\\\",\\n    value: function parseMorphTargets(relationships, deformerNodes) {\\n      var rawMorphTargets = [];\\n\\n      for (var i = 0; i < relationships.children.length; i++) {\\n        var child = relationships.children[i];\\n        var morphTargetNode = deformerNodes[child.ID];\\n        var rawMorphTarget = {\\n          name: morphTargetNode.attrName,\\n          initialWeight: morphTargetNode.DeformPercent,\\n          id: morphTargetNode.id,\\n          fullWeights: morphTargetNode.FullWeights.a\\n        };\\n        if (morphTargetNode.attrType !== 'BlendShapeChannel') return;\\n        rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {\\n          return child.relationship === undefined;\\n        })[0].ID;\\n        rawMorphTargets.push(rawMorphTarget);\\n      }\\n\\n      return rawMorphTargets;\\n    } // create the main Group() to be returned by the loader\\n\\n  }, {\\n    key: \\\"parseScene\\\",\\n    value: function parseScene(deformers, geometryMap, materialMap) {\\n      sceneGraph = new _three.Group();\\n      var modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);\\n      var modelNodes = fbxTree.Objects.Model;\\n      var scope = this;\\n      modelMap.forEach(function (model) {\\n        var modelNode = modelNodes[model.ID];\\n        scope.setLookAtProperties(model, modelNode);\\n        var parentConnections = connections.get(model.ID).parents;\\n        parentConnections.forEach(function (connection) {\\n          var parent = modelMap.get(connection.ID);\\n          if (parent !== undefined) parent.add(model);\\n        });\\n\\n        if (model.parent === null) {\\n          sceneGraph.add(model);\\n        }\\n      });\\n      this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);\\n      this.createAmbientLight();\\n      this.setupMorphMaterials();\\n      sceneGraph.traverse(function (node) {\\n        if (node.userData.transformData) {\\n          if (node.parent) {\\n            node.userData.transformData.parentMatrix = node.parent.matrix;\\n            node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\\n          }\\n\\n          var transform = generateTransform(node.userData.transformData);\\n          node.applyMatrix4(transform);\\n          node.updateWorldMatrix();\\n        }\\n      });\\n      var animations = new AnimationParser().parse(); // if all the models where already combined in a single group, just return that\\n\\n      if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\\n        sceneGraph.children[0].animations = animations;\\n        sceneGraph = sceneGraph.children[0];\\n      }\\n\\n      sceneGraph.animations = animations;\\n    } // parse nodes in FBXTree.Objects.Model\\n\\n  }, {\\n    key: \\\"parseModels\\\",\\n    value: function parseModels(skeletons, geometryMap, materialMap) {\\n      var modelMap = new Map();\\n      var modelNodes = fbxTree.Objects.Model;\\n\\n      for (var nodeID in modelNodes) {\\n        var id = parseInt(nodeID);\\n        var node = modelNodes[nodeID];\\n        var relationships = connections.get(id);\\n        var model = this.buildSkeleton(relationships, skeletons, id, node.attrName);\\n\\n        if (!model) {\\n          switch (node.attrType) {\\n            case 'Camera':\\n              model = this.createCamera(relationships);\\n              break;\\n\\n            case 'Light':\\n              model = this.createLight(relationships);\\n              break;\\n\\n            case 'Mesh':\\n              model = this.createMesh(relationships, geometryMap, materialMap);\\n              break;\\n\\n            case 'NurbsCurve':\\n              model = this.createCurve(relationships, geometryMap);\\n              break;\\n\\n            case 'LimbNode':\\n            case 'Root':\\n              model = new _three.Bone();\\n              break;\\n\\n            case 'Null':\\n            default:\\n              model = new _three.Group();\\n              break;\\n          }\\n\\n          model.name = node.attrName ? _three.PropertyBinding.sanitizeNodeName(node.attrName) : '';\\n          model.ID = id;\\n        }\\n\\n        this.getTransformData(model, node);\\n        modelMap.set(id, model);\\n      }\\n\\n      return modelMap;\\n    }\\n  }, {\\n    key: \\\"buildSkeleton\\\",\\n    value: function buildSkeleton(relationships, skeletons, id, name) {\\n      var bone = null;\\n      relationships.parents.forEach(function (parent) {\\n        var _loop = function _loop(ID) {\\n          var skeleton = skeletons[ID];\\n          skeleton.rawBones.forEach(function (rawBone, i) {\\n            if (rawBone.ID === parent.ID) {\\n              var subBone = bone;\\n              bone = new _three.Bone();\\n              bone.matrixWorld.copy(rawBone.transformLink); // set name and id here - otherwise in cases where \\\"subBone\\\" is created it will not have a name / id\\n\\n              bone.name = name ? _three.PropertyBinding.sanitizeNodeName(name) : '';\\n              bone.ID = id;\\n              skeleton.bones[i] = bone; // In cases where a bone is shared between multiple meshes\\n              // duplicate the bone here and and it as a child of the first bone\\n\\n              if (subBone !== null) {\\n                bone.add(subBone);\\n              }\\n            }\\n          });\\n        };\\n\\n        for (var ID in skeletons) {\\n          _loop(ID);\\n        }\\n      });\\n      return bone;\\n    } // create a PerspectiveCamera or OrthographicCamera\\n\\n  }, {\\n    key: \\\"createCamera\\\",\\n    value: function createCamera(relationships) {\\n      var model;\\n      var cameraAttribute;\\n      relationships.children.forEach(function (child) {\\n        var attr = fbxTree.Objects.NodeAttribute[child.ID];\\n\\n        if (attr !== undefined) {\\n          cameraAttribute = attr;\\n        }\\n      });\\n\\n      if (cameraAttribute === undefined) {\\n        model = new _three.Object3D();\\n      } else {\\n        var type = 0;\\n\\n        if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\\n          type = 1;\\n        }\\n\\n        var nearClippingPlane = 1;\\n\\n        if (cameraAttribute.NearPlane !== undefined) {\\n          nearClippingPlane = cameraAttribute.NearPlane.value / 1000;\\n        }\\n\\n        var farClippingPlane = 1000;\\n\\n        if (cameraAttribute.FarPlane !== undefined) {\\n          farClippingPlane = cameraAttribute.FarPlane.value / 1000;\\n        }\\n\\n        var width = window.innerWidth;\\n        var height = window.innerHeight;\\n\\n        if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\\n          width = cameraAttribute.AspectWidth.value;\\n          height = cameraAttribute.AspectHeight.value;\\n        }\\n\\n        var aspect = width / height;\\n        var fov = 45;\\n\\n        if (cameraAttribute.FieldOfView !== undefined) {\\n          fov = cameraAttribute.FieldOfView.value;\\n        }\\n\\n        var focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\\n\\n        switch (type) {\\n          case 0:\\n            // Perspective\\n            model = new _three.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\\n            if (focalLength !== null) model.setFocalLength(focalLength);\\n            break;\\n\\n          case 1:\\n            // Orthographic\\n            model = new _three.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\\n            break;\\n\\n          default:\\n            console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\\n            model = new _three.Object3D();\\n            break;\\n        }\\n      }\\n\\n      return model;\\n    } // Create a DirectionalLight, PointLight or SpotLight\\n\\n  }, {\\n    key: \\\"createLight\\\",\\n    value: function createLight(relationships) {\\n      var model;\\n      var lightAttribute;\\n      relationships.children.forEach(function (child) {\\n        var attr = fbxTree.Objects.NodeAttribute[child.ID];\\n\\n        if (attr !== undefined) {\\n          lightAttribute = attr;\\n        }\\n      });\\n\\n      if (lightAttribute === undefined) {\\n        model = new _three.Object3D();\\n      } else {\\n        var type; // LightType can be undefined for Point lights\\n\\n        if (lightAttribute.LightType === undefined) {\\n          type = 0;\\n        } else {\\n          type = lightAttribute.LightType.value;\\n        }\\n\\n        var color = 0xffffff;\\n\\n        if (lightAttribute.Color !== undefined) {\\n          color = new _three.Color().fromArray(lightAttribute.Color.value);\\n        }\\n\\n        var intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100; // light disabled\\n\\n        if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\\n          intensity = 0;\\n        }\\n\\n        var distance = 0;\\n\\n        if (lightAttribute.FarAttenuationEnd !== undefined) {\\n          if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\\n            distance = 0;\\n          } else {\\n            distance = lightAttribute.FarAttenuationEnd.value;\\n          }\\n        } // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\\n\\n\\n        var decay = 1;\\n\\n        switch (type) {\\n          case 0:\\n            // Point\\n            model = new _three.PointLight(color, intensity, distance, decay);\\n            break;\\n\\n          case 1:\\n            // Directional\\n            model = new _three.DirectionalLight(color, intensity);\\n            break;\\n\\n          case 2:\\n            // Spot\\n            var angle = Math.PI / 3;\\n\\n            if (lightAttribute.InnerAngle !== undefined) {\\n              angle = _three.MathUtils.degToRad(lightAttribute.InnerAngle.value);\\n            }\\n\\n            var penumbra = 0;\\n\\n            if (lightAttribute.OuterAngle !== undefined) {\\n              // TODO: this is not correct - FBX calculates outer and inner angle in degrees\\n              // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\\n              // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\\n              penumbra = _three.MathUtils.degToRad(lightAttribute.OuterAngle.value);\\n              penumbra = Math.max(penumbra, 1);\\n            }\\n\\n            model = new _three.SpotLight(color, intensity, distance, angle, penumbra, decay);\\n            break;\\n\\n          default:\\n            console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.');\\n            model = new _three.PointLight(color, intensity);\\n            break;\\n        }\\n\\n        if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\\n          model.castShadow = true;\\n        }\\n      }\\n\\n      return model;\\n    }\\n  }, {\\n    key: \\\"createMesh\\\",\\n    value: function createMesh(relationships, geometryMap, materialMap) {\\n      var model;\\n      var geometry = null;\\n      var material = null;\\n      var materials = []; // get geometry and materials(s) from connections\\n\\n      relationships.children.forEach(function (child) {\\n        if (geometryMap.has(child.ID)) {\\n          geometry = geometryMap.get(child.ID);\\n        }\\n\\n        if (materialMap.has(child.ID)) {\\n          materials.push(materialMap.get(child.ID));\\n        }\\n      });\\n\\n      if (materials.length > 1) {\\n        material = materials;\\n      } else if (materials.length > 0) {\\n        material = materials[0];\\n      } else {\\n        material = new _three.MeshPhongMaterial({\\n          color: 0xcccccc\\n        });\\n        materials.push(material);\\n      }\\n\\n      if ('color' in geometry.attributes) {\\n        materials.forEach(function (material) {\\n          material.vertexColors = true;\\n        });\\n      }\\n\\n      if (geometry.FBX_Deformer) {\\n        materials.forEach(function (material) {\\n          material.skinning = true;\\n        });\\n        model = new _three.SkinnedMesh(geometry, material);\\n        model.normalizeSkinWeights();\\n      } else {\\n        model = new _three.Mesh(geometry, material);\\n      }\\n\\n      return model;\\n    }\\n  }, {\\n    key: \\\"createCurve\\\",\\n    value: function createCurve(relationships, geometryMap) {\\n      var geometry = relationships.children.reduce(function (geo, child) {\\n        if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\\n        return geo;\\n      }, null); // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\\n\\n      var material = new _three.LineBasicMaterial({\\n        color: 0x3300ff,\\n        linewidth: 1\\n      });\\n      return new _three.Line(geometry, material);\\n    } // parse the model node for transform data\\n\\n  }, {\\n    key: \\\"getTransformData\\\",\\n    value: function getTransformData(model, modelNode) {\\n      var transformData = {};\\n      if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\\n      if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);else transformData.eulerOrder = 'ZYX';\\n      if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value;\\n      if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value;\\n      if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;\\n      if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value;\\n      if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;\\n      if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;\\n      if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;\\n      if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;\\n      if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;\\n      model.userData.transformData = transformData;\\n    }\\n  }, {\\n    key: \\\"setLookAtProperties\\\",\\n    value: function setLookAtProperties(model, modelNode) {\\n      if ('LookAtProperty' in modelNode) {\\n        var children = connections.get(model.ID).children;\\n        children.forEach(function (child) {\\n          if (child.relationship === 'LookAtProperty') {\\n            var lookAtTarget = fbxTree.Objects.Model[child.ID];\\n\\n            if ('Lcl_Translation' in lookAtTarget) {\\n              var pos = lookAtTarget.Lcl_Translation.value; // DirectionalLight, SpotLight\\n\\n              if (model.target !== undefined) {\\n                model.target.position.fromArray(pos);\\n                sceneGraph.add(model.target);\\n              } else {\\n                // Cameras and other Object3Ds\\n                model.lookAt(new _three.Vector3().fromArray(pos));\\n              }\\n            }\\n          }\\n        });\\n      }\\n    }\\n  }, {\\n    key: \\\"bindSkeleton\\\",\\n    value: function bindSkeleton(skeletons, geometryMap, modelMap) {\\n      var bindMatrices = this.parsePoseNodes();\\n\\n      var _loop2 = function _loop2(ID) {\\n        var skeleton = skeletons[ID];\\n        var parents = connections.get(parseInt(skeleton.ID)).parents;\\n        parents.forEach(function (parent) {\\n          if (geometryMap.has(parent.ID)) {\\n            var geoID = parent.ID;\\n            var geoRelationships = connections.get(geoID);\\n            geoRelationships.parents.forEach(function (geoConnParent) {\\n              if (modelMap.has(geoConnParent.ID)) {\\n                var model = modelMap.get(geoConnParent.ID);\\n                model.bind(new _three.Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\\n              }\\n            });\\n          }\\n        });\\n      };\\n\\n      for (var ID in skeletons) {\\n        _loop2(ID);\\n      }\\n    }\\n  }, {\\n    key: \\\"parsePoseNodes\\\",\\n    value: function parsePoseNodes() {\\n      var bindMatrices = {};\\n\\n      if ('Pose' in fbxTree.Objects) {\\n        var BindPoseNode = fbxTree.Objects.Pose;\\n\\n        for (var nodeID in BindPoseNode) {\\n          if (BindPoseNode[nodeID].attrType === 'BindPose') {\\n            var poseNodes = BindPoseNode[nodeID].PoseNode;\\n\\n            if (Array.isArray(poseNodes)) {\\n              poseNodes.forEach(function (poseNode) {\\n                bindMatrices[poseNode.Node] = new _three.Matrix4().fromArray(poseNode.Matrix.a);\\n              });\\n            } else {\\n              bindMatrices[poseNodes.Node] = new _three.Matrix4().fromArray(poseNodes.Matrix.a);\\n            }\\n          }\\n        }\\n      }\\n\\n      return bindMatrices;\\n    } // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\\n\\n  }, {\\n    key: \\\"createAmbientLight\\\",\\n    value: function createAmbientLight() {\\n      if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {\\n        var ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\\n        var r = ambientColor[0];\\n        var g = ambientColor[1];\\n        var b = ambientColor[2];\\n\\n        if (r !== 0 || g !== 0 || b !== 0) {\\n          var color = new _three.Color(r, g, b);\\n          sceneGraph.add(new _three.AmbientLight(color, 1));\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"setupMorphMaterials\\\",\\n    value: function setupMorphMaterials() {\\n      var scope = this;\\n      sceneGraph.traverse(function (child) {\\n        if (child.isMesh) {\\n          if (child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length) {\\n            if (Array.isArray(child.material)) {\\n              child.material.forEach(function (material, i) {\\n                scope.setupMorphMaterial(child, material, i);\\n              });\\n            } else {\\n              scope.setupMorphMaterial(child, child.material);\\n            }\\n          }\\n        }\\n      });\\n    }\\n  }, {\\n    key: \\\"setupMorphMaterial\\\",\\n    value: function setupMorphMaterial(child, material, index) {\\n      var uuid = child.uuid;\\n      var matUuid = material.uuid; // if a geometry has morph targets, it cannot share the material with other geometries\\n\\n      var sharedMat = false;\\n      sceneGraph.traverse(function (node) {\\n        if (node.isMesh) {\\n          if (Array.isArray(node.material)) {\\n            node.material.forEach(function (mat) {\\n              if (mat.uuid === matUuid && node.uuid !== uuid) sharedMat = true;\\n            });\\n          } else if (node.material.uuid === matUuid && node.uuid !== uuid) {\\n            sharedMat = true;\\n          }\\n        }\\n      });\\n\\n      if (sharedMat === true) {\\n        var clonedMat = material.clone();\\n        clonedMat.morphTargets = true;\\n        if (index === undefined) child.material = clonedMat;else child.material[index] = clonedMat;\\n      } else {\\n        material.morphTargets = true;\\n      }\\n    }\\n  }]);\\n\\n  return FBXTreeParser;\\n}(); // parse Geometry data from FBXTree and return map of BufferGeometries\\n\\n\\nvar GeometryParser =\\n/*#__PURE__*/\\nfunction () {\\n  function GeometryParser() {\\n    _classCallCheck(this, GeometryParser);\\n  }\\n\\n  _createClass(GeometryParser, [{\\n    key: \\\"parse\\\",\\n    // Parse nodes in FBXTree.Objects.Geometry\\n    value: function parse(deformers) {\\n      var geometryMap = new Map();\\n\\n      if ('Geometry' in fbxTree.Objects) {\\n        var geoNodes = fbxTree.Objects.Geometry;\\n\\n        for (var nodeID in geoNodes) {\\n          var relationships = connections.get(parseInt(nodeID));\\n          var geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);\\n          geometryMap.set(parseInt(nodeID), geo);\\n        }\\n      }\\n\\n      return geometryMap;\\n    } // Parse single node in FBXTree.Objects.Geometry\\n\\n  }, {\\n    key: \\\"parseGeometry\\\",\\n    value: function parseGeometry(relationships, geoNode, deformers) {\\n      switch (geoNode.attrType) {\\n        case 'Mesh':\\n          return this.parseMeshGeometry(relationships, geoNode, deformers);\\n\\n        case 'NurbsCurve':\\n          return this.parseNurbsGeometry(geoNode);\\n      }\\n    } // Parse single node mesh geometry in FBXTree.Objects.Geometry\\n\\n  }, {\\n    key: \\\"parseMeshGeometry\\\",\\n    value: function parseMeshGeometry(relationships, geoNode, deformers) {\\n      var skeletons = deformers.skeletons;\\n      var morphTargets = [];\\n      var modelNodes = relationships.parents.map(function (parent) {\\n        return fbxTree.Objects.Model[parent.ID];\\n      }); // don't create geometry if it is not associated with any models\\n\\n      if (modelNodes.length === 0) return;\\n      var skeleton = relationships.children.reduce(function (skeleton, child) {\\n        if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\\n        return skeleton;\\n      }, null);\\n      relationships.children.forEach(function (child) {\\n        if (deformers.morphTargets[child.ID] !== undefined) {\\n          morphTargets.push(deformers.morphTargets[child.ID]);\\n        }\\n      }); // Assume one model and get the preRotation from that\\n      // if there is more than one model associated with the geometry this may cause problems\\n\\n      var modelNode = modelNodes[0];\\n      var transformData = {};\\n      if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);\\n      if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\\n      if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value;\\n      if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value;\\n      if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value;\\n      var transform = generateTransform(transformData);\\n      return this.genGeometry(geoNode, skeleton, morphTargets, transform);\\n    } // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\\n\\n  }, {\\n    key: \\\"genGeometry\\\",\\n    value: function genGeometry(geoNode, skeleton, morphTargets, preTransform) {\\n      var geo = new _three.BufferGeometry();\\n      if (geoNode.attrName) geo.name = geoNode.attrName;\\n      var geoInfo = this.parseGeoNode(geoNode, skeleton);\\n      var buffers = this.genBuffers(geoInfo);\\n      var positionAttribute = new _three.Float32BufferAttribute(buffers.vertex, 3);\\n      positionAttribute.applyMatrix4(preTransform);\\n      geo.setAttribute('position', positionAttribute);\\n\\n      if (buffers.colors.length > 0) {\\n        geo.setAttribute('color', new _three.Float32BufferAttribute(buffers.colors, 3));\\n      }\\n\\n      if (skeleton) {\\n        geo.setAttribute('skinIndex', new _three.Uint16BufferAttribute(buffers.weightsIndices, 4));\\n        geo.setAttribute('skinWeight', new _three.Float32BufferAttribute(buffers.vertexWeights, 4)); // used later to bind the skeleton to the model\\n\\n        geo.FBX_Deformer = skeleton;\\n      }\\n\\n      if (buffers.normal.length > 0) {\\n        var normalMatrix = new _three.Matrix3().getNormalMatrix(preTransform);\\n        var normalAttribute = new _three.Float32BufferAttribute(buffers.normal, 3);\\n        normalAttribute.applyNormalMatrix(normalMatrix);\\n        geo.setAttribute('normal', normalAttribute);\\n      }\\n\\n      buffers.uvs.forEach(function (uvBuffer, i) {\\n        // subsequent uv buffers are called 'uv1', 'uv2', ...\\n        var name = 'uv' + (i + 1).toString(); // the first uv buffer is just called 'uv'\\n\\n        if (i === 0) {\\n          name = 'uv';\\n        }\\n\\n        geo.setAttribute(name, new _three.Float32BufferAttribute(buffers.uvs[i], 2));\\n      });\\n\\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\\n        // Convert the material indices of each vertex into rendering groups on the geometry.\\n        var prevMaterialIndex = buffers.materialIndex[0];\\n        var startIndex = 0;\\n        buffers.materialIndex.forEach(function (currentIndex, i) {\\n          if (currentIndex !== prevMaterialIndex) {\\n            geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\\n            prevMaterialIndex = currentIndex;\\n            startIndex = i;\\n          }\\n        }); // the loop above doesn't add the last group, do that here.\\n\\n        if (geo.groups.length > 0) {\\n          var lastGroup = geo.groups[geo.groups.length - 1];\\n          var lastIndex = lastGroup.start + lastGroup.count;\\n\\n          if (lastIndex !== buffers.materialIndex.length) {\\n            geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\\n          }\\n        } // case where there are multiple materials but the whole geometry is only\\n        // using one of them\\n\\n\\n        if (geo.groups.length === 0) {\\n          geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\\n        }\\n      }\\n\\n      this.addMorphTargets(geo, geoNode, morphTargets, preTransform);\\n      return geo;\\n    }\\n  }, {\\n    key: \\\"parseGeoNode\\\",\\n    value: function parseGeoNode(geoNode, skeleton) {\\n      var geoInfo = {};\\n      geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\\n      geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\\n\\n      if (geoNode.LayerElementColor) {\\n        geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);\\n      }\\n\\n      if (geoNode.LayerElementMaterial) {\\n        geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);\\n      }\\n\\n      if (geoNode.LayerElementNormal) {\\n        geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);\\n      }\\n\\n      if (geoNode.LayerElementUV) {\\n        geoInfo.uv = [];\\n        var i = 0;\\n\\n        while (geoNode.LayerElementUV[i]) {\\n          if (geoNode.LayerElementUV[i].UV) {\\n            geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));\\n          }\\n\\n          i++;\\n        }\\n      }\\n\\n      geoInfo.weightTable = {};\\n\\n      if (skeleton !== null) {\\n        geoInfo.skeleton = skeleton;\\n        skeleton.rawBones.forEach(function (rawBone, i) {\\n          // loop over the bone's vertex indices and weights\\n          rawBone.indices.forEach(function (index, j) {\\n            if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\\n            geoInfo.weightTable[index].push({\\n              id: i,\\n              weight: rawBone.weights[j]\\n            });\\n          });\\n        });\\n      }\\n\\n      return geoInfo;\\n    }\\n  }, {\\n    key: \\\"genBuffers\\\",\\n    value: function genBuffers(geoInfo) {\\n      var buffers = {\\n        vertex: [],\\n        normal: [],\\n        colors: [],\\n        uvs: [],\\n        materialIndex: [],\\n        vertexWeights: [],\\n        weightsIndices: []\\n      };\\n      var polygonIndex = 0;\\n      var faceLength = 0;\\n      var displayedWeightsWarning = false; // these will hold data for a single face\\n\\n      var facePositionIndexes = [];\\n      var faceNormals = [];\\n      var faceColors = [];\\n      var faceUVs = [];\\n      var faceWeights = [];\\n      var faceWeightIndices = [];\\n      var scope = this;\\n      geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\\n        var materialIndex;\\n        var endOfFace = false; // Face index and vertex index arrays are combined in a single array\\n        // A cube with quad faces looks like this:\\n        // PolygonVertexIndex: *24 {\\n        //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\\n        //  }\\n        // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\\n        // to find index of last vertex bit shift the index: ^ - 1\\n\\n        if (vertexIndex < 0) {\\n          vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\\n\\n          endOfFace = true;\\n        }\\n\\n        var weightIndices = [];\\n        var weights = [];\\n        facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\\n\\n        if (geoInfo.color) {\\n          var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\\n          faceColors.push(data[0], data[1], data[2]);\\n        }\\n\\n        if (geoInfo.skeleton) {\\n          if (geoInfo.weightTable[vertexIndex] !== undefined) {\\n            geoInfo.weightTable[vertexIndex].forEach(function (wt) {\\n              weights.push(wt.weight);\\n              weightIndices.push(wt.id);\\n            });\\n          }\\n\\n          if (weights.length > 4) {\\n            if (!displayedWeightsWarning) {\\n              console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\\n              displayedWeightsWarning = true;\\n            }\\n\\n            var wIndex = [0, 0, 0, 0];\\n            var Weight = [0, 0, 0, 0];\\n            weights.forEach(function (weight, weightIndex) {\\n              var currentWeight = weight;\\n              var currentIndex = weightIndices[weightIndex];\\n              Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\\n                if (currentWeight > comparedWeight) {\\n                  comparedWeightArray[comparedWeightIndex] = currentWeight;\\n                  currentWeight = comparedWeight;\\n                  var tmp = wIndex[comparedWeightIndex];\\n                  wIndex[comparedWeightIndex] = currentIndex;\\n                  currentIndex = tmp;\\n                }\\n              });\\n            });\\n            weightIndices = wIndex;\\n            weights = Weight;\\n          } // if the weight array is shorter than 4 pad with 0s\\n\\n\\n          while (weights.length < 4) {\\n            weights.push(0);\\n            weightIndices.push(0);\\n          }\\n\\n          for (var i = 0; i < 4; ++i) {\\n            faceWeights.push(weights[i]);\\n            faceWeightIndices.push(weightIndices[i]);\\n          }\\n        }\\n\\n        if (geoInfo.normal) {\\n          var _data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\\n\\n          faceNormals.push(_data[0], _data[1], _data[2]);\\n        }\\n\\n        if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\\n          materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\\n        }\\n\\n        if (geoInfo.uv) {\\n          geoInfo.uv.forEach(function (uv, i) {\\n            var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\\n\\n            if (faceUVs[i] === undefined) {\\n              faceUVs[i] = [];\\n            }\\n\\n            faceUVs[i].push(data[0]);\\n            faceUVs[i].push(data[1]);\\n          });\\n        }\\n\\n        faceLength++;\\n\\n        if (endOfFace) {\\n          scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\\n          polygonIndex++;\\n          faceLength = 0; // reset arrays for the next face\\n\\n          facePositionIndexes = [];\\n          faceNormals = [];\\n          faceColors = [];\\n          faceUVs = [];\\n          faceWeights = [];\\n          faceWeightIndices = [];\\n        }\\n      });\\n      return buffers;\\n    } // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\\n\\n  }, {\\n    key: \\\"genFace\\\",\\n    value: function genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\\n      var _loop3 = function _loop3(i) {\\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\\n        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\\n\\n        if (geoInfo.skeleton) {\\n          buffers.vertexWeights.push(faceWeights[0]);\\n          buffers.vertexWeights.push(faceWeights[1]);\\n          buffers.vertexWeights.push(faceWeights[2]);\\n          buffers.vertexWeights.push(faceWeights[3]);\\n          buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\\n          buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\\n          buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\\n          buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\\n          buffers.vertexWeights.push(faceWeights[i * 4]);\\n          buffers.vertexWeights.push(faceWeights[i * 4 + 1]);\\n          buffers.vertexWeights.push(faceWeights[i * 4 + 2]);\\n          buffers.vertexWeights.push(faceWeights[i * 4 + 3]);\\n          buffers.weightsIndices.push(faceWeightIndices[0]);\\n          buffers.weightsIndices.push(faceWeightIndices[1]);\\n          buffers.weightsIndices.push(faceWeightIndices[2]);\\n          buffers.weightsIndices.push(faceWeightIndices[3]);\\n          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\\n          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\\n          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\\n          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\\n          buffers.weightsIndices.push(faceWeightIndices[i * 4]);\\n          buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\\n          buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\\n          buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\\n        }\\n\\n        if (geoInfo.color) {\\n          buffers.colors.push(faceColors[0]);\\n          buffers.colors.push(faceColors[1]);\\n          buffers.colors.push(faceColors[2]);\\n          buffers.colors.push(faceColors[(i - 1) * 3]);\\n          buffers.colors.push(faceColors[(i - 1) * 3 + 1]);\\n          buffers.colors.push(faceColors[(i - 1) * 3 + 2]);\\n          buffers.colors.push(faceColors[i * 3]);\\n          buffers.colors.push(faceColors[i * 3 + 1]);\\n          buffers.colors.push(faceColors[i * 3 + 2]);\\n        }\\n\\n        if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\\n          buffers.materialIndex.push(materialIndex);\\n          buffers.materialIndex.push(materialIndex);\\n          buffers.materialIndex.push(materialIndex);\\n        }\\n\\n        if (geoInfo.normal) {\\n          buffers.normal.push(faceNormals[0]);\\n          buffers.normal.push(faceNormals[1]);\\n          buffers.normal.push(faceNormals[2]);\\n          buffers.normal.push(faceNormals[(i - 1) * 3]);\\n          buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\\n          buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\\n          buffers.normal.push(faceNormals[i * 3]);\\n          buffers.normal.push(faceNormals[i * 3 + 1]);\\n          buffers.normal.push(faceNormals[i * 3 + 2]);\\n        }\\n\\n        if (geoInfo.uv) {\\n          geoInfo.uv.forEach(function (uv, j) {\\n            if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\\n            buffers.uvs[j].push(faceUVs[j][0]);\\n            buffers.uvs[j].push(faceUVs[j][1]);\\n            buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\\n            buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\\n            buffers.uvs[j].push(faceUVs[j][i * 2]);\\n            buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\\n          });\\n        }\\n      };\\n\\n      for (var i = 2; i < faceLength; i++) {\\n        _loop3(i);\\n      }\\n    }\\n  }, {\\n    key: \\\"addMorphTargets\\\",\\n    value: function addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\\n      if (morphTargets.length === 0) return;\\n      parentGeo.morphTargetsRelative = true;\\n      parentGeo.morphAttributes.position = []; // parentGeo.morphAttributes.normal = []; // not implemented\\n\\n      var scope = this;\\n      morphTargets.forEach(function (morphTarget) {\\n        morphTarget.rawTargets.forEach(function (rawTarget) {\\n          var morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];\\n\\n          if (morphGeoNode !== undefined) {\\n            scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);\\n          }\\n        });\\n      });\\n    } // a morph geometry node is similar to a standard  node, and the node is also contained\\n    // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\\n    // and a special attribute Index defining which vertices of the original geometry are affected\\n    // Normal and position attributes only have data for the vertices that are affected by the morph\\n\\n  }, {\\n    key: \\\"genMorphGeometry\\\",\\n    value: function genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\\n      var vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];\\n      var morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\\n      var indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\\n      var length = parentGeo.attributes.position.count * 3;\\n      var morphPositions = new Float32Array(length);\\n\\n      for (var i = 0; i < indices.length; i++) {\\n        var morphIndex = indices[i] * 3;\\n        morphPositions[morphIndex] = morphPositionsSparse[i * 3];\\n        morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];\\n        morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];\\n      } // TODO: add morph normal support\\n\\n\\n      var morphGeoInfo = {\\n        vertexIndices: vertexIndices,\\n        vertexPositions: morphPositions\\n      };\\n      var morphBuffers = this.genBuffers(morphGeoInfo);\\n      var positionAttribute = new _three.Float32BufferAttribute(morphBuffers.vertex, 3);\\n      positionAttribute.name = name || morphGeoNode.attrName;\\n      positionAttribute.applyMatrix4(preTransform);\\n      parentGeo.morphAttributes.position.push(positionAttribute);\\n    } // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\\n\\n  }, {\\n    key: \\\"parseNormals\\\",\\n    value: function parseNormals(NormalNode) {\\n      var mappingType = NormalNode.MappingInformationType;\\n      var referenceType = NormalNode.ReferenceInformationType;\\n      var buffer = NormalNode.Normals.a;\\n      var indexBuffer = [];\\n\\n      if (referenceType === 'IndexToDirect') {\\n        if ('NormalIndex' in NormalNode) {\\n          indexBuffer = NormalNode.NormalIndex.a;\\n        } else if ('NormalsIndex' in NormalNode) {\\n          indexBuffer = NormalNode.NormalsIndex.a;\\n        }\\n      }\\n\\n      return {\\n        dataSize: 3,\\n        buffer: buffer,\\n        indices: indexBuffer,\\n        mappingType: mappingType,\\n        referenceType: referenceType\\n      };\\n    } // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\\n\\n  }, {\\n    key: \\\"parseUVs\\\",\\n    value: function parseUVs(UVNode) {\\n      var mappingType = UVNode.MappingInformationType;\\n      var referenceType = UVNode.ReferenceInformationType;\\n      var buffer = UVNode.UV.a;\\n      var indexBuffer = [];\\n\\n      if (referenceType === 'IndexToDirect') {\\n        indexBuffer = UVNode.UVIndex.a;\\n      }\\n\\n      return {\\n        dataSize: 2,\\n        buffer: buffer,\\n        indices: indexBuffer,\\n        mappingType: mappingType,\\n        referenceType: referenceType\\n      };\\n    } // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\\n\\n  }, {\\n    key: \\\"parseVertexColors\\\",\\n    value: function parseVertexColors(ColorNode) {\\n      var mappingType = ColorNode.MappingInformationType;\\n      var referenceType = ColorNode.ReferenceInformationType;\\n      var buffer = ColorNode.Colors.a;\\n      var indexBuffer = [];\\n\\n      if (referenceType === 'IndexToDirect') {\\n        indexBuffer = ColorNode.ColorIndex.a;\\n      }\\n\\n      return {\\n        dataSize: 4,\\n        buffer: buffer,\\n        indices: indexBuffer,\\n        mappingType: mappingType,\\n        referenceType: referenceType\\n      };\\n    } // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\\n\\n  }, {\\n    key: \\\"parseMaterialIndices\\\",\\n    value: function parseMaterialIndices(MaterialNode) {\\n      var mappingType = MaterialNode.MappingInformationType;\\n      var referenceType = MaterialNode.ReferenceInformationType;\\n\\n      if (mappingType === 'NoMappingInformation') {\\n        return {\\n          dataSize: 1,\\n          buffer: [0],\\n          indices: [0],\\n          mappingType: 'AllSame',\\n          referenceType: referenceType\\n        };\\n      }\\n\\n      var materialIndexBuffer = MaterialNode.Materials.a; // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\\n      // we expect.So we create an intermediate buffer that points to the index in the buffer,\\n      // for conforming with the other functions we've written for other data.\\n\\n      var materialIndices = [];\\n\\n      for (var i = 0; i < materialIndexBuffer.length; ++i) {\\n        materialIndices.push(i);\\n      }\\n\\n      return {\\n        dataSize: 1,\\n        buffer: materialIndexBuffer,\\n        indices: materialIndices,\\n        mappingType: mappingType,\\n        referenceType: referenceType\\n      };\\n    } // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\\n\\n  }, {\\n    key: \\\"parseNurbsGeometry\\\",\\n    value: function parseNurbsGeometry(geoNode) {\\n      if (_NURBSCurve.NURBSCurve === undefined) {\\n        console.error('THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\\n        return new _three.BufferGeometry();\\n      }\\n\\n      var order = parseInt(geoNode.Order);\\n\\n      if (isNaN(order)) {\\n        console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);\\n        return new _three.BufferGeometry();\\n      }\\n\\n      var degree = order - 1;\\n      var knots = geoNode.KnotVector.a;\\n      var controlPoints = [];\\n      var pointsValues = geoNode.Points.a;\\n\\n      for (var i = 0, l = pointsValues.length; i < l; i += 4) {\\n        controlPoints.push(new _three.Vector4().fromArray(pointsValues, i));\\n      }\\n\\n      var startKnot, endKnot;\\n\\n      if (geoNode.Form === 'Closed') {\\n        controlPoints.push(controlPoints[0]);\\n      } else if (geoNode.Form === 'Periodic') {\\n        startKnot = degree;\\n        endKnot = knots.length - 1 - startKnot;\\n\\n        for (var _i = 0; _i < degree; ++_i) {\\n          controlPoints.push(controlPoints[_i]);\\n        }\\n      }\\n\\n      var curve = new _NURBSCurve.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\\n      var vertices = curve.getPoints(controlPoints.length * 7);\\n      var positions = new Float32Array(vertices.length * 3);\\n      vertices.forEach(function (vertex, i) {\\n        vertex.toArray(positions, i * 3);\\n      });\\n      var geometry = new _three.BufferGeometry();\\n      geometry.setAttribute('position', new _three.BufferAttribute(positions, 3));\\n      return geometry;\\n    }\\n  }]);\\n\\n  return GeometryParser;\\n}(); // parse animation data from FBXTree\\n\\n\\nvar AnimationParser =\\n/*#__PURE__*/\\nfunction () {\\n  function AnimationParser() {\\n    _classCallCheck(this, AnimationParser);\\n  }\\n\\n  _createClass(AnimationParser, [{\\n    key: \\\"parse\\\",\\n    // take raw animation clips and turn them into three.js animation clips\\n    value: function parse() {\\n      var animationClips = [];\\n      var rawClips = this.parseClips();\\n\\n      if (rawClips !== undefined) {\\n        for (var key in rawClips) {\\n          var rawClip = rawClips[key];\\n          var clip = this.addClip(rawClip);\\n          animationClips.push(clip);\\n        }\\n      }\\n\\n      return animationClips;\\n    }\\n  }, {\\n    key: \\\"parseClips\\\",\\n    value: function parseClips() {\\n      // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\\n      // if this is undefined we can safely assume there are no animations\\n      if (fbxTree.Objects.AnimationCurve === undefined) return undefined;\\n      var curveNodesMap = this.parseAnimationCurveNodes();\\n      this.parseAnimationCurves(curveNodesMap);\\n      var layersMap = this.parseAnimationLayers(curveNodesMap);\\n      var rawClips = this.parseAnimStacks(layersMap);\\n      return rawClips;\\n    } // parse nodes in FBXTree.Objects.AnimationCurveNode\\n    // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\\n    // and is referenced by an AnimationLayer\\n\\n  }, {\\n    key: \\\"parseAnimationCurveNodes\\\",\\n    value: function parseAnimationCurveNodes() {\\n      var rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\\n      var curveNodesMap = new Map();\\n\\n      for (var nodeID in rawCurveNodes) {\\n        var rawCurveNode = rawCurveNodes[nodeID];\\n\\n        if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\\n          var curveNode = {\\n            id: rawCurveNode.id,\\n            attr: rawCurveNode.attrName,\\n            curves: {}\\n          };\\n          curveNodesMap.set(curveNode.id, curveNode);\\n        }\\n      }\\n\\n      return curveNodesMap;\\n    } // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\\n    // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\\n    // axis ( e.g. times and values of x rotation)\\n\\n  }, {\\n    key: \\\"parseAnimationCurves\\\",\\n    value: function parseAnimationCurves(curveNodesMap) {\\n      var rawCurves = fbxTree.Objects.AnimationCurve; // TODO: Many values are identical up to roundoff error, but won't be optimised\\n      // e.g. position times: [0, 0.4, 0. 8]\\n      // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\\n      // clearly, this should be optimised to\\n      // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\\n      // this shows up in nearly every FBX file, and generally time array is length > 100\\n\\n      for (var nodeID in rawCurves) {\\n        var animationCurve = {\\n          id: rawCurves[nodeID].id,\\n          times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\\n          values: rawCurves[nodeID].KeyValueFloat.a\\n        };\\n        var relationships = connections.get(animationCurve.id);\\n\\n        if (relationships !== undefined) {\\n          var animationCurveID = relationships.parents[0].ID;\\n          var animationCurveRelationship = relationships.parents[0].relationship;\\n\\n          if (animationCurveRelationship.match(/X/)) {\\n            curveNodesMap.get(animationCurveID).curves['x'] = animationCurve;\\n          } else if (animationCurveRelationship.match(/Y/)) {\\n            curveNodesMap.get(animationCurveID).curves['y'] = animationCurve;\\n          } else if (animationCurveRelationship.match(/Z/)) {\\n            curveNodesMap.get(animationCurveID).curves['z'] = animationCurve;\\n          } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {\\n            curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve;\\n          }\\n        }\\n      }\\n    } // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\\n    // to various AnimationCurveNodes and is referenced by an AnimationStack node\\n    // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\\n\\n  }, {\\n    key: \\\"parseAnimationLayers\\\",\\n    value: function parseAnimationLayers(curveNodesMap) {\\n      var rawLayers = fbxTree.Objects.AnimationLayer;\\n      var layersMap = new Map();\\n\\n      var _loop4 = function _loop4(nodeID) {\\n        var layerCurveNodes = [];\\n        var connection = connections.get(parseInt(nodeID));\\n\\n        if (connection !== undefined) {\\n          // all the animationCurveNodes used in the layer\\n          var children = connection.children;\\n          children.forEach(function (child, i) {\\n            if (curveNodesMap.has(child.ID)) {\\n              var curveNode = curveNodesMap.get(child.ID); // check that the curves are defined for at least one axis, otherwise ignore the curveNode\\n\\n              if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\\n                if (layerCurveNodes[i] === undefined) {\\n                  var modelID = connections.get(child.ID).parents.filter(function (parent) {\\n                    return parent.relationship !== undefined;\\n                  })[0].ID;\\n\\n                  if (modelID !== undefined) {\\n                    var rawModel = fbxTree.Objects.Model[modelID.toString()];\\n\\n                    if (rawModel === undefined) {\\n                      console.warn('THREE.FBXLoader: Encountered a unused curve.', child);\\n                      return;\\n                    }\\n\\n                    var node = {\\n                      modelName: rawModel.attrName ? _three.PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',\\n                      ID: rawModel.id,\\n                      initialPosition: [0, 0, 0],\\n                      initialRotation: [0, 0, 0],\\n                      initialScale: [1, 1, 1]\\n                    };\\n                    sceneGraph.traverse(function (child) {\\n                      if (child.ID === rawModel.id) {\\n                        node.transform = child.matrix;\\n                        if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder;\\n                      }\\n                    });\\n                    if (!node.transform) node.transform = new _three.Matrix4(); // if the animated model is pre rotated, we'll have to apply the pre rotations to every\\n                    // animation value as well\\n\\n                    if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value;\\n                    if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value;\\n                    layerCurveNodes[i] = node;\\n                  }\\n                }\\n\\n                if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;\\n              } else if (curveNode.curves.morph !== undefined) {\\n                if (layerCurveNodes[i] === undefined) {\\n                  var deformerID = connections.get(child.ID).parents.filter(function (parent) {\\n                    return parent.relationship !== undefined;\\n                  })[0].ID;\\n                  var morpherID = connections.get(deformerID).parents[0].ID;\\n                  var geoID = connections.get(morpherID).parents[0].ID; // assuming geometry is not used in more than one model\\n\\n                  var _modelID = connections.get(geoID).parents[0].ID;\\n                  var _rawModel = fbxTree.Objects.Model[_modelID];\\n                  var _node = {\\n                    modelName: _rawModel.attrName ? _three.PropertyBinding.sanitizeNodeName(_rawModel.attrName) : '',\\n                    morphName: fbxTree.Objects.Deformer[deformerID].attrName\\n                  };\\n                  layerCurveNodes[i] = _node;\\n                }\\n\\n                layerCurveNodes[i][curveNode.attr] = curveNode;\\n              }\\n            }\\n          });\\n          layersMap.set(parseInt(nodeID), layerCurveNodes);\\n        }\\n      };\\n\\n      for (var nodeID in rawLayers) {\\n        _loop4(nodeID);\\n      }\\n\\n      return layersMap;\\n    } // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\\n    // hierarchy. Each Stack node will be used to create a AnimationClip\\n\\n  }, {\\n    key: \\\"parseAnimStacks\\\",\\n    value: function parseAnimStacks(layersMap) {\\n      var rawStacks = fbxTree.Objects.AnimationStack; // connect the stacks (clips) up to the layers\\n\\n      var rawClips = {};\\n\\n      for (var nodeID in rawStacks) {\\n        var children = connections.get(parseInt(nodeID)).children;\\n\\n        if (children.length > 1) {\\n          // it seems like stacks will always be associated with a single layer. But just in case there are files\\n          // where there are multiple layers per stack, we'll display a warning\\n          console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');\\n        }\\n\\n        var layer = layersMap.get(children[0].ID);\\n        rawClips[nodeID] = {\\n          name: rawStacks[nodeID].attrName,\\n          layer: layer\\n        };\\n      }\\n\\n      return rawClips;\\n    }\\n  }, {\\n    key: \\\"addClip\\\",\\n    value: function addClip(rawClip) {\\n      var tracks = [];\\n      var scope = this;\\n      rawClip.layer.forEach(function (rawTracks) {\\n        tracks = tracks.concat(scope.generateTracks(rawTracks));\\n      });\\n      return new _three.AnimationClip(rawClip.name, -1, tracks);\\n    }\\n  }, {\\n    key: \\\"generateTracks\\\",\\n    value: function generateTracks(rawTracks) {\\n      var tracks = [];\\n      var initialPosition = new _three.Vector3();\\n      var initialRotation = new _three.Quaternion();\\n      var initialScale = new _three.Vector3();\\n      if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);\\n      initialPosition = initialPosition.toArray();\\n      initialRotation = new _three.Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();\\n      initialScale = initialScale.toArray();\\n\\n      if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\\n        var positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position');\\n        if (positionTrack !== undefined) tracks.push(positionTrack);\\n      }\\n\\n      if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\\n        var rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);\\n        if (rotationTrack !== undefined) tracks.push(rotationTrack);\\n      }\\n\\n      if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\\n        var scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale');\\n        if (scaleTrack !== undefined) tracks.push(scaleTrack);\\n      }\\n\\n      if (rawTracks.DeformPercent !== undefined) {\\n        var morphTrack = this.generateMorphTrack(rawTracks);\\n        if (morphTrack !== undefined) tracks.push(morphTrack);\\n      }\\n\\n      return tracks;\\n    }\\n  }, {\\n    key: \\\"generateVectorTrack\\\",\\n    value: function generateVectorTrack(modelName, curves, initialValue, type) {\\n      var times = this.getTimesForAllAxes(curves);\\n      var values = this.getKeyframeTrackValues(times, curves, initialValue);\\n      return new _three.VectorKeyframeTrack(modelName + '.' + type, times, values);\\n    }\\n  }, {\\n    key: \\\"generateRotationTrack\\\",\\n    value: function generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\\n      if (curves.x !== undefined) {\\n        this.interpolateRotations(curves.x);\\n        curves.x.values = curves.x.values.map(_three.MathUtils.degToRad);\\n      }\\n\\n      if (curves.y !== undefined) {\\n        this.interpolateRotations(curves.y);\\n        curves.y.values = curves.y.values.map(_three.MathUtils.degToRad);\\n      }\\n\\n      if (curves.z !== undefined) {\\n        this.interpolateRotations(curves.z);\\n        curves.z.values = curves.z.values.map(_three.MathUtils.degToRad);\\n      }\\n\\n      var times = this.getTimesForAllAxes(curves);\\n      var values = this.getKeyframeTrackValues(times, curves, initialValue);\\n\\n      if (preRotation !== undefined) {\\n        preRotation = preRotation.map(_three.MathUtils.degToRad);\\n        preRotation.push(eulerOrder);\\n        preRotation = new _three.Euler().fromArray(preRotation);\\n        preRotation = new _three.Quaternion().setFromEuler(preRotation);\\n      }\\n\\n      if (postRotation !== undefined) {\\n        postRotation = postRotation.map(_three.MathUtils.degToRad);\\n        postRotation.push(eulerOrder);\\n        postRotation = new _three.Euler().fromArray(postRotation);\\n        postRotation = new _three.Quaternion().setFromEuler(postRotation).invert();\\n      }\\n\\n      var quaternion = new _three.Quaternion();\\n      var euler = new _three.Euler();\\n      var quaternionValues = [];\\n\\n      for (var i = 0; i < values.length; i += 3) {\\n        euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);\\n        quaternion.setFromEuler(euler);\\n        if (preRotation !== undefined) quaternion.premultiply(preRotation);\\n        if (postRotation !== undefined) quaternion.multiply(postRotation);\\n        quaternion.toArray(quaternionValues, i / 3 * 4);\\n      }\\n\\n      return new _three.QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);\\n    }\\n  }, {\\n    key: \\\"generateMorphTrack\\\",\\n    value: function generateMorphTrack(rawTracks) {\\n      var curves = rawTracks.DeformPercent.curves.morph;\\n      var values = curves.values.map(function (val) {\\n        return val / 100;\\n      });\\n      var morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];\\n      return new _three.NumberKeyframeTrack(rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values);\\n    } // For all animated objects, times are defined separately for each axis\\n    // Here we'll combine the times into one sorted array without duplicates\\n\\n  }, {\\n    key: \\\"getTimesForAllAxes\\\",\\n    value: function getTimesForAllAxes(curves) {\\n      var times = []; // first join together the times for each axis, if defined\\n\\n      if (curves.x !== undefined) times = times.concat(curves.x.times);\\n      if (curves.y !== undefined) times = times.concat(curves.y.times);\\n      if (curves.z !== undefined) times = times.concat(curves.z.times); // then sort them\\n\\n      times = times.sort(function (a, b) {\\n        return a - b;\\n      }); // and remove duplicates\\n\\n      if (times.length > 1) {\\n        var targetIndex = 1;\\n        var lastValue = times[0];\\n\\n        for (var i = 1; i < times.length; i++) {\\n          var currentValue = times[i];\\n\\n          if (currentValue !== lastValue) {\\n            times[targetIndex] = currentValue;\\n            lastValue = currentValue;\\n            targetIndex++;\\n          }\\n        }\\n\\n        times = times.slice(0, targetIndex);\\n      }\\n\\n      return times;\\n    }\\n  }, {\\n    key: \\\"getKeyframeTrackValues\\\",\\n    value: function getKeyframeTrackValues(times, curves, initialValue) {\\n      var prevValue = initialValue;\\n      var values = [];\\n      var xIndex = -1;\\n      var yIndex = -1;\\n      var zIndex = -1;\\n      times.forEach(function (time) {\\n        if (curves.x) xIndex = curves.x.times.indexOf(time);\\n        if (curves.y) yIndex = curves.y.times.indexOf(time);\\n        if (curves.z) zIndex = curves.z.times.indexOf(time); // if there is an x value defined for this frame, use that\\n\\n        if (xIndex !== -1) {\\n          var xValue = curves.x.values[xIndex];\\n          values.push(xValue);\\n          prevValue[0] = xValue;\\n        } else {\\n          // otherwise use the x value from the previous frame\\n          values.push(prevValue[0]);\\n        }\\n\\n        if (yIndex !== -1) {\\n          var yValue = curves.y.values[yIndex];\\n          values.push(yValue);\\n          prevValue[1] = yValue;\\n        } else {\\n          values.push(prevValue[1]);\\n        }\\n\\n        if (zIndex !== -1) {\\n          var zValue = curves.z.values[zIndex];\\n          values.push(zValue);\\n          prevValue[2] = zValue;\\n        } else {\\n          values.push(prevValue[2]);\\n        }\\n      });\\n      return values;\\n    } // Rotations are defined as Euler angles which can have values  of any size\\n    // These will be converted to quaternions which don't support values greater than\\n    // PI, so we'll interpolate large rotations\\n\\n  }, {\\n    key: \\\"interpolateRotations\\\",\\n    value: function interpolateRotations(curve) {\\n      for (var i = 1; i < curve.values.length; i++) {\\n        var initialValue = curve.values[i - 1];\\n        var valuesSpan = curve.values[i] - initialValue;\\n        var absoluteSpan = Math.abs(valuesSpan);\\n\\n        if (absoluteSpan >= 180) {\\n          var numSubIntervals = absoluteSpan / 180;\\n          var step = valuesSpan / numSubIntervals;\\n          var nextValue = initialValue + step;\\n          var initialTime = curve.times[i - 1];\\n          var timeSpan = curve.times[i] - initialTime;\\n          var interval = timeSpan / numSubIntervals;\\n          var nextTime = initialTime + interval;\\n          var interpolatedTimes = [];\\n          var interpolatedValues = [];\\n\\n          while (nextTime < curve.times[i]) {\\n            interpolatedTimes.push(nextTime);\\n            nextTime += interval;\\n            interpolatedValues.push(nextValue);\\n            nextValue += step;\\n          }\\n\\n          curve.times = inject(curve.times, i, interpolatedTimes);\\n          curve.values = inject(curve.values, i, interpolatedValues);\\n        }\\n      }\\n    }\\n  }]);\\n\\n  return AnimationParser;\\n}(); // parse an FBX file in ASCII format\\n\\n\\nvar TextParser =\\n/*#__PURE__*/\\nfunction () {\\n  function TextParser() {\\n    _classCallCheck(this, TextParser);\\n  }\\n\\n  _createClass(TextParser, [{\\n    key: \\\"getPrevNode\\\",\\n    value: function getPrevNode() {\\n      return this.nodeStack[this.currentIndent - 2];\\n    }\\n  }, {\\n    key: \\\"getCurrentNode\\\",\\n    value: function getCurrentNode() {\\n      return this.nodeStack[this.currentIndent - 1];\\n    }\\n  }, {\\n    key: \\\"getCurrentProp\\\",\\n    value: function getCurrentProp() {\\n      return this.currentProp;\\n    }\\n  }, {\\n    key: \\\"pushStack\\\",\\n    value: function pushStack(node) {\\n      this.nodeStack.push(node);\\n      this.currentIndent += 1;\\n    }\\n  }, {\\n    key: \\\"popStack\\\",\\n    value: function popStack() {\\n      this.nodeStack.pop();\\n      this.currentIndent -= 1;\\n    }\\n  }, {\\n    key: \\\"setCurrentProp\\\",\\n    value: function setCurrentProp(val, name) {\\n      this.currentProp = val;\\n      this.currentPropName = name;\\n    }\\n  }, {\\n    key: \\\"parse\\\",\\n    value: function parse(text) {\\n      this.currentIndent = 0;\\n      this.allNodes = new FBXTree();\\n      this.nodeStack = [];\\n      this.currentProp = [];\\n      this.currentPropName = '';\\n      var scope = this;\\n      var split = text.split(/[\\\\r\\\\n]+/);\\n      split.forEach(function (line, i) {\\n        var matchComment = line.match(/^[\\\\s\\\\t]*;/);\\n        var matchEmpty = line.match(/^[\\\\s\\\\t]*$/);\\n        if (matchComment || matchEmpty) return;\\n        var matchBeginning = line.match('^\\\\\\\\t{' + scope.currentIndent + '}(\\\\\\\\w+):(.*){', '');\\n        var matchProperty = line.match('^\\\\\\\\t{' + scope.currentIndent + '}(\\\\\\\\w+):[\\\\\\\\s\\\\\\\\t\\\\\\\\r\\\\\\\\n](.*)');\\n        var matchEnd = line.match('^\\\\\\\\t{' + (scope.currentIndent - 1) + '}}');\\n\\n        if (matchBeginning) {\\n          scope.parseNodeBegin(line, matchBeginning);\\n        } else if (matchProperty) {\\n          scope.parseNodeProperty(line, matchProperty, split[++i]);\\n        } else if (matchEnd) {\\n          scope.popStack();\\n        } else if (line.match(/^[^\\\\s\\\\t}]/)) {\\n          // large arrays are split over multiple lines terminated with a ',' character\\n          // if this is encountered the line needs to be joined to the previous line\\n          scope.parseNodePropertyContinued(line);\\n        }\\n      });\\n      return this.allNodes;\\n    }\\n  }, {\\n    key: \\\"parseNodeBegin\\\",\\n    value: function parseNodeBegin(line, property) {\\n      var nodeName = property[1].trim().replace(/^\\\"/, '').replace(/\\\"$/, '');\\n      var nodeAttrs = property[2].split(',').map(function (attr) {\\n        return attr.trim().replace(/^\\\"/, '').replace(/\\\"$/, '');\\n      });\\n      var node = {\\n        name: nodeName\\n      };\\n      var attrs = this.parseNodeAttr(nodeAttrs);\\n      var currentNode = this.getCurrentNode(); // a top node\\n\\n      if (this.currentIndent === 0) {\\n        this.allNodes.add(nodeName, node);\\n      } else {\\n        // a subnode\\n        // if the subnode already exists, append it\\n        if (nodeName in currentNode) {\\n          // special case Pose needs PoseNodes as an array\\n          if (nodeName === 'PoseNode') {\\n            currentNode.PoseNode.push(node);\\n          } else if (currentNode[nodeName].id !== undefined) {\\n            currentNode[nodeName] = {};\\n            currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\\n          }\\n\\n          if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;\\n        } else if (typeof attrs.id === 'number') {\\n          currentNode[nodeName] = {};\\n          currentNode[nodeName][attrs.id] = node;\\n        } else if (nodeName !== 'Properties70') {\\n          if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;\\n        }\\n      }\\n\\n      if (typeof attrs.id === 'number') node.id = attrs.id;\\n      if (attrs.name !== '') node.attrName = attrs.name;\\n      if (attrs.type !== '') node.attrType = attrs.type;\\n      this.pushStack(node);\\n    }\\n  }, {\\n    key: \\\"parseNodeAttr\\\",\\n    value: function parseNodeAttr(attrs) {\\n      var id = attrs[0];\\n\\n      if (attrs[0] !== '') {\\n        id = parseInt(attrs[0]);\\n\\n        if (isNaN(id)) {\\n          id = attrs[0];\\n        }\\n      }\\n\\n      var name = '',\\n          type = '';\\n\\n      if (attrs.length > 1) {\\n        name = attrs[1].replace(/^(\\\\w+)::/, '');\\n        type = attrs[2];\\n      }\\n\\n      return {\\n        id: id,\\n        name: name,\\n        type: type\\n      };\\n    }\\n  }, {\\n    key: \\\"parseNodeProperty\\\",\\n    value: function parseNodeProperty(line, property, contentLine) {\\n      var propName = property[1].replace(/^\\\"/, '').replace(/\\\"$/, '').trim();\\n      var propValue = property[2].replace(/^\\\"/, '').replace(/\\\"$/, '').trim(); // for special case: base64 image data follows \\\"Content: ,\\\" line\\n      //\\tContent: ,\\n      //\\t \\\"/9j/4RDaRXhpZgAATU0A...\\\"\\n\\n      if (propName === 'Content' && propValue === ',') {\\n        propValue = contentLine.replace(/\\\"/g, '').replace(/,$/, '').trim();\\n      }\\n\\n      var currentNode = this.getCurrentNode();\\n      var parentName = currentNode.name;\\n\\n      if (parentName === 'Properties70') {\\n        this.parseNodeSpecialProperty(line, propName, propValue);\\n        return;\\n      } // Connections\\n\\n\\n      if (propName === 'C') {\\n        var connProps = propValue.split(',').slice(1);\\n        var from = parseInt(connProps[0]);\\n        var to = parseInt(connProps[1]);\\n        var rest = propValue.split(',').slice(3);\\n        rest = rest.map(function (elem) {\\n          return elem.trim().replace(/^\\\"/, '');\\n        });\\n        propName = 'connections';\\n        propValue = [from, to];\\n        append(propValue, rest);\\n\\n        if (currentNode[propName] === undefined) {\\n          currentNode[propName] = [];\\n        }\\n      } // Node\\n\\n\\n      if (propName === 'Node') currentNode.id = propValue; // connections\\n\\n      if (propName in currentNode && Array.isArray(currentNode[propName])) {\\n        currentNode[propName].push(propValue);\\n      } else {\\n        if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;\\n      }\\n\\n      this.setCurrentProp(currentNode, propName); // convert string to array, unless it ends in ',' in which case more will be added to it\\n\\n      if (propName === 'a' && propValue.slice(-1) !== ',') {\\n        currentNode.a = parseNumberArray(propValue);\\n      }\\n    }\\n  }, {\\n    key: \\\"parseNodePropertyContinued\\\",\\n    value: function parseNodePropertyContinued(line) {\\n      var currentNode = this.getCurrentNode();\\n      currentNode.a += line; // if the line doesn't end in ',' we have reached the end of the property value\\n      // so convert the string to an array\\n\\n      if (line.slice(-1) !== ',') {\\n        currentNode.a = parseNumberArray(currentNode.a);\\n      }\\n    } // parse \\\"Property70\\\"\\n\\n  }, {\\n    key: \\\"parseNodeSpecialProperty\\\",\\n    value: function parseNodeSpecialProperty(line, propName, propValue) {\\n      // split this\\n      // P: \\\"Lcl Scaling\\\", \\\"Lcl Scaling\\\", \\\"\\\", \\\"A\\\",1,1,1\\n      // into array like below\\n      // [\\\"Lcl Scaling\\\", \\\"Lcl Scaling\\\", \\\"\\\", \\\"A\\\", \\\"1,1,1\\\" ]\\n      var props = propValue.split('\\\",').map(function (prop) {\\n        return prop.trim().replace(/^\\\\\\\"/, '').replace(/\\\\s/, '_');\\n      });\\n      var innerPropName = props[0];\\n      var innerPropType1 = props[1];\\n      var innerPropType2 = props[2];\\n      var innerPropFlag = props[3];\\n      var innerPropValue = props[4]; // cast values where needed, otherwise leave as strings\\n\\n      switch (innerPropType1) {\\n        case 'int':\\n        case 'enum':\\n        case 'bool':\\n        case 'ULongLong':\\n        case 'double':\\n        case 'Number':\\n        case 'FieldOfView':\\n          innerPropValue = parseFloat(innerPropValue);\\n          break;\\n\\n        case 'Color':\\n        case 'ColorRGB':\\n        case 'Vector3D':\\n        case 'Lcl_Translation':\\n        case 'Lcl_Rotation':\\n        case 'Lcl_Scaling':\\n          innerPropValue = parseNumberArray(innerPropValue);\\n          break;\\n      } // CAUTION: these props must append to parent's parent\\n\\n\\n      this.getPrevNode()[innerPropName] = {\\n        type: innerPropType1,\\n        type2: innerPropType2,\\n        flag: innerPropFlag,\\n        value: innerPropValue\\n      };\\n      this.setCurrentProp(this.getPrevNode(), innerPropName);\\n    }\\n  }]);\\n\\n  return TextParser;\\n}(); // Parse an FBX file in Binary format\\n\\n\\nvar BinaryParser =\\n/*#__PURE__*/\\nfunction () {\\n  function BinaryParser() {\\n    _classCallCheck(this, BinaryParser);\\n  }\\n\\n  _createClass(BinaryParser, [{\\n    key: \\\"parse\\\",\\n    value: function parse(buffer) {\\n      var reader = new BinaryReader(buffer);\\n      reader.skip(23); // skip magic 23 bytes\\n\\n      var version = reader.getUint32();\\n\\n      if (version < 6400) {\\n        throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version);\\n      }\\n\\n      var allNodes = new FBXTree();\\n\\n      while (!this.endOfContent(reader)) {\\n        var node = this.parseNode(reader, version);\\n        if (node !== null) allNodes.add(node.name, node);\\n      }\\n\\n      return allNodes;\\n    } // Check if reader has reached the end of content.\\n\\n  }, {\\n    key: \\\"endOfContent\\\",\\n    value: function endOfContent(reader) {\\n      // footer size: 160bytes + 16-byte alignment padding\\n      // - 16bytes: magic\\n      // - padding til 16-byte alignment (at least 1byte?)\\n      //\\t(seems like some exporters embed fixed 15 or 16bytes?)\\n      // - 4bytes: magic\\n      // - 4bytes: version\\n      // - 120bytes: zero\\n      // - 16bytes: magic\\n      if (reader.size() % 16 === 0) {\\n        return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\\n      } else {\\n        return reader.getOffset() + 160 + 16 >= reader.size();\\n      }\\n    } // recursively parse nodes until the end of the file is reached\\n\\n  }, {\\n    key: \\\"parseNode\\\",\\n    value: function parseNode(reader, version) {\\n      var node = {}; // The first three data sizes depends on version.\\n\\n      var endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\\n      var numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\\n      version >= 7500 ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\\n\\n      var nameLen = reader.getUint8();\\n      var name = reader.getString(nameLen); // Regards this node as NULL-record if endOffset is zero\\n\\n      if (endOffset === 0) return null;\\n      var propertyList = [];\\n\\n      for (var i = 0; i < numProperties; i++) {\\n        propertyList.push(this.parseProperty(reader));\\n      } // Regards the first three elements in propertyList as id, attrName, and attrType\\n\\n\\n      var id = propertyList.length > 0 ? propertyList[0] : '';\\n      var attrName = propertyList.length > 1 ? propertyList[1] : '';\\n      var attrType = propertyList.length > 2 ? propertyList[2] : ''; // check if this node represents just a single property\\n      // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\\n\\n      node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\\n\\n      while (endOffset > reader.getOffset()) {\\n        var subNode = this.parseNode(reader, version);\\n        if (subNode !== null) this.parseSubNode(name, node, subNode);\\n      }\\n\\n      node.propertyList = propertyList; // raw property list used by parent\\n\\n      if (typeof id === 'number') node.id = id;\\n      if (attrName !== '') node.attrName = attrName;\\n      if (attrType !== '') node.attrType = attrType;\\n      if (name !== '') node.name = name;\\n      return node;\\n    }\\n  }, {\\n    key: \\\"parseSubNode\\\",\\n    value: function parseSubNode(name, node, subNode) {\\n      // special case: child node is single property\\n      if (subNode.singleProperty === true) {\\n        var value = subNode.propertyList[0];\\n\\n        if (Array.isArray(value)) {\\n          node[subNode.name] = subNode;\\n          subNode.a = value;\\n        } else {\\n          node[subNode.name] = value;\\n        }\\n      } else if (name === 'Connections' && subNode.name === 'C') {\\n        var array = [];\\n        subNode.propertyList.forEach(function (property, i) {\\n          // first Connection is FBX type (OO, OP, etc.). We'll discard these\\n          if (i !== 0) array.push(property);\\n        });\\n\\n        if (node.connections === undefined) {\\n          node.connections = [];\\n        }\\n\\n        node.connections.push(array);\\n      } else if (subNode.name === 'Properties70') {\\n        var keys = Object.keys(subNode);\\n        keys.forEach(function (key) {\\n          node[key] = subNode[key];\\n        });\\n      } else if (name === 'Properties70' && subNode.name === 'P') {\\n        var innerPropName = subNode.propertyList[0];\\n        var innerPropType1 = subNode.propertyList[1];\\n        var innerPropType2 = subNode.propertyList[2];\\n        var innerPropFlag = subNode.propertyList[3];\\n        var innerPropValue;\\n        if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\\n        if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\\n\\n        if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\\n          innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\\n        } else {\\n          innerPropValue = subNode.propertyList[4];\\n        } // this will be copied to parent, see above\\n\\n\\n        node[innerPropName] = {\\n          type: innerPropType1,\\n          type2: innerPropType2,\\n          flag: innerPropFlag,\\n          value: innerPropValue\\n        };\\n      } else if (node[subNode.name] === undefined) {\\n        if (typeof subNode.id === 'number') {\\n          node[subNode.name] = {};\\n          node[subNode.name][subNode.id] = subNode;\\n        } else {\\n          node[subNode.name] = subNode;\\n        }\\n      } else {\\n        if (subNode.name === 'PoseNode') {\\n          if (!Array.isArray(node[subNode.name])) {\\n            node[subNode.name] = [node[subNode.name]];\\n          }\\n\\n          node[subNode.name].push(subNode);\\n        } else if (node[subNode.name][subNode.id] === undefined) {\\n          node[subNode.name][subNode.id] = subNode;\\n        }\\n      }\\n    }\\n  }, {\\n    key: \\\"parseProperty\\\",\\n    value: function parseProperty(reader) {\\n      var type = reader.getString(1);\\n      var length;\\n\\n      switch (type) {\\n        case 'C':\\n          return reader.getBoolean();\\n\\n        case 'D':\\n          return reader.getFloat64();\\n\\n        case 'F':\\n          return reader.getFloat32();\\n\\n        case 'I':\\n          return reader.getInt32();\\n\\n        case 'L':\\n          return reader.getInt64();\\n\\n        case 'R':\\n          length = reader.getUint32();\\n          return reader.getArrayBuffer(length);\\n\\n        case 'S':\\n          length = reader.getUint32();\\n          return reader.getString(length);\\n\\n        case 'Y':\\n          return reader.getInt16();\\n\\n        case 'b':\\n        case 'c':\\n        case 'd':\\n        case 'f':\\n        case 'i':\\n        case 'l':\\n          var arrayLength = reader.getUint32();\\n          var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\\n\\n          var compressedLength = reader.getUint32();\\n\\n          if (encoding === 0) {\\n            switch (type) {\\n              case 'b':\\n              case 'c':\\n                return reader.getBooleanArray(arrayLength);\\n\\n              case 'd':\\n                return reader.getFloat64Array(arrayLength);\\n\\n              case 'f':\\n                return reader.getFloat32Array(arrayLength);\\n\\n              case 'i':\\n                return reader.getInt32Array(arrayLength);\\n\\n              case 'l':\\n                return reader.getInt64Array(arrayLength);\\n            }\\n          }\\n\\n          var data = (0, _fflate.unzlibSync)(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\\n\\n          var reader2 = new BinaryReader(data.buffer);\\n\\n          switch (type) {\\n            case 'b':\\n            case 'c':\\n              return reader2.getBooleanArray(arrayLength);\\n\\n            case 'd':\\n              return reader2.getFloat64Array(arrayLength);\\n\\n            case 'f':\\n              return reader2.getFloat32Array(arrayLength);\\n\\n            case 'i':\\n              return reader2.getInt32Array(arrayLength);\\n\\n            case 'l':\\n              return reader2.getInt64Array(arrayLength);\\n          }\\n\\n        default:\\n          throw new Error('THREE.FBXLoader: Unknown property type ' + type);\\n      }\\n    }\\n  }]);\\n\\n  return BinaryParser;\\n}();\\n\\nvar BinaryReader =\\n/*#__PURE__*/\\nfunction () {\\n  function BinaryReader(buffer, littleEndian) {\\n    _classCallCheck(this, BinaryReader);\\n\\n    this.dv = new DataView(buffer);\\n    this.offset = 0;\\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true;\\n  }\\n\\n  _createClass(BinaryReader, [{\\n    key: \\\"getOffset\\\",\\n    value: function getOffset() {\\n      return this.offset;\\n    }\\n  }, {\\n    key: \\\"size\\\",\\n    value: function size() {\\n      return this.dv.buffer.byteLength;\\n    }\\n  }, {\\n    key: \\\"skip\\\",\\n    value: function skip(length) {\\n      this.offset += length;\\n    } // seems like true/false representation depends on exporter.\\n    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\\n    // then sees LSB.\\n\\n  }, {\\n    key: \\\"getBoolean\\\",\\n    value: function getBoolean() {\\n      return (this.getUint8() & 1) === 1;\\n    }\\n  }, {\\n    key: \\\"getBooleanArray\\\",\\n    value: function getBooleanArray(size) {\\n      var a = [];\\n\\n      for (var i = 0; i < size; i++) {\\n        a.push(this.getBoolean());\\n      }\\n\\n      return a;\\n    }\\n  }, {\\n    key: \\\"getUint8\\\",\\n    value: function getUint8() {\\n      var value = this.dv.getUint8(this.offset);\\n      this.offset += 1;\\n      return value;\\n    }\\n  }, {\\n    key: \\\"getInt16\\\",\\n    value: function getInt16() {\\n      var value = this.dv.getInt16(this.offset, this.littleEndian);\\n      this.offset += 2;\\n      return value;\\n    }\\n  }, {\\n    key: \\\"getInt32\\\",\\n    value: function getInt32() {\\n      var value = this.dv.getInt32(this.offset, this.littleEndian);\\n      this.offset += 4;\\n      return value;\\n    }\\n  }, {\\n    key: \\\"getInt32Array\\\",\\n    value: function getInt32Array(size) {\\n      var a = [];\\n\\n      for (var i = 0; i < size; i++) {\\n        a.push(this.getInt32());\\n      }\\n\\n      return a;\\n    }\\n  }, {\\n    key: \\\"getUint32\\\",\\n    value: function getUint32() {\\n      var value = this.dv.getUint32(this.offset, this.littleEndian);\\n      this.offset += 4;\\n      return value;\\n    } // JavaScript doesn't support 64-bit integer so calculate this here\\n    // 1 << 32 will return 1 so using multiply operation instead here.\\n    // There's a possibility that this method returns wrong value if the value\\n    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\\n    // TODO: safely handle 64-bit integer\\n\\n  }, {\\n    key: \\\"getInt64\\\",\\n    value: function getInt64() {\\n      var low, high;\\n\\n      if (this.littleEndian) {\\n        low = this.getUint32();\\n        high = this.getUint32();\\n      } else {\\n        high = this.getUint32();\\n        low = this.getUint32();\\n      } // calculate negative value\\n\\n\\n      if (high & 0x80000000) {\\n        high = ~high & 0xffffffff;\\n        low = ~low & 0xffffffff;\\n        if (low === 0xffffffff) high = high + 1 & 0xffffffff;\\n        low = low + 1 & 0xffffffff;\\n        return -(high * 0x100000000 + low);\\n      }\\n\\n      return high * 0x100000000 + low;\\n    }\\n  }, {\\n    key: \\\"getInt64Array\\\",\\n    value: function getInt64Array(size) {\\n      var a = [];\\n\\n      for (var i = 0; i < size; i++) {\\n        a.push(this.getInt64());\\n      }\\n\\n      return a;\\n    } // Note: see getInt64() comment\\n\\n  }, {\\n    key: \\\"getUint64\\\",\\n    value: function getUint64() {\\n      var low, high;\\n\\n      if (this.littleEndian) {\\n        low = this.getUint32();\\n        high = this.getUint32();\\n      } else {\\n        high = this.getUint32();\\n        low = this.getUint32();\\n      }\\n\\n      return high * 0x100000000 + low;\\n    }\\n  }, {\\n    key: \\\"getFloat32\\\",\\n    value: function getFloat32() {\\n      var value = this.dv.getFloat32(this.offset, this.littleEndian);\\n      this.offset += 4;\\n      return value;\\n    }\\n  }, {\\n    key: \\\"getFloat32Array\\\",\\n    value: function getFloat32Array(size) {\\n      var a = [];\\n\\n      for (var i = 0; i < size; i++) {\\n        a.push(this.getFloat32());\\n      }\\n\\n      return a;\\n    }\\n  }, {\\n    key: \\\"getFloat64\\\",\\n    value: function getFloat64() {\\n      var value = this.dv.getFloat64(this.offset, this.littleEndian);\\n      this.offset += 8;\\n      return value;\\n    }\\n  }, {\\n    key: \\\"getFloat64Array\\\",\\n    value: function getFloat64Array(size) {\\n      var a = [];\\n\\n      for (var i = 0; i < size; i++) {\\n        a.push(this.getFloat64());\\n      }\\n\\n      return a;\\n    }\\n  }, {\\n    key: \\\"getArrayBuffer\\\",\\n    value: function getArrayBuffer(size) {\\n      var value = this.dv.buffer.slice(this.offset, this.offset + size);\\n      this.offset += size;\\n      return value;\\n    }\\n  }, {\\n    key: \\\"getString\\\",\\n    value: function getString(size) {\\n      // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\\n      var a = [];\\n\\n      for (var i = 0; i < size; i++) {\\n        a[i] = this.getUint8();\\n      }\\n\\n      var nullByte = a.indexOf(0);\\n      if (nullByte >= 0) a = a.slice(0, nullByte);\\n      return _three.LoaderUtils.decodeText(new Uint8Array(a));\\n    }\\n  }]);\\n\\n  return BinaryReader;\\n}(); // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\\n// and BinaryParser( FBX Binary format)\\n\\n\\nvar FBXTree =\\n/*#__PURE__*/\\nfunction () {\\n  function FBXTree() {\\n    _classCallCheck(this, FBXTree);\\n  }\\n\\n  _createClass(FBXTree, [{\\n    key: \\\"add\\\",\\n    value: function add(key, val) {\\n      this[key] = val;\\n    }\\n  }]);\\n\\n  return FBXTree;\\n}(); // ************** UTILITY FUNCTIONS **************\\n\\n\\nfunction isFbxFormatBinary(buffer) {\\n  var CORRECT = \\\"Kaydara FBX Binary  \\\\0\\\";\\n  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\\n}\\n\\nfunction isFbxFormatASCII(text) {\\n  var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\\\\\', 'F', 'B', 'X', '\\\\\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\\\\\', '\\\\\\\\'];\\n  var cursor = 0;\\n\\n  function read(offset) {\\n    var result = text[offset - 1];\\n    text = text.slice(cursor + offset);\\n    cursor++;\\n    return result;\\n  }\\n\\n  for (var i = 0; i < CORRECT.length; ++i) {\\n    var num = read(1);\\n\\n    if (num === CORRECT[i]) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\nfunction getFbxVersion(text) {\\n  var versionRegExp = /FBXVersion: (\\\\d+)/;\\n  var match = text.match(versionRegExp);\\n\\n  if (match) {\\n    var version = parseInt(match[1]);\\n    return version;\\n  }\\n\\n  throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\\n} // Converts FBX ticks into real time seconds.\\n\\n\\nfunction convertFBXTimeToSeconds(time) {\\n  return time / 46186158000;\\n}\\n\\nvar dataArray = []; // extracts the data from the correct position in the FBX array based on indexing type\\n\\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\\n  var index;\\n\\n  switch (infoObject.mappingType) {\\n    case 'ByPolygonVertex':\\n      index = polygonVertexIndex;\\n      break;\\n\\n    case 'ByPolygon':\\n      index = polygonIndex;\\n      break;\\n\\n    case 'ByVertice':\\n      index = vertexIndex;\\n      break;\\n\\n    case 'AllSame':\\n      index = infoObject.indices[0];\\n      break;\\n\\n    default:\\n      console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);\\n  }\\n\\n  if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];\\n  var from = index * infoObject.dataSize;\\n  var to = from + infoObject.dataSize;\\n  return slice(dataArray, infoObject.buffer, from, to);\\n}\\n\\nvar tempEuler = new _three.Euler();\\nvar tempVec = new _three.Vector3(); // generate transformation from FBX transform data\\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\\n\\nfunction generateTransform(transformData) {\\n  var lTranslationM = new _three.Matrix4();\\n  var lPreRotationM = new _three.Matrix4();\\n  var lRotationM = new _three.Matrix4();\\n  var lPostRotationM = new _three.Matrix4();\\n  var lScalingM = new _three.Matrix4();\\n  var lScalingPivotM = new _three.Matrix4();\\n  var lScalingOffsetM = new _three.Matrix4();\\n  var lRotationOffsetM = new _three.Matrix4();\\n  var lRotationPivotM = new _three.Matrix4();\\n  var lParentGX = new _three.Matrix4();\\n  var lParentLX = new _three.Matrix4();\\n  var lGlobalT = new _three.Matrix4();\\n  var inheritType = transformData.inheritType ? transformData.inheritType : 0;\\n  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));\\n\\n  if (transformData.preRotation) {\\n    var array = transformData.preRotation.map(_three.MathUtils.degToRad);\\n    array.push(transformData.eulerOrder);\\n    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\\n  }\\n\\n  if (transformData.rotation) {\\n    var _array = transformData.rotation.map(_three.MathUtils.degToRad);\\n\\n    _array.push(transformData.eulerOrder);\\n\\n    lRotationM.makeRotationFromEuler(tempEuler.fromArray(_array));\\n  }\\n\\n  if (transformData.postRotation) {\\n    var _array2 = transformData.postRotation.map(_three.MathUtils.degToRad);\\n\\n    _array2.push(transformData.eulerOrder);\\n\\n    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(_array2));\\n    lPostRotationM.invert();\\n  }\\n\\n  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale)); // Pivots and offsets\\n\\n  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));\\n  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));\\n  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));\\n  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot)); // parent transform\\n\\n  if (transformData.parentMatrixWorld) {\\n    lParentLX.copy(transformData.parentMatrix);\\n    lParentGX.copy(transformData.parentMatrixWorld);\\n  }\\n\\n  var lLRM = new _three.Matrix4().copy(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM); // Global Rotation\\n\\n  var lParentGRM = new _three.Matrix4();\\n  lParentGRM.extractRotation(lParentGX); // Global Shear*Scaling\\n\\n  var lParentTM = new _three.Matrix4();\\n  lParentTM.copyPosition(lParentGX);\\n  var lParentGSM = new _three.Matrix4();\\n  var lParentGRSM = new _three.Matrix4().copy(lParentTM).invert().multiply(lParentGX);\\n  lParentGSM.copy(lParentGRM).invert().multiply(lParentGRSM);\\n  var lLSM = lScalingM;\\n  var lGlobalRS = new _three.Matrix4();\\n\\n  if (inheritType === 0) {\\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);\\n  } else if (inheritType === 1) {\\n    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);\\n  } else {\\n    var lParentLSM = new _three.Matrix4().scale(new _three.Vector3().setFromMatrixScale(lParentLX));\\n    var lParentLSM_inv = new _three.Matrix4().copy(lParentLSM).invert();\\n    var lParentGSM_noLocal = new _three.Matrix4().copy(lParentGSM).multiply(lParentLSM_inv);\\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);\\n  }\\n\\n  var lRotationPivotM_inv = new _three.Matrix4();\\n  lRotationPivotM_inv.copy(lRotationPivotM).invert();\\n  var lScalingPivotM_inv = new _three.Matrix4();\\n  lScalingPivotM_inv.copy(lScalingPivotM).invert(); // Calculate the local transform matrix\\n\\n  var lTransform = new _three.Matrix4();\\n  lTransform.copy(lTranslationM).multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);\\n  var lLocalTWithAllPivotAndOffsetInfo = new _three.Matrix4().copyPosition(lTransform);\\n  var lGlobalTranslation = new _three.Matrix4().copy(lParentGX).multiply(lLocalTWithAllPivotAndOffsetInfo);\\n  lGlobalT.copyPosition(lGlobalTranslation);\\n  lTransform = new _three.Matrix4().copy(lGlobalT).multiply(lGlobalRS); // from global to local\\n\\n  lTransform.premultiply(lParentGX.invert());\\n  return lTransform;\\n} // Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\\n\\n\\nfunction getEulerOrder(order) {\\n  order = order || 0;\\n  var enums = ['ZYX', // -> XYZ extrinsic\\n  'YZX', // -> XZY extrinsic\\n  'XZY', // -> YZX extrinsic\\n  'ZXY', // -> YXZ extrinsic\\n  'YXZ', // -> ZXY extrinsic\\n  'XYZ' // -> ZYX extrinsic\\n  //'SphericXYZ', // not possible to support\\n  ];\\n\\n  if (order === 6) {\\n    console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');\\n    return enums[0];\\n  }\\n\\n  return enums[order];\\n} // Parses comma separated list of numbers and returns them an array.\\n// Used internally by the TextParser\\n\\n\\nfunction parseNumberArray(value) {\\n  var array = value.split(',').map(function (val) {\\n    return parseFloat(val);\\n  });\\n  return array;\\n}\\n\\nfunction convertArrayBufferToString(buffer, from, to) {\\n  if (from === undefined) from = 0;\\n  if (to === undefined) to = buffer.byteLength;\\n  return _three.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\\n}\\n\\nfunction append(a, b) {\\n  for (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {\\n    a[j] = b[i];\\n  }\\n}\\n\\nfunction slice(a, b, from, to) {\\n  for (var i = from, j = 0; i < to; i++, j++) {\\n    a[j] = b[i];\\n  }\\n\\n  return a;\\n} // inject array a2 into array a1 at index\\n\\n\\nfunction inject(a1, index, a2) {\\n  return a1.slice(0, index).concat(a2).concat(a1.slice(index));\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_classCallCheck\",\"instance\",\"Constructor\",\"TypeError\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"getFbxVersion\",\"text\",\"match\",\"versionRegExp\",\"parseInt\",\"version\",\"Error\",\"convertFBXTimeToSeconds\",\"time\",\"getData\",\"polygonVertexIndex\",\"polygonIndex\",\"vertexIndex\",\"infoObject\",\"mappingType\",\"index\",\"indices\",\"console\",\"warn\",\"referenceType\",\"from\",\"dataSize\",\"dataArray\",\"buffer\",\"to\",\"j\",\"a\",\"b\",\"generateTransform\",\"transformData\",\"lTranslationM\",\"_three\",\"Matrix4\",\"lPreRotationM\",\"lRotationM\",\"lPostRotationM\",\"lScalingM\",\"lScalingPivotM\",\"lScalingOffsetM\",\"lRotationOffsetM\",\"lRotationPivotM\",\"lParentGX\",\"lParentLX\",\"lGlobalT\",\"inheritType\",\"translation\",\"setPosition\",\"tempVec\",\"fromArray\",\"preRotation\",\"array\",\"map\",\"MathUtils\",\"degToRad\",\"push\",\"eulerOrder\",\"makeRotationFromEuler\",\"tempEuler\",\"rotation\",\"_array\",\"postRotation\",\"_array2\",\"invert\",\"scale\",\"scalingOffset\",\"scalingPivot\",\"rotationOffset\",\"rotationPivot\",\"parentMatrixWorld\",\"copy\",\"parentMatrix\",\"lLRM\",\"multiply\",\"lParentGRM\",\"extractRotation\",\"lParentTM\",\"copyPosition\",\"lParentGSM\",\"lParentGRSM\",\"lGlobalRS\",\"lParentLSM\",\"setFromMatrixScale\",\"Vector3\",\"lParentLSM_inv\",\"lParentGSM_noLocal\",\"lRotationPivotM_inv\",\"lScalingPivotM_inv\",\"lTransform\",\"lLocalTWithAllPivotAndOffsetInfo\",\"lGlobalTranslation\",\"premultiply\",\"getEulerOrder\",\"order\",\"enums\",\"parseNumberArray\",\"split\",\"val\",\"parseFloat\",\"convertArrayBufferToString\",\"undefined\",\"byteLength\",\"LoaderUtils\",\"decodeText\",\"Uint8Array\",\"append\",\"l\",\"inject\",\"a1\",\"a2\",\"slice\",\"concat\",\"FBXLoader\",\"_fflate\",\"_NURBSCurve\",\"fbxTree\",\"connections\",\"sceneGraph\",\"_Loader\",\"manager\",\"call\",\"self\",\"ReferenceError\",\"load\",\"url\",\"onLoad\",\"onProgress\",\"onError\",\"scope\",\"path\",\"extractUrlBase\",\"loader\",\"FileLoader\",\"setPath\",\"setResponseType\",\"setRequestHeader\",\"requestHeader\",\"setWithCredentials\",\"withCredentials\",\"parse\",\"e\",\"error\",\"itemError\",\"FBXBuffer\",\"CORRECT\",\"BinaryParser\",\"FBXText\",\"cursor\",\"result\",\"offset\",\"TextParser\",\"textureLoader\",\"TextureLoader\",\"resourcePath\",\"setCrossOrigin\",\"crossOrigin\",\"FBXTreeParser\",\"Loader\",\"parseConnections\",\"images\",\"parseImages\",\"textures\",\"parseTextures\",\"materials\",\"parseMaterials\",\"deformers\",\"parseDeformers\",\"geometryMap\",\"GeometryParser\",\"parseScene\",\"connectionMap\",\"Map\",\"Connections\",\"forEach\",\"rawConnection\",\"fromID\",\"toID\",\"relationship\",\"has\",\"set\",\"parents\",\"children\",\"parentRelationship\",\"ID\",\"get\",\"childRelationship\",\"blobs\",\"Objects\",\"videoNodes\",\"Video\",\"nodeID\",\"videoNode\",\"id\",\"RelativeFilename\",\"Filename\",\"base64Content\",\"Content\",\"ArrayBuffer\",\"image\",\"parseImage\",\"_id\",\"filename\",\"pop\",\"content\",\"fileName\",\"extension\",\"lastIndexOf\",\"toLowerCase\",\"type\",\"getHandler\",\"window\",\"URL\",\"createObjectURL\",\"Blob\",\"textureMap\",\"textureNodes\",\"Texture\",\"texture\",\"parseTexture\",\"textureNode\",\"loadTexture\",\"name\",\"attrName\",\"wrapModeU\",\"WrapModeU\",\"wrapModeV\",\"WrapModeV\",\"valueV\",\"wrapS\",\"valueU\",\"RepeatWrapping\",\"ClampToEdgeWrapping\",\"wrapT\",\"values\",\"Scaling\",\"repeat\",\"x\",\"y\",\"currentPath\",\"indexOf\",\"FileName\",\"materialMap\",\"materialNodes\",\"Material\",\"material\",\"parseMaterial\",\"materialNode\",\"ShadingModel\",\"parameters\",\"parseParameters\",\"MeshPhongMaterial\",\"MeshLambertMaterial\",\"setValues\",\"BumpFactor\",\"bumpScale\",\"Diffuse\",\"color\",\"Color\",\"DiffuseColor\",\"DisplacementFactor\",\"displacementScale\",\"Emissive\",\"emissive\",\"EmissiveColor\",\"EmissiveFactor\",\"emissiveIntensity\",\"Opacity\",\"opacity\",\"transparent\",\"ReflectionFactor\",\"reflectivity\",\"Shininess\",\"shininess\",\"Specular\",\"specular\",\"SpecularColor\",\"child\",\"bumpMap\",\"getTexture\",\"aoMap\",\"encoding\",\"sRGBEncoding\",\"displacementMap\",\"emissiveMap\",\"normalMap\",\"envMap\",\"mapping\",\"EquirectangularReflectionMapping\",\"specularMap\",\"alphaMap\",\"LayeredTexture\",\"skeletons\",\"morphTargets\",\"DeformerNodes\",\"Deformer\",\"deformerNode\",\"relationships\",\"attrType\",\"skeleton\",\"parseSkeleton\",\"geometryID\",\"morphTarget\",\"rawTargets\",\"parseMorphTargets\",\"deformerNodes\",\"rawBones\",\"boneNode\",\"rawBone\",\"weights\",\"transformLink\",\"TransformLink\",\"Indexes\",\"Weights\",\"bones\",\"rawMorphTargets\",\"morphTargetNode\",\"rawMorphTarget\",\"initialWeight\",\"DeformPercent\",\"fullWeights\",\"FullWeights\",\"geoID\",\"filter\",\"Group\",\"modelMap\",\"parseModels\",\"modelNodes\",\"Model\",\"model\",\"setLookAtProperties\",\"modelNode\",\"connection\",\"parent\",\"add\",\"bindSkeleton\",\"createAmbientLight\",\"setupMorphMaterials\",\"traverse\",\"node\",\"userData\",\"matrix\",\"matrixWorld\",\"transform\",\"applyMatrix4\",\"updateWorldMatrix\",\"animations\",\"AnimationParser\",\"isGroup\",\"buildSkeleton\",\"createCamera\",\"createLight\",\"createMesh\",\"createCurve\",\"Bone\",\"PropertyBinding\",\"sanitizeNodeName\",\"getTransformData\",\"bone\",\"_loop\",\"subBone\",\"cameraAttribute\",\"attr\",\"NodeAttribute\",\"Object3D\",\"CameraProjectionType\",\"nearClippingPlane\",\"NearPlane\",\"farClippingPlane\",\"FarPlane\",\"width\",\"innerWidth\",\"height\",\"innerHeight\",\"AspectWidth\",\"AspectHeight\",\"aspect\",\"fov\",\"FieldOfView\",\"focalLength\",\"FocalLength\",\"PerspectiveCamera\",\"setFocalLength\",\"OrthographicCamera\",\"lightAttribute\",\"LightType\",\"intensity\",\"Intensity\",\"CastLightOnObject\",\"distance\",\"FarAttenuationEnd\",\"EnableFarAttenuation\",\"PointLight\",\"decay\",\"DirectionalLight\",\"angle\",\"Math\",\"PI\",\"InnerAngle\",\"penumbra\",\"OuterAngle\",\"max\",\"SpotLight\",\"CastShadows\",\"castShadow\",\"geometry\",\"attributes\",\"vertexColors\",\"FBX_Deformer\",\"skinning\",\"SkinnedMesh\",\"normalizeSkinWeights\",\"Mesh\",\"reduce\",\"geo\",\"LineBasicMaterial\",\"linewidth\",\"Line\",\"InheritType\",\"RotationOrder\",\"Lcl_Translation\",\"PreRotation\",\"Lcl_Rotation\",\"PostRotation\",\"Lcl_Scaling\",\"ScalingOffset\",\"ScalingPivot\",\"RotationOffset\",\"RotationPivot\",\"lookAtTarget\",\"pos\",\"position\",\"lookAt\",\"bindMatrices\",\"parsePoseNodes\",\"_loop2\",\"geoRelationships\",\"geoConnParent\",\"bind\",\"Skeleton\",\"BindPoseNode\",\"Pose\",\"poseNodes\",\"PoseNode\",\"Array\",\"isArray\",\"poseNode\",\"Node\",\"Matrix\",\"GlobalSettings\",\"ambientColor\",\"AmbientColor\",\"r\",\"g\",\"AmbientLight\",\"isMesh\",\"morphAttributes\",\"setupMorphMaterial\",\"uuid\",\"matUuid\",\"sharedMat\",\"mat\",\"clonedMat\",\"clone\",\"geoNodes\",\"Geometry\",\"parseGeometry\",\"geoNode\",\"parseMeshGeometry\",\"parseNurbsGeometry\",\"GeometricTranslation\",\"GeometricRotation\",\"GeometricScaling\",\"genGeometry\",\"preTransform\",\"BufferGeometry\",\"geoInfo\",\"parseGeoNode\",\"buffers\",\"genBuffers\",\"positionAttribute\",\"Float32BufferAttribute\",\"vertex\",\"setAttribute\",\"colors\",\"Uint16BufferAttribute\",\"weightsIndices\",\"vertexWeights\",\"normal\",\"normalMatrix\",\"getNormalMatrix\",\"Matrix3\",\"normalAttribute\",\"applyNormalMatrix\",\"uvs\",\"uvBuffer\",\"toString\",\"prevMaterialIndex\",\"materialIndex\",\"startIndex\",\"currentIndex\",\"addGroup\",\"groups\",\"lastGroup\",\"lastIndex\",\"start\",\"count\",\"addMorphTargets\",\"vertexPositions\",\"Vertices\",\"vertexIndices\",\"PolygonVertexIndex\",\"LayerElementColor\",\"parseVertexColors\",\"LayerElementMaterial\",\"parseMaterialIndices\",\"LayerElementNormal\",\"parseNormals\",\"LayerElementUV\",\"uv\",\"UV\",\"parseUVs\",\"weightTable\",\"weight\",\"faceLength\",\"displayedWeightsWarning\",\"facePositionIndexes\",\"faceNormals\",\"faceColors\",\"faceUVs\",\"faceWeights\",\"faceWeightIndices\",\"endOfFace\",\"weightIndices\",\"data\",\"wt\",\"wIndex\",\"Weight\",\"weightIndex\",\"currentWeight\",\"comparedWeight\",\"comparedWeightIndex\",\"comparedWeightArray\",\"tmp\",\"_data\",\"genFace\",\"_loop3\",\"parentGeo\",\"parentGeoNode\",\"morphTargetsRelative\",\"rawTarget\",\"morphGeoNode\",\"genMorphGeometry\",\"morphPositionsSparse\",\"morphPositions\",\"Float32Array\",\"morphIndex\",\"morphBuffers\",\"morphGeoInfo\",\"NormalNode\",\"MappingInformationType\",\"ReferenceInformationType\",\"Normals\",\"indexBuffer\",\"NormalIndex\",\"NormalsIndex\",\"UVNode\",\"UVIndex\",\"ColorNode\",\"Colors\",\"ColorIndex\",\"MaterialNode\",\"materialIndexBuffer\",\"Materials\",\"materialIndices\",\"NURBSCurve\",\"Order\",\"isNaN\",\"degree\",\"knots\",\"KnotVector\",\"controlPoints\",\"pointsValues\",\"Points\",\"Vector4\",\"Form\",\"startKnot\",\"endKnot\",\"_i\",\"vertices\",\"getPoints\",\"curve\",\"positions\",\"toArray\",\"BufferAttribute\",\"animationClips\",\"rawClips\",\"parseClips\",\"clip\",\"addClip\",\"rawClip\",\"AnimationCurve\",\"curveNodesMap\",\"parseAnimationCurveNodes\",\"parseAnimationCurves\",\"layersMap\",\"parseAnimationLayers\",\"parseAnimStacks\",\"rawCurveNodes\",\"AnimationCurveNode\",\"rawCurveNode\",\"curveNode\",\"curves\",\"rawCurves\",\"animationCurve\",\"times\",\"KeyTime\",\"KeyValueFloat\",\"animationCurveID\",\"animationCurveRelationship\",\"rawLayers\",\"AnimationLayer\",\"_loop4\",\"layerCurveNodes\",\"z\",\"modelID\",\"rawModel\",\"modelName\",\"initialPosition\",\"initialRotation\",\"initialScale\",\"morph\",\"deformerID\",\"morpherID\",\"_modelID\",\"_rawModel\",\"_node\",\"morphName\",\"rawStacks\",\"AnimationStack\",\"layer\",\"tracks\",\"rawTracks\",\"generateTracks\",\"AnimationClip\",\"Quaternion\",\"decompose\",\"setFromQuaternion\",\"Euler\",\"T\",\"keys\",\"positionTrack\",\"generateVectorTrack\",\"R\",\"rotationTrack\",\"generateRotationTrack\",\"S\",\"scaleTrack\",\"morphTrack\",\"generateMorphTrack\",\"initialValue\",\"getTimesForAllAxes\",\"getKeyframeTrackValues\",\"VectorKeyframeTrack\",\"interpolateRotations\",\"setFromEuler\",\"quaternion\",\"euler\",\"quaternionValues\",\"QuaternionKeyframeTrack\",\"morphNum\",\"getObjectByName\",\"morphTargetDictionary\",\"NumberKeyframeTrack\",\"sort\",\"targetIndex\",\"lastValue\",\"currentValue\",\"xIndex\",\"yIndex\",\"zIndex\",\"xValue\",\"yValue\",\"zValue\",\"valuesSpan\",\"absoluteSpan\",\"abs\",\"numSubIntervals\",\"step\",\"nextValue\",\"initialTime\",\"interval\",\"nextTime\",\"interpolatedTimes\",\"interpolatedValues\",\"getPrevNode\",\"nodeStack\",\"currentIndent\",\"getCurrentNode\",\"getCurrentProp\",\"currentProp\",\"pushStack\",\"popStack\",\"setCurrentProp\",\"currentPropName\",\"allNodes\",\"FBXTree\",\"line\",\"matchComment\",\"matchEmpty\",\"matchBeginning\",\"matchProperty\",\"matchEnd\",\"parseNodeBegin\",\"parseNodeProperty\",\"parseNodePropertyContinued\",\"property\",\"nodeName\",\"trim\",\"replace\",\"nodeAttrs\",\"attrs\",\"parseNodeAttr\",\"currentNode\",\"contentLine\",\"propName\",\"propValue\",\"parseNodeSpecialProperty\",\"connProps\",\"rest\",\"elem\",\"prop\",\"innerPropName\",\"innerPropType1\",\"innerPropType2\",\"innerPropFlag\",\"innerPropValue\",\"type2\",\"flag\",\"reader\",\"BinaryReader\",\"skip\",\"getUint32\",\"endOfContent\",\"parseNode\",\"size\",\"getOffset\",\"endOffset\",\"getUint64\",\"numProperties\",\"nameLen\",\"getUint8\",\"getString\",\"propertyList\",\"parseProperty\",\"singleProperty\",\"subNode\",\"parseSubNode\",\"getBoolean\",\"getFloat64\",\"getFloat32\",\"getInt32\",\"getInt64\",\"getArrayBuffer\",\"getInt16\",\"arrayLength\",\"compressedLength\",\"getBooleanArray\",\"getFloat64Array\",\"getFloat32Array\",\"getInt32Array\",\"getInt64Array\",\"unzlibSync\",\"reader2\",\"littleEndian\",\"dv\",\"DataView\",\"low\",\"high\",\"nullByte\"]\n}\n"]