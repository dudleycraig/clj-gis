["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/DigitalGlitch.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$DigitalGlitch=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.DigitalGlitch=void 0;exports.DigitalGlitch={uniforms:{tDiffuse:{value:null},tDisp:{value:null},byp:{value:0},amount:{value:.08},angle:{value:.02},seed:{value:.02},seed_x:{value:.02},seed_y:{value:.02},distortion_x:{value:.5},distortion_y:{value:.6},col_s:{value:.05}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",\nfragmentShader:\"uniform int byp;\\nuniform sampler2D tDiffuse;\\nuniform sampler2D tDisp;\\nuniform float amount;\\nuniform float angle;\\nuniform float seed;\\nuniform float seed_x;\\nuniform float seed_y;\\nuniform float distortion_x;\\nuniform float distortion_y;\\nuniform float col_s;\\nvarying vec2 vUv;\\nfloat rand(vec2 co){\\n\\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\\n}\\nvoid main() {\\n\\tif(byp\\x3c1) {\\n\\t\\tvec2 p \\x3d vUv;\\n\\t\\tfloat xs \\x3d floor(gl_FragCoord.x / 0.5);\\n\\t\\tfloat ys \\x3d floor(gl_FragCoord.y / 0.5);\\n\\t\\tvec4 normal \\x3d texture2D (tDisp, p*seed*seed);\\n\\t\\tif(p.y\\x3cdistortion_x+col_s \\x26\\x26 p.y\\x3edistortion_x-col_s*seed) {\\n\\t\\t\\tif(seed_x\\x3e0.){\\n\\t\\t\\t\\tp.y \\x3d 1. - (p.y + distortion_y);\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tp.y \\x3d distortion_y;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(p.x\\x3cdistortion_y+col_s \\x26\\x26 p.x\\x3edistortion_y-col_s*seed) {\\n\\t\\t\\tif(seed_y\\x3e0.){\\n\\t\\t\\t\\tp.x\\x3ddistortion_x;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tp.x \\x3d 1. - (p.x + distortion_x);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tp.x+\\x3dnormal.x*seed_x*(seed/5.);\\n\\t\\tp.y+\\x3dnormal.y*seed_y*(seed/5.);\\n\\t\\tvec2 offset \\x3d amount * vec2( cos(angle), sin(angle));\\n\\t\\tvec4 cr \\x3d texture2D(tDiffuse, p + offset);\\n\\t\\tvec4 cga \\x3d texture2D(tDiffuse, p);\\n\\t\\tvec4 cb \\x3d texture2D(tDiffuse, p - offset);\\n\\t\\tgl_FragColor \\x3d vec4(cr.r, cga.g, cb.b, cga.a);\\n\\t\\tvec4 snow \\x3d 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\\n\\t\\tgl_FragColor \\x3d gl_FragColor+ snow;\\n\\t}\\n\\telse {\\n\\t\\tgl_FragColor\\x3dtexture2D (tDiffuse, vUv);\\n\\t}\\n}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$DigitalGlitch\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DigitalGlitch = void 0;\n\n/**\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\nvar DigitalGlitch = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    //diffuse texture\n    tDisp: {\n      value: null\n    },\n    //displacement texture for digital glitch squares\n    byp: {\n      value: 0\n    },\n    //apply the glitch ?\n    amount: {\n      value: 0.08\n    },\n    angle: {\n      value: 0.02\n    },\n    seed: {\n      value: 0.02\n    },\n    seed_x: {\n      value: 0.02\n    },\n    //-1,1\n    seed_y: {\n      value: 0.02\n    },\n    //-1,1\n    distortion_x: {\n      value: 0.5\n    },\n    distortion_y: {\n      value: 0.6\n    },\n    col_s: {\n      value: 0.05\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform int byp;', //should we apply the glitch ?\n  'uniform sampler2D tDiffuse;', 'uniform sampler2D tDisp;', 'uniform float amount;', 'uniform float angle;', 'uniform float seed;', 'uniform float seed_x;', 'uniform float seed_y;', 'uniform float distortion_x;', 'uniform float distortion_y;', 'uniform float col_s;', 'varying vec2 vUv;', 'float rand(vec2 co){', '\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);', '}', 'void main() {', '\tif(byp<1) {', '\t\tvec2 p = vUv;', '\t\tfloat xs = floor(gl_FragCoord.x / 0.5);', '\t\tfloat ys = floor(gl_FragCoord.y / 0.5);', //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n  '\t\tvec4 normal = texture2D (tDisp, p*seed*seed);', '\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {', '\t\t\tif(seed_x>0.){', '\t\t\t\tp.y = 1. - (p.y + distortion_y);', '\t\t\t}', '\t\t\telse {', '\t\t\t\tp.y = distortion_y;', '\t\t\t}', '\t\t}', '\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {', '\t\t\tif(seed_y>0.){', '\t\t\t\tp.x=distortion_x;', '\t\t\t}', '\t\t\telse {', '\t\t\t\tp.x = 1. - (p.x + distortion_x);', '\t\t\t}', '\t\t}', '\t\tp.x+=normal.x*seed_x*(seed/5.);', '\t\tp.y+=normal.y*seed_y*(seed/5.);', //base from RGB shift shader\n  '\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));', '\t\tvec4 cr = texture2D(tDiffuse, p + offset);', '\t\tvec4 cga = texture2D(tDiffuse, p);', '\t\tvec4 cb = texture2D(tDiffuse, p - offset);', '\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);', //add noise\n  '\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);', '\t\tgl_FragColor = gl_FragColor+ snow;', '\t}', '\telse {', '\t\tgl_FragColor=texture2D (tDiffuse, vUv);', '\t}', '}'].join('\\n')\n};\nexports.DigitalGlitch = DigitalGlitch;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["fragmentShader","distortion_x","seed_y","col_s","distortion_y","seed_x","DigitalGlitch","byp","__esModule","tDiffuse","angle","vertexShader","value","seed","tDisp","amount","uniforms"]],"~:compiled-at",1630917515479,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$DigitalGlitch.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,sDAAA,CAA2E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGnHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,aAAR,CAAwB,IAAK,EA2D7BJ,QAAQI,CAAAA,aAAR,CAhDoBA,CAClBC,SAAU,CACRC,SAAU,CACRH,MAAO,IADC,CADF,CAKRI,MAAO,CACLJ,MAAO,IADF,CALC,CASRK,IAAK,CACHL,MAAO,CADJ,CATG,CAaRM,OAAQ,CACNN,MAAO,GADD,CAbA,CAgBRO,MAAO,CACLP,MAAO,GADF,CAhBC,CAmBRQ,KAAM,CACJR,MAAO,GADH,CAnBE,CAsBRS,OAAQ,CACNT,MAAO,GADD,CAtBA,CA0BRU,OAAQ,CACNV,MAAO,GADD,CA1BA,CA8BRW,aAAc,CACZX,MAAO,EADK,CA9BN,CAiCRY,aAAc,CACZZ,MAAO,EADK,CAjCN,CAoCRa,MAAO,CACLb,MAAO,GADF,CApCC,CADQC,CAyClBa,aAAiJ,qIAzC/Hb;AA0ClBc,eAIwL,ghDA9CtKd,CAjB+F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/DigitalGlitch.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$DigitalGlitch\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.DigitalGlitch = void 0;\\n\\n/**\\n * RGB Shift Shader\\n * Shifts red and blue channels from center in opposite directions\\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\\n * by Tom Butterworth / http://kriss.cx/tom/\\n *\\n * amount: shift distance (1 is width of input)\\n * angle: shift angle in radians\\n */\\nvar DigitalGlitch = {\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    //diffuse texture\\n    tDisp: {\\n      value: null\\n    },\\n    //displacement texture for digital glitch squares\\n    byp: {\\n      value: 0\\n    },\\n    //apply the glitch ?\\n    amount: {\\n      value: 0.08\\n    },\\n    angle: {\\n      value: 0.02\\n    },\\n    seed: {\\n      value: 0.02\\n    },\\n    seed_x: {\\n      value: 0.02\\n    },\\n    //-1,1\\n    seed_y: {\\n      value: 0.02\\n    },\\n    //-1,1\\n    distortion_x: {\\n      value: 0.5\\n    },\\n    distortion_y: {\\n      value: 0.6\\n    },\\n    col_s: {\\n      value: 0.05\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform int byp;', //should we apply the glitch ?\\n  'uniform sampler2D tDiffuse;', 'uniform sampler2D tDisp;', 'uniform float amount;', 'uniform float angle;', 'uniform float seed;', 'uniform float seed_x;', 'uniform float seed_y;', 'uniform float distortion_x;', 'uniform float distortion_y;', 'uniform float col_s;', 'varying vec2 vUv;', 'float rand(vec2 co){', '\\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);', '}', 'void main() {', '\\tif(byp<1) {', '\\t\\tvec2 p = vUv;', '\\t\\tfloat xs = floor(gl_FragCoord.x / 0.5);', '\\t\\tfloat ys = floor(gl_FragCoord.y / 0.5);', //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\\n  '\\t\\tvec4 normal = texture2D (tDisp, p*seed*seed);', '\\t\\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {', '\\t\\t\\tif(seed_x>0.){', '\\t\\t\\t\\tp.y = 1. - (p.y + distortion_y);', '\\t\\t\\t}', '\\t\\t\\telse {', '\\t\\t\\t\\tp.y = distortion_y;', '\\t\\t\\t}', '\\t\\t}', '\\t\\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {', '\\t\\t\\tif(seed_y>0.){', '\\t\\t\\t\\tp.x=distortion_x;', '\\t\\t\\t}', '\\t\\t\\telse {', '\\t\\t\\t\\tp.x = 1. - (p.x + distortion_x);', '\\t\\t\\t}', '\\t\\t}', '\\t\\tp.x+=normal.x*seed_x*(seed/5.);', '\\t\\tp.y+=normal.y*seed_y*(seed/5.);', //base from RGB shift shader\\n  '\\t\\tvec2 offset = amount * vec2( cos(angle), sin(angle));', '\\t\\tvec4 cr = texture2D(tDiffuse, p + offset);', '\\t\\tvec4 cga = texture2D(tDiffuse, p);', '\\t\\tvec4 cb = texture2D(tDiffuse, p - offset);', '\\t\\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);', //add noise\\n  '\\t\\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);', '\\t\\tgl_FragColor = gl_FragColor+ snow;', '\\t}', '\\telse {', '\\t\\tgl_FragColor=texture2D (tDiffuse, vUv);', '\\t}', '}'].join('\\\\n')\\n};\\nexports.DigitalGlitch = DigitalGlitch;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"DigitalGlitch\",\"uniforms\",\"tDiffuse\",\"tDisp\",\"byp\",\"amount\",\"angle\",\"seed\",\"seed_x\",\"seed_y\",\"distortion_x\",\"distortion_y\",\"col_s\",\"vertexShader\",\"fragmentShader\"]\n}\n"]