["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/VRMLLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$VRMLLoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");\n}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _possibleConstructorReturn(self,\ncall){return!call||\"object\"!==_typeof(call)&&\"function\"!==typeof call?_assertThisInitialized(self):call}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==\ntypeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});\nexports.VRMLLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_chevrotain=require(\"module$node_modules$chevrotain$lib$src$api\");global=function(_Loader){function VRMLLoader(manager){_classCallCheck(this,VRMLLoader);return _possibleConstructorReturn(this,_getPrototypeOf(VRMLLoader).call(this,manager))}_inherits(VRMLLoader,_Loader);_createClass(VRMLLoader,[{key:\"load\",value:function(url,onLoad,onProgress,onError){var scope=this,path=\"\"===scope.path?_three.LoaderUtils.extractUrlBase(url):\nscope.path,loader=new _three.FileLoader(scope.manager);loader.setPath(scope.path);loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(text){try{onLoad(scope.parse(text,path))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}},onProgress,onError)}},{key:\"parse\",value:function(data$jscomp$0,path){function createVisitor(BaseVRMLVisitor){function VRMLToASTVisitor(){BaseVRMLVisitor.call(this);this.validateVisitor()}\nfunction processField(scope,ctx){var field={type:null,values:[]};if(ctx.node){field.type=\"node\";for(var i=0,l=ctx.node.length;i<l;i++)field.values.push(scope.visit(ctx.node[i]))}if(ctx.use)for(field.type=\"use\",i=0,l=ctx.use.length;i<l;i++)field.values.push(scope.visit(ctx.use[i]));if(ctx.StringLiteral)for(field.type=\"string\",scope=0,i=ctx.StringLiteral.length;scope<i;scope++)field.values.push(ctx.StringLiteral[scope].image.replace(/'|\"/g,\"\"));if(ctx.NumberLiteral)for(field.type=\"number\",scope=0,i=\nctx.NumberLiteral.length;scope<i;scope++)field.values.push(parseFloat(ctx.NumberLiteral[scope].image));if(ctx.HexLiteral)for(field.type=\"hex\",scope=0,i=ctx.HexLiteral.length;scope<i;scope++)field.values.push(ctx.HexLiteral[scope].image);if(ctx.TrueLiteral)for(field.type=\"boolean\",scope=0,i=ctx.TrueLiteral.length;scope<i;scope++)\"TRUE\"===ctx.TrueLiteral[scope].image&&field.values.push(!0);if(ctx.FalseLiteral)for(field.type=\"boolean\",scope=0,i=ctx.FalseLiteral.length;scope<i;scope++)\"FALSE\"===ctx.FalseLiteral[scope].image&&\nfield.values.push(!1);ctx.NullLiteral&&(field.type=\"null\",ctx.NullLiteral.forEach(function(){field.values.push(null)}));return field}VRMLToASTVisitor.prototype=Object.assign(Object.create(BaseVRMLVisitor.prototype),{constructor:VRMLToASTVisitor,vrml:function(ctx){for(var data={version:this.visit(ctx.version),nodes:[],routes:[]},i=0,l=ctx.node.length;i<l;i++)data.nodes.push(this.visit(ctx.node[i]));if(ctx.route)for(i=0,l=ctx.route.length;i<l;i++)data.routes.push(this.visit(ctx.route[i]));return data},\nversion:function(ctx){return ctx.Version[0].image},node:function(ctx){var data={name:ctx.NodeName[0].image,fields:[]};if(ctx.field)for(var i=0,l=ctx.field.length;i<l;i++)data.fields.push(this.visit(ctx.field[i]));ctx.def&&(data.DEF=this.visit(ctx.def[0]));return data},field:function(ctx){var data={name:ctx.Identifier[0].image,type:null,values:null},result;ctx.singleFieldValue&&(result=this.visit(ctx.singleFieldValue[0]));ctx.multiFieldValue&&(result=this.visit(ctx.multiFieldValue[0]));data.type=result.type;\ndata.values=result.values;return data},def:function(ctx){return(ctx.Identifier||ctx.NodeName)[0].image},use:function(ctx){return{USE:(ctx.Identifier||ctx.NodeName)[0].image}},singleFieldValue:function(ctx){return processField(this,ctx)},multiFieldValue:function(ctx){return processField(this,ctx)},route:function(ctx){return{FROM:ctx.RouteIdentifier[0].image,TO:ctx.RouteIdentifier[1].image}}});return new VRMLToASTVisitor}function buildNodeMap(node){node.DEF&&(nodeMap[node.DEF]=node);node=node.fields;\nfor(var i=0,l=node.length;i<l;i++){var field=node[i];if(\"node\"===field.type){field=field.values;for(var j=0,jl=field.length;j<jl;j++)buildNodeMap(field[j])}}}function getNode(node){if(node.USE){var build=getNode(nodeMap[node.USE]);return build.isObject3D||build.isMaterial?build.clone():build}if(void 0!==node.build)return node.build;var nodeName=node.name;switch(nodeName){case \"Group\":case \"Transform\":case \"Collision\":for(var object=new _three.Group,fields=node.fields,i=0,l=fields.length;i<l;i++){var field=\nfields[i],fieldName=field.name,fieldValues=field.values;switch(fieldName){case \"bboxCenter\":break;case \"bboxSize\":break;case \"center\":break;case \"children\":for(var children=fieldValues,owner=object,i$jscomp$0=0,l$jscomp$0=children.length;i$jscomp$0<l$jscomp$0;i$jscomp$0++){var object$jscomp$0=getNode(children[i$jscomp$0]);object$jscomp$0 instanceof _three.Object3D&&owner.add(object$jscomp$0)}break;case \"collide\":break;case \"rotation\":var axis=new _three.Vector3(fieldValues[0],fieldValues[1],fieldValues[2]);\nobject.quaternion.setFromAxisAngle(axis,fieldValues[3]);break;case \"scale\":object.scale.set(fieldValues[0],fieldValues[1],fieldValues[2]);break;case \"scaleOrientation\":break;case \"translation\":object.position.set(fieldValues[0],fieldValues[1],fieldValues[2]);break;case \"proxy\":break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName)}}var build$jscomp$0=object;break;case \"Background\":for(var group=new _three.Group,groundAngle,groundColor,skyAngle,skyColor,fields$jscomp$0=node.fields,\ni$jscomp$1=0,l$jscomp$1=fields$jscomp$0.length;i$jscomp$1<l$jscomp$1;i$jscomp$1++){var field$jscomp$0=fields$jscomp$0[i$jscomp$1],fieldName$jscomp$0=field$jscomp$0.name,fieldValues$jscomp$0=field$jscomp$0.values;switch(fieldName$jscomp$0){case \"groundAngle\":groundAngle=fieldValues$jscomp$0;break;case \"groundColor\":groundColor=fieldValues$jscomp$0;break;case \"backUrl\":break;case \"bottomUrl\":break;case \"frontUrl\":break;case \"leftUrl\":break;case \"rightUrl\":break;case \"topUrl\":break;case \"skyAngle\":skyAngle=\nfieldValues$jscomp$0;break;case \"skyColor\":skyColor=fieldValues$jscomp$0;break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$0)}}if(skyColor){var skyGeometry=new _three.SphereGeometry(1E4,32,16),skyMaterial=new _three.MeshBasicMaterial({fog:!1,side:_three.BackSide,depthWrite:!1,depthTest:!1});3<skyColor.length?(paintFaces(skyGeometry,1E4,skyAngle,toColorArray(skyColor),!0),skyMaterial.vertexColors=!0):skyMaterial.color.setRGB(skyColor[0],skyColor[1],skyColor[2]);var sky=\nnew _three.Mesh(skyGeometry,skyMaterial);group.add(sky)}if(groundColor&&0<groundColor.length){var groundGeometry=new _three.SphereGeometry(1E4,32,16,0,2*Math.PI,.5*Math.PI,1.5*Math.PI),groundMaterial=new _three.MeshBasicMaterial({fog:!1,side:_three.BackSide,vertexColors:!0,depthWrite:!1,depthTest:!1});paintFaces(groundGeometry,1E4,groundAngle,toColorArray(groundColor),!1);var ground=new _three.Mesh(groundGeometry,groundMaterial);group.add(ground)}group.renderOrder=-Infinity;build$jscomp$0=group;break;\ncase \"Shape\":for(var fields$jscomp$1=node.fields,material=new _three.MeshBasicMaterial({color:0}),geometry,i$jscomp$2=0,l$jscomp$2=fields$jscomp$1.length;i$jscomp$2<l$jscomp$2;i$jscomp$2++){var field$jscomp$1=fields$jscomp$1[i$jscomp$2],fieldName$jscomp$1=field$jscomp$1.name,fieldValues$jscomp$1=field$jscomp$1.values;switch(fieldName$jscomp$1){case \"appearance\":null!==fieldValues$jscomp$1[0]&&(material=getNode(fieldValues$jscomp$1[0]));break;case \"geometry\":null!==fieldValues$jscomp$1[0]&&(geometry=\ngetNode(fieldValues$jscomp$1[0]));break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$1)}}if(geometry&&geometry.attributes.position){var type=geometry._type;if(\"points\"===type){var pointsMaterial=new _three.PointsMaterial({color:16777215});void 0!==geometry.attributes.color?pointsMaterial.vertexColors=!0:material.isMeshPhongMaterial&&pointsMaterial.color.copy(material.emissive);var object$jscomp$1=new _three.Points(geometry,pointsMaterial)}else if(\"line\"===type){var lineMaterial=\nnew _three.LineBasicMaterial({color:16777215});void 0!==geometry.attributes.color?lineMaterial.vertexColors=!0:material.isMeshPhongMaterial&&lineMaterial.color.copy(material.emissive);object$jscomp$1=new _three.LineSegments(geometry,lineMaterial)}else void 0!==geometry._solid&&(material.side=geometry._solid?_three.FrontSide:_three.DoubleSide),void 0!==geometry.attributes.color&&(material.vertexColors=!0),object$jscomp$1=new _three.Mesh(geometry,material)}else object$jscomp$1=new _three.Object3D,object$jscomp$1.visible=\n!1;build$jscomp$0=object$jscomp$1;break;case \"Appearance\":for(var material$jscomp$0=new _three.MeshPhongMaterial,transformData,fields$jscomp$2=node.fields,i$jscomp$3=0,l$jscomp$3=fields$jscomp$2.length;i$jscomp$3<l$jscomp$3;i$jscomp$3++){var field$jscomp$2=fields$jscomp$2[i$jscomp$3],fieldName$jscomp$2=field$jscomp$2.name,fieldValues$jscomp$2=field$jscomp$2.values;switch(fieldName$jscomp$2){case \"material\":if(null!==fieldValues$jscomp$2[0]){var materialData=getNode(fieldValues$jscomp$2[0]);materialData.diffuseColor&&\nmaterial$jscomp$0.color.copy(materialData.diffuseColor);materialData.emissiveColor&&material$jscomp$0.emissive.copy(materialData.emissiveColor);materialData.shininess&&(material$jscomp$0.shininess=materialData.shininess);materialData.specularColor&&material$jscomp$0.specular.copy(materialData.specularColor);materialData.transparency&&(material$jscomp$0.opacity=1-materialData.transparency);0<materialData.transparency&&(material$jscomp$0.transparent=!0)}else material$jscomp$0=new _three.MeshBasicMaterial({color:0});\nbreak;case \"texture\":var textureNode=fieldValues$jscomp$2[0];null===textureNode||\"ImageTexture\"!==textureNode.name&&\"PixelTexture\"!==textureNode.name||(material$jscomp$0.map=getNode(textureNode));break;case \"textureTransform\":null!==fieldValues$jscomp$2[0]&&(transformData=getNode(fieldValues$jscomp$2[0]));break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$2)}}if(material$jscomp$0.map){if(material$jscomp$0.map.__type){switch(material$jscomp$0.map.__type){case TEXTURE_TYPE.INTENSITY_ALPHA:material$jscomp$0.opacity=\n1;break;case TEXTURE_TYPE.RGB:material$jscomp$0.color.set(16777215);break;case TEXTURE_TYPE.RGBA:material$jscomp$0.color.set(16777215),material$jscomp$0.opacity=1}delete material$jscomp$0.map.__type}transformData&&(material$jscomp$0.map.center.copy(transformData.center),material$jscomp$0.map.rotation=transformData.rotation,material$jscomp$0.map.repeat.copy(transformData.scale),material$jscomp$0.map.offset.copy(transformData.translation))}build$jscomp$0=material$jscomp$0;break;case \"Material\":for(var materialData$jscomp$0=\n{},fields$jscomp$3=node.fields,i$jscomp$4=0,l$jscomp$4=fields$jscomp$3.length;i$jscomp$4<l$jscomp$4;i$jscomp$4++){var field$jscomp$3=fields$jscomp$3[i$jscomp$4],fieldName$jscomp$3=field$jscomp$3.name,fieldValues$jscomp$3=field$jscomp$3.values;switch(fieldName$jscomp$3){case \"ambientIntensity\":break;case \"diffuseColor\":materialData$jscomp$0.diffuseColor=new _three.Color(fieldValues$jscomp$3[0],fieldValues$jscomp$3[1],fieldValues$jscomp$3[2]);break;case \"emissiveColor\":materialData$jscomp$0.emissiveColor=\nnew _three.Color(fieldValues$jscomp$3[0],fieldValues$jscomp$3[1],fieldValues$jscomp$3[2]);break;case \"shininess\":materialData$jscomp$0.shininess=fieldValues$jscomp$3[0];break;case \"specularColor\":materialData$jscomp$0.emissiveColor=new _three.Color(fieldValues$jscomp$3[0],fieldValues$jscomp$3[1],fieldValues$jscomp$3[2]);break;case \"transparency\":materialData$jscomp$0.transparency=fieldValues$jscomp$3[0];break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$3)}}build$jscomp$0=\nmaterialData$jscomp$0;break;case \"ImageTexture\":for(var texture,wrapS=_three.RepeatWrapping,wrapT=_three.RepeatWrapping,fields$jscomp$4=node.fields,i$jscomp$5=0,l$jscomp$5=fields$jscomp$4.length;i$jscomp$5<l$jscomp$5;i$jscomp$5++){var field$jscomp$4=fields$jscomp$4[i$jscomp$5],fieldName$jscomp$4=field$jscomp$4.name,fieldValues$jscomp$4=field$jscomp$4.values;switch(fieldName$jscomp$4){case \"url\":var url=fieldValues$jscomp$4[0];url&&(texture=textureLoader.load(url));break;case \"repeatS\":!1===fieldValues$jscomp$4[0]&&\n(wrapS=_three.ClampToEdgeWrapping);break;case \"repeatT\":!1===fieldValues$jscomp$4[0]&&(wrapT=_three.ClampToEdgeWrapping);break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$4)}}texture&&(texture.wrapS=wrapS,texture.wrapT=wrapT);build$jscomp$0=texture;break;case \"PixelTexture\":for(var texture$jscomp$0,wrapS$jscomp$0=_three.RepeatWrapping,wrapT$jscomp$0=_three.RepeatWrapping,fields$jscomp$5=node.fields,i$jscomp$6=0,l$jscomp$6=fields$jscomp$5.length;i$jscomp$6<l$jscomp$6;i$jscomp$6++){var field$jscomp$5=\nfields$jscomp$5[i$jscomp$6],fieldName$jscomp$5=field$jscomp$5.name,fieldValues$jscomp$5=field$jscomp$5.values;switch(fieldName$jscomp$5){case \"image\":var width=fieldValues$jscomp$5[0],height=fieldValues$jscomp$5[1],num_components=fieldValues$jscomp$5[2],useAlpha=2===num_components||4===num_components,type$jscomp$0=void 0;switch(num_components){case 1:type$jscomp$0=TEXTURE_TYPE.INTENSITY;break;case 2:type$jscomp$0=TEXTURE_TYPE.INTENSITY_ALPHA;break;case 3:type$jscomp$0=TEXTURE_TYPE.RGB;break;case 4:type$jscomp$0=\nTEXTURE_TYPE.RGBA}var textureType=type$jscomp$0;for(var _data=new Uint8Array((!0===useAlpha?4:3)*width*height),color={r:0,g:0,b:0,a:0},j=3,k=0,jl=fieldValues$jscomp$5.length;j<jl;j++,k++){var hex=fieldValues$jscomp$5[j],color$jscomp$0=color;switch(textureType){case TEXTURE_TYPE.INTENSITY:var value=parseInt(hex);color$jscomp$0.r=value;color$jscomp$0.g=value;color$jscomp$0.b=value;break;case TEXTURE_TYPE.INTENSITY_ALPHA:value=parseInt(\"0x\"+hex.substring(2,4));color$jscomp$0.r=value;color$jscomp$0.g=\nvalue;color$jscomp$0.b=value;color$jscomp$0.a=parseInt(\"0x\"+hex.substring(4,6));break;case TEXTURE_TYPE.RGB:color$jscomp$0.r=parseInt(\"0x\"+hex.substring(2,4));color$jscomp$0.g=parseInt(\"0x\"+hex.substring(4,6));color$jscomp$0.b=parseInt(\"0x\"+hex.substring(6,8));break;case TEXTURE_TYPE.RGBA:color$jscomp$0.r=parseInt(\"0x\"+hex.substring(2,4)),color$jscomp$0.g=parseInt(\"0x\"+hex.substring(4,6)),color$jscomp$0.b=parseInt(\"0x\"+hex.substring(6,8)),color$jscomp$0.a=parseInt(\"0x\"+hex.substring(8,10))}if(!0===\nuseAlpha){var stride=4*k;_data[stride+0]=color.r;_data[stride+1]=color.g;_data[stride+2]=color.b;_data[stride+3]=color.a}else{var _stride=3*k;_data[_stride+0]=color.r;_data[_stride+1]=color.g;_data[_stride+2]=color.b}}texture$jscomp$0=new _three.DataTexture(_data,width,height,!0===useAlpha?_three.RGBAFormat:_three.RGBFormat);texture$jscomp$0.__type=textureType;break;case \"repeatS\":!1===fieldValues$jscomp$5[0]&&(wrapS$jscomp$0=_three.ClampToEdgeWrapping);break;case \"repeatT\":!1===fieldValues$jscomp$5[0]&&\n(wrapT$jscomp$0=_three.ClampToEdgeWrapping);break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$5)}}texture$jscomp$0&&(texture$jscomp$0.wrapS=wrapS$jscomp$0,texture$jscomp$0.wrapT=wrapT$jscomp$0);build$jscomp$0=texture$jscomp$0;break;case \"TextureTransform\":for(var transformData$jscomp$0={center:new _three.Vector2,rotation:new _three.Vector2,scale:new _three.Vector2,translation:new _three.Vector2},fields$jscomp$6=node.fields,i$jscomp$7=0,l$jscomp$7=fields$jscomp$6.length;i$jscomp$7<\nl$jscomp$7;i$jscomp$7++){var field$jscomp$6=fields$jscomp$6[i$jscomp$7],fieldName$jscomp$6=field$jscomp$6.name,fieldValues$jscomp$6=field$jscomp$6.values;switch(fieldName$jscomp$6){case \"center\":transformData$jscomp$0.center.set(fieldValues$jscomp$6[0],fieldValues$jscomp$6[1]);break;case \"rotation\":transformData$jscomp$0.rotation=fieldValues$jscomp$6[0];break;case \"scale\":transformData$jscomp$0.scale.set(fieldValues$jscomp$6[0],fieldValues$jscomp$6[1]);break;case \"translation\":transformData$jscomp$0.translation.set(fieldValues$jscomp$6[0],\nfieldValues$jscomp$6[1]);break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$6)}}build$jscomp$0=transformData$jscomp$0;break;case \"IndexedFaceSet\":for(var color$jscomp$1,coord,normal,texCoord,ccw=!0,solid=!0,creaseAngle=0,colorIndex,coordIndex,normalIndex,texCoordIndex,colorPerVertex=!0,normalPerVertex=!0,fields$jscomp$7=node.fields,i$jscomp$8=0,l$jscomp$8=fields$jscomp$7.length;i$jscomp$8<l$jscomp$8;i$jscomp$8++){var field$jscomp$7=fields$jscomp$7[i$jscomp$8],fieldName$jscomp$7=\nfield$jscomp$7.name,fieldValues$jscomp$7=field$jscomp$7.values;switch(fieldName$jscomp$7){case \"color\":var colorNode=fieldValues$jscomp$7[0];null!==colorNode&&(color$jscomp$1=getNode(colorNode));break;case \"coord\":var coordNode=fieldValues$jscomp$7[0];null!==coordNode&&(coord=getNode(coordNode));break;case \"normal\":var normalNode=fieldValues$jscomp$7[0];null!==normalNode&&(normal=getNode(normalNode));break;case \"texCoord\":var texCoordNode=fieldValues$jscomp$7[0];null!==texCoordNode&&(texCoord=getNode(texCoordNode));\nbreak;case \"ccw\":ccw=fieldValues$jscomp$7[0];break;case \"colorIndex\":colorIndex=fieldValues$jscomp$7;break;case \"colorPerVertex\":colorPerVertex=fieldValues$jscomp$7[0];break;case \"convex\":break;case \"coordIndex\":coordIndex=fieldValues$jscomp$7;break;case \"creaseAngle\":creaseAngle=fieldValues$jscomp$7[0];break;case \"normalIndex\":normalIndex=fieldValues$jscomp$7;break;case \"normalPerVertex\":normalPerVertex=fieldValues$jscomp$7[0];break;case \"solid\":solid=fieldValues$jscomp$7[0];break;case \"texCoordIndex\":texCoordIndex=\nfieldValues$jscomp$7;break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$7)}}if(void 0===coordIndex)console.warn(\"THREE.VRMLLoader: Missing coordIndex.\"),build$jscomp$0=new _three.BufferGeometry;else{var triangulatedCoordIndex=triangulateFaceIndex(coordIndex,ccw);if(color$jscomp$1)if(!0===colorPerVertex)if(colorIndex&&0<colorIndex.length){var triangulatedColorIndex=triangulateFaceIndex(colorIndex,ccw);var colorAttribute=computeAttributeFromIndexedData(triangulatedCoordIndex,\ntriangulatedColorIndex,color$jscomp$1,3)}else colorAttribute=toNonIndexedAttribute(triangulatedCoordIndex,new _three.Float32BufferAttribute(color$jscomp$1,3));else if(colorIndex&&0<colorIndex.length){var flattenFaceColors=flattenData(color$jscomp$1,colorIndex),triangulatedFaceColors=triangulateFaceData(flattenFaceColors,coordIndex);colorAttribute=computeAttributeFromFaceData(triangulatedCoordIndex,triangulatedFaceColors)}else{var _triangulatedFaceColors=triangulateFaceData(color$jscomp$1,coordIndex);\ncolorAttribute=computeAttributeFromFaceData(triangulatedCoordIndex,_triangulatedFaceColors)}if(normal)if(!0===normalPerVertex)if(normalIndex&&0<normalIndex.length){var triangulatedNormalIndex=triangulateFaceIndex(normalIndex,ccw);var normalAttribute=computeAttributeFromIndexedData(triangulatedCoordIndex,triangulatedNormalIndex,normal,3)}else normalAttribute=toNonIndexedAttribute(triangulatedCoordIndex,new _three.Float32BufferAttribute(normal,3));else if(normalIndex&&0<normalIndex.length){var flattenFaceNormals=\nflattenData(normal,normalIndex),triangulatedFaceNormals=triangulateFaceData(flattenFaceNormals,coordIndex);normalAttribute=computeAttributeFromFaceData(triangulatedCoordIndex,triangulatedFaceNormals)}else{var _triangulatedFaceNormals=triangulateFaceData(normal,coordIndex);normalAttribute=computeAttributeFromFaceData(triangulatedCoordIndex,_triangulatedFaceNormals)}else normalAttribute=computeNormalAttribute(triangulatedCoordIndex,coord,creaseAngle);if(texCoord)if(texCoordIndex&&0<texCoordIndex.length){var triangulatedTexCoordIndex=\ntriangulateFaceIndex(texCoordIndex,ccw);var uvAttribute=computeAttributeFromIndexedData(triangulatedCoordIndex,triangulatedTexCoordIndex,texCoord,2)}else uvAttribute=toNonIndexedAttribute(triangulatedCoordIndex,new _three.Float32BufferAttribute(texCoord,2));var geometry$jscomp$0=new _three.BufferGeometry,positionAttribute=toNonIndexedAttribute(triangulatedCoordIndex,new _three.Float32BufferAttribute(coord,3));geometry$jscomp$0.setAttribute(\"position\",positionAttribute);geometry$jscomp$0.setAttribute(\"normal\",\nnormalAttribute);colorAttribute&&geometry$jscomp$0.setAttribute(\"color\",colorAttribute);uvAttribute&&geometry$jscomp$0.setAttribute(\"uv\",uvAttribute);geometry$jscomp$0._solid=solid;geometry$jscomp$0._type=\"mesh\";build$jscomp$0=geometry$jscomp$0}break;case \"IndexedLineSet\":for(var color$jscomp$2,coord$jscomp$0,colorIndex$jscomp$0,coordIndex$jscomp$0,colorPerVertex$jscomp$0=!0,fields$jscomp$8=node.fields,i$jscomp$9=0,l$jscomp$9=fields$jscomp$8.length;i$jscomp$9<l$jscomp$9;i$jscomp$9++){var field$jscomp$8=\nfields$jscomp$8[i$jscomp$9],fieldName$jscomp$8=field$jscomp$8.name,fieldValues$jscomp$8=field$jscomp$8.values;switch(fieldName$jscomp$8){case \"color\":var colorNode$jscomp$0=fieldValues$jscomp$8[0];null!==colorNode$jscomp$0&&(color$jscomp$2=getNode(colorNode$jscomp$0));break;case \"coord\":var coordNode$jscomp$0=fieldValues$jscomp$8[0];null!==coordNode$jscomp$0&&(coord$jscomp$0=getNode(coordNode$jscomp$0));break;case \"colorIndex\":colorIndex$jscomp$0=fieldValues$jscomp$8;break;case \"colorPerVertex\":colorPerVertex$jscomp$0=\nfieldValues$jscomp$8[0];break;case \"coordIndex\":coordIndex$jscomp$0=fieldValues$jscomp$8;break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$8)}}var expandedLineIndex=expandLineIndex(coordIndex$jscomp$0);if(color$jscomp$2)if(!0===colorPerVertex$jscomp$0)if(0<colorIndex$jscomp$0.length){var expandedColorIndex=expandLineIndex(colorIndex$jscomp$0);var colorAttribute$jscomp$0=computeAttributeFromIndexedData(expandedLineIndex,expandedColorIndex,color$jscomp$2,3)}else colorAttribute$jscomp$0=\ntoNonIndexedAttribute(expandedLineIndex,new _three.Float32BufferAttribute(color$jscomp$2,3));else if(0<colorIndex$jscomp$0.length){var flattenLineColors=flattenData(color$jscomp$2,colorIndex$jscomp$0),expandedLineColors=expandLineData(flattenLineColors,coordIndex$jscomp$0);colorAttribute$jscomp$0=computeAttributeFromLineData(expandedLineIndex,expandedLineColors)}else{var _expandedLineColors=expandLineData(color$jscomp$2,coordIndex$jscomp$0);colorAttribute$jscomp$0=computeAttributeFromLineData(expandedLineIndex,\n_expandedLineColors)}var geometry$jscomp$1=new _three.BufferGeometry,positionAttribute$jscomp$0=toNonIndexedAttribute(expandedLineIndex,new _three.Float32BufferAttribute(coord$jscomp$0,3));geometry$jscomp$1.setAttribute(\"position\",positionAttribute$jscomp$0);colorAttribute$jscomp$0&&geometry$jscomp$1.setAttribute(\"color\",colorAttribute$jscomp$0);geometry$jscomp$1._type=\"line\";build$jscomp$0=geometry$jscomp$1;break;case \"PointSet\":for(var color$jscomp$3,coord$jscomp$1,fields$jscomp$9=node.fields,i$jscomp$10=\n0,l$jscomp$10=fields$jscomp$9.length;i$jscomp$10<l$jscomp$10;i$jscomp$10++){var field$jscomp$9=fields$jscomp$9[i$jscomp$10],fieldName$jscomp$9=field$jscomp$9.name,fieldValues$jscomp$9=field$jscomp$9.values;switch(fieldName$jscomp$9){case \"color\":var colorNode$jscomp$1=fieldValues$jscomp$9[0];null!==colorNode$jscomp$1&&(color$jscomp$3=getNode(colorNode$jscomp$1));break;case \"coord\":var coordNode$jscomp$1=fieldValues$jscomp$9[0];null!==coordNode$jscomp$1&&(coord$jscomp$1=getNode(coordNode$jscomp$1));\nbreak;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$9)}}var geometry$jscomp$2=new _three.BufferGeometry;geometry$jscomp$2.setAttribute(\"position\",new _three.Float32BufferAttribute(coord$jscomp$1,3));color$jscomp$3&&geometry$jscomp$2.setAttribute(\"color\",new _three.Float32BufferAttribute(color$jscomp$3,3));geometry$jscomp$2._type=\"points\";build$jscomp$0=geometry$jscomp$2;break;case \"Box\":for(var size=new _three.Vector3(2,2,2),fields$jscomp$10=node.fields,i$jscomp$11=0,l$jscomp$11=\nfields$jscomp$10.length;i$jscomp$11<l$jscomp$11;i$jscomp$11++){var field$jscomp$10=fields$jscomp$10[i$jscomp$11],fieldName$jscomp$10=field$jscomp$10.name,fieldValues$jscomp$10=field$jscomp$10.values;switch(fieldName$jscomp$10){case \"size\":size.x=fieldValues$jscomp$10[0];size.y=fieldValues$jscomp$10[1];size.z=fieldValues$jscomp$10[2];break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$10)}}build$jscomp$0=new _three.BoxGeometry(size.x,size.y,size.z);break;case \"Cone\":for(var radius=\n1,height$jscomp$0=2,openEnded=!1,fields$jscomp$11=node.fields,i$jscomp$12=0,l$jscomp$12=fields$jscomp$11.length;i$jscomp$12<l$jscomp$12;i$jscomp$12++){var field$jscomp$11=fields$jscomp$11[i$jscomp$12],fieldName$jscomp$11=field$jscomp$11.name,fieldValues$jscomp$11=field$jscomp$11.values;switch(fieldName$jscomp$11){case \"bottom\":openEnded=!fieldValues$jscomp$11[0];break;case \"bottomRadius\":radius=fieldValues$jscomp$11[0];break;case \"height\":height$jscomp$0=fieldValues$jscomp$11[0];break;case \"side\":break;\ndefault:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$11)}}build$jscomp$0=new _three.ConeGeometry(radius,height$jscomp$0,16,1,openEnded);break;case \"Cylinder\":for(var radius$jscomp$0=1,height$jscomp$1=2,fields$jscomp$12=node.fields,i$jscomp$13=0,l$jscomp$13=fields$jscomp$12.length;i$jscomp$13<l$jscomp$13;i$jscomp$13++){var field$jscomp$12=fields$jscomp$12[i$jscomp$13],fieldName$jscomp$12=field$jscomp$12.name,fieldValues$jscomp$12=field$jscomp$12.values;switch(fieldName$jscomp$12){case \"bottom\":break;\ncase \"radius\":radius$jscomp$0=fieldValues$jscomp$12[0];break;case \"height\":height$jscomp$1=fieldValues$jscomp$12[0];break;case \"side\":break;case \"top\":break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$12)}}build$jscomp$0=new _three.CylinderGeometry(radius$jscomp$0,radius$jscomp$0,height$jscomp$1,16,1);break;case \"Sphere\":for(var radius$jscomp$1=1,fields$jscomp$13=node.fields,i$jscomp$14=0,l$jscomp$14=fields$jscomp$13.length;i$jscomp$14<l$jscomp$14;i$jscomp$14++){var field$jscomp$13=\nfields$jscomp$13[i$jscomp$14],fieldName$jscomp$13=field$jscomp$13.name,fieldValues$jscomp$13=field$jscomp$13.values;switch(fieldName$jscomp$13){case \"radius\":radius$jscomp$1=fieldValues$jscomp$13[0];break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$13)}}build$jscomp$0=new _three.SphereGeometry(radius$jscomp$1,16,16);break;case \"ElevationGrid\":for(var color$jscomp$4,normal$jscomp$0,texCoord$jscomp$0,height$jscomp$2,colorPerVertex$jscomp$1=!0,normalPerVertex$jscomp$0=!0,\nsolid$jscomp$0=!0,ccw$jscomp$0=!0,creaseAngle$jscomp$0=0,xDimension=2,zDimension=2,xSpacing=1,zSpacing=1,fields$jscomp$14=node.fields,i$jscomp$15=0,l$jscomp$15=fields$jscomp$14.length;i$jscomp$15<l$jscomp$15;i$jscomp$15++){var field$jscomp$14=fields$jscomp$14[i$jscomp$15],fieldName$jscomp$14=field$jscomp$14.name,fieldValues$jscomp$14=field$jscomp$14.values;switch(fieldName$jscomp$14){case \"color\":var colorNode$jscomp$2=fieldValues$jscomp$14[0];null!==colorNode$jscomp$2&&(color$jscomp$4=getNode(colorNode$jscomp$2));\nbreak;case \"normal\":var normalNode$jscomp$0=fieldValues$jscomp$14[0];null!==normalNode$jscomp$0&&(normal$jscomp$0=getNode(normalNode$jscomp$0));break;case \"texCoord\":var texCoordNode$jscomp$0=fieldValues$jscomp$14[0];null!==texCoordNode$jscomp$0&&(texCoord$jscomp$0=getNode(texCoordNode$jscomp$0));break;case \"height\":height$jscomp$2=fieldValues$jscomp$14;break;case \"ccw\":ccw$jscomp$0=fieldValues$jscomp$14[0];break;case \"colorPerVertex\":colorPerVertex$jscomp$1=fieldValues$jscomp$14[0];break;case \"creaseAngle\":creaseAngle$jscomp$0=\nfieldValues$jscomp$14[0];break;case \"normalPerVertex\":normalPerVertex$jscomp$0=fieldValues$jscomp$14[0];break;case \"solid\":solid$jscomp$0=fieldValues$jscomp$14[0];break;case \"xDimension\":xDimension=fieldValues$jscomp$14[0];break;case \"xSpacing\":xSpacing=fieldValues$jscomp$14[0];break;case \"zDimension\":zDimension=fieldValues$jscomp$14[0];break;case \"zSpacing\":zSpacing=fieldValues$jscomp$14[0];break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$14)}}for(var vertices=[],normals=\n[],colors=[],uvs=[],_i9=0;_i9<zDimension;_i9++)for(var j$jscomp$0=0;j$jscomp$0<xDimension;j$jscomp$0++){var index=_i9*xDimension+j$jscomp$0;vertices.push(xSpacing*_i9,height$jscomp$2[index],zSpacing*j$jscomp$0);color$jscomp$4&&!0===colorPerVertex$jscomp$1&&colors.push(color$jscomp$4[3*index],color$jscomp$4[3*index+1],color$jscomp$4[3*index+2]);normal$jscomp$0&&!0===normalPerVertex$jscomp$0&&normals.push(normal$jscomp$0[3*index],normal$jscomp$0[3*index+1],normal$jscomp$0[3*index+2]);texCoord$jscomp$0?\nuvs.push(texCoord$jscomp$0[2*index],texCoord$jscomp$0[2*index+1]):uvs.push(_i9/(xDimension-1),j$jscomp$0/(zDimension-1))}for(var indices=[],_i10=0;_i10<xDimension-1;_i10++)for(var _j=0;_j<zDimension-1;_j++){var a=_i10+_j*xDimension,_b=_i10+(_j+1)*xDimension,c=_i10+1+(_j+1)*xDimension,d=_i10+1+_j*xDimension;!0===ccw$jscomp$0?(indices.push(a,c,_b),indices.push(c,a,d)):(indices.push(a,_b,c),indices.push(c,d,a))}var positionAttribute$jscomp$1=toNonIndexedAttribute(indices,new _three.Float32BufferAttribute(vertices,\n3)),uvAttribute$jscomp$0=toNonIndexedAttribute(indices,new _three.Float32BufferAttribute(uvs,2));if(color$jscomp$4)if(!1===colorPerVertex$jscomp$1){for(var _i11=0;_i11<xDimension-1;_i11++)for(var _j2=0;_j2<zDimension-1;_j2++){var _index=_i11+_j2*(xDimension-1),_r=color$jscomp$4[3*_index],_g=color$jscomp$4[3*_index+1],_b2=color$jscomp$4[3*_index+2];colors.push(_r,_g,_b2);colors.push(_r,_g,_b2);colors.push(_r,_g,_b2);colors.push(_r,_g,_b2);colors.push(_r,_g,_b2);colors.push(_r,_g,_b2)}var colorAttribute$jscomp$1=\nnew _three.Float32BufferAttribute(colors,3)}else colorAttribute$jscomp$1=toNonIndexedAttribute(indices,new _three.Float32BufferAttribute(colors,3));if(normal$jscomp$0)if(!1===normalPerVertex$jscomp$0){for(var _i12=0;_i12<xDimension-1;_i12++)for(var _j3=0;_j3<zDimension-1;_j3++){var _index2=_i12+_j3*(xDimension-1),_xn=normal$jscomp$0[3*_index2],_yn=normal$jscomp$0[3*_index2+1],_zn=normal$jscomp$0[3*_index2+2];normals.push(_xn,_yn,_zn);normals.push(_xn,_yn,_zn);normals.push(_xn,_yn,_zn);normals.push(_xn,\n_yn,_zn);normals.push(_xn,_yn,_zn);normals.push(_xn,_yn,_zn)}var normalAttribute$jscomp$0=new _three.Float32BufferAttribute(normals,3)}else normalAttribute$jscomp$0=toNonIndexedAttribute(indices,new _three.Float32BufferAttribute(normals,3));else normalAttribute$jscomp$0=computeNormalAttribute(indices,vertices,creaseAngle$jscomp$0);var geometry$jscomp$3=new _three.BufferGeometry;geometry$jscomp$3.setAttribute(\"position\",positionAttribute$jscomp$1);geometry$jscomp$3.setAttribute(\"normal\",normalAttribute$jscomp$0);\ngeometry$jscomp$3.setAttribute(\"uv\",uvAttribute$jscomp$0);colorAttribute$jscomp$1&&geometry$jscomp$3.setAttribute(\"color\",colorAttribute$jscomp$1);geometry$jscomp$3._solid=solid$jscomp$0;geometry$jscomp$3._type=\"mesh\";build$jscomp$0=geometry$jscomp$3;break;case \"Extrusion\":for(var crossSection=[1,1,1,-1,-1,-1,-1,1,1,1],spine=[0,0,0,0,1,0],scale,orientation,beginCap=!0,ccw$jscomp$1=!0,creaseAngle$jscomp$1=0,endCap=!0,solid$jscomp$1=!0,fields$jscomp$15=node.fields,i$jscomp$16=0,l$jscomp$16=fields$jscomp$15.length;i$jscomp$16<\nl$jscomp$16;i$jscomp$16++){var field$jscomp$15=fields$jscomp$15[i$jscomp$16],fieldName$jscomp$15=field$jscomp$15.name,fieldValues$jscomp$15=field$jscomp$15.values;switch(fieldName$jscomp$15){case \"beginCap\":beginCap=fieldValues$jscomp$15[0];break;case \"ccw\":ccw$jscomp$1=fieldValues$jscomp$15[0];break;case \"convex\":break;case \"creaseAngle\":creaseAngle$jscomp$1=fieldValues$jscomp$15[0];break;case \"crossSection\":crossSection=fieldValues$jscomp$15;break;case \"endCap\":endCap=fieldValues$jscomp$15[0];break;\ncase \"orientation\":orientation=fieldValues$jscomp$15;break;case \"scale\":scale=fieldValues$jscomp$15;break;case \"solid\":solid$jscomp$1=fieldValues$jscomp$15[0];break;case \"spine\":spine=fieldValues$jscomp$15;break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$15)}}for(var crossSectionClosed=crossSection[0]===crossSection[crossSection.length-2]&&crossSection[1]===crossSection[crossSection.length-1],vertices$jscomp$0=[],spineVector=new _three.Vector3,scaling=new _three.Vector3,\naxis$jscomp$0=new _three.Vector3,vertex=new _three.Vector3,quaternion=new _three.Quaternion,_i13=0,j$jscomp$1=0,o=0,il=spine.length;_i13<il;_i13+=3,j$jscomp$1+=2,o+=4){spineVector.fromArray(spine,_i13);scaling.x=scale?scale[j$jscomp$1+0]:1;scaling.y=1;scaling.z=scale?scale[j$jscomp$1+1]:1;axis$jscomp$0.x=orientation?orientation[o+0]:0;axis$jscomp$0.y=orientation?orientation[o+1]:0;axis$jscomp$0.z=orientation?orientation[o+2]:1;for(var angle=orientation?orientation[o+3]:0,k$jscomp$0=0,kl=crossSection.length;k$jscomp$0<\nkl;k$jscomp$0+=2)vertex.x=crossSection[k$jscomp$0+0],vertex.y=0,vertex.z=crossSection[k$jscomp$0+1],vertex.multiply(scaling),quaternion.setFromAxisAngle(axis$jscomp$0,angle),vertex.applyQuaternion(quaternion),vertex.add(spineVector),vertices$jscomp$0.push(vertex.x,vertex.y,vertex.z)}for(var indices$jscomp$0=[],spineCount=spine.length/3,crossSectionCount=crossSection.length/2,_i14=0;_i14<spineCount-1;_i14++)for(var _j4=0;_j4<crossSectionCount-1;_j4++){var a$jscomp$0=_j4+_i14*crossSectionCount,b=_j4+\n1+_i14*crossSectionCount,c$jscomp$0=_j4+(_i14+1)*crossSectionCount,d$jscomp$0=_j4+1+(_i14+1)*crossSectionCount;_j4===crossSectionCount-2&&!0===crossSectionClosed&&(b=_i14*crossSectionCount,d$jscomp$0=(_i14+1)*crossSectionCount);!0===ccw$jscomp$1?(indices$jscomp$0.push(a$jscomp$0,b,c$jscomp$0),indices$jscomp$0.push(c$jscomp$0,b,d$jscomp$0)):(indices$jscomp$0.push(a$jscomp$0,c$jscomp$0,b),indices$jscomp$0.push(c$jscomp$0,d$jscomp$0,b))}if(!0===beginCap||!0===endCap){for(var contour=[],_i15=0,_l9=crossSection.length;_i15<\n_l9;_i15+=2)contour.push(new _three.Vector2(crossSection[_i15],crossSection[_i15+1]));for(var faces=_three.ShapeUtils.triangulateShape(contour,[]),capIndices=[],_i16=0,_l10=faces.length;_i16<_l10;_i16++){var face=faces[_i16];capIndices.push(face[0],face[1],face[2])}if(!0===beginCap)for(var _i17=0,_l11=capIndices.length;_i17<_l11;_i17+=3)!0===ccw$jscomp$1?indices$jscomp$0.push(capIndices[_i17+0],capIndices[_i17+1],capIndices[_i17+2]):indices$jscomp$0.push(capIndices[_i17+0],capIndices[_i17+2],capIndices[_i17+\n1]);if(!0===endCap)for(var indexOffset=crossSectionCount*(spineCount-1),_i18=0,_l12=capIndices.length;_i18<_l12;_i18+=3)!0===ccw$jscomp$1?indices$jscomp$0.push(indexOffset+capIndices[_i18+0],indexOffset+capIndices[_i18+2],indexOffset+capIndices[_i18+1]):indices$jscomp$0.push(indexOffset+capIndices[_i18+0],indexOffset+capIndices[_i18+1],indexOffset+capIndices[_i18+2])}var positionAttribute$jscomp$2=toNonIndexedAttribute(indices$jscomp$0,new _three.Float32BufferAttribute(vertices$jscomp$0,3)),normalAttribute$jscomp$1=\ncomputeNormalAttribute(indices$jscomp$0,vertices$jscomp$0,creaseAngle$jscomp$1),geometry$jscomp$4=new _three.BufferGeometry;geometry$jscomp$4.setAttribute(\"position\",positionAttribute$jscomp$2);geometry$jscomp$4.setAttribute(\"normal\",normalAttribute$jscomp$1);geometry$jscomp$4._solid=solid$jscomp$1;geometry$jscomp$4._type=\"mesh\";build$jscomp$0=geometry$jscomp$4;break;case \"Color\":case \"Coordinate\":case \"Normal\":case \"TextureCoordinate\":build$jscomp$0=node.fields[0].values;break;case \"WorldInfo\":for(var worldInfo=\n{},fields$jscomp$16=node.fields,i$jscomp$17=0,l$jscomp$17=fields$jscomp$16.length;i$jscomp$17<l$jscomp$17;i$jscomp$17++){var field$jscomp$16=fields$jscomp$16[i$jscomp$17],fieldName$jscomp$16=field$jscomp$16.name,fieldValues$jscomp$16=field$jscomp$16.values;switch(fieldName$jscomp$16){case \"title\":worldInfo.title=fieldValues$jscomp$16[0];break;case \"info\":worldInfo.info=fieldValues$jscomp$16;break;default:console.warn(\"THREE.VRMLLoader: Unknown field:\",fieldName$jscomp$16)}}build$jscomp$0=worldInfo;\nbreak;case \"Anchor\":case \"Billboard\":case \"Inline\":case \"LOD\":case \"Switch\":case \"AudioClip\":case \"DirectionalLight\":case \"PointLight\":case \"Script\":case \"Sound\":case \"SpotLight\":case \"CylinderSensor\":case \"PlaneSensor\":case \"ProximitySensor\":case \"SphereSensor\":case \"TimeSensor\":case \"TouchSensor\":case \"VisibilitySensor\":case \"Text\":case \"FontStyle\":case \"MovieTexture\":case \"ColorInterpolator\":case \"CoordinateInterpolator\":case \"NormalInterpolator\":case \"OrientationInterpolator\":case \"PositionInterpolator\":case \"ScalarInterpolator\":case \"Fog\":case \"NavigationInfo\":case \"Viewpoint\":break;\ndefault:console.warn(\"THREE.VRMLLoader: Unknown node:\",nodeName)}void 0!==build$jscomp$0&&void 0!==node.DEF&&!0===build$jscomp$0.hasOwnProperty(\"name\")&&(build$jscomp$0.name=node.DEF);node.build=build$jscomp$0;return node.build}function triangulateFaceIndex(index,ccw){for(var indices=[],start=0,i=0,l=index.length;i<l;i++)if(indices.push(index[start],index[i+(ccw?1:2)],index[i+(ccw?2:1)]),-1===index[i+3]||i+3>=l)i+=3,start=i+1;return indices}function triangulateFaceData(data,index){for(var triangulatedData=\n[],start=0,i=0,l=index.length;i<l;i++){var stride=3*start;triangulatedData.push(data[stride],data[stride+1],data[stride+2]);if(-1===index[i+3]||i+3>=l)i+=3,start++}return triangulatedData}function flattenData(data,index){for(var flattenData=[],i=0,l=index.length;i<l;i++){var stride=3*index[i];flattenData.push(data[stride],data[stride+1],data[stride+2])}return flattenData}function expandLineIndex(index){for(var indices=[],i=0,l=index.length;i<l;i++)if(indices.push(index[i],index[i+1]),-1===index[i+\n2]||i+2>=l)i+=2;return indices}function expandLineData(data,index){for(var triangulatedData=[],start=0,i=0,l=index.length;i<l;i++){var stride=3*start;triangulatedData.push(data[stride],data[stride+1],data[stride+2]);if(-1===index[i+2]||i+2>=l)i+=2,start++}return triangulatedData}function computeAttributeFromIndexedData(coordIndex,index,data,itemSize){var array=[],i=0;for(coordIndex=coordIndex.length;i<coordIndex;i+=3){var a=index[i],b=index[i+1],c=index[i+2];2===itemSize?(uvA.fromArray(data,a*itemSize),\nuvB.fromArray(data,b*itemSize),uvC.fromArray(data,c*itemSize),array.push(uvA.x,uvA.y),array.push(uvB.x,uvB.y),array.push(uvC.x,uvC.y)):(vA.fromArray(data,a*itemSize),vB.fromArray(data,b*itemSize),vC.fromArray(data,c*itemSize),array.push(vA.x,vA.y,vA.z),array.push(vB.x,vB.y,vB.z),array.push(vC.x,vC.y,vC.z))}return new _three.Float32BufferAttribute(array,itemSize)}function computeAttributeFromFaceData(index,faceData){var array=[],i=0,j=0;for(index=index.length;i<index;i+=3,j++)vA.fromArray(faceData,\n3*j),array.push(vA.x,vA.y,vA.z),array.push(vA.x,vA.y,vA.z),array.push(vA.x,vA.y,vA.z);return new _three.Float32BufferAttribute(array,3)}function computeAttributeFromLineData(index,lineData){var array=[],i=0,j=0;for(index=index.length;i<index;i+=2,j++)vA.fromArray(lineData,3*j),array.push(vA.x,vA.y,vA.z),array.push(vA.x,vA.y,vA.z);return new _three.Float32BufferAttribute(array,3)}function toNonIndexedAttribute(indices,attribute){var array=attribute.array;attribute=attribute.itemSize;for(var array2=\nnew array.constructor(indices.length*attribute),index,index2=0,i=0,l=indices.length;i<l;i++){index=indices[i]*attribute;for(var j=0;j<attribute;j++)array2[index2++]=array[index++]}return new _three.Float32BufferAttribute(array2,attribute)}function computeNormalAttribute(index,coord,creaseAngle){for(var faces=[],vertexNormals={},i=0,l=index.length;i<l;i+=3){var a=index[i],b=index[i+1],c=index[i+2],face=new Face$jscomp$0(a,b,c);vA.fromArray(coord,3*a);vB.fromArray(coord,3*b);vC.fromArray(coord,3*c);\ncb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);cb.normalize();face.normal.copy(cb);void 0===vertexNormals[a]&&(vertexNormals[a]=[]);void 0===vertexNormals[b]&&(vertexNormals[b]=[]);void 0===vertexNormals[c]&&(vertexNormals[c]=[]);vertexNormals[a].push(face.normal);vertexNormals[b].push(face.normal);vertexNormals[c].push(face.normal);faces.push(face)}index=[];i=0;for(l=faces.length;i<l;i++)a=faces[i],b=weightedNormal(vertexNormals[a.a],a.normal,creaseAngle),c=weightedNormal(vertexNormals[a.b],\na.normal,creaseAngle),face=weightedNormal(vertexNormals[a.c],a.normal,creaseAngle),vA.fromArray(coord,3*a.a),vB.fromArray(coord,3*a.b),vC.fromArray(coord,3*a.c),index.push(b.x,b.y,b.z),index.push(c.x,c.y,c.z),index.push(face.x,face.y,face.z);return new _three.Float32BufferAttribute(index,3)}function weightedNormal(normals,vector,creaseAngle){var normal=new _three.Vector3;if(0===creaseAngle)normal.copy(vector);else for(var i=0,l=normals.length;i<l;i++)normals[i].angleTo(vector)<creaseAngle&&normal.add(normals[i]);\nreturn normal.normalize()}function toColorArray(colors){for(var array=[],i=0,l=colors.length;i<l;i+=3)array.push(new _three.Color(colors[i],colors[i+1],colors[i+2]));return array}function paintFaces(geometry,radius,angles,colors,topDown){for(var thresholds=[],startAngle=!0===topDown?0:Math.PI,i=0,l=colors.length;i<l;i++){var angle=0===i?0:angles[i-1];angle=!0===topDown?angle:startAngle-angle;var point=new _three.Vector3;point.setFromSphericalCoords(radius,angle,0);thresholds.push(point)}radius=geometry.index;\nangles=geometry.attributes.position;startAngle=new _three.BufferAttribute(new Float32Array(3*geometry.attributes.position.count),3);i=new _three.Vector3;l=new _three.Color;for(angle=0;angle<radius.count;angle++){point=radius.getX(angle);i.fromBufferAttribute(angles,point);for(var thresholdIndexA=void 0,thresholdIndexB=void 0,t=1,j=1;j<thresholds.length;j++){thresholdIndexA=j-1;thresholdIndexB=j;var thresholdA=thresholds[thresholdIndexA],thresholdB=thresholds[thresholdIndexB];if(!0===topDown){if(i.y<=\nthresholdA.y&&i.y>thresholdB.y){t=Math.abs(thresholdA.y-i.y)/Math.abs(thresholdA.y-thresholdB.y);break}}else if(i.y>=thresholdA.y&&i.y<thresholdB.y){t=Math.abs(thresholdA.y-i.y)/Math.abs(thresholdA.y-thresholdB.y);break}}thresholdIndexB=colors[thresholdIndexB];l.copy(colors[thresholdIndexA]).lerp(thresholdIndexB,t);startAngle.setXYZ(point,l.r,l.g,l.b)}geometry.setAttribute(\"color\",startAngle)}var nodeMap={},vA=new _three.Vector3,vB=new _three.Vector3,vC=new _three.Vector3,uvA=new _three.Vector2,uvB=\nnew _three.Vector2,uvC=new _three.Vector2,ab=new _three.Vector3,cb=new _three.Vector3,textureLoader=new _three.TextureLoader(this.manager);textureLoader.setPath(this.resourcePath||path).setCrossOrigin(this.crossOrigin);if(-1===data$jscomp$0.indexOf(\"#VRML V2.0\"))throw Error(\"THREE.VRMLLexer: Version of VRML asset not supported.\");return function(tree){tree=tree.nodes;for(var scene=new _three.Scene,i=0,l=tree.length;i<l;i++)buildNodeMap(tree[i]);i=0;for(l=tree.length;i<l;i++){var _node=tree[i],object=\ngetNode(_node);object instanceof _three.Object3D&&scene.add(object);\"WorldInfo\"===_node.name&&(scene.userData.worldInfo=object)}return scene}(function(data){var RouteIdentifier=(0,_chevrotain.createToken)({name:\"RouteIdentifier\",pattern:/[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/}),Identifier=\n(0,_chevrotain.createToken)({name:\"Identifier\",pattern:/[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,longer_alt:RouteIdentifier}),Version=(0,_chevrotain.createToken)({name:\"Version\",pattern:/#VRML.*/,longer_alt:Identifier}),NodeName=(0,_chevrotain.createToken)({name:\"NodeName\",pattern:/Anchor|Billboard|Collision|Group|Transform|Inline|LOD|Switch|AudioClip|DirectionalLight|PointLight|Script|Shape|Sound|SpotLight|WorldInfo|CylinderSensor|PlaneSensor|ProximitySensor|SphereSensor|TimeSensor|TouchSensor|VisibilitySensor|Box|Cone|Cylinder|ElevationGrid|Extrusion|IndexedFaceSet|IndexedLineSet|PointSet|Sphere|Color|Coordinate|Normal|TextureCoordinate|Appearance|FontStyle|ImageTexture|Material|MovieTexture|PixelTexture|TextureTransform|ColorInterpolator|CoordinateInterpolator|NormalInterpolator|OrientationInterpolator|PositionInterpolator|ScalarInterpolator|Background|Fog|NavigationInfo|Viewpoint|Text/,\nlonger_alt:Identifier}),DEF=(0,_chevrotain.createToken)({name:\"DEF\",pattern:/DEF/,longer_alt:Identifier}),USE=(0,_chevrotain.createToken)({name:\"USE\",pattern:/USE/,longer_alt:Identifier}),ROUTE=(0,_chevrotain.createToken)({name:\"ROUTE\",pattern:/ROUTE/,longer_alt:Identifier}),TO=(0,_chevrotain.createToken)({name:\"TO\",pattern:/TO/,longer_alt:Identifier}),StringLiteral=(0,_chevrotain.createToken)({name:\"StringLiteral\",pattern:/\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/}),HexLiteral=(0,_chevrotain.createToken)({name:\"HexLiteral\",\npattern:/0[xX][0-9a-fA-F]+/}),NumberLiteral=(0,_chevrotain.createToken)({name:\"NumberLiteral\",pattern:/[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/}),TrueLiteral=(0,_chevrotain.createToken)({name:\"TrueLiteral\",pattern:/TRUE/}),FalseLiteral=(0,_chevrotain.createToken)({name:\"FalseLiteral\",pattern:/FALSE/}),NullLiteral=(0,_chevrotain.createToken)({name:\"NullLiteral\",pattern:/NULL/}),LSquare=(0,_chevrotain.createToken)({name:\"LSquare\",pattern:/\\[/}),RSquare=(0,_chevrotain.createToken)({name:\"RSquare\",pattern:/]/}),\nLCurly=(0,_chevrotain.createToken)({name:\"LCurly\",pattern:/{/}),RCurly=(0,_chevrotain.createToken)({name:\"RCurly\",pattern:/}/}),Comment=(0,_chevrotain.createToken)({name:\"Comment\",pattern:/#.*/,group:_chevrotain.Lexer.SKIPPED});Identifier=[(0,_chevrotain.createToken)({name:\"WhiteSpace\",pattern:/[ ,\\s]/,group:_chevrotain.Lexer.SKIPPED}),NodeName,DEF,USE,ROUTE,TO,TrueLiteral,FalseLiteral,NullLiteral,Version,Identifier,RouteIdentifier,StringLiteral,HexLiteral,NumberLiteral,LSquare,RSquare,LCurly,RCurly,\nComment];RouteIdentifier={};Version=0;for(NodeName=Identifier.length;Version<NodeName;Version++)DEF=Identifier[Version],RouteIdentifier[DEF.name]=DEF;Version=new VRMLLexer(Identifier);RouteIdentifier=new VRMLParser(RouteIdentifier);Identifier=createVisitor(RouteIdentifier.getBaseCstVisitorConstructor());data=Version.lex(data);RouteIdentifier.input=data.tokens;data=RouteIdentifier.vrml();if(0<RouteIdentifier.errors.length)throw console.error(RouteIdentifier.errors),Error(\"THREE.VRMLLoader: Parsing errors detected.\");\nreturn Identifier.visit(data)}(data$jscomp$0))}}]);return VRMLLoader}(_three.Loader);exports.VRMLLoader=global;var VRMLLexer=function(){function VRMLLexer(tokens){_classCallCheck(this,VRMLLexer);this.lexer=new _chevrotain.Lexer(tokens)}_createClass(VRMLLexer,[{key:\"lex\",value:function(inputText){inputText=this.lexer.tokenize(inputText);if(0<inputText.errors.length)throw console.error(inputText.errors),Error(\"THREE.VRMLLexer: Lexing errors detected.\");return inputText}}]);return VRMLLexer}(),VRMLParser=\nfunction(_CstParser){function VRMLParser(tokenVocabulary){_classCallCheck(this,VRMLParser);var _this=_possibleConstructorReturn(this,_getPrototypeOf(VRMLParser).call(this,tokenVocabulary));var $=_assertThisInitialized(_this),Version=tokenVocabulary.Version,LCurly=tokenVocabulary.LCurly,RCurly=tokenVocabulary.RCurly,LSquare=tokenVocabulary.LSquare,RSquare=tokenVocabulary.RSquare,Identifier=tokenVocabulary.Identifier,RouteIdentifier=tokenVocabulary.RouteIdentifier,StringLiteral=tokenVocabulary.StringLiteral,\nHexLiteral=tokenVocabulary.HexLiteral,NumberLiteral=tokenVocabulary.NumberLiteral,TrueLiteral=tokenVocabulary.TrueLiteral,FalseLiteral=tokenVocabulary.FalseLiteral,NullLiteral=tokenVocabulary.NullLiteral,DEF=tokenVocabulary.DEF,USE=tokenVocabulary.USE,ROUTE=tokenVocabulary.ROUTE,TO=tokenVocabulary.TO,NodeName=tokenVocabulary.NodeName;$.RULE(\"vrml\",function(){$.SUBRULE($.version);$.AT_LEAST_ONE(function(){$.SUBRULE($.node)});$.MANY(function(){$.SUBRULE($.route)})});$.RULE(\"version\",function(){$.CONSUME(Version)});\n$.RULE(\"node\",function(){$.OPTION(function(){$.SUBRULE($.def)});$.CONSUME(NodeName);$.CONSUME(LCurly);$.MANY(function(){$.SUBRULE($.field)});$.CONSUME(RCurly)});$.RULE(\"field\",function(){$.CONSUME(Identifier);$.OR2([{ALT:function(){$.SUBRULE($.singleFieldValue)}},{ALT:function(){$.SUBRULE($.multiFieldValue)}}])});$.RULE(\"def\",function(){$.CONSUME(DEF);$.OR([{ALT:function(){$.CONSUME(Identifier)}},{ALT:function(){$.CONSUME(NodeName)}}])});$.RULE(\"use\",function(){$.CONSUME(USE);$.OR([{ALT:function(){$.CONSUME(Identifier)}},\n{ALT:function(){$.CONSUME(NodeName)}}])});$.RULE(\"singleFieldValue\",function(){$.AT_LEAST_ONE(function(){$.OR([{ALT:function(){$.SUBRULE($.node)}},{ALT:function(){$.SUBRULE($.use)}},{ALT:function(){$.CONSUME(StringLiteral)}},{ALT:function(){$.CONSUME(HexLiteral)}},{ALT:function(){$.CONSUME(NumberLiteral)}},{ALT:function(){$.CONSUME(TrueLiteral)}},{ALT:function(){$.CONSUME(FalseLiteral)}},{ALT:function(){$.CONSUME(NullLiteral)}}])})});$.RULE(\"multiFieldValue\",function(){$.CONSUME(LSquare);$.MANY(function(){$.OR([{ALT:function(){$.SUBRULE($.node)}},\n{ALT:function(){$.SUBRULE($.use)}},{ALT:function(){$.CONSUME(StringLiteral)}},{ALT:function(){$.CONSUME(HexLiteral)}},{ALT:function(){$.CONSUME(NumberLiteral)}},{ALT:function(){$.CONSUME(NullLiteral)}}])});$.CONSUME(RSquare)});$.RULE(\"route\",function(){$.CONSUME(ROUTE);$.CONSUME(RouteIdentifier);$.CONSUME(TO);$.CONSUME2(RouteIdentifier)});_this.performSelfAnalysis();return _this}_inherits(VRMLParser,_CstParser);return VRMLParser}(_chevrotain.CstParser),Face$jscomp$0=function Face(a,b,c){_classCallCheck(this,\nFace);this.a=a;this.b=b;this.c=c;this.normal=new _three.Vector3},TEXTURE_TYPE={INTENSITY:1,INTENSITY_ALPHA:2,RGB:3,RGBA:4}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$VRMLLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VRMLLoader = void 0;\n\nvar _three = require(\"three\");\n\nvar _chevrotain = require(\"chevrotain\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar VRMLLoader =\n/*#__PURE__*/\nfunction (_Loader) {\n  _inherits(VRMLLoader, _Loader);\n\n  function VRMLLoader(manager) {\n    _classCallCheck(this, VRMLLoader);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(VRMLLoader).call(this, manager));\n  }\n\n  _createClass(VRMLLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? _three.LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new _three.FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, path) {\n      var nodeMap = {};\n\n      function generateVRMLTree(data) {\n        // create lexer, parser and visitor\n        var tokenData = createTokens();\n        var lexer = new VRMLLexer(tokenData.tokens);\n        var parser = new VRMLParser(tokenData.tokenVocabulary);\n        var visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\n\n        var lexingResult = lexer.lex(data);\n        parser.input = lexingResult.tokens; // parsing\n\n        var cstOutput = parser.vrml();\n\n        if (parser.errors.length > 0) {\n          console.error(parser.errors);\n          throw Error('THREE.VRMLLoader: Parsing errors detected.');\n        } // actions\n\n\n        var ast = visitor.visit(cstOutput);\n        return ast;\n      }\n\n      function createTokens() {\n        // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n        var RouteIdentifier = (0, _chevrotain.createToken)({\n          name: 'RouteIdentifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n        });\n        var Identifier = (0, _chevrotain.createToken)({\n          name: 'Identifier',\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n          longer_alt: RouteIdentifier\n        }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n        var nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n        'Inline', 'LOD', 'Switch', // special groups\n        'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n        'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n        'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n        'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n        'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n        'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n        'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n        'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n        ]; //\n\n        var Version = (0, _chevrotain.createToken)({\n          name: 'Version',\n          pattern: /#VRML.*/,\n          longer_alt: Identifier\n        });\n        var NodeName = (0, _chevrotain.createToken)({\n          name: 'NodeName',\n          pattern: new RegExp(nodeTypes.join('|')),\n          longer_alt: Identifier\n        });\n        var DEF = (0, _chevrotain.createToken)({\n          name: 'DEF',\n          pattern: /DEF/,\n          longer_alt: Identifier\n        });\n        var USE = (0, _chevrotain.createToken)({\n          name: 'USE',\n          pattern: /USE/,\n          longer_alt: Identifier\n        });\n        var ROUTE = (0, _chevrotain.createToken)({\n          name: 'ROUTE',\n          pattern: /ROUTE/,\n          longer_alt: Identifier\n        });\n        var TO = (0, _chevrotain.createToken)({\n          name: 'TO',\n          pattern: /TO/,\n          longer_alt: Identifier\n        }); //\n\n        var StringLiteral = (0, _chevrotain.createToken)({\n          name: 'StringLiteral',\n          pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/\n        });\n        var HexLiteral = (0, _chevrotain.createToken)({\n          name: 'HexLiteral',\n          pattern: /0[xX][0-9a-fA-F]+/\n        });\n        var NumberLiteral = (0, _chevrotain.createToken)({\n          name: 'NumberLiteral',\n          pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n        });\n        var TrueLiteral = (0, _chevrotain.createToken)({\n          name: 'TrueLiteral',\n          pattern: /TRUE/\n        });\n        var FalseLiteral = (0, _chevrotain.createToken)({\n          name: 'FalseLiteral',\n          pattern: /FALSE/\n        });\n        var NullLiteral = (0, _chevrotain.createToken)({\n          name: 'NullLiteral',\n          pattern: /NULL/\n        });\n        var LSquare = (0, _chevrotain.createToken)({\n          name: 'LSquare',\n          pattern: /\\[/\n        });\n        var RSquare = (0, _chevrotain.createToken)({\n          name: 'RSquare',\n          pattern: /]/\n        });\n        var LCurly = (0, _chevrotain.createToken)({\n          name: 'LCurly',\n          pattern: /{/\n        });\n        var RCurly = (0, _chevrotain.createToken)({\n          name: 'RCurly',\n          pattern: /}/\n        });\n        var Comment = (0, _chevrotain.createToken)({\n          name: 'Comment',\n          pattern: /#.*/,\n          group: _chevrotain.Lexer.SKIPPED // eslint-disable-line no-undef\n\n        }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n        var WhiteSpace = (0, _chevrotain.createToken)({\n          name: 'WhiteSpace',\n          pattern: /[ ,\\s]/,\n          group: _chevrotain.Lexer.SKIPPED // eslint-disable-line no-undef\n\n        });\n        var tokens = [WhiteSpace, // keywords appear before the Identifier\n        NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral, // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n        var tokenVocabulary = {};\n\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n          tokenVocabulary[token.name] = token;\n        }\n\n        return {\n          tokens: tokens,\n          tokenVocabulary: tokenVocabulary\n        };\n      }\n\n      function createVisitor(BaseVRMLVisitor) {\n        // the visitor is created dynmaically based on the given base class\n        function VRMLToASTVisitor() {\n          BaseVRMLVisitor.call(this);\n          this.validateVisitor();\n        }\n\n        VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n          constructor: VRMLToASTVisitor,\n          vrml: function vrml(ctx) {\n            var data = {\n              version: this.visit(ctx.version),\n              nodes: [],\n              routes: []\n            };\n\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              data.nodes.push(this.visit(node));\n            }\n\n            if (ctx.route) {\n              for (var _i = 0, _l = ctx.route.length; _i < _l; _i++) {\n                var route = ctx.route[_i];\n                data.routes.push(this.visit(route));\n              }\n            }\n\n            return data;\n          },\n          version: function version(ctx) {\n            return ctx.Version[0].image;\n          },\n          node: function node(ctx) {\n            var data = {\n              name: ctx.NodeName[0].image,\n              fields: []\n            };\n\n            if (ctx.field) {\n              for (var i = 0, l = ctx.field.length; i < l; i++) {\n                var field = ctx.field[i];\n                data.fields.push(this.visit(field));\n              }\n            } // DEF\n\n\n            if (ctx.def) {\n              data.DEF = this.visit(ctx.def[0]);\n            }\n\n            return data;\n          },\n          field: function field(ctx) {\n            var data = {\n              name: ctx.Identifier[0].image,\n              type: null,\n              values: null\n            };\n            var result; // SFValue\n\n            if (ctx.singleFieldValue) {\n              result = this.visit(ctx.singleFieldValue[0]);\n            } // MFValue\n\n\n            if (ctx.multiFieldValue) {\n              result = this.visit(ctx.multiFieldValue[0]);\n            }\n\n            data.type = result.type;\n            data.values = result.values;\n            return data;\n          },\n          def: function def(ctx) {\n            return (ctx.Identifier || ctx.NodeName)[0].image;\n          },\n          use: function use(ctx) {\n            return {\n              USE: (ctx.Identifier || ctx.NodeName)[0].image\n            };\n          },\n          singleFieldValue: function singleFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          multiFieldValue: function multiFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          route: function route(ctx) {\n            var data = {\n              FROM: ctx.RouteIdentifier[0].image,\n              TO: ctx.RouteIdentifier[1].image\n            };\n            return data;\n          }\n        });\n\n        function processField(scope, ctx) {\n          var field = {\n            type: null,\n            values: []\n          };\n\n          if (ctx.node) {\n            field.type = 'node';\n\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              field.values.push(scope.visit(node));\n            }\n          }\n\n          if (ctx.use) {\n            field.type = 'use';\n\n            for (var _i2 = 0, _l2 = ctx.use.length; _i2 < _l2; _i2++) {\n              var use = ctx.use[_i2];\n              field.values.push(scope.visit(use));\n            }\n          }\n\n          if (ctx.StringLiteral) {\n            field.type = 'string';\n\n            for (var _i3 = 0, _l3 = ctx.StringLiteral.length; _i3 < _l3; _i3++) {\n              var stringLiteral = ctx.StringLiteral[_i3];\n              field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n            }\n          }\n\n          if (ctx.NumberLiteral) {\n            field.type = 'number';\n\n            for (var _i4 = 0, _l4 = ctx.NumberLiteral.length; _i4 < _l4; _i4++) {\n              var numberLiteral = ctx.NumberLiteral[_i4];\n              field.values.push(parseFloat(numberLiteral.image));\n            }\n          }\n\n          if (ctx.HexLiteral) {\n            field.type = 'hex';\n\n            for (var _i5 = 0, _l5 = ctx.HexLiteral.length; _i5 < _l5; _i5++) {\n              var hexLiteral = ctx.HexLiteral[_i5];\n              field.values.push(hexLiteral.image);\n            }\n          }\n\n          if (ctx.TrueLiteral) {\n            field.type = 'boolean';\n\n            for (var _i6 = 0, _l6 = ctx.TrueLiteral.length; _i6 < _l6; _i6++) {\n              var trueLiteral = ctx.TrueLiteral[_i6];\n              if (trueLiteral.image === 'TRUE') field.values.push(true);\n            }\n          }\n\n          if (ctx.FalseLiteral) {\n            field.type = 'boolean';\n\n            for (var _i7 = 0, _l7 = ctx.FalseLiteral.length; _i7 < _l7; _i7++) {\n              var falseLiteral = ctx.FalseLiteral[_i7];\n              if (falseLiteral.image === 'FALSE') field.values.push(false);\n            }\n          }\n\n          if (ctx.NullLiteral) {\n            field.type = 'null';\n            ctx.NullLiteral.forEach(function () {\n              field.values.push(null);\n            });\n          }\n\n          return field;\n        }\n\n        return new VRMLToASTVisitor();\n      }\n\n      function parseTree(tree) {\n        // console.log( JSON.stringify( tree, null, 2 ) );\n        var nodes = tree.nodes;\n        var scene = new _three.Scene(); // first iteration: build nodemap based on DEF statements\n\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          buildNodeMap(node);\n        } // second iteration: build nodes\n\n\n        for (var _i8 = 0, _l8 = nodes.length; _i8 < _l8; _i8++) {\n          var _node = nodes[_i8];\n          var object = getNode(_node);\n          if (object instanceof _three.Object3D) scene.add(object);\n          if (_node.name === 'WorldInfo') scene.userData.worldInfo = object;\n        }\n\n        return scene;\n      }\n\n      function buildNodeMap(node) {\n        if (node.DEF) {\n          nodeMap[node.DEF] = node;\n        }\n\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n\n          if (field.type === 'node') {\n            var fieldValues = field.values;\n\n            for (var j = 0, jl = fieldValues.length; j < jl; j++) {\n              buildNodeMap(fieldValues[j]);\n            }\n          }\n        }\n      }\n\n      function getNode(node) {\n        // handle case where a node refers to a different one\n        if (node.USE) {\n          return resolveUSE(node.USE);\n        }\n\n        if (node.build !== undefined) return node.build;\n        node.build = buildNode(node);\n        return node.build;\n      } // node builder\n\n\n      function buildNode(node) {\n        var nodeName = node.name;\n        var build;\n\n        switch (nodeName) {\n          case 'Group':\n          case 'Transform':\n          case 'Collision':\n            build = buildGroupingNode(node);\n            break;\n\n          case 'Background':\n            build = buildBackgroundNode(node);\n            break;\n\n          case 'Shape':\n            build = buildShapeNode(node);\n            break;\n\n          case 'Appearance':\n            build = buildAppearanceNode(node);\n            break;\n\n          case 'Material':\n            build = buildMaterialNode(node);\n            break;\n\n          case 'ImageTexture':\n            build = buildImageTextureNode(node);\n            break;\n\n          case 'PixelTexture':\n            build = buildPixelTextureNode(node);\n            break;\n\n          case 'TextureTransform':\n            build = buildTextureTransformNode(node);\n            break;\n\n          case 'IndexedFaceSet':\n            build = buildIndexedFaceSetNode(node);\n            break;\n\n          case 'IndexedLineSet':\n            build = buildIndexedLineSetNode(node);\n            break;\n\n          case 'PointSet':\n            build = buildPointSetNode(node);\n            break;\n\n          case 'Box':\n            build = buildBoxNode(node);\n            break;\n\n          case 'Cone':\n            build = buildConeNode(node);\n            break;\n\n          case 'Cylinder':\n            build = buildCylinderNode(node);\n            break;\n\n          case 'Sphere':\n            build = buildSphereNode(node);\n            break;\n\n          case 'ElevationGrid':\n            build = buildElevationGridNode(node);\n            break;\n\n          case 'Extrusion':\n            build = buildExtrusionNode(node);\n            break;\n\n          case 'Color':\n          case 'Coordinate':\n          case 'Normal':\n          case 'TextureCoordinate':\n            build = buildGeometricNode(node);\n            break;\n\n          case 'WorldInfo':\n            build = buildWorldInfoNode(node);\n            break;\n\n          case 'Anchor':\n          case 'Billboard':\n          case 'Inline':\n          case 'LOD':\n          case 'Switch':\n          case 'AudioClip':\n          case 'DirectionalLight':\n          case 'PointLight':\n          case 'Script':\n          case 'Sound':\n          case 'SpotLight':\n          case 'CylinderSensor':\n          case 'PlaneSensor':\n          case 'ProximitySensor':\n          case 'SphereSensor':\n          case 'TimeSensor':\n          case 'TouchSensor':\n          case 'VisibilitySensor':\n          case 'Text':\n          case 'FontStyle':\n          case 'MovieTexture':\n          case 'ColorInterpolator':\n          case 'CoordinateInterpolator':\n          case 'NormalInterpolator':\n          case 'OrientationInterpolator':\n          case 'PositionInterpolator':\n          case 'ScalarInterpolator':\n          case 'Fog':\n          case 'NavigationInfo':\n          case 'Viewpoint':\n            // node not supported yet\n            break;\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n            break;\n        }\n\n        if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n          build.name = node.DEF;\n        }\n\n        return build;\n      }\n\n      function buildGroupingNode(node) {\n        var object = new _three.Group(); //\n\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bboxCenter':\n              // field not supported\n              break;\n\n            case 'bboxSize':\n              // field not supported\n              break;\n\n            case 'center':\n              // field not supported\n              break;\n\n            case 'children':\n              parseFieldChildren(fieldValues, object);\n              break;\n\n            case 'collide':\n              // field not supported\n              break;\n\n            case 'rotation':\n              var axis = new _three.Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n              var angle = fieldValues[3];\n              object.quaternion.setFromAxisAngle(axis, angle);\n              break;\n\n            case 'scale':\n              object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'scaleOrientation':\n              // field not supported\n              break;\n\n            case 'translation':\n              object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'proxy':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return object;\n      }\n\n      function buildBackgroundNode(node) {\n        var group = new _three.Group();\n        var groundAngle, groundColor;\n        var skyAngle, skyColor;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'groundAngle':\n              groundAngle = fieldValues;\n              break;\n\n            case 'groundColor':\n              groundColor = fieldValues;\n              break;\n\n            case 'backUrl':\n              // field not supported\n              break;\n\n            case 'bottomUrl':\n              // field not supported\n              break;\n\n            case 'frontUrl':\n              // field not supported\n              break;\n\n            case 'leftUrl':\n              // field not supported\n              break;\n\n            case 'rightUrl':\n              // field not supported\n              break;\n\n            case 'topUrl':\n              // field not supported\n              break;\n\n            case 'skyAngle':\n              skyAngle = fieldValues;\n              break;\n\n            case 'skyColor':\n              skyColor = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var radius = 10000; // sky\n\n        if (skyColor) {\n          var skyGeometry = new _three.SphereGeometry(radius, 32, 16);\n          var skyMaterial = new _three.MeshBasicMaterial({\n            fog: false,\n            side: _three.BackSide,\n            depthWrite: false,\n            depthTest: false\n          });\n\n          if (skyColor.length > 3) {\n            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n            skyMaterial.vertexColors = true;\n          } else {\n            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n          }\n\n          var sky = new _three.Mesh(skyGeometry, skyMaterial);\n          group.add(sky);\n        } // ground\n\n\n        if (groundColor) {\n          if (groundColor.length > 0) {\n            var groundGeometry = new _three.SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n            var groundMaterial = new _three.MeshBasicMaterial({\n              fog: false,\n              side: _three.BackSide,\n              vertexColors: true,\n              depthWrite: false,\n              depthTest: false\n            });\n            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n            var ground = new _three.Mesh(groundGeometry, groundMaterial);\n            group.add(ground);\n          }\n        } // render background group first\n\n\n        group.renderOrder = -Infinity;\n        return group;\n      }\n\n      function buildShapeNode(node) {\n        var fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n        var material = new _three.MeshBasicMaterial({\n          color: 0x000000\n        });\n        var geometry;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'appearance':\n              if (fieldValues[0] !== null) {\n                material = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            case 'geometry':\n              if (fieldValues[0] !== null) {\n                geometry = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build 3D object\n\n\n        var object;\n\n        if (geometry && geometry.attributes.position) {\n          var type = geometry._type;\n\n          if (type === 'points') {\n            // points\n            var pointsMaterial = new _three.PointsMaterial({\n              color: 0xffffff\n            });\n\n            if (geometry.attributes.color !== undefined) {\n              pointsMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n              if (material.isMeshPhongMaterial) {\n                pointsMaterial.color.copy(material.emissive);\n              }\n            }\n\n            object = new _three.Points(geometry, pointsMaterial);\n          } else if (type === 'line') {\n            // lines\n            var lineMaterial = new _three.LineBasicMaterial({\n              color: 0xffffff\n            });\n\n            if (geometry.attributes.color !== undefined) {\n              lineMaterial.vertexColors = true;\n            } else {\n              // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n              if (material.isMeshPhongMaterial) {\n                lineMaterial.color.copy(material.emissive);\n              }\n            }\n\n            object = new _three.LineSegments(geometry, lineMaterial);\n          } else {\n            // consider meshes\n            // check \"solid\" hint (it's placed in the geometry but affects the material)\n            if (geometry._solid !== undefined) {\n              material.side = geometry._solid ? _three.FrontSide : _three.DoubleSide;\n            } // check for vertex colors\n\n\n            if (geometry.attributes.color !== undefined) {\n              material.vertexColors = true;\n            }\n\n            object = new _three.Mesh(geometry, material);\n          }\n        } else {\n          object = new _three.Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n          object.visible = false;\n        }\n\n        return object;\n      }\n\n      function buildAppearanceNode(node) {\n        var material = new _three.MeshPhongMaterial();\n        var transformData;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'material':\n              if (fieldValues[0] !== null) {\n                var materialData = getNode(fieldValues[0]);\n                if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n                if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n                if (materialData.shininess) material.shininess = materialData.shininess;\n                if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n                if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n                if (materialData.transparency > 0) material.transparent = true;\n              } else {\n                // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n                material = new _three.MeshBasicMaterial({\n                  color: 0x000000\n                });\n              }\n\n              break;\n\n            case 'texture':\n              var textureNode = fieldValues[0];\n\n              if (textureNode !== null) {\n                if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                  material.map = getNode(textureNode);\n                }\n              }\n\n              break;\n\n            case 'textureTransform':\n              if (fieldValues[0] !== null) {\n                transformData = getNode(fieldValues[0]);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // only apply texture transform data if a texture was defined\n\n\n        if (material.map) {\n          // respect VRML lighting model\n          if (material.map.__type) {\n            switch (material.map.__type) {\n              case TEXTURE_TYPE.INTENSITY_ALPHA:\n                material.opacity = 1; // ignore transparency\n\n                break;\n\n              case TEXTURE_TYPE.RGB:\n                material.color.set(0xffffff); // ignore material color\n\n                break;\n\n              case TEXTURE_TYPE.RGBA:\n                material.color.set(0xffffff); // ignore material color\n\n                material.opacity = 1; // ignore transparency\n\n                break;\n            }\n\n            delete material.map.__type;\n          } // apply texture transform\n\n\n          if (transformData) {\n            material.map.center.copy(transformData.center);\n            material.map.rotation = transformData.rotation;\n            material.map.repeat.copy(transformData.scale);\n            material.map.offset.copy(transformData.translation);\n          }\n        }\n\n        return material;\n      }\n\n      function buildMaterialNode(node) {\n        var materialData = {};\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'ambientIntensity':\n              // field not supported\n              break;\n\n            case 'diffuseColor':\n              materialData.diffuseColor = new _three.Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'emissiveColor':\n              materialData.emissiveColor = new _three.Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'shininess':\n              materialData.shininess = fieldValues[0];\n              break;\n\n            case 'specularColor':\n              materialData.emissiveColor = new _three.Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n\n            case 'transparency':\n              materialData.transparency = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return materialData;\n      }\n\n      function parseHexColor(hex, textureType, color) {\n        var value;\n\n        switch (textureType) {\n          case TEXTURE_TYPE.INTENSITY:\n            // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n            value = parseInt(hex);\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            break;\n\n          case TEXTURE_TYPE.INTENSITY_ALPHA:\n            // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n            value = parseInt('0x' + hex.substring(2, 4));\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = parseInt('0x' + hex.substring(4, 6));\n            break;\n\n          case TEXTURE_TYPE.RGB:\n            // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            break;\n\n          case TEXTURE_TYPE.RGBA:\n            // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n            color.r = parseInt('0x' + hex.substring(2, 4));\n            color.g = parseInt('0x' + hex.substring(4, 6));\n            color.b = parseInt('0x' + hex.substring(6, 8));\n            color.a = parseInt('0x' + hex.substring(8, 10));\n            break;\n        }\n      }\n\n      function getTextureType(num_components) {\n        var type;\n\n        switch (num_components) {\n          case 1:\n            type = TEXTURE_TYPE.INTENSITY;\n            break;\n\n          case 2:\n            type = TEXTURE_TYPE.INTENSITY_ALPHA;\n            break;\n\n          case 3:\n            type = TEXTURE_TYPE.RGB;\n            break;\n\n          case 4:\n            type = TEXTURE_TYPE.RGBA;\n            break;\n        }\n\n        return type;\n      }\n\n      function buildPixelTextureNode(node) {\n        var texture;\n        var wrapS = _three.RepeatWrapping;\n        var wrapT = _three.RepeatWrapping;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'image':\n              var width = fieldValues[0];\n              var height = fieldValues[1];\n              var num_components = fieldValues[2];\n              var useAlpha = num_components === 2 || num_components === 4;\n              var textureType = getTextureType(num_components);\n              var size = (useAlpha === true ? 4 : 3) * (width * height);\n\n              var _data = new Uint8Array(size);\n\n              var color = {\n                r: 0,\n                g: 0,\n                b: 0,\n                a: 0\n              };\n\n              for (var j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n                parseHexColor(fieldValues[j], textureType, color);\n\n                if (useAlpha === true) {\n                  var stride = k * 4;\n                  _data[stride + 0] = color.r;\n                  _data[stride + 1] = color.g;\n                  _data[stride + 2] = color.b;\n                  _data[stride + 3] = color.a;\n                } else {\n                  var _stride = k * 3;\n\n                  _data[_stride + 0] = color.r;\n                  _data[_stride + 1] = color.g;\n                  _data[_stride + 2] = color.b;\n                }\n              }\n\n              texture = new _three.DataTexture(_data, width, height, useAlpha === true ? _three.RGBAFormat : _three.RGBFormat);\n              texture.__type = textureType; // needed for material modifications\n\n              break;\n\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = _three.ClampToEdgeWrapping;\n              break;\n\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = _three.ClampToEdgeWrapping;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n\n        return texture;\n      }\n\n      function buildImageTextureNode(node) {\n        var texture;\n        var wrapS = _three.RepeatWrapping;\n        var wrapT = _three.RepeatWrapping;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'url':\n              var url = fieldValues[0];\n              if (url) texture = textureLoader.load(url);\n              break;\n\n            case 'repeatS':\n              if (fieldValues[0] === false) wrapS = _three.ClampToEdgeWrapping;\n              break;\n\n            case 'repeatT':\n              if (fieldValues[0] === false) wrapT = _three.ClampToEdgeWrapping;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n\n        return texture;\n      }\n\n      function buildTextureTransformNode(node) {\n        var transformData = {\n          center: new _three.Vector2(),\n          rotation: new _three.Vector2(),\n          scale: new _three.Vector2(),\n          translation: new _three.Vector2()\n        };\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'center':\n              transformData.center.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            case 'rotation':\n              transformData.rotation = fieldValues[0];\n              break;\n\n            case 'scale':\n              transformData.scale.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            case 'translation':\n              transformData.translation.set(fieldValues[0], fieldValues[1]);\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return transformData;\n      }\n\n      function buildGeometricNode(node) {\n        return node.fields[0].values;\n      }\n\n      function buildWorldInfoNode(node) {\n        var worldInfo = {};\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'title':\n              worldInfo.title = fieldValues[0];\n              break;\n\n            case 'info':\n              worldInfo.info = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        return worldInfo;\n      }\n\n      function buildIndexedFaceSetNode(node) {\n        var color, coord, normal, texCoord;\n        var ccw = true,\n            solid = true,\n            creaseAngle = 0;\n        var colorIndex, coordIndex, normalIndex, texCoordIndex;\n        var colorPerVertex = true,\n            normalPerVertex = true;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            case 'normal':\n              var normalNode = fieldValues[0];\n\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n\n              break;\n\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'convex':\n              // field not supported\n              break;\n\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'normalIndex':\n              normalIndex = fieldValues;\n              break;\n\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'texCoordIndex':\n              texCoordIndex = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        if (coordIndex === undefined) {\n          console.warn('THREE.VRMLLoader: Missing coordIndex.');\n          return new _three.BufferGeometry(); // handle VRML files with incomplete geometry definition\n        }\n\n        var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n        var colorAttribute;\n        var normalAttribute;\n        var uvAttribute;\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n              var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n              colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new _three.Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex && colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n              var flattenFaceColors = flattenData(color, colorIndex);\n              var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            } else {\n              // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n              var _triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceColors);\n            }\n          }\n        }\n\n        if (normal) {\n          if (normalPerVertex === true) {\n            // consider vertex normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n              var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n              normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n            } else {\n              // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n              normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new _three.Float32BufferAttribute(normal, 3));\n            }\n          } else {\n            // consider face normals\n            if (normalIndex && normalIndex.length > 0) {\n              // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n              var flattenFaceNormals = flattenData(normal, normalIndex);\n              var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            } else {\n              // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n              var _triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceNormals);\n            }\n          }\n        } else {\n          // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n          normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n        }\n\n        if (texCoord) {\n          // texture coordinates are always defined on vertex level\n          if (texCoordIndex && texCoordIndex.length > 0) {\n            // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n          } else {\n            // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new _three.Float32BufferAttribute(texCoord, 2));\n          }\n        }\n\n        var geometry = new _three.BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new _three.Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // optional attributes\n\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n\n      function buildIndexedLineSetNode(node) {\n        var color, coord;\n        var colorIndex, coordIndex;\n        var colorPerVertex = true;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            case 'colorIndex':\n              colorIndex = fieldValues;\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'coordIndex':\n              coordIndex = fieldValues;\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // build lines\n\n\n        var colorAttribute;\n        var expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\n\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n              var expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n              colorAttribute = toNonIndexedAttribute(expandedLineIndex, new _three.Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex.length > 0) {\n              // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n              var flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\n\n              var expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\n            } else {\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n              var _expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\n\n\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, _expandedLineColors); // compute data on vertex level\n            }\n          }\n        } //\n\n\n        var geometry = new _three.BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new _three.Float32BufferAttribute(coord, 3));\n        geometry.setAttribute('position', positionAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\n        geometry._type = 'line';\n        return geometry;\n      }\n\n      function buildPointSetNode(node) {\n        var color, coord;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'coord':\n              var coordNode = fieldValues[0];\n\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new _three.BufferGeometry();\n        geometry.setAttribute('position', new _three.Float32BufferAttribute(coord, 3));\n        if (color) geometry.setAttribute('color', new _three.Float32BufferAttribute(color, 3));\n        geometry._type = 'points';\n        return geometry;\n      }\n\n      function buildBoxNode(node) {\n        var size = new _three.Vector3(2, 2, 2);\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'size':\n              size.x = fieldValues[0];\n              size.y = fieldValues[1];\n              size.z = fieldValues[2];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new _three.BoxGeometry(size.x, size.y, size.z);\n        return geometry;\n      }\n\n      function buildConeNode(node) {\n        var radius = 1,\n            height = 2,\n            openEnded = false;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bottom':\n              openEnded = !fieldValues[0];\n              break;\n\n            case 'bottomRadius':\n              radius = fieldValues[0];\n              break;\n\n            case 'height':\n              height = fieldValues[0];\n              break;\n\n            case 'side':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new _three.ConeGeometry(radius, height, 16, 1, openEnded);\n        return geometry;\n      }\n\n      function buildCylinderNode(node) {\n        var radius = 1,\n            height = 2;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'bottom':\n              // field not supported\n              break;\n\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n\n            case 'height':\n              height = fieldValues[0];\n              break;\n\n            case 'side':\n              // field not supported\n              break;\n\n            case 'top':\n              // field not supported\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new _three.CylinderGeometry(radius, radius, height, 16, 1);\n        return geometry;\n      }\n\n      function buildSphereNode(node) {\n        var radius = 1;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'radius':\n              radius = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var geometry = new _three.SphereGeometry(radius, 16, 16);\n        return geometry;\n      }\n\n      function buildElevationGridNode(node) {\n        var color;\n        var normal;\n        var texCoord;\n        var height;\n        var colorPerVertex = true;\n        var normalPerVertex = true;\n        var solid = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var xDimension = 2;\n        var zDimension = 2;\n        var xSpacing = 1;\n        var zSpacing = 1;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'color':\n              var colorNode = fieldValues[0];\n\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n\n              break;\n\n            case 'normal':\n              var normalNode = fieldValues[0];\n\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n\n              break;\n\n            case 'texCoord':\n              var texCoordNode = fieldValues[0];\n\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n\n              break;\n\n            case 'height':\n              height = fieldValues;\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'colorPerVertex':\n              colorPerVertex = fieldValues[0];\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'normalPerVertex':\n              normalPerVertex = fieldValues[0];\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'xDimension':\n              xDimension = fieldValues[0];\n              break;\n\n            case 'xSpacing':\n              xSpacing = fieldValues[0];\n              break;\n\n            case 'zDimension':\n              zDimension = fieldValues[0];\n              break;\n\n            case 'zSpacing':\n              zSpacing = fieldValues[0];\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        } // vertex data\n\n\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var uvs = [];\n\n        for (var _i9 = 0; _i9 < zDimension; _i9++) {\n          for (var j = 0; j < xDimension; j++) {\n            // compute a row major index\n            var index = _i9 * xDimension + j; // vertices\n\n            var x = xSpacing * _i9;\n            var y = height[index];\n            var z = zSpacing * j;\n            vertices.push(x, y, z); // colors\n\n            if (color && colorPerVertex === true) {\n              var r = color[index * 3 + 0];\n              var g = color[index * 3 + 1];\n              var b = color[index * 3 + 2];\n              colors.push(r, g, b);\n            } // normals\n\n\n            if (normal && normalPerVertex === true) {\n              var xn = normal[index * 3 + 0];\n              var yn = normal[index * 3 + 1];\n              var zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n            } // uvs\n\n\n            if (texCoord) {\n              var s = texCoord[index * 2 + 0];\n              var t = texCoord[index * 2 + 1];\n              uvs.push(s, t);\n            } else {\n              uvs.push(_i9 / (xDimension - 1), j / (zDimension - 1));\n            }\n          }\n        } // indices\n\n\n        var indices = [];\n\n        for (var _i10 = 0; _i10 < xDimension - 1; _i10++) {\n          for (var _j = 0; _j < zDimension - 1; _j++) {\n            // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n            var a = _i10 + _j * xDimension;\n\n            var _b = _i10 + (_j + 1) * xDimension;\n\n            var c = _i10 + 1 + (_j + 1) * xDimension;\n            var d = _i10 + 1 + _j * xDimension; // faces\n\n            if (ccw === true) {\n              indices.push(a, c, _b);\n              indices.push(c, a, d);\n            } else {\n              indices.push(a, _b, c);\n              indices.push(c, d, a);\n            }\n          }\n        } //\n\n\n        var positionAttribute = toNonIndexedAttribute(indices, new _three.Float32BufferAttribute(vertices, 3));\n        var uvAttribute = toNonIndexedAttribute(indices, new _three.Float32BufferAttribute(uvs, 2));\n        var colorAttribute;\n        var normalAttribute; // color attribute\n\n        if (color) {\n          if (colorPerVertex === false) {\n            for (var _i11 = 0; _i11 < xDimension - 1; _i11++) {\n              for (var _j2 = 0; _j2 < zDimension - 1; _j2++) {\n                var _index = _i11 + _j2 * (xDimension - 1);\n\n                var _r = color[_index * 3 + 0];\n                var _g = color[_index * 3 + 1];\n                var _b2 = color[_index * 3 + 2]; // one color per quad\n\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n              }\n            }\n\n            colorAttribute = new _three.Float32BufferAttribute(colors, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(indices, new _three.Float32BufferAttribute(colors, 3));\n          }\n        } // normal attribute\n\n\n        if (normal) {\n          if (normalPerVertex === false) {\n            for (var _i12 = 0; _i12 < xDimension - 1; _i12++) {\n              for (var _j3 = 0; _j3 < zDimension - 1; _j3++) {\n                var _index2 = _i12 + _j3 * (xDimension - 1);\n\n                var _xn = normal[_index2 * 3 + 0];\n                var _yn = normal[_index2 * 3 + 1];\n                var _zn = normal[_index2 * 3 + 2]; // one normal per quad\n\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n              }\n            }\n\n            normalAttribute = new _three.Float32BufferAttribute(normals, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(indices, new _three.Float32BufferAttribute(normals, 3));\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        } // build geometry\n\n\n        var geometry = new _three.BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute);\n        geometry.setAttribute('uv', uvAttribute);\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      }\n\n      function buildExtrusionNode(node) {\n        var crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n        var spine = [0, 0, 0, 0, 1, 0];\n        var scale;\n        var orientation;\n        var beginCap = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var endCap = true;\n        var solid = true;\n        var fields = node.fields;\n\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n\n          switch (fieldName) {\n            case 'beginCap':\n              beginCap = fieldValues[0];\n              break;\n\n            case 'ccw':\n              ccw = fieldValues[0];\n              break;\n\n            case 'convex':\n              // field not supported\n              break;\n\n            case 'creaseAngle':\n              creaseAngle = fieldValues[0];\n              break;\n\n            case 'crossSection':\n              crossSection = fieldValues;\n              break;\n\n            case 'endCap':\n              endCap = fieldValues[0];\n              break;\n\n            case 'orientation':\n              orientation = fieldValues;\n              break;\n\n            case 'scale':\n              scale = fieldValues;\n              break;\n\n            case 'solid':\n              solid = fieldValues[0];\n              break;\n\n            case 'spine':\n              spine = fieldValues; // only extrusion along the Y-axis are supported so far\n\n              break;\n\n            default:\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n              break;\n          }\n        }\n\n        var crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\n\n        var vertices = [];\n        var spineVector = new _three.Vector3();\n        var scaling = new _three.Vector3();\n        var axis = new _three.Vector3();\n        var vertex = new _three.Vector3();\n        var quaternion = new _three.Quaternion();\n\n        for (var _i13 = 0, j = 0, o = 0, il = spine.length; _i13 < il; _i13 += 3, j += 2, o += 4) {\n          spineVector.fromArray(spine, _i13);\n          scaling.x = scale ? scale[j + 0] : 1;\n          scaling.y = 1;\n          scaling.z = scale ? scale[j + 1] : 1;\n          axis.x = orientation ? orientation[o + 0] : 0;\n          axis.y = orientation ? orientation[o + 1] : 0;\n          axis.z = orientation ? orientation[o + 2] : 1;\n          var angle = orientation ? orientation[o + 3] : 0;\n\n          for (var k = 0, kl = crossSection.length; k < kl; k += 2) {\n            vertex.x = crossSection[k + 0];\n            vertex.y = 0;\n            vertex.z = crossSection[k + 1]; // scale\n\n            vertex.multiply(scaling); // rotate\n\n            quaternion.setFromAxisAngle(axis, angle);\n            vertex.applyQuaternion(quaternion); // translate\n\n            vertex.add(spineVector);\n            vertices.push(vertex.x, vertex.y, vertex.z);\n          }\n        } // indices\n\n\n        var indices = [];\n        var spineCount = spine.length / 3;\n        var crossSectionCount = crossSection.length / 2;\n\n        for (var _i14 = 0; _i14 < spineCount - 1; _i14++) {\n          for (var _j4 = 0; _j4 < crossSectionCount - 1; _j4++) {\n            var a = _j4 + _i14 * crossSectionCount;\n            var b = _j4 + 1 + _i14 * crossSectionCount;\n            var c = _j4 + (_i14 + 1) * crossSectionCount;\n            var d = _j4 + 1 + (_i14 + 1) * crossSectionCount;\n\n            if (_j4 === crossSectionCount - 2 && crossSectionClosed === true) {\n              b = _i14 * crossSectionCount;\n              d = (_i14 + 1) * crossSectionCount;\n            }\n\n            if (ccw === true) {\n              indices.push(a, b, c);\n              indices.push(c, b, d);\n            } else {\n              indices.push(a, c, b);\n              indices.push(c, d, b);\n            }\n          }\n        } // triangulate cap\n\n\n        if (beginCap === true || endCap === true) {\n          var contour = [];\n\n          for (var _i15 = 0, _l9 = crossSection.length; _i15 < _l9; _i15 += 2) {\n            contour.push(new _three.Vector2(crossSection[_i15], crossSection[_i15 + 1]));\n          }\n\n          var faces = _three.ShapeUtils.triangulateShape(contour, []);\n\n          var capIndices = [];\n\n          for (var _i16 = 0, _l10 = faces.length; _i16 < _l10; _i16++) {\n            var face = faces[_i16];\n            capIndices.push(face[0], face[1], face[2]);\n          } // begin cap\n\n\n          if (beginCap === true) {\n            for (var _i17 = 0, _l11 = capIndices.length; _i17 < _l11; _i17 += 3) {\n              if (ccw === true) {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 1], capIndices[_i17 + 2]);\n              } else {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 2], capIndices[_i17 + 1]);\n              }\n            }\n          } // end cap\n\n\n          if (endCap === true) {\n            var indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\n\n            for (var _i18 = 0, _l12 = capIndices.length; _i18 < _l12; _i18 += 3) {\n              if (ccw === true) {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 2], indexOffset + capIndices[_i18 + 1]);\n              } else {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 1], indexOffset + capIndices[_i18 + 2]);\n              }\n            }\n          }\n        }\n\n        var positionAttribute = toNonIndexedAttribute(indices, new _three.Float32BufferAttribute(vertices, 3));\n        var normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        var geometry = new _three.BufferGeometry();\n        geometry.setAttribute('position', positionAttribute);\n        geometry.setAttribute('normal', normalAttribute); // no uvs yet\n        // \"solid\" influences the material so let's store it for later use\n\n        geometry._solid = solid;\n        geometry._type = 'mesh';\n        return geometry;\n      } // helper functions\n\n\n      function resolveUSE(identifier) {\n        var node = nodeMap[identifier];\n        var build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\n        // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n        // any side effects\n\n        return build.isObject3D || build.isMaterial ? build.clone() : build;\n      }\n\n      function parseFieldChildren(children, owner) {\n        for (var i = 0, l = children.length; i < l; i++) {\n          var object = getNode(children[i]);\n          if (object instanceof _three.Object3D) owner.add(object);\n        }\n      }\n\n      function triangulateFaceIndex(index, ccw) {\n        var indices = []; // since face defintions can have more than three vertices, it's necessary to\n        // perform a simple triangulation\n\n        var start = 0;\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[start];\n          var i2 = index[i + (ccw ? 1 : 2)];\n          var i3 = index[i + (ccw ? 2 : 1)];\n          indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start = i + 1;\n          }\n        }\n\n        return indices;\n      }\n\n      function triangulateFaceData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\n\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start++;\n          }\n        }\n\n        return triangulatedData;\n      }\n\n      function flattenData(data, index) {\n        var flattenData = [];\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var stride = i1 * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          flattenData.push(x, y, z);\n        }\n\n        return flattenData;\n      }\n\n      function expandLineIndex(index) {\n        var indices = [];\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var i2 = index[i + 1];\n          indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n          }\n        }\n\n        return indices;\n      }\n\n      function expandLineData(data, index) {\n        var triangulatedData = [];\n        var start = 0;\n\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data[stride];\n          var y = data[stride + 1];\n          var z = data[stride + 2];\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\n\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n            start++;\n          }\n        }\n\n        return triangulatedData;\n      }\n\n      var vA = new _three.Vector3();\n      var vB = new _three.Vector3();\n      var vC = new _three.Vector3();\n      var uvA = new _three.Vector2();\n      var uvB = new _three.Vector2();\n      var uvC = new _three.Vector2();\n\n      function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n        var array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n        for (var i = 0, l = coordIndex.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n\n          if (itemSize === 2) {\n            uvA.fromArray(data, a * itemSize);\n            uvB.fromArray(data, b * itemSize);\n            uvC.fromArray(data, c * itemSize);\n            array.push(uvA.x, uvA.y);\n            array.push(uvB.x, uvB.y);\n            array.push(uvC.x, uvC.y);\n          } else {\n            vA.fromArray(data, a * itemSize);\n            vB.fromArray(data, b * itemSize);\n            vC.fromArray(data, c * itemSize);\n            array.push(vA.x, vA.y, vA.z);\n            array.push(vB.x, vB.y, vB.z);\n            array.push(vC.x, vC.y, vC.z);\n          }\n        }\n\n        return new _three.Float32BufferAttribute(array, itemSize);\n      }\n\n      function computeAttributeFromFaceData(index, faceData) {\n        var array = [];\n\n        for (var i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n          vA.fromArray(faceData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n\n        return new _three.Float32BufferAttribute(array, 3);\n      }\n\n      function computeAttributeFromLineData(index, lineData) {\n        var array = [];\n\n        for (var i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n          vA.fromArray(lineData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n\n        return new _three.Float32BufferAttribute(array, 3);\n      }\n\n      function toNonIndexedAttribute(indices, attribute) {\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        var array2 = new array.constructor(indices.length * itemSize);\n        var index = 0,\n            index2 = 0;\n\n        for (var i = 0, l = indices.length; i < l; i++) {\n          index = indices[i] * itemSize;\n\n          for (var j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n\n        return new _three.Float32BufferAttribute(array2, itemSize);\n      }\n\n      var ab = new _three.Vector3();\n      var cb = new _three.Vector3();\n\n      function computeNormalAttribute(index, coord, creaseAngle) {\n        var faces = [];\n        var vertexNormals = {}; // prepare face and raw vertex normals\n\n        for (var i = 0, l = index.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          var face = new Face(a, b, c);\n          vA.fromArray(coord, a * 3);\n          vB.fromArray(coord, b * 3);\n          vC.fromArray(coord, c * 3);\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          cb.normalize();\n          face.normal.copy(cb);\n          if (vertexNormals[a] === undefined) vertexNormals[a] = [];\n          if (vertexNormals[b] === undefined) vertexNormals[b] = [];\n          if (vertexNormals[c] === undefined) vertexNormals[c] = [];\n          vertexNormals[a].push(face.normal);\n          vertexNormals[b].push(face.normal);\n          vertexNormals[c].push(face.normal);\n          faces.push(face);\n        } // compute vertex normals and build final geometry\n\n\n        var normals = [];\n\n        for (var _i19 = 0, _l13 = faces.length; _i19 < _l13; _i19++) {\n          var _face = faces[_i19];\n          var nA = weightedNormal(vertexNormals[_face.a], _face.normal, creaseAngle);\n          var nB = weightedNormal(vertexNormals[_face.b], _face.normal, creaseAngle);\n          var nC = weightedNormal(vertexNormals[_face.c], _face.normal, creaseAngle);\n          vA.fromArray(coord, _face.a * 3);\n          vB.fromArray(coord, _face.b * 3);\n          vC.fromArray(coord, _face.c * 3);\n          normals.push(nA.x, nA.y, nA.z);\n          normals.push(nB.x, nB.y, nB.z);\n          normals.push(nC.x, nC.y, nC.z);\n        }\n\n        return new _three.Float32BufferAttribute(normals, 3);\n      }\n\n      function weightedNormal(normals, vector, creaseAngle) {\n        var normal = new _three.Vector3();\n\n        if (creaseAngle === 0) {\n          normal.copy(vector);\n        } else {\n          for (var i = 0, l = normals.length; i < l; i++) {\n            if (normals[i].angleTo(vector) < creaseAngle) {\n              normal.add(normals[i]);\n            }\n          }\n        }\n\n        return normal.normalize();\n      }\n\n      function toColorArray(colors) {\n        var array = [];\n\n        for (var i = 0, l = colors.length; i < l; i += 3) {\n          array.push(new _three.Color(colors[i], colors[i + 1], colors[i + 2]));\n        }\n\n        return array;\n      }\n      /**\n       * Vertically paints the faces interpolating between the\n       * specified colors at the specified angels. This is used for the Background\n       * node, but could be applied to other nodes with multiple faces as well.\n       *\n       * When used with the Background node, default is directionIsDown is true if\n       * interpolating the skyColor down from the Zenith. When interpolationg up from\n       * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n       *\n       * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n       * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n       * is linear along the Y axis in any case.\n       *\n       * You must specify one more color than you have angles at the beginning of the colors array.\n       * This is the color of the Zenith (the top of the shape).\n       *\n       * @param {BufferGeometry} geometry\n       * @param {number} radius\n       * @param {array} angles\n       * @param {array} colors\n       * @param {boolean} topDown - Whether to work top down or bottom up.\n       */\n\n\n      function paintFaces(geometry, radius, angles, colors, topDown) {\n        // compute threshold values\n        var thresholds = [];\n        var startAngle = topDown === true ? 0 : Math.PI;\n\n        for (var i = 0, l = colors.length; i < l; i++) {\n          var angle = i === 0 ? 0 : angles[i - 1];\n          angle = topDown === true ? angle : startAngle - angle;\n          var point = new _three.Vector3();\n          point.setFromSphericalCoords(radius, angle, 0);\n          thresholds.push(point);\n        } // generate vertex colors\n\n\n        var indices = geometry.index;\n        var positionAttribute = geometry.attributes.position;\n        var colorAttribute = new _three.BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n        var position = new _three.Vector3();\n        var color = new _three.Color();\n\n        for (var _i20 = 0; _i20 < indices.count; _i20++) {\n          var index = indices.getX(_i20);\n          position.fromBufferAttribute(positionAttribute, index);\n          var thresholdIndexA = void 0,\n              thresholdIndexB = void 0;\n          var t = 1;\n\n          for (var j = 1; j < thresholds.length; j++) {\n            thresholdIndexA = j - 1;\n            thresholdIndexB = j;\n            var thresholdA = thresholds[thresholdIndexA];\n            var thresholdB = thresholds[thresholdIndexB];\n\n            if (topDown === true) {\n              // interpolation for sky color\n              if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            } else {\n              // interpolation for ground color\n              if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            }\n          }\n\n          var colorA = colors[thresholdIndexA];\n          var colorB = colors[thresholdIndexB];\n          color.copy(colorA).lerp(colorB, t);\n          colorAttribute.setXYZ(index, color.r, color.g, color.b);\n        }\n\n        geometry.setAttribute('color', colorAttribute);\n      } //\n\n\n      var textureLoader = new _three.TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\n\n      if (data.indexOf('#VRML V2.0') === -1) {\n        throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n      } // create JSON representing the tree structure of the VRML asset\n\n\n      var tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\n\n      var scene = parseTree(tree);\n      return scene;\n    }\n  }]);\n\n  return VRMLLoader;\n}(_three.Loader);\n\nexports.VRMLLoader = VRMLLoader;\n\nvar VRMLLexer =\n/*#__PURE__*/\nfunction () {\n  function VRMLLexer(tokens) {\n    _classCallCheck(this, VRMLLexer);\n\n    this.lexer = new _chevrotain.Lexer(tokens); // eslint-disable-line no-undef\n  }\n\n  _createClass(VRMLLexer, [{\n    key: \"lex\",\n    value: function lex(inputText) {\n      var lexingResult = this.lexer.tokenize(inputText);\n\n      if (lexingResult.errors.length > 0) {\n        console.error(lexingResult.errors);\n        throw Error('THREE.VRMLLexer: Lexing errors detected.');\n      }\n\n      return lexingResult;\n    }\n  }]);\n\n  return VRMLLexer;\n}();\n\nvar VRMLParser =\n/*#__PURE__*/\nfunction (_CstParser) {\n  _inherits(VRMLParser, _CstParser);\n\n  function VRMLParser(tokenVocabulary) {\n    var _this;\n\n    _classCallCheck(this, VRMLParser);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(VRMLParser).call(this, tokenVocabulary));\n\n    var $ = _assertThisInitialized(_this);\n\n    var Version = tokenVocabulary['Version'];\n    var LCurly = tokenVocabulary['LCurly'];\n    var RCurly = tokenVocabulary['RCurly'];\n    var LSquare = tokenVocabulary['LSquare'];\n    var RSquare = tokenVocabulary['RSquare'];\n    var Identifier = tokenVocabulary['Identifier'];\n    var RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n    var StringLiteral = tokenVocabulary['StringLiteral'];\n    var HexLiteral = tokenVocabulary['HexLiteral'];\n    var NumberLiteral = tokenVocabulary['NumberLiteral'];\n    var TrueLiteral = tokenVocabulary['TrueLiteral'];\n    var FalseLiteral = tokenVocabulary['FalseLiteral'];\n    var NullLiteral = tokenVocabulary['NullLiteral'];\n    var DEF = tokenVocabulary['DEF'];\n    var USE = tokenVocabulary['USE'];\n    var ROUTE = tokenVocabulary['ROUTE'];\n    var TO = tokenVocabulary['TO'];\n    var NodeName = tokenVocabulary['NodeName'];\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE('version', function () {\n      $.CONSUME(Version);\n    });\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE('field', function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function ALT() {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function ALT() {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE('def', function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('use', function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n\n    _this.performSelfAnalysis();\n\n    return _this;\n  }\n\n  return VRMLParser;\n}(_chevrotain.CstParser);\n\nvar Face = function Face(a, b, c) {\n  _classCallCheck(this, Face);\n\n  this.a = a;\n  this.b = b;\n  this.c = c;\n  this.normal = new _three.Vector3();\n};\n\nvar TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$chevrotain$lib$src$api","~$shadow.js"]],"~:properties",["^5",["USE","map","FROM","z","_type","transparency","wrapS","values","DEF","depthTest","__type","prototype","scale","transparent","emissiveColor","side","group","INTENSITY_ALPHA","fog","worldInfo","longer_alt","key","x","__esModule","info","route","INTENSITY","normal","renderOrder","multiFieldValue","lexer","name","configurable","RGB","value","center","visible","enumerable","vertexColors","field","build","a","writable","TO","diffuseColor","shininess","rotation","ALT","input","nodes","title","pattern","type","b","r","y","wrapT","vrml","RGBA","version","__proto__","fields","g","depthWrite","def","_solid","use","VRMLLoader","color","opacity","routes","singleFieldValue","c","translation","node","constructor"]],"~:compiled-at",1630917515736,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$VRMLLoader.js\",\n\"lineCount\":98,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/VRMLLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$VRMLLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.VRMLLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _chevrotain = require(\\\"chevrotain\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar VRMLLoader =\\n/*#__PURE__*/\\nfunction (_Loader) {\\n  _inherits(VRMLLoader, _Loader);\\n\\n  function VRMLLoader(manager) {\\n    _classCallCheck(this, VRMLLoader);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(VRMLLoader).call(this, manager));\\n  }\\n\\n  _createClass(VRMLLoader, [{\\n    key: \\\"load\\\",\\n    value: function load(url, onLoad, onProgress, onError) {\\n      var scope = this;\\n      var path = scope.path === '' ? _three.LoaderUtils.extractUrlBase(url) : scope.path;\\n      var loader = new _three.FileLoader(scope.manager);\\n      loader.setPath(scope.path);\\n      loader.setRequestHeader(scope.requestHeader);\\n      loader.setWithCredentials(scope.withCredentials);\\n      loader.load(url, function (text) {\\n        try {\\n          onLoad(scope.parse(text, path));\\n        } catch (e) {\\n          if (onError) {\\n            onError(e);\\n          } else {\\n            console.error(e);\\n          }\\n\\n          scope.manager.itemError(url);\\n        }\\n      }, onProgress, onError);\\n    }\\n  }, {\\n    key: \\\"parse\\\",\\n    value: function parse(data, path) {\\n      var nodeMap = {};\\n\\n      function generateVRMLTree(data) {\\n        // create lexer, parser and visitor\\n        var tokenData = createTokens();\\n        var lexer = new VRMLLexer(tokenData.tokens);\\n        var parser = new VRMLParser(tokenData.tokenVocabulary);\\n        var visitor = createVisitor(parser.getBaseCstVisitorConstructor()); // lexing\\n\\n        var lexingResult = lexer.lex(data);\\n        parser.input = lexingResult.tokens; // parsing\\n\\n        var cstOutput = parser.vrml();\\n\\n        if (parser.errors.length > 0) {\\n          console.error(parser.errors);\\n          throw Error('THREE.VRMLLoader: Parsing errors detected.');\\n        } // actions\\n\\n\\n        var ast = visitor.visit(cstOutput);\\n        return ast;\\n      }\\n\\n      function createTokens() {\\n        // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\\n        var RouteIdentifier = (0, _chevrotain.createToken)({\\n          name: 'RouteIdentifier',\\n          pattern: /[^\\\\x30-\\\\x39\\\\0-\\\\x20\\\\x22\\\\x27\\\\x23\\\\x2b\\\\x2c\\\\x2d\\\\x2e\\\\x5b\\\\x5d\\\\x5c\\\\x7b\\\\x7d][^\\\\0-\\\\x20\\\\x22\\\\x27\\\\x23\\\\x2b\\\\x2c\\\\x2d\\\\x2e\\\\x5b\\\\x5d\\\\x5c\\\\x7b\\\\x7d]*[\\\\.][^\\\\x30-\\\\x39\\\\0-\\\\x20\\\\x22\\\\x27\\\\x23\\\\x2b\\\\x2c\\\\x2d\\\\x2e\\\\x5b\\\\x5d\\\\x5c\\\\x7b\\\\x7d][^\\\\0-\\\\x20\\\\x22\\\\x27\\\\x23\\\\x2b\\\\x2c\\\\x2d\\\\x2e\\\\x5b\\\\x5d\\\\x5c\\\\x7b\\\\x7d]*/\\n        });\\n        var Identifier = (0, _chevrotain.createToken)({\\n          name: 'Identifier',\\n          pattern: /[^\\\\x30-\\\\x39\\\\0-\\\\x20\\\\x22\\\\x27\\\\x23\\\\x2b\\\\x2c\\\\x2d\\\\x2e\\\\x5b\\\\x5d\\\\x5c\\\\x7b\\\\x7d][^\\\\0-\\\\x20\\\\x22\\\\x27\\\\x23\\\\x2b\\\\x2c\\\\x2d\\\\x2e\\\\x5b\\\\x5d\\\\x5c\\\\x7b\\\\x7d]*/,\\n          longer_alt: RouteIdentifier\\n        }); // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\\n\\n        var nodeTypes = ['Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\\n        'Inline', 'LOD', 'Switch', // special groups\\n        'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\\n        'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\\n        'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\\n        'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\\n        'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\\n        'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\\n        'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\\n        'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\\n        ]; //\\n\\n        var Version = (0, _chevrotain.createToken)({\\n          name: 'Version',\\n          pattern: /#VRML.*/,\\n          longer_alt: Identifier\\n        });\\n        var NodeName = (0, _chevrotain.createToken)({\\n          name: 'NodeName',\\n          pattern: new RegExp(nodeTypes.join('|')),\\n          longer_alt: Identifier\\n        });\\n        var DEF = (0, _chevrotain.createToken)({\\n          name: 'DEF',\\n          pattern: /DEF/,\\n          longer_alt: Identifier\\n        });\\n        var USE = (0, _chevrotain.createToken)({\\n          name: 'USE',\\n          pattern: /USE/,\\n          longer_alt: Identifier\\n        });\\n        var ROUTE = (0, _chevrotain.createToken)({\\n          name: 'ROUTE',\\n          pattern: /ROUTE/,\\n          longer_alt: Identifier\\n        });\\n        var TO = (0, _chevrotain.createToken)({\\n          name: 'TO',\\n          pattern: /TO/,\\n          longer_alt: Identifier\\n        }); //\\n\\n        var StringLiteral = (0, _chevrotain.createToken)({\\n          name: 'StringLiteral',\\n          pattern: /\\\"(:?[^\\\\\\\\\\\"\\\\n\\\\r]+|\\\\\\\\(:?[bfnrtv\\\"\\\\\\\\/]|u[0-9a-fA-F]{4}))*\\\"/\\n        });\\n        var HexLiteral = (0, _chevrotain.createToken)({\\n          name: 'HexLiteral',\\n          pattern: /0[xX][0-9a-fA-F]+/\\n        });\\n        var NumberLiteral = (0, _chevrotain.createToken)({\\n          name: 'NumberLiteral',\\n          pattern: /[-+]?[0-9]*\\\\.?[0-9]+([eE][-+]?[0-9]+)?/\\n        });\\n        var TrueLiteral = (0, _chevrotain.createToken)({\\n          name: 'TrueLiteral',\\n          pattern: /TRUE/\\n        });\\n        var FalseLiteral = (0, _chevrotain.createToken)({\\n          name: 'FalseLiteral',\\n          pattern: /FALSE/\\n        });\\n        var NullLiteral = (0, _chevrotain.createToken)({\\n          name: 'NullLiteral',\\n          pattern: /NULL/\\n        });\\n        var LSquare = (0, _chevrotain.createToken)({\\n          name: 'LSquare',\\n          pattern: /\\\\[/\\n        });\\n        var RSquare = (0, _chevrotain.createToken)({\\n          name: 'RSquare',\\n          pattern: /]/\\n        });\\n        var LCurly = (0, _chevrotain.createToken)({\\n          name: 'LCurly',\\n          pattern: /{/\\n        });\\n        var RCurly = (0, _chevrotain.createToken)({\\n          name: 'RCurly',\\n          pattern: /}/\\n        });\\n        var Comment = (0, _chevrotain.createToken)({\\n          name: 'Comment',\\n          pattern: /#.*/,\\n          group: _chevrotain.Lexer.SKIPPED // eslint-disable-line no-undef\\n\\n        }); // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\\n\\n        var WhiteSpace = (0, _chevrotain.createToken)({\\n          name: 'WhiteSpace',\\n          pattern: /[ ,\\\\s]/,\\n          group: _chevrotain.Lexer.SKIPPED // eslint-disable-line no-undef\\n\\n        });\\n        var tokens = [WhiteSpace, // keywords appear before the Identifier\\n        NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral, // the Identifier must appear after the keywords because all keywords are valid identifiers\\n        Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\\n        var tokenVocabulary = {};\\n\\n        for (var i = 0, l = tokens.length; i < l; i++) {\\n          var token = tokens[i];\\n          tokenVocabulary[token.name] = token;\\n        }\\n\\n        return {\\n          tokens: tokens,\\n          tokenVocabulary: tokenVocabulary\\n        };\\n      }\\n\\n      function createVisitor(BaseVRMLVisitor) {\\n        // the visitor is created dynmaically based on the given base class\\n        function VRMLToASTVisitor() {\\n          BaseVRMLVisitor.call(this);\\n          this.validateVisitor();\\n        }\\n\\n        VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\\n          constructor: VRMLToASTVisitor,\\n          vrml: function vrml(ctx) {\\n            var data = {\\n              version: this.visit(ctx.version),\\n              nodes: [],\\n              routes: []\\n            };\\n\\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\\n              var node = ctx.node[i];\\n              data.nodes.push(this.visit(node));\\n            }\\n\\n            if (ctx.route) {\\n              for (var _i = 0, _l = ctx.route.length; _i < _l; _i++) {\\n                var route = ctx.route[_i];\\n                data.routes.push(this.visit(route));\\n              }\\n            }\\n\\n            return data;\\n          },\\n          version: function version(ctx) {\\n            return ctx.Version[0].image;\\n          },\\n          node: function node(ctx) {\\n            var data = {\\n              name: ctx.NodeName[0].image,\\n              fields: []\\n            };\\n\\n            if (ctx.field) {\\n              for (var i = 0, l = ctx.field.length; i < l; i++) {\\n                var field = ctx.field[i];\\n                data.fields.push(this.visit(field));\\n              }\\n            } // DEF\\n\\n\\n            if (ctx.def) {\\n              data.DEF = this.visit(ctx.def[0]);\\n            }\\n\\n            return data;\\n          },\\n          field: function field(ctx) {\\n            var data = {\\n              name: ctx.Identifier[0].image,\\n              type: null,\\n              values: null\\n            };\\n            var result; // SFValue\\n\\n            if (ctx.singleFieldValue) {\\n              result = this.visit(ctx.singleFieldValue[0]);\\n            } // MFValue\\n\\n\\n            if (ctx.multiFieldValue) {\\n              result = this.visit(ctx.multiFieldValue[0]);\\n            }\\n\\n            data.type = result.type;\\n            data.values = result.values;\\n            return data;\\n          },\\n          def: function def(ctx) {\\n            return (ctx.Identifier || ctx.NodeName)[0].image;\\n          },\\n          use: function use(ctx) {\\n            return {\\n              USE: (ctx.Identifier || ctx.NodeName)[0].image\\n            };\\n          },\\n          singleFieldValue: function singleFieldValue(ctx) {\\n            return processField(this, ctx);\\n          },\\n          multiFieldValue: function multiFieldValue(ctx) {\\n            return processField(this, ctx);\\n          },\\n          route: function route(ctx) {\\n            var data = {\\n              FROM: ctx.RouteIdentifier[0].image,\\n              TO: ctx.RouteIdentifier[1].image\\n            };\\n            return data;\\n          }\\n        });\\n\\n        function processField(scope, ctx) {\\n          var field = {\\n            type: null,\\n            values: []\\n          };\\n\\n          if (ctx.node) {\\n            field.type = 'node';\\n\\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\\n              var node = ctx.node[i];\\n              field.values.push(scope.visit(node));\\n            }\\n          }\\n\\n          if (ctx.use) {\\n            field.type = 'use';\\n\\n            for (var _i2 = 0, _l2 = ctx.use.length; _i2 < _l2; _i2++) {\\n              var use = ctx.use[_i2];\\n              field.values.push(scope.visit(use));\\n            }\\n          }\\n\\n          if (ctx.StringLiteral) {\\n            field.type = 'string';\\n\\n            for (var _i3 = 0, _l3 = ctx.StringLiteral.length; _i3 < _l3; _i3++) {\\n              var stringLiteral = ctx.StringLiteral[_i3];\\n              field.values.push(stringLiteral.image.replace(/'|\\\"/g, ''));\\n            }\\n          }\\n\\n          if (ctx.NumberLiteral) {\\n            field.type = 'number';\\n\\n            for (var _i4 = 0, _l4 = ctx.NumberLiteral.length; _i4 < _l4; _i4++) {\\n              var numberLiteral = ctx.NumberLiteral[_i4];\\n              field.values.push(parseFloat(numberLiteral.image));\\n            }\\n          }\\n\\n          if (ctx.HexLiteral) {\\n            field.type = 'hex';\\n\\n            for (var _i5 = 0, _l5 = ctx.HexLiteral.length; _i5 < _l5; _i5++) {\\n              var hexLiteral = ctx.HexLiteral[_i5];\\n              field.values.push(hexLiteral.image);\\n            }\\n          }\\n\\n          if (ctx.TrueLiteral) {\\n            field.type = 'boolean';\\n\\n            for (var _i6 = 0, _l6 = ctx.TrueLiteral.length; _i6 < _l6; _i6++) {\\n              var trueLiteral = ctx.TrueLiteral[_i6];\\n              if (trueLiteral.image === 'TRUE') field.values.push(true);\\n            }\\n          }\\n\\n          if (ctx.FalseLiteral) {\\n            field.type = 'boolean';\\n\\n            for (var _i7 = 0, _l7 = ctx.FalseLiteral.length; _i7 < _l7; _i7++) {\\n              var falseLiteral = ctx.FalseLiteral[_i7];\\n              if (falseLiteral.image === 'FALSE') field.values.push(false);\\n            }\\n          }\\n\\n          if (ctx.NullLiteral) {\\n            field.type = 'null';\\n            ctx.NullLiteral.forEach(function () {\\n              field.values.push(null);\\n            });\\n          }\\n\\n          return field;\\n        }\\n\\n        return new VRMLToASTVisitor();\\n      }\\n\\n      function parseTree(tree) {\\n        // console.log( JSON.stringify( tree, null, 2 ) );\\n        var nodes = tree.nodes;\\n        var scene = new _three.Scene(); // first iteration: build nodemap based on DEF statements\\n\\n        for (var i = 0, l = nodes.length; i < l; i++) {\\n          var node = nodes[i];\\n          buildNodeMap(node);\\n        } // second iteration: build nodes\\n\\n\\n        for (var _i8 = 0, _l8 = nodes.length; _i8 < _l8; _i8++) {\\n          var _node = nodes[_i8];\\n          var object = getNode(_node);\\n          if (object instanceof _three.Object3D) scene.add(object);\\n          if (_node.name === 'WorldInfo') scene.userData.worldInfo = object;\\n        }\\n\\n        return scene;\\n      }\\n\\n      function buildNodeMap(node) {\\n        if (node.DEF) {\\n          nodeMap[node.DEF] = node;\\n        }\\n\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n\\n          if (field.type === 'node') {\\n            var fieldValues = field.values;\\n\\n            for (var j = 0, jl = fieldValues.length; j < jl; j++) {\\n              buildNodeMap(fieldValues[j]);\\n            }\\n          }\\n        }\\n      }\\n\\n      function getNode(node) {\\n        // handle case where a node refers to a different one\\n        if (node.USE) {\\n          return resolveUSE(node.USE);\\n        }\\n\\n        if (node.build !== undefined) return node.build;\\n        node.build = buildNode(node);\\n        return node.build;\\n      } // node builder\\n\\n\\n      function buildNode(node) {\\n        var nodeName = node.name;\\n        var build;\\n\\n        switch (nodeName) {\\n          case 'Group':\\n          case 'Transform':\\n          case 'Collision':\\n            build = buildGroupingNode(node);\\n            break;\\n\\n          case 'Background':\\n            build = buildBackgroundNode(node);\\n            break;\\n\\n          case 'Shape':\\n            build = buildShapeNode(node);\\n            break;\\n\\n          case 'Appearance':\\n            build = buildAppearanceNode(node);\\n            break;\\n\\n          case 'Material':\\n            build = buildMaterialNode(node);\\n            break;\\n\\n          case 'ImageTexture':\\n            build = buildImageTextureNode(node);\\n            break;\\n\\n          case 'PixelTexture':\\n            build = buildPixelTextureNode(node);\\n            break;\\n\\n          case 'TextureTransform':\\n            build = buildTextureTransformNode(node);\\n            break;\\n\\n          case 'IndexedFaceSet':\\n            build = buildIndexedFaceSetNode(node);\\n            break;\\n\\n          case 'IndexedLineSet':\\n            build = buildIndexedLineSetNode(node);\\n            break;\\n\\n          case 'PointSet':\\n            build = buildPointSetNode(node);\\n            break;\\n\\n          case 'Box':\\n            build = buildBoxNode(node);\\n            break;\\n\\n          case 'Cone':\\n            build = buildConeNode(node);\\n            break;\\n\\n          case 'Cylinder':\\n            build = buildCylinderNode(node);\\n            break;\\n\\n          case 'Sphere':\\n            build = buildSphereNode(node);\\n            break;\\n\\n          case 'ElevationGrid':\\n            build = buildElevationGridNode(node);\\n            break;\\n\\n          case 'Extrusion':\\n            build = buildExtrusionNode(node);\\n            break;\\n\\n          case 'Color':\\n          case 'Coordinate':\\n          case 'Normal':\\n          case 'TextureCoordinate':\\n            build = buildGeometricNode(node);\\n            break;\\n\\n          case 'WorldInfo':\\n            build = buildWorldInfoNode(node);\\n            break;\\n\\n          case 'Anchor':\\n          case 'Billboard':\\n          case 'Inline':\\n          case 'LOD':\\n          case 'Switch':\\n          case 'AudioClip':\\n          case 'DirectionalLight':\\n          case 'PointLight':\\n          case 'Script':\\n          case 'Sound':\\n          case 'SpotLight':\\n          case 'CylinderSensor':\\n          case 'PlaneSensor':\\n          case 'ProximitySensor':\\n          case 'SphereSensor':\\n          case 'TimeSensor':\\n          case 'TouchSensor':\\n          case 'VisibilitySensor':\\n          case 'Text':\\n          case 'FontStyle':\\n          case 'MovieTexture':\\n          case 'ColorInterpolator':\\n          case 'CoordinateInterpolator':\\n          case 'NormalInterpolator':\\n          case 'OrientationInterpolator':\\n          case 'PositionInterpolator':\\n          case 'ScalarInterpolator':\\n          case 'Fog':\\n          case 'NavigationInfo':\\n          case 'Viewpoint':\\n            // node not supported yet\\n            break;\\n\\n          default:\\n            console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\\n            break;\\n        }\\n\\n        if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\\n          build.name = node.DEF;\\n        }\\n\\n        return build;\\n      }\\n\\n      function buildGroupingNode(node) {\\n        var object = new _three.Group(); //\\n\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'bboxCenter':\\n              // field not supported\\n              break;\\n\\n            case 'bboxSize':\\n              // field not supported\\n              break;\\n\\n            case 'center':\\n              // field not supported\\n              break;\\n\\n            case 'children':\\n              parseFieldChildren(fieldValues, object);\\n              break;\\n\\n            case 'collide':\\n              // field not supported\\n              break;\\n\\n            case 'rotation':\\n              var axis = new _three.Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\\n              var angle = fieldValues[3];\\n              object.quaternion.setFromAxisAngle(axis, angle);\\n              break;\\n\\n            case 'scale':\\n              object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\\n              break;\\n\\n            case 'scaleOrientation':\\n              // field not supported\\n              break;\\n\\n            case 'translation':\\n              object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\\n              break;\\n\\n            case 'proxy':\\n              // field not supported\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        return object;\\n      }\\n\\n      function buildBackgroundNode(node) {\\n        var group = new _three.Group();\\n        var groundAngle, groundColor;\\n        var skyAngle, skyColor;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'groundAngle':\\n              groundAngle = fieldValues;\\n              break;\\n\\n            case 'groundColor':\\n              groundColor = fieldValues;\\n              break;\\n\\n            case 'backUrl':\\n              // field not supported\\n              break;\\n\\n            case 'bottomUrl':\\n              // field not supported\\n              break;\\n\\n            case 'frontUrl':\\n              // field not supported\\n              break;\\n\\n            case 'leftUrl':\\n              // field not supported\\n              break;\\n\\n            case 'rightUrl':\\n              // field not supported\\n              break;\\n\\n            case 'topUrl':\\n              // field not supported\\n              break;\\n\\n            case 'skyAngle':\\n              skyAngle = fieldValues;\\n              break;\\n\\n            case 'skyColor':\\n              skyColor = fieldValues;\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        var radius = 10000; // sky\\n\\n        if (skyColor) {\\n          var skyGeometry = new _three.SphereGeometry(radius, 32, 16);\\n          var skyMaterial = new _three.MeshBasicMaterial({\\n            fog: false,\\n            side: _three.BackSide,\\n            depthWrite: false,\\n            depthTest: false\\n          });\\n\\n          if (skyColor.length > 3) {\\n            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\\n            skyMaterial.vertexColors = true;\\n          } else {\\n            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\\n          }\\n\\n          var sky = new _three.Mesh(skyGeometry, skyMaterial);\\n          group.add(sky);\\n        } // ground\\n\\n\\n        if (groundColor) {\\n          if (groundColor.length > 0) {\\n            var groundGeometry = new _three.SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\\n            var groundMaterial = new _three.MeshBasicMaterial({\\n              fog: false,\\n              side: _three.BackSide,\\n              vertexColors: true,\\n              depthWrite: false,\\n              depthTest: false\\n            });\\n            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\\n            var ground = new _three.Mesh(groundGeometry, groundMaterial);\\n            group.add(ground);\\n          }\\n        } // render background group first\\n\\n\\n        group.renderOrder = -Infinity;\\n        return group;\\n      }\\n\\n      function buildShapeNode(node) {\\n        var fields = node.fields; // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\\n\\n        var material = new _three.MeshBasicMaterial({\\n          color: 0x000000\\n        });\\n        var geometry;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'appearance':\\n              if (fieldValues[0] !== null) {\\n                material = getNode(fieldValues[0]);\\n              }\\n\\n              break;\\n\\n            case 'geometry':\\n              if (fieldValues[0] !== null) {\\n                geometry = getNode(fieldValues[0]);\\n              }\\n\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        } // build 3D object\\n\\n\\n        var object;\\n\\n        if (geometry && geometry.attributes.position) {\\n          var type = geometry._type;\\n\\n          if (type === 'points') {\\n            // points\\n            var pointsMaterial = new _three.PointsMaterial({\\n              color: 0xffffff\\n            });\\n\\n            if (geometry.attributes.color !== undefined) {\\n              pointsMaterial.vertexColors = true;\\n            } else {\\n              // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\\n              if (material.isMeshPhongMaterial) {\\n                pointsMaterial.color.copy(material.emissive);\\n              }\\n            }\\n\\n            object = new _three.Points(geometry, pointsMaterial);\\n          } else if (type === 'line') {\\n            // lines\\n            var lineMaterial = new _three.LineBasicMaterial({\\n              color: 0xffffff\\n            });\\n\\n            if (geometry.attributes.color !== undefined) {\\n              lineMaterial.vertexColors = true;\\n            } else {\\n              // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\\n              if (material.isMeshPhongMaterial) {\\n                lineMaterial.color.copy(material.emissive);\\n              }\\n            }\\n\\n            object = new _three.LineSegments(geometry, lineMaterial);\\n          } else {\\n            // consider meshes\\n            // check \\\"solid\\\" hint (it's placed in the geometry but affects the material)\\n            if (geometry._solid !== undefined) {\\n              material.side = geometry._solid ? _three.FrontSide : _three.DoubleSide;\\n            } // check for vertex colors\\n\\n\\n            if (geometry.attributes.color !== undefined) {\\n              material.vertexColors = true;\\n            }\\n\\n            object = new _three.Mesh(geometry, material);\\n          }\\n        } else {\\n          object = new _three.Object3D(); // if the geometry field is NULL or no vertices are defined the object is not drawn\\n\\n          object.visible = false;\\n        }\\n\\n        return object;\\n      }\\n\\n      function buildAppearanceNode(node) {\\n        var material = new _three.MeshPhongMaterial();\\n        var transformData;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'material':\\n              if (fieldValues[0] !== null) {\\n                var materialData = getNode(fieldValues[0]);\\n                if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\\n                if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\\n                if (materialData.shininess) material.shininess = materialData.shininess;\\n                if (materialData.specularColor) material.specular.copy(materialData.specularColor);\\n                if (materialData.transparency) material.opacity = 1 - materialData.transparency;\\n                if (materialData.transparency > 0) material.transparent = true;\\n              } else {\\n                // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\\n                material = new _three.MeshBasicMaterial({\\n                  color: 0x000000\\n                });\\n              }\\n\\n              break;\\n\\n            case 'texture':\\n              var textureNode = fieldValues[0];\\n\\n              if (textureNode !== null) {\\n                if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\\n                  material.map = getNode(textureNode);\\n                }\\n              }\\n\\n              break;\\n\\n            case 'textureTransform':\\n              if (fieldValues[0] !== null) {\\n                transformData = getNode(fieldValues[0]);\\n              }\\n\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        } // only apply texture transform data if a texture was defined\\n\\n\\n        if (material.map) {\\n          // respect VRML lighting model\\n          if (material.map.__type) {\\n            switch (material.map.__type) {\\n              case TEXTURE_TYPE.INTENSITY_ALPHA:\\n                material.opacity = 1; // ignore transparency\\n\\n                break;\\n\\n              case TEXTURE_TYPE.RGB:\\n                material.color.set(0xffffff); // ignore material color\\n\\n                break;\\n\\n              case TEXTURE_TYPE.RGBA:\\n                material.color.set(0xffffff); // ignore material color\\n\\n                material.opacity = 1; // ignore transparency\\n\\n                break;\\n            }\\n\\n            delete material.map.__type;\\n          } // apply texture transform\\n\\n\\n          if (transformData) {\\n            material.map.center.copy(transformData.center);\\n            material.map.rotation = transformData.rotation;\\n            material.map.repeat.copy(transformData.scale);\\n            material.map.offset.copy(transformData.translation);\\n          }\\n        }\\n\\n        return material;\\n      }\\n\\n      function buildMaterialNode(node) {\\n        var materialData = {};\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'ambientIntensity':\\n              // field not supported\\n              break;\\n\\n            case 'diffuseColor':\\n              materialData.diffuseColor = new _three.Color(fieldValues[0], fieldValues[1], fieldValues[2]);\\n              break;\\n\\n            case 'emissiveColor':\\n              materialData.emissiveColor = new _three.Color(fieldValues[0], fieldValues[1], fieldValues[2]);\\n              break;\\n\\n            case 'shininess':\\n              materialData.shininess = fieldValues[0];\\n              break;\\n\\n            case 'specularColor':\\n              materialData.emissiveColor = new _three.Color(fieldValues[0], fieldValues[1], fieldValues[2]);\\n              break;\\n\\n            case 'transparency':\\n              materialData.transparency = fieldValues[0];\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        return materialData;\\n      }\\n\\n      function parseHexColor(hex, textureType, color) {\\n        var value;\\n\\n        switch (textureType) {\\n          case TEXTURE_TYPE.INTENSITY:\\n            // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\\n            value = parseInt(hex);\\n            color.r = value;\\n            color.g = value;\\n            color.b = value;\\n            break;\\n\\n          case TEXTURE_TYPE.INTENSITY_ALPHA:\\n            // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\\n            value = parseInt('0x' + hex.substring(2, 4));\\n            color.r = value;\\n            color.g = value;\\n            color.b = value;\\n            color.a = parseInt('0x' + hex.substring(4, 6));\\n            break;\\n\\n          case TEXTURE_TYPE.RGB:\\n            // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\\n            color.r = parseInt('0x' + hex.substring(2, 4));\\n            color.g = parseInt('0x' + hex.substring(4, 6));\\n            color.b = parseInt('0x' + hex.substring(6, 8));\\n            break;\\n\\n          case TEXTURE_TYPE.RGBA:\\n            // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\\n            color.r = parseInt('0x' + hex.substring(2, 4));\\n            color.g = parseInt('0x' + hex.substring(4, 6));\\n            color.b = parseInt('0x' + hex.substring(6, 8));\\n            color.a = parseInt('0x' + hex.substring(8, 10));\\n            break;\\n        }\\n      }\\n\\n      function getTextureType(num_components) {\\n        var type;\\n\\n        switch (num_components) {\\n          case 1:\\n            type = TEXTURE_TYPE.INTENSITY;\\n            break;\\n\\n          case 2:\\n            type = TEXTURE_TYPE.INTENSITY_ALPHA;\\n            break;\\n\\n          case 3:\\n            type = TEXTURE_TYPE.RGB;\\n            break;\\n\\n          case 4:\\n            type = TEXTURE_TYPE.RGBA;\\n            break;\\n        }\\n\\n        return type;\\n      }\\n\\n      function buildPixelTextureNode(node) {\\n        var texture;\\n        var wrapS = _three.RepeatWrapping;\\n        var wrapT = _three.RepeatWrapping;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'image':\\n              var width = fieldValues[0];\\n              var height = fieldValues[1];\\n              var num_components = fieldValues[2];\\n              var useAlpha = num_components === 2 || num_components === 4;\\n              var textureType = getTextureType(num_components);\\n              var size = (useAlpha === true ? 4 : 3) * (width * height);\\n\\n              var _data = new Uint8Array(size);\\n\\n              var color = {\\n                r: 0,\\n                g: 0,\\n                b: 0,\\n                a: 0\\n              };\\n\\n              for (var j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\\n                parseHexColor(fieldValues[j], textureType, color);\\n\\n                if (useAlpha === true) {\\n                  var stride = k * 4;\\n                  _data[stride + 0] = color.r;\\n                  _data[stride + 1] = color.g;\\n                  _data[stride + 2] = color.b;\\n                  _data[stride + 3] = color.a;\\n                } else {\\n                  var _stride = k * 3;\\n\\n                  _data[_stride + 0] = color.r;\\n                  _data[_stride + 1] = color.g;\\n                  _data[_stride + 2] = color.b;\\n                }\\n              }\\n\\n              texture = new _three.DataTexture(_data, width, height, useAlpha === true ? _three.RGBAFormat : _three.RGBFormat);\\n              texture.__type = textureType; // needed for material modifications\\n\\n              break;\\n\\n            case 'repeatS':\\n              if (fieldValues[0] === false) wrapS = _three.ClampToEdgeWrapping;\\n              break;\\n\\n            case 'repeatT':\\n              if (fieldValues[0] === false) wrapT = _three.ClampToEdgeWrapping;\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        if (texture) {\\n          texture.wrapS = wrapS;\\n          texture.wrapT = wrapT;\\n        }\\n\\n        return texture;\\n      }\\n\\n      function buildImageTextureNode(node) {\\n        var texture;\\n        var wrapS = _three.RepeatWrapping;\\n        var wrapT = _three.RepeatWrapping;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'url':\\n              var url = fieldValues[0];\\n              if (url) texture = textureLoader.load(url);\\n              break;\\n\\n            case 'repeatS':\\n              if (fieldValues[0] === false) wrapS = _three.ClampToEdgeWrapping;\\n              break;\\n\\n            case 'repeatT':\\n              if (fieldValues[0] === false) wrapT = _three.ClampToEdgeWrapping;\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        if (texture) {\\n          texture.wrapS = wrapS;\\n          texture.wrapT = wrapT;\\n        }\\n\\n        return texture;\\n      }\\n\\n      function buildTextureTransformNode(node) {\\n        var transformData = {\\n          center: new _three.Vector2(),\\n          rotation: new _three.Vector2(),\\n          scale: new _three.Vector2(),\\n          translation: new _three.Vector2()\\n        };\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'center':\\n              transformData.center.set(fieldValues[0], fieldValues[1]);\\n              break;\\n\\n            case 'rotation':\\n              transformData.rotation = fieldValues[0];\\n              break;\\n\\n            case 'scale':\\n              transformData.scale.set(fieldValues[0], fieldValues[1]);\\n              break;\\n\\n            case 'translation':\\n              transformData.translation.set(fieldValues[0], fieldValues[1]);\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        return transformData;\\n      }\\n\\n      function buildGeometricNode(node) {\\n        return node.fields[0].values;\\n      }\\n\\n      function buildWorldInfoNode(node) {\\n        var worldInfo = {};\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'title':\\n              worldInfo.title = fieldValues[0];\\n              break;\\n\\n            case 'info':\\n              worldInfo.info = fieldValues;\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        return worldInfo;\\n      }\\n\\n      function buildIndexedFaceSetNode(node) {\\n        var color, coord, normal, texCoord;\\n        var ccw = true,\\n            solid = true,\\n            creaseAngle = 0;\\n        var colorIndex, coordIndex, normalIndex, texCoordIndex;\\n        var colorPerVertex = true,\\n            normalPerVertex = true;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'color':\\n              var colorNode = fieldValues[0];\\n\\n              if (colorNode !== null) {\\n                color = getNode(colorNode);\\n              }\\n\\n              break;\\n\\n            case 'coord':\\n              var coordNode = fieldValues[0];\\n\\n              if (coordNode !== null) {\\n                coord = getNode(coordNode);\\n              }\\n\\n              break;\\n\\n            case 'normal':\\n              var normalNode = fieldValues[0];\\n\\n              if (normalNode !== null) {\\n                normal = getNode(normalNode);\\n              }\\n\\n              break;\\n\\n            case 'texCoord':\\n              var texCoordNode = fieldValues[0];\\n\\n              if (texCoordNode !== null) {\\n                texCoord = getNode(texCoordNode);\\n              }\\n\\n              break;\\n\\n            case 'ccw':\\n              ccw = fieldValues[0];\\n              break;\\n\\n            case 'colorIndex':\\n              colorIndex = fieldValues;\\n              break;\\n\\n            case 'colorPerVertex':\\n              colorPerVertex = fieldValues[0];\\n              break;\\n\\n            case 'convex':\\n              // field not supported\\n              break;\\n\\n            case 'coordIndex':\\n              coordIndex = fieldValues;\\n              break;\\n\\n            case 'creaseAngle':\\n              creaseAngle = fieldValues[0];\\n              break;\\n\\n            case 'normalIndex':\\n              normalIndex = fieldValues;\\n              break;\\n\\n            case 'normalPerVertex':\\n              normalPerVertex = fieldValues[0];\\n              break;\\n\\n            case 'solid':\\n              solid = fieldValues[0];\\n              break;\\n\\n            case 'texCoordIndex':\\n              texCoordIndex = fieldValues;\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        if (coordIndex === undefined) {\\n          console.warn('THREE.VRMLLoader: Missing coordIndex.');\\n          return new _three.BufferGeometry(); // handle VRML files with incomplete geometry definition\\n        }\\n\\n        var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\\n        var colorAttribute;\\n        var normalAttribute;\\n        var uvAttribute;\\n\\n        if (color) {\\n          if (colorPerVertex === true) {\\n            if (colorIndex && colorIndex.length > 0) {\\n              // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\\n              var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\\n              colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\\n            } else {\\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\\n              colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new _three.Float32BufferAttribute(color, 3));\\n            }\\n          } else {\\n            if (colorIndex && colorIndex.length > 0) {\\n              // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\\n              var flattenFaceColors = flattenData(color, colorIndex);\\n              var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\\n            } else {\\n              // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\\n              var _triangulatedFaceColors = triangulateFaceData(color, coordIndex);\\n\\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceColors);\\n            }\\n          }\\n        }\\n\\n        if (normal) {\\n          if (normalPerVertex === true) {\\n            // consider vertex normals\\n            if (normalIndex && normalIndex.length > 0) {\\n              // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\\n              var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\\n              normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\\n            } else {\\n              // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\\n              normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new _three.Float32BufferAttribute(normal, 3));\\n            }\\n          } else {\\n            // consider face normals\\n            if (normalIndex && normalIndex.length > 0) {\\n              // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\\n              var flattenFaceNormals = flattenData(normal, normalIndex);\\n              var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\\n            } else {\\n              // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\\n              var _triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\\n\\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceNormals);\\n            }\\n          }\\n        } else {\\n          // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\\n          normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\\n        }\\n\\n        if (texCoord) {\\n          // texture coordinates are always defined on vertex level\\n          if (texCoordIndex && texCoordIndex.length > 0) {\\n            // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\\n            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\\n            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\\n          } else {\\n            // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\\n            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new _three.Float32BufferAttribute(texCoord, 2));\\n          }\\n        }\\n\\n        var geometry = new _three.BufferGeometry();\\n        var positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new _three.Float32BufferAttribute(coord, 3));\\n        geometry.setAttribute('position', positionAttribute);\\n        geometry.setAttribute('normal', normalAttribute); // optional attributes\\n\\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\\n        if (uvAttribute) geometry.setAttribute('uv', uvAttribute); // \\\"solid\\\" influences the material so let's store it for later use\\n\\n        geometry._solid = solid;\\n        geometry._type = 'mesh';\\n        return geometry;\\n      }\\n\\n      function buildIndexedLineSetNode(node) {\\n        var color, coord;\\n        var colorIndex, coordIndex;\\n        var colorPerVertex = true;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'color':\\n              var colorNode = fieldValues[0];\\n\\n              if (colorNode !== null) {\\n                color = getNode(colorNode);\\n              }\\n\\n              break;\\n\\n            case 'coord':\\n              var coordNode = fieldValues[0];\\n\\n              if (coordNode !== null) {\\n                coord = getNode(coordNode);\\n              }\\n\\n              break;\\n\\n            case 'colorIndex':\\n              colorIndex = fieldValues;\\n              break;\\n\\n            case 'colorPerVertex':\\n              colorPerVertex = fieldValues[0];\\n              break;\\n\\n            case 'coordIndex':\\n              coordIndex = fieldValues;\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        } // build lines\\n\\n\\n        var colorAttribute;\\n        var expandedLineIndex = expandLineIndex(coordIndex); // create an index for three.js's linesegment primitive\\n\\n        if (color) {\\n          if (colorPerVertex === true) {\\n            if (colorIndex.length > 0) {\\n              // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\\n              var expandedColorIndex = expandLineIndex(colorIndex); // compute colors for each line segment (rendering primitve)\\n\\n              colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3); // compute data on vertex level\\n            } else {\\n              // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\\n              colorAttribute = toNonIndexedAttribute(expandedLineIndex, new _three.Float32BufferAttribute(color, 3));\\n            }\\n          } else {\\n            if (colorIndex.length > 0) {\\n              // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\\n              var flattenLineColors = flattenData(color, colorIndex); // compute colors for each VRML primitve\\n\\n              var expandedLineColors = expandLineData(flattenLineColors, coordIndex); // compute colors for each line segment (rendering primitve)\\n\\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors); // compute data on vertex level\\n            } else {\\n              // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\\n              var _expandedLineColors = expandLineData(color, coordIndex); // compute colors for each line segment (rendering primitve)\\n\\n\\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, _expandedLineColors); // compute data on vertex level\\n            }\\n          }\\n        } //\\n\\n\\n        var geometry = new _three.BufferGeometry();\\n        var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new _three.Float32BufferAttribute(coord, 3));\\n        geometry.setAttribute('position', positionAttribute);\\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute);\\n        geometry._type = 'line';\\n        return geometry;\\n      }\\n\\n      function buildPointSetNode(node) {\\n        var color, coord;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'color':\\n              var colorNode = fieldValues[0];\\n\\n              if (colorNode !== null) {\\n                color = getNode(colorNode);\\n              }\\n\\n              break;\\n\\n            case 'coord':\\n              var coordNode = fieldValues[0];\\n\\n              if (coordNode !== null) {\\n                coord = getNode(coordNode);\\n              }\\n\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        var geometry = new _three.BufferGeometry();\\n        geometry.setAttribute('position', new _three.Float32BufferAttribute(coord, 3));\\n        if (color) geometry.setAttribute('color', new _three.Float32BufferAttribute(color, 3));\\n        geometry._type = 'points';\\n        return geometry;\\n      }\\n\\n      function buildBoxNode(node) {\\n        var size = new _three.Vector3(2, 2, 2);\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'size':\\n              size.x = fieldValues[0];\\n              size.y = fieldValues[1];\\n              size.z = fieldValues[2];\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        var geometry = new _three.BoxGeometry(size.x, size.y, size.z);\\n        return geometry;\\n      }\\n\\n      function buildConeNode(node) {\\n        var radius = 1,\\n            height = 2,\\n            openEnded = false;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'bottom':\\n              openEnded = !fieldValues[0];\\n              break;\\n\\n            case 'bottomRadius':\\n              radius = fieldValues[0];\\n              break;\\n\\n            case 'height':\\n              height = fieldValues[0];\\n              break;\\n\\n            case 'side':\\n              // field not supported\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        var geometry = new _three.ConeGeometry(radius, height, 16, 1, openEnded);\\n        return geometry;\\n      }\\n\\n      function buildCylinderNode(node) {\\n        var radius = 1,\\n            height = 2;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'bottom':\\n              // field not supported\\n              break;\\n\\n            case 'radius':\\n              radius = fieldValues[0];\\n              break;\\n\\n            case 'height':\\n              height = fieldValues[0];\\n              break;\\n\\n            case 'side':\\n              // field not supported\\n              break;\\n\\n            case 'top':\\n              // field not supported\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        var geometry = new _three.CylinderGeometry(radius, radius, height, 16, 1);\\n        return geometry;\\n      }\\n\\n      function buildSphereNode(node) {\\n        var radius = 1;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'radius':\\n              radius = fieldValues[0];\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        var geometry = new _three.SphereGeometry(radius, 16, 16);\\n        return geometry;\\n      }\\n\\n      function buildElevationGridNode(node) {\\n        var color;\\n        var normal;\\n        var texCoord;\\n        var height;\\n        var colorPerVertex = true;\\n        var normalPerVertex = true;\\n        var solid = true;\\n        var ccw = true;\\n        var creaseAngle = 0;\\n        var xDimension = 2;\\n        var zDimension = 2;\\n        var xSpacing = 1;\\n        var zSpacing = 1;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'color':\\n              var colorNode = fieldValues[0];\\n\\n              if (colorNode !== null) {\\n                color = getNode(colorNode);\\n              }\\n\\n              break;\\n\\n            case 'normal':\\n              var normalNode = fieldValues[0];\\n\\n              if (normalNode !== null) {\\n                normal = getNode(normalNode);\\n              }\\n\\n              break;\\n\\n            case 'texCoord':\\n              var texCoordNode = fieldValues[0];\\n\\n              if (texCoordNode !== null) {\\n                texCoord = getNode(texCoordNode);\\n              }\\n\\n              break;\\n\\n            case 'height':\\n              height = fieldValues;\\n              break;\\n\\n            case 'ccw':\\n              ccw = fieldValues[0];\\n              break;\\n\\n            case 'colorPerVertex':\\n              colorPerVertex = fieldValues[0];\\n              break;\\n\\n            case 'creaseAngle':\\n              creaseAngle = fieldValues[0];\\n              break;\\n\\n            case 'normalPerVertex':\\n              normalPerVertex = fieldValues[0];\\n              break;\\n\\n            case 'solid':\\n              solid = fieldValues[0];\\n              break;\\n\\n            case 'xDimension':\\n              xDimension = fieldValues[0];\\n              break;\\n\\n            case 'xSpacing':\\n              xSpacing = fieldValues[0];\\n              break;\\n\\n            case 'zDimension':\\n              zDimension = fieldValues[0];\\n              break;\\n\\n            case 'zSpacing':\\n              zSpacing = fieldValues[0];\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        } // vertex data\\n\\n\\n        var vertices = [];\\n        var normals = [];\\n        var colors = [];\\n        var uvs = [];\\n\\n        for (var _i9 = 0; _i9 < zDimension; _i9++) {\\n          for (var j = 0; j < xDimension; j++) {\\n            // compute a row major index\\n            var index = _i9 * xDimension + j; // vertices\\n\\n            var x = xSpacing * _i9;\\n            var y = height[index];\\n            var z = zSpacing * j;\\n            vertices.push(x, y, z); // colors\\n\\n            if (color && colorPerVertex === true) {\\n              var r = color[index * 3 + 0];\\n              var g = color[index * 3 + 1];\\n              var b = color[index * 3 + 2];\\n              colors.push(r, g, b);\\n            } // normals\\n\\n\\n            if (normal && normalPerVertex === true) {\\n              var xn = normal[index * 3 + 0];\\n              var yn = normal[index * 3 + 1];\\n              var zn = normal[index * 3 + 2];\\n              normals.push(xn, yn, zn);\\n            } // uvs\\n\\n\\n            if (texCoord) {\\n              var s = texCoord[index * 2 + 0];\\n              var t = texCoord[index * 2 + 1];\\n              uvs.push(s, t);\\n            } else {\\n              uvs.push(_i9 / (xDimension - 1), j / (zDimension - 1));\\n            }\\n          }\\n        } // indices\\n\\n\\n        var indices = [];\\n\\n        for (var _i10 = 0; _i10 < xDimension - 1; _i10++) {\\n          for (var _j = 0; _j < zDimension - 1; _j++) {\\n            // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\\n            var a = _i10 + _j * xDimension;\\n\\n            var _b = _i10 + (_j + 1) * xDimension;\\n\\n            var c = _i10 + 1 + (_j + 1) * xDimension;\\n            var d = _i10 + 1 + _j * xDimension; // faces\\n\\n            if (ccw === true) {\\n              indices.push(a, c, _b);\\n              indices.push(c, a, d);\\n            } else {\\n              indices.push(a, _b, c);\\n              indices.push(c, d, a);\\n            }\\n          }\\n        } //\\n\\n\\n        var positionAttribute = toNonIndexedAttribute(indices, new _three.Float32BufferAttribute(vertices, 3));\\n        var uvAttribute = toNonIndexedAttribute(indices, new _three.Float32BufferAttribute(uvs, 2));\\n        var colorAttribute;\\n        var normalAttribute; // color attribute\\n\\n        if (color) {\\n          if (colorPerVertex === false) {\\n            for (var _i11 = 0; _i11 < xDimension - 1; _i11++) {\\n              for (var _j2 = 0; _j2 < zDimension - 1; _j2++) {\\n                var _index = _i11 + _j2 * (xDimension - 1);\\n\\n                var _r = color[_index * 3 + 0];\\n                var _g = color[_index * 3 + 1];\\n                var _b2 = color[_index * 3 + 2]; // one color per quad\\n\\n                colors.push(_r, _g, _b2);\\n                colors.push(_r, _g, _b2);\\n                colors.push(_r, _g, _b2);\\n                colors.push(_r, _g, _b2);\\n                colors.push(_r, _g, _b2);\\n                colors.push(_r, _g, _b2);\\n              }\\n            }\\n\\n            colorAttribute = new _three.Float32BufferAttribute(colors, 3);\\n          } else {\\n            colorAttribute = toNonIndexedAttribute(indices, new _three.Float32BufferAttribute(colors, 3));\\n          }\\n        } // normal attribute\\n\\n\\n        if (normal) {\\n          if (normalPerVertex === false) {\\n            for (var _i12 = 0; _i12 < xDimension - 1; _i12++) {\\n              for (var _j3 = 0; _j3 < zDimension - 1; _j3++) {\\n                var _index2 = _i12 + _j3 * (xDimension - 1);\\n\\n                var _xn = normal[_index2 * 3 + 0];\\n                var _yn = normal[_index2 * 3 + 1];\\n                var _zn = normal[_index2 * 3 + 2]; // one normal per quad\\n\\n                normals.push(_xn, _yn, _zn);\\n                normals.push(_xn, _yn, _zn);\\n                normals.push(_xn, _yn, _zn);\\n                normals.push(_xn, _yn, _zn);\\n                normals.push(_xn, _yn, _zn);\\n                normals.push(_xn, _yn, _zn);\\n              }\\n            }\\n\\n            normalAttribute = new _three.Float32BufferAttribute(normals, 3);\\n          } else {\\n            normalAttribute = toNonIndexedAttribute(indices, new _three.Float32BufferAttribute(normals, 3));\\n          }\\n        } else {\\n          normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\\n        } // build geometry\\n\\n\\n        var geometry = new _three.BufferGeometry();\\n        geometry.setAttribute('position', positionAttribute);\\n        geometry.setAttribute('normal', normalAttribute);\\n        geometry.setAttribute('uv', uvAttribute);\\n        if (colorAttribute) geometry.setAttribute('color', colorAttribute); // \\\"solid\\\" influences the material so let's store it for later use\\n\\n        geometry._solid = solid;\\n        geometry._type = 'mesh';\\n        return geometry;\\n      }\\n\\n      function buildExtrusionNode(node) {\\n        var crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\\n        var spine = [0, 0, 0, 0, 1, 0];\\n        var scale;\\n        var orientation;\\n        var beginCap = true;\\n        var ccw = true;\\n        var creaseAngle = 0;\\n        var endCap = true;\\n        var solid = true;\\n        var fields = node.fields;\\n\\n        for (var i = 0, l = fields.length; i < l; i++) {\\n          var field = fields[i];\\n          var fieldName = field.name;\\n          var fieldValues = field.values;\\n\\n          switch (fieldName) {\\n            case 'beginCap':\\n              beginCap = fieldValues[0];\\n              break;\\n\\n            case 'ccw':\\n              ccw = fieldValues[0];\\n              break;\\n\\n            case 'convex':\\n              // field not supported\\n              break;\\n\\n            case 'creaseAngle':\\n              creaseAngle = fieldValues[0];\\n              break;\\n\\n            case 'crossSection':\\n              crossSection = fieldValues;\\n              break;\\n\\n            case 'endCap':\\n              endCap = fieldValues[0];\\n              break;\\n\\n            case 'orientation':\\n              orientation = fieldValues;\\n              break;\\n\\n            case 'scale':\\n              scale = fieldValues;\\n              break;\\n\\n            case 'solid':\\n              solid = fieldValues[0];\\n              break;\\n\\n            case 'spine':\\n              spine = fieldValues; // only extrusion along the Y-axis are supported so far\\n\\n              break;\\n\\n            default:\\n              console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\\n              break;\\n          }\\n        }\\n\\n        var crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1]; // vertices\\n\\n        var vertices = [];\\n        var spineVector = new _three.Vector3();\\n        var scaling = new _three.Vector3();\\n        var axis = new _three.Vector3();\\n        var vertex = new _three.Vector3();\\n        var quaternion = new _three.Quaternion();\\n\\n        for (var _i13 = 0, j = 0, o = 0, il = spine.length; _i13 < il; _i13 += 3, j += 2, o += 4) {\\n          spineVector.fromArray(spine, _i13);\\n          scaling.x = scale ? scale[j + 0] : 1;\\n          scaling.y = 1;\\n          scaling.z = scale ? scale[j + 1] : 1;\\n          axis.x = orientation ? orientation[o + 0] : 0;\\n          axis.y = orientation ? orientation[o + 1] : 0;\\n          axis.z = orientation ? orientation[o + 2] : 1;\\n          var angle = orientation ? orientation[o + 3] : 0;\\n\\n          for (var k = 0, kl = crossSection.length; k < kl; k += 2) {\\n            vertex.x = crossSection[k + 0];\\n            vertex.y = 0;\\n            vertex.z = crossSection[k + 1]; // scale\\n\\n            vertex.multiply(scaling); // rotate\\n\\n            quaternion.setFromAxisAngle(axis, angle);\\n            vertex.applyQuaternion(quaternion); // translate\\n\\n            vertex.add(spineVector);\\n            vertices.push(vertex.x, vertex.y, vertex.z);\\n          }\\n        } // indices\\n\\n\\n        var indices = [];\\n        var spineCount = spine.length / 3;\\n        var crossSectionCount = crossSection.length / 2;\\n\\n        for (var _i14 = 0; _i14 < spineCount - 1; _i14++) {\\n          for (var _j4 = 0; _j4 < crossSectionCount - 1; _j4++) {\\n            var a = _j4 + _i14 * crossSectionCount;\\n            var b = _j4 + 1 + _i14 * crossSectionCount;\\n            var c = _j4 + (_i14 + 1) * crossSectionCount;\\n            var d = _j4 + 1 + (_i14 + 1) * crossSectionCount;\\n\\n            if (_j4 === crossSectionCount - 2 && crossSectionClosed === true) {\\n              b = _i14 * crossSectionCount;\\n              d = (_i14 + 1) * crossSectionCount;\\n            }\\n\\n            if (ccw === true) {\\n              indices.push(a, b, c);\\n              indices.push(c, b, d);\\n            } else {\\n              indices.push(a, c, b);\\n              indices.push(c, d, b);\\n            }\\n          }\\n        } // triangulate cap\\n\\n\\n        if (beginCap === true || endCap === true) {\\n          var contour = [];\\n\\n          for (var _i15 = 0, _l9 = crossSection.length; _i15 < _l9; _i15 += 2) {\\n            contour.push(new _three.Vector2(crossSection[_i15], crossSection[_i15 + 1]));\\n          }\\n\\n          var faces = _three.ShapeUtils.triangulateShape(contour, []);\\n\\n          var capIndices = [];\\n\\n          for (var _i16 = 0, _l10 = faces.length; _i16 < _l10; _i16++) {\\n            var face = faces[_i16];\\n            capIndices.push(face[0], face[1], face[2]);\\n          } // begin cap\\n\\n\\n          if (beginCap === true) {\\n            for (var _i17 = 0, _l11 = capIndices.length; _i17 < _l11; _i17 += 3) {\\n              if (ccw === true) {\\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 1], capIndices[_i17 + 2]);\\n              } else {\\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 2], capIndices[_i17 + 1]);\\n              }\\n            }\\n          } // end cap\\n\\n\\n          if (endCap === true) {\\n            var indexOffset = crossSectionCount * (spineCount - 1); // references to the first vertex of the last cross section\\n\\n            for (var _i18 = 0, _l12 = capIndices.length; _i18 < _l12; _i18 += 3) {\\n              if (ccw === true) {\\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 2], indexOffset + capIndices[_i18 + 1]);\\n              } else {\\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 1], indexOffset + capIndices[_i18 + 2]);\\n              }\\n            }\\n          }\\n        }\\n\\n        var positionAttribute = toNonIndexedAttribute(indices, new _three.Float32BufferAttribute(vertices, 3));\\n        var normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\\n        var geometry = new _three.BufferGeometry();\\n        geometry.setAttribute('position', positionAttribute);\\n        geometry.setAttribute('normal', normalAttribute); // no uvs yet\\n        // \\\"solid\\\" influences the material so let's store it for later use\\n\\n        geometry._solid = solid;\\n        geometry._type = 'mesh';\\n        return geometry;\\n      } // helper functions\\n\\n\\n      function resolveUSE(identifier) {\\n        var node = nodeMap[identifier];\\n        var build = getNode(node); // because the same 3D objects can have different transformations, it's necessary to clone them.\\n        // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\\n        // any side effects\\n\\n        return build.isObject3D || build.isMaterial ? build.clone() : build;\\n      }\\n\\n      function parseFieldChildren(children, owner) {\\n        for (var i = 0, l = children.length; i < l; i++) {\\n          var object = getNode(children[i]);\\n          if (object instanceof _three.Object3D) owner.add(object);\\n        }\\n      }\\n\\n      function triangulateFaceIndex(index, ccw) {\\n        var indices = []; // since face defintions can have more than three vertices, it's necessary to\\n        // perform a simple triangulation\\n\\n        var start = 0;\\n\\n        for (var i = 0, l = index.length; i < l; i++) {\\n          var i1 = index[start];\\n          var i2 = index[i + (ccw ? 1 : 2)];\\n          var i3 = index[i + (ccw ? 2 : 1)];\\n          indices.push(i1, i2, i3); // an index of -1 indicates that the current face has ended and the next one begins\\n\\n          if (index[i + 3] === -1 || i + 3 >= l) {\\n            i += 3;\\n            start = i + 1;\\n          }\\n        }\\n\\n        return indices;\\n      }\\n\\n      function triangulateFaceData(data, index) {\\n        var triangulatedData = [];\\n        var start = 0;\\n\\n        for (var i = 0, l = index.length; i < l; i++) {\\n          var stride = start * 3;\\n          var x = data[stride];\\n          var y = data[stride + 1];\\n          var z = data[stride + 2];\\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current face has ended and the next one begins\\n\\n          if (index[i + 3] === -1 || i + 3 >= l) {\\n            i += 3;\\n            start++;\\n          }\\n        }\\n\\n        return triangulatedData;\\n      }\\n\\n      function flattenData(data, index) {\\n        var flattenData = [];\\n\\n        for (var i = 0, l = index.length; i < l; i++) {\\n          var i1 = index[i];\\n          var stride = i1 * 3;\\n          var x = data[stride];\\n          var y = data[stride + 1];\\n          var z = data[stride + 2];\\n          flattenData.push(x, y, z);\\n        }\\n\\n        return flattenData;\\n      }\\n\\n      function expandLineIndex(index) {\\n        var indices = [];\\n\\n        for (var i = 0, l = index.length; i < l; i++) {\\n          var i1 = index[i];\\n          var i2 = index[i + 1];\\n          indices.push(i1, i2); // an index of -1 indicates that the current line has ended and the next one begins\\n\\n          if (index[i + 2] === -1 || i + 2 >= l) {\\n            i += 2;\\n          }\\n        }\\n\\n        return indices;\\n      }\\n\\n      function expandLineData(data, index) {\\n        var triangulatedData = [];\\n        var start = 0;\\n\\n        for (var i = 0, l = index.length; i < l; i++) {\\n          var stride = start * 3;\\n          var x = data[stride];\\n          var y = data[stride + 1];\\n          var z = data[stride + 2];\\n          triangulatedData.push(x, y, z); // an index of -1 indicates that the current line has ended and the next one begins\\n\\n          if (index[i + 2] === -1 || i + 2 >= l) {\\n            i += 2;\\n            start++;\\n          }\\n        }\\n\\n        return triangulatedData;\\n      }\\n\\n      var vA = new _three.Vector3();\\n      var vB = new _three.Vector3();\\n      var vC = new _three.Vector3();\\n      var uvA = new _three.Vector2();\\n      var uvB = new _three.Vector2();\\n      var uvC = new _three.Vector2();\\n\\n      function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\\n        var array = []; // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\\n\\n        for (var i = 0, l = coordIndex.length; i < l; i += 3) {\\n          var a = index[i];\\n          var b = index[i + 1];\\n          var c = index[i + 2];\\n\\n          if (itemSize === 2) {\\n            uvA.fromArray(data, a * itemSize);\\n            uvB.fromArray(data, b * itemSize);\\n            uvC.fromArray(data, c * itemSize);\\n            array.push(uvA.x, uvA.y);\\n            array.push(uvB.x, uvB.y);\\n            array.push(uvC.x, uvC.y);\\n          } else {\\n            vA.fromArray(data, a * itemSize);\\n            vB.fromArray(data, b * itemSize);\\n            vC.fromArray(data, c * itemSize);\\n            array.push(vA.x, vA.y, vA.z);\\n            array.push(vB.x, vB.y, vB.z);\\n            array.push(vC.x, vC.y, vC.z);\\n          }\\n        }\\n\\n        return new _three.Float32BufferAttribute(array, itemSize);\\n      }\\n\\n      function computeAttributeFromFaceData(index, faceData) {\\n        var array = [];\\n\\n        for (var i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\\n          vA.fromArray(faceData, j * 3);\\n          array.push(vA.x, vA.y, vA.z);\\n          array.push(vA.x, vA.y, vA.z);\\n          array.push(vA.x, vA.y, vA.z);\\n        }\\n\\n        return new _three.Float32BufferAttribute(array, 3);\\n      }\\n\\n      function computeAttributeFromLineData(index, lineData) {\\n        var array = [];\\n\\n        for (var i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\\n          vA.fromArray(lineData, j * 3);\\n          array.push(vA.x, vA.y, vA.z);\\n          array.push(vA.x, vA.y, vA.z);\\n        }\\n\\n        return new _three.Float32BufferAttribute(array, 3);\\n      }\\n\\n      function toNonIndexedAttribute(indices, attribute) {\\n        var array = attribute.array;\\n        var itemSize = attribute.itemSize;\\n        var array2 = new array.constructor(indices.length * itemSize);\\n        var index = 0,\\n            index2 = 0;\\n\\n        for (var i = 0, l = indices.length; i < l; i++) {\\n          index = indices[i] * itemSize;\\n\\n          for (var j = 0; j < itemSize; j++) {\\n            array2[index2++] = array[index++];\\n          }\\n        }\\n\\n        return new _three.Float32BufferAttribute(array2, itemSize);\\n      }\\n\\n      var ab = new _three.Vector3();\\n      var cb = new _three.Vector3();\\n\\n      function computeNormalAttribute(index, coord, creaseAngle) {\\n        var faces = [];\\n        var vertexNormals = {}; // prepare face and raw vertex normals\\n\\n        for (var i = 0, l = index.length; i < l; i += 3) {\\n          var a = index[i];\\n          var b = index[i + 1];\\n          var c = index[i + 2];\\n          var face = new Face(a, b, c);\\n          vA.fromArray(coord, a * 3);\\n          vB.fromArray(coord, b * 3);\\n          vC.fromArray(coord, c * 3);\\n          cb.subVectors(vC, vB);\\n          ab.subVectors(vA, vB);\\n          cb.cross(ab);\\n          cb.normalize();\\n          face.normal.copy(cb);\\n          if (vertexNormals[a] === undefined) vertexNormals[a] = [];\\n          if (vertexNormals[b] === undefined) vertexNormals[b] = [];\\n          if (vertexNormals[c] === undefined) vertexNormals[c] = [];\\n          vertexNormals[a].push(face.normal);\\n          vertexNormals[b].push(face.normal);\\n          vertexNormals[c].push(face.normal);\\n          faces.push(face);\\n        } // compute vertex normals and build final geometry\\n\\n\\n        var normals = [];\\n\\n        for (var _i19 = 0, _l13 = faces.length; _i19 < _l13; _i19++) {\\n          var _face = faces[_i19];\\n          var nA = weightedNormal(vertexNormals[_face.a], _face.normal, creaseAngle);\\n          var nB = weightedNormal(vertexNormals[_face.b], _face.normal, creaseAngle);\\n          var nC = weightedNormal(vertexNormals[_face.c], _face.normal, creaseAngle);\\n          vA.fromArray(coord, _face.a * 3);\\n          vB.fromArray(coord, _face.b * 3);\\n          vC.fromArray(coord, _face.c * 3);\\n          normals.push(nA.x, nA.y, nA.z);\\n          normals.push(nB.x, nB.y, nB.z);\\n          normals.push(nC.x, nC.y, nC.z);\\n        }\\n\\n        return new _three.Float32BufferAttribute(normals, 3);\\n      }\\n\\n      function weightedNormal(normals, vector, creaseAngle) {\\n        var normal = new _three.Vector3();\\n\\n        if (creaseAngle === 0) {\\n          normal.copy(vector);\\n        } else {\\n          for (var i = 0, l = normals.length; i < l; i++) {\\n            if (normals[i].angleTo(vector) < creaseAngle) {\\n              normal.add(normals[i]);\\n            }\\n          }\\n        }\\n\\n        return normal.normalize();\\n      }\\n\\n      function toColorArray(colors) {\\n        var array = [];\\n\\n        for (var i = 0, l = colors.length; i < l; i += 3) {\\n          array.push(new _three.Color(colors[i], colors[i + 1], colors[i + 2]));\\n        }\\n\\n        return array;\\n      }\\n      /**\\n       * Vertically paints the faces interpolating between the\\n       * specified colors at the specified angels. This is used for the Background\\n       * node, but could be applied to other nodes with multiple faces as well.\\n       *\\n       * When used with the Background node, default is directionIsDown is true if\\n       * interpolating the skyColor down from the Zenith. When interpolationg up from\\n       * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\\n       *\\n       * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\\n       * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\\n       * is linear along the Y axis in any case.\\n       *\\n       * You must specify one more color than you have angles at the beginning of the colors array.\\n       * This is the color of the Zenith (the top of the shape).\\n       *\\n       * @param {BufferGeometry} geometry\\n       * @param {number} radius\\n       * @param {array} angles\\n       * @param {array} colors\\n       * @param {boolean} topDown - Whether to work top down or bottom up.\\n       */\\n\\n\\n      function paintFaces(geometry, radius, angles, colors, topDown) {\\n        // compute threshold values\\n        var thresholds = [];\\n        var startAngle = topDown === true ? 0 : Math.PI;\\n\\n        for (var i = 0, l = colors.length; i < l; i++) {\\n          var angle = i === 0 ? 0 : angles[i - 1];\\n          angle = topDown === true ? angle : startAngle - angle;\\n          var point = new _three.Vector3();\\n          point.setFromSphericalCoords(radius, angle, 0);\\n          thresholds.push(point);\\n        } // generate vertex colors\\n\\n\\n        var indices = geometry.index;\\n        var positionAttribute = geometry.attributes.position;\\n        var colorAttribute = new _three.BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\\n        var position = new _three.Vector3();\\n        var color = new _three.Color();\\n\\n        for (var _i20 = 0; _i20 < indices.count; _i20++) {\\n          var index = indices.getX(_i20);\\n          position.fromBufferAttribute(positionAttribute, index);\\n          var thresholdIndexA = void 0,\\n              thresholdIndexB = void 0;\\n          var t = 1;\\n\\n          for (var j = 1; j < thresholds.length; j++) {\\n            thresholdIndexA = j - 1;\\n            thresholdIndexB = j;\\n            var thresholdA = thresholds[thresholdIndexA];\\n            var thresholdB = thresholds[thresholdIndexB];\\n\\n            if (topDown === true) {\\n              // interpolation for sky color\\n              if (position.y <= thresholdA.y && position.y > thresholdB.y) {\\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\\n                break;\\n              }\\n            } else {\\n              // interpolation for ground color\\n              if (position.y >= thresholdA.y && position.y < thresholdB.y) {\\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\\n                break;\\n              }\\n            }\\n          }\\n\\n          var colorA = colors[thresholdIndexA];\\n          var colorB = colors[thresholdIndexB];\\n          color.copy(colorA).lerp(colorB, t);\\n          colorAttribute.setXYZ(index, color.r, color.g, color.b);\\n        }\\n\\n        geometry.setAttribute('color', colorAttribute);\\n      } //\\n\\n\\n      var textureLoader = new _three.TextureLoader(this.manager);\\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin); // check version (only 2.0 is supported)\\n\\n      if (data.indexOf('#VRML V2.0') === -1) {\\n        throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\\n      } // create JSON representing the tree structure of the VRML asset\\n\\n\\n      var tree = generateVRMLTree(data); // parse the tree structure to a three.js scene\\n\\n      var scene = parseTree(tree);\\n      return scene;\\n    }\\n  }]);\\n\\n  return VRMLLoader;\\n}(_three.Loader);\\n\\nexports.VRMLLoader = VRMLLoader;\\n\\nvar VRMLLexer =\\n/*#__PURE__*/\\nfunction () {\\n  function VRMLLexer(tokens) {\\n    _classCallCheck(this, VRMLLexer);\\n\\n    this.lexer = new _chevrotain.Lexer(tokens); // eslint-disable-line no-undef\\n  }\\n\\n  _createClass(VRMLLexer, [{\\n    key: \\\"lex\\\",\\n    value: function lex(inputText) {\\n      var lexingResult = this.lexer.tokenize(inputText);\\n\\n      if (lexingResult.errors.length > 0) {\\n        console.error(lexingResult.errors);\\n        throw Error('THREE.VRMLLexer: Lexing errors detected.');\\n      }\\n\\n      return lexingResult;\\n    }\\n  }]);\\n\\n  return VRMLLexer;\\n}();\\n\\nvar VRMLParser =\\n/*#__PURE__*/\\nfunction (_CstParser) {\\n  _inherits(VRMLParser, _CstParser);\\n\\n  function VRMLParser(tokenVocabulary) {\\n    var _this;\\n\\n    _classCallCheck(this, VRMLParser);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(VRMLParser).call(this, tokenVocabulary));\\n\\n    var $ = _assertThisInitialized(_this);\\n\\n    var Version = tokenVocabulary['Version'];\\n    var LCurly = tokenVocabulary['LCurly'];\\n    var RCurly = tokenVocabulary['RCurly'];\\n    var LSquare = tokenVocabulary['LSquare'];\\n    var RSquare = tokenVocabulary['RSquare'];\\n    var Identifier = tokenVocabulary['Identifier'];\\n    var RouteIdentifier = tokenVocabulary['RouteIdentifier'];\\n    var StringLiteral = tokenVocabulary['StringLiteral'];\\n    var HexLiteral = tokenVocabulary['HexLiteral'];\\n    var NumberLiteral = tokenVocabulary['NumberLiteral'];\\n    var TrueLiteral = tokenVocabulary['TrueLiteral'];\\n    var FalseLiteral = tokenVocabulary['FalseLiteral'];\\n    var NullLiteral = tokenVocabulary['NullLiteral'];\\n    var DEF = tokenVocabulary['DEF'];\\n    var USE = tokenVocabulary['USE'];\\n    var ROUTE = tokenVocabulary['ROUTE'];\\n    var TO = tokenVocabulary['TO'];\\n    var NodeName = tokenVocabulary['NodeName'];\\n    $.RULE('vrml', function () {\\n      $.SUBRULE($.version);\\n      $.AT_LEAST_ONE(function () {\\n        $.SUBRULE($.node);\\n      });\\n      $.MANY(function () {\\n        $.SUBRULE($.route);\\n      });\\n    });\\n    $.RULE('version', function () {\\n      $.CONSUME(Version);\\n    });\\n    $.RULE('node', function () {\\n      $.OPTION(function () {\\n        $.SUBRULE($.def);\\n      });\\n      $.CONSUME(NodeName);\\n      $.CONSUME(LCurly);\\n      $.MANY(function () {\\n        $.SUBRULE($.field);\\n      });\\n      $.CONSUME(RCurly);\\n    });\\n    $.RULE('field', function () {\\n      $.CONSUME(Identifier);\\n      $.OR2([{\\n        ALT: function ALT() {\\n          $.SUBRULE($.singleFieldValue);\\n        }\\n      }, {\\n        ALT: function ALT() {\\n          $.SUBRULE($.multiFieldValue);\\n        }\\n      }]);\\n    });\\n    $.RULE('def', function () {\\n      $.CONSUME(DEF);\\n      $.OR([{\\n        ALT: function ALT() {\\n          $.CONSUME(Identifier);\\n        }\\n      }, {\\n        ALT: function ALT() {\\n          $.CONSUME(NodeName);\\n        }\\n      }]);\\n    });\\n    $.RULE('use', function () {\\n      $.CONSUME(USE);\\n      $.OR([{\\n        ALT: function ALT() {\\n          $.CONSUME(Identifier);\\n        }\\n      }, {\\n        ALT: function ALT() {\\n          $.CONSUME(NodeName);\\n        }\\n      }]);\\n    });\\n    $.RULE('singleFieldValue', function () {\\n      $.AT_LEAST_ONE(function () {\\n        $.OR([{\\n          ALT: function ALT() {\\n            $.SUBRULE($.node);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.SUBRULE($.use);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.CONSUME(StringLiteral);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.CONSUME(HexLiteral);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.CONSUME(NumberLiteral);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.CONSUME(TrueLiteral);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.CONSUME(FalseLiteral);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.CONSUME(NullLiteral);\\n          }\\n        }]);\\n      });\\n    });\\n    $.RULE('multiFieldValue', function () {\\n      $.CONSUME(LSquare);\\n      $.MANY(function () {\\n        $.OR([{\\n          ALT: function ALT() {\\n            $.SUBRULE($.node);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.SUBRULE($.use);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.CONSUME(StringLiteral);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.CONSUME(HexLiteral);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.CONSUME(NumberLiteral);\\n          }\\n        }, {\\n          ALT: function ALT() {\\n            $.CONSUME(NullLiteral);\\n          }\\n        }]);\\n      });\\n      $.CONSUME(RSquare);\\n    });\\n    $.RULE('route', function () {\\n      $.CONSUME(ROUTE);\\n      $.CONSUME(RouteIdentifier);\\n      $.CONSUME(TO);\\n      $.CONSUME2(RouteIdentifier);\\n    });\\n\\n    _this.performSelfAnalysis();\\n\\n    return _this;\\n  }\\n\\n  return VRMLParser;\\n}(_chevrotain.CstParser);\\n\\nvar Face = function Face(a, b, c) {\\n  _classCallCheck(this, Face);\\n\\n  this.a = a;\\n  this.b = b;\\n  this.c = c;\\n  this.normal = new _three.Vector3();\\n};\\n\\nvar TEXTURE_TYPE = {\\n  INTENSITY: 1,\\n  INTENSITY_ALPHA: 2,\\n  RGB: 3,\\n  RGBA: 4\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_classCallCheck\",\"instance\",\"Constructor\",\"TypeError\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"protoProps\",\"staticProps\",\"_possibleConstructorReturn\",\"self\",\"call\",\"_assertThisInitialized\",\"ReferenceError\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"VRMLLoader\",\"_three\",\"_chevrotain\",\"_Loader\",\"manager\",\"load\",\"url\",\"onLoad\",\"onProgress\",\"onError\",\"scope\",\"path\",\"LoaderUtils\",\"extractUrlBase\",\"loader\",\"FileLoader\",\"setPath\",\"setRequestHeader\",\"requestHeader\",\"setWithCredentials\",\"withCredentials\",\"text\",\"parse\",\"e\",\"console\",\"error\",\"itemError\",\"data\",\"createVisitor\",\"BaseVRMLVisitor\",\"VRMLToASTVisitor\",\"validateVisitor\",\"processField\",\"ctx\",\"field\",\"type\",\"values\",\"node\",\"l\",\"push\",\"visit\",\"use\",\"_l2\",\"_i2\",\"StringLiteral\",\"_l3\",\"_i3\",\"stringLiteral\",\"image\",\"replace\",\"NumberLiteral\",\"_l4\",\"_i4\",\"parseFloat\",\"numberLiteral\",\"HexLiteral\",\"_l5\",\"_i5\",\"hexLiteral\",\"TrueLiteral\",\"_l6\",\"_i6\",\"trueLiteral\",\"FalseLiteral\",\"_l7\",\"_i7\",\"falseLiteral\",\"NullLiteral\",\"forEach\",\"assign\",\"vrml\",\"version\",\"nodes\",\"routes\",\"route\",\"_i\",\"_l\",\"Version\",\"name\",\"NodeName\",\"fields\",\"def\",\"DEF\",\"Identifier\",\"result\",\"singleFieldValue\",\"multiFieldValue\",\"USE\",\"FROM\",\"RouteIdentifier\",\"TO\",\"buildNodeMap\",\"nodeMap\",\"fieldValues\",\"j\",\"jl\",\"getNode\",\"build\",\"isObject3D\",\"isMaterial\",\"clone\",\"undefined\",\"nodeName\",\"object\",\"Group\",\"fieldName\",\"children\",\"Object3D\",\"owner\",\"add\",\"axis\",\"Vector3\",\"quaternion\",\"setFromAxisAngle\",\"angle\",\"scale\",\"set\",\"position\",\"warn\",\"group\",\"groundAngle\",\"groundColor\",\"skyAngle\",\"skyColor\",\"skyGeometry\",\"SphereGeometry\",\"radius\",\"skyMaterial\",\"MeshBasicMaterial\",\"fog\",\"side\",\"BackSide\",\"depthWrite\",\"depthTest\",\"paintFaces\",\"toColorArray\",\"vertexColors\",\"color\",\"setRGB\",\"sky\",\"Mesh\",\"groundGeometry\",\"Math\",\"PI\",\"groundMaterial\",\"ground\",\"renderOrder\",\"Infinity\",\"material\",\"geometry\",\"attributes\",\"_type\",\"pointsMaterial\",\"PointsMaterial\",\"isMeshPhongMaterial\",\"copy\",\"emissive\",\"Points\",\"lineMaterial\",\"LineBasicMaterial\",\"LineSegments\",\"_solid\",\"FrontSide\",\"DoubleSide\",\"visible\",\"MeshPhongMaterial\",\"transformData\",\"materialData\",\"diffuseColor\",\"emissiveColor\",\"shininess\",\"specularColor\",\"specular\",\"transparency\",\"opacity\",\"transparent\",\"textureNode\",\"map\",\"__type\",\"TEXTURE_TYPE\",\"INTENSITY_ALPHA\",\"RGB\",\"RGBA\",\"center\",\"rotation\",\"repeat\",\"offset\",\"translation\",\"Color\",\"texture\",\"wrapS\",\"RepeatWrapping\",\"wrapT\",\"textureLoader\",\"ClampToEdgeWrapping\",\"width\",\"height\",\"num_components\",\"useAlpha\",\"INTENSITY\",\"_data\",\"Uint8Array\",\"r\",\"g\",\"b\",\"a\",\"k\",\"textureType\",\"parseInt\",\"hex\",\"substring\",\"stride\",\"_stride\",\"DataTexture\",\"RGBAFormat\",\"RGBFormat\",\"Vector2\",\"coord\",\"normal\",\"texCoord\",\"ccw\",\"solid\",\"creaseAngle\",\"colorIndex\",\"coordIndex\",\"normalIndex\",\"texCoordIndex\",\"colorPerVertex\",\"normalPerVertex\",\"colorNode\",\"coordNode\",\"normalNode\",\"texCoordNode\",\"BufferGeometry\",\"triangulatedCoordIndex\",\"triangulateFaceIndex\",\"triangulatedColorIndex\",\"colorAttribute\",\"computeAttributeFromIndexedData\",\"toNonIndexedAttribute\",\"Float32BufferAttribute\",\"flattenFaceColors\",\"flattenData\",\"triangulatedFaceColors\",\"triangulateFaceData\",\"computeAttributeFromFaceData\",\"_triangulatedFaceColors\",\"triangulatedNormalIndex\",\"normalAttribute\",\"flattenFaceNormals\",\"triangulatedFaceNormals\",\"_triangulatedFaceNormals\",\"computeNormalAttribute\",\"triangulatedTexCoordIndex\",\"uvAttribute\",\"positionAttribute\",\"setAttribute\",\"expandedLineIndex\",\"expandLineIndex\",\"expandedColorIndex\",\"flattenLineColors\",\"expandedLineColors\",\"expandLineData\",\"computeAttributeFromLineData\",\"_expandedLineColors\",\"size\",\"x\",\"y\",\"z\",\"BoxGeometry\",\"openEnded\",\"ConeGeometry\",\"CylinderGeometry\",\"xDimension\",\"zDimension\",\"xSpacing\",\"zSpacing\",\"vertices\",\"normals\",\"colors\",\"uvs\",\"_i9\",\"index\",\"xn\",\"yn\",\"zn\",\"s\",\"t\",\"indices\",\"_i10\",\"_j\",\"_b\",\"c\",\"d\",\"_i11\",\"_j2\",\"_index\",\"_r\",\"_g\",\"_b2\",\"_i12\",\"_j3\",\"_index2\",\"_xn\",\"_yn\",\"_zn\",\"crossSection\",\"spine\",\"orientation\",\"beginCap\",\"endCap\",\"crossSectionClosed\",\"spineVector\",\"scaling\",\"vertex\",\"Quaternion\",\"_i13\",\"il\",\"fromArray\",\"kl\",\"multiply\",\"applyQuaternion\",\"spineCount\",\"crossSectionCount\",\"_i14\",\"_j4\",\"contour\",\"_i15\",\"_l9\",\"faces\",\"ShapeUtils\",\"triangulateShape\",\"capIndices\",\"_i16\",\"_l10\",\"face\",\"_i17\",\"_l11\",\"indexOffset\",\"_i18\",\"_l12\",\"worldInfo\",\"title\",\"info\",\"hasOwnProperty\",\"start\",\"i1\",\"i2\",\"i3\",\"triangulatedData\",\"itemSize\",\"array\",\"uvA\",\"uvB\",\"uvC\",\"vA\",\"vB\",\"vC\",\"faceData\",\"lineData\",\"attribute\",\"array2\",\"index2\",\"vertexNormals\",\"Face\",\"cb\",\"subVectors\",\"ab\",\"cross\",\"normalize\",\"_i19\",\"_l13\",\"_face\",\"nA\",\"weightedNormal\",\"nB\",\"nC\",\"vector\",\"angleTo\",\"angles\",\"topDown\",\"thresholds\",\"startAngle\",\"point\",\"setFromSphericalCoords\",\"BufferAttribute\",\"Float32Array\",\"count\",\"_i20\",\"getX\",\"fromBufferAttribute\",\"thresholdIndexA\",\"thresholdIndexB\",\"thresholdA\",\"thresholdB\",\"abs\",\"colorB\",\"colorA\",\"lerp\",\"setXYZ\",\"TextureLoader\",\"resourcePath\",\"setCrossOrigin\",\"crossOrigin\",\"indexOf\",\"Error\",\"parseTree\",\"tree\",\"scene\",\"Scene\",\"_i8\",\"_l8\",\"_node\",\"userData\",\"generateVRMLTree\",\"createToken\",\"pattern\",\"longer_alt\",\"ROUTE\",\"LSquare\",\"RSquare\",\"LCurly\",\"RCurly\",\"Comment\",\"Lexer\",\"SKIPPED\",\"tokens\",\"WhiteSpace\",\"tokenVocabulary\",\"token\",\"lexer\",\"VRMLLexer\",\"parser\",\"VRMLParser\",\"visitor\",\"getBaseCstVisitorConstructor\",\"lexingResult\",\"lex\",\"input\",\"cstOutput\",\"errors\",\"ast\",\"Loader\",\"inputText\",\"tokenize\",\"_CstParser\",\"_this\",\"$\",\"RULE\",\"SUBRULE\",\"AT_LEAST_ONE\",\"MANY\",\"CONSUME\",\"OPTION\",\"OR2\",\"ALT\",\"OR\",\"CONSUME2\",\"performSelfAnalysis\",\"CstParser\"]\n}\n"]