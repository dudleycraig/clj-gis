["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/objects/Refractor.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$objects$Refractor=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _possibleConstructorReturn(self,call){return!call||\"object\"!==_typeof(call)&&\"function\"!==typeof call?\n_assertThisInitialized(self):call}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");\nsubClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.Refractor=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_Mesh){function Refractor(geometry){var options=\n1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!(this instanceof Refractor))throw new TypeError(\"Cannot call a class as a function\");var _this=_possibleConstructorReturn(this,_getPrototypeOf(Refractor).call(this,geometry));_this.type=\"Refractor\";var scope=_assertThisInitialized(_this),color=void 0!==options.color?new _three.Color(options.color):new _three.Color(8355711),textureWidth=options.textureWidth||512,textureHeight=options.textureHeight||512,clipBias=options.clipBias||0;options=\noptions.shader||Refractor.RefractorShader;var virtualCamera=new _three.PerspectiveCamera;virtualCamera.matrixAutoUpdate=!1;virtualCamera.userData.refractor=!0;var refractorPlane=new _three.Plane,textureMatrix=new _three.Matrix4,renderTarget=new _three.WebGLRenderTarget(textureWidth,textureHeight,{minFilter:_three.LinearFilter,magFilter:_three.LinearFilter,format:_three.RGBFormat});_three.MathUtils.isPowerOfTwo(textureWidth)&&_three.MathUtils.isPowerOfTwo(textureHeight)||(renderTarget.texture.generateMipmaps=\n!1);_this.material=new _three.ShaderMaterial({uniforms:_three.UniformsUtils.clone(options.uniforms),vertexShader:options.vertexShader,fragmentShader:options.fragmentShader,transparent:!0});_this.material.uniforms.color.value=color;_this.material.uniforms.tDiffuse.value=renderTarget.texture;_this.material.uniforms.textureMatrix.value=textureMatrix;var visible=function(){var refractorWorldPosition=new _three.Vector3,cameraWorldPosition=new _three.Vector3,rotationMatrix=new _three.Matrix4,view=new _three.Vector3,\nnormal=new _three.Vector3;return function(camera){refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);view.subVectors(refractorWorldPosition,cameraWorldPosition);rotationMatrix.extractRotation(scope.matrixWorld);normal.set(0,0,1);normal.applyMatrix4(rotationMatrix);return 0>view.dot(normal)}}(),updateRefractorPlane=function(){var normal=new _three.Vector3,position=new _three.Vector3,quaternion=new _three.Quaternion,scale=new _three.Vector3;\nreturn function(){scope.matrixWorld.decompose(position,quaternion,scale);normal.set(0,0,1).applyQuaternion(quaternion).normalize();normal.negate();refractorPlane.setFromNormalAndCoplanarPoint(normal,position)}}(),updateVirtualCamera=function(){var clipPlane=new _three.Plane,clipVector=new _three.Vector4,q=new _three.Vector4;return function(camera){virtualCamera.matrixWorld.copy(camera.matrixWorld);virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\nvirtualCamera.far=camera.far;clipPlane.copy(refractorPlane);clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);clipVector.set(clipPlane.normal.x,clipPlane.normal.y,clipPlane.normal.z,clipPlane.constant);camera=virtualCamera.projectionMatrix;q.x=(Math.sign(clipVector.x)+camera.elements[8])/camera.elements[0];q.y=(Math.sign(clipVector.y)+camera.elements[9])/camera.elements[5];q.z=-1;q.w=(1+camera.elements[10])/camera.elements[14];clipVector.multiplyScalar(2/clipVector.dot(q));camera.elements[2]=\nclipVector.x;camera.elements[6]=clipVector.y;camera.elements[10]=clipVector.z+1-clipBias;camera.elements[14]=clipVector.w}}();_this.onBeforeRender=function(renderer,scene,camera){renderTarget.texture.encoding=renderer.outputEncoding;if(!0!==camera.userData.refractor&&!0!==!visible(camera)){updateRefractorPlane();textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);textureMatrix.multiply(camera.projectionMatrix);textureMatrix.multiply(camera.matrixWorldInverse);textureMatrix.multiply(scope.matrixWorld);\nupdateVirtualCamera(camera);scope.visible=!1;var currentRenderTarget=renderer.getRenderTarget(),currentXrEnabled=renderer.xr.enabled,currentShadowAutoUpdate=renderer.shadowMap.autoUpdate;renderer.xr.enabled=!1;renderer.shadowMap.autoUpdate=!1;renderer.setRenderTarget(renderTarget);!1===renderer.autoClear&&renderer.clear();renderer.render(scene,virtualCamera);renderer.xr.enabled=currentXrEnabled;renderer.shadowMap.autoUpdate=currentShadowAutoUpdate;renderer.setRenderTarget(currentRenderTarget);scene=\ncamera.viewport;void 0!==scene&&renderer.state.viewport(scene);scope.visible=!0}};_this.getRenderTarget=function(){return renderTarget};return _this}_inherits(Refractor,_Mesh);return Refractor}(_three.Mesh);exports.Refractor=global;global.prototype.isRefractor=!0;global.RefractorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:\"\\n\\n\\t\\tuniform mat4 textureMatrix;\\n\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv \\x3d textureMatrix * vec4( position, 1.0 );\\n\\t\\t\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\nfragmentShader:\"\\n\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base \\x3c 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvec4 base \\x3d texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor \\x3d vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$objects$Refractor\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Refractor = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Refractor =\n/*#__PURE__*/\nfunction (_Mesh) {\n  _inherits(Refractor, _Mesh);\n\n  function Refractor(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Refractor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Refractor).call(this, geometry));\n    _this.type = 'Refractor';\n\n    var scope = _assertThisInitialized(_this);\n\n    var color = options.color !== undefined ? new _three.Color(options.color) : new _three.Color(0x7f7f7f);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || Refractor.RefractorShader; //\n\n    var virtualCamera = new _three.PerspectiveCamera();\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true; //\n\n    var refractorPlane = new _three.Plane();\n    var textureMatrix = new _three.Matrix4(); // render target\n\n    var parameters = {\n      minFilter: _three.LinearFilter,\n      magFilter: _three.LinearFilter,\n      format: _three.RGBFormat\n    };\n    var renderTarget = new _three.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n    if (!_three.MathUtils.isPowerOfTwo(textureWidth) || !_three.MathUtils.isPowerOfTwo(textureHeight)) {\n      renderTarget.texture.generateMipmaps = false;\n    } // material\n\n\n    _this.material = new _three.ShaderMaterial({\n      uniforms: _three.UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true // ensures, refractors are drawn from farthest to closest\n\n    });\n    _this.material.uniforms['color'].value = color;\n    _this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n    _this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\n\n    var visible = function () {\n      var refractorWorldPosition = new _three.Vector3();\n      var cameraWorldPosition = new _three.Vector3();\n      var rotationMatrix = new _three.Matrix4();\n      var view = new _three.Vector3();\n      var normal = new _three.Vector3();\n      return function visible(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n\n    var updateRefractorPlane = function () {\n      var normal = new _three.Vector3();\n      var position = new _three.Vector3();\n      var quaternion = new _three.Quaternion();\n      var scale = new _three.Vector3();\n      return function updateRefractorPlane() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\n\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n\n    var updateVirtualCamera = function () {\n      var clipPlane = new _three.Plane();\n      var clipVector = new _three.Vector4();\n      var q = new _three.Vector4();\n      return function updateVirtualCamera(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far; // used in WebGLBackground\n        // The following code creates an oblique view frustum for clipping.\n        // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n        var projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1.0;\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\n\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\n\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\n    function updateTextureMatrix(camera) {\n      // this matrix does range mapping to [ 0, 1 ]\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n      // (matrix above) with the projection and view matrix of the virtual camera\n      // and the model matrix of the refractor\n\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    } //\n\n\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      renderer.xr.enabled = false; // avoid camera modification\n\n      renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // restore viewport\n\n      var viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n\n      scope.visible = true;\n    } //\n\n\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      // Render\n      renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\n\n      if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\n\n      if (!visible(camera) === true) return; // update\n\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n\n    return _this;\n  }\n\n  return Refractor;\n}(_three.Mesh);\n\nexports.Refractor = Refractor;\nRefractor.prototype.isRefractor = true;\nRefractor.RefractorShader = {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\n\\t\\tuniform mat4 textureMatrix;\\n\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t}\"\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","RefractorShader","z","w","isRefractor","textureMatrix","prototype","transparent","autoUpdate","far","Refractor","x","__esModule","onBeforeRender","matrixAutoUpdate","encoding","enabled","tDiffuse","getRenderTarget","vertexShader","configurable","value","visible","magFilter","writable","type","y","refractor","__proto__","generateMipmaps","uniforms","minFilter","color","format","constructor","material"]],"~:compiled-at",1630917515363,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$objects$Refractor.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/objects/Refractor.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$objects$Refractor\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.Refractor = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar Refractor =\\n/*#__PURE__*/\\nfunction (_Mesh) {\\n  _inherits(Refractor, _Mesh);\\n\\n  function Refractor(geometry) {\\n    var _this;\\n\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n    _classCallCheck(this, Refractor);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Refractor).call(this, geometry));\\n    _this.type = 'Refractor';\\n\\n    var scope = _assertThisInitialized(_this);\\n\\n    var color = options.color !== undefined ? new _three.Color(options.color) : new _three.Color(0x7f7f7f);\\n    var textureWidth = options.textureWidth || 512;\\n    var textureHeight = options.textureHeight || 512;\\n    var clipBias = options.clipBias || 0;\\n    var shader = options.shader || Refractor.RefractorShader; //\\n\\n    var virtualCamera = new _three.PerspectiveCamera();\\n    virtualCamera.matrixAutoUpdate = false;\\n    virtualCamera.userData.refractor = true; //\\n\\n    var refractorPlane = new _three.Plane();\\n    var textureMatrix = new _three.Matrix4(); // render target\\n\\n    var parameters = {\\n      minFilter: _three.LinearFilter,\\n      magFilter: _three.LinearFilter,\\n      format: _three.RGBFormat\\n    };\\n    var renderTarget = new _three.WebGLRenderTarget(textureWidth, textureHeight, parameters);\\n\\n    if (!_three.MathUtils.isPowerOfTwo(textureWidth) || !_three.MathUtils.isPowerOfTwo(textureHeight)) {\\n      renderTarget.texture.generateMipmaps = false;\\n    } // material\\n\\n\\n    _this.material = new _three.ShaderMaterial({\\n      uniforms: _three.UniformsUtils.clone(shader.uniforms),\\n      vertexShader: shader.vertexShader,\\n      fragmentShader: shader.fragmentShader,\\n      transparent: true // ensures, refractors are drawn from farthest to closest\\n\\n    });\\n    _this.material.uniforms['color'].value = color;\\n    _this.material.uniforms['tDiffuse'].value = renderTarget.texture;\\n    _this.material.uniforms['textureMatrix'].value = textureMatrix; // functions\\n\\n    var visible = function () {\\n      var refractorWorldPosition = new _three.Vector3();\\n      var cameraWorldPosition = new _three.Vector3();\\n      var rotationMatrix = new _three.Matrix4();\\n      var view = new _three.Vector3();\\n      var normal = new _three.Vector3();\\n      return function visible(camera) {\\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\\n        rotationMatrix.extractRotation(scope.matrixWorld);\\n        normal.set(0, 0, 1);\\n        normal.applyMatrix4(rotationMatrix);\\n        return view.dot(normal) < 0;\\n      };\\n    }();\\n\\n    var updateRefractorPlane = function () {\\n      var normal = new _three.Vector3();\\n      var position = new _three.Vector3();\\n      var quaternion = new _three.Quaternion();\\n      var scale = new _three.Vector3();\\n      return function updateRefractorPlane() {\\n        scope.matrixWorld.decompose(position, quaternion, scale);\\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize(); // flip the normal because we want to cull everything above the plane\\n\\n        normal.negate();\\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\\n      };\\n    }();\\n\\n    var updateVirtualCamera = function () {\\n      var clipPlane = new _three.Plane();\\n      var clipVector = new _three.Vector4();\\n      var q = new _three.Vector4();\\n      return function updateVirtualCamera(camera) {\\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\\n        virtualCamera.far = camera.far; // used in WebGLBackground\\n        // The following code creates an oblique view frustum for clipping.\\n        // see: Lengyel, Eric. \\u201cOblique View Frustum Depth Projection and Clipping\\u201d.\\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5\\u201316\\n\\n        clipPlane.copy(refractorPlane);\\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant); // calculate the clip-space corner point opposite the clipping plane and\\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\\n\\n        var projectionMatrix = virtualCamera.projectionMatrix;\\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\\n        q.z = -1.0;\\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // calculate the scaled plane vector\\n\\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q)); // replacing the third row of the projection matrix\\n\\n        projectionMatrix.elements[2] = clipVector.x;\\n        projectionMatrix.elements[6] = clipVector.y;\\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\\n        projectionMatrix.elements[14] = clipVector.w;\\n      };\\n    }(); // This will update the texture matrix that is used for projective texture mapping in the shader.\\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\\n\\n\\n    function updateTextureMatrix(camera) {\\n      // this matrix does range mapping to [ 0, 1 ]\\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0); // we use \\\"Object Linear Texgen\\\", so we need to multiply the texture matrix T\\n      // (matrix above) with the projection and view matrix of the virtual camera\\n      // and the model matrix of the refractor\\n\\n      textureMatrix.multiply(camera.projectionMatrix);\\n      textureMatrix.multiply(camera.matrixWorldInverse);\\n      textureMatrix.multiply(scope.matrixWorld);\\n    } //\\n\\n\\n    function render(renderer, scene, camera) {\\n      scope.visible = false;\\n      var currentRenderTarget = renderer.getRenderTarget();\\n      var currentXrEnabled = renderer.xr.enabled;\\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\\n      renderer.xr.enabled = false; // avoid camera modification\\n\\n      renderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\\n\\n      renderer.setRenderTarget(renderTarget);\\n      if (renderer.autoClear === false) renderer.clear();\\n      renderer.render(scene, virtualCamera);\\n      renderer.xr.enabled = currentXrEnabled;\\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\\n      renderer.setRenderTarget(currentRenderTarget); // restore viewport\\n\\n      var viewport = camera.viewport;\\n\\n      if (viewport !== undefined) {\\n        renderer.state.viewport(viewport);\\n      }\\n\\n      scope.visible = true;\\n    } //\\n\\n\\n    _this.onBeforeRender = function (renderer, scene, camera) {\\n      // Render\\n      renderTarget.texture.encoding = renderer.outputEncoding; // ensure refractors are rendered only once per frame\\n\\n      if (camera.userData.refractor === true) return; // avoid rendering when the refractor is viewed from behind\\n\\n      if (!visible(camera) === true) return; // update\\n\\n      updateRefractorPlane();\\n      updateTextureMatrix(camera);\\n      updateVirtualCamera(camera);\\n      render(renderer, scene, camera);\\n    };\\n\\n    _this.getRenderTarget = function () {\\n      return renderTarget;\\n    };\\n\\n    return _this;\\n  }\\n\\n  return Refractor;\\n}(_three.Mesh);\\n\\nexports.Refractor = Refractor;\\nRefractor.prototype.isRefractor = true;\\nRefractor.RefractorShader = {\\n  uniforms: {\\n    color: {\\n      value: null\\n    },\\n    tDiffuse: {\\n      value: null\\n    },\\n    textureMatrix: {\\n      value: null\\n    }\\n  },\\n  vertexShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\n\\\\t\\\\tuniform mat4 textureMatrix;\\\\n\\\\n\\\\t\\\\tvarying vec4 vUv;\\\\n\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\tvUv = textureMatrix * vec4( position, 1.0 );\\\\n\\\\t\\\\t\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\n\\\\t\\\\t}\\\",\\n  fragmentShader:\\n  /* glsl */\\n  \\\"\\\\n\\\\n\\\\t\\\\tuniform vec3 color;\\\\n\\\\t\\\\tuniform sampler2D tDiffuse;\\\\n\\\\n\\\\t\\\\tvarying vec4 vUv;\\\\n\\\\n\\\\t\\\\tfloat blendOverlay( float base, float blend ) {\\\\n\\\\n\\\\t\\\\t\\\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\\\n\\\\n\\\\t\\\\t\\\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\\\n\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\tvec4 base = texture2DProj( tDiffuse, vUv );\\\\n\\\\t\\\\t\\\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\\\n\\\\n\\\\t\\\\t}\\\"\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_possibleConstructorReturn\",\"self\",\"call\",\"_assertThisInitialized\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"ReferenceError\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"defineProperty\",\"Refractor\",\"_three\",\"_Mesh\",\"geometry\",\"options\",\"arguments\",\"length\",\"undefined\",\"instance\",\"_this\",\"type\",\"scope\",\"color\",\"Color\",\"textureWidth\",\"textureHeight\",\"clipBias\",\"shader\",\"RefractorShader\",\"virtualCamera\",\"PerspectiveCamera\",\"matrixAutoUpdate\",\"userData\",\"refractor\",\"refractorPlane\",\"Plane\",\"textureMatrix\",\"Matrix4\",\"renderTarget\",\"WebGLRenderTarget\",\"parameters\",\"minFilter\",\"LinearFilter\",\"magFilter\",\"format\",\"RGBFormat\",\"MathUtils\",\"isPowerOfTwo\",\"texture\",\"generateMipmaps\",\"material\",\"ShaderMaterial\",\"uniforms\",\"UniformsUtils\",\"clone\",\"vertexShader\",\"fragmentShader\",\"transparent\",\"visible\",\"refractorWorldPosition\",\"Vector3\",\"cameraWorldPosition\",\"rotationMatrix\",\"view\",\"normal\",\"camera\",\"setFromMatrixPosition\",\"matrixWorld\",\"subVectors\",\"extractRotation\",\"set\",\"applyMatrix4\",\"dot\",\"updateRefractorPlane\",\"position\",\"quaternion\",\"Quaternion\",\"scale\",\"decompose\",\"applyQuaternion\",\"normalize\",\"negate\",\"setFromNormalAndCoplanarPoint\",\"updateVirtualCamera\",\"clipPlane\",\"clipVector\",\"Vector4\",\"q\",\"copy\",\"matrixWorldInverse\",\"invert\",\"projectionMatrix\",\"far\",\"x\",\"y\",\"z\",\"constant\",\"Math\",\"sign\",\"elements\",\"w\",\"multiplyScalar\",\"onBeforeRender\",\"_this.onBeforeRender\",\"renderer\",\"scene\",\"encoding\",\"outputEncoding\",\"multiply\",\"currentRenderTarget\",\"getRenderTarget\",\"currentXrEnabled\",\"xr\",\"enabled\",\"currentShadowAutoUpdate\",\"shadowMap\",\"autoUpdate\",\"setRenderTarget\",\"autoClear\",\"clear\",\"render\",\"viewport\",\"state\",\"_this.getRenderTarget\",\"Mesh\",\"isRefractor\",\"tDiffuse\"]\n}\n"]