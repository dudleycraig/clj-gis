["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/utils/GeometryUtils.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$utils$GeometryUtils=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.hilbert3D=exports.hilbert2D=exports.gosper=void 0;var _three=require(\"module$node_modules$three$build$three_module\");exports.hilbert2D=function hilbert2D(center,size,iterations,v0,v1,v2,v3){center=void 0!==center?center:new _three.Vector3(0,0,0);size=(void 0!==size?size:10)/2;iterations=void 0!==iterations?iterations:1;v0=void 0!==\nv0?v0:0;v1=void 0!==v1?v1:1;v2=void 0!==v2?v2:2;v3=void 0!==v3?v3:3;center=[new _three.Vector3(center.x-size,center.y,center.z-size),new _three.Vector3(center.x-size,center.y,center.z+size),new _three.Vector3(center.x+size,center.y,center.z+size),new _three.Vector3(center.x+size,center.y,center.z-size)];center=[center[v0],center[v1],center[v2],center[v3]];if(0<=--iterations){var tmp=[];Array.prototype.push.apply(tmp,hilbert2D(center[0],size,iterations,v0,v3,v2,v1));Array.prototype.push.apply(tmp,\nhilbert2D(center[1],size,iterations,v0,v1,v2,v3));Array.prototype.push.apply(tmp,hilbert2D(center[2],size,iterations,v0,v1,v2,v3));Array.prototype.push.apply(tmp,hilbert2D(center[3],size,iterations,v2,v1,v0,v3));return tmp}return center};exports.hilbert3D=function hilbert3D(center,size,iterations,v0,v1,v2,v3,v4,v5,v6,v7){center=void 0!==center?center:new _three.Vector3(0,0,0);size=(void 0!==size?size:10)/2;iterations=void 0!==iterations?iterations:1;v0=void 0!==v0?v0:0;v1=void 0!==v1?v1:1;v2=void 0!==\nv2?v2:2;v3=void 0!==v3?v3:3;v4=void 0!==v4?v4:4;v5=void 0!==v5?v5:5;v6=void 0!==v6?v6:6;v7=void 0!==v7?v7:7;center=[new _three.Vector3(center.x-size,center.y+size,center.z-size),new _three.Vector3(center.x-size,center.y+size,center.z+size),new _three.Vector3(center.x-size,center.y-size,center.z+size),new _three.Vector3(center.x-size,center.y-size,center.z-size),new _three.Vector3(center.x+size,center.y-size,center.z-size),new _three.Vector3(center.x+size,center.y-size,center.z+size),new _three.Vector3(center.x+\nsize,center.y+size,center.z+size),new _three.Vector3(center.x+size,center.y+size,center.z-size)];center=[center[v0],center[v1],center[v2],center[v3],center[v4],center[v5],center[v6],center[v7]];if(0<=--iterations){var tmp=[];Array.prototype.push.apply(tmp,hilbert3D(center[0],size,iterations,v0,v3,v4,v7,v6,v5,v2,v1));Array.prototype.push.apply(tmp,hilbert3D(center[1],size,iterations,v0,v7,v6,v1,v2,v5,v4,v3));Array.prototype.push.apply(tmp,hilbert3D(center[2],size,iterations,v0,v7,v6,v1,v2,v5,v4,v3));\nArray.prototype.push.apply(tmp,hilbert3D(center[3],size,iterations,v2,v3,v0,v1,v6,v7,v4,v5));Array.prototype.push.apply(tmp,hilbert3D(center[4],size,iterations,v2,v3,v0,v1,v6,v7,v4,v5));Array.prototype.push.apply(tmp,hilbert3D(center[5],size,iterations,v4,v3,v2,v5,v6,v1,v0,v7));Array.prototype.push.apply(tmp,hilbert3D(center[6],size,iterations,v4,v3,v2,v5,v6,v1,v0,v7));Array.prototype.push.apply(tmp,hilbert3D(center[7],size,iterations,v6,v5,v2,v1,v0,v3,v4,v7));return tmp}return center};exports.gosper=\nfunction(size){size=void 0!==size?size:1;return function(config){for(var currX=0,currY=0,angle=0,path=[0,0,0],fractal=config.fractal,i=0,l=fractal.length;i<l;i++){var _char2=fractal[i];\"+\"===_char2?angle+=config.angle:\"-\"===_char2?angle-=config.angle:\"F\"===_char2&&(currX+=config.size*Math.cos(angle),currY+=-config.size*Math.sin(angle),path.push(currX,currY,0))}return path}({fractal:function(config){for(var output,input=config.axiom,i=0,il=config.steps;0<=il?i<il:i>il;0<=il?i++:i--){output=\"\";for(var j=\n0,jl=input.length;j<jl;j++){var _char=input[j];output=_char in config.rules?output+config.rules[_char]:output+_char}input=output}return output}({axiom:\"A\",steps:4,rules:{A:\"A+BF++BF-FA--FAFA-BF+\",B:\"-FA+BFBF++BF+FA--FA-B\"}}),size,angle:Math.PI/3})}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$utils$GeometryUtils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hilbert3D = exports.hilbert2D = exports.gosper = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\nvar hilbert2D = function hilbert2D(center, size, iterations, v0, v1, v2, v3) {\n  // Default Vars\n  var center = center !== undefined ? center : new _three.Vector3(0, 0, 0),\n      size = size !== undefined ? size : 10,\n      half = size / 2,\n      iterations = iterations !== undefined ? iterations : 1,\n      v0 = v0 !== undefined ? v0 : 0,\n      v1 = v1 !== undefined ? v1 : 1,\n      v2 = v2 !== undefined ? v2 : 2,\n      v3 = v3 !== undefined ? v3 : 3;\n  var vec_s = [new _three.Vector3(center.x - half, center.y, center.z - half), new _three.Vector3(center.x - half, center.y, center.z + half), new _three.Vector3(center.x + half, center.y, center.z + half), new _three.Vector3(center.x + half, center.y, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]; // Recurse iterations\n\n  if (0 <= --iterations) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/visuals/?visualID=15599\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\n\n\nexports.hilbert2D = hilbert2D;\n\nvar hilbert3D = function hilbert3D(center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7) {\n  // Default Vars\n  var center = center !== undefined ? center : new _three.Vector3(0, 0, 0),\n      size = size !== undefined ? size : 10,\n      half = size / 2,\n      iterations = iterations !== undefined ? iterations : 1,\n      v0 = v0 !== undefined ? v0 : 0,\n      v1 = v1 !== undefined ? v1 : 1,\n      v2 = v2 !== undefined ? v2 : 2,\n      v3 = v3 !== undefined ? v3 : 3,\n      v4 = v4 !== undefined ? v4 : 4,\n      v5 = v5 !== undefined ? v5 : 5,\n      v6 = v6 !== undefined ? v6 : 6,\n      v7 = v7 !== undefined ? v7 : 7;\n  var vec_s = [new _three.Vector3(center.x - half, center.y + half, center.z - half), new _three.Vector3(center.x - half, center.y + half, center.z + half), new _three.Vector3(center.x - half, center.y - half, center.z + half), new _three.Vector3(center.x - half, center.y - half, center.z - half), new _three.Vector3(center.x + half, center.y - half, center.z - half), new _three.Vector3(center.x + half, center.y - half, center.z + half), new _three.Vector3(center.x + half, center.y + half, center.z + half), new _three.Vector3(center.x + half, center.y + half, center.z - half)];\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]; // Recurse iterations\n\n  if (--iterations >= 0) {\n    var tmp = [];\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)); // Return recursive call\n\n    return tmp;\n  } // Return complete Hilbert Curve.\n\n\n  return vec;\n};\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\n\n\nexports.hilbert3D = hilbert3D;\n\nvar gosper = function gosper(size) {\n  size = size !== undefined ? size : 1;\n\n  function fractalize(config) {\n    var output;\n    var input = config.axiom;\n\n    for (var i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = '';\n\n      for (var j = 0, jl = input.length; j < jl; j++) {\n        var _char = input[j];\n\n        if (_char in config.rules) {\n          output += config.rules[_char];\n        } else {\n          output += _char;\n        }\n      }\n\n      input = output;\n    }\n\n    return output;\n  }\n\n  function toPoints(config) {\n    var currX = 0,\n        currY = 0;\n    var angle = 0;\n    var path = [0, 0, 0];\n    var fractal = config.fractal;\n\n    for (var i = 0, l = fractal.length; i < l; i++) {\n      var _char2 = fractal[i];\n\n      if (_char2 === '+') {\n        angle += config.angle;\n      } else if (_char2 === '-') {\n        angle -= config.angle;\n      } else if (_char2 === 'F') {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n\n    return path;\n  } //\n\n\n  var gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B'\n    }\n  });\n  var points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3 // 60 degrees\n\n  });\n  return points;\n};\n\nexports.gosper = gosper;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["hilbert2D","steps","__esModule","angle","value","rules","fractal","B","hilbert3D","A","size","axiom","gosper"]],"~:compiled-at",1630917515397,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$utils$GeometryUtils.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/utils/GeometryUtils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$utils$GeometryUtils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.hilbert3D = exports.hilbert2D = exports.gosper = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Generates 2D-Coordinates in a very fast way.\\n *\\n * Based on work by:\\n * @link http://www.openprocessing.org/sketch/15493\\n *\\n * @param center     Center of Hilbert curve.\\n * @param size       Total width of Hilbert curve.\\n * @param iterations Number of subdivisions.\\n * @param v0         Corner index -X, -Z.\\n * @param v1         Corner index -X, +Z.\\n * @param v2         Corner index +X, +Z.\\n * @param v3         Corner index +X, -Z.\\n */\\nvar hilbert2D = function hilbert2D(center, size, iterations, v0, v1, v2, v3) {\\n  // Default Vars\\n  var center = center !== undefined ? center : new _three.Vector3(0, 0, 0),\\n      size = size !== undefined ? size : 10,\\n      half = size / 2,\\n      iterations = iterations !== undefined ? iterations : 1,\\n      v0 = v0 !== undefined ? v0 : 0,\\n      v1 = v1 !== undefined ? v1 : 1,\\n      v2 = v2 !== undefined ? v2 : 2,\\n      v3 = v3 !== undefined ? v3 : 3;\\n  var vec_s = [new _three.Vector3(center.x - half, center.y, center.z - half), new _three.Vector3(center.x - half, center.y, center.z + half), new _three.Vector3(center.x + half, center.y, center.z + half), new _three.Vector3(center.x + half, center.y, center.z - half)];\\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]; // Recurse iterations\\n\\n  if (0 <= --iterations) {\\n    var tmp = [];\\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)); // Return recursive call\\n\\n    return tmp;\\n  } // Return complete Hilbert Curve.\\n\\n\\n  return vec;\\n};\\n/**\\n * Generates 3D-Coordinates in a very fast way.\\n *\\n * Based on work by:\\n * @link http://www.openprocessing.org/visuals/?visualID=15599\\n *\\n * @param center     Center of Hilbert curve.\\n * @param size       Total width of Hilbert curve.\\n * @param iterations Number of subdivisions.\\n * @param v0         Corner index -X, +Y, -Z.\\n * @param v1         Corner index -X, +Y, +Z.\\n * @param v2         Corner index -X, -Y, +Z.\\n * @param v3         Corner index -X, -Y, -Z.\\n * @param v4         Corner index +X, -Y, -Z.\\n * @param v5         Corner index +X, -Y, +Z.\\n * @param v6         Corner index +X, +Y, +Z.\\n * @param v7         Corner index +X, +Y, -Z.\\n */\\n\\n\\nexports.hilbert2D = hilbert2D;\\n\\nvar hilbert3D = function hilbert3D(center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7) {\\n  // Default Vars\\n  var center = center !== undefined ? center : new _three.Vector3(0, 0, 0),\\n      size = size !== undefined ? size : 10,\\n      half = size / 2,\\n      iterations = iterations !== undefined ? iterations : 1,\\n      v0 = v0 !== undefined ? v0 : 0,\\n      v1 = v1 !== undefined ? v1 : 1,\\n      v2 = v2 !== undefined ? v2 : 2,\\n      v3 = v3 !== undefined ? v3 : 3,\\n      v4 = v4 !== undefined ? v4 : 4,\\n      v5 = v5 !== undefined ? v5 : 5,\\n      v6 = v6 !== undefined ? v6 : 6,\\n      v7 = v7 !== undefined ? v7 : 7;\\n  var vec_s = [new _three.Vector3(center.x - half, center.y + half, center.z - half), new _three.Vector3(center.x - half, center.y + half, center.z + half), new _three.Vector3(center.x - half, center.y - half, center.z + half), new _three.Vector3(center.x - half, center.y - half, center.z - half), new _three.Vector3(center.x + half, center.y - half, center.z - half), new _three.Vector3(center.x + half, center.y - half, center.z + half), new _three.Vector3(center.x + half, center.y + half, center.z + half), new _three.Vector3(center.x + half, center.y + half, center.z - half)];\\n  var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]; // Recurse iterations\\n\\n  if (--iterations >= 0) {\\n    var tmp = [];\\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)); // Return recursive call\\n\\n    return tmp;\\n  } // Return complete Hilbert Curve.\\n\\n\\n  return vec;\\n};\\n/**\\n * Generates a Gosper curve (lying in the XY plane)\\n *\\n * https://gist.github.com/nitaku/6521802\\n *\\n * @param size The size of a single gosper island.\\n */\\n\\n\\nexports.hilbert3D = hilbert3D;\\n\\nvar gosper = function gosper(size) {\\n  size = size !== undefined ? size : 1;\\n\\n  function fractalize(config) {\\n    var output;\\n    var input = config.axiom;\\n\\n    for (var i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\\n      output = '';\\n\\n      for (var j = 0, jl = input.length; j < jl; j++) {\\n        var _char = input[j];\\n\\n        if (_char in config.rules) {\\n          output += config.rules[_char];\\n        } else {\\n          output += _char;\\n        }\\n      }\\n\\n      input = output;\\n    }\\n\\n    return output;\\n  }\\n\\n  function toPoints(config) {\\n    var currX = 0,\\n        currY = 0;\\n    var angle = 0;\\n    var path = [0, 0, 0];\\n    var fractal = config.fractal;\\n\\n    for (var i = 0, l = fractal.length; i < l; i++) {\\n      var _char2 = fractal[i];\\n\\n      if (_char2 === '+') {\\n        angle += config.angle;\\n      } else if (_char2 === '-') {\\n        angle -= config.angle;\\n      } else if (_char2 === 'F') {\\n        currX += config.size * Math.cos(angle);\\n        currY += -config.size * Math.sin(angle);\\n        path.push(currX, currY, 0);\\n      }\\n    }\\n\\n    return path;\\n  } //\\n\\n\\n  var gosper = fractalize({\\n    axiom: 'A',\\n    steps: 4,\\n    rules: {\\n      A: 'A+BF++BF-FA--FAFA-BF+',\\n      B: '-FA+BFBF++BF+FA--FA-B'\\n    }\\n  });\\n  var points = toPoints({\\n    fractal: gosper,\\n    size: size,\\n    angle: Math.PI / 3 // 60 degrees\\n\\n  });\\n  return points;\\n};\\n\\nexports.gosper = gosper;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"hilbert3D\",\"hilbert2D\",\"gosper\",\"_three\",\"center\",\"size\",\"iterations\",\"v0\",\"v1\",\"v2\",\"v3\",\"undefined\",\"Vector3\",\"half\",\"vec_s\",\"x\",\"y\",\"z\",\"vec\",\"tmp\",\"Array\",\"prototype\",\"push\",\"apply\",\"v4\",\"v5\",\"v6\",\"v7\",\"toPoints\",\"config\",\"currX\",\"currY\",\"angle\",\"path\",\"fractal\",\"i\",\"l\",\"length\",\"_char2\",\"Math\",\"cos\",\"sin\",\"points\",\"fractalize\",\"output\",\"input\",\"axiom\",\"il\",\"steps\",\"j\",\"jl\",\"_char\",\"rules\",\"A\",\"B\",\"PI\"]\n}\n"]