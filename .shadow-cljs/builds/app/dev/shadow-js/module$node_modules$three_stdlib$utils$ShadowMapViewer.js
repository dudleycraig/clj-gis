["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/utils/ShadowMapViewer.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$utils$ShadowMapViewer=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ShadowMapViewer=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_UnpackDepthRGBAShader=require(\"module$node_modules$three_stdlib$shaders$UnpackDepthRGBAShader\");global=function(light){var scope=this,doRenderLabel=void 0!==light.name&&\"\"!==light.name,userAutoClearSetting,camera=new _three.OrthographicCamera(window.innerWidth/\n-2,window.innerWidth/2,window.innerHeight/2,window.innerHeight/-2,1,10);camera.position.set(0,0,2);var scene=new _three.Scene,shader=_UnpackDepthRGBAShader.UnpackDepthRGBAShader,uniforms=_three.UniformsUtils.clone(shader.uniforms);shader=new _three.ShaderMaterial({uniforms,vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader});var plane=new _three.PlaneGeometry(256,256),mesh=new _three.Mesh(plane,shader);scene.add(mesh);if(doRenderLabel){var labelCanvas=document.createElement(\"canvas\");\nshader=labelCanvas.getContext(\"2d\");shader.font=\"Bold 20px Arial\";plane=shader.measureText(light.name).width;labelCanvas.width=plane;labelCanvas.height=25;shader.font=\"Bold 20px Arial\";shader.fillStyle=\"rgba( 255, 0, 0, 1 )\";shader.fillText(light.name,0,20);shader=new _three.Texture(labelCanvas);shader.magFilter=_three.LinearFilter;shader.minFilter=_three.LinearFilter;shader.needsUpdate=!0;shader=new _three.MeshBasicMaterial({map:shader,side:_three.DoubleSide});shader.transparent=!0;plane=new _three.PlaneGeometry(labelCanvas.width,\nlabelCanvas.height);var labelMesh=new _three.Mesh(plane,shader);scene.add(labelMesh)}this.enabled=!0;this.size={width:256,height:256,set:function(width,height){this.width=width;this.height=height;mesh.scale.set(this.width/256,this.height/256,1);scope.position.set(scope.position.x,scope.position.y)}};this.position={x:10,y:10,set:function(x,y){this.x=x;this.y=y;mesh.position.set(-window.innerWidth/2+scope.size.width/2+this.x,window.innerHeight/2-scope.size.height/2-this.y,0);doRenderLabel&&labelMesh.position.set(mesh.position.x,\nmesh.position.y-scope.size.height/2+labelCanvas.height/2,0)}};this.render=function(renderer){this.enabled&&(uniforms.tDiffuse.value=light.shadow.map.texture,userAutoClearSetting=renderer.autoClear,renderer.autoClear=!1,renderer.clearDepth(),renderer.render(scene,camera),renderer.autoClear=userAutoClearSetting)};this.updateForWindowResize=function(){this.enabled&&(camera.left=window.innerWidth/-2,camera.right=window.innerWidth/2,camera.top=window.innerHeight/2,camera.bottom=window.innerHeight/-2,camera.updateProjectionMatrix(),\nthis.update())};this.update=function(){this.position.set(this.position.x,this.position.y);this.size.set(this.size.width,this.size.height)};this.update()};exports.ShadowMapViewer=global;global.prototype.constructor=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$utils$ShadowMapViewer\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ShadowMapViewer = void 0;\n\nvar _three = require(\"three\");\n\nvar _UnpackDepthRGBAShader = require(\"../shaders/UnpackDepthRGBAShader.js\");\n\n/**\n * This is a helper for visualising a given light's shadow map.\n * It works for shadow casting lights: DirectionalLight and SpotLight.\n * It renders out the shadow map and displays it on a HUD.\n *\n * Example usage:\n *\t1) Import ShadowMapViewer into your app.\n *\n *\t2) Create a shadow casting light and name it optionally:\n *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\n *\t\tlight.castShadow = true;\n *\t\tlight.name = 'Sun';\n *\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\n *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\n *\n *\t4) Render the shadow map viewer in your render loop:\n *\t\tshadowMapViewer.render( renderer );\n *\n *\t5) Optionally: Update the shadow map viewer on window resize:\n *\t\tshadowMapViewer.updateForWindowResize();\n *\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\n */\nvar ShadowMapViewer = function ShadowMapViewer(light) {\n  //- Internals\n  var scope = this;\n  var doRenderLabel = light.name !== undefined && light.name !== '';\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\n\n  var frame = {\n    x: 10,\n    y: 10,\n    width: 256,\n    height: 256\n  };\n  var camera = new _three.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\n  camera.position.set(0, 0, 2);\n  var scene = new _three.Scene(); //HUD for shadow map\n\n  var shader = _UnpackDepthRGBAShader.UnpackDepthRGBAShader;\n\n  var uniforms = _three.UniformsUtils.clone(shader.uniforms);\n\n  var material = new _three.ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader\n  });\n  var plane = new _three.PlaneGeometry(frame.width, frame.height);\n  var mesh = new _three.Mesh(plane, material);\n  scene.add(mesh); //Label for light's name\n\n  var labelCanvas, labelMesh;\n\n  if (doRenderLabel) {\n    labelCanvas = document.createElement('canvas');\n    var context = labelCanvas.getContext('2d');\n    context.font = 'Bold 20px Arial';\n    var labelWidth = context.measureText(light.name).width;\n    labelCanvas.width = labelWidth;\n    labelCanvas.height = 25; //25 to account for g, p, etc.\n\n    context.font = 'Bold 20px Arial';\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\n    context.fillText(light.name, 0, 20);\n    var labelTexture = new _three.Texture(labelCanvas);\n    labelTexture.magFilter = _three.LinearFilter;\n    labelTexture.minFilter = _three.LinearFilter;\n    labelTexture.needsUpdate = true;\n    var labelMaterial = new _three.MeshBasicMaterial({\n      map: labelTexture,\n      side: _three.DoubleSide\n    });\n    labelMaterial.transparent = true;\n    var labelPlane = new _three.PlaneGeometry(labelCanvas.width, labelCanvas.height);\n    labelMesh = new _three.Mesh(labelPlane, labelMaterial);\n    scene.add(labelMesh);\n  }\n\n  function resetPosition() {\n    scope.position.set(scope.position.x, scope.position.y);\n  } //- API\n  // Set to false to disable displaying this shadow map\n\n\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\n\n  this.size = {\n    width: frame.width,\n    height: frame.height,\n    set: function set(width, height) {\n      this.width = width;\n      this.height = height;\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\n\n      resetPosition();\n    }\n  }; // Set the position of the displayed shadow map on the HUD\n\n  this.position = {\n    x: frame.x,\n    y: frame.y,\n    set: function set(x, y) {\n      this.x = x;\n      this.y = y;\n      var width = scope.size.width;\n      var height = scope.size.height;\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\n      if (doRenderLabel) labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\n    }\n  };\n\n  this.render = function (renderer) {\n    if (this.enabled) {\n      //Because a light's .shadowMap is only initialised after the first render pass\n      //we have to make sure the correct map is sent into the shader, otherwise we\n      //always end up with the scene's first added shadow casting light's shadowMap\n      //in the shader\n      //See: https://github.com/mrdoob/three.js/issues/5932\n      uniforms.tDiffuse.value = light.shadow.map.texture;\n      userAutoClearSetting = renderer.autoClear;\n      renderer.autoClear = false; // To allow render overlay\n\n      renderer.clearDepth();\n      renderer.render(scene, camera);\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\n    }\n  };\n\n  this.updateForWindowResize = function () {\n    if (this.enabled) {\n      camera.left = window.innerWidth / -2;\n      camera.right = window.innerWidth / 2;\n      camera.top = window.innerHeight / 2;\n      camera.bottom = window.innerHeight / -2;\n      camera.updateProjectionMatrix();\n      this.update();\n    }\n  };\n\n  this.update = function () {\n    this.position.set(this.position.x, this.position.y);\n    this.size.set(this.size.width, this.size.height);\n  }; //Force an update to set position/size\n\n\n  this.update();\n};\n\nexports.ShadowMapViewer = ShadowMapViewer;\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$three_stdlib$shaders$UnpackDepthRGBAShader"]],"~:properties",["^5",["fragmentShader","map","width","right","top","needsUpdate","height","transparent","side","x","__esModule","enabled","update","position","vertexShader","value","magFilter","font","autoClear","render","y","ShadowMapViewer","updateForWindowResize","bottom","set","size","uniforms","minFilter","left","constructor","fillStyle"]],"~:compiled-at",1630917515402,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$utils$ShadowMapViewer.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/utils/ShadowMapViewer.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$utils$ShadowMapViewer\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ShadowMapViewer = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _UnpackDepthRGBAShader = require(\\\"../shaders/UnpackDepthRGBAShader.js\\\");\\n\\n/**\\n * This is a helper for visualising a given light's shadow map.\\n * It works for shadow casting lights: DirectionalLight and SpotLight.\\n * It renders out the shadow map and displays it on a HUD.\\n *\\n * Example usage:\\n *\\t1) Import ShadowMapViewer into your app.\\n *\\n *\\t2) Create a shadow casting light and name it optionally:\\n *\\t\\tvar light = new DirectionalLight( 0xffffff, 1 );\\n *\\t\\tlight.castShadow = true;\\n *\\t\\tlight.name = 'Sun';\\n *\\n *\\t3) Create a shadow map viewer for that light and set its size and position optionally:\\n *\\t\\tvar shadowMapViewer = new ShadowMapViewer( light );\\n *\\t\\tshadowMapViewer.size.set( 128, 128 );\\t//width, height  default: 256, 256\\n *\\t\\tshadowMapViewer.position.set( 10, 10 );\\t//x, y in pixel\\t default: 0, 0 (top left corner)\\n *\\n *\\t4) Render the shadow map viewer in your render loop:\\n *\\t\\tshadowMapViewer.render( renderer );\\n *\\n *\\t5) Optionally: Update the shadow map viewer on window resize:\\n *\\t\\tshadowMapViewer.updateForWindowResize();\\n *\\n *\\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\\n */\\nvar ShadowMapViewer = function ShadowMapViewer(light) {\\n  //- Internals\\n  var scope = this;\\n  var doRenderLabel = light.name !== undefined && light.name !== '';\\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\\n\\n  var frame = {\\n    x: 10,\\n    y: 10,\\n    width: 256,\\n    height: 256\\n  };\\n  var camera = new _three.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\\n  camera.position.set(0, 0, 2);\\n  var scene = new _three.Scene(); //HUD for shadow map\\n\\n  var shader = _UnpackDepthRGBAShader.UnpackDepthRGBAShader;\\n\\n  var uniforms = _three.UniformsUtils.clone(shader.uniforms);\\n\\n  var material = new _three.ShaderMaterial({\\n    uniforms: uniforms,\\n    vertexShader: shader.vertexShader,\\n    fragmentShader: shader.fragmentShader\\n  });\\n  var plane = new _three.PlaneGeometry(frame.width, frame.height);\\n  var mesh = new _three.Mesh(plane, material);\\n  scene.add(mesh); //Label for light's name\\n\\n  var labelCanvas, labelMesh;\\n\\n  if (doRenderLabel) {\\n    labelCanvas = document.createElement('canvas');\\n    var context = labelCanvas.getContext('2d');\\n    context.font = 'Bold 20px Arial';\\n    var labelWidth = context.measureText(light.name).width;\\n    labelCanvas.width = labelWidth;\\n    labelCanvas.height = 25; //25 to account for g, p, etc.\\n\\n    context.font = 'Bold 20px Arial';\\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\\n    context.fillText(light.name, 0, 20);\\n    var labelTexture = new _three.Texture(labelCanvas);\\n    labelTexture.magFilter = _three.LinearFilter;\\n    labelTexture.minFilter = _three.LinearFilter;\\n    labelTexture.needsUpdate = true;\\n    var labelMaterial = new _three.MeshBasicMaterial({\\n      map: labelTexture,\\n      side: _three.DoubleSide\\n    });\\n    labelMaterial.transparent = true;\\n    var labelPlane = new _three.PlaneGeometry(labelCanvas.width, labelCanvas.height);\\n    labelMesh = new _three.Mesh(labelPlane, labelMaterial);\\n    scene.add(labelMesh);\\n  }\\n\\n  function resetPosition() {\\n    scope.position.set(scope.position.x, scope.position.y);\\n  } //- API\\n  // Set to false to disable displaying this shadow map\\n\\n\\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\\n\\n  this.size = {\\n    width: frame.width,\\n    height: frame.height,\\n    set: function set(width, height) {\\n      this.width = width;\\n      this.height = height;\\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\\n\\n      resetPosition();\\n    }\\n  }; // Set the position of the displayed shadow map on the HUD\\n\\n  this.position = {\\n    x: frame.x,\\n    y: frame.y,\\n    set: function set(x, y) {\\n      this.x = x;\\n      this.y = y;\\n      var width = scope.size.width;\\n      var height = scope.size.height;\\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\\n      if (doRenderLabel) labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\\n    }\\n  };\\n\\n  this.render = function (renderer) {\\n    if (this.enabled) {\\n      //Because a light's .shadowMap is only initialised after the first render pass\\n      //we have to make sure the correct map is sent into the shader, otherwise we\\n      //always end up with the scene's first added shadow casting light's shadowMap\\n      //in the shader\\n      //See: https://github.com/mrdoob/three.js/issues/5932\\n      uniforms.tDiffuse.value = light.shadow.map.texture;\\n      userAutoClearSetting = renderer.autoClear;\\n      renderer.autoClear = false; // To allow render overlay\\n\\n      renderer.clearDepth();\\n      renderer.render(scene, camera);\\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\\n    }\\n  };\\n\\n  this.updateForWindowResize = function () {\\n    if (this.enabled) {\\n      camera.left = window.innerWidth / -2;\\n      camera.right = window.innerWidth / 2;\\n      camera.top = window.innerHeight / 2;\\n      camera.bottom = window.innerHeight / -2;\\n      camera.updateProjectionMatrix();\\n      this.update();\\n    }\\n  };\\n\\n  this.update = function () {\\n    this.position.set(this.position.x, this.position.y);\\n    this.size.set(this.size.width, this.size.height);\\n  }; //Force an update to set position/size\\n\\n\\n  this.update();\\n};\\n\\nexports.ShadowMapViewer = ShadowMapViewer;\\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"ShadowMapViewer\",\"_three\",\"_UnpackDepthRGBAShader\",\"light\",\"scope\",\"doRenderLabel\",\"undefined\",\"name\",\"userAutoClearSetting\",\"camera\",\"OrthographicCamera\",\"window\",\"innerWidth\",\"innerHeight\",\"position\",\"set\",\"scene\",\"Scene\",\"shader\",\"UnpackDepthRGBAShader\",\"uniforms\",\"UniformsUtils\",\"clone\",\"material\",\"ShaderMaterial\",\"vertexShader\",\"fragmentShader\",\"plane\",\"PlaneGeometry\",\"width\",\"height\",\"mesh\",\"Mesh\",\"add\",\"labelCanvas\",\"document\",\"createElement\",\"context\",\"getContext\",\"font\",\"labelWidth\",\"measureText\",\"fillStyle\",\"fillText\",\"labelTexture\",\"Texture\",\"magFilter\",\"LinearFilter\",\"minFilter\",\"needsUpdate\",\"labelMaterial\",\"MeshBasicMaterial\",\"map\",\"side\",\"DoubleSide\",\"transparent\",\"labelPlane\",\"labelMesh\",\"enabled\",\"size\",\"scale\",\"x\",\"y\",\"render\",\"this.render\",\"renderer\",\"tDiffuse\",\"shadow\",\"texture\",\"autoClear\",\"clearDepth\",\"updateForWindowResize\",\"this.updateForWindowResize\",\"left\",\"right\",\"top\",\"bottom\",\"updateProjectionMatrix\",\"update\",\"this.update\",\"prototype\",\"constructor\"]\n}\n"]