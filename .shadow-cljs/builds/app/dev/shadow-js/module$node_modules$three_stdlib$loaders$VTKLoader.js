["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/VTKLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$VTKLoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=\ndescriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};\nreturn _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};\nreturn _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.VTKLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_fflate=require(\"module$node_modules$fflate$esm$browser\");global=function(_Loader){function VTKLoader(manager){if(!(this instanceof VTKLoader))throw new TypeError(\"Cannot call a class as a function\");manager=_getPrototypeOf(VTKLoader).call(this,manager);if(!manager||\"object\"!==_typeof(manager)&&\"function\"!==\ntypeof manager){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");manager=this}return manager}_inherits(VTKLoader,_Loader);_createClass(VTKLoader,[{key:\"load\",value:function(url,onLoad,onProgress,onError){var scope=this,loader=new _three.FileLoader(scope.manager);loader.setPath(scope.path);loader.setResponseType(\"arraybuffer\");loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(text){try{onLoad(scope.parse(text))}catch(e){onError?\nonError(e):console.error(e),scope.manager.itemError(url)}},onProgress,onError)}},{key:\"parse\",value:function(data$jscomp$0){function parseASCII(data){var indices=[],positions=[],colors=[],normals=[],patWord=/^[^\\d.\\s-]+/,pat3Floats=/(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g,patConnectivity=/^(\\d+)\\s+([\\s\\d]*)/,patPOINTS=/^POINTS /,patPOLYGONS=/^POLYGONS /,patTRIANGLE_STRIPS=/^TRIANGLE_STRIPS /,patPOINT_DATA=/^POINT_DATA[ ]+(\\d+)/,patCELL_DATA=/^CELL_DATA[ ]+(\\d+)/,patCOLOR_SCALARS=\n/^COLOR_SCALARS[ ]+(\\w+)[ ]+3/,patNORMALS=/^NORMALS[ ]+(\\w+)[ ]+(\\w+)/,inPointsSection=!1,inPolygonsSection=!1,inTriangleStripSection=!1,inPointDataSection=!1,inCellDataSection=!1,inColorSection=!1,inNormalsSection=!1;data=data.split(\"\\n\");for(var i in data){var line=data[i].trim();if(0===line.indexOf(\"DATASET\")){var result=line.split(\" \")[1];if(\"POLYDATA\"!==result)throw Error(\"Unsupported DATASET type: \"+result);}else if(inPointsSection)for(;null!==(result=pat3Floats.exec(line))&&null===patWord.exec(line);){var x=\nparseFloat(result[1]),y=parseFloat(result[2]);result=parseFloat(result[3]);positions.push(x,y,result)}else if(inPolygonsSection){if(null!==(result=patConnectivity.exec(line))&&(x=parseInt(result[1]),result=result[2].split(/\\s+/),3<=x)){y=parseInt(result[0]);for(var i1,i2,k=1,j=0;j<x-2;++j)i1=parseInt(result[k]),i2=parseInt(result[k+1]),indices.push(y,i1,i2),k++}}else if(inTriangleStripSection){if(null!==(result=patConnectivity.exec(line))&&(x=parseInt(result[1]),result=result[2].split(/\\s+/),3<=x))for(j=\n0;j<x-2;j++)1===j%2?(y=parseInt(result[j]),i1=parseInt(result[j+2]),i2=parseInt(result[j+1])):(y=parseInt(result[j]),i1=parseInt(result[j+1]),i2=parseInt(result[j+2])),indices.push(y,i1,i2)}else if(inPointDataSection||inCellDataSection)if(inColorSection)for(;null!==(result=pat3Floats.exec(line))&&null===patWord.exec(line);)x=parseFloat(result[1]),y=parseFloat(result[2]),result=parseFloat(result[3]),colors.push(x,y,result);else if(inNormalsSection)for(;null!==(result=pat3Floats.exec(line))&&null===\npatWord.exec(line);)x=parseFloat(result[1]),y=parseFloat(result[2]),result=parseFloat(result[3]),normals.push(x,y,result);null!==patPOLYGONS.exec(line)?(inPolygonsSection=!0,inTriangleStripSection=inPointsSection=!1):null!==patPOINTS.exec(line)?(inPolygonsSection=!1,inPointsSection=!0,inTriangleStripSection=!1):null!==patTRIANGLE_STRIPS.exec(line)?(inPointsSection=inPolygonsSection=!1,inTriangleStripSection=!0):null!==patPOINT_DATA.exec(line)?(inPointDataSection=!0,inTriangleStripSection=inPolygonsSection=\ninPointsSection=!1):null!==patCELL_DATA.exec(line)?(inCellDataSection=!0,inTriangleStripSection=inPolygonsSection=inPointsSection=!1):null!==patCOLOR_SCALARS.exec(line)?(inColorSection=!0,inTriangleStripSection=inPolygonsSection=inPointsSection=inNormalsSection=!1):null!==patNORMALS.exec(line)&&(inNormalsSection=!0,inTriangleStripSection=inPolygonsSection=inPointsSection=inColorSection=!1)}patWord=new _three.BufferGeometry;patWord.setIndex(indices);patWord.setAttribute(\"position\",new _three.Float32BufferAttribute(positions,\n3));normals.length===positions.length&&patWord.setAttribute(\"normal\",new _three.Float32BufferAttribute(normals,3));if(colors.length!==indices.length)colors.length===positions.length&&patWord.setAttribute(\"color\",new _three.Float32BufferAttribute(colors,3));else if(patWord=patWord.toNonIndexed(),indices=patWord.attributes.position.count/3,colors.length===3*indices){positions=[];for(i=0;i<indices;i++)x=colors[3*i],y=colors[3*i+1],result=colors[3*i+2],positions.push(x,y,result),positions.push(x,y,result),\npositions.push(x,y,result);patWord.setAttribute(\"color\",new _three.Float32BufferAttribute(positions,3))}return patWord}function parseBinary(data){function findString(buffer,start){for(var index=start,c=buffer[index],s=[];10!==c;)s.push(String.fromCharCode(c)),index++,c=buffer[index];return{start,end:index,next:index+1,parsedString:s.join(\"\")}}var i,s$jscomp$0,buffer$jscomp$0=new Uint8Array(data),dataView=new DataView(data);data=[];for(var normals=[],indices=[],index$jscomp$0=0;;){index$jscomp$0=findString(buffer$jscomp$0,\nindex$jscomp$0);var count=index$jscomp$0.parsedString;if(0===count.indexOf(\"DATASET\")){if(count=count.split(\" \")[1],\"POLYDATA\"!==count)throw Error(\"Unsupported DATASET type: \"+count);}else if(0===count.indexOf(\"POINTS\")){var numberOfPoints=parseInt(count.split(\" \")[1],10);count=12*numberOfPoints;data=new Float32Array(3*numberOfPoints);var pointIndex=index$jscomp$0.next;for(i=0;i<numberOfPoints;i++)data[3*i]=dataView.getFloat32(pointIndex,!1),data[3*i+1]=dataView.getFloat32(pointIndex+4,!1),data[3*\ni+2]=dataView.getFloat32(pointIndex+8,!1),pointIndex+=12;index$jscomp$0.next=index$jscomp$0.next+count+1}else if(0===count.indexOf(\"TRIANGLE_STRIPS\")){numberOfPoints=parseInt(count.split(\" \")[1],10);indices=parseInt(count.split(\" \")[2],10);count=4*indices;indices=new Uint32Array(3*indices-9*numberOfPoints);var indicesIndex=0;pointIndex=index$jscomp$0.next;for(i=0;i<numberOfPoints;i++){var indexCount=dataView.getInt32(pointIndex,!1),strip=[];pointIndex+=4;for(s$jscomp$0=0;s$jscomp$0<indexCount;s$jscomp$0++)strip.push(dataView.getInt32(pointIndex,\n!1)),pointIndex+=4;for(s$jscomp$0=0;s$jscomp$0<indexCount-2;s$jscomp$0++)s$jscomp$0%2?(indices[indicesIndex++]=strip[s$jscomp$0],indices[indicesIndex++]=strip[s$jscomp$0+2],indices[indicesIndex++]=strip[s$jscomp$0+1]):(indices[indicesIndex++]=strip[s$jscomp$0],indices[indicesIndex++]=strip[s$jscomp$0+1],indices[indicesIndex++]=strip[s$jscomp$0+2])}index$jscomp$0.next=index$jscomp$0.next+count+1}else if(0===count.indexOf(\"POLYGONS\")){numberOfPoints=parseInt(count.split(\" \")[1],10);indices=parseInt(count.split(\" \")[2],\n10);count=4*indices;indices=new Uint32Array(3*indices-9*numberOfPoints);indicesIndex=0;pointIndex=index$jscomp$0.next;for(i=0;i<numberOfPoints;i++){indexCount=dataView.getInt32(pointIndex,!1);strip=[];pointIndex+=4;for(s$jscomp$0=0;s$jscomp$0<indexCount;s$jscomp$0++)strip.push(dataView.getInt32(pointIndex,!1)),pointIndex+=4;for(s$jscomp$0=1;s$jscomp$0<indexCount-1;s$jscomp$0++)indices[indicesIndex++]=strip[0],indices[indicesIndex++]=strip[s$jscomp$0],indices[indicesIndex++]=strip[s$jscomp$0+1]}index$jscomp$0.next=\nindex$jscomp$0.next+count+1}else if(0===count.indexOf(\"POINT_DATA\")){numberOfPoints=parseInt(count.split(\" \")[1],10);index$jscomp$0=findString(buffer$jscomp$0,index$jscomp$0.next);count=12*numberOfPoints;normals=new Float32Array(3*numberOfPoints);pointIndex=index$jscomp$0.next;for(i=0;i<numberOfPoints;i++)normals[3*i]=dataView.getFloat32(pointIndex,!1),normals[3*i+1]=dataView.getFloat32(pointIndex+4,!1),normals[3*i+2]=dataView.getFloat32(pointIndex+8,!1),pointIndex+=12;index$jscomp$0.next+=count}index$jscomp$0=\nindex$jscomp$0.next;if(index$jscomp$0>=buffer$jscomp$0.byteLength)break}buffer$jscomp$0=new _three.BufferGeometry;buffer$jscomp$0.setIndex(new _three.BufferAttribute(indices,1));buffer$jscomp$0.setAttribute(\"position\",new _three.BufferAttribute(data,3));normals.length===data.length&&buffer$jscomp$0.setAttribute(\"normal\",new _three.BufferAttribute(normals,3));return buffer$jscomp$0}function Float32Concat(first,second){var firstLength=first.length,result=new Float32Array(firstLength+second.length);\nresult.set(first);result.set(second,firstLength);return result}function Int32Concat(first,second){var firstLength=first.length,result=new Int32Array(firstLength+second.length);result.set(first);result.set(second,firstLength);return result}function parseXML(stringFile){function xmlToJson(xml){var obj={};if(1===xml.nodeType){if(xml.attributes&&0<xml.attributes.length){obj.attributes={};for(var j=0;j<xml.attributes.length;j++){var attribute=xml.attributes.item(j);obj.attributes[attribute.nodeName]=attribute.nodeValue.trim()}}}else 3===\nxml.nodeType&&(obj=xml.nodeValue.trim());if(xml.hasChildNodes())for(j=0;j<xml.childNodes.length;j++){var item=xml.childNodes.item(j);attribute=item.nodeName;\"undefined\"===typeof obj[attribute]?(item=xmlToJson(item),\"\"!==item&&(obj[attribute]=item)):(\"undefined\"===typeof obj[attribute].push&&(obj[attribute]=[obj[attribute]]),item=xmlToJson(item),\"\"!==item&&obj[attribute].push(item))}return obj}function Base64toByteArray(b64){var Arr=\"undefined\"!==typeof Uint8Array?Uint8Array:Array,i,revLookup=[],len=\n64;for(i=0;i<len;i++);for(i=0;i<len;++i)revLookup[\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charCodeAt(i)]=i;revLookup[45]=62;revLookup[95]=63;len=b64.length;if(0<len%4)throw Error(\"Invalid string. Length must be a multiple of 4\");var placeHolders=\"\\x3d\"===b64[len-2]?2:\"\\x3d\"===b64[len-1]?1:0;Arr=new Arr(3*len/4-placeHolders);len=0<placeHolders?len-4:len;var L=0;for(i=0;i<len;i+=4){var tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+\n2)]<<6|revLookup[b64.charCodeAt(i+3)];Arr[L++]=(tmp&16711680)>>16;Arr[L++]=(tmp&65280)>>8;Arr[L++]=tmp&255}2===placeHolders?(tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4,Arr[L++]=tmp&255):1===placeHolders&&(tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+2)]>>2,Arr[L++]=tmp>>8&255,Arr[L++]=tmp&255);return Arr}function parseDataArray(ele,compressed){var numBytes=0;\"UInt64\"===json.attributes.header_type?numBytes=8:\"UInt32\"===\njson.attributes.header_type&&(numBytes=4);if(\"binary\"===ele.attributes.format&&compressed){var headerSize;if(\"Float32\"===ele.attributes.type)var txt=new Float32Array;else\"Int64\"===ele.attributes.type&&(txt=new Int32Array);compressed=Base64toByteArray(ele[\"#text\"]);var content=compressed[0];for(headerSize=1;headerSize<numBytes-1;headerSize++)content|=compressed[headerSize]<<headerSize*numBytes;headerSize=(content+3)*numBytes;var dataOffsets=[];var currentOffset=headerSize+(0<headerSize%3?3-headerSize%\n3:0);dataOffsets.push(currentOffset);var cSizeStart=3*numBytes;for(headerSize=0;headerSize<content;headerSize++){for(var currentBlockSize=compressed[headerSize*numBytes+cSizeStart],j=1;j<numBytes-1;j++)currentBlockSize|=compressed[headerSize*numBytes+cSizeStart+j]<<8*j;currentOffset+=currentBlockSize;dataOffsets.push(currentOffset)}for(headerSize=0;headerSize<dataOffsets.length-1;headerSize++)content=(0,_fflate.unzlibSync)(compressed.slice(dataOffsets[headerSize],dataOffsets[headerSize+1])).buffer,\n\"Float32\"===ele.attributes.type?(content=new Float32Array(content),txt=Float32Concat(txt,content)):\"Int64\"===ele.attributes.type&&(content=new Int32Array(content),txt=Int32Concat(txt,content));delete ele[\"#text\"];\"Int64\"===ele.attributes.type&&\"binary\"===ele.attributes.format&&(txt=txt.filter(function(el,idx){if(1!==idx%2)return!0}))}else\"binary\"!==ele.attributes.format||compressed?content=ele[\"#text\"]?ele[\"#text\"].split(/\\s+/).filter(function(el){if(\"\"!==el)return el}):(new Int32Array(0)).buffer:\n(content=Base64toByteArray(ele[\"#text\"]),content=content.slice(numBytes).buffer),delete ele[\"#text\"],\"Float32\"===ele.attributes.type?txt=new Float32Array(content):\"Int32\"===ele.attributes.type?txt=new Int32Array(content):\"Int64\"===ele.attributes.type&&(txt=new Int32Array(content),\"binary\"===ele.attributes.format&&(txt=txt.filter(function(el,idx){if(1!==idx%2)return!0})));return txt}var dom=null;if(window.DOMParser)try{dom=(new DOMParser).parseFromString(stringFile,\"text/xml\")}catch(e){dom=null}else if(window.ActiveXObject)try{if(dom=\nnew ActiveXObject(\"Microsoft.XMLDOM\"),dom.async=!1,!dom.loadXML())throw Error(dom.parseError.reason+dom.parseError.srcText);}catch(e){dom=null}else throw Error(\"Cannot parse xml string!\");var json=xmlToJson(dom.documentElement);stringFile=[];dom=[];var indices=[];if(json.PolyData){for(var piece=json.PolyData.Piece,compressed$jscomp$0=json.attributes.hasOwnProperty(\"compressor\"),sections=[\"PointData\",\"Points\",\"Strips\",\"Polys\"],sectionIndex=0,numberOfSections=sections.length;sectionIndex<numberOfSections;){var section=\npiece[sections[sectionIndex]];if(section&&section.DataArray){for(var arr=\"[object Array]\"===Object.prototype.toString.call(section.DataArray)?section.DataArray:[section.DataArray],dataArrayIndex=0,numberOfDataArrays=arr.length;dataArrayIndex<numberOfDataArrays;)\"#text\"in arr[dataArrayIndex]&&0<arr[dataArrayIndex][\"#text\"].length&&(arr[dataArrayIndex].text=parseDataArray(arr[dataArrayIndex],compressed$jscomp$0)),dataArrayIndex++;switch(sections[sectionIndex]){case \"PointData\":numberOfDataArrays=parseInt(piece.attributes.NumberOfPoints);\nvar normalsName=section.attributes.Normals;if(0<numberOfDataArrays)for(section=0,dataArrayIndex=arr.length;section<dataArrayIndex;section++)if(normalsName===arr[section].attributes.Name){var components=arr[section].attributes.NumberOfComponents;dom=new Float32Array(numberOfDataArrays*components);dom.set(arr[section].text,0)}break;case \"Points\":numberOfDataArrays=parseInt(piece.attributes.NumberOfPoints);0<numberOfDataArrays&&(components=section.DataArray.attributes.NumberOfComponents,stringFile=new Float32Array(numberOfDataArrays*\ncomponents),stringFile.set(section.DataArray.text,0));break;case \"Strips\":dataArrayIndex=parseInt(piece.attributes.NumberOfStrips);if(0<dataArrayIndex)for(arr=new Int32Array(section.DataArray[0].text.length),numberOfDataArrays=new Int32Array(section.DataArray[1].text.length),arr.set(section.DataArray[0].text,0),numberOfDataArrays.set(section.DataArray[1].text,0),indices=dataArrayIndex+arr.length,indices=new Uint32Array(3*indices-9*dataArrayIndex),section=components=0;section<dataArrayIndex;section++){var strip=\n[],s=0;normalsName=numberOfDataArrays[section];for(var len0=0;s<normalsName-len0;s++)strip.push(arr[s]),0<section&&(len0=numberOfDataArrays[section-1]);s=0;normalsName=numberOfDataArrays[section];for(len0=0;s<normalsName-len0-2;s++)s%2?(indices[components++]=strip[s],indices[components++]=strip[s+2],indices[components++]=strip[s+1]):(indices[components++]=strip[s],indices[components++]=strip[s+1],indices[components++]=strip[s+2]),0<section&&(len0=numberOfDataArrays[section-1])}break;case \"Polys\":if(dataArrayIndex=\nparseInt(piece.attributes.NumberOfPolys),0<dataArrayIndex)for(arr=new Int32Array(section.DataArray[0].text.length),numberOfDataArrays=new Int32Array(section.DataArray[1].text.length),arr.set(section.DataArray[0].text,0),numberOfDataArrays.set(section.DataArray[1].text,0),indices=dataArrayIndex+arr.length,indices=new Uint32Array(3*indices-9*dataArrayIndex),len0=section=strip=components=0;section<dataArrayIndex;){var poly=[];s=0;for(normalsName=numberOfDataArrays[section];s<normalsName-len0;)poly.push(arr[strip++]),\ns++;for(s=1;s<normalsName-len0-1;)indices[components++]=poly[0],indices[components++]=poly[s],indices[components++]=poly[s+1],s++;section++;len0=numberOfDataArrays[section-1]}}}sectionIndex++}piece=new _three.BufferGeometry;piece.setIndex(new _three.BufferAttribute(indices,1));piece.setAttribute(\"position\",new _three.BufferAttribute(stringFile,3));dom.length===stringFile.length&&piece.setAttribute(\"normal\",new _three.BufferAttribute(dom,3));return piece}throw Error(\"Unsupported DATASET type\");}var meta=\n_three.LoaderUtils.decodeText(new Uint8Array(data$jscomp$0,0,250)).split(\"\\n\");return-1!==meta[0].indexOf(\"xml\")?parseXML(_three.LoaderUtils.decodeText(data$jscomp$0)):meta[2].includes(\"ASCII\")?parseASCII(_three.LoaderUtils.decodeText(data$jscomp$0)):parseBinary(data$jscomp$0)}}]);return VTKLoader}(_three.Loader);exports.VTKLoader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$VTKLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VTKLoader = void 0;\n\nvar _three = require(\"three\");\n\nvar _fflate = require(\"fflate\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar VTKLoader =\n/*#__PURE__*/\nfunction (_Loader) {\n  _inherits(VTKLoader, _Loader);\n\n  function VTKLoader(manager) {\n    _classCallCheck(this, VTKLoader);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(VTKLoader).call(this, manager));\n  }\n\n  _createClass(VTKLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new _three.FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function parseASCII(data) {\n        // connectivity of the triangles\n        var indices = []; // triangles vertices\n\n        var positions = []; // red, green, blue colors in the range 0 to 1\n\n        var colors = []; // normal vector, one per vertex\n\n        var normals = [];\n        var result; // pattern for detecting the end of a number sequence\n\n        var patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers\n\n        var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\n        // the first integer is the number of polygon nodes\n\n        var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section\n\n        var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\n\n        var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\n\n        var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\n\n        var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys\n\n        var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section\n\n        var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float\n\n        var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n        var inPointsSection = false;\n        var inPolygonsSection = false;\n        var inTriangleStripSection = false;\n        var inPointDataSection = false;\n        var inCellDataSection = false;\n        var inColorSection = false;\n        var inNormalsSection = false;\n        var lines = data.split('\\n');\n\n        for (var i in lines) {\n          var line = lines[i].trim();\n\n          if (line.indexOf('DATASET') === 0) {\n            var dataset = line.split(' ')[1];\n            if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n          } else if (inPointsSection) {\n            // get the vertices\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var x = parseFloat(result[1]);\n              var y = parseFloat(result[2]);\n              var z = parseFloat(result[3]);\n              positions.push(x, y, z);\n            }\n          } else if (inPolygonsSection) {\n            if ((result = patConnectivity.exec(line)) !== null) {\n              // numVertices i0 i1 i2 ...\n              var numVertices = parseInt(result[1]);\n              var inds = result[2].split(/\\s+/);\n\n              if (numVertices >= 3) {\n                var i0 = parseInt(inds[0]);\n                var i1, i2;\n                var k = 1; // split the polygon in numVertices - 2 triangles\n\n                for (var j = 0; j < numVertices - 2; ++j) {\n                  i1 = parseInt(inds[k]);\n                  i2 = parseInt(inds[k + 1]);\n                  indices.push(i0, i1, i2);\n                  k++;\n                }\n              }\n            }\n          } else if (inTriangleStripSection) {\n            if ((result = patConnectivity.exec(line)) !== null) {\n              // numVertices i0 i1 i2 ...\n              var numVertices = parseInt(result[1]);\n              var inds = result[2].split(/\\s+/);\n\n              if (numVertices >= 3) {\n                var i0, i1, i2; // split the polygon in numVertices - 2 triangles\n\n                for (var j = 0; j < numVertices - 2; j++) {\n                  if (j % 2 === 1) {\n                    i0 = parseInt(inds[j]);\n                    i1 = parseInt(inds[j + 2]);\n                    i2 = parseInt(inds[j + 1]);\n                    indices.push(i0, i1, i2);\n                  } else {\n                    i0 = parseInt(inds[j]);\n                    i1 = parseInt(inds[j + 1]);\n                    i2 = parseInt(inds[j + 2]);\n                    indices.push(i0, i1, i2);\n                  }\n                }\n              }\n            }\n          } else if (inPointDataSection || inCellDataSection) {\n            if (inColorSection) {\n              // Get the colors\n              while ((result = pat3Floats.exec(line)) !== null) {\n                if (patWord.exec(line) !== null) break;\n                var r = parseFloat(result[1]);\n                var g = parseFloat(result[2]);\n                var b = parseFloat(result[3]);\n                colors.push(r, g, b);\n              }\n            } else if (inNormalsSection) {\n              // Get the normal vectors\n              while ((result = pat3Floats.exec(line)) !== null) {\n                if (patWord.exec(line) !== null) break;\n                var nx = parseFloat(result[1]);\n                var ny = parseFloat(result[2]);\n                var nz = parseFloat(result[3]);\n                normals.push(nx, ny, nz);\n              }\n            }\n          }\n\n          if (patPOLYGONS.exec(line) !== null) {\n            inPolygonsSection = true;\n            inPointsSection = false;\n            inTriangleStripSection = false;\n          } else if (patPOINTS.exec(line) !== null) {\n            inPolygonsSection = false;\n            inPointsSection = true;\n            inTriangleStripSection = false;\n          } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n            inPolygonsSection = false;\n            inPointsSection = false;\n            inTriangleStripSection = true;\n          } else if (patPOINT_DATA.exec(line) !== null) {\n            inPointDataSection = true;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patCELL_DATA.exec(line) !== null) {\n            inCellDataSection = true;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patCOLOR_SCALARS.exec(line) !== null) {\n            inColorSection = true;\n            inNormalsSection = false;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patNORMALS.exec(line) !== null) {\n            inNormalsSection = true;\n            inColorSection = false;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          }\n        }\n\n        var geometry = new _three.BufferGeometry();\n        geometry.setIndex(indices);\n        geometry.setAttribute('position', new _three.Float32BufferAttribute(positions, 3));\n\n        if (normals.length === positions.length) {\n          geometry.setAttribute('normal', new _three.Float32BufferAttribute(normals, 3));\n        }\n\n        if (colors.length !== indices.length) {\n          // stagger\n          if (colors.length === positions.length) {\n            geometry.setAttribute('color', new _three.Float32BufferAttribute(colors, 3));\n          }\n        } else {\n          // cell\n          geometry = geometry.toNonIndexed();\n          var numTriangles = geometry.attributes.position.count / 3;\n\n          if (colors.length === numTriangles * 3) {\n            var newColors = [];\n\n            for (var i = 0; i < numTriangles; i++) {\n              var r = colors[3 * i + 0];\n              var g = colors[3 * i + 1];\n              var b = colors[3 * i + 2];\n              newColors.push(r, g, b);\n              newColors.push(r, g, b);\n              newColors.push(r, g, b);\n            }\n\n            geometry.setAttribute('color', new _three.Float32BufferAttribute(newColors, 3));\n          }\n        }\n\n        return geometry;\n      }\n\n      function parseBinary(data) {\n        var count, pointIndex, i, numberOfPoints, s;\n        var buffer = new Uint8Array(data);\n        var dataView = new DataView(data); // Points and normals, by default, are empty\n\n        var points = [];\n        var normals = [];\n        var indices = []; // Going to make a big array of strings\n\n        var index = 0;\n\n        function findString(buffer, start) {\n          var index = start;\n          var c = buffer[index];\n          var s = [];\n\n          while (c !== 10) {\n            s.push(String.fromCharCode(c));\n            index++;\n            c = buffer[index];\n          }\n\n          return {\n            start: start,\n            end: index,\n            next: index + 1,\n            parsedString: s.join('')\n          };\n        }\n\n        var state, line;\n\n        while (true) {\n          // Get a string\n          state = findString(buffer, index);\n          line = state.parsedString;\n\n          if (line.indexOf('DATASET') === 0) {\n            var dataset = line.split(' ')[1];\n            if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n          } else if (line.indexOf('POINTS') === 0) {\n            numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\n\n            count = numberOfPoints * 4 * 3;\n            points = new Float32Array(numberOfPoints * 3);\n            pointIndex = state.next;\n\n            for (i = 0; i < numberOfPoints; i++) {\n              points[3 * i] = dataView.getFloat32(pointIndex, false);\n              points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n              points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n              pointIndex = pointIndex + 12;\n            } // increment our next pointer\n\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n            var numberOfStrips = parseInt(line.split(' ')[1], 10);\n            var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n            count = size * 4;\n            indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n            var indicesIndex = 0;\n            pointIndex = state.next;\n\n            for (i = 0; i < numberOfStrips; i++) {\n              // For each strip, read the first value, then record that many more points\n              var indexCount = dataView.getInt32(pointIndex, false);\n              var strip = [];\n              pointIndex += 4;\n\n              for (s = 0; s < indexCount; s++) {\n                strip.push(dataView.getInt32(pointIndex, false));\n                pointIndex += 4;\n              } // retrieves the n-2 triangles from the triangle strip\n\n\n              for (var j = 0; j < indexCount - 2; j++) {\n                if (j % 2) {\n                  indices[indicesIndex++] = strip[j];\n                  indices[indicesIndex++] = strip[j + 2];\n                  indices[indicesIndex++] = strip[j + 1];\n                } else {\n                  indices[indicesIndex++] = strip[j];\n                  indices[indicesIndex++] = strip[j + 1];\n                  indices[indicesIndex++] = strip[j + 2];\n                }\n              }\n            } // increment our next pointer\n\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('POLYGONS') === 0) {\n            var numberOfStrips = parseInt(line.split(' ')[1], 10);\n            var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n            count = size * 4;\n            indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n            var indicesIndex = 0;\n            pointIndex = state.next;\n\n            for (i = 0; i < numberOfStrips; i++) {\n              // For each strip, read the first value, then record that many more points\n              var indexCount = dataView.getInt32(pointIndex, false);\n              var strip = [];\n              pointIndex += 4;\n\n              for (s = 0; s < indexCount; s++) {\n                strip.push(dataView.getInt32(pointIndex, false));\n                pointIndex += 4;\n              } // divide the polygon in n-2 triangle\n\n\n              for (var j = 1; j < indexCount - 1; j++) {\n                indices[indicesIndex++] = strip[0];\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n              }\n            } // increment our next pointer\n\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('POINT_DATA') === 0) {\n            numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\n\n            state = findString(buffer, state.next); // Now grab the binary data\n\n            count = numberOfPoints * 4 * 3;\n            normals = new Float32Array(numberOfPoints * 3);\n            pointIndex = state.next;\n\n            for (i = 0; i < numberOfPoints; i++) {\n              normals[3 * i] = dataView.getFloat32(pointIndex, false);\n              normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n              normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n              pointIndex += 12;\n            } // Increment past our data\n\n\n            state.next = state.next + count;\n          } // Increment index\n\n\n          index = state.next;\n\n          if (index >= buffer.byteLength) {\n            break;\n          }\n        }\n\n        var geometry = new _three.BufferGeometry();\n        geometry.setIndex(new _three.BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new _three.BufferAttribute(points, 3));\n\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new _three.BufferAttribute(normals, 3));\n        }\n\n        return geometry;\n      }\n\n      function Float32Concat(first, second) {\n        var firstLength = first.length,\n            result = new Float32Array(firstLength + second.length);\n        result.set(first);\n        result.set(second, firstLength);\n        return result;\n      }\n\n      function Int32Concat(first, second) {\n        var firstLength = first.length,\n            result = new Int32Array(firstLength + second.length);\n        result.set(first);\n        result.set(second, firstLength);\n        return result;\n      }\n\n      function parseXML(stringFile) {\n        // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n        function xmlToJson(xml) {\n          // Create the return object\n          var obj = {};\n\n          if (xml.nodeType === 1) {\n            // element\n            // do attributes\n            if (xml.attributes) {\n              if (xml.attributes.length > 0) {\n                obj['attributes'] = {};\n\n                for (var j = 0; j < xml.attributes.length; j++) {\n                  var attribute = xml.attributes.item(j);\n                  obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n                }\n              }\n            }\n          } else if (xml.nodeType === 3) {\n            // text\n            obj = xml.nodeValue.trim();\n          } // do children\n\n\n          if (xml.hasChildNodes()) {\n            for (var i = 0; i < xml.childNodes.length; i++) {\n              var item = xml.childNodes.item(i);\n              var nodeName = item.nodeName;\n\n              if (typeof obj[nodeName] === 'undefined') {\n                var tmp = xmlToJson(item);\n                if (tmp !== '') obj[nodeName] = tmp;\n              } else {\n                if (typeof obj[nodeName].push === 'undefined') {\n                  var old = obj[nodeName];\n                  obj[nodeName] = [old];\n                }\n\n                var tmp = xmlToJson(item);\n                if (tmp !== '') obj[nodeName].push(tmp);\n              }\n            }\n          }\n\n          return obj;\n        } // Taken from Base64-js\n\n\n        function Base64toByteArray(b64) {\n          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n          var i;\n          var lookup = [];\n          var revLookup = [];\n          var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n          var len = code.length;\n\n          for (i = 0; i < len; i++) {\n            lookup[i] = code[i];\n          }\n\n          for (i = 0; i < len; ++i) {\n            revLookup[code.charCodeAt(i)] = i;\n          }\n\n          revLookup['-'.charCodeAt(0)] = 62;\n          revLookup['_'.charCodeAt(0)] = 63;\n          var j, l, tmp, placeHolders, arr;\n          var len = b64.length;\n\n          if (len % 4 > 0) {\n            throw new Error('Invalid string. Length must be a multiple of 4');\n          }\n\n          placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n          arr = new Arr(len * 3 / 4 - placeHolders);\n          l = placeHolders > 0 ? len - 4 : len;\n          var L = 0;\n\n          for (i = 0, j = 0; i < l; i += 4, j += 3) {\n            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n            arr[L++] = (tmp & 0xff0000) >> 16;\n            arr[L++] = (tmp & 0xff00) >> 8;\n            arr[L++] = tmp & 0xff;\n          }\n\n          if (placeHolders === 2) {\n            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n            arr[L++] = tmp & 0xff;\n          } else if (placeHolders === 1) {\n            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n            arr[L++] = tmp >> 8 & 0xff;\n            arr[L++] = tmp & 0xff;\n          }\n\n          return arr;\n        }\n\n        function parseDataArray(ele, compressed) {\n          var numBytes = 0;\n\n          if (json.attributes.header_type === 'UInt64') {\n            numBytes = 8;\n          } else if (json.attributes.header_type === 'UInt32') {\n            numBytes = 4;\n          } // Check the format\n\n\n          if (ele.attributes.format === 'binary' && compressed) {\n            var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n            if (ele.attributes.type === 'Float32') {\n              var txt = new Float32Array();\n            } else if (ele.attributes.type === 'Int64') {\n              var txt = new Int32Array();\n            } // VTP data with the header has the following structure:\n            // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n            //\n            // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n            // [#blocks] = Number of blocks\n            // [#u-size] = Block size before compression\n            // [#p-size] = Size of last partial block (zero if it not needed)\n            // [#c-size-i] = Size in bytes of block i after compression\n            //\n            // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n            // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\n            rawData = ele['#text'];\n            byteData = Base64toByteArray(rawData);\n            blocks = byteData[0];\n\n            for (var i = 1; i < numBytes - 1; i++) {\n              blocks = blocks | byteData[i] << i * numBytes;\n            }\n\n            headerSize = (blocks + 3) * numBytes;\n            padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n            headerSize = headerSize + padding;\n            dataOffsets = [];\n            currentOffset = headerSize;\n            dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\n            // There are three blocks before c-size-i, so we skip 3*numBytes\n\n            cSizeStart = 3 * numBytes;\n\n            for (var i = 0; i < blocks; i++) {\n              var currentBlockSize = byteData[i * numBytes + cSizeStart];\n\n              for (var j = 1; j < numBytes - 1; j++) {\n                // Each data point consists of 8 bytes regardless of the header type\n                currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n              }\n\n              currentOffset = currentOffset + currentBlockSize;\n              dataOffsets.push(currentOffset);\n            }\n\n            for (var i = 0; i < dataOffsets.length - 1; i++) {\n              var data = (0, _fflate.unzlibSync)(byteData.slice(dataOffsets[i], dataOffsets[i + 1])); // eslint-disable-line no-undef\n\n              content = data.buffer;\n\n              if (ele.attributes.type === 'Float32') {\n                content = new Float32Array(content);\n                txt = Float32Concat(txt, content);\n              } else if (ele.attributes.type === 'Int64') {\n                content = new Int32Array(content);\n                txt = Int32Concat(txt, content);\n              }\n            }\n\n            delete ele['#text'];\n\n            if (ele.attributes.type === 'Int64') {\n              if (ele.attributes.format === 'binary') {\n                txt = txt.filter(function (el, idx) {\n                  if (idx % 2 !== 1) return true;\n                });\n              }\n            }\n          } else {\n            if (ele.attributes.format === 'binary' && !compressed) {\n              var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\n              // [#bytes][DATA]\n              // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\n              content = content.slice(numBytes).buffer;\n            } else {\n              if (ele['#text']) {\n                var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                  if (el !== '') return el;\n                });\n              } else {\n                var content = new Int32Array(0).buffer;\n              }\n            }\n\n            delete ele['#text']; // Get the content and optimize it\n\n            if (ele.attributes.type === 'Float32') {\n              var txt = new Float32Array(content);\n            } else if (ele.attributes.type === 'Int32') {\n              var txt = new Int32Array(content);\n            } else if (ele.attributes.type === 'Int64') {\n              var txt = new Int32Array(content);\n\n              if (ele.attributes.format === 'binary') {\n                txt = txt.filter(function (el, idx) {\n                  if (idx % 2 !== 1) return true;\n                });\n              }\n            }\n          } // endif ( ele.attributes.format === 'binary' && compressed )\n\n\n          return txt;\n        } // Main part\n        // Get Dom\n\n\n        var dom = null;\n\n        if (window.DOMParser) {\n          try {\n            dom = new DOMParser().parseFromString(stringFile, 'text/xml');\n          } catch (e) {\n            dom = null;\n          }\n        } else if (window.ActiveXObject) {\n          try {\n            dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\n            dom.async = false;\n\n            if (!dom.loadXML()) {\n              throw new Error(dom.parseError.reason + dom.parseError.srcText);\n            }\n          } catch (e) {\n            dom = null;\n          }\n        } else {\n          throw new Error('Cannot parse xml string!');\n        } // Get the doc\n\n\n        var doc = dom.documentElement; // Convert to json\n\n        var json = xmlToJson(doc);\n        var points = [];\n        var normals = [];\n        var indices = [];\n\n        if (json.PolyData) {\n          var piece = json.PolyData.Piece;\n          var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\n          // Loop through the sections\n\n          var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\n          var sectionIndex = 0,\n              numberOfSections = sections.length;\n\n          while (sectionIndex < numberOfSections) {\n            var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\n\n            if (section && section.DataArray) {\n              // Depending on the number of DataArrays\n              if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n                var arr = section.DataArray;\n              } else {\n                var arr = [section.DataArray];\n              }\n\n              var dataArrayIndex = 0,\n                  numberOfDataArrays = arr.length;\n\n              while (dataArrayIndex < numberOfDataArrays) {\n                // Parse the DataArray\n                if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                  arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n                }\n\n                dataArrayIndex++;\n              }\n\n              switch (sections[sectionIndex]) {\n                // if iti is point data\n                case 'PointData':\n                  var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                  var normalsName = section.attributes.Normals;\n\n                  if (numberOfPoints > 0) {\n                    for (var i = 0, len = arr.length; i < len; i++) {\n                      if (normalsName === arr[i].attributes.Name) {\n                        var components = arr[i].attributes.NumberOfComponents;\n                        normals = new Float32Array(numberOfPoints * components);\n                        normals.set(arr[i].text, 0);\n                      }\n                    }\n                  }\n\n                  break;\n                // if it is points\n\n                case 'Points':\n                  var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\n                  if (numberOfPoints > 0) {\n                    var components = section.DataArray.attributes.NumberOfComponents;\n                    points = new Float32Array(numberOfPoints * components);\n                    points.set(section.DataArray.text, 0);\n                  }\n\n                  break;\n                // if it is strips\n\n                case 'Strips':\n                  var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n\n                  if (numberOfStrips > 0) {\n                    var connectivity = new Int32Array(section.DataArray[0].text.length);\n                    var offset = new Int32Array(section.DataArray[1].text.length);\n                    connectivity.set(section.DataArray[0].text, 0);\n                    offset.set(section.DataArray[1].text, 0);\n                    var size = numberOfStrips + connectivity.length;\n                    indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                    var indicesIndex = 0;\n\n                    for (var i = 0, len = numberOfStrips; i < len; i++) {\n                      var strip = [];\n\n                      for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                        strip.push(connectivity[s]);\n                        if (i > 0) len0 = offset[i - 1];\n                      }\n\n                      for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                        if (j % 2) {\n                          indices[indicesIndex++] = strip[j];\n                          indices[indicesIndex++] = strip[j + 2];\n                          indices[indicesIndex++] = strip[j + 1];\n                        } else {\n                          indices[indicesIndex++] = strip[j];\n                          indices[indicesIndex++] = strip[j + 1];\n                          indices[indicesIndex++] = strip[j + 2];\n                        }\n\n                        if (i > 0) len0 = offset[i - 1];\n                      }\n                    }\n                  }\n\n                  break;\n                // if it is polys\n\n                case 'Polys':\n                  var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n\n                  if (numberOfPolys > 0) {\n                    var connectivity = new Int32Array(section.DataArray[0].text.length);\n                    var offset = new Int32Array(section.DataArray[1].text.length);\n                    connectivity.set(section.DataArray[0].text, 0);\n                    offset.set(section.DataArray[1].text, 0);\n                    var size = numberOfPolys + connectivity.length;\n                    indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                    var indicesIndex = 0,\n                        connectivityIndex = 0;\n                    var i = 0,\n                        len = numberOfPolys,\n                        len0 = 0;\n\n                    while (i < len) {\n                      var poly = [];\n                      var s = 0,\n                          len1 = offset[i];\n\n                      while (s < len1 - len0) {\n                        poly.push(connectivity[connectivityIndex++]);\n                        s++;\n                      }\n\n                      var j = 1;\n\n                      while (j < len1 - len0 - 1) {\n                        indices[indicesIndex++] = poly[0];\n                        indices[indicesIndex++] = poly[j];\n                        indices[indicesIndex++] = poly[j + 1];\n                        j++;\n                      }\n\n                      i++;\n                      len0 = offset[i - 1];\n                    }\n                  }\n\n                  break;\n              }\n            }\n\n            sectionIndex++;\n          }\n\n          var geometry = new _three.BufferGeometry();\n          geometry.setIndex(new _three.BufferAttribute(indices, 1));\n          geometry.setAttribute('position', new _three.BufferAttribute(points, 3));\n\n          if (normals.length === points.length) {\n            geometry.setAttribute('normal', new _three.BufferAttribute(normals, 3));\n          }\n\n          return geometry;\n        } else {\n          throw new Error('Unsupported DATASET type');\n        }\n      } // get the 5 first lines of the files to check if there is the key word binary\n\n\n      var meta = _three.LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n\n      if (meta[0].indexOf('xml') !== -1) {\n        return parseXML(_three.LoaderUtils.decodeText(data));\n      } else if (meta[2].includes('ASCII')) {\n        return parseASCII(_three.LoaderUtils.decodeText(data));\n      } else {\n        return parseBinary(data);\n      }\n    }\n  }]);\n\n  return VTKLoader;\n}(_three.Loader);\n\nexports.VTKLoader = VTKLoader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$fflate$esm$browser"]],"~:properties",["^5",["parsedString","VTKLoader","next","prototype","key","__esModule","async","configurable","value","enumerable","start","text","writable","__proto__","end","constructor"]],"~:compiled-at",1630917515881,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$VTKLoader.js\",\n\"lineCount\":35,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/VTKLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$VTKLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.VTKLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _fflate = require(\\\"fflate\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar VTKLoader =\\n/*#__PURE__*/\\nfunction (_Loader) {\\n  _inherits(VTKLoader, _Loader);\\n\\n  function VTKLoader(manager) {\\n    _classCallCheck(this, VTKLoader);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(VTKLoader).call(this, manager));\\n  }\\n\\n  _createClass(VTKLoader, [{\\n    key: \\\"load\\\",\\n    value: function load(url, onLoad, onProgress, onError) {\\n      var scope = this;\\n      var loader = new _three.FileLoader(scope.manager);\\n      loader.setPath(scope.path);\\n      loader.setResponseType('arraybuffer');\\n      loader.setRequestHeader(scope.requestHeader);\\n      loader.setWithCredentials(scope.withCredentials);\\n      loader.load(url, function (text) {\\n        try {\\n          onLoad(scope.parse(text));\\n        } catch (e) {\\n          if (onError) {\\n            onError(e);\\n          } else {\\n            console.error(e);\\n          }\\n\\n          scope.manager.itemError(url);\\n        }\\n      }, onProgress, onError);\\n    }\\n  }, {\\n    key: \\\"parse\\\",\\n    value: function parse(data) {\\n      function parseASCII(data) {\\n        // connectivity of the triangles\\n        var indices = []; // triangles vertices\\n\\n        var positions = []; // red, green, blue colors in the range 0 to 1\\n\\n        var colors = []; // normal vector, one per vertex\\n\\n        var normals = [];\\n        var result; // pattern for detecting the end of a number sequence\\n\\n        var patWord = /^[^\\\\d.\\\\s-]+/; // pattern for reading vertices, 3 floats or integers\\n\\n        var pat3Floats = /(\\\\-?\\\\d+\\\\.?[\\\\d\\\\-\\\\+e]*)\\\\s+(\\\\-?\\\\d+\\\\.?[\\\\d\\\\-\\\\+e]*)\\\\s+(\\\\-?\\\\d+\\\\.?[\\\\d\\\\-\\\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\\n        // the first integer is the number of polygon nodes\\n\\n        var patConnectivity = /^(\\\\d+)\\\\s+([\\\\s\\\\d]*)/; // indicates start of vertex data section\\n\\n        var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\\n\\n        var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\\n\\n        var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\\n\\n        var patPOINT_DATA = /^POINT_DATA[ ]+(\\\\d+)/; // CELL_DATA number_of_polys\\n\\n        var patCELL_DATA = /^CELL_DATA[ ]+(\\\\d+)/; // Start of color section\\n\\n        var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\\\w+)[ ]+3/; // NORMALS Normals float\\n\\n        var patNORMALS = /^NORMALS[ ]+(\\\\w+)[ ]+(\\\\w+)/;\\n        var inPointsSection = false;\\n        var inPolygonsSection = false;\\n        var inTriangleStripSection = false;\\n        var inPointDataSection = false;\\n        var inCellDataSection = false;\\n        var inColorSection = false;\\n        var inNormalsSection = false;\\n        var lines = data.split('\\\\n');\\n\\n        for (var i in lines) {\\n          var line = lines[i].trim();\\n\\n          if (line.indexOf('DATASET') === 0) {\\n            var dataset = line.split(' ')[1];\\n            if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\\n          } else if (inPointsSection) {\\n            // get the vertices\\n            while ((result = pat3Floats.exec(line)) !== null) {\\n              if (patWord.exec(line) !== null) break;\\n              var x = parseFloat(result[1]);\\n              var y = parseFloat(result[2]);\\n              var z = parseFloat(result[3]);\\n              positions.push(x, y, z);\\n            }\\n          } else if (inPolygonsSection) {\\n            if ((result = patConnectivity.exec(line)) !== null) {\\n              // numVertices i0 i1 i2 ...\\n              var numVertices = parseInt(result[1]);\\n              var inds = result[2].split(/\\\\s+/);\\n\\n              if (numVertices >= 3) {\\n                var i0 = parseInt(inds[0]);\\n                var i1, i2;\\n                var k = 1; // split the polygon in numVertices - 2 triangles\\n\\n                for (var j = 0; j < numVertices - 2; ++j) {\\n                  i1 = parseInt(inds[k]);\\n                  i2 = parseInt(inds[k + 1]);\\n                  indices.push(i0, i1, i2);\\n                  k++;\\n                }\\n              }\\n            }\\n          } else if (inTriangleStripSection) {\\n            if ((result = patConnectivity.exec(line)) !== null) {\\n              // numVertices i0 i1 i2 ...\\n              var numVertices = parseInt(result[1]);\\n              var inds = result[2].split(/\\\\s+/);\\n\\n              if (numVertices >= 3) {\\n                var i0, i1, i2; // split the polygon in numVertices - 2 triangles\\n\\n                for (var j = 0; j < numVertices - 2; j++) {\\n                  if (j % 2 === 1) {\\n                    i0 = parseInt(inds[j]);\\n                    i1 = parseInt(inds[j + 2]);\\n                    i2 = parseInt(inds[j + 1]);\\n                    indices.push(i0, i1, i2);\\n                  } else {\\n                    i0 = parseInt(inds[j]);\\n                    i1 = parseInt(inds[j + 1]);\\n                    i2 = parseInt(inds[j + 2]);\\n                    indices.push(i0, i1, i2);\\n                  }\\n                }\\n              }\\n            }\\n          } else if (inPointDataSection || inCellDataSection) {\\n            if (inColorSection) {\\n              // Get the colors\\n              while ((result = pat3Floats.exec(line)) !== null) {\\n                if (patWord.exec(line) !== null) break;\\n                var r = parseFloat(result[1]);\\n                var g = parseFloat(result[2]);\\n                var b = parseFloat(result[3]);\\n                colors.push(r, g, b);\\n              }\\n            } else if (inNormalsSection) {\\n              // Get the normal vectors\\n              while ((result = pat3Floats.exec(line)) !== null) {\\n                if (patWord.exec(line) !== null) break;\\n                var nx = parseFloat(result[1]);\\n                var ny = parseFloat(result[2]);\\n                var nz = parseFloat(result[3]);\\n                normals.push(nx, ny, nz);\\n              }\\n            }\\n          }\\n\\n          if (patPOLYGONS.exec(line) !== null) {\\n            inPolygonsSection = true;\\n            inPointsSection = false;\\n            inTriangleStripSection = false;\\n          } else if (patPOINTS.exec(line) !== null) {\\n            inPolygonsSection = false;\\n            inPointsSection = true;\\n            inTriangleStripSection = false;\\n          } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\\n            inPolygonsSection = false;\\n            inPointsSection = false;\\n            inTriangleStripSection = true;\\n          } else if (patPOINT_DATA.exec(line) !== null) {\\n            inPointDataSection = true;\\n            inPointsSection = false;\\n            inPolygonsSection = false;\\n            inTriangleStripSection = false;\\n          } else if (patCELL_DATA.exec(line) !== null) {\\n            inCellDataSection = true;\\n            inPointsSection = false;\\n            inPolygonsSection = false;\\n            inTriangleStripSection = false;\\n          } else if (patCOLOR_SCALARS.exec(line) !== null) {\\n            inColorSection = true;\\n            inNormalsSection = false;\\n            inPointsSection = false;\\n            inPolygonsSection = false;\\n            inTriangleStripSection = false;\\n          } else if (patNORMALS.exec(line) !== null) {\\n            inNormalsSection = true;\\n            inColorSection = false;\\n            inPointsSection = false;\\n            inPolygonsSection = false;\\n            inTriangleStripSection = false;\\n          }\\n        }\\n\\n        var geometry = new _three.BufferGeometry();\\n        geometry.setIndex(indices);\\n        geometry.setAttribute('position', new _three.Float32BufferAttribute(positions, 3));\\n\\n        if (normals.length === positions.length) {\\n          geometry.setAttribute('normal', new _three.Float32BufferAttribute(normals, 3));\\n        }\\n\\n        if (colors.length !== indices.length) {\\n          // stagger\\n          if (colors.length === positions.length) {\\n            geometry.setAttribute('color', new _three.Float32BufferAttribute(colors, 3));\\n          }\\n        } else {\\n          // cell\\n          geometry = geometry.toNonIndexed();\\n          var numTriangles = geometry.attributes.position.count / 3;\\n\\n          if (colors.length === numTriangles * 3) {\\n            var newColors = [];\\n\\n            for (var i = 0; i < numTriangles; i++) {\\n              var r = colors[3 * i + 0];\\n              var g = colors[3 * i + 1];\\n              var b = colors[3 * i + 2];\\n              newColors.push(r, g, b);\\n              newColors.push(r, g, b);\\n              newColors.push(r, g, b);\\n            }\\n\\n            geometry.setAttribute('color', new _three.Float32BufferAttribute(newColors, 3));\\n          }\\n        }\\n\\n        return geometry;\\n      }\\n\\n      function parseBinary(data) {\\n        var count, pointIndex, i, numberOfPoints, s;\\n        var buffer = new Uint8Array(data);\\n        var dataView = new DataView(data); // Points and normals, by default, are empty\\n\\n        var points = [];\\n        var normals = [];\\n        var indices = []; // Going to make a big array of strings\\n\\n        var index = 0;\\n\\n        function findString(buffer, start) {\\n          var index = start;\\n          var c = buffer[index];\\n          var s = [];\\n\\n          while (c !== 10) {\\n            s.push(String.fromCharCode(c));\\n            index++;\\n            c = buffer[index];\\n          }\\n\\n          return {\\n            start: start,\\n            end: index,\\n            next: index + 1,\\n            parsedString: s.join('')\\n          };\\n        }\\n\\n        var state, line;\\n\\n        while (true) {\\n          // Get a string\\n          state = findString(buffer, index);\\n          line = state.parsedString;\\n\\n          if (line.indexOf('DATASET') === 0) {\\n            var dataset = line.split(' ')[1];\\n            if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\\n          } else if (line.indexOf('POINTS') === 0) {\\n            numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\\n\\n            count = numberOfPoints * 4 * 3;\\n            points = new Float32Array(numberOfPoints * 3);\\n            pointIndex = state.next;\\n\\n            for (i = 0; i < numberOfPoints; i++) {\\n              points[3 * i] = dataView.getFloat32(pointIndex, false);\\n              points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\\n              points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\\n              pointIndex = pointIndex + 12;\\n            } // increment our next pointer\\n\\n\\n            state.next = state.next + count + 1;\\n          } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\\n            var numberOfStrips = parseInt(line.split(' ')[1], 10);\\n            var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\\n\\n            count = size * 4;\\n            indices = new Uint32Array(3 * size - 9 * numberOfStrips);\\n            var indicesIndex = 0;\\n            pointIndex = state.next;\\n\\n            for (i = 0; i < numberOfStrips; i++) {\\n              // For each strip, read the first value, then record that many more points\\n              var indexCount = dataView.getInt32(pointIndex, false);\\n              var strip = [];\\n              pointIndex += 4;\\n\\n              for (s = 0; s < indexCount; s++) {\\n                strip.push(dataView.getInt32(pointIndex, false));\\n                pointIndex += 4;\\n              } // retrieves the n-2 triangles from the triangle strip\\n\\n\\n              for (var j = 0; j < indexCount - 2; j++) {\\n                if (j % 2) {\\n                  indices[indicesIndex++] = strip[j];\\n                  indices[indicesIndex++] = strip[j + 2];\\n                  indices[indicesIndex++] = strip[j + 1];\\n                } else {\\n                  indices[indicesIndex++] = strip[j];\\n                  indices[indicesIndex++] = strip[j + 1];\\n                  indices[indicesIndex++] = strip[j + 2];\\n                }\\n              }\\n            } // increment our next pointer\\n\\n\\n            state.next = state.next + count + 1;\\n          } else if (line.indexOf('POLYGONS') === 0) {\\n            var numberOfStrips = parseInt(line.split(' ')[1], 10);\\n            var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\\n\\n            count = size * 4;\\n            indices = new Uint32Array(3 * size - 9 * numberOfStrips);\\n            var indicesIndex = 0;\\n            pointIndex = state.next;\\n\\n            for (i = 0; i < numberOfStrips; i++) {\\n              // For each strip, read the first value, then record that many more points\\n              var indexCount = dataView.getInt32(pointIndex, false);\\n              var strip = [];\\n              pointIndex += 4;\\n\\n              for (s = 0; s < indexCount; s++) {\\n                strip.push(dataView.getInt32(pointIndex, false));\\n                pointIndex += 4;\\n              } // divide the polygon in n-2 triangle\\n\\n\\n              for (var j = 1; j < indexCount - 1; j++) {\\n                indices[indicesIndex++] = strip[0];\\n                indices[indicesIndex++] = strip[j];\\n                indices[indicesIndex++] = strip[j + 1];\\n              }\\n            } // increment our next pointer\\n\\n\\n            state.next = state.next + count + 1;\\n          } else if (line.indexOf('POINT_DATA') === 0) {\\n            numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\\n\\n            state = findString(buffer, state.next); // Now grab the binary data\\n\\n            count = numberOfPoints * 4 * 3;\\n            normals = new Float32Array(numberOfPoints * 3);\\n            pointIndex = state.next;\\n\\n            for (i = 0; i < numberOfPoints; i++) {\\n              normals[3 * i] = dataView.getFloat32(pointIndex, false);\\n              normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\\n              normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\\n              pointIndex += 12;\\n            } // Increment past our data\\n\\n\\n            state.next = state.next + count;\\n          } // Increment index\\n\\n\\n          index = state.next;\\n\\n          if (index >= buffer.byteLength) {\\n            break;\\n          }\\n        }\\n\\n        var geometry = new _three.BufferGeometry();\\n        geometry.setIndex(new _three.BufferAttribute(indices, 1));\\n        geometry.setAttribute('position', new _three.BufferAttribute(points, 3));\\n\\n        if (normals.length === points.length) {\\n          geometry.setAttribute('normal', new _three.BufferAttribute(normals, 3));\\n        }\\n\\n        return geometry;\\n      }\\n\\n      function Float32Concat(first, second) {\\n        var firstLength = first.length,\\n            result = new Float32Array(firstLength + second.length);\\n        result.set(first);\\n        result.set(second, firstLength);\\n        return result;\\n      }\\n\\n      function Int32Concat(first, second) {\\n        var firstLength = first.length,\\n            result = new Int32Array(firstLength + second.length);\\n        result.set(first);\\n        result.set(second, firstLength);\\n        return result;\\n      }\\n\\n      function parseXML(stringFile) {\\n        // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\\n        function xmlToJson(xml) {\\n          // Create the return object\\n          var obj = {};\\n\\n          if (xml.nodeType === 1) {\\n            // element\\n            // do attributes\\n            if (xml.attributes) {\\n              if (xml.attributes.length > 0) {\\n                obj['attributes'] = {};\\n\\n                for (var j = 0; j < xml.attributes.length; j++) {\\n                  var attribute = xml.attributes.item(j);\\n                  obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\\n                }\\n              }\\n            }\\n          } else if (xml.nodeType === 3) {\\n            // text\\n            obj = xml.nodeValue.trim();\\n          } // do children\\n\\n\\n          if (xml.hasChildNodes()) {\\n            for (var i = 0; i < xml.childNodes.length; i++) {\\n              var item = xml.childNodes.item(i);\\n              var nodeName = item.nodeName;\\n\\n              if (typeof obj[nodeName] === 'undefined') {\\n                var tmp = xmlToJson(item);\\n                if (tmp !== '') obj[nodeName] = tmp;\\n              } else {\\n                if (typeof obj[nodeName].push === 'undefined') {\\n                  var old = obj[nodeName];\\n                  obj[nodeName] = [old];\\n                }\\n\\n                var tmp = xmlToJson(item);\\n                if (tmp !== '') obj[nodeName].push(tmp);\\n              }\\n            }\\n          }\\n\\n          return obj;\\n        } // Taken from Base64-js\\n\\n\\n        function Base64toByteArray(b64) {\\n          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\\n          var i;\\n          var lookup = [];\\n          var revLookup = [];\\n          var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n          var len = code.length;\\n\\n          for (i = 0; i < len; i++) {\\n            lookup[i] = code[i];\\n          }\\n\\n          for (i = 0; i < len; ++i) {\\n            revLookup[code.charCodeAt(i)] = i;\\n          }\\n\\n          revLookup['-'.charCodeAt(0)] = 62;\\n          revLookup['_'.charCodeAt(0)] = 63;\\n          var j, l, tmp, placeHolders, arr;\\n          var len = b64.length;\\n\\n          if (len % 4 > 0) {\\n            throw new Error('Invalid string. Length must be a multiple of 4');\\n          }\\n\\n          placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\\n          arr = new Arr(len * 3 / 4 - placeHolders);\\n          l = placeHolders > 0 ? len - 4 : len;\\n          var L = 0;\\n\\n          for (i = 0, j = 0; i < l; i += 4, j += 3) {\\n            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\\n            arr[L++] = (tmp & 0xff0000) >> 16;\\n            arr[L++] = (tmp & 0xff00) >> 8;\\n            arr[L++] = tmp & 0xff;\\n          }\\n\\n          if (placeHolders === 2) {\\n            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\\n            arr[L++] = tmp & 0xff;\\n          } else if (placeHolders === 1) {\\n            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\\n            arr[L++] = tmp >> 8 & 0xff;\\n            arr[L++] = tmp & 0xff;\\n          }\\n\\n          return arr;\\n        }\\n\\n        function parseDataArray(ele, compressed) {\\n          var numBytes = 0;\\n\\n          if (json.attributes.header_type === 'UInt64') {\\n            numBytes = 8;\\n          } else if (json.attributes.header_type === 'UInt32') {\\n            numBytes = 4;\\n          } // Check the format\\n\\n\\n          if (ele.attributes.format === 'binary' && compressed) {\\n            var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\\n\\n            if (ele.attributes.type === 'Float32') {\\n              var txt = new Float32Array();\\n            } else if (ele.attributes.type === 'Int64') {\\n              var txt = new Int32Array();\\n            } // VTP data with the header has the following structure:\\n            // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\\n            //\\n            // Each token is an integer value whose type is specified by \\\"header_type\\\" at the top of the file (UInt32 if no type specified). The token meanings are:\\n            // [#blocks] = Number of blocks\\n            // [#u-size] = Block size before compression\\n            // [#p-size] = Size of last partial block (zero if it not needed)\\n            // [#c-size-i] = Size in bytes of block i after compression\\n            //\\n            // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\\n            // computed by summing the compressed block sizes from preceding blocks according to the header.\\n\\n\\n            rawData = ele['#text'];\\n            byteData = Base64toByteArray(rawData);\\n            blocks = byteData[0];\\n\\n            for (var i = 1; i < numBytes - 1; i++) {\\n              blocks = blocks | byteData[i] << i * numBytes;\\n            }\\n\\n            headerSize = (blocks + 3) * numBytes;\\n            padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\\n            headerSize = headerSize + padding;\\n            dataOffsets = [];\\n            currentOffset = headerSize;\\n            dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\\n            // There are three blocks before c-size-i, so we skip 3*numBytes\\n\\n            cSizeStart = 3 * numBytes;\\n\\n            for (var i = 0; i < blocks; i++) {\\n              var currentBlockSize = byteData[i * numBytes + cSizeStart];\\n\\n              for (var j = 1; j < numBytes - 1; j++) {\\n                // Each data point consists of 8 bytes regardless of the header type\\n                currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\\n              }\\n\\n              currentOffset = currentOffset + currentBlockSize;\\n              dataOffsets.push(currentOffset);\\n            }\\n\\n            for (var i = 0; i < dataOffsets.length - 1; i++) {\\n              var data = (0, _fflate.unzlibSync)(byteData.slice(dataOffsets[i], dataOffsets[i + 1])); // eslint-disable-line no-undef\\n\\n              content = data.buffer;\\n\\n              if (ele.attributes.type === 'Float32') {\\n                content = new Float32Array(content);\\n                txt = Float32Concat(txt, content);\\n              } else if (ele.attributes.type === 'Int64') {\\n                content = new Int32Array(content);\\n                txt = Int32Concat(txt, content);\\n              }\\n            }\\n\\n            delete ele['#text'];\\n\\n            if (ele.attributes.type === 'Int64') {\\n              if (ele.attributes.format === 'binary') {\\n                txt = txt.filter(function (el, idx) {\\n                  if (idx % 2 !== 1) return true;\\n                });\\n              }\\n            }\\n          } else {\\n            if (ele.attributes.format === 'binary' && !compressed) {\\n              var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\\n              // [#bytes][DATA]\\n              // where \\\"[#bytes]\\\" is an integer value specifying the number of bytes in the block of data following it.\\n\\n              content = content.slice(numBytes).buffer;\\n            } else {\\n              if (ele['#text']) {\\n                var content = ele['#text'].split(/\\\\s+/).filter(function (el) {\\n                  if (el !== '') return el;\\n                });\\n              } else {\\n                var content = new Int32Array(0).buffer;\\n              }\\n            }\\n\\n            delete ele['#text']; // Get the content and optimize it\\n\\n            if (ele.attributes.type === 'Float32') {\\n              var txt = new Float32Array(content);\\n            } else if (ele.attributes.type === 'Int32') {\\n              var txt = new Int32Array(content);\\n            } else if (ele.attributes.type === 'Int64') {\\n              var txt = new Int32Array(content);\\n\\n              if (ele.attributes.format === 'binary') {\\n                txt = txt.filter(function (el, idx) {\\n                  if (idx % 2 !== 1) return true;\\n                });\\n              }\\n            }\\n          } // endif ( ele.attributes.format === 'binary' && compressed )\\n\\n\\n          return txt;\\n        } // Main part\\n        // Get Dom\\n\\n\\n        var dom = null;\\n\\n        if (window.DOMParser) {\\n          try {\\n            dom = new DOMParser().parseFromString(stringFile, 'text/xml');\\n          } catch (e) {\\n            dom = null;\\n          }\\n        } else if (window.ActiveXObject) {\\n          try {\\n            dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\\n\\n            dom.async = false;\\n\\n            if (!dom.loadXML()) {\\n              throw new Error(dom.parseError.reason + dom.parseError.srcText);\\n            }\\n          } catch (e) {\\n            dom = null;\\n          }\\n        } else {\\n          throw new Error('Cannot parse xml string!');\\n        } // Get the doc\\n\\n\\n        var doc = dom.documentElement; // Convert to json\\n\\n        var json = xmlToJson(doc);\\n        var points = [];\\n        var normals = [];\\n        var indices = [];\\n\\n        if (json.PolyData) {\\n          var piece = json.PolyData.Piece;\\n          var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\\n          // Loop through the sections\\n\\n          var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\\n\\n          var sectionIndex = 0,\\n              numberOfSections = sections.length;\\n\\n          while (sectionIndex < numberOfSections) {\\n            var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\\n\\n            if (section && section.DataArray) {\\n              // Depending on the number of DataArrays\\n              if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\\n                var arr = section.DataArray;\\n              } else {\\n                var arr = [section.DataArray];\\n              }\\n\\n              var dataArrayIndex = 0,\\n                  numberOfDataArrays = arr.length;\\n\\n              while (dataArrayIndex < numberOfDataArrays) {\\n                // Parse the DataArray\\n                if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\\n                  arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\\n                }\\n\\n                dataArrayIndex++;\\n              }\\n\\n              switch (sections[sectionIndex]) {\\n                // if iti is point data\\n                case 'PointData':\\n                  var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\\n                  var normalsName = section.attributes.Normals;\\n\\n                  if (numberOfPoints > 0) {\\n                    for (var i = 0, len = arr.length; i < len; i++) {\\n                      if (normalsName === arr[i].attributes.Name) {\\n                        var components = arr[i].attributes.NumberOfComponents;\\n                        normals = new Float32Array(numberOfPoints * components);\\n                        normals.set(arr[i].text, 0);\\n                      }\\n                    }\\n                  }\\n\\n                  break;\\n                // if it is points\\n\\n                case 'Points':\\n                  var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\\n\\n                  if (numberOfPoints > 0) {\\n                    var components = section.DataArray.attributes.NumberOfComponents;\\n                    points = new Float32Array(numberOfPoints * components);\\n                    points.set(section.DataArray.text, 0);\\n                  }\\n\\n                  break;\\n                // if it is strips\\n\\n                case 'Strips':\\n                  var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\\n\\n                  if (numberOfStrips > 0) {\\n                    var connectivity = new Int32Array(section.DataArray[0].text.length);\\n                    var offset = new Int32Array(section.DataArray[1].text.length);\\n                    connectivity.set(section.DataArray[0].text, 0);\\n                    offset.set(section.DataArray[1].text, 0);\\n                    var size = numberOfStrips + connectivity.length;\\n                    indices = new Uint32Array(3 * size - 9 * numberOfStrips);\\n                    var indicesIndex = 0;\\n\\n                    for (var i = 0, len = numberOfStrips; i < len; i++) {\\n                      var strip = [];\\n\\n                      for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\\n                        strip.push(connectivity[s]);\\n                        if (i > 0) len0 = offset[i - 1];\\n                      }\\n\\n                      for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\\n                        if (j % 2) {\\n                          indices[indicesIndex++] = strip[j];\\n                          indices[indicesIndex++] = strip[j + 2];\\n                          indices[indicesIndex++] = strip[j + 1];\\n                        } else {\\n                          indices[indicesIndex++] = strip[j];\\n                          indices[indicesIndex++] = strip[j + 1];\\n                          indices[indicesIndex++] = strip[j + 2];\\n                        }\\n\\n                        if (i > 0) len0 = offset[i - 1];\\n                      }\\n                    }\\n                  }\\n\\n                  break;\\n                // if it is polys\\n\\n                case 'Polys':\\n                  var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\\n\\n                  if (numberOfPolys > 0) {\\n                    var connectivity = new Int32Array(section.DataArray[0].text.length);\\n                    var offset = new Int32Array(section.DataArray[1].text.length);\\n                    connectivity.set(section.DataArray[0].text, 0);\\n                    offset.set(section.DataArray[1].text, 0);\\n                    var size = numberOfPolys + connectivity.length;\\n                    indices = new Uint32Array(3 * size - 9 * numberOfPolys);\\n                    var indicesIndex = 0,\\n                        connectivityIndex = 0;\\n                    var i = 0,\\n                        len = numberOfPolys,\\n                        len0 = 0;\\n\\n                    while (i < len) {\\n                      var poly = [];\\n                      var s = 0,\\n                          len1 = offset[i];\\n\\n                      while (s < len1 - len0) {\\n                        poly.push(connectivity[connectivityIndex++]);\\n                        s++;\\n                      }\\n\\n                      var j = 1;\\n\\n                      while (j < len1 - len0 - 1) {\\n                        indices[indicesIndex++] = poly[0];\\n                        indices[indicesIndex++] = poly[j];\\n                        indices[indicesIndex++] = poly[j + 1];\\n                        j++;\\n                      }\\n\\n                      i++;\\n                      len0 = offset[i - 1];\\n                    }\\n                  }\\n\\n                  break;\\n              }\\n            }\\n\\n            sectionIndex++;\\n          }\\n\\n          var geometry = new _three.BufferGeometry();\\n          geometry.setIndex(new _three.BufferAttribute(indices, 1));\\n          geometry.setAttribute('position', new _three.BufferAttribute(points, 3));\\n\\n          if (normals.length === points.length) {\\n            geometry.setAttribute('normal', new _three.BufferAttribute(normals, 3));\\n          }\\n\\n          return geometry;\\n        } else {\\n          throw new Error('Unsupported DATASET type');\\n        }\\n      } // get the 5 first lines of the files to check if there is the key word binary\\n\\n\\n      var meta = _three.LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\\\n');\\n\\n      if (meta[0].indexOf('xml') !== -1) {\\n        return parseXML(_three.LoaderUtils.decodeText(data));\\n      } else if (meta[2].includes('ASCII')) {\\n        return parseASCII(_three.LoaderUtils.decodeText(data));\\n      } else {\\n        return parseBinary(data);\\n      }\\n    }\\n  }]);\\n\\n  return VTKLoader;\\n}(_three.Loader);\\n\\nexports.VTKLoader = VTKLoader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"VTKLoader\",\"_three\",\"_fflate\",\"_Loader\",\"manager\",\"instance\",\"call\",\"self\",\"ReferenceError\",\"load\",\"url\",\"onLoad\",\"onProgress\",\"onError\",\"scope\",\"loader\",\"FileLoader\",\"setPath\",\"path\",\"setResponseType\",\"setRequestHeader\",\"requestHeader\",\"setWithCredentials\",\"withCredentials\",\"text\",\"parse\",\"e\",\"console\",\"error\",\"itemError\",\"data\",\"parseASCII\",\"indices\",\"positions\",\"colors\",\"normals\",\"patWord\",\"pat3Floats\",\"patConnectivity\",\"patPOINTS\",\"patPOLYGONS\",\"patTRIANGLE_STRIPS\",\"patPOINT_DATA\",\"patCELL_DATA\",\"patCOLOR_SCALARS\",\"patNORMALS\",\"inPointsSection\",\"inPolygonsSection\",\"inTriangleStripSection\",\"inPointDataSection\",\"inCellDataSection\",\"inColorSection\",\"inNormalsSection\",\"lines\",\"split\",\"line\",\"trim\",\"indexOf\",\"dataset\",\"Error\",\"result\",\"exec\",\"x\",\"parseFloat\",\"y\",\"z\",\"push\",\"numVertices\",\"parseInt\",\"inds\",\"i0\",\"i1\",\"i2\",\"k\",\"j\",\"r\",\"g\",\"b\",\"nx\",\"ny\",\"nz\",\"geometry\",\"BufferGeometry\",\"setIndex\",\"setAttribute\",\"Float32BufferAttribute\",\"toNonIndexed\",\"numTriangles\",\"attributes\",\"position\",\"count\",\"newColors\",\"parseBinary\",\"findString\",\"buffer\",\"start\",\"index\",\"c\",\"s\",\"String\",\"fromCharCode\",\"end\",\"next\",\"parsedString\",\"join\",\"Uint8Array\",\"dataView\",\"DataView\",\"points\",\"state\",\"numberOfPoints\",\"Float32Array\",\"pointIndex\",\"getFloat32\",\"numberOfStrips\",\"size\",\"Uint32Array\",\"indicesIndex\",\"indexCount\",\"getInt32\",\"strip\",\"byteLength\",\"BufferAttribute\",\"Float32Concat\",\"first\",\"second\",\"firstLength\",\"set\",\"Int32Concat\",\"Int32Array\",\"parseXML\",\"stringFile\",\"xmlToJson\",\"xml\",\"nodeType\",\"attribute\",\"item\",\"nodeName\",\"nodeValue\",\"hasChildNodes\",\"childNodes\",\"tmp\",\"old\",\"Base64toByteArray\",\"b64\",\"Arr\",\"Array\",\"revLookup\",\"len\",\"code\",\"charCodeAt\",\"placeHolders\",\"arr\",\"l\",\"L\",\"parseDataArray\",\"ele\",\"compressed\",\"numBytes\",\"json\",\"header_type\",\"format\",\"headerSize\",\"type\",\"txt\",\"byteData\",\"rawData\",\"blocks\",\"dataOffsets\",\"currentOffset\",\"padding\",\"cSizeStart\",\"currentBlockSize\",\"content\",\"unzlibSync\",\"slice\",\"filter\",\"el\",\"idx\",\"dom\",\"window\",\"DOMParser\",\"parseFromString\",\"ActiveXObject\",\"async\",\"loadXML\",\"parseError\",\"reason\",\"srcText\",\"documentElement\",\"PolyData\",\"piece\",\"Piece\",\"hasOwnProperty\",\"sections\",\"sectionIndex\",\"numberOfSections\",\"section\",\"DataArray\",\"toString\",\"dataArrayIndex\",\"numberOfDataArrays\",\"NumberOfPoints\",\"normalsName\",\"Normals\",\"Name\",\"components\",\"NumberOfComponents\",\"NumberOfStrips\",\"connectivity\",\"offset\",\"len1\",\"len0\",\"numberOfPolys\",\"NumberOfPolys\",\"connectivityIndex\",\"poly\",\"meta\",\"LoaderUtils\",\"decodeText\",\"includes\",\"Loader\"]\n}\n"]