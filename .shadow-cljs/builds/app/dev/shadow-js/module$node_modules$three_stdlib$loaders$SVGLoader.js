["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/SVGLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$SVGLoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=\ndescriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};\nreturn _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};\nreturn _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.SVGLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_Loader){function SVGLoader(manager){if(!(this instanceof SVGLoader))throw new TypeError(\"Cannot call a class as a function\");manager=_getPrototypeOf(SVGLoader).call(this,manager);if(!manager||\"object\"!==_typeof(manager)&&\"function\"!==typeof manager){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\nmanager=this}manager.defaultDPI=90;manager.defaultUnit=\"px\";return manager}_inherits(SVGLoader,_Loader);_createClass(SVGLoader,[{key:\"load\",value:function(url,onLoad,onProgress,onError){var scope=this,loader=new _three.FileLoader(scope.manager);loader.setPath(scope.path);loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(text){try{onLoad(scope.parse(text))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}},\nonProgress,onError)}},{key:\"parse\",value:function(text){function parseNode(node,style){if(1===node.nodeType){if(node.hasAttribute(\"transform\")||\"use\"===node.nodeName&&(node.hasAttribute(\"x\")||node.hasAttribute(\"y\"))){var transform=new _three.Matrix3,currentTransform$jscomp$0=tempTransform0;if(\"use\"===node.nodeName&&(node.hasAttribute(\"x\")||node.hasAttribute(\"y\"))){var tx=parseFloatWithUnits(node.getAttribute(\"x\")),ty=parseFloatWithUnits(node.getAttribute(\"y\"));transform.translate(tx,ty)}if(node.hasAttribute(\"transform\"))for(var transformsTexts=\nnode.getAttribute(\"transform\").split(\")\"),tIndex=transformsTexts.length-1;0<=tIndex;tIndex--){var transformText=transformsTexts[tIndex].trim();if(\"\"!==transformText){var openParPos=transformText.indexOf(\"(\"),closeParPos=transformText.length;if(0<openParPos&&openParPos<closeParPos){var transformType=transformText.substr(0,openParPos),array=parseFloats(transformText.substr(openParPos+1,closeParPos-openParPos-1));currentTransform$jscomp$0.identity();switch(transformType){case \"translate\":if(1<=array.length){var _tx=\narray[0],_ty=_tx;2<=array.length&&(_ty=array[1]);currentTransform$jscomp$0.translate(_tx,_ty)}break;case \"rotate\":if(1<=array.length){var cx=0,cy=0;var angle=-array[0]*Math.PI/180;3<=array.length&&(cx=array[1],cy=array[2]);tempTransform1.identity().translate(-cx,-cy);tempTransform2.identity().rotate(angle);tempTransform3.multiplyMatrices(tempTransform2,tempTransform1);tempTransform1.identity().translate(cx,cy);currentTransform$jscomp$0.multiplyMatrices(tempTransform1,tempTransform3)}break;case \"scale\":if(1<=\narray.length){var scaleX=array[0],scaleY=scaleX;2<=array.length&&(scaleY=array[1]);currentTransform$jscomp$0.scale(scaleX,scaleY)}break;case \"skewX\":1===array.length&&currentTransform$jscomp$0.set(1,Math.tan(array[0]*Math.PI/180),0,0,1,0,0,0,1);break;case \"skewY\":1===array.length&&currentTransform$jscomp$0.set(1,0,0,Math.tan(array[0]*Math.PI/180),1,0,0,0,1);break;case \"matrix\":6===array.length&&currentTransform$jscomp$0.set(array[0],array[2],array[4],array[1],array[3],array[5],0,0,1)}}transform.premultiply(currentTransform$jscomp$0)}}0<\ntransformStack.length&&transform.premultiply(transformStack[transformStack.length-1]);currentTransform.copy(transform);transformStack.push(transform);var transform$jscomp$0=transform}else transform$jscomp$0=null;var traverseChildNodes=!0,path=null;switch(node.nodeName){case \"style\":parseCSSStylesheet(node);break;case \"g\":style=parseStyle(node,style);break;case \"path\":style=parseStyle(node,style);if(node.hasAttribute(\"d\")){for(var path$jscomp$0=new _three.ShapePath,point=new _three.Vector2,control=\nnew _three.Vector2,firstPoint=new _three.Vector2,isFirstPoint=!0,doSetFirstPoint=!1,commands=node.getAttribute(\"d\").match(/[a-df-z][^a-df-z]*/gi),i=0,l=commands.length;i<l;i++){var command=commands[i],type=command.charAt(0),_data=command.substr(1).trim();!0===isFirstPoint&&(doSetFirstPoint=!0,isFirstPoint=!1);switch(type){case \"M\":var numbers=parseFloats(_data);for(var j=0,jl=numbers.length;j<jl;j+=2)point.x=numbers[j+0],point.y=numbers[j+1],control.x=point.x,control.y=point.y,0===j?path$jscomp$0.moveTo(point.x,\npoint.y):path$jscomp$0.lineTo(point.x,point.y),0===j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"H\":numbers=parseFloats(_data);for(var _j=0,_jl=numbers.length;_j<_jl;_j++)point.x=numbers[_j],control.x=point.x,control.y=point.y,path$jscomp$0.lineTo(point.x,point.y),0===_j&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"V\":numbers=parseFloats(_data);for(var _j2=0,_jl2=numbers.length;_j2<_jl2;_j2++)point.y=numbers[_j2],control.x=point.x,control.y=point.y,path$jscomp$0.lineTo(point.x,\npoint.y),0===_j2&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"L\":numbers=parseFloats(_data);for(var _j3=0,_jl3=numbers.length;_j3<_jl3;_j3+=2)point.x=numbers[_j3+0],point.y=numbers[_j3+1],control.x=point.x,control.y=point.y,path$jscomp$0.lineTo(point.x,point.y),0===_j3&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"C\":numbers=parseFloats(_data);for(var _j4=0,_jl4=numbers.length;_j4<_jl4;_j4+=6)path$jscomp$0.bezierCurveTo(numbers[_j4+0],numbers[_j4+1],numbers[_j4+2],numbers[_j4+\n3],numbers[_j4+4],numbers[_j4+5]),control.x=numbers[_j4+2],control.y=numbers[_j4+3],point.x=numbers[_j4+4],point.y=numbers[_j4+5],0===_j4&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"S\":numbers=parseFloats(_data);for(var _j5=0,_jl5=numbers.length;_j5<_jl5;_j5+=4)path$jscomp$0.bezierCurveTo(getReflection(point.x,control.x),getReflection(point.y,control.y),numbers[_j5+0],numbers[_j5+1],numbers[_j5+2],numbers[_j5+3]),control.x=numbers[_j5+0],control.y=numbers[_j5+1],point.x=numbers[_j5+\n2],point.y=numbers[_j5+3],0===_j5&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"Q\":numbers=parseFloats(_data);for(var _j6=0,_jl6=numbers.length;_j6<_jl6;_j6+=4)path$jscomp$0.quadraticCurveTo(numbers[_j6+0],numbers[_j6+1],numbers[_j6+2],numbers[_j6+3]),control.x=numbers[_j6+0],control.y=numbers[_j6+1],point.x=numbers[_j6+2],point.y=numbers[_j6+3],0===_j6&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"T\":numbers=parseFloats(_data);for(var _j7=0,_jl7=numbers.length;_j7<_jl7;_j7+=\n2){var rx=getReflection(point.x,control.x),ry=getReflection(point.y,control.y);path$jscomp$0.quadraticCurveTo(rx,ry,numbers[_j7+0],numbers[_j7+1]);control.x=rx;control.y=ry;point.x=numbers[_j7+0];point.y=numbers[_j7+1];0===_j7&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case \"A\":numbers=parseFloats(_data,[3,4],7);for(var _j8=0,_jl8=numbers.length;_j8<_jl8;_j8+=7)if(numbers[_j8+5]!=point.x||numbers[_j8+6]!=point.y){var start=point.clone();point.x=numbers[_j8+5];point.y=numbers[_j8+6];control.x=\npoint.x;control.y=point.y;parseArcCommand(path$jscomp$0,numbers[_j8],numbers[_j8+1],numbers[_j8+2],numbers[_j8+3],numbers[_j8+4],start,point);0===_j8&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case \"m\":numbers=parseFloats(_data);for(var _j9=0,_jl9=numbers.length;_j9<_jl9;_j9+=2)point.x+=numbers[_j9+0],point.y+=numbers[_j9+1],control.x=point.x,control.y=point.y,0===_j9?path$jscomp$0.moveTo(point.x,point.y):path$jscomp$0.lineTo(point.x,point.y),0===_j9&&!0===doSetFirstPoint&&firstPoint.copy(point);\nbreak;case \"h\":numbers=parseFloats(_data);for(var _j10=0,_jl10=numbers.length;_j10<_jl10;_j10++)point.x+=numbers[_j10],control.x=point.x,control.y=point.y,path$jscomp$0.lineTo(point.x,point.y),0===_j10&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"v\":numbers=parseFloats(_data);for(var _j11=0,_jl11=numbers.length;_j11<_jl11;_j11++)point.y+=numbers[_j11],control.x=point.x,control.y=point.y,path$jscomp$0.lineTo(point.x,point.y),0===_j11&&!0===doSetFirstPoint&&firstPoint.copy(point);break;\ncase \"l\":numbers=parseFloats(_data);for(var _j12=0,_jl12=numbers.length;_j12<_jl12;_j12+=2)point.x+=numbers[_j12+0],point.y+=numbers[_j12+1],control.x=point.x,control.y=point.y,path$jscomp$0.lineTo(point.x,point.y),0===_j12&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"c\":numbers=parseFloats(_data);for(var _j13=0,_jl13=numbers.length;_j13<_jl13;_j13+=6)path$jscomp$0.bezierCurveTo(point.x+numbers[_j13+0],point.y+numbers[_j13+1],point.x+numbers[_j13+2],point.y+numbers[_j13+3],point.x+numbers[_j13+\n4],point.y+numbers[_j13+5]),control.x=point.x+numbers[_j13+2],control.y=point.y+numbers[_j13+3],point.x+=numbers[_j13+4],point.y+=numbers[_j13+5],0===_j13&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"s\":numbers=parseFloats(_data);for(var _j14=0,_jl14=numbers.length;_j14<_jl14;_j14+=4)path$jscomp$0.bezierCurveTo(getReflection(point.x,control.x),getReflection(point.y,control.y),point.x+numbers[_j14+0],point.y+numbers[_j14+1],point.x+numbers[_j14+2],point.y+numbers[_j14+3]),control.x=point.x+\nnumbers[_j14+0],control.y=point.y+numbers[_j14+1],point.x+=numbers[_j14+2],point.y+=numbers[_j14+3],0===_j14&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"q\":numbers=parseFloats(_data);for(var _j15=0,_jl15=numbers.length;_j15<_jl15;_j15+=4)path$jscomp$0.quadraticCurveTo(point.x+numbers[_j15+0],point.y+numbers[_j15+1],point.x+numbers[_j15+2],point.y+numbers[_j15+3]),control.x=point.x+numbers[_j15+0],control.y=point.y+numbers[_j15+1],point.x+=numbers[_j15+2],point.y+=numbers[_j15+3],0===\n_j15&&!0===doSetFirstPoint&&firstPoint.copy(point);break;case \"t\":numbers=parseFloats(_data);for(var _j16=0,_jl16=numbers.length;_j16<_jl16;_j16+=2){var _rx=getReflection(point.x,control.x),_ry=getReflection(point.y,control.y);path$jscomp$0.quadraticCurveTo(_rx,_ry,point.x+numbers[_j16+0],point.y+numbers[_j16+1]);control.x=_rx;control.y=_ry;point.x+=numbers[_j16+0];point.y+=numbers[_j16+1];0===_j16&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case \"a\":numbers=parseFloats(_data,[3,4],7);for(var _j17=\n0,_jl17=numbers.length;_j17<_jl17;_j17+=7)if(0!=numbers[_j17+5]||0!=numbers[_j17+6]){var _start=point.clone();point.x+=numbers[_j17+5];point.y+=numbers[_j17+6];control.x=point.x;control.y=point.y;parseArcCommand(path$jscomp$0,numbers[_j17],numbers[_j17+1],numbers[_j17+2],numbers[_j17+3],numbers[_j17+4],_start,point);0===_j17&&!0===doSetFirstPoint&&firstPoint.copy(point)}break;case \"Z\":case \"z\":path$jscomp$0.currentPath.autoClose=!0;0<path$jscomp$0.currentPath.curves.length&&(point.copy(firstPoint),\npath$jscomp$0.currentPath.currentPoint.copy(point),isFirstPoint=!0);break;default:console.warn(command)}doSetFirstPoint=!1}path=path$jscomp$0}break;case \"rect\":style=parseStyle(node,style);var x=parseFloatWithUnits(node.getAttribute(\"x\")||0),y=parseFloatWithUnits(node.getAttribute(\"y\")||0),rx$jscomp$0=parseFloatWithUnits(node.getAttribute(\"rx\")||0),ry$jscomp$0=parseFloatWithUnits(node.getAttribute(\"ry\")||0),w=parseFloatWithUnits(node.getAttribute(\"width\")),h=parseFloatWithUnits(node.getAttribute(\"height\")),\npath$jscomp$1=new _three.ShapePath;path$jscomp$1.moveTo(x+2*rx$jscomp$0,y);path$jscomp$1.lineTo(x+w-2*rx$jscomp$0,y);0===rx$jscomp$0&&0===ry$jscomp$0||path$jscomp$1.bezierCurveTo(x+w,y,x+w,y,x+w,y+2*ry$jscomp$0);path$jscomp$1.lineTo(x+w,y+h-2*ry$jscomp$0);0===rx$jscomp$0&&0===ry$jscomp$0||path$jscomp$1.bezierCurveTo(x+w,y+h,x+w,y+h,x+w-2*rx$jscomp$0,y+h);path$jscomp$1.lineTo(x+2*rx$jscomp$0,y+h);0===rx$jscomp$0&&0===ry$jscomp$0||path$jscomp$1.bezierCurveTo(x,y+h,x,y+h,x,y+h-2*ry$jscomp$0);path$jscomp$1.lineTo(x,\ny+2*ry$jscomp$0);0===rx$jscomp$0&&0===ry$jscomp$0||path$jscomp$1.bezierCurveTo(x,y,x,y,x+2*rx$jscomp$0,y);path=path$jscomp$1;break;case \"polygon\":style=parseStyle(node,style);path=parsePolygonNode(node);break;case \"polyline\":style=parseStyle(node,style);path=parsePolylineNode(node);break;case \"circle\":style=parseStyle(node,style);var x$jscomp$0=parseFloatWithUnits(node.getAttribute(\"cx\")||0),y$jscomp$0=parseFloatWithUnits(node.getAttribute(\"cy\")||0),r=parseFloatWithUnits(node.getAttribute(\"r\")||0),\nsubpath=new _three.Path;subpath.absarc(x$jscomp$0,y$jscomp$0,r,0,2*Math.PI);var path$jscomp$2=new _three.ShapePath;path$jscomp$2.subPaths.push(subpath);path=path$jscomp$2;break;case \"ellipse\":style=parseStyle(node,style);var x$jscomp$1=parseFloatWithUnits(node.getAttribute(\"cx\")||0),y$jscomp$1=parseFloatWithUnits(node.getAttribute(\"cy\")||0),rx$jscomp$1=parseFloatWithUnits(node.getAttribute(\"rx\")||0),ry$jscomp$1=parseFloatWithUnits(node.getAttribute(\"ry\")||0),subpath$jscomp$0=new _three.Path;subpath$jscomp$0.absellipse(x$jscomp$1,\ny$jscomp$1,rx$jscomp$1,ry$jscomp$1,0,2*Math.PI);var path$jscomp$3=new _three.ShapePath;path$jscomp$3.subPaths.push(subpath$jscomp$0);path=path$jscomp$3;break;case \"line\":style=parseStyle(node,style);var x1=parseFloatWithUnits(node.getAttribute(\"x1\")||0),y1=parseFloatWithUnits(node.getAttribute(\"y1\")||0),x2=parseFloatWithUnits(node.getAttribute(\"x2\")||0),y2=parseFloatWithUnits(node.getAttribute(\"y2\")||0),path$jscomp$4=new _three.ShapePath;path$jscomp$4.moveTo(x1,y1);path$jscomp$4.lineTo(x2,y2);path$jscomp$4.currentPath.autoClose=\n!1;path=path$jscomp$4;break;case \"defs\":traverseChildNodes=!1;break;case \"use\":style=parseStyle(node,style);var usedNodeId=node.href.baseVal.substring(1),usedNode=node.viewportElement.getElementById(usedNodeId);usedNode?parseNode(usedNode,style):console.warn(\"SVGLoader: 'use node' references non-existent node id: \"+usedNodeId)}path&&(void 0!==style.fill&&\"none\"!==style.fill&&path.color.setStyle(style.fill),transformPath(path,currentTransform),paths.push(path),path.userData={node,style});if(traverseChildNodes)for(var nodes=\nnode.childNodes,i$jscomp$0=0;i$jscomp$0<nodes.length;i$jscomp$0++)parseNode(nodes[i$jscomp$0],style);transform$jscomp$0&&(transformStack.pop(),0<transformStack.length?currentTransform.copy(transformStack[transformStack.length-1]):currentTransform.identity())}}function parseCSSStylesheet(node){if(node.sheet&&node.sheet.cssRules&&node.sheet.cssRules.length)for(var i$jscomp$0=0;i$jscomp$0<node.sheet.cssRules.length;i$jscomp$0++){var stylesheet=node.sheet.cssRules[i$jscomp$0];if(1===stylesheet.type)for(var selectorList=\nstylesheet.selectorText.split(/,/gm).filter(Boolean).map(function(i){return i.trim()}),j=0;j<selectorList.length;j++)stylesheets[selectorList[j]]=Object.assign(stylesheets[selectorList[j]]||{},stylesheet.style)}}function parseArcCommand(path,rx,ry,x_axis_rotation,large_arc_flag,sweep_flag,start,end){if(0==rx||0==ry)path.lineTo(end.x,end.y);else{x_axis_rotation=x_axis_rotation*Math.PI/180;rx=Math.abs(rx);ry=Math.abs(ry);var dx2=(start.x-end.x)/2,dy2=(start.y-end.y)/2,x1p=Math.cos(x_axis_rotation)*\ndx2+Math.sin(x_axis_rotation)*dy2;dx2=-Math.sin(x_axis_rotation)*dx2+Math.cos(x_axis_rotation)*dy2;dy2=rx*rx;var rys=ry*ry,x1ps=x1p*x1p,y1ps=dx2*dx2,cr=x1ps/dy2+y1ps/rys;1<cr&&(dy2=Math.sqrt(cr),rx*=dy2,ry*=dy2,dy2=rx*rx,rys=ry*ry);x1ps=dy2*y1ps+rys*x1ps;dy2=Math.sqrt(Math.max(0,(dy2*rys-x1ps)/x1ps));large_arc_flag===sweep_flag&&(dy2=-dy2);large_arc_flag=dy2*rx*dx2/ry;rys=-dy2*ry*x1p/rx;dy2=Math.cos(x_axis_rotation)*large_arc_flag-Math.sin(x_axis_rotation)*rys+(start.x+end.x)/2;start=Math.sin(x_axis_rotation)*\nlarge_arc_flag+Math.cos(x_axis_rotation)*rys+(start.y+end.y)/2;end=svgAngle(1,0,(x1p-large_arc_flag)/rx,(dx2-rys)/ry);x1p=svgAngle((x1p-large_arc_flag)/rx,(dx2-rys)/ry,(-x1p-large_arc_flag)/rx,(-dx2-rys)/ry)%(2*Math.PI);path.currentPath.absellipse(dy2,start,rx,ry,end,end+x1p,0===sweep_flag,x_axis_rotation)}}function svgAngle(ux,uy,vx,vy){var ang=Math.acos(Math.max(-1,Math.min(1,(ux*vx+uy*vy)/(Math.sqrt(ux*ux+uy*uy)*Math.sqrt(vx*vx+vy*vy)))));0>ux*vy-uy*vx&&(ang=-ang);return ang}function parsePolygonNode(node){var path=\nnew _three.ShapePath,index=0;node.getAttribute(\"points\").replace(/(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g,function(match,a,b){match=parseFloatWithUnits(a);b=parseFloatWithUnits(b);0===index?path.moveTo(match,b):path.lineTo(match,b);index++});path.currentPath.autoClose=!0;return path}function parsePolylineNode(node){var path=new _three.ShapePath,index=0;node.getAttribute(\"points\").replace(/(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g,function(match,a,b){match=parseFloatWithUnits(a);b=parseFloatWithUnits(b);0===index?\npath.moveTo(match,b):path.lineTo(match,b);index++});path.currentPath.autoClose=!1;return path}function parseStyle(node,style){function addStyle(svgName,jsName,adjustFunction){void 0===adjustFunction&&(adjustFunction=function(v){v.startsWith(\"url\")&&console.warn(\"SVGLoader: url access in attributes is not implemented.\");return v});node.hasAttribute(svgName)&&(style[jsName]=adjustFunction(node.getAttribute(svgName)));stylesheetStyles[svgName]&&(style[jsName]=adjustFunction(stylesheetStyles[svgName]));\nnode.style&&\"\"!==node.style[svgName]&&(style[jsName]=adjustFunction(node.style[svgName]))}function clamp(v){return Math.max(0,Math.min(1,parseFloatWithUnits(v)))}function positive(v){return Math.max(0,parseFloatWithUnits(v))}style=Object.assign({},style);var stylesheetStyles={};if(node.hasAttribute(\"class\"))for(var classSelectors=node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map(function(i){return i.trim()}),i$jscomp$0=0;i$jscomp$0<classSelectors.length;i$jscomp$0++)stylesheetStyles=Object.assign(stylesheetStyles,\nstylesheets[\".\"+classSelectors[i$jscomp$0]]);node.hasAttribute(\"id\")&&(stylesheetStyles=Object.assign(stylesheetStyles,stylesheets[\"#\"+node.getAttribute(\"id\")]));addStyle(\"fill\",\"fill\");addStyle(\"fill-opacity\",\"fillOpacity\",clamp);addStyle(\"opacity\",\"opacity\",clamp);addStyle(\"stroke\",\"stroke\");addStyle(\"stroke-opacity\",\"strokeOpacity\",clamp);addStyle(\"stroke-width\",\"strokeWidth\",positive);addStyle(\"stroke-linejoin\",\"strokeLineJoin\");addStyle(\"stroke-linecap\",\"strokeLineCap\");addStyle(\"stroke-miterlimit\",\n\"strokeMiterLimit\",positive);addStyle(\"visibility\",\"visibility\");return style}function getReflection(a,b){return a-(b-a)}function parseFloats(input,flags,stride){function throwSyntaxError(current,i,partial){current=new SyntaxError('Unexpected character \"'+current+'\" at index '+i+\".\");current.partial=partial;throw current;}function newNumber(){\"\"!==number&&(\"\"===exponent?result.push(Number(number)):result.push(Number(number)*Math.pow(10,Number(exponent))));exponent=number=\"\"}if(\"string\"!==typeof input)throw new TypeError(\"Invalid input: \"+\n_typeof(input));for(var JSCompiler_object_inline_WHITESPACE_6624=/[ \\t\\r\\n]/,JSCompiler_object_inline_DIGIT_6625=/[\\d]/,JSCompiler_object_inline_SIGN_6626=/[-+]/,JSCompiler_object_inline_POINT_6627=/\\./,JSCompiler_object_inline_COMMA_6628=/,/,JSCompiler_object_inline_EXP_6629=/e/i,JSCompiler_object_inline_FLAGS_6630=/[01]/,state=0,seenComma=!0,number=\"\",exponent=\"\",result=[],current$jscomp$0,length=input.length,i$jscomp$0=0;i$jscomp$0<length;i$jscomp$0++)if(current$jscomp$0=input[i$jscomp$0],Array.isArray(flags)&&\nflags.includes(result.length%stride)&&JSCompiler_object_inline_FLAGS_6630.test(current$jscomp$0))state=1,number=current$jscomp$0,newNumber();else{if(0===state){if(JSCompiler_object_inline_WHITESPACE_6624.test(current$jscomp$0))continue;if(JSCompiler_object_inline_DIGIT_6625.test(current$jscomp$0)||JSCompiler_object_inline_SIGN_6626.test(current$jscomp$0)){state=1;number=current$jscomp$0;continue}if(JSCompiler_object_inline_POINT_6627.test(current$jscomp$0)){state=2;number=current$jscomp$0;continue}JSCompiler_object_inline_COMMA_6628.test(current$jscomp$0)&&\n(seenComma&&throwSyntaxError(current$jscomp$0,i$jscomp$0,result),seenComma=!0)}if(1===state){if(JSCompiler_object_inline_DIGIT_6625.test(current$jscomp$0)){number+=current$jscomp$0;continue}if(JSCompiler_object_inline_POINT_6627.test(current$jscomp$0)){number+=current$jscomp$0;state=2;continue}if(JSCompiler_object_inline_EXP_6629.test(current$jscomp$0)){state=3;continue}JSCompiler_object_inline_SIGN_6626.test(current$jscomp$0)&&1===number.length&&JSCompiler_object_inline_SIGN_6626.test(number[0])&&\nthrowSyntaxError(current$jscomp$0,i$jscomp$0,result)}if(2===state){if(JSCompiler_object_inline_DIGIT_6625.test(current$jscomp$0)){number+=current$jscomp$0;continue}if(JSCompiler_object_inline_EXP_6629.test(current$jscomp$0)){state=3;continue}JSCompiler_object_inline_POINT_6627.test(current$jscomp$0)&&\".\"===number[number.length-1]&&throwSyntaxError(current$jscomp$0,i$jscomp$0,result)}if(3===state){if(JSCompiler_object_inline_DIGIT_6625.test(current$jscomp$0)){exponent+=current$jscomp$0;continue}if(JSCompiler_object_inline_SIGN_6626.test(current$jscomp$0)){if(\"\"===\nexponent){exponent+=current$jscomp$0;continue}1===exponent.length&&JSCompiler_object_inline_SIGN_6626.test(exponent)&&throwSyntaxError(current$jscomp$0,i$jscomp$0,result)}}JSCompiler_object_inline_WHITESPACE_6624.test(current$jscomp$0)?(newNumber(),state=0,seenComma=!1):JSCompiler_object_inline_COMMA_6628.test(current$jscomp$0)?(newNumber(),state=0,seenComma=!0):JSCompiler_object_inline_SIGN_6626.test(current$jscomp$0)?(newNumber(),state=1,number=current$jscomp$0):JSCompiler_object_inline_POINT_6627.test(current$jscomp$0)?\n(newNumber(),state=2,number=current$jscomp$0):throwSyntaxError(current$jscomp$0,i$jscomp$0,result)}newNumber();return result}function parseFloatWithUnits(string){var theUnit=\"px\";if(\"string\"===typeof string||string instanceof String)for(var i=0,n=units.length;i<n;i++){var u=units[i];if(string.endsWith(u)){theUnit=u;string=string.substring(0,string.length-u.length);break}}\"px\"===theUnit&&\"px\"!==scope.defaultUnit?i=unitConversion[\"in\"][scope.defaultUnit]/scope.defaultDPI:(i=unitConversion[theUnit][scope.defaultUnit],\n0>i&&(i=unitConversion[theUnit][\"in\"]*scope.defaultDPI));return i*parseFloat(string)}function transformPath(path,m){function transfVec2(v2){tempV3.set(v2.x,v2.y,1).applyMatrix3(m);v2.set(tempV3.x,tempV3.y)}var isRotated=0!==m.elements[1]||0!==m.elements[3];path=path.subPaths;for(var i=0,n=path.length;i<n;i++)for(var curves=path[i].curves,j=0;j<curves.length;j++){var curve=curves[j];curve.isLineCurve?(transfVec2(curve.v1),transfVec2(curve.v2)):curve.isCubicBezierCurve?(transfVec2(curve.v0),transfVec2(curve.v1),\ntransfVec2(curve.v2),transfVec2(curve.v3)):curve.isQuadraticBezierCurve?(transfVec2(curve.v0),transfVec2(curve.v1),transfVec2(curve.v2)):curve.isEllipseCurve&&(isRotated&&console.warn(\"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\"),tempV2.set(curve.aX,curve.aY),transfVec2(tempV2),curve.aX=tempV2.x,curve.aY=tempV2.y,curve.xRadius*=getTransformScaleX(m),curve.yRadius*=getTransformScaleY(m))}}function getTransformScaleX(m){m=m.elements;return Math.sqrt(m[0]*m[0]+m[1]*m[1])}\nfunction getTransformScaleY(m){m=m.elements;return Math.sqrt(m[3]*m[3]+m[4]*m[4])}var scope=this,units=\"mm cm in pt pc px\".split(\" \"),unitConversion={mm:{mm:1,cm:.1,\"in\":1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,\"in\":1/2.54,pt:72/2.54,pc:6/2.54,px:-1},\"in\":{mm:25.4,cm:2.54,\"in\":1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,\"in\":1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,\"in\":1/6,pt:12,pc:1,px:-1},px:{px:1}},paths=[],stylesheets={},transformStack=[],tempTransform0=new _three.Matrix3,\ntempTransform1=new _three.Matrix3,tempTransform2=new _three.Matrix3,tempTransform3=new _three.Matrix3,tempV2=new _three.Vector2,tempV3=new _three.Vector3,currentTransform=new _three.Matrix3;text=(new DOMParser).parseFromString(text,\"image/svg+xml\");parseNode(text.documentElement,{fill:\"#000\",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:\"miter\",strokeLineCap:\"butt\",strokeMiterLimit:4});return{paths,xml:text.documentElement}}}],[{key:\"createShapes\",value:function(shapePath){var JSCompiler_object_inline_t_6632;\nfunction findEdgeIntersection(a0,a1,b0,b1){var x1=a0.x,x2=a1.x,x3=b0.x,x4=b1.x,y1=a0.y,y2=a1.y,y3=b0.y,y4=b1.y,nom1=(x4-x3)*(y1-y3)-(y4-y3)*(x1-x3);y4=(y4-y3)*(x2-x1)-(x4-x3)*(y2-y1);x4=nom1/y4;x3=((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3))/y4;if(0===y4&&0!==nom1||0>=x4||1<=x4||0>x3||1<x3)return null;if(0===nom1&&0===y4){for(x4=0;2>x4;x4++){classifyPoint(0===x4?b0:b1,a0,a1);if(JSCompiler_object_inline_loc_6631==IntersectionLocationType.ORIGIN)return y1=0===x4?b0:b1,{x:y1.x,y:y1.y,t:JSCompiler_object_inline_t_6632};\nif(JSCompiler_object_inline_loc_6631==IntersectionLocationType.BETWEEN)return a0=+(x1+JSCompiler_object_inline_t_6632*(x2-x1)).toPrecision(10),y1=+(y1+JSCompiler_object_inline_t_6632*(y2-y1)).toPrecision(10),{x:a0,y:y1,t:JSCompiler_object_inline_t_6632}}return null}for(nom1=0;2>nom1;nom1++)if(classifyPoint(0===nom1?b0:b1,a0,a1),JSCompiler_object_inline_loc_6631==IntersectionLocationType.ORIGIN)return y1=0===nom1?b0:b1,{x:y1.x,y:y1.y,t:JSCompiler_object_inline_t_6632};a0=+(x1+x4*(x2-x1)).toPrecision(10);\ny1=+(y1+x4*(y2-y1)).toPrecision(10);return{x:a0,y:y1,t:x4}}function classifyPoint(p,edgeStart,edgeEnd){var ax=edgeEnd.x-edgeStart.x,ay=edgeEnd.y-edgeStart.y,bx=p.x-edgeStart.x,by=p.y-edgeStart.y,sa=ax*by-bx*ay;p.x===edgeStart.x&&p.y===edgeStart.y?(JSCompiler_object_inline_loc_6631=IntersectionLocationType.ORIGIN,JSCompiler_object_inline_t_6632=0):p.x===edgeEnd.x&&p.y===edgeEnd.y?(JSCompiler_object_inline_loc_6631=IntersectionLocationType.DESTINATION,JSCompiler_object_inline_t_6632=1):sa<-Number.EPSILON?\nJSCompiler_object_inline_loc_6631=IntersectionLocationType.LEFT:sa>Number.EPSILON?JSCompiler_object_inline_loc_6631=IntersectionLocationType.RIGHT:0>ax*bx||0>ay*by?JSCompiler_object_inline_loc_6631=IntersectionLocationType.BEHIND:Math.sqrt(ax*ax+ay*ay)<Math.sqrt(bx*bx+by*by)?JSCompiler_object_inline_loc_6631=IntersectionLocationType.BEYOND:(JSCompiler_object_inline_loc_6631=IntersectionLocationType.BETWEEN,JSCompiler_object_inline_t_6632=0!==ax?bx/ax:by/ay)}function getIntersections(path1,path2){for(var intersectionsRaw=\n[],intersections=[],index=1;index<path1.length;index++)for(var path1EdgeStart=path1[index-1],path1EdgeEnd=path1[index],_loop=function(index2){var intersection=findEdgeIntersection(path1EdgeStart,path1EdgeEnd,path2[index2-1],path2[index2]);null!==intersection&&void 0===intersectionsRaw.find(function(i){return i.t<=intersection.t+Number.EPSILON&&i.t>=intersection.t-Number.EPSILON})&&(intersectionsRaw.push(intersection),intersections.push(new _three.Vector2(intersection.x,intersection.y)))},index2$jscomp$0=\n1;index2$jscomp$0<path2.length;index2$jscomp$0++)_loop(index2$jscomp$0);return intersections}function getScanlineIntersections(scanline,boundingBox,paths){var center=new _three.Vector2;boundingBox.getCenter(center);var allIntersections=[];paths.forEach(function(path){path.boundingBox.containsPoint(center)&&getIntersections(scanline,path.points).forEach(function(p){allIntersections.push({identifier:path.identifier,isCW:path.isCW,point:p})})});allIntersections.sort(function(i1,i2){return i1.point.x-\ni2.point.x});return allIntersections}function isHoleTo(simplePath,allPaths,scanlineMinX,scanlineMaxX,_fillRule){if(null===_fillRule||void 0===_fillRule||\"\"===_fillRule)_fillRule=\"nonzero\";var centerBoundingBox=new _three.Vector2;simplePath.boundingBox.getCenter(centerBoundingBox);scanlineMinX=[new _three.Vector2(scanlineMinX,centerBoundingBox.y),new _three.Vector2(scanlineMaxX,centerBoundingBox.y)];scanlineMinX=getScanlineIntersections(scanlineMinX,simplePath.boundingBox,allPaths);scanlineMinX.sort(function(i1,\ni2){return i1.point.x-i2.point.x});var baseIntersections=[],otherIntersections=[];scanlineMinX.forEach(function(i){i.identifier===simplePath.identifier?baseIntersections.push(i):otherIntersections.push(i)});scanlineMaxX=baseIntersections[0].point.x;scanlineMinX=[];for(centerBoundingBox=0;centerBoundingBox<otherIntersections.length&&otherIntersections[centerBoundingBox].point.x<scanlineMaxX;)0<scanlineMinX.length&&scanlineMinX[scanlineMinX.length-1]===otherIntersections[centerBoundingBox].identifier?\nscanlineMinX.pop():scanlineMinX.push(otherIntersections[centerBoundingBox].identifier),centerBoundingBox++;scanlineMinX.push(simplePath.identifier);if(\"evenodd\"===_fillRule)return{identifier:simplePath.identifier,isHole:0===scanlineMinX.length%2?!0:!1,\"for\":scanlineMinX[scanlineMinX.length-2]};if(\"nonzero\"===_fillRule){_fillRule=!0;centerBoundingBox=scanlineMaxX=null;for(var _i2=0;_i2<scanlineMinX.length;_i2++){var _identifier=scanlineMinX[_i2];_fillRule?(centerBoundingBox=allPaths[_identifier].isCW,\n_fillRule=!1,scanlineMaxX=_identifier):centerBoundingBox!==allPaths[_identifier].isCW&&(centerBoundingBox=allPaths[_identifier].isCW,_fillRule=!0)}return{identifier:simplePath.identifier,isHole:_fillRule,\"for\":scanlineMaxX}}console.warn('fill-rule: \"'+_fillRule+'\" is currently not implemented.')}var IntersectionLocationType={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6};var JSCompiler_object_inline_loc_6631=IntersectionLocationType.ORIGIN;var identifier=JSCompiler_object_inline_t_6632=\n0,scanlineMinX=999999999,scanlineMaxX=-999999999,simplePaths=shapePath.subPaths.map(function(p){p=p.getPoints();for(var maxY=-999999999,minY=999999999,maxX=-999999999,minX=999999999,i=0;i<p.length;i++){var _p=p[i];_p.y>maxY&&(maxY=_p.y);_p.y<minY&&(minY=_p.y);_p.x>maxX&&(maxX=_p.x);_p.x<minX&&(minX=_p.x)}scanlineMaxX<=maxX&&(scanlineMaxX=maxX+1);scanlineMinX>=minX&&(scanlineMinX=minX-1);return{points:p,isCW:_three.ShapeUtils.isClockWise(p),identifier:identifier++,boundingBox:new _three.Box2(new _three.Vector2(minX,\nminY),new _three.Vector2(maxX,maxY))}});simplePaths=simplePaths.filter(function(sp){return 0<sp.points.length});var isAHole=simplePaths.map(function(p){return isHoleTo(p,simplePaths,scanlineMinX,scanlineMaxX,shapePath.userData.style.fillRule)}),shapesToReturn=[];simplePaths.forEach(function(p){if(!isAHole[p.identifier].isHole){var shape=new _three.Shape(p.points);isAHole.filter(function(h){return h.isHole&&h[\"for\"]===p.identifier}).forEach(function(h){shape.holes.push(new _three.Path(simplePaths[h.identifier].points))});\nshapesToReturn.push(shape)}});return shapesToReturn}},{key:\"getStrokeStyle\",value:function(width,color,lineJoin,lineCap,miterLimit){return{strokeColor:void 0!==color?color:\"#000\",strokeWidth:void 0!==width?width:1,strokeLineJoin:void 0!==lineJoin?lineJoin:\"miter\",strokeLineCap:void 0!==lineCap?lineCap:\"butt\",strokeMiterLimit:void 0!==miterLimit?miterLimit:4}}},{key:\"pointsToStroke\",value:function(points,style,arcDivisions,minDistance){var vertices=[],normals=[],uvs=[];if(0===SVGLoader.pointsToStrokeWithBuffers(points,\nstyle,arcDivisions,minDistance,vertices,normals,uvs))return null;points=new _three.BufferGeometry;points.setAttribute(\"position\",new _three.Float32BufferAttribute(vertices,3));points.setAttribute(\"normal\",new _three.Float32BufferAttribute(normals,3));points.setAttribute(\"uv\",new _three.Float32BufferAttribute(uvs,2));return points}},{key:\"pointsToStrokeWithBuffers\",value:function(points$jscomp$0,style,arcDivisions,minDistance,vertices,normals,uvs,vertexOffset){function getNormal(p1,p2,result){result.subVectors(p2,\np1);return result.set(-result.y,result.x).normalize()}function addVertex(position,u,v){vertices&&(vertices[currentCoordinate]=position.x,vertices[currentCoordinate+1]=position.y,vertices[currentCoordinate+2]=0,normals&&(normals[currentCoordinate]=0,normals[currentCoordinate+1]=0,normals[currentCoordinate+2]=1),currentCoordinate+=3,uvs&&(uvs[currentCoordinateUV]=u,uvs[currentCoordinateUV+1]=v,currentCoordinateUV+=2));numVertices+=3}function makeCircularSector(center,p1,p2,u,v){tempV2_1.copy(p1).sub(center).normalize();\ntempV2_2.copy(p2).sub(center).normalize();var angle=Math.PI,dot=tempV2_1.dot(tempV2_2);1>Math.abs(dot)&&(angle=Math.abs(Math.acos(dot)));angle/=arcDivisions;tempV2_3.copy(p1);p1=0;for(dot=arcDivisions-1;p1<dot;p1++)tempV2_4.copy(tempV2_3).rotateAround(center,angle),addVertex(tempV2_3,u,v),addVertex(tempV2_4,u,v),addVertex(center,u,.5),tempV2_3.copy(tempV2_4);addVertex(tempV2_4,u,v);addVertex(p2,u,v);addVertex(center,u,.5)}function makeSegmentTriangles(){addVertex(lastPointR,u0,1);addVertex(lastPointL,\nu0,0);addVertex(currentPointL,u1,0);addVertex(lastPointR,u0,1);addVertex(currentPointL,u1,1);addVertex(currentPointR,u1,0)}function makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u){innerSideModified?(joinIsOnLeftSide?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,0),addVertex(innerPoint,u1,1),addVertex(currentPointL,u,0),addVertex(nextPointL,u,0)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,\nu0,0),addVertex(currentPointR,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(currentPointR,u1,1),addVertex(currentPointR,u,1),addVertex(nextPointR,u,0)),addVertex(innerPoint,u,.5)):(joinIsOnLeftSide?(addVertex(currentPointL,u,0),addVertex(nextPointL,u,0)):(addVertex(currentPointR,u,1),addVertex(nextPointR,u,0)),addVertex(currentPoint,u,.5))}function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified){innerSideModified&&(joinIsOnLeftSide?(addVertex(lastPointR,\nu0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,0),addVertex(innerPoint,u1,1),addVertex(currentPointL,u0,0),addVertex(currentPoint,u1,.5),addVertex(innerPoint,u1,1),addVertex(currentPoint,u1,.5),addVertex(nextPointL,u0,0),addVertex(innerPoint,u1,1)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointR,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(currentPointR,u1,1),addVertex(currentPointR,\nu0,1),addVertex(innerPoint,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(innerPoint,u1,0),addVertex(nextPointR,u0,1)))}function addCapGeometry(center,p1,p2,joinIsOnLeftSide,start,u){switch(style.strokeLineCap){case \"round\":start?makeCircularSector(center,p2,p1,u,.5):makeCircularSector(center,p1,p2,u,.5);break;case \"square\":start?(tempV2_1.subVectors(p1,center),tempV2_2.set(tempV2_1.y,-tempV2_1.x),tempV2_3.addVectors(tempV2_1,tempV2_2).add(center),tempV2_4.subVectors(tempV2_2,\ntempV2_1).add(center),joinIsOnLeftSide?(tempV2_3.toArray(vertices,3),tempV2_4.toArray(vertices,0),tempV2_4.toArray(vertices,9)):(tempV2_3.toArray(vertices,3),tempV2_3.toArray(vertices,9),tempV2_4.toArray(vertices,0))):(tempV2_1.subVectors(p2,center),tempV2_2.set(tempV2_1.y,-tempV2_1.x),tempV2_3.addVectors(tempV2_1,tempV2_2).add(center),tempV2_4.subVectors(tempV2_2,tempV2_1).add(center),center=vertices.length,joinIsOnLeftSide?(tempV2_3.toArray(vertices,center-3),tempV2_4.toArray(vertices,center-6)):\n(tempV2_3.toArray(vertices,center-6),tempV2_4.toArray(vertices,center-3)),tempV2_4.toArray(vertices,center-12))}}var tempV2_1=new _three.Vector2,tempV2_2=new _three.Vector2,tempV2_3=new _three.Vector2,tempV2_4=new _three.Vector2,tempV2_5=new _three.Vector2,tempV2_6=new _three.Vector2,tempV2_7=new _three.Vector2,lastPointL=new _three.Vector2,lastPointR=new _three.Vector2,point0L=new _three.Vector2,point0R=new _three.Vector2,currentPointL=new _three.Vector2,currentPointR=new _three.Vector2,nextPointL=\nnew _three.Vector2,nextPointR=new _three.Vector2,innerPoint=new _three.Vector2,outerPoint=new _three.Vector2;arcDivisions=void 0!==arcDivisions?arcDivisions:12;minDistance=void 0!==minDistance?minDistance:.001;vertexOffset=void 0!==vertexOffset?vertexOffset:0;points$jscomp$0=function(points){for(var dupPoints=!1,i=1,n=points.length-1;i<n;i++)if(points[i].distanceTo(points[i+1])<minDistance){dupPoints=!0;break}if(!dupPoints)return points;dupPoints=[];dupPoints.push(points[0]);i=1;for(n=points.length-\n1;i<n;i++)points[i].distanceTo(points[i+1])>=minDistance&&dupPoints.push(points[i]);dupPoints.push(points[points.length-1]);return dupPoints}(points$jscomp$0);var numPoints=points$jscomp$0.length;if(2>numPoints)return 0;var isClosed=points$jscomp$0[0].equals(points$jscomp$0[numPoints-1]),previousPoint=points$jscomp$0[0],strokeWidth2=style.strokeWidth/2,deltaU=1/(numPoints-1),u0=0,initialJoinIsOnLeftSide=!1,numVertices=0,currentCoordinate=3*vertexOffset,currentCoordinateUV=2*vertexOffset;getNormal(points$jscomp$0[0],\npoints$jscomp$0[1],tempV2_1).multiplyScalar(strokeWidth2);lastPointL.copy(points$jscomp$0[0]).sub(tempV2_1);lastPointR.copy(points$jscomp$0[0]).add(tempV2_1);point0L.copy(lastPointL);point0R.copy(lastPointR);for(vertexOffset=1;vertexOffset<numPoints;vertexOffset++){var currentPoint=points$jscomp$0[vertexOffset];var nextPoint=vertexOffset===numPoints-1?isClosed?points$jscomp$0[1]:void 0:points$jscomp$0[vertexOffset+1];var normal1=tempV2_1;getNormal(previousPoint,currentPoint,normal1);tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\ncurrentPointL.copy(currentPoint).sub(tempV2_3);currentPointR.copy(currentPoint).add(tempV2_3);var u1=u0+deltaU;var innerSideModified=!1;if(void 0!==nextPoint){getNormal(currentPoint,nextPoint,tempV2_2);tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);nextPointL.copy(currentPoint).sub(tempV2_3);nextPointR.copy(currentPoint).add(tempV2_3);var joinIsOnLeftSide=!0;tempV2_3.subVectors(nextPoint,previousPoint);0>normal1.dot(tempV2_3)&&(joinIsOnLeftSide=!1);1===vertexOffset&&(initialJoinIsOnLeftSide=\njoinIsOnLeftSide);tempV2_3.subVectors(nextPoint,currentPoint);tempV2_3.normalize();normal1=Math.abs(normal1.dot(tempV2_3));if(0!==normal1){var isMiter=strokeWidth2/normal1;tempV2_3.multiplyScalar(-isMiter);tempV2_4.subVectors(currentPoint,previousPoint);tempV2_5.copy(tempV2_4).setLength(isMiter).add(tempV2_3);innerPoint.copy(tempV2_5).negate();previousPoint=tempV2_5.length();isMiter=tempV2_4.length();tempV2_4.divideScalar(isMiter);tempV2_6.subVectors(nextPoint,currentPoint);nextPoint=tempV2_6.length();\ntempV2_6.divideScalar(nextPoint);tempV2_4.dot(innerPoint)<isMiter&&tempV2_6.dot(innerPoint)<nextPoint&&(innerSideModified=!0);outerPoint.copy(tempV2_5).add(currentPoint);innerPoint.add(currentPoint);isMiter=!1;innerSideModified?joinIsOnLeftSide?(nextPointR.copy(innerPoint),currentPointR.copy(innerPoint)):(nextPointL.copy(innerPoint),currentPointL.copy(innerPoint)):makeSegmentTriangles();switch(style.strokeLineJoin){case \"bevel\":makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u1);break;\ncase \"round\":createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified);joinIsOnLeftSide?makeCircularSector(currentPoint,currentPointL,nextPointL,u1,0):makeCircularSector(currentPoint,nextPointR,currentPointR,u1,1);break;default:nextPoint=strokeWidth2*style.strokeMiterLimit/previousPoint,1>nextPoint?\"miter-clip\"!==style.strokeLineJoin?makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u1):(createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified),joinIsOnLeftSide?\n(tempV2_6.subVectors(outerPoint,currentPointL).multiplyScalar(nextPoint).add(currentPointL),tempV2_7.subVectors(outerPoint,nextPointL).multiplyScalar(nextPoint).add(nextPointL),addVertex(currentPointL,u1,0),addVertex(tempV2_6,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(tempV2_6,u1,0),addVertex(tempV2_7,u1,0),addVertex(currentPoint,u1,.5),addVertex(tempV2_7,u1,0),addVertex(nextPointL,u1,0)):(tempV2_6.subVectors(outerPoint,currentPointR).multiplyScalar(nextPoint).add(currentPointR),\ntempV2_7.subVectors(outerPoint,nextPointR).multiplyScalar(nextPoint).add(nextPointR),addVertex(currentPointR,u1,1),addVertex(tempV2_6,u1,1),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(tempV2_6,u1,1),addVertex(tempV2_7,u1,1),addVertex(currentPoint,u1,.5),addVertex(tempV2_7,u1,1),addVertex(nextPointR,u1,1))):(innerSideModified?(joinIsOnLeftSide?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(outerPoint,u1,0),addVertex(lastPointR,u0,1),addVertex(outerPoint,\nu1,0),addVertex(innerPoint,u1,1)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(outerPoint,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(outerPoint,u1,1)),joinIsOnLeftSide?nextPointL.copy(outerPoint):nextPointR.copy(outerPoint)):joinIsOnLeftSide?(addVertex(currentPointL,u1,0),addVertex(outerPoint,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(outerPoint,u1,0),addVertex(nextPointL,u1,0)):(addVertex(currentPointR,u1,1),addVertex(outerPoint,\nu1,1),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(outerPoint,u1,1),addVertex(nextPointR,u1,1)),isMiter=!0)}}else makeSegmentTriangles()}else makeSegmentTriangles();isClosed||vertexOffset!==numPoints-1||addCapGeometry(points$jscomp$0[0],point0L,point0R,joinIsOnLeftSide,!0,u0);u0=u1;previousPoint=currentPoint;lastPointL.copy(nextPointL);lastPointR.copy(nextPointR)}if(!isClosed)addCapGeometry(currentPoint,currentPointL,currentPointR,joinIsOnLeftSide,!1,u1);else if(innerSideModified&&\nvertices)if(points$jscomp$0=outerPoint,tempV2_5=innerPoint,initialJoinIsOnLeftSide!==joinIsOnLeftSide&&(points$jscomp$0=innerPoint,tempV2_5=outerPoint),joinIsOnLeftSide){if(isMiter||initialJoinIsOnLeftSide)tempV2_5.toArray(vertices,0),tempV2_5.toArray(vertices,9),isMiter&&points$jscomp$0.toArray(vertices,3)}else if(isMiter||!initialJoinIsOnLeftSide)tempV2_5.toArray(vertices,3),tempV2_5.toArray(vertices,9),isMiter&&points$jscomp$0.toArray(vertices,0);return numVertices}}]);return SVGLoader}(_three.Loader);\nexports.SVGLoader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$SVGLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SVGLoader = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar SVGLoader =\n/*#__PURE__*/\nfunction (_Loader) {\n  _inherits(SVGLoader, _Loader);\n\n  function SVGLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, SVGLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SVGLoader).call(this, manager)); // Default dots per inch\n\n    _this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\n    _this.defaultUnit = 'px';\n    return _this;\n  }\n\n  _createClass(SVGLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new _three.FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var scope = this;\n\n      function parseNode(node, style) {\n        if (node.nodeType !== 1) return;\n        var transform = getNodeTransform(node);\n        var traverseChildNodes = true;\n        var path = null;\n\n        switch (node.nodeName) {\n          case 'svg':\n            break;\n\n          case 'style':\n            parseCSSStylesheet(node);\n            break;\n\n          case 'g':\n            style = parseStyle(node, style);\n            break;\n\n          case 'path':\n            style = parseStyle(node, style);\n            if (node.hasAttribute('d')) path = parsePathNode(node);\n            break;\n\n          case 'rect':\n            style = parseStyle(node, style);\n            path = parseRectNode(node);\n            break;\n\n          case 'polygon':\n            style = parseStyle(node, style);\n            path = parsePolygonNode(node);\n            break;\n\n          case 'polyline':\n            style = parseStyle(node, style);\n            path = parsePolylineNode(node);\n            break;\n\n          case 'circle':\n            style = parseStyle(node, style);\n            path = parseCircleNode(node);\n            break;\n\n          case 'ellipse':\n            style = parseStyle(node, style);\n            path = parseEllipseNode(node);\n            break;\n\n          case 'line':\n            style = parseStyle(node, style);\n            path = parseLineNode(node);\n            break;\n\n          case 'defs':\n            traverseChildNodes = false;\n            break;\n\n          case 'use':\n            style = parseStyle(node, style);\n            var usedNodeId = node.href.baseVal.substring(1);\n            var usedNode = node.viewportElement.getElementById(usedNodeId);\n\n            if (usedNode) {\n              parseNode(usedNode, style);\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n            }\n\n            break;\n        }\n\n        if (path) {\n          if (style.fill !== undefined && style.fill !== 'none') {\n            path.color.setStyle(style.fill);\n          }\n\n          transformPath(path, currentTransform);\n          paths.push(path);\n          path.userData = {\n            node: node,\n            style: style\n          };\n        }\n\n        if (traverseChildNodes) {\n          var nodes = node.childNodes;\n\n          for (var i = 0; i < nodes.length; i++) {\n            parseNode(nodes[i], style);\n          }\n        }\n\n        if (transform) {\n          transformStack.pop();\n\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1]);\n          } else {\n            currentTransform.identity();\n          }\n        }\n      }\n\n      function parsePathNode(node) {\n        var path = new _three.ShapePath();\n        var point = new _three.Vector2();\n        var control = new _three.Vector2();\n        var firstPoint = new _three.Vector2();\n        var isFirstPoint = true;\n        var doSetFirstPoint = false;\n        var d = node.getAttribute('d'); // console.log( d );\n\n        var commands = d.match(/[a-df-z][^a-df-z]*/gi);\n\n        for (var i = 0, l = commands.length; i < l; i++) {\n          var command = commands[i];\n          var type = command.charAt(0);\n\n          var _data = command.substr(1).trim();\n\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true;\n            isFirstPoint = false;\n          }\n\n          var numbers = void 0;\n\n          switch (type) {\n            case 'M':\n              numbers = parseFloats(_data);\n\n              for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'H':\n              numbers = parseFloats(_data);\n\n              for (var _j = 0, _jl = numbers.length; _j < _jl; _j++) {\n                point.x = numbers[_j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'V':\n              numbers = parseFloats(_data);\n\n              for (var _j2 = 0, _jl2 = numbers.length; _j2 < _jl2; _j2++) {\n                point.y = numbers[_j2];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j2 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'L':\n              numbers = parseFloats(_data);\n\n              for (var _j3 = 0, _jl3 = numbers.length; _j3 < _jl3; _j3 += 2) {\n                point.x = numbers[_j3 + 0];\n                point.y = numbers[_j3 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j3 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'C':\n              numbers = parseFloats(_data);\n\n              for (var _j4 = 0, _jl4 = numbers.length; _j4 < _jl4; _j4 += 6) {\n                path.bezierCurveTo(numbers[_j4 + 0], numbers[_j4 + 1], numbers[_j4 + 2], numbers[_j4 + 3], numbers[_j4 + 4], numbers[_j4 + 5]);\n                control.x = numbers[_j4 + 2];\n                control.y = numbers[_j4 + 3];\n                point.x = numbers[_j4 + 4];\n                point.y = numbers[_j4 + 5];\n                if (_j4 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'S':\n              numbers = parseFloats(_data);\n\n              for (var _j5 = 0, _jl5 = numbers.length; _j5 < _jl5; _j5 += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[_j5 + 0], numbers[_j5 + 1], numbers[_j5 + 2], numbers[_j5 + 3]);\n                control.x = numbers[_j5 + 0];\n                control.y = numbers[_j5 + 1];\n                point.x = numbers[_j5 + 2];\n                point.y = numbers[_j5 + 3];\n                if (_j5 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'Q':\n              numbers = parseFloats(_data);\n\n              for (var _j6 = 0, _jl6 = numbers.length; _j6 < _jl6; _j6 += 4) {\n                path.quadraticCurveTo(numbers[_j6 + 0], numbers[_j6 + 1], numbers[_j6 + 2], numbers[_j6 + 3]);\n                control.x = numbers[_j6 + 0];\n                control.y = numbers[_j6 + 1];\n                point.x = numbers[_j6 + 2];\n                point.y = numbers[_j6 + 3];\n                if (_j6 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'T':\n              numbers = parseFloats(_data);\n\n              for (var _j7 = 0, _jl7 = numbers.length; _j7 < _jl7; _j7 += 2) {\n                var rx = getReflection(point.x, control.x);\n                var ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, numbers[_j7 + 0], numbers[_j7 + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = numbers[_j7 + 0];\n                point.y = numbers[_j7 + 1];\n                if (_j7 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'A':\n              numbers = parseFloats(_data, [3, 4], 7);\n\n              for (var _j8 = 0, _jl8 = numbers.length; _j8 < _jl8; _j8 += 7) {\n                // skip command if start point == end point\n                if (numbers[_j8 + 5] == point.x && numbers[_j8 + 6] == point.y) continue;\n                var start = point.clone();\n                point.x = numbers[_j8 + 5];\n                point.y = numbers[_j8 + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[_j8], numbers[_j8 + 1], numbers[_j8 + 2], numbers[_j8 + 3], numbers[_j8 + 4], start, point);\n                if (_j8 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'm':\n              numbers = parseFloats(_data);\n\n              for (var _j9 = 0, _jl9 = numbers.length; _j9 < _jl9; _j9 += 2) {\n                point.x += numbers[_j9 + 0];\n                point.y += numbers[_j9 + 1];\n                control.x = point.x;\n                control.y = point.y;\n\n                if (_j9 === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n\n                if (_j9 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'h':\n              numbers = parseFloats(_data);\n\n              for (var _j10 = 0, _jl10 = numbers.length; _j10 < _jl10; _j10++) {\n                point.x += numbers[_j10];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j10 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'v':\n              numbers = parseFloats(_data);\n\n              for (var _j11 = 0, _jl11 = numbers.length; _j11 < _jl11; _j11++) {\n                point.y += numbers[_j11];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j11 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'l':\n              numbers = parseFloats(_data);\n\n              for (var _j12 = 0, _jl12 = numbers.length; _j12 < _jl12; _j12 += 2) {\n                point.x += numbers[_j12 + 0];\n                point.y += numbers[_j12 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j12 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'c':\n              numbers = parseFloats(_data);\n\n              for (var _j13 = 0, _jl13 = numbers.length; _j13 < _jl13; _j13 += 6) {\n                path.bezierCurveTo(point.x + numbers[_j13 + 0], point.y + numbers[_j13 + 1], point.x + numbers[_j13 + 2], point.y + numbers[_j13 + 3], point.x + numbers[_j13 + 4], point.y + numbers[_j13 + 5]);\n                control.x = point.x + numbers[_j13 + 2];\n                control.y = point.y + numbers[_j13 + 3];\n                point.x += numbers[_j13 + 4];\n                point.y += numbers[_j13 + 5];\n                if (_j13 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 's':\n              numbers = parseFloats(_data);\n\n              for (var _j14 = 0, _jl14 = numbers.length; _j14 < _jl14; _j14 += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[_j14 + 0], point.y + numbers[_j14 + 1], point.x + numbers[_j14 + 2], point.y + numbers[_j14 + 3]);\n                control.x = point.x + numbers[_j14 + 0];\n                control.y = point.y + numbers[_j14 + 1];\n                point.x += numbers[_j14 + 2];\n                point.y += numbers[_j14 + 3];\n                if (_j14 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'q':\n              numbers = parseFloats(_data);\n\n              for (var _j15 = 0, _jl15 = numbers.length; _j15 < _jl15; _j15 += 4) {\n                path.quadraticCurveTo(point.x + numbers[_j15 + 0], point.y + numbers[_j15 + 1], point.x + numbers[_j15 + 2], point.y + numbers[_j15 + 3]);\n                control.x = point.x + numbers[_j15 + 0];\n                control.y = point.y + numbers[_j15 + 1];\n                point.x += numbers[_j15 + 2];\n                point.y += numbers[_j15 + 3];\n                if (_j15 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 't':\n              numbers = parseFloats(_data);\n\n              for (var _j16 = 0, _jl16 = numbers.length; _j16 < _jl16; _j16 += 2) {\n                var _rx = getReflection(point.x, control.x);\n\n                var _ry = getReflection(point.y, control.y);\n\n                path.quadraticCurveTo(_rx, _ry, point.x + numbers[_j16 + 0], point.y + numbers[_j16 + 1]);\n                control.x = _rx;\n                control.y = _ry;\n                point.x = point.x + numbers[_j16 + 0];\n                point.y = point.y + numbers[_j16 + 1];\n                if (_j16 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'a':\n              numbers = parseFloats(_data, [3, 4], 7);\n\n              for (var _j17 = 0, _jl17 = numbers.length; _j17 < _jl17; _j17 += 7) {\n                // skip command if no displacement\n                if (numbers[_j17 + 5] == 0 && numbers[_j17 + 6] == 0) continue;\n\n                var _start = point.clone();\n\n                point.x += numbers[_j17 + 5];\n                point.y += numbers[_j17 + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[_j17], numbers[_j17 + 1], numbers[_j17 + 2], numbers[_j17 + 3], numbers[_j17 + 4], _start, point);\n                if (_j17 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n\n              break;\n\n            case 'Z':\n            case 'z':\n              path.currentPath.autoClose = true;\n\n              if (path.currentPath.curves.length > 0) {\n                // Reset point to beginning of Path\n                point.copy(firstPoint);\n                path.currentPath.currentPoint.copy(point);\n                isFirstPoint = true;\n              }\n\n              break;\n\n            default:\n              console.warn(command);\n          } // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\n          doSetFirstPoint = false;\n        }\n\n        return path;\n      }\n\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n\n        for (var i = 0; i < node.sheet.cssRules.length; i++) {\n          var stylesheet = node.sheet.cssRules[i];\n          if (stylesheet.type !== 1) continue;\n          var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(function (i) {\n            return i.trim();\n          });\n\n          for (var j = 0; j < selectorList.length; j++) {\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\n          }\n        }\n      }\n      /**\n       * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n       * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n       * From\n       * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n       * To\n       * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n       */\n\n\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          // draw a line if either of the radii == 0\n          path.lineTo(end.x, end.y);\n          return;\n        }\n\n        x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive\n\n        rx = Math.abs(rx);\n        ry = Math.abs(ry); // Compute (x1', y1')\n\n        var dx2 = (start.x - end.x) / 2.0;\n        var dy2 = (start.y - end.y) / 2.0;\n        var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n        var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2; // Compute (cx', cy')\n\n        var rxs = rx * rx;\n        var rys = ry * ry;\n        var x1ps = x1p * x1p;\n        var y1ps = y1p * y1p; // Ensure radii are large enough\n\n        var cr = x1ps / rxs + y1ps / rys;\n\n        if (cr > 1) {\n          // scale up rx,ry equally so cr == 1\n          var s = Math.sqrt(cr);\n          rx = s * rx;\n          ry = s * ry;\n          rxs = rx * rx;\n          rys = ry * ry;\n        }\n\n        var dq = rxs * y1ps + rys * x1ps;\n        var pq = (rxs * rys - dq) / dq;\n        var q = Math.sqrt(Math.max(0, pq));\n        if (large_arc_flag === sweep_flag) q = -q;\n        var cxp = q * rx * y1p / ry;\n        var cyp = -q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy')\n\n        var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n        var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2; // Step 4: Compute θ1 and Δθ\n\n        var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n        var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n      }\n\n      function svgAngle(ux, uy, vx, vy) {\n        var dot = ux * vx + uy * vy;\n        var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n        var ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n\n        if (ux * vy - uy * vx < 0) ang = -ang;\n        return ang;\n      }\n      /*\n       * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n       * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n       */\n\n\n      function parseRectNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute('x') || 0);\n        var y = parseFloatWithUnits(node.getAttribute('y') || 0);\n        var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n        var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n        var w = parseFloatWithUnits(node.getAttribute('width'));\n        var h = parseFloatWithUnits(node.getAttribute('height'));\n        var path = new _three.ShapePath();\n        path.moveTo(x + 2 * rx, y);\n        path.lineTo(x + w - 2 * rx, y);\n        if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n        path.lineTo(x + w, y + h - 2 * ry);\n        if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n        path.lineTo(x + 2 * rx, y + h);\n\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n        }\n\n        path.lineTo(x, y + 2 * ry);\n\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n        }\n\n        return path;\n      }\n\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          var x = parseFloatWithUnits(a);\n          var y = parseFloatWithUnits(b);\n\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n\n          index++;\n        }\n\n        var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n        var path = new _three.ShapePath();\n        var index = 0;\n        node.getAttribute('points').replace(regex, iterator);\n        path.currentPath.autoClose = true;\n        return path;\n      }\n\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          var x = parseFloatWithUnits(a);\n          var y = parseFloatWithUnits(b);\n\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n\n          index++;\n        }\n\n        var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n        var path = new _three.ShapePath();\n        var index = 0;\n        node.getAttribute('points').replace(regex, iterator);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n\n      function parseCircleNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute('cx') || 0);\n        var y = parseFloatWithUnits(node.getAttribute('cy') || 0);\n        var r = parseFloatWithUnits(node.getAttribute('r') || 0);\n        var subpath = new _three.Path();\n        subpath.absarc(x, y, r, 0, Math.PI * 2);\n        var path = new _three.ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n\n      function parseEllipseNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute('cx') || 0);\n        var y = parseFloatWithUnits(node.getAttribute('cy') || 0);\n        var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n        var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n        var subpath = new _three.Path();\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n        var path = new _three.ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n\n      function parseLineNode(node) {\n        var x1 = parseFloatWithUnits(node.getAttribute('x1') || 0);\n        var y1 = parseFloatWithUnits(node.getAttribute('y1') || 0);\n        var x2 = parseFloatWithUnits(node.getAttribute('x2') || 0);\n        var y2 = parseFloatWithUnits(node.getAttribute('y2') || 0);\n        var path = new _three.ShapePath();\n        path.moveTo(x1, y1);\n        path.lineTo(x2, y2);\n        path.currentPath.autoClose = false;\n        return path;\n      } //\n\n\n      function parseStyle(node, style) {\n        style = Object.assign({}, style); // clone style\n\n        var stylesheetStyles = {};\n\n        if (node.hasAttribute('class')) {\n          var classSelectors = node.getAttribute('class').split(/\\s/).filter(Boolean).map(function (i) {\n            return i.trim();\n          });\n\n          for (var i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]]);\n          }\n        }\n\n        if (node.hasAttribute('id')) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')]);\n        }\n\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === undefined) {\n            adjustFunction = function copy(v) {\n              if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.');\n              return v;\n            };\n          }\n\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n          if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName]);\n        }\n\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n        }\n\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v));\n        }\n\n        addStyle('fill', 'fill');\n        addStyle('fill-opacity', 'fillOpacity', clamp);\n        addStyle('opacity', 'opacity', clamp);\n        addStyle('stroke', 'stroke');\n        addStyle('stroke-opacity', 'strokeOpacity', clamp);\n        addStyle('stroke-width', 'strokeWidth', positive);\n        addStyle('stroke-linejoin', 'strokeLineJoin');\n        addStyle('stroke-linecap', 'strokeLineCap');\n        addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\n        addStyle('visibility', 'visibility');\n        return style;\n      } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\n      function getReflection(a, b) {\n        return a - (b - a);\n      } // from https://github.com/ppvg/svg-numbers (MIT License)\n\n\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== 'string') {\n          throw new TypeError('Invalid input: ' + _typeof(input));\n        } // Character groups\n\n\n        var RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/\n        }; // States\n\n        var SEP = 0;\n        var INT = 1;\n        var FLOAT = 2;\n        var EXP = 3;\n        var state = SEP;\n        var seenComma = true;\n        var number = '',\n            exponent = '';\n        var result = [];\n\n        function throwSyntaxError(current, i, partial) {\n          var error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.');\n          error.partial = partial;\n          throw error;\n        }\n\n        function newNumber() {\n          if (number !== '') {\n            if (exponent === '') result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n          }\n\n          number = '';\n          exponent = '';\n        }\n\n        var current;\n        var length = input.length;\n\n        for (var i = 0; i < length; i++) {\n          current = input[i]; // check for flags\n\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT;\n            number = current;\n            newNumber();\n            continue;\n          } // parse until next number\n\n\n          if (state === SEP) {\n            // eat whitespace\n            if (RE.WHITESPACE.test(current)) {\n              continue;\n            } // start new number\n\n\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT;\n              number = current;\n              continue;\n            }\n\n            if (RE.POINT.test(current)) {\n              state = FLOAT;\n              number = current;\n              continue;\n            } // throw on double commas (e.g. \"1, , 2\")\n\n\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result);\n              }\n\n              seenComma = true;\n            }\n          } // parse integer part\n\n\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n\n            if (RE.POINT.test(current)) {\n              number += current;\n              state = FLOAT;\n              continue;\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            } // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\n\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result);\n            }\n          } // parse decimal part\n\n\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            } // throw on double decimal points (e.g. \"1..2\")\n\n\n            if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n              throwSyntaxError(current, i, result);\n            }\n          } // parse exponent part\n\n\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current;\n              continue;\n            }\n\n            if (RE.SIGN.test(current)) {\n              if (exponent === '') {\n                exponent += current;\n                continue;\n              }\n\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result);\n              }\n            }\n          } // end of number\n\n\n          if (RE.WHITESPACE.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = false;\n          } else if (RE.COMMA.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = true;\n          } else if (RE.SIGN.test(current)) {\n            newNumber();\n            state = INT;\n            number = current;\n          } else if (RE.POINT.test(current)) {\n            newNumber();\n            state = FLOAT;\n            number = current;\n          } else {\n            throwSyntaxError(current, i, result);\n          }\n        } // add the last number found (if any)\n\n\n        newNumber();\n        return result;\n      } // Units\n\n\n      var units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\n      var unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          \"in\": 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          \"in\": 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1\n        },\n        \"in\": {\n          mm: 25.4,\n          cm: 2.54,\n          \"in\": 1,\n          pt: 72,\n          pc: 6,\n          px: -1\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          \"in\": 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          \"in\": 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1\n        },\n        px: {\n          px: 1\n        }\n      };\n\n      function parseFloatWithUnits(string) {\n        var theUnit = 'px';\n\n        if (typeof string === 'string' || string instanceof String) {\n          for (var i = 0, n = units.length; i < n; i++) {\n            var u = units[i];\n\n            if (string.endsWith(u)) {\n              theUnit = u;\n              string = string.substring(0, string.length - u.length);\n              break;\n            }\n          }\n        }\n\n        var scale = undefined;\n\n        if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n          // Conversion scale from  pixels to inches, then to default units\n          scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit];\n\n          if (scale < 0) {\n            // Conversion scale to pixels\n            scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\n          }\n        }\n\n        return scale * parseFloat(string);\n      } // Transforms\n\n\n      function getNodeTransform(node) {\n        if (!(node.hasAttribute('transform') || node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))) {\n          return null;\n        }\n\n        var transform = parseNodeTransform(node);\n\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1]);\n        }\n\n        currentTransform.copy(transform);\n        transformStack.push(transform);\n        return transform;\n      }\n\n      function parseNodeTransform(node) {\n        var transform = new _three.Matrix3();\n        var currentTransform = tempTransform0;\n\n        if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n          var tx = parseFloatWithUnits(node.getAttribute('x'));\n          var ty = parseFloatWithUnits(node.getAttribute('y'));\n          transform.translate(tx, ty);\n        }\n\n        if (node.hasAttribute('transform')) {\n          var transformsTexts = node.getAttribute('transform').split(')');\n\n          for (var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            var transformText = transformsTexts[tIndex].trim();\n            if (transformText === '') continue;\n            var openParPos = transformText.indexOf('(');\n            var closeParPos = transformText.length;\n\n            if (openParPos > 0 && openParPos < closeParPos) {\n              var transformType = transformText.substr(0, openParPos);\n              var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n              currentTransform.identity();\n\n              switch (transformType) {\n                case 'translate':\n                  if (array.length >= 1) {\n                    var _tx = array[0];\n                    var _ty = _tx;\n\n                    if (array.length >= 2) {\n                      _ty = array[1];\n                    }\n\n                    currentTransform.translate(_tx, _ty);\n                  }\n\n                  break;\n\n                case 'rotate':\n                  if (array.length >= 1) {\n                    var angle = 0;\n                    var cx = 0;\n                    var cy = 0; // Angle\n\n                    angle = -array[0] * Math.PI / 180;\n\n                    if (array.length >= 3) {\n                      // Center x, y\n                      cx = array[1];\n                      cy = array[2];\n                    } // Rotate around center (cx, cy)\n\n\n                    tempTransform1.identity().translate(-cx, -cy);\n                    tempTransform2.identity().rotate(angle);\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                    tempTransform1.identity().translate(cx, cy);\n                    currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                  }\n\n                  break;\n\n                case 'scale':\n                  if (array.length >= 1) {\n                    var scaleX = array[0];\n                    var scaleY = scaleX;\n\n                    if (array.length >= 2) {\n                      scaleY = array[1];\n                    }\n\n                    currentTransform.scale(scaleX, scaleY);\n                  }\n\n                  break;\n\n                case 'skewX':\n                  if (array.length === 1) {\n                    currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                  }\n\n                  break;\n\n                case 'skewY':\n                  if (array.length === 1) {\n                    currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                  }\n\n                  break;\n\n                case 'matrix':\n                  if (array.length === 6) {\n                    currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                  }\n\n                  break;\n              }\n            }\n\n            transform.premultiply(currentTransform);\n          }\n        }\n\n        return transform;\n      }\n\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n          v2.set(tempV3.x, tempV3.y);\n        }\n\n        var isRotated = isTransformRotated(m);\n        var subPaths = path.subPaths;\n\n        for (var i = 0, n = subPaths.length; i < n; i++) {\n          var subPath = subPaths[i];\n          var curves = subPath.curves;\n\n          for (var j = 0; j < curves.length; j++) {\n            var curve = curves[j];\n\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n              transfVec2(curve.v3);\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isEllipseCurve) {\n              if (isRotated) {\n                console.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n              }\n\n              tempV2.set(curve.aX, curve.aY);\n              transfVec2(tempV2);\n              curve.aX = tempV2.x;\n              curve.aY = tempV2.y;\n              curve.xRadius *= getTransformScaleX(m);\n              curve.yRadius *= getTransformScaleY(m);\n            }\n          }\n        }\n      }\n\n      function isTransformRotated(m) {\n        return m.elements[1] !== 0 || m.elements[3] !== 0;\n      }\n\n      function getTransformScaleX(m) {\n        var te = m.elements;\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n      }\n\n      function getTransformScaleY(m) {\n        var te = m.elements;\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n      } //\n\n\n      var paths = [];\n      var stylesheets = {};\n      var transformStack = [];\n      var tempTransform0 = new _three.Matrix3();\n      var tempTransform1 = new _three.Matrix3();\n      var tempTransform2 = new _three.Matrix3();\n      var tempTransform3 = new _three.Matrix3();\n      var tempV2 = new _three.Vector2();\n      var tempV3 = new _three.Vector3();\n      var currentTransform = new _three.Matrix3();\n      var xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n      parseNode(xml.documentElement, {\n        fill: '#000',\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: 'miter',\n        strokeLineCap: 'butt',\n        strokeMiterLimit: 4\n      });\n      var data = {\n        paths: paths,\n        xml: xml.documentElement\n      }; // console.log( paths );\n\n      return data;\n    }\n  }], [{\n    key: \"createShapes\",\n    value: function createShapes(shapePath) {\n      // Param shapePath: a shapepath as returned by the parse function of this class\n      // Returns Shape object\n      var BIGNUMBER = 999999999;\n      var IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6\n      };\n      var classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0\n      };\n\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        var x1 = a0.x;\n        var x2 = a1.x;\n        var x3 = b0.x;\n        var x4 = b1.x;\n        var y1 = a0.y;\n        var y2 = a1.y;\n        var y3 = b0.y;\n        var y4 = b1.y;\n        var nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n        var nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n        var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n        var t1 = nom1 / denom;\n        var t2 = nom2 / denom;\n\n        if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          //1. lines are parallel or edges don't intersect\n          return null;\n        } else if (nom1 === 0 && denom === 0) {\n          //2. lines are colinear\n          //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n          for (var i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1); //find position of this endpoints relatively to edge1\n\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              var point = i === 0 ? b0 : b1;\n              return {\n                x: point.x,\n                y: point.y,\n                t: classifyResult.t\n              };\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              var x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n              var y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n              return {\n                x: x,\n                y: y,\n                t: classifyResult.t\n              };\n            }\n          }\n\n          return null;\n        } else {\n          //3. edges intersect\n          for (var _i = 0; _i < 2; _i++) {\n            classifyPoint(_i === 0 ? b0 : b1, a0, a1);\n\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              var _point = _i === 0 ? b0 : b1;\n\n              return {\n                x: _point.x,\n                y: _point.y,\n                t: classifyResult.t\n              };\n            }\n          }\n\n          var _x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n\n          var _y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n\n          return {\n            x: _x,\n            y: _y,\n            t: t1\n          };\n        }\n      }\n\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        var ax = edgeEnd.x - edgeStart.x;\n        var ay = edgeEnd.y - edgeStart.y;\n        var bx = p.x - edgeStart.x;\n        var by = p.y - edgeStart.y;\n        var sa = ax * by - bx * ay;\n\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN;\n          classifyResult.t = 0;\n          return;\n        }\n\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION;\n          classifyResult.t = 1;\n          return;\n        }\n\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT;\n          return;\n        }\n\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT;\n          return;\n        }\n\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND;\n          return;\n        }\n\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND;\n          return;\n        }\n\n        var t;\n\n        if (ax !== 0) {\n          t = bx / ax;\n        } else {\n          t = by / ay;\n        }\n\n        classifyResult.loc = IntersectionLocationType.BETWEEN;\n        classifyResult.t = t;\n      }\n\n      function getIntersections(path1, path2) {\n        var intersectionsRaw = [];\n        var intersections = [];\n\n        for (var index = 1; index < path1.length; index++) {\n          var path1EdgeStart = path1[index - 1];\n          var path1EdgeEnd = path1[index];\n\n          var _loop = function _loop(index2) {\n            var path2EdgeStart = path2[index2 - 1];\n            var path2EdgeEnd = path2[index2];\n            var intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n\n            if (intersection !== null && intersectionsRaw.find(function (i) {\n              return i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON;\n            }) === undefined) {\n              intersectionsRaw.push(intersection);\n              intersections.push(new _three.Vector2(intersection.x, intersection.y));\n            }\n          };\n\n          for (var index2 = 1; index2 < path2.length; index2++) {\n            _loop(index2);\n          }\n        }\n\n        return intersections;\n      }\n\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        var center = new _three.Vector2();\n        boundingBox.getCenter(center);\n        var allIntersections = [];\n        paths.forEach(function (path) {\n          // check if the center of the bounding box is in the bounding box of the paths.\n          // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n          // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n          if (path.boundingBox.containsPoint(center)) {\n            var intersections = getIntersections(scanline, path.points);\n            intersections.forEach(function (p) {\n              allIntersections.push({\n                identifier: path.identifier,\n                isCW: path.isCW,\n                point: p\n              });\n            });\n          }\n        });\n        allIntersections.sort(function (i1, i2) {\n          return i1.point.x - i2.point.x;\n        });\n        return allIntersections;\n      }\n\n      function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n        if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n          _fillRule = 'nonzero';\n        }\n\n        var centerBoundingBox = new _three.Vector2();\n        simplePath.boundingBox.getCenter(centerBoundingBox);\n        var scanline = [new _three.Vector2(scanlineMinX, centerBoundingBox.y), new _three.Vector2(scanlineMaxX, centerBoundingBox.y)];\n        var scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n        scanlineIntersections.sort(function (i1, i2) {\n          return i1.point.x - i2.point.x;\n        });\n        var baseIntersections = [];\n        var otherIntersections = [];\n        scanlineIntersections.forEach(function (i) {\n          if (i.identifier === simplePath.identifier) {\n            baseIntersections.push(i);\n          } else {\n            otherIntersections.push(i);\n          }\n        });\n        var firstXOfPath = baseIntersections[0].point.x; // build up the path hierarchy\n\n        var stack = [];\n        var i = 0;\n\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop();\n          } else {\n            stack.push(otherIntersections[i].identifier);\n          }\n\n          i++;\n        }\n\n        stack.push(simplePath.identifier);\n\n        if (_fillRule === 'evenodd') {\n          var isHole = stack.length % 2 === 0 ? true : false;\n          var isHoleFor = stack[stack.length - 2];\n          return {\n            identifier: simplePath.identifier,\n            isHole: isHole,\n            \"for\": isHoleFor\n          };\n        } else if (_fillRule === 'nonzero') {\n          // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n          var _isHole = true;\n          var _isHoleFor = null;\n          var lastCWValue = null;\n\n          for (var _i2 = 0; _i2 < stack.length; _i2++) {\n            var _identifier = stack[_i2];\n\n            if (_isHole) {\n              lastCWValue = allPaths[_identifier].isCW;\n              _isHole = false;\n              _isHoleFor = _identifier;\n            } else if (lastCWValue !== allPaths[_identifier].isCW) {\n              lastCWValue = allPaths[_identifier].isCW;\n              _isHole = true;\n            }\n          }\n\n          return {\n            identifier: simplePath.identifier,\n            isHole: _isHole,\n            \"for\": _isHoleFor\n          };\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n        }\n      } // check for self intersecting paths\n      // TODO\n      // check intersecting paths\n      // TODO\n      // prepare paths for hole detection\n\n\n      var identifier = 0;\n      var scanlineMinX = BIGNUMBER;\n      var scanlineMaxX = -BIGNUMBER;\n      var simplePaths = shapePath.subPaths.map(function (p) {\n        var points = p.getPoints();\n        var maxY = -BIGNUMBER;\n        var minY = BIGNUMBER;\n        var maxX = -BIGNUMBER;\n        var minX = BIGNUMBER; //points.forEach(p => p.y *= -1);\n\n        for (var i = 0; i < points.length; i++) {\n          var _p = points[i];\n\n          if (_p.y > maxY) {\n            maxY = _p.y;\n          }\n\n          if (_p.y < minY) {\n            minY = _p.y;\n          }\n\n          if (_p.x > maxX) {\n            maxX = _p.x;\n          }\n\n          if (_p.x < minX) {\n            minX = _p.x;\n          }\n        } //\n\n\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1;\n        }\n\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1;\n        }\n\n        return {\n          points: points,\n          isCW: _three.ShapeUtils.isClockWise(points),\n          identifier: identifier++,\n          boundingBox: new _three.Box2(new _three.Vector2(minX, minY), new _three.Vector2(maxX, maxY))\n        };\n      });\n      simplePaths = simplePaths.filter(function (sp) {\n        return sp.points.length > 0;\n      }); // check if path is solid or a hole\n\n      var isAHole = simplePaths.map(function (p) {\n        return isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule);\n      });\n      var shapesToReturn = [];\n      simplePaths.forEach(function (p) {\n        var amIAHole = isAHole[p.identifier];\n\n        if (!amIAHole.isHole) {\n          var shape = new _three.Shape(p.points);\n          var holes = isAHole.filter(function (h) {\n            return h.isHole && h[\"for\"] === p.identifier;\n          });\n          holes.forEach(function (h) {\n            var path = simplePaths[h.identifier];\n            shape.holes.push(new _three.Path(path.points));\n          });\n          shapesToReturn.push(shape);\n        }\n      });\n      return shapesToReturn;\n    }\n  }, {\n    key: \"getStrokeStyle\",\n    value: function getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      // Param width: Stroke width\n      // Param color: As returned by THREE.Color.getStyle()\n      // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n      // Param lineCap: One of \"round\", \"square\" or \"butt\"\n      // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n      // Returns style object\n      width = width !== undefined ? width : 1;\n      color = color !== undefined ? color : '#000';\n      lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n      lineCap = lineCap !== undefined ? lineCap : 'butt';\n      miterLimit = miterLimit !== undefined ? miterLimit : 4;\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit\n      };\n    }\n  }, {\n    key: \"pointsToStroke\",\n    value: function pointsToStroke(points, style, arcDivisions, minDistance) {\n      // Generates a stroke with some witdh around the given path.\n      // The path can be open or closed (last point equals to first point)\n      // Param points: Array of Vector2D (the path). Minimum 2 points.\n      // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n      // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n      // Param minDistance: Points closer to this distance will be merged. (Optional)\n      // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n      var vertices = [];\n      var normals = [];\n      var uvs = [];\n\n      if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null;\n      }\n\n      var geometry = new _three.BufferGeometry();\n      geometry.setAttribute('position', new _three.Float32BufferAttribute(vertices, 3));\n      geometry.setAttribute('normal', new _three.Float32BufferAttribute(normals, 3));\n      geometry.setAttribute('uv', new _three.Float32BufferAttribute(uvs, 2));\n      return geometry;\n    }\n  }, {\n    key: \"pointsToStrokeWithBuffers\",\n    value: function pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      // This function can be called to update existing arrays or buffers.\n      // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n      // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n      // Returns number of written vertices / normals / uvs pairs\n      // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n      // 'normals' and 'uvs' buffers are optional\n      var tempV2_1 = new _three.Vector2();\n      var tempV2_2 = new _three.Vector2();\n      var tempV2_3 = new _three.Vector2();\n      var tempV2_4 = new _three.Vector2();\n      var tempV2_5 = new _three.Vector2();\n      var tempV2_6 = new _three.Vector2();\n      var tempV2_7 = new _three.Vector2();\n      var lastPointL = new _three.Vector2();\n      var lastPointR = new _three.Vector2();\n      var point0L = new _three.Vector2();\n      var point0R = new _three.Vector2();\n      var currentPointL = new _three.Vector2();\n      var currentPointR = new _three.Vector2();\n      var nextPointL = new _three.Vector2();\n      var nextPointR = new _three.Vector2();\n      var innerPoint = new _three.Vector2();\n      var outerPoint = new _three.Vector2();\n      arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n      minDistance = minDistance !== undefined ? minDistance : 0.001;\n      vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points\n\n      points = removeDuplicatedPoints(points);\n      var numPoints = points.length;\n      if (numPoints < 2) return 0;\n      var isClosed = points[0].equals(points[numPoints - 1]);\n      var currentPoint;\n      var previousPoint = points[0];\n      var nextPoint;\n      var strokeWidth2 = style.strokeWidth / 2;\n      var deltaU = 1 / (numPoints - 1);\n      var u0 = 0,\n          u1;\n      var innerSideModified;\n      var joinIsOnLeftSide;\n      var isMiter;\n      var initialJoinIsOnLeftSide = false;\n      var numVertices = 0;\n      var currentCoordinate = vertexOffset * 3;\n      var currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points\n\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n      lastPointL.copy(points[0]).sub(tempV2_1);\n      lastPointR.copy(points[0]).add(tempV2_1);\n      point0L.copy(lastPointL);\n      point0R.copy(lastPointR);\n\n      for (var iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint]; // Get next point\n\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            // Skip duplicated initial point\n            nextPoint = points[1];\n          } else {\n            nextPoint = undefined;\n          }\n        } else {\n          nextPoint = points[iPoint + 1];\n        } // Normal of previous segment in tempV2_1\n\n\n        var normal1 = tempV2_1;\n        getNormal(previousPoint, currentPoint, normal1);\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n        currentPointL.copy(currentPoint).sub(tempV2_3);\n        currentPointR.copy(currentPoint).add(tempV2_3);\n        u1 = u0 + deltaU;\n        innerSideModified = false;\n\n        if (nextPoint !== undefined) {\n          // Normal of next segment in tempV2_2\n          getNormal(currentPoint, nextPoint, tempV2_2);\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n          nextPointL.copy(currentPoint).sub(tempV2_3);\n          nextPointR.copy(currentPoint).add(tempV2_3);\n          joinIsOnLeftSide = true;\n          tempV2_3.subVectors(nextPoint, previousPoint);\n\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false;\n          }\n\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n          tempV2_3.subVectors(nextPoint, currentPoint);\n          tempV2_3.normalize();\n          var dot = Math.abs(normal1.dot(tempV2_3)); // If path is straight, don't create join\n\n          if (dot !== 0) {\n            // Compute inner and outer segment intersections\n            var miterSide = strokeWidth2 / dot;\n            tempV2_3.multiplyScalar(-miterSide);\n            tempV2_4.subVectors(currentPoint, previousPoint);\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n            innerPoint.copy(tempV2_5).negate();\n            var miterLength2 = tempV2_5.length();\n            var segmentLengthPrev = tempV2_4.length();\n            tempV2_4.divideScalar(segmentLengthPrev);\n            tempV2_6.subVectors(nextPoint, currentPoint);\n            var segmentLengthNext = tempV2_6.length();\n            tempV2_6.divideScalar(segmentLengthNext); // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true;\n            }\n\n            outerPoint.copy(tempV2_5).add(currentPoint);\n            innerPoint.add(currentPoint);\n            isMiter = false;\n\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint);\n                currentPointR.copy(innerPoint);\n              } else {\n                nextPointL.copy(innerPoint);\n                currentPointL.copy(innerPoint);\n              }\n            } else {\n              // The segment triangles are generated here if there was overlapping\n              makeSegmentTriangles();\n            }\n\n            switch (style.strokeLineJoin) {\n              case 'bevel':\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                break;\n\n              case 'round':\n                // Segment triangles\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Join triangles\n\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n                }\n\n                break;\n\n              case 'miter':\n              case 'miter-clip':\n              default:\n                var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n\n                if (miterFraction < 1) {\n                  // The join miter length exceeds the miter limit\n                  if (style.strokeLineJoin !== 'miter-clip') {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                    break;\n                  } else {\n                    // Segment triangles\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Miter-clip join triangles\n\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                } else {\n                  // Miter join segment triangles\n                  if (innerSideModified) {\n                    // Optimized segment + join triangles\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(innerPoint, u1, 1);\n                    } else {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(innerPoint, u1, 0);\n                      addVertex(outerPoint, u1, 1);\n                    }\n\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint);\n                    } else {\n                      nextPointR.copy(outerPoint);\n                    }\n                  } else {\n                    // Add extra miter join triangles\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n\n                  isMiter = true;\n                }\n\n                break;\n            }\n          } else {\n            // The segment triangles are generated here when two consecutive points are collinear\n            makeSegmentTriangles();\n          }\n        } else {\n          // The segment triangles are generated here if it is the ending segment\n          makeSegmentTriangles();\n        }\n\n        if (!isClosed && iPoint === numPoints - 1) {\n          // Start line endcap\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n        } // Increment loop variables\n\n\n        u0 = u1;\n        previousPoint = currentPoint;\n        lastPointL.copy(nextPointL);\n        lastPointR.copy(nextPointR);\n      }\n\n      if (!isClosed) {\n        // Ending line endcap\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n      } else if (innerSideModified && vertices) {\n        // Modify path first segment vertices to adjust to the segments inner and outer intersections\n        var lastOuter = outerPoint;\n        var lastInner = innerPoint;\n\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint;\n          lastInner = outerPoint;\n        }\n\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3);\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3);\n            }\n          }\n        }\n      }\n\n      return numVertices; // -- End of algorithm\n      // -- Functions\n\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1);\n        return result.set(-result.y, result.x).normalize();\n      }\n\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x;\n          vertices[currentCoordinate + 1] = position.y;\n          vertices[currentCoordinate + 2] = 0;\n\n          if (normals) {\n            normals[currentCoordinate] = 0;\n            normals[currentCoordinate + 1] = 0;\n            normals[currentCoordinate + 2] = 1;\n          }\n\n          currentCoordinate += 3;\n\n          if (uvs) {\n            uvs[currentCoordinateUV] = u;\n            uvs[currentCoordinateUV + 1] = v;\n            currentCoordinateUV += 2;\n          }\n        }\n\n        numVertices += 3;\n      }\n\n      function makeCircularSector(center, p1, p2, u, v) {\n        // param p1, p2: Points in the circle arc.\n        // p1 and p2 are in clockwise direction.\n        tempV2_1.copy(p1).sub(center).normalize();\n        tempV2_2.copy(p2).sub(center).normalize();\n        var angle = Math.PI;\n        var dot = tempV2_1.dot(tempV2_2);\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n        angle /= arcDivisions;\n        tempV2_3.copy(p1);\n\n        for (var i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n          addVertex(tempV2_3, u, v);\n          addVertex(tempV2_4, u, v);\n          addVertex(center, u, 0.5);\n          tempV2_3.copy(tempV2_4);\n        }\n\n        addVertex(tempV2_4, u, v);\n        addVertex(p2, u, v);\n        addVertex(center, u, 0.5);\n      }\n\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1);\n        addVertex(lastPointL, u0, 0);\n        addVertex(currentPointL, u1, 0);\n        addVertex(lastPointR, u0, 1);\n        addVertex(currentPointL, u1, 1);\n        addVertex(currentPointR, u1, 0);\n      }\n\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n        if (innerSideModified) {\n          // Optimized segment + bevel triangles\n          if (joinIsOnLeftSide) {\n            // Path segments triangles\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1); // Bevel join triangle\n\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          } else {\n            // Path segments triangles\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1); // Bevel join triangle\n\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          }\n        } else {\n          // Bevel join triangle. The segment triangles are done in the main loop\n          if (joinIsOnLeftSide) {\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          } else {\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          }\n        }\n      }\n\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n        if (innerSideModified) {\n          if (joinIsOnLeftSide) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u0, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(nextPointL, u0, 0);\n            addVertex(innerPoint, u1, 1);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u0, 1);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 0);\n            addVertex(nextPointR, u0, 1);\n          }\n        }\n      }\n\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n        // param center: End point of the path\n        // param p1, p2: Left and right cap points\n        switch (style.strokeLineCap) {\n          case 'round':\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5);\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5);\n            }\n\n            break;\n\n          case 'square':\n            if (start) {\n              tempV2_1.subVectors(p1, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center); // Modify already existing vertices\n\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n                tempV2_4.toArray(vertices, 3 * 3);\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_3.toArray(vertices, 3 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n              }\n            } else {\n              tempV2_1.subVectors(p2, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              var vl = vertices.length; // Modify already existing vertices\n\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              } else {\n                tempV2_3.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              }\n            }\n\n            break;\n        }\n      }\n\n      function removeDuplicatedPoints(points) {\n        // Creates a new array if necessary with duplicated points removed.\n        // This does not remove duplicated initial and ending points of a closed path.\n        var dupPoints = false;\n\n        for (var i = 1, n = points.length - 1; i < n; i++) {\n          if (points[i].distanceTo(points[i + 1]) < minDistance) {\n            dupPoints = true;\n            break;\n          }\n        }\n\n        if (!dupPoints) return points;\n        var newPoints = [];\n        newPoints.push(points[0]);\n\n        for (var _i3 = 1, _n = points.length - 1; _i3 < _n; _i3++) {\n          if (points[_i3].distanceTo(points[_i3 + 1]) >= minDistance) {\n            newPoints.push(points[_i3]);\n          }\n        }\n\n        newPoints.push(points[points.length - 1]);\n        return newPoints;\n      }\n    }\n  }]);\n\n  return SVGLoader;\n}(_three.Loader);\n\nexports.SVGLoader = SVGLoader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["autoClose","partial","px","SVGLoader","pt","isCW","xml","prototype","xRadius","LEFT","points","key","x","__esModule","ORIGIN","mm","paths","BEHIND","BEYOND","aX","configurable","strokeMiterLimit","style","value","aY","enumerable","boundingBox","userData","identifier","fill","strokeWidth","writable","strokeOpacity","isHole","yRadius","t","RIGHT","y","defaultUnit","__proto__","fillOpacity","strokeColor","strokeLineJoin","DESTINATION","pc","defaultDPI","BETWEEN","strokeLineCap","point","cm","node","constructor"]],"~:compiled-at",1630917515910,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$SVGLoader.js\",\n\"lineCount\":83,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/SVGLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$SVGLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.SVGLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar SVGLoader =\\n/*#__PURE__*/\\nfunction (_Loader) {\\n  _inherits(SVGLoader, _Loader);\\n\\n  function SVGLoader(manager) {\\n    var _this;\\n\\n    _classCallCheck(this, SVGLoader);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SVGLoader).call(this, manager)); // Default dots per inch\\n\\n    _this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\\n\\n    _this.defaultUnit = 'px';\\n    return _this;\\n  }\\n\\n  _createClass(SVGLoader, [{\\n    key: \\\"load\\\",\\n    value: function load(url, onLoad, onProgress, onError) {\\n      var scope = this;\\n      var loader = new _three.FileLoader(scope.manager);\\n      loader.setPath(scope.path);\\n      loader.setRequestHeader(scope.requestHeader);\\n      loader.setWithCredentials(scope.withCredentials);\\n      loader.load(url, function (text) {\\n        try {\\n          onLoad(scope.parse(text));\\n        } catch (e) {\\n          if (onError) {\\n            onError(e);\\n          } else {\\n            console.error(e);\\n          }\\n\\n          scope.manager.itemError(url);\\n        }\\n      }, onProgress, onError);\\n    }\\n  }, {\\n    key: \\\"parse\\\",\\n    value: function parse(text) {\\n      var scope = this;\\n\\n      function parseNode(node, style) {\\n        if (node.nodeType !== 1) return;\\n        var transform = getNodeTransform(node);\\n        var traverseChildNodes = true;\\n        var path = null;\\n\\n        switch (node.nodeName) {\\n          case 'svg':\\n            break;\\n\\n          case 'style':\\n            parseCSSStylesheet(node);\\n            break;\\n\\n          case 'g':\\n            style = parseStyle(node, style);\\n            break;\\n\\n          case 'path':\\n            style = parseStyle(node, style);\\n            if (node.hasAttribute('d')) path = parsePathNode(node);\\n            break;\\n\\n          case 'rect':\\n            style = parseStyle(node, style);\\n            path = parseRectNode(node);\\n            break;\\n\\n          case 'polygon':\\n            style = parseStyle(node, style);\\n            path = parsePolygonNode(node);\\n            break;\\n\\n          case 'polyline':\\n            style = parseStyle(node, style);\\n            path = parsePolylineNode(node);\\n            break;\\n\\n          case 'circle':\\n            style = parseStyle(node, style);\\n            path = parseCircleNode(node);\\n            break;\\n\\n          case 'ellipse':\\n            style = parseStyle(node, style);\\n            path = parseEllipseNode(node);\\n            break;\\n\\n          case 'line':\\n            style = parseStyle(node, style);\\n            path = parseLineNode(node);\\n            break;\\n\\n          case 'defs':\\n            traverseChildNodes = false;\\n            break;\\n\\n          case 'use':\\n            style = parseStyle(node, style);\\n            var usedNodeId = node.href.baseVal.substring(1);\\n            var usedNode = node.viewportElement.getElementById(usedNodeId);\\n\\n            if (usedNode) {\\n              parseNode(usedNode, style);\\n            } else {\\n              console.warn(\\\"SVGLoader: 'use node' references non-existent node id: \\\" + usedNodeId);\\n            }\\n\\n            break;\\n        }\\n\\n        if (path) {\\n          if (style.fill !== undefined && style.fill !== 'none') {\\n            path.color.setStyle(style.fill);\\n          }\\n\\n          transformPath(path, currentTransform);\\n          paths.push(path);\\n          path.userData = {\\n            node: node,\\n            style: style\\n          };\\n        }\\n\\n        if (traverseChildNodes) {\\n          var nodes = node.childNodes;\\n\\n          for (var i = 0; i < nodes.length; i++) {\\n            parseNode(nodes[i], style);\\n          }\\n        }\\n\\n        if (transform) {\\n          transformStack.pop();\\n\\n          if (transformStack.length > 0) {\\n            currentTransform.copy(transformStack[transformStack.length - 1]);\\n          } else {\\n            currentTransform.identity();\\n          }\\n        }\\n      }\\n\\n      function parsePathNode(node) {\\n        var path = new _three.ShapePath();\\n        var point = new _three.Vector2();\\n        var control = new _three.Vector2();\\n        var firstPoint = new _three.Vector2();\\n        var isFirstPoint = true;\\n        var doSetFirstPoint = false;\\n        var d = node.getAttribute('d'); // console.log( d );\\n\\n        var commands = d.match(/[a-df-z][^a-df-z]*/gi);\\n\\n        for (var i = 0, l = commands.length; i < l; i++) {\\n          var command = commands[i];\\n          var type = command.charAt(0);\\n\\n          var _data = command.substr(1).trim();\\n\\n          if (isFirstPoint === true) {\\n            doSetFirstPoint = true;\\n            isFirstPoint = false;\\n          }\\n\\n          var numbers = void 0;\\n\\n          switch (type) {\\n            case 'M':\\n              numbers = parseFloats(_data);\\n\\n              for (var j = 0, jl = numbers.length; j < jl; j += 2) {\\n                point.x = numbers[j + 0];\\n                point.y = numbers[j + 1];\\n                control.x = point.x;\\n                control.y = point.y;\\n\\n                if (j === 0) {\\n                  path.moveTo(point.x, point.y);\\n                } else {\\n                  path.lineTo(point.x, point.y);\\n                }\\n\\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'H':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j = 0, _jl = numbers.length; _j < _jl; _j++) {\\n                point.x = numbers[_j];\\n                control.x = point.x;\\n                control.y = point.y;\\n                path.lineTo(point.x, point.y);\\n                if (_j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'V':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j2 = 0, _jl2 = numbers.length; _j2 < _jl2; _j2++) {\\n                point.y = numbers[_j2];\\n                control.x = point.x;\\n                control.y = point.y;\\n                path.lineTo(point.x, point.y);\\n                if (_j2 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'L':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j3 = 0, _jl3 = numbers.length; _j3 < _jl3; _j3 += 2) {\\n                point.x = numbers[_j3 + 0];\\n                point.y = numbers[_j3 + 1];\\n                control.x = point.x;\\n                control.y = point.y;\\n                path.lineTo(point.x, point.y);\\n                if (_j3 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'C':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j4 = 0, _jl4 = numbers.length; _j4 < _jl4; _j4 += 6) {\\n                path.bezierCurveTo(numbers[_j4 + 0], numbers[_j4 + 1], numbers[_j4 + 2], numbers[_j4 + 3], numbers[_j4 + 4], numbers[_j4 + 5]);\\n                control.x = numbers[_j4 + 2];\\n                control.y = numbers[_j4 + 3];\\n                point.x = numbers[_j4 + 4];\\n                point.y = numbers[_j4 + 5];\\n                if (_j4 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'S':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j5 = 0, _jl5 = numbers.length; _j5 < _jl5; _j5 += 4) {\\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[_j5 + 0], numbers[_j5 + 1], numbers[_j5 + 2], numbers[_j5 + 3]);\\n                control.x = numbers[_j5 + 0];\\n                control.y = numbers[_j5 + 1];\\n                point.x = numbers[_j5 + 2];\\n                point.y = numbers[_j5 + 3];\\n                if (_j5 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'Q':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j6 = 0, _jl6 = numbers.length; _j6 < _jl6; _j6 += 4) {\\n                path.quadraticCurveTo(numbers[_j6 + 0], numbers[_j6 + 1], numbers[_j6 + 2], numbers[_j6 + 3]);\\n                control.x = numbers[_j6 + 0];\\n                control.y = numbers[_j6 + 1];\\n                point.x = numbers[_j6 + 2];\\n                point.y = numbers[_j6 + 3];\\n                if (_j6 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'T':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j7 = 0, _jl7 = numbers.length; _j7 < _jl7; _j7 += 2) {\\n                var rx = getReflection(point.x, control.x);\\n                var ry = getReflection(point.y, control.y);\\n                path.quadraticCurveTo(rx, ry, numbers[_j7 + 0], numbers[_j7 + 1]);\\n                control.x = rx;\\n                control.y = ry;\\n                point.x = numbers[_j7 + 0];\\n                point.y = numbers[_j7 + 1];\\n                if (_j7 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'A':\\n              numbers = parseFloats(_data, [3, 4], 7);\\n\\n              for (var _j8 = 0, _jl8 = numbers.length; _j8 < _jl8; _j8 += 7) {\\n                // skip command if start point == end point\\n                if (numbers[_j8 + 5] == point.x && numbers[_j8 + 6] == point.y) continue;\\n                var start = point.clone();\\n                point.x = numbers[_j8 + 5];\\n                point.y = numbers[_j8 + 6];\\n                control.x = point.x;\\n                control.y = point.y;\\n                parseArcCommand(path, numbers[_j8], numbers[_j8 + 1], numbers[_j8 + 2], numbers[_j8 + 3], numbers[_j8 + 4], start, point);\\n                if (_j8 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'm':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j9 = 0, _jl9 = numbers.length; _j9 < _jl9; _j9 += 2) {\\n                point.x += numbers[_j9 + 0];\\n                point.y += numbers[_j9 + 1];\\n                control.x = point.x;\\n                control.y = point.y;\\n\\n                if (_j9 === 0) {\\n                  path.moveTo(point.x, point.y);\\n                } else {\\n                  path.lineTo(point.x, point.y);\\n                }\\n\\n                if (_j9 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'h':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j10 = 0, _jl10 = numbers.length; _j10 < _jl10; _j10++) {\\n                point.x += numbers[_j10];\\n                control.x = point.x;\\n                control.y = point.y;\\n                path.lineTo(point.x, point.y);\\n                if (_j10 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'v':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j11 = 0, _jl11 = numbers.length; _j11 < _jl11; _j11++) {\\n                point.y += numbers[_j11];\\n                control.x = point.x;\\n                control.y = point.y;\\n                path.lineTo(point.x, point.y);\\n                if (_j11 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'l':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j12 = 0, _jl12 = numbers.length; _j12 < _jl12; _j12 += 2) {\\n                point.x += numbers[_j12 + 0];\\n                point.y += numbers[_j12 + 1];\\n                control.x = point.x;\\n                control.y = point.y;\\n                path.lineTo(point.x, point.y);\\n                if (_j12 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'c':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j13 = 0, _jl13 = numbers.length; _j13 < _jl13; _j13 += 6) {\\n                path.bezierCurveTo(point.x + numbers[_j13 + 0], point.y + numbers[_j13 + 1], point.x + numbers[_j13 + 2], point.y + numbers[_j13 + 3], point.x + numbers[_j13 + 4], point.y + numbers[_j13 + 5]);\\n                control.x = point.x + numbers[_j13 + 2];\\n                control.y = point.y + numbers[_j13 + 3];\\n                point.x += numbers[_j13 + 4];\\n                point.y += numbers[_j13 + 5];\\n                if (_j13 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 's':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j14 = 0, _jl14 = numbers.length; _j14 < _jl14; _j14 += 4) {\\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[_j14 + 0], point.y + numbers[_j14 + 1], point.x + numbers[_j14 + 2], point.y + numbers[_j14 + 3]);\\n                control.x = point.x + numbers[_j14 + 0];\\n                control.y = point.y + numbers[_j14 + 1];\\n                point.x += numbers[_j14 + 2];\\n                point.y += numbers[_j14 + 3];\\n                if (_j14 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'q':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j15 = 0, _jl15 = numbers.length; _j15 < _jl15; _j15 += 4) {\\n                path.quadraticCurveTo(point.x + numbers[_j15 + 0], point.y + numbers[_j15 + 1], point.x + numbers[_j15 + 2], point.y + numbers[_j15 + 3]);\\n                control.x = point.x + numbers[_j15 + 0];\\n                control.y = point.y + numbers[_j15 + 1];\\n                point.x += numbers[_j15 + 2];\\n                point.y += numbers[_j15 + 3];\\n                if (_j15 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 't':\\n              numbers = parseFloats(_data);\\n\\n              for (var _j16 = 0, _jl16 = numbers.length; _j16 < _jl16; _j16 += 2) {\\n                var _rx = getReflection(point.x, control.x);\\n\\n                var _ry = getReflection(point.y, control.y);\\n\\n                path.quadraticCurveTo(_rx, _ry, point.x + numbers[_j16 + 0], point.y + numbers[_j16 + 1]);\\n                control.x = _rx;\\n                control.y = _ry;\\n                point.x = point.x + numbers[_j16 + 0];\\n                point.y = point.y + numbers[_j16 + 1];\\n                if (_j16 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'a':\\n              numbers = parseFloats(_data, [3, 4], 7);\\n\\n              for (var _j17 = 0, _jl17 = numbers.length; _j17 < _jl17; _j17 += 7) {\\n                // skip command if no displacement\\n                if (numbers[_j17 + 5] == 0 && numbers[_j17 + 6] == 0) continue;\\n\\n                var _start = point.clone();\\n\\n                point.x += numbers[_j17 + 5];\\n                point.y += numbers[_j17 + 6];\\n                control.x = point.x;\\n                control.y = point.y;\\n                parseArcCommand(path, numbers[_j17], numbers[_j17 + 1], numbers[_j17 + 2], numbers[_j17 + 3], numbers[_j17 + 4], _start, point);\\n                if (_j17 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\\n              }\\n\\n              break;\\n\\n            case 'Z':\\n            case 'z':\\n              path.currentPath.autoClose = true;\\n\\n              if (path.currentPath.curves.length > 0) {\\n                // Reset point to beginning of Path\\n                point.copy(firstPoint);\\n                path.currentPath.currentPoint.copy(point);\\n                isFirstPoint = true;\\n              }\\n\\n              break;\\n\\n            default:\\n              console.warn(command);\\n          } // console.log( type, parseFloats( data ), parseFloats( data ).length  )\\n\\n\\n          doSetFirstPoint = false;\\n        }\\n\\n        return path;\\n      }\\n\\n      function parseCSSStylesheet(node) {\\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\\n\\n        for (var i = 0; i < node.sheet.cssRules.length; i++) {\\n          var stylesheet = node.sheet.cssRules[i];\\n          if (stylesheet.type !== 1) continue;\\n          var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(function (i) {\\n            return i.trim();\\n          });\\n\\n          for (var j = 0; j < selectorList.length; j++) {\\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, stylesheet.style);\\n          }\\n        }\\n      }\\n      /**\\n       * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\\n       * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\\n       * From\\n       * rx ry x-axis-rotation large-arc-flag sweep-flag x y\\n       * To\\n       * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\\n       */\\n\\n\\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\\n        if (rx == 0 || ry == 0) {\\n          // draw a line if either of the radii == 0\\n          path.lineTo(end.x, end.y);\\n          return;\\n        }\\n\\n        x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive\\n\\n        rx = Math.abs(rx);\\n        ry = Math.abs(ry); // Compute (x1', y1')\\n\\n        var dx2 = (start.x - end.x) / 2.0;\\n        var dy2 = (start.y - end.y) / 2.0;\\n        var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\\n        var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2; // Compute (cx', cy')\\n\\n        var rxs = rx * rx;\\n        var rys = ry * ry;\\n        var x1ps = x1p * x1p;\\n        var y1ps = y1p * y1p; // Ensure radii are large enough\\n\\n        var cr = x1ps / rxs + y1ps / rys;\\n\\n        if (cr > 1) {\\n          // scale up rx,ry equally so cr == 1\\n          var s = Math.sqrt(cr);\\n          rx = s * rx;\\n          ry = s * ry;\\n          rxs = rx * rx;\\n          rys = ry * ry;\\n        }\\n\\n        var dq = rxs * y1ps + rys * x1ps;\\n        var pq = (rxs * rys - dq) / dq;\\n        var q = Math.sqrt(Math.max(0, pq));\\n        if (large_arc_flag === sweep_flag) q = -q;\\n        var cxp = q * rx * y1p / ry;\\n        var cyp = -q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy')\\n\\n        var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\\n        var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2; // Step 4: Compute \\u03b81 and \\u0394\\u03b8\\n\\n        var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\\n        var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\\n      }\\n\\n      function svgAngle(ux, uy, vx, vy) {\\n        var dot = ux * vx + uy * vy;\\n        var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\\n        var ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\\n\\n        if (ux * vy - uy * vx < 0) ang = -ang;\\n        return ang;\\n      }\\n      /*\\n       * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\\n       * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\\n       */\\n\\n\\n      function parseRectNode(node) {\\n        var x = parseFloatWithUnits(node.getAttribute('x') || 0);\\n        var y = parseFloatWithUnits(node.getAttribute('y') || 0);\\n        var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\\n        var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\\n        var w = parseFloatWithUnits(node.getAttribute('width'));\\n        var h = parseFloatWithUnits(node.getAttribute('height'));\\n        var path = new _three.ShapePath();\\n        path.moveTo(x + 2 * rx, y);\\n        path.lineTo(x + w - 2 * rx, y);\\n        if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\\n        path.lineTo(x + w, y + h - 2 * ry);\\n        if (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\\n        path.lineTo(x + 2 * rx, y + h);\\n\\n        if (rx !== 0 || ry !== 0) {\\n          path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\\n        }\\n\\n        path.lineTo(x, y + 2 * ry);\\n\\n        if (rx !== 0 || ry !== 0) {\\n          path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\\n        }\\n\\n        return path;\\n      }\\n\\n      function parsePolygonNode(node) {\\n        function iterator(match, a, b) {\\n          var x = parseFloatWithUnits(a);\\n          var y = parseFloatWithUnits(b);\\n\\n          if (index === 0) {\\n            path.moveTo(x, y);\\n          } else {\\n            path.lineTo(x, y);\\n          }\\n\\n          index++;\\n        }\\n\\n        var regex = /(-?[\\\\d\\\\.?]+)[,|\\\\s](-?[\\\\d\\\\.?]+)/g;\\n        var path = new _three.ShapePath();\\n        var index = 0;\\n        node.getAttribute('points').replace(regex, iterator);\\n        path.currentPath.autoClose = true;\\n        return path;\\n      }\\n\\n      function parsePolylineNode(node) {\\n        function iterator(match, a, b) {\\n          var x = parseFloatWithUnits(a);\\n          var y = parseFloatWithUnits(b);\\n\\n          if (index === 0) {\\n            path.moveTo(x, y);\\n          } else {\\n            path.lineTo(x, y);\\n          }\\n\\n          index++;\\n        }\\n\\n        var regex = /(-?[\\\\d\\\\.?]+)[,|\\\\s](-?[\\\\d\\\\.?]+)/g;\\n        var path = new _three.ShapePath();\\n        var index = 0;\\n        node.getAttribute('points').replace(regex, iterator);\\n        path.currentPath.autoClose = false;\\n        return path;\\n      }\\n\\n      function parseCircleNode(node) {\\n        var x = parseFloatWithUnits(node.getAttribute('cx') || 0);\\n        var y = parseFloatWithUnits(node.getAttribute('cy') || 0);\\n        var r = parseFloatWithUnits(node.getAttribute('r') || 0);\\n        var subpath = new _three.Path();\\n        subpath.absarc(x, y, r, 0, Math.PI * 2);\\n        var path = new _three.ShapePath();\\n        path.subPaths.push(subpath);\\n        return path;\\n      }\\n\\n      function parseEllipseNode(node) {\\n        var x = parseFloatWithUnits(node.getAttribute('cx') || 0);\\n        var y = parseFloatWithUnits(node.getAttribute('cy') || 0);\\n        var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\\n        var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\\n        var subpath = new _three.Path();\\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\\n        var path = new _three.ShapePath();\\n        path.subPaths.push(subpath);\\n        return path;\\n      }\\n\\n      function parseLineNode(node) {\\n        var x1 = parseFloatWithUnits(node.getAttribute('x1') || 0);\\n        var y1 = parseFloatWithUnits(node.getAttribute('y1') || 0);\\n        var x2 = parseFloatWithUnits(node.getAttribute('x2') || 0);\\n        var y2 = parseFloatWithUnits(node.getAttribute('y2') || 0);\\n        var path = new _three.ShapePath();\\n        path.moveTo(x1, y1);\\n        path.lineTo(x2, y2);\\n        path.currentPath.autoClose = false;\\n        return path;\\n      } //\\n\\n\\n      function parseStyle(node, style) {\\n        style = Object.assign({}, style); // clone style\\n\\n        var stylesheetStyles = {};\\n\\n        if (node.hasAttribute('class')) {\\n          var classSelectors = node.getAttribute('class').split(/\\\\s/).filter(Boolean).map(function (i) {\\n            return i.trim();\\n          });\\n\\n          for (var i = 0; i < classSelectors.length; i++) {\\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]]);\\n          }\\n        }\\n\\n        if (node.hasAttribute('id')) {\\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')]);\\n        }\\n\\n        function addStyle(svgName, jsName, adjustFunction) {\\n          if (adjustFunction === undefined) {\\n            adjustFunction = function copy(v) {\\n              if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.');\\n              return v;\\n            };\\n          }\\n\\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\\n          if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName]);\\n        }\\n\\n        function clamp(v) {\\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\\n        }\\n\\n        function positive(v) {\\n          return Math.max(0, parseFloatWithUnits(v));\\n        }\\n\\n        addStyle('fill', 'fill');\\n        addStyle('fill-opacity', 'fillOpacity', clamp);\\n        addStyle('opacity', 'opacity', clamp);\\n        addStyle('stroke', 'stroke');\\n        addStyle('stroke-opacity', 'strokeOpacity', clamp);\\n        addStyle('stroke-width', 'strokeWidth', positive);\\n        addStyle('stroke-linejoin', 'strokeLineJoin');\\n        addStyle('stroke-linecap', 'strokeLineCap');\\n        addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\\n        addStyle('visibility', 'visibility');\\n        return style;\\n      } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\\n\\n\\n      function getReflection(a, b) {\\n        return a - (b - a);\\n      } // from https://github.com/ppvg/svg-numbers (MIT License)\\n\\n\\n      function parseFloats(input, flags, stride) {\\n        if (typeof input !== 'string') {\\n          throw new TypeError('Invalid input: ' + _typeof(input));\\n        } // Character groups\\n\\n\\n        var RE = {\\n          SEPARATOR: /[ \\\\t\\\\r\\\\n\\\\,.\\\\-+]/,\\n          WHITESPACE: /[ \\\\t\\\\r\\\\n]/,\\n          DIGIT: /[\\\\d]/,\\n          SIGN: /[-+]/,\\n          POINT: /\\\\./,\\n          COMMA: /,/,\\n          EXP: /e/i,\\n          FLAGS: /[01]/\\n        }; // States\\n\\n        var SEP = 0;\\n        var INT = 1;\\n        var FLOAT = 2;\\n        var EXP = 3;\\n        var state = SEP;\\n        var seenComma = true;\\n        var number = '',\\n            exponent = '';\\n        var result = [];\\n\\n        function throwSyntaxError(current, i, partial) {\\n          var error = new SyntaxError('Unexpected character \\\"' + current + '\\\" at index ' + i + '.');\\n          error.partial = partial;\\n          throw error;\\n        }\\n\\n        function newNumber() {\\n          if (number !== '') {\\n            if (exponent === '') result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\\n          }\\n\\n          number = '';\\n          exponent = '';\\n        }\\n\\n        var current;\\n        var length = input.length;\\n\\n        for (var i = 0; i < length; i++) {\\n          current = input[i]; // check for flags\\n\\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\\n            state = INT;\\n            number = current;\\n            newNumber();\\n            continue;\\n          } // parse until next number\\n\\n\\n          if (state === SEP) {\\n            // eat whitespace\\n            if (RE.WHITESPACE.test(current)) {\\n              continue;\\n            } // start new number\\n\\n\\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\\n              state = INT;\\n              number = current;\\n              continue;\\n            }\\n\\n            if (RE.POINT.test(current)) {\\n              state = FLOAT;\\n              number = current;\\n              continue;\\n            } // throw on double commas (e.g. \\\"1, , 2\\\")\\n\\n\\n            if (RE.COMMA.test(current)) {\\n              if (seenComma) {\\n                throwSyntaxError(current, i, result);\\n              }\\n\\n              seenComma = true;\\n            }\\n          } // parse integer part\\n\\n\\n          if (state === INT) {\\n            if (RE.DIGIT.test(current)) {\\n              number += current;\\n              continue;\\n            }\\n\\n            if (RE.POINT.test(current)) {\\n              number += current;\\n              state = FLOAT;\\n              continue;\\n            }\\n\\n            if (RE.EXP.test(current)) {\\n              state = EXP;\\n              continue;\\n            } // throw on double signs (\\\"-+1\\\"), but not on sign as separator (\\\"-1-2\\\")\\n\\n\\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\\n              throwSyntaxError(current, i, result);\\n            }\\n          } // parse decimal part\\n\\n\\n          if (state === FLOAT) {\\n            if (RE.DIGIT.test(current)) {\\n              number += current;\\n              continue;\\n            }\\n\\n            if (RE.EXP.test(current)) {\\n              state = EXP;\\n              continue;\\n            } // throw on double decimal points (e.g. \\\"1..2\\\")\\n\\n\\n            if (RE.POINT.test(current) && number[number.length - 1] === '.') {\\n              throwSyntaxError(current, i, result);\\n            }\\n          } // parse exponent part\\n\\n\\n          if (state === EXP) {\\n            if (RE.DIGIT.test(current)) {\\n              exponent += current;\\n              continue;\\n            }\\n\\n            if (RE.SIGN.test(current)) {\\n              if (exponent === '') {\\n                exponent += current;\\n                continue;\\n              }\\n\\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\\n                throwSyntaxError(current, i, result);\\n              }\\n            }\\n          } // end of number\\n\\n\\n          if (RE.WHITESPACE.test(current)) {\\n            newNumber();\\n            state = SEP;\\n            seenComma = false;\\n          } else if (RE.COMMA.test(current)) {\\n            newNumber();\\n            state = SEP;\\n            seenComma = true;\\n          } else if (RE.SIGN.test(current)) {\\n            newNumber();\\n            state = INT;\\n            number = current;\\n          } else if (RE.POINT.test(current)) {\\n            newNumber();\\n            state = FLOAT;\\n            number = current;\\n          } else {\\n            throwSyntaxError(current, i, result);\\n          }\\n        } // add the last number found (if any)\\n\\n\\n        newNumber();\\n        return result;\\n      } // Units\\n\\n\\n      var units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\\n\\n      var unitConversion = {\\n        mm: {\\n          mm: 1,\\n          cm: 0.1,\\n          \\\"in\\\": 1 / 25.4,\\n          pt: 72 / 25.4,\\n          pc: 6 / 25.4,\\n          px: -1\\n        },\\n        cm: {\\n          mm: 10,\\n          cm: 1,\\n          \\\"in\\\": 1 / 2.54,\\n          pt: 72 / 2.54,\\n          pc: 6 / 2.54,\\n          px: -1\\n        },\\n        \\\"in\\\": {\\n          mm: 25.4,\\n          cm: 2.54,\\n          \\\"in\\\": 1,\\n          pt: 72,\\n          pc: 6,\\n          px: -1\\n        },\\n        pt: {\\n          mm: 25.4 / 72,\\n          cm: 2.54 / 72,\\n          \\\"in\\\": 1 / 72,\\n          pt: 1,\\n          pc: 6 / 72,\\n          px: -1\\n        },\\n        pc: {\\n          mm: 25.4 / 6,\\n          cm: 2.54 / 6,\\n          \\\"in\\\": 1 / 6,\\n          pt: 72 / 6,\\n          pc: 1,\\n          px: -1\\n        },\\n        px: {\\n          px: 1\\n        }\\n      };\\n\\n      function parseFloatWithUnits(string) {\\n        var theUnit = 'px';\\n\\n        if (typeof string === 'string' || string instanceof String) {\\n          for (var i = 0, n = units.length; i < n; i++) {\\n            var u = units[i];\\n\\n            if (string.endsWith(u)) {\\n              theUnit = u;\\n              string = string.substring(0, string.length - u.length);\\n              break;\\n            }\\n          }\\n        }\\n\\n        var scale = undefined;\\n\\n        if (theUnit === 'px' && scope.defaultUnit !== 'px') {\\n          // Conversion scale from  pixels to inches, then to default units\\n          scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\\n        } else {\\n          scale = unitConversion[theUnit][scope.defaultUnit];\\n\\n          if (scale < 0) {\\n            // Conversion scale to pixels\\n            scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\\n          }\\n        }\\n\\n        return scale * parseFloat(string);\\n      } // Transforms\\n\\n\\n      function getNodeTransform(node) {\\n        if (!(node.hasAttribute('transform') || node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))) {\\n          return null;\\n        }\\n\\n        var transform = parseNodeTransform(node);\\n\\n        if (transformStack.length > 0) {\\n          transform.premultiply(transformStack[transformStack.length - 1]);\\n        }\\n\\n        currentTransform.copy(transform);\\n        transformStack.push(transform);\\n        return transform;\\n      }\\n\\n      function parseNodeTransform(node) {\\n        var transform = new _three.Matrix3();\\n        var currentTransform = tempTransform0;\\n\\n        if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\\n          var tx = parseFloatWithUnits(node.getAttribute('x'));\\n          var ty = parseFloatWithUnits(node.getAttribute('y'));\\n          transform.translate(tx, ty);\\n        }\\n\\n        if (node.hasAttribute('transform')) {\\n          var transformsTexts = node.getAttribute('transform').split(')');\\n\\n          for (var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\\n            var transformText = transformsTexts[tIndex].trim();\\n            if (transformText === '') continue;\\n            var openParPos = transformText.indexOf('(');\\n            var closeParPos = transformText.length;\\n\\n            if (openParPos > 0 && openParPos < closeParPos) {\\n              var transformType = transformText.substr(0, openParPos);\\n              var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\\n              currentTransform.identity();\\n\\n              switch (transformType) {\\n                case 'translate':\\n                  if (array.length >= 1) {\\n                    var _tx = array[0];\\n                    var _ty = _tx;\\n\\n                    if (array.length >= 2) {\\n                      _ty = array[1];\\n                    }\\n\\n                    currentTransform.translate(_tx, _ty);\\n                  }\\n\\n                  break;\\n\\n                case 'rotate':\\n                  if (array.length >= 1) {\\n                    var angle = 0;\\n                    var cx = 0;\\n                    var cy = 0; // Angle\\n\\n                    angle = -array[0] * Math.PI / 180;\\n\\n                    if (array.length >= 3) {\\n                      // Center x, y\\n                      cx = array[1];\\n                      cy = array[2];\\n                    } // Rotate around center (cx, cy)\\n\\n\\n                    tempTransform1.identity().translate(-cx, -cy);\\n                    tempTransform2.identity().rotate(angle);\\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\\n                    tempTransform1.identity().translate(cx, cy);\\n                    currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\\n                  }\\n\\n                  break;\\n\\n                case 'scale':\\n                  if (array.length >= 1) {\\n                    var scaleX = array[0];\\n                    var scaleY = scaleX;\\n\\n                    if (array.length >= 2) {\\n                      scaleY = array[1];\\n                    }\\n\\n                    currentTransform.scale(scaleX, scaleY);\\n                  }\\n\\n                  break;\\n\\n                case 'skewX':\\n                  if (array.length === 1) {\\n                    currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\\n                  }\\n\\n                  break;\\n\\n                case 'skewY':\\n                  if (array.length === 1) {\\n                    currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\\n                  }\\n\\n                  break;\\n\\n                case 'matrix':\\n                  if (array.length === 6) {\\n                    currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\\n                  }\\n\\n                  break;\\n              }\\n            }\\n\\n            transform.premultiply(currentTransform);\\n          }\\n        }\\n\\n        return transform;\\n      }\\n\\n      function transformPath(path, m) {\\n        function transfVec2(v2) {\\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\\n          v2.set(tempV3.x, tempV3.y);\\n        }\\n\\n        var isRotated = isTransformRotated(m);\\n        var subPaths = path.subPaths;\\n\\n        for (var i = 0, n = subPaths.length; i < n; i++) {\\n          var subPath = subPaths[i];\\n          var curves = subPath.curves;\\n\\n          for (var j = 0; j < curves.length; j++) {\\n            var curve = curves[j];\\n\\n            if (curve.isLineCurve) {\\n              transfVec2(curve.v1);\\n              transfVec2(curve.v2);\\n            } else if (curve.isCubicBezierCurve) {\\n              transfVec2(curve.v0);\\n              transfVec2(curve.v1);\\n              transfVec2(curve.v2);\\n              transfVec2(curve.v3);\\n            } else if (curve.isQuadraticBezierCurve) {\\n              transfVec2(curve.v0);\\n              transfVec2(curve.v1);\\n              transfVec2(curve.v2);\\n            } else if (curve.isEllipseCurve) {\\n              if (isRotated) {\\n                console.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\\n              }\\n\\n              tempV2.set(curve.aX, curve.aY);\\n              transfVec2(tempV2);\\n              curve.aX = tempV2.x;\\n              curve.aY = tempV2.y;\\n              curve.xRadius *= getTransformScaleX(m);\\n              curve.yRadius *= getTransformScaleY(m);\\n            }\\n          }\\n        }\\n      }\\n\\n      function isTransformRotated(m) {\\n        return m.elements[1] !== 0 || m.elements[3] !== 0;\\n      }\\n\\n      function getTransformScaleX(m) {\\n        var te = m.elements;\\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\\n      }\\n\\n      function getTransformScaleY(m) {\\n        var te = m.elements;\\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\\n      } //\\n\\n\\n      var paths = [];\\n      var stylesheets = {};\\n      var transformStack = [];\\n      var tempTransform0 = new _three.Matrix3();\\n      var tempTransform1 = new _three.Matrix3();\\n      var tempTransform2 = new _three.Matrix3();\\n      var tempTransform3 = new _three.Matrix3();\\n      var tempV2 = new _three.Vector2();\\n      var tempV3 = new _three.Vector3();\\n      var currentTransform = new _three.Matrix3();\\n      var xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\\n\\n      parseNode(xml.documentElement, {\\n        fill: '#000',\\n        fillOpacity: 1,\\n        strokeOpacity: 1,\\n        strokeWidth: 1,\\n        strokeLineJoin: 'miter',\\n        strokeLineCap: 'butt',\\n        strokeMiterLimit: 4\\n      });\\n      var data = {\\n        paths: paths,\\n        xml: xml.documentElement\\n      }; // console.log( paths );\\n\\n      return data;\\n    }\\n  }], [{\\n    key: \\\"createShapes\\\",\\n    value: function createShapes(shapePath) {\\n      // Param shapePath: a shapepath as returned by the parse function of this class\\n      // Returns Shape object\\n      var BIGNUMBER = 999999999;\\n      var IntersectionLocationType = {\\n        ORIGIN: 0,\\n        DESTINATION: 1,\\n        BETWEEN: 2,\\n        LEFT: 3,\\n        RIGHT: 4,\\n        BEHIND: 5,\\n        BEYOND: 6\\n      };\\n      var classifyResult = {\\n        loc: IntersectionLocationType.ORIGIN,\\n        t: 0\\n      };\\n\\n      function findEdgeIntersection(a0, a1, b0, b1) {\\n        var x1 = a0.x;\\n        var x2 = a1.x;\\n        var x3 = b0.x;\\n        var x4 = b1.x;\\n        var y1 = a0.y;\\n        var y2 = a1.y;\\n        var y3 = b0.y;\\n        var y4 = b1.y;\\n        var nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\\n        var nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\\n        var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\\n        var t1 = nom1 / denom;\\n        var t2 = nom2 / denom;\\n\\n        if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\\n          //1. lines are parallel or edges don't intersect\\n          return null;\\n        } else if (nom1 === 0 && denom === 0) {\\n          //2. lines are colinear\\n          //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\\n          for (var i = 0; i < 2; i++) {\\n            classifyPoint(i === 0 ? b0 : b1, a0, a1); //find position of this endpoints relatively to edge1\\n\\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\\n              var point = i === 0 ? b0 : b1;\\n              return {\\n                x: point.x,\\n                y: point.y,\\n                t: classifyResult.t\\n              };\\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\\n              var x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\\n              var y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\\n              return {\\n                x: x,\\n                y: y,\\n                t: classifyResult.t\\n              };\\n            }\\n          }\\n\\n          return null;\\n        } else {\\n          //3. edges intersect\\n          for (var _i = 0; _i < 2; _i++) {\\n            classifyPoint(_i === 0 ? b0 : b1, a0, a1);\\n\\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\\n              var _point = _i === 0 ? b0 : b1;\\n\\n              return {\\n                x: _point.x,\\n                y: _point.y,\\n                t: classifyResult.t\\n              };\\n            }\\n          }\\n\\n          var _x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\\n\\n          var _y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\\n\\n          return {\\n            x: _x,\\n            y: _y,\\n            t: t1\\n          };\\n        }\\n      }\\n\\n      function classifyPoint(p, edgeStart, edgeEnd) {\\n        var ax = edgeEnd.x - edgeStart.x;\\n        var ay = edgeEnd.y - edgeStart.y;\\n        var bx = p.x - edgeStart.x;\\n        var by = p.y - edgeStart.y;\\n        var sa = ax * by - bx * ay;\\n\\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\\n          classifyResult.loc = IntersectionLocationType.ORIGIN;\\n          classifyResult.t = 0;\\n          return;\\n        }\\n\\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\\n          classifyResult.loc = IntersectionLocationType.DESTINATION;\\n          classifyResult.t = 1;\\n          return;\\n        }\\n\\n        if (sa < -Number.EPSILON) {\\n          classifyResult.loc = IntersectionLocationType.LEFT;\\n          return;\\n        }\\n\\n        if (sa > Number.EPSILON) {\\n          classifyResult.loc = IntersectionLocationType.RIGHT;\\n          return;\\n        }\\n\\n        if (ax * bx < 0 || ay * by < 0) {\\n          classifyResult.loc = IntersectionLocationType.BEHIND;\\n          return;\\n        }\\n\\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\\n          classifyResult.loc = IntersectionLocationType.BEYOND;\\n          return;\\n        }\\n\\n        var t;\\n\\n        if (ax !== 0) {\\n          t = bx / ax;\\n        } else {\\n          t = by / ay;\\n        }\\n\\n        classifyResult.loc = IntersectionLocationType.BETWEEN;\\n        classifyResult.t = t;\\n      }\\n\\n      function getIntersections(path1, path2) {\\n        var intersectionsRaw = [];\\n        var intersections = [];\\n\\n        for (var index = 1; index < path1.length; index++) {\\n          var path1EdgeStart = path1[index - 1];\\n          var path1EdgeEnd = path1[index];\\n\\n          var _loop = function _loop(index2) {\\n            var path2EdgeStart = path2[index2 - 1];\\n            var path2EdgeEnd = path2[index2];\\n            var intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\\n\\n            if (intersection !== null && intersectionsRaw.find(function (i) {\\n              return i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON;\\n            }) === undefined) {\\n              intersectionsRaw.push(intersection);\\n              intersections.push(new _three.Vector2(intersection.x, intersection.y));\\n            }\\n          };\\n\\n          for (var index2 = 1; index2 < path2.length; index2++) {\\n            _loop(index2);\\n          }\\n        }\\n\\n        return intersections;\\n      }\\n\\n      function getScanlineIntersections(scanline, boundingBox, paths) {\\n        var center = new _three.Vector2();\\n        boundingBox.getCenter(center);\\n        var allIntersections = [];\\n        paths.forEach(function (path) {\\n          // check if the center of the bounding box is in the bounding box of the paths.\\n          // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\\n          // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\\n          if (path.boundingBox.containsPoint(center)) {\\n            var intersections = getIntersections(scanline, path.points);\\n            intersections.forEach(function (p) {\\n              allIntersections.push({\\n                identifier: path.identifier,\\n                isCW: path.isCW,\\n                point: p\\n              });\\n            });\\n          }\\n        });\\n        allIntersections.sort(function (i1, i2) {\\n          return i1.point.x - i2.point.x;\\n        });\\n        return allIntersections;\\n      }\\n\\n      function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\\n        if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\\n          _fillRule = 'nonzero';\\n        }\\n\\n        var centerBoundingBox = new _three.Vector2();\\n        simplePath.boundingBox.getCenter(centerBoundingBox);\\n        var scanline = [new _three.Vector2(scanlineMinX, centerBoundingBox.y), new _three.Vector2(scanlineMaxX, centerBoundingBox.y)];\\n        var scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\\n        scanlineIntersections.sort(function (i1, i2) {\\n          return i1.point.x - i2.point.x;\\n        });\\n        var baseIntersections = [];\\n        var otherIntersections = [];\\n        scanlineIntersections.forEach(function (i) {\\n          if (i.identifier === simplePath.identifier) {\\n            baseIntersections.push(i);\\n          } else {\\n            otherIntersections.push(i);\\n          }\\n        });\\n        var firstXOfPath = baseIntersections[0].point.x; // build up the path hierarchy\\n\\n        var stack = [];\\n        var i = 0;\\n\\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\\n            stack.pop();\\n          } else {\\n            stack.push(otherIntersections[i].identifier);\\n          }\\n\\n          i++;\\n        }\\n\\n        stack.push(simplePath.identifier);\\n\\n        if (_fillRule === 'evenodd') {\\n          var isHole = stack.length % 2 === 0 ? true : false;\\n          var isHoleFor = stack[stack.length - 2];\\n          return {\\n            identifier: simplePath.identifier,\\n            isHole: isHole,\\n            \\\"for\\\": isHoleFor\\n          };\\n        } else if (_fillRule === 'nonzero') {\\n          // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\\n          var _isHole = true;\\n          var _isHoleFor = null;\\n          var lastCWValue = null;\\n\\n          for (var _i2 = 0; _i2 < stack.length; _i2++) {\\n            var _identifier = stack[_i2];\\n\\n            if (_isHole) {\\n              lastCWValue = allPaths[_identifier].isCW;\\n              _isHole = false;\\n              _isHoleFor = _identifier;\\n            } else if (lastCWValue !== allPaths[_identifier].isCW) {\\n              lastCWValue = allPaths[_identifier].isCW;\\n              _isHole = true;\\n            }\\n          }\\n\\n          return {\\n            identifier: simplePath.identifier,\\n            isHole: _isHole,\\n            \\\"for\\\": _isHoleFor\\n          };\\n        } else {\\n          console.warn('fill-rule: \\\"' + _fillRule + '\\\" is currently not implemented.');\\n        }\\n      } // check for self intersecting paths\\n      // TODO\\n      // check intersecting paths\\n      // TODO\\n      // prepare paths for hole detection\\n\\n\\n      var identifier = 0;\\n      var scanlineMinX = BIGNUMBER;\\n      var scanlineMaxX = -BIGNUMBER;\\n      var simplePaths = shapePath.subPaths.map(function (p) {\\n        var points = p.getPoints();\\n        var maxY = -BIGNUMBER;\\n        var minY = BIGNUMBER;\\n        var maxX = -BIGNUMBER;\\n        var minX = BIGNUMBER; //points.forEach(p => p.y *= -1);\\n\\n        for (var i = 0; i < points.length; i++) {\\n          var _p = points[i];\\n\\n          if (_p.y > maxY) {\\n            maxY = _p.y;\\n          }\\n\\n          if (_p.y < minY) {\\n            minY = _p.y;\\n          }\\n\\n          if (_p.x > maxX) {\\n            maxX = _p.x;\\n          }\\n\\n          if (_p.x < minX) {\\n            minX = _p.x;\\n          }\\n        } //\\n\\n\\n        if (scanlineMaxX <= maxX) {\\n          scanlineMaxX = maxX + 1;\\n        }\\n\\n        if (scanlineMinX >= minX) {\\n          scanlineMinX = minX - 1;\\n        }\\n\\n        return {\\n          points: points,\\n          isCW: _three.ShapeUtils.isClockWise(points),\\n          identifier: identifier++,\\n          boundingBox: new _three.Box2(new _three.Vector2(minX, minY), new _three.Vector2(maxX, maxY))\\n        };\\n      });\\n      simplePaths = simplePaths.filter(function (sp) {\\n        return sp.points.length > 0;\\n      }); // check if path is solid or a hole\\n\\n      var isAHole = simplePaths.map(function (p) {\\n        return isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData.style.fillRule);\\n      });\\n      var shapesToReturn = [];\\n      simplePaths.forEach(function (p) {\\n        var amIAHole = isAHole[p.identifier];\\n\\n        if (!amIAHole.isHole) {\\n          var shape = new _three.Shape(p.points);\\n          var holes = isAHole.filter(function (h) {\\n            return h.isHole && h[\\\"for\\\"] === p.identifier;\\n          });\\n          holes.forEach(function (h) {\\n            var path = simplePaths[h.identifier];\\n            shape.holes.push(new _three.Path(path.points));\\n          });\\n          shapesToReturn.push(shape);\\n        }\\n      });\\n      return shapesToReturn;\\n    }\\n  }, {\\n    key: \\\"getStrokeStyle\\\",\\n    value: function getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\\n      // Param width: Stroke width\\n      // Param color: As returned by THREE.Color.getStyle()\\n      // Param lineJoin: One of \\\"round\\\", \\\"bevel\\\", \\\"miter\\\" or \\\"miter-limit\\\"\\n      // Param lineCap: One of \\\"round\\\", \\\"square\\\" or \\\"butt\\\"\\n      // Param miterLimit: Maximum join length, in multiples of the \\\"width\\\" parameter (join is truncated if it exceeds that distance)\\n      // Returns style object\\n      width = width !== undefined ? width : 1;\\n      color = color !== undefined ? color : '#000';\\n      lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\\n      lineCap = lineCap !== undefined ? lineCap : 'butt';\\n      miterLimit = miterLimit !== undefined ? miterLimit : 4;\\n      return {\\n        strokeColor: color,\\n        strokeWidth: width,\\n        strokeLineJoin: lineJoin,\\n        strokeLineCap: lineCap,\\n        strokeMiterLimit: miterLimit\\n      };\\n    }\\n  }, {\\n    key: \\\"pointsToStroke\\\",\\n    value: function pointsToStroke(points, style, arcDivisions, minDistance) {\\n      // Generates a stroke with some witdh around the given path.\\n      // The path can be open or closed (last point equals to first point)\\n      // Param points: Array of Vector2D (the path). Minimum 2 points.\\n      // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\\n      // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\\n      // Param minDistance: Points closer to this distance will be merged. (Optional)\\n      // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\\n      var vertices = [];\\n      var normals = [];\\n      var uvs = [];\\n\\n      if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\\n        return null;\\n      }\\n\\n      var geometry = new _three.BufferGeometry();\\n      geometry.setAttribute('position', new _three.Float32BufferAttribute(vertices, 3));\\n      geometry.setAttribute('normal', new _three.Float32BufferAttribute(normals, 3));\\n      geometry.setAttribute('uv', new _three.Float32BufferAttribute(uvs, 2));\\n      return geometry;\\n    }\\n  }, {\\n    key: \\\"pointsToStrokeWithBuffers\\\",\\n    value: function pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\\n      // This function can be called to update existing arrays or buffers.\\n      // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\\n      // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\\n      // Returns number of written vertices / normals / uvs pairs\\n      // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\\n      // 'normals' and 'uvs' buffers are optional\\n      var tempV2_1 = new _three.Vector2();\\n      var tempV2_2 = new _three.Vector2();\\n      var tempV2_3 = new _three.Vector2();\\n      var tempV2_4 = new _three.Vector2();\\n      var tempV2_5 = new _three.Vector2();\\n      var tempV2_6 = new _three.Vector2();\\n      var tempV2_7 = new _three.Vector2();\\n      var lastPointL = new _three.Vector2();\\n      var lastPointR = new _three.Vector2();\\n      var point0L = new _three.Vector2();\\n      var point0R = new _three.Vector2();\\n      var currentPointL = new _three.Vector2();\\n      var currentPointR = new _three.Vector2();\\n      var nextPointL = new _three.Vector2();\\n      var nextPointR = new _three.Vector2();\\n      var innerPoint = new _three.Vector2();\\n      var outerPoint = new _three.Vector2();\\n      arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\\n      minDistance = minDistance !== undefined ? minDistance : 0.001;\\n      vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points\\n\\n      points = removeDuplicatedPoints(points);\\n      var numPoints = points.length;\\n      if (numPoints < 2) return 0;\\n      var isClosed = points[0].equals(points[numPoints - 1]);\\n      var currentPoint;\\n      var previousPoint = points[0];\\n      var nextPoint;\\n      var strokeWidth2 = style.strokeWidth / 2;\\n      var deltaU = 1 / (numPoints - 1);\\n      var u0 = 0,\\n          u1;\\n      var innerSideModified;\\n      var joinIsOnLeftSide;\\n      var isMiter;\\n      var initialJoinIsOnLeftSide = false;\\n      var numVertices = 0;\\n      var currentCoordinate = vertexOffset * 3;\\n      var currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points\\n\\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\\n      lastPointL.copy(points[0]).sub(tempV2_1);\\n      lastPointR.copy(points[0]).add(tempV2_1);\\n      point0L.copy(lastPointL);\\n      point0R.copy(lastPointR);\\n\\n      for (var iPoint = 1; iPoint < numPoints; iPoint++) {\\n        currentPoint = points[iPoint]; // Get next point\\n\\n        if (iPoint === numPoints - 1) {\\n          if (isClosed) {\\n            // Skip duplicated initial point\\n            nextPoint = points[1];\\n          } else {\\n            nextPoint = undefined;\\n          }\\n        } else {\\n          nextPoint = points[iPoint + 1];\\n        } // Normal of previous segment in tempV2_1\\n\\n\\n        var normal1 = tempV2_1;\\n        getNormal(previousPoint, currentPoint, normal1);\\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\\n        currentPointL.copy(currentPoint).sub(tempV2_3);\\n        currentPointR.copy(currentPoint).add(tempV2_3);\\n        u1 = u0 + deltaU;\\n        innerSideModified = false;\\n\\n        if (nextPoint !== undefined) {\\n          // Normal of next segment in tempV2_2\\n          getNormal(currentPoint, nextPoint, tempV2_2);\\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\\n          nextPointL.copy(currentPoint).sub(tempV2_3);\\n          nextPointR.copy(currentPoint).add(tempV2_3);\\n          joinIsOnLeftSide = true;\\n          tempV2_3.subVectors(nextPoint, previousPoint);\\n\\n          if (normal1.dot(tempV2_3) < 0) {\\n            joinIsOnLeftSide = false;\\n          }\\n\\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\\n          tempV2_3.subVectors(nextPoint, currentPoint);\\n          tempV2_3.normalize();\\n          var dot = Math.abs(normal1.dot(tempV2_3)); // If path is straight, don't create join\\n\\n          if (dot !== 0) {\\n            // Compute inner and outer segment intersections\\n            var miterSide = strokeWidth2 / dot;\\n            tempV2_3.multiplyScalar(-miterSide);\\n            tempV2_4.subVectors(currentPoint, previousPoint);\\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\\n            innerPoint.copy(tempV2_5).negate();\\n            var miterLength2 = tempV2_5.length();\\n            var segmentLengthPrev = tempV2_4.length();\\n            tempV2_4.divideScalar(segmentLengthPrev);\\n            tempV2_6.subVectors(nextPoint, currentPoint);\\n            var segmentLengthNext = tempV2_6.length();\\n            tempV2_6.divideScalar(segmentLengthNext); // Check that previous and next segments doesn't overlap with the innerPoint of intersection\\n\\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\\n              innerSideModified = true;\\n            }\\n\\n            outerPoint.copy(tempV2_5).add(currentPoint);\\n            innerPoint.add(currentPoint);\\n            isMiter = false;\\n\\n            if (innerSideModified) {\\n              if (joinIsOnLeftSide) {\\n                nextPointR.copy(innerPoint);\\n                currentPointR.copy(innerPoint);\\n              } else {\\n                nextPointL.copy(innerPoint);\\n                currentPointL.copy(innerPoint);\\n              }\\n            } else {\\n              // The segment triangles are generated here if there was overlapping\\n              makeSegmentTriangles();\\n            }\\n\\n            switch (style.strokeLineJoin) {\\n              case 'bevel':\\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\\n                break;\\n\\n              case 'round':\\n                // Segment triangles\\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Join triangles\\n\\n                if (joinIsOnLeftSide) {\\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\\n                } else {\\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\\n                }\\n\\n                break;\\n\\n              case 'miter':\\n              case 'miter-clip':\\n              default:\\n                var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\\n\\n                if (miterFraction < 1) {\\n                  // The join miter length exceeds the miter limit\\n                  if (style.strokeLineJoin !== 'miter-clip') {\\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\\n                    break;\\n                  } else {\\n                    // Segment triangles\\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Miter-clip join triangles\\n\\n                    if (joinIsOnLeftSide) {\\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\\n                      addVertex(currentPointL, u1, 0);\\n                      addVertex(tempV2_6, u1, 0);\\n                      addVertex(currentPoint, u1, 0.5);\\n                      addVertex(currentPoint, u1, 0.5);\\n                      addVertex(tempV2_6, u1, 0);\\n                      addVertex(tempV2_7, u1, 0);\\n                      addVertex(currentPoint, u1, 0.5);\\n                      addVertex(tempV2_7, u1, 0);\\n                      addVertex(nextPointL, u1, 0);\\n                    } else {\\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\\n                      addVertex(currentPointR, u1, 1);\\n                      addVertex(tempV2_6, u1, 1);\\n                      addVertex(currentPoint, u1, 0.5);\\n                      addVertex(currentPoint, u1, 0.5);\\n                      addVertex(tempV2_6, u1, 1);\\n                      addVertex(tempV2_7, u1, 1);\\n                      addVertex(currentPoint, u1, 0.5);\\n                      addVertex(tempV2_7, u1, 1);\\n                      addVertex(nextPointR, u1, 1);\\n                    }\\n                  }\\n                } else {\\n                  // Miter join segment triangles\\n                  if (innerSideModified) {\\n                    // Optimized segment + join triangles\\n                    if (joinIsOnLeftSide) {\\n                      addVertex(lastPointR, u0, 1);\\n                      addVertex(lastPointL, u0, 0);\\n                      addVertex(outerPoint, u1, 0);\\n                      addVertex(lastPointR, u0, 1);\\n                      addVertex(outerPoint, u1, 0);\\n                      addVertex(innerPoint, u1, 1);\\n                    } else {\\n                      addVertex(lastPointR, u0, 1);\\n                      addVertex(lastPointL, u0, 0);\\n                      addVertex(outerPoint, u1, 1);\\n                      addVertex(lastPointL, u0, 0);\\n                      addVertex(innerPoint, u1, 0);\\n                      addVertex(outerPoint, u1, 1);\\n                    }\\n\\n                    if (joinIsOnLeftSide) {\\n                      nextPointL.copy(outerPoint);\\n                    } else {\\n                      nextPointR.copy(outerPoint);\\n                    }\\n                  } else {\\n                    // Add extra miter join triangles\\n                    if (joinIsOnLeftSide) {\\n                      addVertex(currentPointL, u1, 0);\\n                      addVertex(outerPoint, u1, 0);\\n                      addVertex(currentPoint, u1, 0.5);\\n                      addVertex(currentPoint, u1, 0.5);\\n                      addVertex(outerPoint, u1, 0);\\n                      addVertex(nextPointL, u1, 0);\\n                    } else {\\n                      addVertex(currentPointR, u1, 1);\\n                      addVertex(outerPoint, u1, 1);\\n                      addVertex(currentPoint, u1, 0.5);\\n                      addVertex(currentPoint, u1, 0.5);\\n                      addVertex(outerPoint, u1, 1);\\n                      addVertex(nextPointR, u1, 1);\\n                    }\\n                  }\\n\\n                  isMiter = true;\\n                }\\n\\n                break;\\n            }\\n          } else {\\n            // The segment triangles are generated here when two consecutive points are collinear\\n            makeSegmentTriangles();\\n          }\\n        } else {\\n          // The segment triangles are generated here if it is the ending segment\\n          makeSegmentTriangles();\\n        }\\n\\n        if (!isClosed && iPoint === numPoints - 1) {\\n          // Start line endcap\\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\\n        } // Increment loop variables\\n\\n\\n        u0 = u1;\\n        previousPoint = currentPoint;\\n        lastPointL.copy(nextPointL);\\n        lastPointR.copy(nextPointR);\\n      }\\n\\n      if (!isClosed) {\\n        // Ending line endcap\\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\\n      } else if (innerSideModified && vertices) {\\n        // Modify path first segment vertices to adjust to the segments inner and outer intersections\\n        var lastOuter = outerPoint;\\n        var lastInner = innerPoint;\\n\\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\\n          lastOuter = innerPoint;\\n          lastInner = outerPoint;\\n        }\\n\\n        if (joinIsOnLeftSide) {\\n          if (isMiter || initialJoinIsOnLeftSide) {\\n            lastInner.toArray(vertices, 0 * 3);\\n            lastInner.toArray(vertices, 3 * 3);\\n\\n            if (isMiter) {\\n              lastOuter.toArray(vertices, 1 * 3);\\n            }\\n          }\\n        } else {\\n          if (isMiter || !initialJoinIsOnLeftSide) {\\n            lastInner.toArray(vertices, 1 * 3);\\n            lastInner.toArray(vertices, 3 * 3);\\n\\n            if (isMiter) {\\n              lastOuter.toArray(vertices, 0 * 3);\\n            }\\n          }\\n        }\\n      }\\n\\n      return numVertices; // -- End of algorithm\\n      // -- Functions\\n\\n      function getNormal(p1, p2, result) {\\n        result.subVectors(p2, p1);\\n        return result.set(-result.y, result.x).normalize();\\n      }\\n\\n      function addVertex(position, u, v) {\\n        if (vertices) {\\n          vertices[currentCoordinate] = position.x;\\n          vertices[currentCoordinate + 1] = position.y;\\n          vertices[currentCoordinate + 2] = 0;\\n\\n          if (normals) {\\n            normals[currentCoordinate] = 0;\\n            normals[currentCoordinate + 1] = 0;\\n            normals[currentCoordinate + 2] = 1;\\n          }\\n\\n          currentCoordinate += 3;\\n\\n          if (uvs) {\\n            uvs[currentCoordinateUV] = u;\\n            uvs[currentCoordinateUV + 1] = v;\\n            currentCoordinateUV += 2;\\n          }\\n        }\\n\\n        numVertices += 3;\\n      }\\n\\n      function makeCircularSector(center, p1, p2, u, v) {\\n        // param p1, p2: Points in the circle arc.\\n        // p1 and p2 are in clockwise direction.\\n        tempV2_1.copy(p1).sub(center).normalize();\\n        tempV2_2.copy(p2).sub(center).normalize();\\n        var angle = Math.PI;\\n        var dot = tempV2_1.dot(tempV2_2);\\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\\n        angle /= arcDivisions;\\n        tempV2_3.copy(p1);\\n\\n        for (var i = 0, il = arcDivisions - 1; i < il; i++) {\\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle);\\n          addVertex(tempV2_3, u, v);\\n          addVertex(tempV2_4, u, v);\\n          addVertex(center, u, 0.5);\\n          tempV2_3.copy(tempV2_4);\\n        }\\n\\n        addVertex(tempV2_4, u, v);\\n        addVertex(p2, u, v);\\n        addVertex(center, u, 0.5);\\n      }\\n\\n      function makeSegmentTriangles() {\\n        addVertex(lastPointR, u0, 1);\\n        addVertex(lastPointL, u0, 0);\\n        addVertex(currentPointL, u1, 0);\\n        addVertex(lastPointR, u0, 1);\\n        addVertex(currentPointL, u1, 1);\\n        addVertex(currentPointR, u1, 0);\\n      }\\n\\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\\n        if (innerSideModified) {\\n          // Optimized segment + bevel triangles\\n          if (joinIsOnLeftSide) {\\n            // Path segments triangles\\n            addVertex(lastPointR, u0, 1);\\n            addVertex(lastPointL, u0, 0);\\n            addVertex(currentPointL, u1, 0);\\n            addVertex(lastPointR, u0, 1);\\n            addVertex(currentPointL, u1, 0);\\n            addVertex(innerPoint, u1, 1); // Bevel join triangle\\n\\n            addVertex(currentPointL, u, 0);\\n            addVertex(nextPointL, u, 0);\\n            addVertex(innerPoint, u, 0.5);\\n          } else {\\n            // Path segments triangles\\n            addVertex(lastPointR, u0, 1);\\n            addVertex(lastPointL, u0, 0);\\n            addVertex(currentPointR, u1, 1);\\n            addVertex(lastPointL, u0, 0);\\n            addVertex(innerPoint, u1, 0);\\n            addVertex(currentPointR, u1, 1); // Bevel join triangle\\n\\n            addVertex(currentPointR, u, 1);\\n            addVertex(nextPointR, u, 0);\\n            addVertex(innerPoint, u, 0.5);\\n          }\\n        } else {\\n          // Bevel join triangle. The segment triangles are done in the main loop\\n          if (joinIsOnLeftSide) {\\n            addVertex(currentPointL, u, 0);\\n            addVertex(nextPointL, u, 0);\\n            addVertex(currentPoint, u, 0.5);\\n          } else {\\n            addVertex(currentPointR, u, 1);\\n            addVertex(nextPointR, u, 0);\\n            addVertex(currentPoint, u, 0.5);\\n          }\\n        }\\n      }\\n\\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\\n        if (innerSideModified) {\\n          if (joinIsOnLeftSide) {\\n            addVertex(lastPointR, u0, 1);\\n            addVertex(lastPointL, u0, 0);\\n            addVertex(currentPointL, u1, 0);\\n            addVertex(lastPointR, u0, 1);\\n            addVertex(currentPointL, u1, 0);\\n            addVertex(innerPoint, u1, 1);\\n            addVertex(currentPointL, u0, 0);\\n            addVertex(currentPoint, u1, 0.5);\\n            addVertex(innerPoint, u1, 1);\\n            addVertex(currentPoint, u1, 0.5);\\n            addVertex(nextPointL, u0, 0);\\n            addVertex(innerPoint, u1, 1);\\n          } else {\\n            addVertex(lastPointR, u0, 1);\\n            addVertex(lastPointL, u0, 0);\\n            addVertex(currentPointR, u1, 1);\\n            addVertex(lastPointL, u0, 0);\\n            addVertex(innerPoint, u1, 0);\\n            addVertex(currentPointR, u1, 1);\\n            addVertex(currentPointR, u0, 1);\\n            addVertex(innerPoint, u1, 0);\\n            addVertex(currentPoint, u1, 0.5);\\n            addVertex(currentPoint, u1, 0.5);\\n            addVertex(innerPoint, u1, 0);\\n            addVertex(nextPointR, u0, 1);\\n          }\\n        }\\n      }\\n\\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\\n        // param center: End point of the path\\n        // param p1, p2: Left and right cap points\\n        switch (style.strokeLineCap) {\\n          case 'round':\\n            if (start) {\\n              makeCircularSector(center, p2, p1, u, 0.5);\\n            } else {\\n              makeCircularSector(center, p1, p2, u, 0.5);\\n            }\\n\\n            break;\\n\\n          case 'square':\\n            if (start) {\\n              tempV2_1.subVectors(p1, center);\\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center); // Modify already existing vertices\\n\\n              if (joinIsOnLeftSide) {\\n                tempV2_3.toArray(vertices, 1 * 3);\\n                tempV2_4.toArray(vertices, 0 * 3);\\n                tempV2_4.toArray(vertices, 3 * 3);\\n              } else {\\n                tempV2_3.toArray(vertices, 1 * 3);\\n                tempV2_3.toArray(vertices, 3 * 3);\\n                tempV2_4.toArray(vertices, 0 * 3);\\n              }\\n            } else {\\n              tempV2_1.subVectors(p2, center);\\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\\n              var vl = vertices.length; // Modify already existing vertices\\n\\n              if (joinIsOnLeftSide) {\\n                tempV2_3.toArray(vertices, vl - 1 * 3);\\n                tempV2_4.toArray(vertices, vl - 2 * 3);\\n                tempV2_4.toArray(vertices, vl - 4 * 3);\\n              } else {\\n                tempV2_3.toArray(vertices, vl - 2 * 3);\\n                tempV2_4.toArray(vertices, vl - 1 * 3);\\n                tempV2_4.toArray(vertices, vl - 4 * 3);\\n              }\\n            }\\n\\n            break;\\n        }\\n      }\\n\\n      function removeDuplicatedPoints(points) {\\n        // Creates a new array if necessary with duplicated points removed.\\n        // This does not remove duplicated initial and ending points of a closed path.\\n        var dupPoints = false;\\n\\n        for (var i = 1, n = points.length - 1; i < n; i++) {\\n          if (points[i].distanceTo(points[i + 1]) < minDistance) {\\n            dupPoints = true;\\n            break;\\n          }\\n        }\\n\\n        if (!dupPoints) return points;\\n        var newPoints = [];\\n        newPoints.push(points[0]);\\n\\n        for (var _i3 = 1, _n = points.length - 1; _i3 < _n; _i3++) {\\n          if (points[_i3].distanceTo(points[_i3 + 1]) >= minDistance) {\\n            newPoints.push(points[_i3]);\\n          }\\n        }\\n\\n        newPoints.push(points[points.length - 1]);\\n        return newPoints;\\n      }\\n    }\\n  }]);\\n\\n  return SVGLoader;\\n}(_three.Loader);\\n\\nexports.SVGLoader = SVGLoader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"SVGLoader\",\"_three\",\"_Loader\",\"manager\",\"instance\",\"call\",\"self\",\"ReferenceError\",\"_this\",\"defaultDPI\",\"defaultUnit\",\"load\",\"url\",\"onLoad\",\"onProgress\",\"onError\",\"scope\",\"loader\",\"FileLoader\",\"setPath\",\"path\",\"setRequestHeader\",\"requestHeader\",\"setWithCredentials\",\"withCredentials\",\"text\",\"parse\",\"e\",\"console\",\"error\",\"itemError\",\"parseNode\",\"node\",\"style\",\"nodeType\",\"hasAttribute\",\"nodeName\",\"transform\",\"Matrix3\",\"currentTransform\",\"tempTransform0\",\"tx\",\"parseFloatWithUnits\",\"getAttribute\",\"ty\",\"translate\",\"transformsTexts\",\"split\",\"tIndex\",\"transformText\",\"trim\",\"openParPos\",\"indexOf\",\"closeParPos\",\"transformType\",\"substr\",\"array\",\"parseFloats\",\"identity\",\"_tx\",\"_ty\",\"cx\",\"cy\",\"angle\",\"Math\",\"PI\",\"tempTransform1\",\"tempTransform2\",\"rotate\",\"tempTransform3\",\"multiplyMatrices\",\"scaleX\",\"scaleY\",\"scale\",\"set\",\"tan\",\"premultiply\",\"transformStack\",\"copy\",\"push\",\"traverseChildNodes\",\"parseCSSStylesheet\",\"parseStyle\",\"ShapePath\",\"point\",\"Vector2\",\"control\",\"firstPoint\",\"isFirstPoint\",\"doSetFirstPoint\",\"commands\",\"d\",\"match\",\"l\",\"command\",\"type\",\"charAt\",\"_data\",\"numbers\",\"j\",\"jl\",\"x\",\"y\",\"moveTo\",\"lineTo\",\"_j\",\"_jl\",\"_j2\",\"_jl2\",\"_j3\",\"_jl3\",\"_j4\",\"_jl4\",\"bezierCurveTo\",\"_j5\",\"_jl5\",\"getReflection\",\"_j6\",\"_jl6\",\"quadraticCurveTo\",\"_j7\",\"_jl7\",\"rx\",\"ry\",\"_j8\",\"_jl8\",\"start\",\"clone\",\"parseArcCommand\",\"_j9\",\"_jl9\",\"_j10\",\"_jl10\",\"_j11\",\"_jl11\",\"_j12\",\"_jl12\",\"_j13\",\"_jl13\",\"_j14\",\"_jl14\",\"_j15\",\"_jl15\",\"_j16\",\"_jl16\",\"_rx\",\"_ry\",\"_j17\",\"_jl17\",\"_start\",\"currentPath\",\"autoClose\",\"curves\",\"currentPoint\",\"warn\",\"w\",\"h\",\"parsePolygonNode\",\"parsePolylineNode\",\"r\",\"subpath\",\"Path\",\"absarc\",\"subPaths\",\"absellipse\",\"x1\",\"y1\",\"x2\",\"y2\",\"usedNodeId\",\"href\",\"baseVal\",\"substring\",\"usedNode\",\"viewportElement\",\"getElementById\",\"undefined\",\"fill\",\"color\",\"setStyle\",\"transformPath\",\"paths\",\"userData\",\"nodes\",\"childNodes\",\"pop\",\"sheet\",\"cssRules\",\"stylesheet\",\"selectorList\",\"selectorText\",\"filter\",\"Boolean\",\"map\",\"stylesheets\",\"assign\",\"x_axis_rotation\",\"large_arc_flag\",\"sweep_flag\",\"end\",\"abs\",\"dx2\",\"dy2\",\"x1p\",\"cos\",\"sin\",\"y1p\",\"rxs\",\"rys\",\"x1ps\",\"y1ps\",\"cr\",\"s\",\"sqrt\",\"dq\",\"q\",\"max\",\"cxp\",\"cyp\",\"theta\",\"svgAngle\",\"delta\",\"ux\",\"uy\",\"vx\",\"vy\",\"ang\",\"acos\",\"min\",\"index\",\"replace\",\"regex\",\"a\",\"b\",\"addStyle\",\"svgName\",\"jsName\",\"adjustFunction\",\"v\",\"startsWith\",\"stylesheetStyles\",\"clamp\",\"positive\",\"classSelectors\",\"input\",\"flags\",\"stride\",\"throwSyntaxError\",\"current\",\"partial\",\"SyntaxError\",\"newNumber\",\"number\",\"exponent\",\"result\",\"Number\",\"pow\",\"state\",\"SEP\",\"seenComma\",\"Array\",\"isArray\",\"includes\",\"FLAGS\",\"test\",\"INT\",\"WHITESPACE\",\"DIGIT\",\"SIGN\",\"POINT\",\"FLOAT\",\"COMMA\",\"EXP\",\"string\",\"theUnit\",\"String\",\"n\",\"units\",\"u\",\"endsWith\",\"unitConversion\",\"parseFloat\",\"m\",\"transfVec2\",\"v2\",\"tempV3\",\"applyMatrix3\",\"isRotated\",\"elements\",\"subPath\",\"curve\",\"isLineCurve\",\"v1\",\"isCubicBezierCurve\",\"v0\",\"v3\",\"isQuadraticBezierCurve\",\"isEllipseCurve\",\"tempV2\",\"aX\",\"aY\",\"xRadius\",\"getTransformScaleX\",\"yRadius\",\"getTransformScaleY\",\"te\",\"mm\",\"cm\",\"pt\",\"pc\",\"px\",\"Vector3\",\"xml\",\"parseFromString\",\"DOMParser\",\"documentElement\",\"fillOpacity\",\"strokeOpacity\",\"strokeWidth\",\"strokeLineJoin\",\"strokeLineCap\",\"strokeMiterLimit\",\"data\",\"createShapes\",\"shapePath\",\"findEdgeIntersection\",\"a0\",\"a1\",\"b0\",\"b1\",\"x3\",\"x4\",\"y3\",\"y4\",\"nom1\",\"denom\",\"t1\",\"t2\",\"classifyPoint\",\"loc\",\"IntersectionLocationType\",\"ORIGIN\",\"t\",\"BETWEEN\",\"toPrecision\",\"_i\",\"_point\",\"_x\",\"_y\",\"edgeStart\",\"edgeEnd\",\"ax\",\"ay\",\"bx\",\"by\",\"sa\",\"DESTINATION\",\"EPSILON\",\"LEFT\",\"RIGHT\",\"BEHIND\",\"BEYOND\",\"getIntersections\",\"path1\",\"path2\",\"intersectionsRaw\",\"intersections\",\"path1EdgeStart\",\"path1EdgeEnd\",\"_loop\",\"index2\",\"intersection\",\"path2EdgeStart\",\"path2EdgeEnd\",\"find\",\"getScanlineIntersections\",\"scanline\",\"boundingBox\",\"center\",\"getCenter\",\"allIntersections\",\"forEach\",\"containsPoint\",\"points\",\"identifier\",\"isCW\",\"sort\",\"i1\",\"i2\",\"isHoleTo\",\"simplePath\",\"allPaths\",\"scanlineMinX\",\"scanlineMaxX\",\"_fillRule\",\"centerBoundingBox\",\"scanlineIntersections\",\"baseIntersections\",\"otherIntersections\",\"firstXOfPath\",\"stack\",\"isHole\",\"isHoleFor\",\"_isHole\",\"lastCWValue\",\"_isHoleFor\",\"_i2\",\"_identifier\",\"BIGNUMBER\",\"simplePaths\",\"getPoints\",\"maxY\",\"minY\",\"maxX\",\"minX\",\"_p\",\"ShapeUtils\",\"isClockWise\",\"Box2\",\"sp\",\"isAHole\",\"fillRule\",\"shapesToReturn\",\"amIAHole\",\"shape\",\"Shape\",\"holes\",\"getStrokeStyle\",\"width\",\"lineJoin\",\"lineCap\",\"miterLimit\",\"strokeColor\",\"pointsToStroke\",\"arcDivisions\",\"minDistance\",\"vertices\",\"normals\",\"uvs\",\"pointsToStrokeWithBuffers\",\"geometry\",\"BufferGeometry\",\"setAttribute\",\"Float32BufferAttribute\",\"vertexOffset\",\"getNormal\",\"p1\",\"p2\",\"subVectors\",\"normalize\",\"addVertex\",\"position\",\"currentCoordinate\",\"currentCoordinateUV\",\"numVertices\",\"makeCircularSector\",\"tempV2_1\",\"sub\",\"tempV2_2\",\"dot\",\"tempV2_3\",\"il\",\"tempV2_4\",\"rotateAround\",\"makeSegmentTriangles\",\"lastPointR\",\"u0\",\"lastPointL\",\"currentPointL\",\"u1\",\"currentPointR\",\"makeSegmentWithBevelJoin\",\"joinIsOnLeftSide\",\"innerSideModified\",\"innerPoint\",\"nextPointL\",\"nextPointR\",\"createSegmentTrianglesWithMiddleSection\",\"addCapGeometry\",\"addVectors\",\"add\",\"toArray\",\"vl\",\"tempV2_5\",\"tempV2_6\",\"tempV2_7\",\"point0L\",\"point0R\",\"outerPoint\",\"removeDuplicatedPoints\",\"dupPoints\",\"distanceTo\",\"newPoints\",\"_i3\",\"_n\",\"numPoints\",\"isClosed\",\"equals\",\"previousPoint\",\"strokeWidth2\",\"deltaU\",\"initialJoinIsOnLeftSide\",\"multiplyScalar\",\"iPoint\",\"nextPoint\",\"normal1\",\"miterSide\",\"setLength\",\"negate\",\"miterLength2\",\"segmentLengthPrev\",\"divideScalar\",\"segmentLengthNext\",\"isMiter\",\"miterFraction\",\"lastOuter\",\"lastInner\",\"Loader\"]\n}\n"]