["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/misc/GPUComputationRenderer.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$misc$GPUComputationRenderer=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.GPUComputationRenderer=void 0;var _three=require(\"module$node_modules$three$build$three_module\");exports.GPUComputationRenderer=function(sizeX,sizeY,renderer){function addResolutionDefine(materialShader){materialShader.defines.resolution=\"vec2( \"+sizeX.toFixed(1)+\", \"+sizeY.toFixed(1)+\" )\"}function createShaderMaterial(computeFragmentShader,\nuniforms){uniforms=uniforms||{};computeFragmentShader=new _three.ShaderMaterial({uniforms,vertexShader:\"void main()\\t{\\n\\n\\tgl_Position \\x3d vec4( position, 1.0 );\\n\\n}\\n\",fragmentShader:computeFragmentShader});addResolutionDefine(computeFragmentShader);return computeFragmentShader}this.variables=[];this.currentTextureIndex=0;var dataType=_three.FloatType,scene=new _three.Scene,camera=new _three.Camera;camera.position.z=1;var passThruUniforms={passThruTexture:{value:null}},passThruShader=createShaderMaterial(\"uniform sampler2D passThruTexture;\\n\\nvoid main() {\\n\\n\\tvec2 uv \\x3d gl_FragCoord.xy / resolution.xy;\\n\\n\\tgl_FragColor \\x3d texture2D( passThruTexture, uv );\\n\\n}\\n\",\npassThruUniforms),mesh=new _three.Mesh(new _three.PlaneGeometry(2,2),passThruShader);scene.add(mesh);this.setDataType=function(type){dataType=type;return this};this.addVariable=function(variableName,computeFragmentShader,initialValueTexture){computeFragmentShader=this.createShaderMaterial(computeFragmentShader);variableName={name:variableName,initialValueTexture,material:computeFragmentShader,dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:_three.NearestFilter,magFilter:_three.NearestFilter};\nthis.variables.push(variableName);return variableName};this.setVariableDependencies=function(variable,dependencies){variable.dependencies=dependencies};this.init=function(){if(!1===renderer.capabilities.isWebGL2&&!1===renderer.extensions.has(\"OES_texture_float\"))return\"No OES_texture_float support for float textures.\";if(0===renderer.capabilities.maxVertexTextures)return\"No support for vertex shader textures.\";for(var i=0;i<this.variables.length;i++){var variable=this.variables[i];variable.renderTargets[0]=\nthis.createRenderTarget(sizeX,sizeY,variable.wrapS,variable.wrapT,variable.minFilter,variable.magFilter);variable.renderTargets[1]=this.createRenderTarget(sizeX,sizeY,variable.wrapS,variable.wrapT,variable.minFilter,variable.magFilter);this.renderTexture(variable.initialValueTexture,variable.renderTargets[0]);this.renderTexture(variable.initialValueTexture,variable.renderTargets[1]);var material=variable.material,uniforms=material.uniforms;if(null!==variable.dependencies)for(var d=0;d<variable.dependencies.length;d++){var depVar=\nvariable.dependencies[d];if(depVar.name!==variable.name){for(var found=!1,j=0;j<this.variables.length;j++)if(depVar.name===this.variables[j].name){found=!0;break}if(!found)return\"Variable dependency not found. Variable\\x3d\"+variable.name+\", dependency\\x3d\"+depVar.name}uniforms[depVar.name]={value:null};material.fragmentShader=\"\\nuniform sampler2D \"+depVar.name+\";\\n\"+material.fragmentShader}}this.currentTextureIndex=0;return null};this.compute=function(){for(var currentTextureIndex=this.currentTextureIndex,\nnextTextureIndex=0===this.currentTextureIndex?1:0,i=0,il=this.variables.length;i<il;i++){var variable=this.variables[i];if(null!==variable.dependencies)for(var uniforms=variable.material.uniforms,d=0,dl=variable.dependencies.length;d<dl;d++){var depVar=variable.dependencies[d];uniforms[depVar.name].value=depVar.renderTargets[currentTextureIndex].texture}this.doRenderTarget(variable.material,variable.renderTargets[nextTextureIndex])}this.currentTextureIndex=nextTextureIndex};this.getCurrentRenderTarget=\nfunction(variable){return variable.renderTargets[this.currentTextureIndex]};this.getAlternateRenderTarget=function(variable){return variable.renderTargets[0===this.currentTextureIndex?1:0]};this.addResolutionDefine=addResolutionDefine;this.createShaderMaterial=createShaderMaterial;this.createRenderTarget=function(sizeXTexture,sizeYTexture,wrapS,wrapT,minFilter,magFilter){sizeXTexture=sizeXTexture||sizeX;sizeYTexture=sizeYTexture||sizeY;wrapS=wrapS||_three.ClampToEdgeWrapping;wrapT=wrapT||_three.ClampToEdgeWrapping;\nminFilter=minFilter||_three.NearestFilter;magFilter=magFilter||_three.NearestFilter;return new _three.WebGLRenderTarget(sizeXTexture,sizeYTexture,{wrapS,wrapT,minFilter,magFilter,format:_three.RGBAFormat,type:dataType,depthBuffer:!1})};this.createTexture=function(){var data=new Float32Array(sizeX*sizeY*4);return new _three.DataTexture(data,sizeX,sizeY,_three.RGBAFormat,_three.FloatType)};this.renderTexture=function(input,output){passThruUniforms.passThruTexture.value=input;this.doRenderTarget(passThruShader,\noutput);passThruUniforms.passThruTexture.value=null};this.doRenderTarget=function(material,output){var currentRenderTarget=renderer.getRenderTarget();mesh.material=material;renderer.setRenderTarget(output);renderer.render(scene,camera);mesh.material=passThruShader;renderer.setRenderTarget(currentRenderTarget)}}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$misc$GPUComputationRenderer\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GPUComputationRenderer = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n */\nvar GPUComputationRenderer = function GPUComputationRenderer(sizeX, sizeY, renderer) {\n  this.variables = [];\n  this.currentTextureIndex = 0;\n  var dataType = _three.FloatType;\n  var scene = new _three.Scene();\n  var camera = new _three.Camera();\n  camera.position.z = 1;\n  var passThruUniforms = {\n    passThruTexture: {\n      value: null\n    }\n  };\n  var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n  var mesh = new _three.Mesh(new _three.PlaneGeometry(2, 2), passThruShader);\n  scene.add(mesh);\n\n  this.setDataType = function (type) {\n    dataType = type;\n    return this;\n  };\n\n  this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n    var material = this.createShaderMaterial(computeFragmentShader);\n    var variable = {\n      name: variableName,\n      initialValueTexture: initialValueTexture,\n      material: material,\n      dependencies: null,\n      renderTargets: [],\n      wrapS: null,\n      wrapT: null,\n      minFilter: _three.NearestFilter,\n      magFilter: _three.NearestFilter\n    };\n    this.variables.push(variable);\n    return variable;\n  };\n\n  this.setVariableDependencies = function (variable, dependencies) {\n    variable.dependencies = dependencies;\n  };\n\n  this.init = function () {\n    if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('OES_texture_float') === false) {\n      return 'No OES_texture_float support for float textures.';\n    }\n\n    if (renderer.capabilities.maxVertexTextures === 0) {\n      return 'No support for vertex shader textures.';\n    }\n\n    for (var i = 0; i < this.variables.length; i++) {\n      var variable = this.variables[i]; // Creates rendertargets and initialize them with input texture\n\n      variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]); // Adds dependencies uniforms to the ShaderMaterial\n\n      var material = variable.material;\n      var uniforms = material.uniforms;\n\n      if (variable.dependencies !== null) {\n        for (var d = 0; d < variable.dependencies.length; d++) {\n          var depVar = variable.dependencies[d];\n\n          if (depVar.name !== variable.name) {\n            // Checks if variable exists\n            var found = false;\n\n            for (var j = 0; j < this.variables.length; j++) {\n              if (depVar.name === this.variables[j].name) {\n                found = true;\n                break;\n              }\n            }\n\n            if (!found) {\n              return 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\n            }\n          }\n\n          uniforms[depVar.name] = {\n            value: null\n          };\n          material.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader;\n        }\n      }\n    }\n\n    this.currentTextureIndex = 0;\n    return null;\n  };\n\n  this.compute = function () {\n    var currentTextureIndex = this.currentTextureIndex;\n    var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n    for (var i = 0, il = this.variables.length; i < il; i++) {\n      var variable = this.variables[i]; // Sets texture dependencies uniforms\n\n      if (variable.dependencies !== null) {\n        var uniforms = variable.material.uniforms;\n\n        for (var d = 0, dl = variable.dependencies.length; d < dl; d++) {\n          var depVar = variable.dependencies[d];\n          uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n        }\n      } // Performs the computation for this variable\n\n\n      this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n    }\n\n    this.currentTextureIndex = nextTextureIndex;\n  };\n\n  this.getCurrentRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex];\n  };\n\n  this.getAlternateRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n  };\n\n  function addResolutionDefine(materialShader) {\n    materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + ' )';\n  }\n\n  this.addResolutionDefine = addResolutionDefine; // The following functions can be used to compute things manually\n\n  function createShaderMaterial(computeFragmentShader, uniforms) {\n    uniforms = uniforms || {};\n    var material = new _three.ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: getPassThroughVertexShader(),\n      fragmentShader: computeFragmentShader\n    });\n    addResolutionDefine(material);\n    return material;\n  }\n\n  this.createShaderMaterial = createShaderMaterial;\n\n  this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n    sizeXTexture = sizeXTexture || sizeX;\n    sizeYTexture = sizeYTexture || sizeY;\n    wrapS = wrapS || _three.ClampToEdgeWrapping;\n    wrapT = wrapT || _three.ClampToEdgeWrapping;\n    minFilter = minFilter || _three.NearestFilter;\n    magFilter = magFilter || _three.NearestFilter;\n    var renderTarget = new _three.WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n      wrapS: wrapS,\n      wrapT: wrapT,\n      minFilter: minFilter,\n      magFilter: magFilter,\n      format: _three.RGBAFormat,\n      type: dataType,\n      depthBuffer: false\n    });\n    return renderTarget;\n  };\n\n  this.createTexture = function () {\n    var data = new Float32Array(sizeX * sizeY * 4);\n    return new _three.DataTexture(data, sizeX, sizeY, _three.RGBAFormat, _three.FloatType);\n  };\n\n  this.renderTexture = function (input, output) {\n    // Takes a texture, and render out in rendertarget\n    // input = Texture\n    // output = RenderTarget\n    passThruUniforms.passThruTexture.value = input;\n    this.doRenderTarget(passThruShader, output);\n    passThruUniforms.passThruTexture.value = null;\n  };\n\n  this.doRenderTarget = function (material, output) {\n    var currentRenderTarget = renderer.getRenderTarget();\n    mesh.material = material;\n    renderer.setRenderTarget(output);\n    renderer.render(scene, camera);\n    mesh.material = passThruShader;\n    renderer.setRenderTarget(currentRenderTarget);\n  }; // Shaders\n\n\n  function getPassThroughVertexShader() {\n    return 'void main()\t{\\n' + '\\n' + '\tgl_Position = vec4( position, 1.0 );\\n' + '\\n' + '}\\n';\n  }\n\n  function getPassThroughFragmentShader() {\n    return 'uniform sampler2D passThruTexture;\\n' + '\\n' + 'void main() {\\n' + '\\n' + '\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' + '\\n' + '\tgl_FragColor = texture2D( passThruTexture, uv );\\n' + '\\n' + '}\\n';\n  }\n};\n\nexports.GPUComputationRenderer = GPUComputationRenderer;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","renderTargets","z","wrapS","getAlternateRenderTarget","dependencies","depthBuffer","setDataType","setVariableDependencies","passThruTexture","currentTextureIndex","__esModule","GPUComputationRenderer","createShaderMaterial","addVariable","vertexShader","name","value","initialValueTexture","magFilter","addResolutionDefine","variables","type","wrapT","init","getCurrentRenderTarget","doRenderTarget","renderTexture","uniforms","createTexture","minFilter","compute","createRenderTarget","format","resolution","material"]],"~:compiled-at",1630917515107,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$misc$GPUComputationRenderer.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/misc/GPUComputationRenderer.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$misc$GPUComputationRenderer\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.GPUComputationRenderer = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * GPUComputationRenderer, based on SimulationRenderer by zz85\\n *\\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\\n * for each compute element (texel)\\n *\\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\\n *\\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\\n * as inputs to render the textures of the next frame.\\n *\\n * The render targets of the variables can be used as input textures for your visualization shaders.\\n *\\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\\n *\\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\\n *\\n * -------------\\n *\\n * Basic use:\\n *\\n * // Initialization...\\n *\\n * // Create computation renderer\\n * var gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\\n *\\n * // Create initial state float textures\\n * var pos0 = gpuCompute.createTexture();\\n * var vel0 = gpuCompute.createTexture();\\n * // and fill in here the texture data...\\n *\\n * // Add texture variables\\n * var velVar = gpuCompute.addVariable( \\\"textureVelocity\\\", fragmentShaderVel, pos0 );\\n * var posVar = gpuCompute.addVariable( \\\"texturePosition\\\", fragmentShaderPos, vel0 );\\n *\\n * // Add variable dependencies\\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\\n *\\n * // Add custom uniforms\\n * velVar.material.uniforms.time = { value: 0.0 };\\n *\\n * // Check for completeness\\n * var error = gpuCompute.init();\\n * if ( error !== null ) {\\n *\\t\\tconsole.error( error );\\n * }\\n *\\n *\\n * // In each frame...\\n *\\n * // Compute!\\n * gpuCompute.compute();\\n *\\n * // Update texture uniforms in your visualization materials with the gpu renderer output\\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\\n *\\n * // Do your rendering\\n * renderer.render( myScene, myCamera );\\n *\\n * -------------\\n *\\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\\n * Note that the shaders can have multiple input textures.\\n *\\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\\n *\\n * var inputTexture = gpuCompute.createTexture();\\n *\\n * // Fill in here inputTexture...\\n *\\n * myFilter1.uniforms.theTexture.value = inputTexture;\\n *\\n * var myRenderTarget = gpuCompute.createRenderTarget();\\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\\n *\\n * var outputRenderTarget = gpuCompute.createRenderTarget();\\n *\\n * // Now use the output texture where you want:\\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\\n *\\n * // And compute each frame, before rendering to screen:\\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\\n *\\n *\\n *\\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\\n * @param {WebGLRenderer} renderer The renderer\\n */\\nvar GPUComputationRenderer = function GPUComputationRenderer(sizeX, sizeY, renderer) {\\n  this.variables = [];\\n  this.currentTextureIndex = 0;\\n  var dataType = _three.FloatType;\\n  var scene = new _three.Scene();\\n  var camera = new _three.Camera();\\n  camera.position.z = 1;\\n  var passThruUniforms = {\\n    passThruTexture: {\\n      value: null\\n    }\\n  };\\n  var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\\n  var mesh = new _three.Mesh(new _three.PlaneGeometry(2, 2), passThruShader);\\n  scene.add(mesh);\\n\\n  this.setDataType = function (type) {\\n    dataType = type;\\n    return this;\\n  };\\n\\n  this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\\n    var material = this.createShaderMaterial(computeFragmentShader);\\n    var variable = {\\n      name: variableName,\\n      initialValueTexture: initialValueTexture,\\n      material: material,\\n      dependencies: null,\\n      renderTargets: [],\\n      wrapS: null,\\n      wrapT: null,\\n      minFilter: _three.NearestFilter,\\n      magFilter: _three.NearestFilter\\n    };\\n    this.variables.push(variable);\\n    return variable;\\n  };\\n\\n  this.setVariableDependencies = function (variable, dependencies) {\\n    variable.dependencies = dependencies;\\n  };\\n\\n  this.init = function () {\\n    if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('OES_texture_float') === false) {\\n      return 'No OES_texture_float support for float textures.';\\n    }\\n\\n    if (renderer.capabilities.maxVertexTextures === 0) {\\n      return 'No support for vertex shader textures.';\\n    }\\n\\n    for (var i = 0; i < this.variables.length; i++) {\\n      var variable = this.variables[i]; // Creates rendertargets and initialize them with input texture\\n\\n      variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\\n      variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]); // Adds dependencies uniforms to the ShaderMaterial\\n\\n      var material = variable.material;\\n      var uniforms = material.uniforms;\\n\\n      if (variable.dependencies !== null) {\\n        for (var d = 0; d < variable.dependencies.length; d++) {\\n          var depVar = variable.dependencies[d];\\n\\n          if (depVar.name !== variable.name) {\\n            // Checks if variable exists\\n            var found = false;\\n\\n            for (var j = 0; j < this.variables.length; j++) {\\n              if (depVar.name === this.variables[j].name) {\\n                found = true;\\n                break;\\n              }\\n            }\\n\\n            if (!found) {\\n              return 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\\n            }\\n          }\\n\\n          uniforms[depVar.name] = {\\n            value: null\\n          };\\n          material.fragmentShader = '\\\\nuniform sampler2D ' + depVar.name + ';\\\\n' + material.fragmentShader;\\n        }\\n      }\\n    }\\n\\n    this.currentTextureIndex = 0;\\n    return null;\\n  };\\n\\n  this.compute = function () {\\n    var currentTextureIndex = this.currentTextureIndex;\\n    var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\\n\\n    for (var i = 0, il = this.variables.length; i < il; i++) {\\n      var variable = this.variables[i]; // Sets texture dependencies uniforms\\n\\n      if (variable.dependencies !== null) {\\n        var uniforms = variable.material.uniforms;\\n\\n        for (var d = 0, dl = variable.dependencies.length; d < dl; d++) {\\n          var depVar = variable.dependencies[d];\\n          uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\\n        }\\n      } // Performs the computation for this variable\\n\\n\\n      this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\\n    }\\n\\n    this.currentTextureIndex = nextTextureIndex;\\n  };\\n\\n  this.getCurrentRenderTarget = function (variable) {\\n    return variable.renderTargets[this.currentTextureIndex];\\n  };\\n\\n  this.getAlternateRenderTarget = function (variable) {\\n    return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\\n  };\\n\\n  function addResolutionDefine(materialShader) {\\n    materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + ' )';\\n  }\\n\\n  this.addResolutionDefine = addResolutionDefine; // The following functions can be used to compute things manually\\n\\n  function createShaderMaterial(computeFragmentShader, uniforms) {\\n    uniforms = uniforms || {};\\n    var material = new _three.ShaderMaterial({\\n      uniforms: uniforms,\\n      vertexShader: getPassThroughVertexShader(),\\n      fragmentShader: computeFragmentShader\\n    });\\n    addResolutionDefine(material);\\n    return material;\\n  }\\n\\n  this.createShaderMaterial = createShaderMaterial;\\n\\n  this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\\n    sizeXTexture = sizeXTexture || sizeX;\\n    sizeYTexture = sizeYTexture || sizeY;\\n    wrapS = wrapS || _three.ClampToEdgeWrapping;\\n    wrapT = wrapT || _three.ClampToEdgeWrapping;\\n    minFilter = minFilter || _three.NearestFilter;\\n    magFilter = magFilter || _three.NearestFilter;\\n    var renderTarget = new _three.WebGLRenderTarget(sizeXTexture, sizeYTexture, {\\n      wrapS: wrapS,\\n      wrapT: wrapT,\\n      minFilter: minFilter,\\n      magFilter: magFilter,\\n      format: _three.RGBAFormat,\\n      type: dataType,\\n      depthBuffer: false\\n    });\\n    return renderTarget;\\n  };\\n\\n  this.createTexture = function () {\\n    var data = new Float32Array(sizeX * sizeY * 4);\\n    return new _three.DataTexture(data, sizeX, sizeY, _three.RGBAFormat, _three.FloatType);\\n  };\\n\\n  this.renderTexture = function (input, output) {\\n    // Takes a texture, and render out in rendertarget\\n    // input = Texture\\n    // output = RenderTarget\\n    passThruUniforms.passThruTexture.value = input;\\n    this.doRenderTarget(passThruShader, output);\\n    passThruUniforms.passThruTexture.value = null;\\n  };\\n\\n  this.doRenderTarget = function (material, output) {\\n    var currentRenderTarget = renderer.getRenderTarget();\\n    mesh.material = material;\\n    renderer.setRenderTarget(output);\\n    renderer.render(scene, camera);\\n    mesh.material = passThruShader;\\n    renderer.setRenderTarget(currentRenderTarget);\\n  }; // Shaders\\n\\n\\n  function getPassThroughVertexShader() {\\n    return 'void main()\\t{\\\\n' + '\\\\n' + '\\tgl_Position = vec4( position, 1.0 );\\\\n' + '\\\\n' + '}\\\\n';\\n  }\\n\\n  function getPassThroughFragmentShader() {\\n    return 'uniform sampler2D passThruTexture;\\\\n' + '\\\\n' + 'void main() {\\\\n' + '\\\\n' + '\\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\\\n' + '\\\\n' + '\\tgl_FragColor = texture2D( passThruTexture, uv );\\\\n' + '\\\\n' + '}\\\\n';\\n  }\\n};\\n\\nexports.GPUComputationRenderer = GPUComputationRenderer;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"GPUComputationRenderer\",\"_three\",\"sizeX\",\"sizeY\",\"renderer\",\"addResolutionDefine\",\"materialShader\",\"defines\",\"resolution\",\"toFixed\",\"createShaderMaterial\",\"computeFragmentShader\",\"uniforms\",\"material\",\"ShaderMaterial\",\"vertexShader\",\"fragmentShader\",\"variables\",\"currentTextureIndex\",\"dataType\",\"FloatType\",\"scene\",\"Scene\",\"camera\",\"Camera\",\"position\",\"z\",\"passThruUniforms\",\"passThruTexture\",\"passThruShader\",\"mesh\",\"Mesh\",\"PlaneGeometry\",\"add\",\"setDataType\",\"this.setDataType\",\"type\",\"addVariable\",\"this.addVariable\",\"variableName\",\"initialValueTexture\",\"variable\",\"name\",\"dependencies\",\"renderTargets\",\"wrapS\",\"wrapT\",\"minFilter\",\"NearestFilter\",\"magFilter\",\"push\",\"setVariableDependencies\",\"this.setVariableDependencies\",\"init\",\"this.init\",\"capabilities\",\"isWebGL2\",\"extensions\",\"has\",\"maxVertexTextures\",\"i\",\"length\",\"createRenderTarget\",\"renderTexture\",\"d\",\"depVar\",\"found\",\"j\",\"compute\",\"this.compute\",\"nextTextureIndex\",\"il\",\"dl\",\"texture\",\"doRenderTarget\",\"getCurrentRenderTarget\",\"this.getCurrentRenderTarget\",\"getAlternateRenderTarget\",\"this.getAlternateRenderTarget\",\"this.createRenderTarget\",\"sizeXTexture\",\"sizeYTexture\",\"ClampToEdgeWrapping\",\"renderTarget\",\"WebGLRenderTarget\",\"format\",\"RGBAFormat\",\"depthBuffer\",\"createTexture\",\"this.createTexture\",\"data\",\"Float32Array\",\"DataTexture\",\"this.renderTexture\",\"input\",\"output\",\"this.doRenderTarget\",\"currentRenderTarget\",\"getRenderTarget\",\"setRenderTarget\",\"render\"]\n}\n"]