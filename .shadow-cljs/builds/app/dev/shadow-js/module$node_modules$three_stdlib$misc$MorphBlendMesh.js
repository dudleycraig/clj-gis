["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/misc/MorphBlendMesh.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$misc$MorphBlendMesh=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.MorphBlendMesh=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(geometry,material){_three.Mesh.call(this,geometry,material);this.animationsMap={};this.animationsList=[];geometry=Object.keys(this.morphTargetDictionary).length;this.createAnimation(\"__default\",0,geometry-1,geometry/1);this.setAnimationWeight(\"__default\",\n1)};exports.MorphBlendMesh=global;global.prototype=Object.assign(Object.create(_three.Mesh.prototype),{constructor:global,createAnimation:function(name,start,end,fps){start={start,end,length:end-start+1,fps,duration:(end-start)/fps,lastFrame:0,currentFrame:0,active:!1,time:0,direction:1,weight:1,directionBackwards:!1,mirroredLoop:!1};this.animationsMap[name]=start;this.animationsList.push(start)},autoCreateAnimations:function(fps){var pattern=/([a-z]+)_?(\\d+)/i,firstAnimation,frameRanges={},i=0,key;\nfor(key in this.morphTargetDictionary){var chunks=key.match(pattern);if(chunks&&1<chunks.length){chunks=chunks[1];frameRanges[chunks]||(frameRanges[chunks]={start:Infinity,end:-Infinity});var range=frameRanges[chunks];i<range.start&&(range.start=i);i>range.end&&(range.end=i);firstAnimation||(firstAnimation=chunks)}i++}for(var _name in frameRanges)range=frameRanges[_name],this.createAnimation(_name,range.start,range.end,fps);this.firstAnimation=firstAnimation},setAnimationDirectionForward:function(name){if(name=\nthis.animationsMap[name])name.direction=1,name.directionBackwards=!1},setAnimationDirectionBackward:function(name){if(name=this.animationsMap[name])name.direction=-1,name.directionBackwards=!0},setAnimationFPS:function(name,fps){if(name=this.animationsMap[name])name.fps=fps,name.duration=(name.end-name.start)/name.fps},setAnimationDuration:function(name,duration){if(name=this.animationsMap[name])name.duration=duration,name.fps=(name.end-name.start)/name.duration},setAnimationWeight:function(name,\nweight){if(name=this.animationsMap[name])name.weight=weight},setAnimationTime:function(name,time){if(name=this.animationsMap[name])name.time=time},getAnimationTime:function(name){var time=0;if(name=this.animationsMap[name])time=name.time;return time},getAnimationDuration:function(name){var duration=-1;if(name=this.animationsMap[name])duration=name.duration;return duration},playAnimation:function(name){var animation=this.animationsMap[name];animation?(animation.time=0,animation.active=!0):console.warn(\"THREE.MorphBlendMesh: animation[\"+\nname+\"] undefined in .playAnimation()\")},stopAnimation:function(name){if(name=this.animationsMap[name])name.active=!1},update:function(delta){for(var i=0,il=this.animationsList.length;i<il;i++){var animation=this.animationsList[i];if(animation.active){var frameTime=animation.duration/animation.length;animation.time+=animation.direction*delta;if(animation.mirroredLoop){if(animation.time>animation.duration||0>animation.time)animation.direction*=-1,animation.time>animation.duration&&(animation.time=\nanimation.duration,animation.directionBackwards=!0),0>animation.time&&(animation.time=0,animation.directionBackwards=!1)}else animation.time%=animation.duration,0>animation.time&&(animation.time+=animation.duration);var keyframe=animation.start+_three.MathUtils.clamp(Math.floor(animation.time/frameTime),0,animation.length-1),weight=animation.weight;keyframe!==animation.currentFrame&&(this.morphTargetInfluences[animation.lastFrame]=0,this.morphTargetInfluences[animation.currentFrame]=1*weight,this.morphTargetInfluences[keyframe]=\n0,animation.lastFrame=animation.currentFrame,animation.currentFrame=keyframe);frameTime=animation.time%frameTime/frameTime;animation.directionBackwards&&(frameTime=1-frameTime);animation.currentFrame!==animation.lastFrame?(this.morphTargetInfluences[animation.currentFrame]=frameTime*weight,this.morphTargetInfluences[animation.lastFrame]=(1-frameTime)*weight):this.morphTargetInfluences[animation.currentFrame]=weight}}}})}","~:source","shadow$provide[\"module$node_modules$three_stdlib$misc$MorphBlendMesh\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MorphBlendMesh = void 0;\n\nvar _three = require(\"three\");\n\nvar MorphBlendMesh = function MorphBlendMesh(geometry, material) {\n  _three.Mesh.call(this, geometry, material);\n\n  this.animationsMap = {};\n  this.animationsList = []; // prepare default animation\n  // (all frames played together in 1 second)\n\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\n  var name = '__default';\n  var startFrame = 0;\n  var endFrame = numFrames - 1;\n  var fps = numFrames / 1;\n  this.createAnimation(name, startFrame, endFrame, fps);\n  this.setAnimationWeight(name, 1);\n};\n\nexports.MorphBlendMesh = MorphBlendMesh;\nMorphBlendMesh.prototype = Object.assign(Object.create(_three.Mesh.prototype), {\n  constructor: MorphBlendMesh,\n  createAnimation: function createAnimation(name, start, end, fps) {\n    var animation = {\n      start: start,\n      end: end,\n      length: end - start + 1,\n      fps: fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  },\n  autoCreateAnimations: function autoCreateAnimations(fps) {\n    var pattern = /([a-z]+)_?(\\d+)/i;\n    var firstAnimation,\n        frameRanges = {};\n    var i = 0;\n\n    for (var key in this.morphTargetDictionary) {\n      var chunks = key.match(pattern);\n\n      if (chunks && chunks.length > 1) {\n        var name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        var range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n\n      i++;\n    }\n\n    for (var _name in frameRanges) {\n      var range = frameRanges[_name];\n      this.createAnimation(_name, range.start, range.end, fps);\n    }\n\n    this.firstAnimation = firstAnimation;\n  },\n  setAnimationDirectionForward: function setAnimationDirectionForward(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  },\n  setAnimationDirectionBackward: function setAnimationDirectionBackward(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  },\n  setAnimationFPS: function setAnimationFPS(name, fps) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  },\n  setAnimationDuration: function setAnimationDuration(name, duration) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  },\n  setAnimationWeight: function setAnimationWeight(name, weight) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.weight = weight;\n    }\n  },\n  setAnimationTime: function setAnimationTime(name, time) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = time;\n    }\n  },\n  getAnimationTime: function getAnimationTime(name) {\n    var time = 0;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      time = animation.time;\n    }\n\n    return time;\n  },\n  getAnimationDuration: function getAnimationDuration(name) {\n    var duration = -1;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      duration = animation.duration;\n    }\n\n    return duration;\n  },\n  playAnimation: function playAnimation(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n    }\n  },\n  stopAnimation: function stopAnimation(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.active = false;\n    }\n  },\n  update: function update(delta) {\n    for (var i = 0, il = this.animationsList.length; i < il; i++) {\n      var animation = this.animationsList[i];\n      if (!animation.active) continue;\n      var frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n\n      var keyframe = animation.start + _three.MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n\n      var weight = animation.weight;\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n\n      var mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n});\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["MorphBlendMesh","currentFrame","prototype","setAnimationTime","setAnimationDuration","setAnimationDirectionBackward","animationsList","autoCreateAnimations","__esModule","createAnimation","update","setAnimationFPS","playAnimation","setAnimationWeight","animationsMap","value","stopAnimation","direction","start","lastFrame","time","length","duration","firstAnimation","directionBackwards","getAnimationDuration","fps","setAnimationDirectionForward","getAnimationTime","active","mirroredLoop","end","weight","constructor"]],"~:compiled-at",1630917515086,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$misc$MorphBlendMesh.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/misc/MorphBlendMesh.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$misc$MorphBlendMesh\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.MorphBlendMesh = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar MorphBlendMesh = function MorphBlendMesh(geometry, material) {\\n  _three.Mesh.call(this, geometry, material);\\n\\n  this.animationsMap = {};\\n  this.animationsList = []; // prepare default animation\\n  // (all frames played together in 1 second)\\n\\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\\n  var name = '__default';\\n  var startFrame = 0;\\n  var endFrame = numFrames - 1;\\n  var fps = numFrames / 1;\\n  this.createAnimation(name, startFrame, endFrame, fps);\\n  this.setAnimationWeight(name, 1);\\n};\\n\\nexports.MorphBlendMesh = MorphBlendMesh;\\nMorphBlendMesh.prototype = Object.assign(Object.create(_three.Mesh.prototype), {\\n  constructor: MorphBlendMesh,\\n  createAnimation: function createAnimation(name, start, end, fps) {\\n    var animation = {\\n      start: start,\\n      end: end,\\n      length: end - start + 1,\\n      fps: fps,\\n      duration: (end - start) / fps,\\n      lastFrame: 0,\\n      currentFrame: 0,\\n      active: false,\\n      time: 0,\\n      direction: 1,\\n      weight: 1,\\n      directionBackwards: false,\\n      mirroredLoop: false\\n    };\\n    this.animationsMap[name] = animation;\\n    this.animationsList.push(animation);\\n  },\\n  autoCreateAnimations: function autoCreateAnimations(fps) {\\n    var pattern = /([a-z]+)_?(\\\\d+)/i;\\n    var firstAnimation,\\n        frameRanges = {};\\n    var i = 0;\\n\\n    for (var key in this.morphTargetDictionary) {\\n      var chunks = key.match(pattern);\\n\\n      if (chunks && chunks.length > 1) {\\n        var name = chunks[1];\\n        if (!frameRanges[name]) frameRanges[name] = {\\n          start: Infinity,\\n          end: -Infinity\\n        };\\n        var range = frameRanges[name];\\n        if (i < range.start) range.start = i;\\n        if (i > range.end) range.end = i;\\n        if (!firstAnimation) firstAnimation = name;\\n      }\\n\\n      i++;\\n    }\\n\\n    for (var _name in frameRanges) {\\n      var range = frameRanges[_name];\\n      this.createAnimation(_name, range.start, range.end, fps);\\n    }\\n\\n    this.firstAnimation = firstAnimation;\\n  },\\n  setAnimationDirectionForward: function setAnimationDirectionForward(name) {\\n    var animation = this.animationsMap[name];\\n\\n    if (animation) {\\n      animation.direction = 1;\\n      animation.directionBackwards = false;\\n    }\\n  },\\n  setAnimationDirectionBackward: function setAnimationDirectionBackward(name) {\\n    var animation = this.animationsMap[name];\\n\\n    if (animation) {\\n      animation.direction = -1;\\n      animation.directionBackwards = true;\\n    }\\n  },\\n  setAnimationFPS: function setAnimationFPS(name, fps) {\\n    var animation = this.animationsMap[name];\\n\\n    if (animation) {\\n      animation.fps = fps;\\n      animation.duration = (animation.end - animation.start) / animation.fps;\\n    }\\n  },\\n  setAnimationDuration: function setAnimationDuration(name, duration) {\\n    var animation = this.animationsMap[name];\\n\\n    if (animation) {\\n      animation.duration = duration;\\n      animation.fps = (animation.end - animation.start) / animation.duration;\\n    }\\n  },\\n  setAnimationWeight: function setAnimationWeight(name, weight) {\\n    var animation = this.animationsMap[name];\\n\\n    if (animation) {\\n      animation.weight = weight;\\n    }\\n  },\\n  setAnimationTime: function setAnimationTime(name, time) {\\n    var animation = this.animationsMap[name];\\n\\n    if (animation) {\\n      animation.time = time;\\n    }\\n  },\\n  getAnimationTime: function getAnimationTime(name) {\\n    var time = 0;\\n    var animation = this.animationsMap[name];\\n\\n    if (animation) {\\n      time = animation.time;\\n    }\\n\\n    return time;\\n  },\\n  getAnimationDuration: function getAnimationDuration(name) {\\n    var duration = -1;\\n    var animation = this.animationsMap[name];\\n\\n    if (animation) {\\n      duration = animation.duration;\\n    }\\n\\n    return duration;\\n  },\\n  playAnimation: function playAnimation(name) {\\n    var animation = this.animationsMap[name];\\n\\n    if (animation) {\\n      animation.time = 0;\\n      animation.active = true;\\n    } else {\\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\\n    }\\n  },\\n  stopAnimation: function stopAnimation(name) {\\n    var animation = this.animationsMap[name];\\n\\n    if (animation) {\\n      animation.active = false;\\n    }\\n  },\\n  update: function update(delta) {\\n    for (var i = 0, il = this.animationsList.length; i < il; i++) {\\n      var animation = this.animationsList[i];\\n      if (!animation.active) continue;\\n      var frameTime = animation.duration / animation.length;\\n      animation.time += animation.direction * delta;\\n\\n      if (animation.mirroredLoop) {\\n        if (animation.time > animation.duration || animation.time < 0) {\\n          animation.direction *= -1;\\n\\n          if (animation.time > animation.duration) {\\n            animation.time = animation.duration;\\n            animation.directionBackwards = true;\\n          }\\n\\n          if (animation.time < 0) {\\n            animation.time = 0;\\n            animation.directionBackwards = false;\\n          }\\n        }\\n      } else {\\n        animation.time = animation.time % animation.duration;\\n        if (animation.time < 0) animation.time += animation.duration;\\n      }\\n\\n      var keyframe = animation.start + _three.MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\\n\\n      var weight = animation.weight;\\n\\n      if (keyframe !== animation.currentFrame) {\\n        this.morphTargetInfluences[animation.lastFrame] = 0;\\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\\n        this.morphTargetInfluences[keyframe] = 0;\\n        animation.lastFrame = animation.currentFrame;\\n        animation.currentFrame = keyframe;\\n      }\\n\\n      var mix = animation.time % frameTime / frameTime;\\n      if (animation.directionBackwards) mix = 1 - mix;\\n\\n      if (animation.currentFrame !== animation.lastFrame) {\\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\\n      } else {\\n        this.morphTargetInfluences[animation.currentFrame] = weight;\\n      }\\n    }\\n  }\\n});\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"MorphBlendMesh\",\"_three\",\"geometry\",\"material\",\"Mesh\",\"call\",\"animationsMap\",\"animationsList\",\"numFrames\",\"keys\",\"morphTargetDictionary\",\"length\",\"createAnimation\",\"name\",\"startFrame\",\"setAnimationWeight\",\"prototype\",\"assign\",\"create\",\"constructor\",\"start\",\"end\",\"fps\",\"animation\",\"duration\",\"lastFrame\",\"currentFrame\",\"active\",\"time\",\"direction\",\"weight\",\"directionBackwards\",\"mirroredLoop\",\"push\",\"autoCreateAnimations\",\"pattern\",\"firstAnimation\",\"frameRanges\",\"i\",\"key\",\"chunks\",\"match\",\"Infinity\",\"range\",\"_name\",\"setAnimationDirectionForward\",\"setAnimationDirectionBackward\",\"setAnimationFPS\",\"setAnimationDuration\",\"setAnimationTime\",\"getAnimationTime\",\"getAnimationDuration\",\"playAnimation\",\"console\",\"warn\",\"stopAnimation\",\"update\",\"delta\",\"il\",\"frameTime\",\"keyframe\",\"MathUtils\",\"clamp\",\"Math\",\"floor\",\"morphTargetInfluences\",\"mix\"]\n}\n"]