["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$postprocessing$AdaptiveToneMappingPass=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.AdaptiveToneMappingPass=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),_Pass=require(\"module$node_modules$three_stdlib$postprocessing$Pass\"),_CopyShader=require(\"module$node_modules$three_stdlib$shaders$CopyShader\"),_LuminosityShader=require(\"module$node_modules$three_stdlib$shaders$LuminosityShader\"),\n_ToneMapShader=require(\"module$node_modules$three_stdlib$shaders$ToneMapShader\");global=function(adaptive,resolution){this.resolution=void 0!==resolution?resolution:256;this.needsInit=!0;this.adaptive=void 0!==adaptive?!!adaptive:!0;this.currentLuminanceRT=this.previousLuminanceRT=this.luminanceRT=null;void 0===_CopyShader.CopyShader&&console.error(\"THREE.AdaptiveToneMappingPass relies on CopyShader\");adaptive=_CopyShader.CopyShader;this.copyUniforms=_three.UniformsUtils.clone(adaptive.uniforms);\nthis.materialCopy=new _three.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:adaptive.vertexShader,fragmentShader:adaptive.fragmentShader,blending:_three.NoBlending,depthTest:!1});void 0===_LuminosityShader.LuminosityShader&&console.error(\"THREE.AdaptiveToneMappingPass relies on LuminosityShader\");this.materialLuminance=new _three.ShaderMaterial({uniforms:_three.UniformsUtils.clone(_LuminosityShader.LuminosityShader.uniforms),vertexShader:_LuminosityShader.LuminosityShader.vertexShader,fragmentShader:_LuminosityShader.LuminosityShader.fragmentShader,\nblending:_three.NoBlending});this.adaptLuminanceShader={defines:{MIP_LEVEL_1X1:(Math.log(this.resolution)/Math.log(2)).toFixed(1)},uniforms:{lastLum:{value:null},currentLum:{value:null},minLuminance:{value:.01},delta:{value:.016},tau:{value:1}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"varying vec2 vUv;\\nuniform sampler2D lastLum;\\nuniform sampler2D currentLum;\\nuniform float minLuminance;\\nuniform float delta;\\nuniform float tau;\\nvoid main() {\\n\\tvec4 lastLum \\x3d texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\\n\\tvec4 currentLum \\x3d texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\\n\\tfloat fLastLum \\x3d max( minLuminance, lastLum.r );\\n\\tfloat fCurrentLum \\x3d max( minLuminance, currentLum.r );\\n\\tfCurrentLum *\\x3d fCurrentLum;\\n\\tfloat fAdaptedLum \\x3d fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\\n\\tgl_FragColor.r \\x3d fAdaptedLum;\\n}\"};\nthis.materialAdaptiveLum=new _three.ShaderMaterial({uniforms:_three.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),vertexShader:this.adaptLuminanceShader.vertexShader,fragmentShader:this.adaptLuminanceShader.fragmentShader,defines:Object.assign({},this.adaptLuminanceShader.defines),blending:_three.NoBlending});void 0===_ToneMapShader.ToneMapShader&&console.error(\"THREE.AdaptiveToneMappingPass relies on ToneMapShader\");this.materialToneMap=new _three.ShaderMaterial({uniforms:_three.UniformsUtils.clone(_ToneMapShader.ToneMapShader.uniforms),\nvertexShader:_ToneMapShader.ToneMapShader.vertexShader,fragmentShader:_ToneMapShader.ToneMapShader.fragmentShader,blending:_three.NoBlending});this.fsQuad=new _Pass.FullScreenQuad(null)};exports.AdaptiveToneMappingPass=global;global.prototype=Object.assign(Object.create(_Pass.Pass.prototype),{constructor:global,render:function(renderer,writeBuffer,readBuffer,deltaTime){this.needsInit&&(this.reset(renderer),this.luminanceRT.texture.type=readBuffer.texture.type,this.previousLuminanceRT.texture.type=\nreadBuffer.texture.type,this.currentLuminanceRT.texture.type=readBuffer.texture.type,this.needsInit=!1);this.adaptive&&(this.fsQuad.material=this.materialLuminance,this.materialLuminance.uniforms.tDiffuse.value=readBuffer.texture,renderer.setRenderTarget(this.currentLuminanceRT),this.fsQuad.render(renderer),this.fsQuad.material=this.materialAdaptiveLum,this.materialAdaptiveLum.uniforms.delta.value=deltaTime,this.materialAdaptiveLum.uniforms.lastLum.value=this.previousLuminanceRT.texture,this.materialAdaptiveLum.uniforms.currentLum.value=\nthis.currentLuminanceRT.texture,renderer.setRenderTarget(this.luminanceRT),this.fsQuad.render(renderer),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.luminanceRT.texture,renderer.setRenderTarget(this.previousLuminanceRT),this.fsQuad.render(renderer));this.fsQuad.material=this.materialToneMap;this.materialToneMap.uniforms.tDiffuse.value=readBuffer.texture;this.renderToScreen?renderer.setRenderTarget(null):(renderer.setRenderTarget(writeBuffer),this.clear&&renderer.clear());\nthis.fsQuad.render(renderer)},reset:function(){this.luminanceRT&&this.luminanceRT.dispose();this.currentLuminanceRT&&this.currentLuminanceRT.dispose();this.previousLuminanceRT&&this.previousLuminanceRT.dispose();var pars={minFilter:_three.LinearFilter,magFilter:_three.LinearFilter,format:_three.RGBAFormat};this.luminanceRT=new _three.WebGLRenderTarget(this.resolution,this.resolution,pars);this.luminanceRT.texture.name=\"AdaptiveToneMappingPass.l\";this.luminanceRT.texture.generateMipmaps=!1;this.previousLuminanceRT=\nnew _three.WebGLRenderTarget(this.resolution,this.resolution,pars);this.previousLuminanceRT.texture.name=\"AdaptiveToneMappingPass.pl\";this.previousLuminanceRT.texture.generateMipmaps=!1;pars.minFilter=_three.LinearMipmapLinearFilter;pars.generateMipmaps=!0;this.currentLuminanceRT=new _three.WebGLRenderTarget(this.resolution,this.resolution,pars);this.currentLuminanceRT.texture.name=\"AdaptiveToneMappingPass.cl\";this.adaptive&&(this.materialToneMap.defines.ADAPTED_LUMINANCE=\"\",this.materialToneMap.uniforms.luminanceMap.value=\nthis.luminanceRT.texture);this.fsQuad.material=new _three.MeshBasicMaterial({color:7829367});this.materialLuminance.needsUpdate=!0;this.materialAdaptiveLum.needsUpdate=!0;this.materialToneMap.needsUpdate=!0},setAdaptive:function(adaptive){adaptive?(this.adaptive=!0,this.materialToneMap.defines.ADAPTED_LUMINANCE=\"\",this.materialToneMap.uniforms.luminanceMap.value=this.luminanceRT.texture):(this.adaptive=!1,delete this.materialToneMap.defines.ADAPTED_LUMINANCE,this.materialToneMap.uniforms.luminanceMap.value=\nnull);this.materialToneMap.needsUpdate=!0},setAdaptionRate:function(rate){rate&&(this.materialAdaptiveLum.uniforms.tau.value=Math.abs(rate))},setMinLuminance:function(minLum){minLum&&(this.materialToneMap.uniforms.minLuminance.value=minLum,this.materialAdaptiveLum.uniforms.minLuminance.value=minLum)},setMaxLuminance:function(maxLum){maxLum&&(this.materialToneMap.uniforms.maxLuminance.value=maxLum)},setAverageLuminance:function(avgLum){avgLum&&(this.materialToneMap.uniforms.averageLuminance.value=\navgLum)},setMiddleGrey:function(middleGrey){middleGrey&&(this.materialToneMap.uniforms.middleGrey.value=middleGrey)},dispose:function(){this.luminanceRT&&this.luminanceRT.dispose();this.previousLuminanceRT&&this.previousLuminanceRT.dispose();this.currentLuminanceRT&&this.currentLuminanceRT.dispose();this.materialLuminance&&this.materialLuminance.dispose();this.materialAdaptiveLum&&this.materialAdaptiveLum.dispose();this.materialCopy&&this.materialCopy.dispose();this.materialToneMap&&this.materialToneMap.dispose()}})}","~:source","shadow$provide[\"module$node_modules$three_stdlib$postprocessing$AdaptiveToneMappingPass\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AdaptiveToneMappingPass = void 0;\n\nvar _three = require(\"three\");\n\nvar _Pass = require(\"./Pass.js\");\n\nvar _CopyShader = require(\"../shaders/CopyShader.js\");\n\nvar _LuminosityShader = require(\"../shaders/LuminosityShader.js\");\n\nvar _ToneMapShader = require(\"../shaders/ToneMapShader.js\");\n\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\nvar AdaptiveToneMappingPass = function AdaptiveToneMappingPass(adaptive, resolution) {\n  this.resolution = resolution !== undefined ? resolution : 256;\n  this.needsInit = true;\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\n  this.luminanceRT = null;\n  this.previousLuminanceRT = null;\n  this.currentLuminanceRT = null;\n  if (_CopyShader.CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\n  var copyShader = _CopyShader.CopyShader;\n  this.copyUniforms = _three.UniformsUtils.clone(copyShader.uniforms);\n  this.materialCopy = new _three.ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: _three.NoBlending,\n    depthTest: false\n  });\n  if (_LuminosityShader.LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\n  this.materialLuminance = new _three.ShaderMaterial({\n    uniforms: _three.UniformsUtils.clone(_LuminosityShader.LuminosityShader.uniforms),\n    vertexShader: _LuminosityShader.LuminosityShader.vertexShader,\n    fragmentShader: _LuminosityShader.LuminosityShader.fragmentShader,\n    blending: _three.NoBlending\n  });\n  this.adaptLuminanceShader = {\n    defines: {\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n    },\n    uniforms: {\n      lastLum: {\n        value: null\n      },\n      currentLum: {\n        value: null\n      },\n      minLuminance: {\n        value: 0.01\n      },\n      delta: {\n        value: 0.016\n      },\n      tau: {\n        value: 1.0\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\tfloat fLastLum = max( minLuminance, lastLum.r );', '\tfloat fCurrentLum = max( minLuminance, currentLum.r );', //The adaption seems to work better in extreme lighting differences\n    //if the input luminance is squared.\n    '\tfCurrentLum *= fCurrentLum;', // Adapt the luminance using Pattanaik's technique\n    '\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));', // \"fAdaptedLum = sqrt(fAdaptedLum);\",\n    '\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\n')\n  };\n  this.materialAdaptiveLum = new _three.ShaderMaterial({\n    uniforms: _three.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n    vertexShader: this.adaptLuminanceShader.vertexShader,\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\n    blending: _three.NoBlending\n  });\n  if (_ToneMapShader.ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\n  this.materialToneMap = new _three.ShaderMaterial({\n    uniforms: _three.UniformsUtils.clone(_ToneMapShader.ToneMapShader.uniforms),\n    vertexShader: _ToneMapShader.ToneMapShader.vertexShader,\n    fragmentShader: _ToneMapShader.ToneMapShader.fragmentShader,\n    blending: _three.NoBlending\n  });\n  this.fsQuad = new _Pass.FullScreenQuad(null);\n};\n\nexports.AdaptiveToneMappingPass = AdaptiveToneMappingPass;\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {\n  constructor: AdaptiveToneMappingPass,\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime\n  /*, maskActive*/\n  ) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  },\n  reset: function reset() {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    var pars = {\n      minFilter: _three.LinearFilter,\n      magFilter: _three.LinearFilter,\n      format: _three.RGBAFormat\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n    this.luminanceRT = new _three.WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new _three.WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    pars.minFilter = _three.LinearMipmapLinearFilter;\n    pars.generateMipmaps = true;\n    this.currentLuminanceRT = new _three.WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\n\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } //Put something in the adaptive luminance texture so that the scene can render initially\n\n\n    this.fsQuad.material = new _three.MeshBasicMaterial({\n      color: 0x777777\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  },\n  setAdaptive: function setAdaptive(adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n\n    this.materialToneMap.needsUpdate = true;\n  },\n  setAdaptionRate: function setAdaptionRate(rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  },\n  setMinLuminance: function setMinLuminance(minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  },\n  setMaxLuminance: function setMaxLuminance(maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  },\n  setAverageLuminance: function setAverageLuminance(avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  },\n  setMiddleGrey: function setMiddleGrey(middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  },\n  dispose: function dispose() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n});\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_stdlib$shaders$CopyShader","~$shadow.js","~$module$node_modules$three_stdlib$postprocessing$Pass","~$module$node_modules$three_stdlib$shaders$ToneMapShader","~$module$node_modules$three_stdlib$shaders$LuminosityShader"]],"~:properties",["^5",["fragmentShader","setAverageLuminance","needsInit","materialLuminance","currentLuminanceRT","setAdaptionRate","depthTest","blending","AdaptiveToneMappingPass","needsUpdate","prototype","setAdaptive","materialCopy","delta","__esModule","lastLum","dispose","reset","defines","currentLum","vertexShader","name","value","previousLuminanceRT","adaptLuminanceShader","fsQuad","setMaxLuminance","magFilter","luminanceRT","tau","copyUniforms","materialToneMap","adaptive","setMiddleGrey","type","render","MIP_LEVEL_1X1","materialAdaptiveLum","minLuminance","generateMipmaps","uniforms","minFilter","color","setMinLuminance","format","constructor","resolution","material"]],"~:compiled-at",1630917515513,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$postprocessing$AdaptiveToneMappingPass.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$postprocessing$AdaptiveToneMappingPass\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.AdaptiveToneMappingPass = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _Pass = require(\\\"./Pass.js\\\");\\n\\nvar _CopyShader = require(\\\"../shaders/CopyShader.js\\\");\\n\\nvar _LuminosityShader = require(\\\"../shaders/LuminosityShader.js\\\");\\n\\nvar _ToneMapShader = require(\\\"../shaders/ToneMapShader.js\\\");\\n\\n/**\\n * Generate a texture that represents the luminosity of the current scene, adapted over time\\n * to simulate the optic nerve responding to the amount of light it is receiving.\\n * Based on a GDC2007 presentation by Wolfgang Engel titled \\\"Post-Processing Pipeline\\\"\\n *\\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\\n */\\nvar AdaptiveToneMappingPass = function AdaptiveToneMappingPass(adaptive, resolution) {\\n  this.resolution = resolution !== undefined ? resolution : 256;\\n  this.needsInit = true;\\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\\n  this.luminanceRT = null;\\n  this.previousLuminanceRT = null;\\n  this.currentLuminanceRT = null;\\n  if (_CopyShader.CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\\n  var copyShader = _CopyShader.CopyShader;\\n  this.copyUniforms = _three.UniformsUtils.clone(copyShader.uniforms);\\n  this.materialCopy = new _three.ShaderMaterial({\\n    uniforms: this.copyUniforms,\\n    vertexShader: copyShader.vertexShader,\\n    fragmentShader: copyShader.fragmentShader,\\n    blending: _three.NoBlending,\\n    depthTest: false\\n  });\\n  if (_LuminosityShader.LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\\n  this.materialLuminance = new _three.ShaderMaterial({\\n    uniforms: _three.UniformsUtils.clone(_LuminosityShader.LuminosityShader.uniforms),\\n    vertexShader: _LuminosityShader.LuminosityShader.vertexShader,\\n    fragmentShader: _LuminosityShader.LuminosityShader.fragmentShader,\\n    blending: _three.NoBlending\\n  });\\n  this.adaptLuminanceShader = {\\n    defines: {\\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\\n    },\\n    uniforms: {\\n      lastLum: {\\n        value: null\\n      },\\n      currentLum: {\\n        value: null\\n      },\\n      minLuminance: {\\n        value: 0.01\\n      },\\n      delta: {\\n        value: 0.016\\n      },\\n      tau: {\\n        value: 1.0\\n      }\\n    },\\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\\tfloat fLastLum = max( minLuminance, lastLum.r );', '\\tfloat fCurrentLum = max( minLuminance, currentLum.r );', //The adaption seems to work better in extreme lighting differences\\n    //if the input luminance is squared.\\n    '\\tfCurrentLum *= fCurrentLum;', // Adapt the luminance using Pattanaik's technique\\n    '\\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));', // \\\"fAdaptedLum = sqrt(fAdaptedLum);\\\",\\n    '\\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\\\n')\\n  };\\n  this.materialAdaptiveLum = new _three.ShaderMaterial({\\n    uniforms: _three.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\\n    vertexShader: this.adaptLuminanceShader.vertexShader,\\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\\n    blending: _three.NoBlending\\n  });\\n  if (_ToneMapShader.ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\\n  this.materialToneMap = new _three.ShaderMaterial({\\n    uniforms: _three.UniformsUtils.clone(_ToneMapShader.ToneMapShader.uniforms),\\n    vertexShader: _ToneMapShader.ToneMapShader.vertexShader,\\n    fragmentShader: _ToneMapShader.ToneMapShader.fragmentShader,\\n    blending: _three.NoBlending\\n  });\\n  this.fsQuad = new _Pass.FullScreenQuad(null);\\n};\\n\\nexports.AdaptiveToneMappingPass = AdaptiveToneMappingPass;\\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(_Pass.Pass.prototype), {\\n  constructor: AdaptiveToneMappingPass,\\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime\\n  /*, maskActive*/\\n  ) {\\n    if (this.needsInit) {\\n      this.reset(renderer);\\n      this.luminanceRT.texture.type = readBuffer.texture.type;\\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\\n      this.needsInit = false;\\n    }\\n\\n    if (this.adaptive) {\\n      //Render the luminance of the current scene into a render target with mipmapping enabled\\n      this.fsQuad.material = this.materialLuminance;\\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\\n      renderer.setRenderTarget(this.currentLuminanceRT);\\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\\n      //adapt the luminance over time.\\n\\n      this.fsQuad.material = this.materialAdaptiveLum;\\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\\n      renderer.setRenderTarget(this.luminanceRT);\\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\\n\\n      this.fsQuad.material = this.materialCopy;\\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\\n      renderer.setRenderTarget(this.previousLuminanceRT);\\n      this.fsQuad.render(renderer);\\n    }\\n\\n    this.fsQuad.material = this.materialToneMap;\\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\\n\\n    if (this.renderToScreen) {\\n      renderer.setRenderTarget(null);\\n      this.fsQuad.render(renderer);\\n    } else {\\n      renderer.setRenderTarget(writeBuffer);\\n      if (this.clear) renderer.clear();\\n      this.fsQuad.render(renderer);\\n    }\\n  },\\n  reset: function reset() {\\n    // render targets\\n    if (this.luminanceRT) {\\n      this.luminanceRT.dispose();\\n    }\\n\\n    if (this.currentLuminanceRT) {\\n      this.currentLuminanceRT.dispose();\\n    }\\n\\n    if (this.previousLuminanceRT) {\\n      this.previousLuminanceRT.dispose();\\n    }\\n\\n    var pars = {\\n      minFilter: _three.LinearFilter,\\n      magFilter: _three.LinearFilter,\\n      format: _three.RGBAFormat\\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\\n\\n    this.luminanceRT = new _three.WebGLRenderTarget(this.resolution, this.resolution, pars);\\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\\n    this.luminanceRT.texture.generateMipmaps = false;\\n    this.previousLuminanceRT = new _three.WebGLRenderTarget(this.resolution, this.resolution, pars);\\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\\n\\n    pars.minFilter = _three.LinearMipmapLinearFilter;\\n    pars.generateMipmaps = true;\\n    this.currentLuminanceRT = new _three.WebGLRenderTarget(this.resolution, this.resolution, pars);\\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\\n\\n    if (this.adaptive) {\\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\\n    } //Put something in the adaptive luminance texture so that the scene can render initially\\n\\n\\n    this.fsQuad.material = new _three.MeshBasicMaterial({\\n      color: 0x777777\\n    });\\n    this.materialLuminance.needsUpdate = true;\\n    this.materialAdaptiveLum.needsUpdate = true;\\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\\n  },\\n  setAdaptive: function setAdaptive(adaptive) {\\n    if (adaptive) {\\n      this.adaptive = true;\\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\\n    } else {\\n      this.adaptive = false;\\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\\n      this.materialToneMap.uniforms.luminanceMap.value = null;\\n    }\\n\\n    this.materialToneMap.needsUpdate = true;\\n  },\\n  setAdaptionRate: function setAdaptionRate(rate) {\\n    if (rate) {\\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\\n    }\\n  },\\n  setMinLuminance: function setMinLuminance(minLum) {\\n    if (minLum) {\\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\\n    }\\n  },\\n  setMaxLuminance: function setMaxLuminance(maxLum) {\\n    if (maxLum) {\\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\\n    }\\n  },\\n  setAverageLuminance: function setAverageLuminance(avgLum) {\\n    if (avgLum) {\\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\\n    }\\n  },\\n  setMiddleGrey: function setMiddleGrey(middleGrey) {\\n    if (middleGrey) {\\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\\n    }\\n  },\\n  dispose: function dispose() {\\n    if (this.luminanceRT) {\\n      this.luminanceRT.dispose();\\n    }\\n\\n    if (this.previousLuminanceRT) {\\n      this.previousLuminanceRT.dispose();\\n    }\\n\\n    if (this.currentLuminanceRT) {\\n      this.currentLuminanceRT.dispose();\\n    }\\n\\n    if (this.materialLuminance) {\\n      this.materialLuminance.dispose();\\n    }\\n\\n    if (this.materialAdaptiveLum) {\\n      this.materialAdaptiveLum.dispose();\\n    }\\n\\n    if (this.materialCopy) {\\n      this.materialCopy.dispose();\\n    }\\n\\n    if (this.materialToneMap) {\\n      this.materialToneMap.dispose();\\n    }\\n  }\\n});\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"AdaptiveToneMappingPass\",\"_three\",\"_Pass\",\"_CopyShader\",\"_LuminosityShader\",\"_ToneMapShader\",\"adaptive\",\"resolution\",\"undefined\",\"needsInit\",\"currentLuminanceRT\",\"previousLuminanceRT\",\"luminanceRT\",\"CopyShader\",\"console\",\"error\",\"copyShader\",\"copyUniforms\",\"UniformsUtils\",\"clone\",\"uniforms\",\"materialCopy\",\"ShaderMaterial\",\"vertexShader\",\"fragmentShader\",\"blending\",\"NoBlending\",\"depthTest\",\"LuminosityShader\",\"materialLuminance\",\"adaptLuminanceShader\",\"defines\",\"MIP_LEVEL_1X1\",\"toFixed\",\"Math\",\"log\",\"lastLum\",\"currentLum\",\"minLuminance\",\"delta\",\"tau\",\"materialAdaptiveLum\",\"assign\",\"ToneMapShader\",\"materialToneMap\",\"fsQuad\",\"FullScreenQuad\",\"prototype\",\"create\",\"Pass\",\"constructor\",\"render\",\"renderer\",\"writeBuffer\",\"readBuffer\",\"deltaTime\",\"reset\",\"texture\",\"type\",\"material\",\"tDiffuse\",\"setRenderTarget\",\"renderToScreen\",\"clear\",\"dispose\",\"pars\",\"minFilter\",\"LinearFilter\",\"magFilter\",\"format\",\"RGBAFormat\",\"WebGLRenderTarget\",\"name\",\"generateMipmaps\",\"LinearMipmapLinearFilter\",\"luminanceMap\",\"MeshBasicMaterial\",\"color\",\"needsUpdate\",\"setAdaptive\",\"setAdaptionRate\",\"rate\",\"abs\",\"setMinLuminance\",\"minLum\",\"setMaxLuminance\",\"maxLum\",\"maxLuminance\",\"setAverageLuminance\",\"avgLum\",\"averageLuminance\",\"setMiddleGrey\",\"middleGrey\"]\n}\n"]