["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/ToneMapShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$ToneMapShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ToneMapShader=void 0;exports.ToneMapShader={uniforms:{tDiffuse:{value:null},averageLuminance:{value:1},luminanceMap:{value:null},maxLuminance:{value:16},minLuminance:{value:.01},middleGrey:{value:.6}},vertexShader:\"varying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",\nfragmentShader:\"#include \\x3ccommon\\x3e\\nuniform sampler2D tDiffuse;\\nvarying vec2 vUv;\\nuniform float middleGrey;\\nuniform float minLuminance;\\nuniform float maxLuminance;\\n#ifdef ADAPTED_LUMINANCE\\n\\tuniform sampler2D luminanceMap;\\n#else\\n\\tuniform float averageLuminance;\\n#endif\\nvec3 ToneMap( vec3 vColor ) {\\n\\t#ifdef ADAPTED_LUMINANCE\\n\\t\\tfloat fLumAvg \\x3d texture2D(luminanceMap, vec2(0.5, 0.5)).r;\\n\\t#else\\n\\t\\tfloat fLumAvg \\x3d averageLuminance;\\n\\t#endif\\n\\tfloat fLumPixel \\x3d linearToRelativeLuminance( vColor );\\n\\tfloat fLumScaled \\x3d (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\\n\\tfloat fLumCompressed \\x3d (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\\n\\treturn fLumCompressed * vColor;\\n}\\nvoid main() {\\n\\tvec4 texel \\x3d texture2D( tDiffuse, vUv );\\n\\tgl_FragColor \\x3d vec4( ToneMap( texel.xyz ), texel.w );\\n}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$ToneMapShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ToneMapShader = void 0;\n\n/**\n * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf\n */\nvar ToneMapShader = {\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    averageLuminance: {\n      value: 1.0\n    },\n    luminanceMap: {\n      value: null\n    },\n    maxLuminance: {\n      value: 16.0\n    },\n    minLuminance: {\n      value: 0.01\n    },\n    middleGrey: {\n      value: 0.6\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'uniform float middleGrey;', 'uniform float minLuminance;', 'uniform float maxLuminance;', '#ifdef ADAPTED_LUMINANCE', '\tuniform sampler2D luminanceMap;', '#else', '\tuniform float averageLuminance;', '#endif', 'vec3 ToneMap( vec3 vColor ) {', '\t#ifdef ADAPTED_LUMINANCE', // Get the calculated average luminance\n  '\t\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;', '\t#else', '\t\tfloat fLumAvg = averageLuminance;', '\t#endif', // Calculate the luminance of the current pixel\n  '\tfloat fLumPixel = linearToRelativeLuminance( vColor );', // Apply the modified operator (Eq. 4)\n  '\tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );', '\tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);', '\treturn fLumCompressed * vColor;', '}', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );', '}'].join('\\n')\n};\nexports.ToneMapShader = ToneMapShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["fragmentShader","maxLuminance","__esModule","tDiffuse","ToneMapShader","vertexShader","averageLuminance","value","middleGrey","luminanceMap","minLuminance","uniforms"]],"~:compiled-at",1630917515511,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$ToneMapShader.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,sDAAA,CAA2E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGnHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,aAAR,CAAwB,IAAK,EAgC7BJ,QAAQI,CAAAA,aAAR,CA3BoBA,CAClBC,SAAU,CACRC,SAAU,CACRH,MAAO,IADC,CADF,CAIRI,iBAAkB,CAChBJ,MAAO,CADS,CAJV,CAORK,aAAc,CACZL,MAAO,IADK,CAPN,CAURM,aAAc,CACZN,MAAO,EADK,CAVN,CAaRO,aAAc,CACZP,MAAO,GADK,CAbN,CAgBRQ,WAAY,CACVR,MAAO,EADG,CAhBJ,CADQC,CAqBlBQ,aAAiJ,qIArB/HR;AAsBlBS,eAGsW,i3BAzBpVT,CAX+F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/ToneMapShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$ToneMapShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ToneMapShader = void 0;\\n\\n/**\\n * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf\\n */\\nvar ToneMapShader = {\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    averageLuminance: {\\n      value: 1.0\\n    },\\n    luminanceMap: {\\n      value: null\\n    },\\n    maxLuminance: {\\n      value: 16.0\\n    },\\n    minLuminance: {\\n      value: 0.01\\n    },\\n    middleGrey: {\\n      value: 0.6\\n    }\\n  },\\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\\tvUv = uv;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['#include <common>', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'uniform float middleGrey;', 'uniform float minLuminance;', 'uniform float maxLuminance;', '#ifdef ADAPTED_LUMINANCE', '\\tuniform sampler2D luminanceMap;', '#else', '\\tuniform float averageLuminance;', '#endif', 'vec3 ToneMap( vec3 vColor ) {', '\\t#ifdef ADAPTED_LUMINANCE', // Get the calculated average luminance\\n  '\\t\\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;', '\\t#else', '\\t\\tfloat fLumAvg = averageLuminance;', '\\t#endif', // Calculate the luminance of the current pixel\\n  '\\tfloat fLumPixel = linearToRelativeLuminance( vColor );', // Apply the modified operator (Eq. 4)\\n  '\\tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );', '\\tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);', '\\treturn fLumCompressed * vColor;', '}', 'void main() {', '\\tvec4 texel = texture2D( tDiffuse, vUv );', '\\tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );', '}'].join('\\\\n')\\n};\\nexports.ToneMapShader = ToneMapShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"ToneMapShader\",\"uniforms\",\"tDiffuse\",\"averageLuminance\",\"luminanceMap\",\"maxLuminance\",\"minLuminance\",\"middleGrey\",\"vertexShader\",\"fragmentShader\"]\n}\n"]