["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/scan/reg_exp.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$scan$reg_exp=function(global,require,module,exports){function firstCharOptimizedIndices(ast,result,ignoreCase){switch(ast.type){case \"Disjunction\":for(var i=0;i<ast.value.length;i++)firstCharOptimizedIndices(ast.value[i],result,ignoreCase);break;case \"Alternative\":ast=ast.value;for(i=0;i<ast.length;i++){var term=ast[i];switch(term.type){case \"EndAnchor\":case \"GroupBackReference\":case \"Lookahead\":case \"NegativeLookahead\":case \"StartAnchor\":case \"WordBoundary\":case \"NonWordBoundary\":continue}switch(term.type){case \"Character\":addOptimizedIdxToResult(term.value,\nresult,ignoreCase);break;case \"Set\":if(!0===term.complement)throw Error(\"Complement Sets are not supported for first char optimization\");utils_1.forEach(term.value,function(code){if(\"number\"===typeof code)addOptimizedIdxToResult(code,result,ignoreCase);else if(!0===ignoreCase)for(var rangeCode=code.from;rangeCode<=code.to;rangeCode++)addOptimizedIdxToResult(rangeCode,result,ignoreCase);else{for(rangeCode=code.from;rangeCode<=code.to&&rangeCode<lexer_1.minOptimizationVal;rangeCode++)addOptimizedIdxToResult(rangeCode,\nresult,ignoreCase);if(code.to>=lexer_1.minOptimizationVal)for(rangeCode=code.to,code=lexer_1.charCodeToOptimizedIndex(code.from>=lexer_1.minOptimizationVal?code.from:lexer_1.minOptimizationVal),rangeCode=lexer_1.charCodeToOptimizedIndex(rangeCode);code<=rangeCode;code++)result[code]=code}});break;case \"Group\":firstCharOptimizedIndices(term.value,result,ignoreCase);break;default:throw Error(\"Non Exhaustive Match\");}var isOptionalQuantifier=void 0!==term.quantifier&&0===term.quantifier.atLeast;if(\"Group\"===\nterm.type&&!1===isWholeOptional(term)||\"Group\"!==term.type&&!1===isOptionalQuantifier)break}break;default:throw Error(\"non exhaustive match!\");}return utils_1.values(result)}function addOptimizedIdxToResult(code,result,ignoreCase){var optimizedCharIdx=lexer_1.charCodeToOptimizedIndex(code);result[optimizedCharIdx]=optimizedCharIdx;!0===ignoreCase&&(code=String.fromCharCode(code),ignoreCase=code.toUpperCase(),ignoreCase!==code?(code=lexer_1.charCodeToOptimizedIndex(ignoreCase.charCodeAt(0)),result[code]=\ncode):(ignoreCase=code.toLowerCase(),ignoreCase!==code&&(code=lexer_1.charCodeToOptimizedIndex(ignoreCase.charCodeAt(0)),result[code]=code)))}function findCode(setNode,targetCharCodes){return utils_1.find(setNode.value,function(codeOrRange){return\"number\"===typeof codeOrRange?utils_1.contains(targetCharCodes,codeOrRange):void 0!==utils_1.find(targetCharCodes,function(targetCode){return codeOrRange.from<=targetCode&&targetCode<=codeOrRange.to})})}function isWholeOptional(ast){return ast.quantifier&&\n0===ast.quantifier.atLeast?!0:ast.value?utils_1.isArray(ast.value)?utils_1.every(ast.value,isWholeOptional):isWholeOptional(ast.value):!1}var __extends=this&&this.__extends||function(){var extendStatics=function(d$jscomp$0,b$jscomp$0){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b}||function(d,b){for(var p in b)Object.prototype.hasOwnProperty.call(b,p)&&(d[p]=b[p])};return extendStatics(d$jscomp$0,b$jscomp$0)};return function(d,b){function __(){this.constructor=\nd}if(\"function\"!==typeof b&&null!==b)throw new TypeError(\"Class extends value \"+String(b)+\" is not a constructor or null\");extendStatics(d,b);d.prototype=null===b?Object.create(b):(__.prototype=b.prototype,new __)}}();Object.defineProperty(exports,\"__esModule\",{value:!0});exports.canMatchCharCode=exports.firstCharOptimizedIndices=exports.getOptimizedStartCodesIndices=exports.failedOptimizationPrefixMsg=void 0;var regexp_to_ast_1=require(\"module$node_modules$regexp_to_ast$lib$regexp_to_ast\"),utils_1=\nrequire(\"module$node_modules$$chevrotain$utils$lib$src$api\"),reg_exp_parser_1=require(\"module$node_modules$chevrotain$lib$src$scan$reg_exp_parser\"),lexer_1=require(\"module$node_modules$chevrotain$lib$src$scan$lexer\");exports.failedOptimizationPrefixMsg='Unable to use \"first char\" lexer optimizations:\\n';exports.getOptimizedStartCodesIndices=function(regExp,ensureOptimizations){void 0===ensureOptimizations&&(ensureOptimizations=!1);try{var ast=reg_exp_parser_1.getRegExpAst(regExp);return firstCharOptimizedIndices(ast.value,\n{},ast.flags.ignoreCase)}catch(e){\"Complement Sets are not supported for first char optimization\"===e.message?ensureOptimizations&&utils_1.PRINT_WARNING(\"\"+exports.failedOptimizationPrefixMsg+(\"\\tUnable to optimize: \\x3c \"+regExp.toString()+\" \\x3e\\n\\tComplement Sets cannot be automatically optimized.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\")):(ast=\"\",ensureOptimizations&&(ast=\"\\n\\tThis will disable the lexer's first char optimizations.\\n\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"),\nutils_1.PRINT_ERROR(exports.failedOptimizationPrefixMsg+\"\\n\\tFailed parsing: \\x3c \"+(regExp.toString()+\" \\x3e\\n\\tUsing the regexp-to-ast library version: \")+(regexp_to_ast_1.VERSION+\"\\n\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\")+ast))}return[]};exports.firstCharOptimizedIndices=firstCharOptimizedIndices;var CharCodeFinder=function(_super){function CharCodeFinder(targetCharCodes){var _this=_super.call(this)||this;_this.targetCharCodes=targetCharCodes;_this.found=!1;return _this}\n__extends(CharCodeFinder,_super);CharCodeFinder.prototype.visitChildren=function(node){if(!0!==this.found){switch(node.type){case \"Lookahead\":this.visitLookahead(node);return;case \"NegativeLookahead\":this.visitNegativeLookahead(node);return}_super.prototype.visitChildren.call(this,node)}};CharCodeFinder.prototype.visitCharacter=function(node){utils_1.contains(this.targetCharCodes,node.value)&&(this.found=!0)};CharCodeFinder.prototype.visitSet=function(node){node.complement?void 0===findCode(node,\nthis.targetCharCodes)&&(this.found=!0):void 0!==findCode(node,this.targetCharCodes)&&(this.found=!0)};return CharCodeFinder}(regexp_to_ast_1.BaseRegExpVisitor);exports.canMatchCharCode=function(charCodes,pattern){if(pattern instanceof RegExp){pattern=reg_exp_parser_1.getRegExpAst(pattern);var charCodeFinder=new CharCodeFinder(charCodes);charCodeFinder.visit(pattern);return charCodeFinder.found}return void 0!==utils_1.find(pattern,function(char){return utils_1.contains(charCodes,char.charCodeAt(0))})}}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$scan$reg_exp\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\nvar utils_1 = require(\"@chevrotain/utils\");\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\nvar lexer_1 = require(\"./lexer\");\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexports.failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n    if (ensureOptimizations === void 0) { ensureOptimizations = false; }\n    try {\n        var ast = reg_exp_parser_1.getRegExpAst(regExp);\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    }\n    catch (e) {\n        /* istanbul ignore next */\n        // Testing this relies on the regexp-to-ast library having a bug... */\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n        if (e.message === complementErrorMessage) {\n            if (ensureOptimizations) {\n                utils_1.PRINT_WARNING(\"\" + exports.failedOptimizationPrefixMsg +\n                    (\"\\tUnable to optimize: < \" + regExp.toString() + \" >\\n\") +\n                    \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n            }\n        }\n        else {\n            var msgSuffix = \"\";\n            if (ensureOptimizations) {\n                msgSuffix =\n                    \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n                        \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n            }\n            utils_1.PRINT_ERROR(exports.failedOptimizationPrefixMsg + \"\\n\" +\n                (\"\\tFailed parsing: < \" + regExp.toString() + \" >\\n\") +\n                (\"\\tUsing the regexp-to-ast library version: \" + regexp_to_ast_1.VERSION + \"\\n\") +\n                \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n                msgSuffix);\n        }\n    }\n    return [];\n}\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n        case \"Disjunction\":\n            for (var i = 0; i < ast.value.length; i++) {\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            }\n            break;\n        case \"Alternative\":\n            var terms = ast.value;\n            for (var i = 0; i < terms.length; i++) {\n                var term = terms[i];\n                // skip terms that cannot effect the first char results\n                switch (term.type) {\n                    case \"EndAnchor\":\n                    // A group back reference cannot affect potential starting char.\n                    // because if a back reference is the first production than automatically\n                    // the group being referenced has had to come BEFORE so its codes have already been added\n                    case \"GroupBackReference\":\n                    // assertions do not affect potential starting codes\n                    case \"Lookahead\":\n                    case \"NegativeLookahead\":\n                    case \"StartAnchor\":\n                    case \"WordBoundary\":\n                    case \"NonWordBoundary\":\n                        continue;\n                }\n                var atom = term;\n                switch (atom.type) {\n                    case \"Character\":\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                        break;\n                    case \"Set\":\n                        if (atom.complement === true) {\n                            throw Error(complementErrorMessage);\n                        }\n                        utils_1.forEach(atom.value, function (code) {\n                            if (typeof code === \"number\") {\n                                addOptimizedIdxToResult(code, result, ignoreCase);\n                            }\n                            else {\n                                // range\n                                var range = code;\n                                // cannot optimize when ignoreCase is\n                                if (ignoreCase === true) {\n                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                }\n                                // Optimization (2 orders of magnitude less work for very large ranges)\n                                else {\n                                    // handle unoptimized values\n                                    for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                                    if (range.to >= lexer_1.minOptimizationVal) {\n                                        var minUnOptVal = range.from >= lexer_1.minOptimizationVal\n                                            ? range.from\n                                            : lexer_1.minOptimizationVal;\n                                        var maxUnOptVal = range.to;\n                                        var minOptIdx = lexer_1.charCodeToOptimizedIndex(minUnOptVal);\n                                        var maxOptIdx = lexer_1.charCodeToOptimizedIndex(maxUnOptVal);\n                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                                            result[currOptIdx] = currOptIdx;\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case \"Group\":\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                        break;\n                    /* istanbul ignore next */\n                    default:\n                        throw Error(\"Non Exhaustive Match\");\n                }\n                // reached a mandatory production, no more **start** codes can be found on this alternative\n                var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n                if (\n                // A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n                    // If this term is not a group it may only be optional if it has an optional quantifier\n                    (atom.type !== \"Group\" && isOptionalQuantifier === false)) {\n                    break;\n                }\n            }\n            break;\n        /* istanbul ignore next */\n        default:\n            throw Error(\"non exhaustive match!\");\n    }\n    // console.log(Object.keys(result).length)\n    return utils_1.values(result);\n}\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n    var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n    }\n}\nfunction handleIgnoreCase(code, result) {\n    var char = String.fromCharCode(code);\n    var upperChar = char.toUpperCase();\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n        var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    }\n    else {\n        var lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\nfunction findCode(setNode, targetCharCodes) {\n    return utils_1.find(setNode.value, function (codeOrRange) {\n        if (typeof codeOrRange === \"number\") {\n            return utils_1.contains(targetCharCodes, codeOrRange);\n        }\n        else {\n            // range\n            var range_1 = codeOrRange;\n            return (utils_1.find(targetCharCodes, function (targetCode) { return range_1.from <= targetCode && targetCode <= range_1.to; }) !== undefined);\n        }\n    });\n}\nfunction isWholeOptional(ast) {\n    if (ast.quantifier && ast.quantifier.atLeast === 0) {\n        return true;\n    }\n    if (!ast.value) {\n        return false;\n    }\n    return utils_1.isArray(ast.value)\n        ? utils_1.every(ast.value, isWholeOptional)\n        : isWholeOptional(ast.value);\n}\nvar CharCodeFinder = /** @class */ (function (_super) {\n    __extends(CharCodeFinder, _super);\n    function CharCodeFinder(targetCharCodes) {\n        var _this = _super.call(this) || this;\n        _this.targetCharCodes = targetCharCodes;\n        _this.found = false;\n        return _this;\n    }\n    CharCodeFinder.prototype.visitChildren = function (node) {\n        // No need to keep looking...\n        if (this.found === true) {\n            return;\n        }\n        // switch lookaheads as they do not actually consume any characters thus\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n        switch (node.type) {\n            case \"Lookahead\":\n                this.visitLookahead(node);\n                return;\n            case \"NegativeLookahead\":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        _super.prototype.visitChildren.call(this, node);\n    };\n    CharCodeFinder.prototype.visitCharacter = function (node) {\n        if (utils_1.contains(this.targetCharCodes, node.value)) {\n            this.found = true;\n        }\n    };\n    CharCodeFinder.prototype.visitSet = function (node) {\n        if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === undefined) {\n                this.found = true;\n            }\n        }\n        else {\n            if (findCode(node, this.targetCharCodes) !== undefined) {\n                this.found = true;\n            }\n        }\n    };\n    return CharCodeFinder;\n}(regexp_to_ast_1.BaseRegExpVisitor));\nfunction canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        var ast = reg_exp_parser_1.getRegExpAst(pattern);\n        var charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    }\n    else {\n        return (utils_1.find(pattern, function (char) {\n            return utils_1.contains(charCodes, char.charCodeAt(0));\n        }) !== undefined);\n    }\n}\nexports.canMatchCharCode = canMatchCharCode;\n//# sourceMappingURL=reg_exp.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$chevrotain$lib$src$scan$reg_exp_parser","~$module$node_modules$$chevrotain$utils$lib$src$api","~$module$node_modules$chevrotain$lib$src$scan$lexer","~$shadow.js","~$module$node_modules$regexp_to_ast$lib$regexp_to_ast"]],"~:properties",["^5",["prototype","getOptimizedStartCodesIndices","found","__esModule","visitCharacter","failedOptimizationPrefixMsg","value","firstCharOptimizedIndices","visitSet","canMatchCharCode","targetCharCodes","visitChildren","__proto__","constructor"]],"~:compiled-at",1630917515666,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$scan$reg_exp.js\",\n\"lineCount\":12,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/chevrotain/lib/src/scan/reg_exp.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$scan$reg_exp\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nvar __extends = (this && this.__extends) || (function () {\\n    var extendStatics = function (d, b) {\\n        extendStatics = Object.setPrototypeOf ||\\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\\n        return extendStatics(d, b);\\n    };\\n    return function (d, b) {\\n        if (typeof b !== \\\"function\\\" && b !== null)\\n            throw new TypeError(\\\"Class extends value \\\" + String(b) + \\\" is not a constructor or null\\\");\\n        extendStatics(d, b);\\n        function __() { this.constructor = d; }\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\n    };\\n})();\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\\nvar regexp_to_ast_1 = require(\\\"regexp-to-ast\\\");\\nvar utils_1 = require(\\\"@chevrotain/utils\\\");\\nvar reg_exp_parser_1 = require(\\\"./reg_exp_parser\\\");\\nvar lexer_1 = require(\\\"./lexer\\\");\\nvar complementErrorMessage = \\\"Complement Sets are not supported for first char optimization\\\";\\nexports.failedOptimizationPrefixMsg = 'Unable to use \\\"first char\\\" lexer optimizations:\\\\n';\\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\\n    if (ensureOptimizations === void 0) { ensureOptimizations = false; }\\n    try {\\n        var ast = reg_exp_parser_1.getRegExpAst(regExp);\\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\\n        return firstChars;\\n    }\\n    catch (e) {\\n        /* istanbul ignore next */\\n        // Testing this relies on the regexp-to-ast library having a bug... */\\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\\n        if (e.message === complementErrorMessage) {\\n            if (ensureOptimizations) {\\n                utils_1.PRINT_WARNING(\\\"\\\" + exports.failedOptimizationPrefixMsg +\\n                    (\\\"\\\\tUnable to optimize: < \\\" + regExp.toString() + \\\" >\\\\n\\\") +\\n                    \\\"\\\\tComplement Sets cannot be automatically optimized.\\\\n\\\" +\\n                    \\\"\\\\tThis will disable the lexer's first char optimizations.\\\\n\\\" +\\n                    \\\"\\\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\\\");\\n            }\\n        }\\n        else {\\n            var msgSuffix = \\\"\\\";\\n            if (ensureOptimizations) {\\n                msgSuffix =\\n                    \\\"\\\\n\\\\tThis will disable the lexer's first char optimizations.\\\\n\\\" +\\n                        \\\"\\\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\\\";\\n            }\\n            utils_1.PRINT_ERROR(exports.failedOptimizationPrefixMsg + \\\"\\\\n\\\" +\\n                (\\\"\\\\tFailed parsing: < \\\" + regExp.toString() + \\\" >\\\\n\\\") +\\n                (\\\"\\\\tUsing the regexp-to-ast library version: \\\" + regexp_to_ast_1.VERSION + \\\"\\\\n\\\") +\\n                \\\"\\\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\\\" +\\n                msgSuffix);\\n        }\\n    }\\n    return [];\\n}\\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\\n    switch (ast.type) {\\n        case \\\"Disjunction\\\":\\n            for (var i = 0; i < ast.value.length; i++) {\\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\\n            }\\n            break;\\n        case \\\"Alternative\\\":\\n            var terms = ast.value;\\n            for (var i = 0; i < terms.length; i++) {\\n                var term = terms[i];\\n                // skip terms that cannot effect the first char results\\n                switch (term.type) {\\n                    case \\\"EndAnchor\\\":\\n                    // A group back reference cannot affect potential starting char.\\n                    // because if a back reference is the first production than automatically\\n                    // the group being referenced has had to come BEFORE so its codes have already been added\\n                    case \\\"GroupBackReference\\\":\\n                    // assertions do not affect potential starting codes\\n                    case \\\"Lookahead\\\":\\n                    case \\\"NegativeLookahead\\\":\\n                    case \\\"StartAnchor\\\":\\n                    case \\\"WordBoundary\\\":\\n                    case \\\"NonWordBoundary\\\":\\n                        continue;\\n                }\\n                var atom = term;\\n                switch (atom.type) {\\n                    case \\\"Character\\\":\\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\\n                        break;\\n                    case \\\"Set\\\":\\n                        if (atom.complement === true) {\\n                            throw Error(complementErrorMessage);\\n                        }\\n                        utils_1.forEach(atom.value, function (code) {\\n                            if (typeof code === \\\"number\\\") {\\n                                addOptimizedIdxToResult(code, result, ignoreCase);\\n                            }\\n                            else {\\n                                // range\\n                                var range = code;\\n                                // cannot optimize when ignoreCase is\\n                                if (ignoreCase === true) {\\n                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\\n                                    }\\n                                }\\n                                // Optimization (2 orders of magnitude less work for very large ranges)\\n                                else {\\n                                    // handle unoptimized values\\n                                    for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\\n                                    }\\n                                    // Less common charCode where we optimize for faster init time, by using larger \\\"buckets\\\"\\n                                    if (range.to >= lexer_1.minOptimizationVal) {\\n                                        var minUnOptVal = range.from >= lexer_1.minOptimizationVal\\n                                            ? range.from\\n                                            : lexer_1.minOptimizationVal;\\n                                        var maxUnOptVal = range.to;\\n                                        var minOptIdx = lexer_1.charCodeToOptimizedIndex(minUnOptVal);\\n                                        var maxOptIdx = lexer_1.charCodeToOptimizedIndex(maxUnOptVal);\\n                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\\n                                            result[currOptIdx] = currOptIdx;\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        });\\n                        break;\\n                    case \\\"Group\\\":\\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\\n                        break;\\n                    /* istanbul ignore next */\\n                    default:\\n                        throw Error(\\\"Non Exhaustive Match\\\");\\n                }\\n                // reached a mandatory production, no more **start** codes can be found on this alternative\\n                var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\\n                if (\\n                // A group may be optional due to empty contents /(?:)/\\n                // or if everything inside it is optional /((a)?)/\\n                (atom.type === \\\"Group\\\" && isWholeOptional(atom) === false) ||\\n                    // If this term is not a group it may only be optional if it has an optional quantifier\\n                    (atom.type !== \\\"Group\\\" && isOptionalQuantifier === false)) {\\n                    break;\\n                }\\n            }\\n            break;\\n        /* istanbul ignore next */\\n        default:\\n            throw Error(\\\"non exhaustive match!\\\");\\n    }\\n    // console.log(Object.keys(result).length)\\n    return utils_1.values(result);\\n}\\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\\n    var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(code);\\n    result[optimizedCharIdx] = optimizedCharIdx;\\n    if (ignoreCase === true) {\\n        handleIgnoreCase(code, result);\\n    }\\n}\\nfunction handleIgnoreCase(code, result) {\\n    var char = String.fromCharCode(code);\\n    var upperChar = char.toUpperCase();\\n    /* istanbul ignore else */\\n    if (upperChar !== char) {\\n        var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(upperChar.charCodeAt(0));\\n        result[optimizedCharIdx] = optimizedCharIdx;\\n    }\\n    else {\\n        var lowerChar = char.toLowerCase();\\n        if (lowerChar !== char) {\\n            var optimizedCharIdx = lexer_1.charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\\n            result[optimizedCharIdx] = optimizedCharIdx;\\n        }\\n    }\\n}\\nfunction findCode(setNode, targetCharCodes) {\\n    return utils_1.find(setNode.value, function (codeOrRange) {\\n        if (typeof codeOrRange === \\\"number\\\") {\\n            return utils_1.contains(targetCharCodes, codeOrRange);\\n        }\\n        else {\\n            // range\\n            var range_1 = codeOrRange;\\n            return (utils_1.find(targetCharCodes, function (targetCode) { return range_1.from <= targetCode && targetCode <= range_1.to; }) !== undefined);\\n        }\\n    });\\n}\\nfunction isWholeOptional(ast) {\\n    if (ast.quantifier && ast.quantifier.atLeast === 0) {\\n        return true;\\n    }\\n    if (!ast.value) {\\n        return false;\\n    }\\n    return utils_1.isArray(ast.value)\\n        ? utils_1.every(ast.value, isWholeOptional)\\n        : isWholeOptional(ast.value);\\n}\\nvar CharCodeFinder = /** @class */ (function (_super) {\\n    __extends(CharCodeFinder, _super);\\n    function CharCodeFinder(targetCharCodes) {\\n        var _this = _super.call(this) || this;\\n        _this.targetCharCodes = targetCharCodes;\\n        _this.found = false;\\n        return _this;\\n    }\\n    CharCodeFinder.prototype.visitChildren = function (node) {\\n        // No need to keep looking...\\n        if (this.found === true) {\\n            return;\\n        }\\n        // switch lookaheads as they do not actually consume any characters thus\\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\\n        switch (node.type) {\\n            case \\\"Lookahead\\\":\\n                this.visitLookahead(node);\\n                return;\\n            case \\\"NegativeLookahead\\\":\\n                this.visitNegativeLookahead(node);\\n                return;\\n        }\\n        _super.prototype.visitChildren.call(this, node);\\n    };\\n    CharCodeFinder.prototype.visitCharacter = function (node) {\\n        if (utils_1.contains(this.targetCharCodes, node.value)) {\\n            this.found = true;\\n        }\\n    };\\n    CharCodeFinder.prototype.visitSet = function (node) {\\n        if (node.complement) {\\n            if (findCode(node, this.targetCharCodes) === undefined) {\\n                this.found = true;\\n            }\\n        }\\n        else {\\n            if (findCode(node, this.targetCharCodes) !== undefined) {\\n                this.found = true;\\n            }\\n        }\\n    };\\n    return CharCodeFinder;\\n}(regexp_to_ast_1.BaseRegExpVisitor));\\nfunction canMatchCharCode(charCodes, pattern) {\\n    if (pattern instanceof RegExp) {\\n        var ast = reg_exp_parser_1.getRegExpAst(pattern);\\n        var charCodeFinder = new CharCodeFinder(charCodes);\\n        charCodeFinder.visit(ast);\\n        return charCodeFinder.found;\\n    }\\n    else {\\n        return (utils_1.find(pattern, function (char) {\\n            return utils_1.contains(charCodes, char.charCodeAt(0));\\n        }) !== undefined);\\n    }\\n}\\nexports.canMatchCharCode = canMatchCharCode;\\n//# sourceMappingURL=reg_exp.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"firstCharOptimizedIndices\",\"ast\",\"result\",\"ignoreCase\",\"type\",\"i\",\"value\",\"length\",\"terms\",\"term\",\"atom\",\"addOptimizedIdxToResult\",\"complement\",\"Error\",\"complementErrorMessage\",\"utils_1\",\"forEach\",\"code\",\"rangeCode\",\"from\",\"to\",\"lexer_1\",\"minOptimizationVal\",\"maxUnOptVal\",\"maxOptIdx\",\"minOptIdx\",\"charCodeToOptimizedIndex\",\"minUnOptVal\",\"currOptIdx\",\"isOptionalQuantifier\",\"undefined\",\"quantifier\",\"atLeast\",\"isWholeOptional\",\"values\",\"optimizedCharIdx\",\"char\",\"String\",\"fromCharCode\",\"upperChar\",\"toUpperCase\",\"charCodeAt\",\"lowerChar\",\"toLowerCase\",\"findCode\",\"setNode\",\"targetCharCodes\",\"find\",\"codeOrRange\",\"contains\",\"targetCode\",\"isArray\",\"every\",\"__extends\",\"extendStatics\",\"d\",\"b\",\"Object\",\"setPrototypeOf\",\"__proto__\",\"Array\",\"p\",\"prototype\",\"hasOwnProperty\",\"call\",\"__\",\"constructor\",\"TypeError\",\"create\",\"defineProperty\",\"canMatchCharCode\",\"getOptimizedStartCodesIndices\",\"failedOptimizationPrefixMsg\",\"regexp_to_ast_1\",\"reg_exp_parser_1\",\"regExp\",\"ensureOptimizations\",\"getRegExpAst\",\"firstChars\",\"flags\",\"e\",\"message\",\"PRINT_WARNING\",\"toString\",\"msgSuffix\",\"PRINT_ERROR\",\"VERSION\",\"CharCodeFinder\",\"_super\",\"_this\",\"found\",\"visitChildren\",\"CharCodeFinder.prototype.visitChildren\",\"node\",\"visitLookahead\",\"visitNegativeLookahead\",\"visitCharacter\",\"CharCodeFinder.prototype.visitCharacter\",\"visitSet\",\"CharCodeFinder.prototype.visitSet\",\"BaseRegExpVisitor\",\"charCodes\",\"pattern\",\"RegExp\",\"charCodeFinder\",\"visit\"]\n}\n"]