["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/modifiers/SimplifyModifier.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$modifiers$SimplifyModifier=function(global,require,module,exports){function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,\ndescriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function removeFromArray(array,object){object=array.indexOf(object);-1<object&&array.splice(object,1)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.SimplifyModifier=void 0;var _defineProperty2=function(obj){return obj&&obj.__esModule?obj:{\"default\":obj}}(require(\"module$node_modules$$babel$runtime$helpers$esm$defineProperty\")),\n_three=require(\"module$node_modules$three$build$three_module\"),_BufferGeometryUtils=require(\"module$node_modules$three_stdlib$utils$BufferGeometryUtils\"),cb=new _three.Vector3,ab=new _three.Vector3,Vertex$jscomp$0=function(){function Vertex(v,id){_classCallCheck(this,Vertex);(0,_defineProperty2[\"default\"])(this,\"position\",void 0);(0,_defineProperty2[\"default\"])(this,\"id\",void 0);(0,_defineProperty2[\"default\"])(this,\"faces\",void 0);(0,_defineProperty2[\"default\"])(this,\"neighbors\",void 0);(0,_defineProperty2[\"default\"])(this,\n\"collapseCost\",void 0);(0,_defineProperty2[\"default\"])(this,\"collapseNeighbor\",void 0);(0,_defineProperty2[\"default\"])(this,\"minCost\",0);(0,_defineProperty2[\"default\"])(this,\"totalCost\",0);(0,_defineProperty2[\"default\"])(this,\"costCount\",0);this.position=v;this.id=id;this.faces=[];this.neighbors=[];this.collapseCost=0;this.collapseNeighbor=null}_createClass(Vertex,[{key:\"addUniqueNeighbor\",value:function(vertex){var array=this.neighbors;-1===array.indexOf(vertex)&&array.push(vertex)}},{key:\"removeIfNonNeighbor\",\nvalue:function(n){var neighbors=this.neighbors,faces=this.faces,offset=neighbors.indexOf(n);if(-1!==offset){for(var i=0;i<faces.length;i++)if(faces[i].hasVertex(n))return;neighbors.splice(offset,1)}}}]);return Vertex}(),Triangle$jscomp$0=function(){function Triangle(v1,v2,v3,a,b,c){_classCallCheck(this,Triangle);(0,_defineProperty2[\"default\"])(this,\"a\",void 0);(0,_defineProperty2[\"default\"])(this,\"b\",void 0);(0,_defineProperty2[\"default\"])(this,\"c\",void 0);(0,_defineProperty2[\"default\"])(this,\"v1\",\nvoid 0);(0,_defineProperty2[\"default\"])(this,\"v2\",void 0);(0,_defineProperty2[\"default\"])(this,\"v3\",void 0);(0,_defineProperty2[\"default\"])(this,\"normal\",new _three.Vector3);this.a=a;this.b=b;this.c=c;this.v1=v1;this.v2=v2;this.v3=v3;this.computeNormal();v1.faces.push(this);v1.addUniqueNeighbor(v2);v1.addUniqueNeighbor(v3);v2.faces.push(this);v2.addUniqueNeighbor(v1);v2.addUniqueNeighbor(v3);v3.faces.push(this);v3.addUniqueNeighbor(v1);v3.addUniqueNeighbor(v2)}_createClass(Triangle,[{key:\"computeNormal\",\nvalue:function(){var vA=this.v1.position,vB=this.v2.position;cb.subVectors(this.v3.position,vB);ab.subVectors(vA,vB);cb.cross(ab).normalize();this.normal.copy(cb)}},{key:\"hasVertex\",value:function(v){return v===this.v1||v===this.v2||v===this.v3}},{key:\"replaceVertex\",value:function(oldv,newv){oldv===this.v1?this.v1=newv:oldv===this.v2?this.v2=newv:oldv===this.v3&&(this.v3=newv);removeFromArray(oldv.faces,this);newv.faces.push(this);oldv.removeIfNonNeighbor(this.v1);this.v1.removeIfNonNeighbor(oldv);\noldv.removeIfNonNeighbor(this.v2);this.v2.removeIfNonNeighbor(oldv);oldv.removeIfNonNeighbor(this.v3);this.v3.removeIfNonNeighbor(oldv);this.v1.addUniqueNeighbor(this.v2);this.v1.addUniqueNeighbor(this.v3);this.v2.addUniqueNeighbor(this.v1);this.v2.addUniqueNeighbor(this.v3);this.v3.addUniqueNeighbor(this.v1);this.v3.addUniqueNeighbor(this.v2);this.computeNormal()}}]);return Triangle}();global=function(){function SimplifyModifier(){var _this=this;_classCallCheck(this,SimplifyModifier);(0,_defineProperty2[\"default\"])(this,\n\"computeEdgeCollapseCost\",function(u,v){var edgelength=v.position.distanceTo(u.position),curvature=0,sideFaces=[],i,il=u.faces.length;for(i=0;i<il;i++){var face=u.faces[i];face.hasVertex(v)&&sideFaces.push(face)}for(i=0;i<il;i++){v=1;face=u.faces[i];for(var j=0;j<sideFaces.length;j++){var sideFace=sideFaces[j];sideFace=face.normal.dot(sideFace.normal);v=Math.min(v,(1.001-sideFace)/2)}curvature=Math.max(curvature,v)}2>sideFaces.length&&(curvature=1);return edgelength*curvature});(0,_defineProperty2[\"default\"])(this,\n\"computeEdgeCostAtVertex\",function(v){if(0===v.neighbors.length)v.collapseNeighbor=null,v.collapseCost=-.01;else{v.collapseCost=1E5;v.collapseNeighbor=null;for(var i=0;i<v.neighbors.length;i++){var collapseCost=_this.computeEdgeCollapseCost(v,v.neighbors[i]);v.collapseNeighbor||(v.collapseNeighbor=v.neighbors[i],v.collapseCost=collapseCost,v.minCost=collapseCost,v.totalCost=0,v.costCount=0);v.costCount++;v.totalCost+=collapseCost;collapseCost<v.minCost&&(v.collapseNeighbor=v.neighbors[i],v.minCost=\ncollapseCost)}v.collapseCost=v.totalCost/v.costCount}});(0,_defineProperty2[\"default\"])(this,\"removeFace\",function(f,faces){removeFromArray(faces,f);f.v1&&removeFromArray(f.v1.faces,f);f.v2&&removeFromArray(f.v2.faces,f);f.v3&&removeFromArray(f.v3.faces,f);f=[f.v1,f.v2,f.v3];for(var v2,i=0;3>i;i++)faces=f[i],v2=f[(i+1)%3],faces&&v2&&(faces.removeIfNonNeighbor(v2),v2.removeIfNonNeighbor(faces))});(0,_defineProperty2[\"default\"])(this,\"collapse\",function(vertices,faces,u,v){if(v){var i,tmpVertices=[];\nfor(i=0;i<u.neighbors.length;i++)tmpVertices.push(u.neighbors[i]);for(i=u.faces.length-1;0<=i;i--)u.faces[i].hasVertex(v)&&_this.removeFace(u.faces[i],faces);for(i=u.faces.length-1;0<=i;i--)u.faces[i].replaceVertex(u,v);_this.removeVertex(u,vertices);for(i=0;i<tmpVertices.length;i++)_this.computeEdgeCostAtVertex(tmpVertices[i])}else _this.removeVertex(u,vertices)});(0,_defineProperty2[\"default\"])(this,\"minimumCostEdge\",function(vertices){for(var least=vertices[0],i=0;i<vertices.length;i++)vertices[i].collapseCost<\nleast.collapseCost&&(least=vertices[i]);return least});(0,_defineProperty2[\"default\"])(this,\"modify\",function(geometry,count){geometry=geometry.clone();var attributes=geometry.attributes;for(name in attributes)\"position\"!==name&&geometry.deleteAttribute(name);geometry=(0,_BufferGeometryUtils.mergeVertices)(geometry);attributes=[];var name=[];for(var positionAttribute=geometry.getAttribute(\"position\"),i=0;i<positionAttribute.count;i++){var v=(new _three.Vector3).fromBufferAttribute(positionAttribute,\ni);v=new Vertex$jscomp$0(v,i);attributes.push(v)}geometry=geometry.getIndex();if(null!==geometry)for(positionAttribute=0;positionAttribute<geometry.count;positionAttribute+=3){i=geometry.getX(positionAttribute);v=geometry.getX(positionAttribute+1);var c=geometry.getX(positionAttribute+2);i=new Triangle$jscomp$0(attributes[i],attributes[v],attributes[c],i,v,c);name.push(i)}else for(geometry=0;geometry<positionAttribute.count;geometry+=3)i=geometry,v=geometry+1,c=geometry+2,i=new Triangle$jscomp$0(attributes[i],\nattributes[v],attributes[c],i,v,c),name.push(i);positionAttribute=0;for(geometry=attributes.length;positionAttribute<geometry;positionAttribute++)_this.computeEdgeCostAtVertex(attributes[positionAttribute]);for(positionAttribute=count;positionAttribute--;)if(count=_this.minimumCostEdge(attributes))_this.collapse(attributes,name,count,count.collapseNeighbor);else{console.log(\"THREE.SimplifyModifier: No next vertex\");break}count=new _three.BufferGeometry;positionAttribute=[];geometry=[];for(i=0;i<attributes.length;i++)v=\nattributes[i].position,positionAttribute.push(v.x,v.y,v.z);for(i=0;i<name.length;i++){var face=name[i];v=attributes.indexOf(face.v1);c=attributes.indexOf(face.v2);face=attributes.indexOf(face.v3);geometry.push(v,c,face)}count.setAttribute(\"position\",new _three.Float32BufferAttribute(positionAttribute,3));count.setIndex(geometry);return count})}_createClass(SimplifyModifier,[{key:\"removeVertex\",value:function(v,vertices){for(console.assert(0===v.faces.length);v.neighbors.length;){var n=v.neighbors.pop();\nremoveFromArray(n.neighbors,v)}removeFromArray(vertices,v)}}]);return SimplifyModifier}();exports.SimplifyModifier=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$modifiers$SimplifyModifier\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimplifyModifier = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/esm/defineProperty\"));\n\nvar _three = require(\"three\");\n\nvar _BufferGeometryUtils = require(\"../utils/BufferGeometryUtils.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar cb = new _three.Vector3(),\n    ab = new _three.Vector3();\n\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\n\nfunction removeFromArray(array, object) {\n  var k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\n\nvar Vertex =\n/*#__PURE__*/\nfunction () {\n  function Vertex(v, id) {\n    _classCallCheck(this, Vertex);\n\n    (0, _defineProperty2[\"default\"])(this, \"position\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"id\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"faces\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"neighbors\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"collapseCost\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"collapseNeighbor\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"minCost\", 0);\n    (0, _defineProperty2[\"default\"])(this, \"totalCost\", 0);\n    (0, _defineProperty2[\"default\"])(this, \"costCount\", 0);\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  _createClass(Vertex, [{\n    key: \"addUniqueNeighbor\",\n    value: function addUniqueNeighbor(vertex) {\n      pushIfUnique(this.neighbors, vertex);\n    }\n  }, {\n    key: \"removeIfNonNeighbor\",\n    value: function removeIfNonNeighbor(n) {\n      var neighbors = this.neighbors;\n      var faces = this.faces;\n      var offset = neighbors.indexOf(n);\n      if (offset === -1) return;\n\n      for (var i = 0; i < faces.length; i++) {\n        if (faces[i].hasVertex(n)) return;\n      }\n\n      neighbors.splice(offset, 1);\n    }\n  }]);\n\n  return Vertex;\n}(); // we use a triangle class to represent structure of face slightly differently\n\n\nvar Triangle =\n/*#__PURE__*/\nfunction () {\n  function Triangle(v1, v2, v3, a, b, c) {\n    _classCallCheck(this, Triangle);\n\n    (0, _defineProperty2[\"default\"])(this, \"a\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"b\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"c\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"v1\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"v2\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"v3\", void 0);\n    (0, _defineProperty2[\"default\"])(this, \"normal\", new _three.Vector3());\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n\n  _createClass(Triangle, [{\n    key: \"computeNormal\",\n    value: function computeNormal() {\n      var vA = this.v1.position;\n      var vB = this.v2.position;\n      var vC = this.v3.position;\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab).normalize();\n      this.normal.copy(cb);\n    }\n  }, {\n    key: \"hasVertex\",\n    value: function hasVertex(v) {\n      return v === this.v1 || v === this.v2 || v === this.v3;\n    }\n  }, {\n    key: \"replaceVertex\",\n    value: function replaceVertex(oldv, newv) {\n      if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n      removeFromArray(oldv.faces, this);\n      newv.faces.push(this);\n      oldv.removeIfNonNeighbor(this.v1);\n      this.v1.removeIfNonNeighbor(oldv);\n      oldv.removeIfNonNeighbor(this.v2);\n      this.v2.removeIfNonNeighbor(oldv);\n      oldv.removeIfNonNeighbor(this.v3);\n      this.v3.removeIfNonNeighbor(oldv);\n      this.v1.addUniqueNeighbor(this.v2);\n      this.v1.addUniqueNeighbor(this.v3);\n      this.v2.addUniqueNeighbor(this.v1);\n      this.v2.addUniqueNeighbor(this.v3);\n      this.v3.addUniqueNeighbor(this.v1);\n      this.v3.addUniqueNeighbor(this.v2);\n      this.computeNormal();\n    }\n  }]);\n\n  return Triangle;\n}();\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\n\nvar SimplifyModifier =\n/*#__PURE__*/\nfunction () {\n  function SimplifyModifier() {\n    var _this = this;\n\n    _classCallCheck(this, SimplifyModifier);\n\n    (0, _defineProperty2[\"default\"])(this, \"computeEdgeCollapseCost\", function (u, v) {\n      // if we collapse edge uv by moving u to v then how\n      // much different will the model change, i.e. the \"error\".\n      var edgelength = v.position.distanceTo(u.position);\n      var curvature = 0;\n      var sideFaces = [];\n      var i,\n          il = u.faces.length,\n          face,\n          sideFace; // find the \"sides\" triangles that are on the edge uv\n\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      } // use the triangle facing most away from the sides\n      // to determine our curvature term\n\n\n      for (i = 0; i < il; i++) {\n        var minCurvature = 1;\n        face = u.faces[i];\n\n        for (var j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j]; // use dot product of face normals.\n\n          var dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n\n        curvature = Math.max(curvature, minCurvature);\n      } // crude approach in attempt to preserve borders\n      // though it seems not to be totally correct\n\n\n      var borders = 0;\n\n      if (sideFaces.length < 2) {\n        // we add some arbitrary cost for borders,\n        // borders += 10;\n        curvature = 1;\n      }\n\n      var amt = edgelength * curvature + borders;\n      return amt;\n    });\n    (0, _defineProperty2[\"default\"])(this, \"computeEdgeCostAtVertex\", function (v) {\n      // compute the edge collapse cost for all edges that start\n      // from vertex v.  Since we are only interested in reducing\n      // the object by selecting the min cost edge at each step, we\n      // only cache the cost of the least cost edge at this vertex\n      // (in member variable collapse) as well as the value of the\n      // cost (in member variable collapseCost).\n      if (v.neighbors.length === 0) {\n        // collapse if no neighbors.\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n\n      v.collapseCost = 100000;\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n      for (var i = 0; i < v.neighbors.length; i++) {\n        var collapseCost = _this.computeEdgeCollapseCost(v, v.neighbors[i]);\n\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n\n        v.costCount++;\n        v.totalCost += collapseCost;\n\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      } // we average the cost of collapsing at this vertex\n\n\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n    });\n    (0, _defineProperty2[\"default\"])(this, \"removeFace\", function (f, faces) {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n      var vs = [f.v1, f.v2, f.v3];\n      var v1, v2;\n\n      for (var i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n    (0, _defineProperty2[\"default\"])(this, \"collapse\", function (vertices, faces, u, v) {\n      // u and v are pointers to vertices of an edge\n      // Collapse the edge uv by moving vertex u onto v\n      if (!v) {\n        // u is a vertex all by itself so just delete it..\n        _this.removeVertex(u, vertices);\n\n        return;\n      }\n\n      var i;\n      var tmpVertices = [];\n\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      } // delete triangles on edge uv:\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          _this.removeFace(u.faces[i], faces);\n        }\n      } // update remaining triangles to have v instead of u\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n\n      _this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n\n      for (i = 0; i < tmpVertices.length; i++) {\n        _this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n    (0, _defineProperty2[\"default\"])(this, \"minimumCostEdge\", function (vertices) {\n      // O(n * n) approach. TODO optimize this\n      var least = vertices[0];\n\n      for (var i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n\n      return least;\n    });\n    (0, _defineProperty2[\"default\"])(this, \"modify\", function (geometry, count) {\n      geometry = geometry.clone();\n      var attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n      for (var name in attributes) {\n        if (name !== 'position') geometry.deleteAttribute(name);\n      }\n\n      geometry = (0, _BufferGeometryUtils.mergeVertices)(geometry); //\n      // put data of original geometry in different data structures\n      //\n\n      var vertices = [];\n      var faces = []; // add vertices\n\n      var positionAttribute = geometry.getAttribute('position');\n\n      for (var i = 0; i < positionAttribute.count; i++) {\n        var v = new _three.Vector3().fromBufferAttribute(positionAttribute, i);\n        var vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      } // add faces\n\n\n      var geomIndex = geometry.getIndex();\n\n      if (geomIndex !== null) {\n        for (var _i = 0; _i < geomIndex.count; _i += 3) {\n          var a = geomIndex.getX(_i);\n          var b = geomIndex.getX(_i + 1);\n          var c = geomIndex.getX(_i + 2);\n          var triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (var _i2 = 0; _i2 < positionAttribute.count; _i2 += 3) {\n          var _a = _i2;\n\n          var _b = _i2 + 1;\n\n          var _c = _i2 + 2;\n\n          var _triangle = new Triangle(vertices[_a], vertices[_b], vertices[_c], _a, _b, _c);\n\n          faces.push(_triangle);\n        }\n      } // compute all edge collapse costs\n\n\n      for (var _i3 = 0, il = vertices.length; _i3 < il; _i3++) {\n        _this.computeEdgeCostAtVertex(vertices[_i3]);\n      }\n\n      var nextVertex;\n      var z = count;\n\n      while (z--) {\n        nextVertex = _this.minimumCostEdge(vertices);\n\n        if (!nextVertex) {\n          console.log('THREE.SimplifyModifier: No next vertex');\n          break;\n        } else {\n          _this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      } //\n\n\n      var simplifiedGeometry = new _three.BufferGeometry();\n      var position = [];\n      var index = []; //\n\n      for (var _i4 = 0; _i4 < vertices.length; _i4++) {\n        var _vertex = vertices[_i4].position;\n        position.push(_vertex.x, _vertex.y, _vertex.z);\n      } //\n\n\n      for (var _i5 = 0; _i5 < faces.length; _i5++) {\n        var face = faces[_i5];\n\n        var _a2 = vertices.indexOf(face.v1);\n\n        var _b2 = vertices.indexOf(face.v2);\n\n        var _c2 = vertices.indexOf(face.v3);\n\n        index.push(_a2, _b2, _c2);\n      } //\n\n\n      simplifiedGeometry.setAttribute('position', new _three.Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n\n  _createClass(SimplifyModifier, [{\n    key: \"removeVertex\",\n    value: function removeVertex(v, vertices) {\n      console.assert(v.faces.length === 0);\n\n      while (v.neighbors.length) {\n        var n = v.neighbors.pop();\n        removeFromArray(n.neighbors, v);\n      }\n\n      removeFromArray(vertices, v);\n    }\n  }]);\n\n  return SimplifyModifier;\n}();\n\nexports.SimplifyModifier = SimplifyModifier;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js","~$module$node_modules$$babel$runtime$helpers$esm$defineProperty","~$module$node_modules$three_stdlib$utils$BufferGeometryUtils"]],"~:properties",["^5",["neighbors","v3","key","__esModule","collapseCost","id","collapseNeighbor","position","configurable","value","enumerable","a","faces","writable","costCount","totalCost","SimplifyModifier","b","v1","minCost","c","v2"]],"~:compiled-at",1630917515178,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$modifiers$SimplifyModifier.js\",\n\"lineCount\":17,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/modifiers/SimplifyModifier.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$modifiers$SimplifyModifier\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.SimplifyModifier = void 0;\\n\\nvar _defineProperty2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/esm/defineProperty\\\"));\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _BufferGeometryUtils = require(\\\"../utils/BufferGeometryUtils.js\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \\\"default\\\": obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nvar cb = new _three.Vector3(),\\n    ab = new _three.Vector3();\\n\\nfunction pushIfUnique(array, object) {\\n  if (array.indexOf(object) === -1) array.push(object);\\n}\\n\\nfunction removeFromArray(array, object) {\\n  var k = array.indexOf(object);\\n  if (k > -1) array.splice(k, 1);\\n}\\n\\nvar Vertex =\\n/*#__PURE__*/\\nfunction () {\\n  function Vertex(v, id) {\\n    _classCallCheck(this, Vertex);\\n\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"position\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"id\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"faces\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"neighbors\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"collapseCost\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"collapseNeighbor\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"minCost\\\", 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"totalCost\\\", 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"costCount\\\", 0);\\n    this.position = v;\\n    this.id = id; // old index id\\n\\n    this.faces = []; // faces vertex is connected\\n\\n    this.neighbors = []; // neighbouring vertices aka \\\"adjacentVertices\\\"\\n    // these will be computed in computeEdgeCostAtVertex()\\n\\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\\n\\n    this.collapseNeighbor = null; // best candinate for collapsing\\n  }\\n\\n  _createClass(Vertex, [{\\n    key: \\\"addUniqueNeighbor\\\",\\n    value: function addUniqueNeighbor(vertex) {\\n      pushIfUnique(this.neighbors, vertex);\\n    }\\n  }, {\\n    key: \\\"removeIfNonNeighbor\\\",\\n    value: function removeIfNonNeighbor(n) {\\n      var neighbors = this.neighbors;\\n      var faces = this.faces;\\n      var offset = neighbors.indexOf(n);\\n      if (offset === -1) return;\\n\\n      for (var i = 0; i < faces.length; i++) {\\n        if (faces[i].hasVertex(n)) return;\\n      }\\n\\n      neighbors.splice(offset, 1);\\n    }\\n  }]);\\n\\n  return Vertex;\\n}(); // we use a triangle class to represent structure of face slightly differently\\n\\n\\nvar Triangle =\\n/*#__PURE__*/\\nfunction () {\\n  function Triangle(v1, v2, v3, a, b, c) {\\n    _classCallCheck(this, Triangle);\\n\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"a\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"b\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"c\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"v1\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"v2\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"v3\\\", void 0);\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"normal\\\", new _three.Vector3());\\n    this.a = a;\\n    this.b = b;\\n    this.c = c;\\n    this.v1 = v1;\\n    this.v2 = v2;\\n    this.v3 = v3;\\n    this.computeNormal();\\n    v1.faces.push(this);\\n    v1.addUniqueNeighbor(v2);\\n    v1.addUniqueNeighbor(v3);\\n    v2.faces.push(this);\\n    v2.addUniqueNeighbor(v1);\\n    v2.addUniqueNeighbor(v3);\\n    v3.faces.push(this);\\n    v3.addUniqueNeighbor(v1);\\n    v3.addUniqueNeighbor(v2);\\n  }\\n\\n  _createClass(Triangle, [{\\n    key: \\\"computeNormal\\\",\\n    value: function computeNormal() {\\n      var vA = this.v1.position;\\n      var vB = this.v2.position;\\n      var vC = this.v3.position;\\n      cb.subVectors(vC, vB);\\n      ab.subVectors(vA, vB);\\n      cb.cross(ab).normalize();\\n      this.normal.copy(cb);\\n    }\\n  }, {\\n    key: \\\"hasVertex\\\",\\n    value: function hasVertex(v) {\\n      return v === this.v1 || v === this.v2 || v === this.v3;\\n    }\\n  }, {\\n    key: \\\"replaceVertex\\\",\\n    value: function replaceVertex(oldv, newv) {\\n      if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\\n      removeFromArray(oldv.faces, this);\\n      newv.faces.push(this);\\n      oldv.removeIfNonNeighbor(this.v1);\\n      this.v1.removeIfNonNeighbor(oldv);\\n      oldv.removeIfNonNeighbor(this.v2);\\n      this.v2.removeIfNonNeighbor(oldv);\\n      oldv.removeIfNonNeighbor(this.v3);\\n      this.v3.removeIfNonNeighbor(oldv);\\n      this.v1.addUniqueNeighbor(this.v2);\\n      this.v1.addUniqueNeighbor(this.v3);\\n      this.v2.addUniqueNeighbor(this.v1);\\n      this.v2.addUniqueNeighbor(this.v3);\\n      this.v3.addUniqueNeighbor(this.v1);\\n      this.v3.addUniqueNeighbor(this.v2);\\n      this.computeNormal();\\n    }\\n  }]);\\n\\n  return Triangle;\\n}();\\n/**\\n *\\tSimplification Geometry Modifier\\n *    - based on code and technique\\n *\\t  - by Stan Melax in 1998\\n *\\t  - Progressive Mesh type Polygon Reduction Algorithm\\n *    - http://www.melax.com/polychop/\\n */\\n\\n\\nvar SimplifyModifier =\\n/*#__PURE__*/\\nfunction () {\\n  function SimplifyModifier() {\\n    var _this = this;\\n\\n    _classCallCheck(this, SimplifyModifier);\\n\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"computeEdgeCollapseCost\\\", function (u, v) {\\n      // if we collapse edge uv by moving u to v then how\\n      // much different will the model change, i.e. the \\\"error\\\".\\n      var edgelength = v.position.distanceTo(u.position);\\n      var curvature = 0;\\n      var sideFaces = [];\\n      var i,\\n          il = u.faces.length,\\n          face,\\n          sideFace; // find the \\\"sides\\\" triangles that are on the edge uv\\n\\n      for (i = 0; i < il; i++) {\\n        face = u.faces[i];\\n\\n        if (face.hasVertex(v)) {\\n          sideFaces.push(face);\\n        }\\n      } // use the triangle facing most away from the sides\\n      // to determine our curvature term\\n\\n\\n      for (i = 0; i < il; i++) {\\n        var minCurvature = 1;\\n        face = u.faces[i];\\n\\n        for (var j = 0; j < sideFaces.length; j++) {\\n          sideFace = sideFaces[j]; // use dot product of face normals.\\n\\n          var dotProd = face.normal.dot(sideFace.normal);\\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\\n        }\\n\\n        curvature = Math.max(curvature, minCurvature);\\n      } // crude approach in attempt to preserve borders\\n      // though it seems not to be totally correct\\n\\n\\n      var borders = 0;\\n\\n      if (sideFaces.length < 2) {\\n        // we add some arbitrary cost for borders,\\n        // borders += 10;\\n        curvature = 1;\\n      }\\n\\n      var amt = edgelength * curvature + borders;\\n      return amt;\\n    });\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"computeEdgeCostAtVertex\\\", function (v) {\\n      // compute the edge collapse cost for all edges that start\\n      // from vertex v.  Since we are only interested in reducing\\n      // the object by selecting the min cost edge at each step, we\\n      // only cache the cost of the least cost edge at this vertex\\n      // (in member variable collapse) as well as the value of the\\n      // cost (in member variable collapseCost).\\n      if (v.neighbors.length === 0) {\\n        // collapse if no neighbors.\\n        v.collapseNeighbor = null;\\n        v.collapseCost = -0.01;\\n        return;\\n      }\\n\\n      v.collapseCost = 100000;\\n      v.collapseNeighbor = null; // search all neighboring edges for \\\"least cost\\\" edge\\n\\n      for (var i = 0; i < v.neighbors.length; i++) {\\n        var collapseCost = _this.computeEdgeCollapseCost(v, v.neighbors[i]);\\n\\n        if (!v.collapseNeighbor) {\\n          v.collapseNeighbor = v.neighbors[i];\\n          v.collapseCost = collapseCost;\\n          v.minCost = collapseCost;\\n          v.totalCost = 0;\\n          v.costCount = 0;\\n        }\\n\\n        v.costCount++;\\n        v.totalCost += collapseCost;\\n\\n        if (collapseCost < v.minCost) {\\n          v.collapseNeighbor = v.neighbors[i];\\n          v.minCost = collapseCost;\\n        }\\n      } // we average the cost of collapsing at this vertex\\n\\n\\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\\n    });\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"removeFace\\\", function (f, faces) {\\n      removeFromArray(faces, f);\\n      if (f.v1) removeFromArray(f.v1.faces, f);\\n      if (f.v2) removeFromArray(f.v2.faces, f);\\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\\n\\n      var vs = [f.v1, f.v2, f.v3];\\n      var v1, v2;\\n\\n      for (var i = 0; i < 3; i++) {\\n        v1 = vs[i];\\n        v2 = vs[(i + 1) % 3];\\n        if (!v1 || !v2) continue;\\n        v1.removeIfNonNeighbor(v2);\\n        v2.removeIfNonNeighbor(v1);\\n      }\\n    });\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"collapse\\\", function (vertices, faces, u, v) {\\n      // u and v are pointers to vertices of an edge\\n      // Collapse the edge uv by moving vertex u onto v\\n      if (!v) {\\n        // u is a vertex all by itself so just delete it..\\n        _this.removeVertex(u, vertices);\\n\\n        return;\\n      }\\n\\n      var i;\\n      var tmpVertices = [];\\n\\n      for (i = 0; i < u.neighbors.length; i++) {\\n        tmpVertices.push(u.neighbors[i]);\\n      } // delete triangles on edge uv:\\n\\n\\n      for (i = u.faces.length - 1; i >= 0; i--) {\\n        if (u.faces[i].hasVertex(v)) {\\n          _this.removeFace(u.faces[i], faces);\\n        }\\n      } // update remaining triangles to have v instead of u\\n\\n\\n      for (i = u.faces.length - 1; i >= 0; i--) {\\n        u.faces[i].replaceVertex(u, v);\\n      }\\n\\n      _this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\\n\\n\\n      for (i = 0; i < tmpVertices.length; i++) {\\n        _this.computeEdgeCostAtVertex(tmpVertices[i]);\\n      }\\n    });\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"minimumCostEdge\\\", function (vertices) {\\n      // O(n * n) approach. TODO optimize this\\n      var least = vertices[0];\\n\\n      for (var i = 0; i < vertices.length; i++) {\\n        if (vertices[i].collapseCost < least.collapseCost) {\\n          least = vertices[i];\\n        }\\n      }\\n\\n      return least;\\n    });\\n    (0, _defineProperty2[\\\"default\\\"])(this, \\\"modify\\\", function (geometry, count) {\\n      geometry = geometry.clone();\\n      var attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\\n\\n      for (var name in attributes) {\\n        if (name !== 'position') geometry.deleteAttribute(name);\\n      }\\n\\n      geometry = (0, _BufferGeometryUtils.mergeVertices)(geometry); //\\n      // put data of original geometry in different data structures\\n      //\\n\\n      var vertices = [];\\n      var faces = []; // add vertices\\n\\n      var positionAttribute = geometry.getAttribute('position');\\n\\n      for (var i = 0; i < positionAttribute.count; i++) {\\n        var v = new _three.Vector3().fromBufferAttribute(positionAttribute, i);\\n        var vertex = new Vertex(v, i);\\n        vertices.push(vertex);\\n      } // add faces\\n\\n\\n      var geomIndex = geometry.getIndex();\\n\\n      if (geomIndex !== null) {\\n        for (var _i = 0; _i < geomIndex.count; _i += 3) {\\n          var a = geomIndex.getX(_i);\\n          var b = geomIndex.getX(_i + 1);\\n          var c = geomIndex.getX(_i + 2);\\n          var triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\\n          faces.push(triangle);\\n        }\\n      } else {\\n        for (var _i2 = 0; _i2 < positionAttribute.count; _i2 += 3) {\\n          var _a = _i2;\\n\\n          var _b = _i2 + 1;\\n\\n          var _c = _i2 + 2;\\n\\n          var _triangle = new Triangle(vertices[_a], vertices[_b], vertices[_c], _a, _b, _c);\\n\\n          faces.push(_triangle);\\n        }\\n      } // compute all edge collapse costs\\n\\n\\n      for (var _i3 = 0, il = vertices.length; _i3 < il; _i3++) {\\n        _this.computeEdgeCostAtVertex(vertices[_i3]);\\n      }\\n\\n      var nextVertex;\\n      var z = count;\\n\\n      while (z--) {\\n        nextVertex = _this.minimumCostEdge(vertices);\\n\\n        if (!nextVertex) {\\n          console.log('THREE.SimplifyModifier: No next vertex');\\n          break;\\n        } else {\\n          _this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\\n        }\\n      } //\\n\\n\\n      var simplifiedGeometry = new _three.BufferGeometry();\\n      var position = [];\\n      var index = []; //\\n\\n      for (var _i4 = 0; _i4 < vertices.length; _i4++) {\\n        var _vertex = vertices[_i4].position;\\n        position.push(_vertex.x, _vertex.y, _vertex.z);\\n      } //\\n\\n\\n      for (var _i5 = 0; _i5 < faces.length; _i5++) {\\n        var face = faces[_i5];\\n\\n        var _a2 = vertices.indexOf(face.v1);\\n\\n        var _b2 = vertices.indexOf(face.v2);\\n\\n        var _c2 = vertices.indexOf(face.v3);\\n\\n        index.push(_a2, _b2, _c2);\\n      } //\\n\\n\\n      simplifiedGeometry.setAttribute('position', new _three.Float32BufferAttribute(position, 3));\\n      simplifiedGeometry.setIndex(index);\\n      return simplifiedGeometry;\\n    });\\n  }\\n\\n  _createClass(SimplifyModifier, [{\\n    key: \\\"removeVertex\\\",\\n    value: function removeVertex(v, vertices) {\\n      console.assert(v.faces.length === 0);\\n\\n      while (v.neighbors.length) {\\n        var n = v.neighbors.pop();\\n        removeFromArray(n.neighbors, v);\\n      }\\n\\n      removeFromArray(vertices, v);\\n    }\\n  }]);\\n\\n  return SimplifyModifier;\\n}();\\n\\nexports.SimplifyModifier = SimplifyModifier;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_classCallCheck\",\"instance\",\"Constructor\",\"TypeError\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"protoProps\",\"staticProps\",\"prototype\",\"removeFromArray\",\"array\",\"object\",\"k\",\"indexOf\",\"splice\",\"value\",\"SimplifyModifier\",\"_defineProperty2\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"_three\",\"_BufferGeometryUtils\",\"cb\",\"Vector3\",\"ab\",\"Vertex\",\"v\",\"id\",\"position\",\"faces\",\"neighbors\",\"collapseCost\",\"collapseNeighbor\",\"addUniqueNeighbor\",\"vertex\",\"push\",\"removeIfNonNeighbor\",\"n\",\"offset\",\"hasVertex\",\"Triangle\",\"v1\",\"v2\",\"v3\",\"a\",\"b\",\"c\",\"computeNormal\",\"vA\",\"vB\",\"subVectors\",\"cross\",\"normalize\",\"normal\",\"copy\",\"replaceVertex\",\"oldv\",\"newv\",\"_this\",\"u\",\"edgelength\",\"distanceTo\",\"curvature\",\"sideFaces\",\"il\",\"face\",\"minCurvature\",\"j\",\"sideFace\",\"dotProd\",\"dot\",\"Math\",\"min\",\"max\",\"computeEdgeCollapseCost\",\"minCost\",\"totalCost\",\"costCount\",\"f\",\"vs\",\"vertices\",\"tmpVertices\",\"removeFace\",\"removeVertex\",\"computeEdgeCostAtVertex\",\"least\",\"geometry\",\"count\",\"clone\",\"attributes\",\"name\",\"deleteAttribute\",\"mergeVertices\",\"positionAttribute\",\"getAttribute\",\"fromBufferAttribute\",\"geomIndex\",\"getIndex\",\"_i\",\"getX\",\"triangle\",\"_i2\",\"_a\",\"_b\",\"_c\",\"_triangle\",\"_i3\",\"z\",\"nextVertex\",\"minimumCostEdge\",\"collapse\",\"console\",\"log\",\"simplifiedGeometry\",\"BufferGeometry\",\"index\",\"_i4\",\"_vertex\",\"x\",\"y\",\"_i5\",\"_a2\",\"_b2\",\"_c2\",\"setAttribute\",\"Float32BufferAttribute\",\"setIndex\",\"assert\",\"pop\"]\n}\n"]