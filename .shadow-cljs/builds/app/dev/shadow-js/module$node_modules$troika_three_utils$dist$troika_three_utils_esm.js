["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/troika-three-utils/dist/troika-three-utils.esm.js"],"~:js","shadow$provide.module$node_modules$troika_three_utils$dist$troika_three_utils_esm=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:\nfunction(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&\n_defineProperties(Constructor,staticProps);return Constructor}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,\np){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}function expandShaderIncludes(source){return source.replace(/^[ \\t]*#include +<([\\w\\d./]+)>/gm,function(match,include){return(include=_three.ShaderChunk[include])?expandShaderIncludes(include):match})}function createDerivedMaterial(baseMaterial,options){var optionsKey=getKeyForOptions(options),ctorsByDerivation=CONSTRUCTOR_CACHE.get(baseMaterial);ctorsByDerivation||CONSTRUCTOR_CACHE.set(baseMaterial,ctorsByDerivation=Object.create(null));\nif(ctorsByDerivation[optionsKey])return new ctorsByDerivation[optionsKey];var privateBeforeCompileProp=\"_onBeforeCompile\".concat(optionsKey),onBeforeCompile=function(shaderInfo){baseMaterial.onBeforeCompile.call(this,shaderInfo);var cacheKey=optionsKey+\"|||\"+shaderInfo.vertexShader+\"|||\"+shaderInfo.fragmentShader,upgradedShaders=SHADER_UPGRADE_CACHE[cacheKey];upgradedShaders||(upgradedShaders=upgradeShaders(shaderInfo,options,optionsKey),upgradedShaders=SHADER_UPGRADE_CACHE[cacheKey]=upgradedShaders);\nshaderInfo.vertexShader=upgradedShaders.vertexShader;shaderInfo.fragmentShader=upgradedShaders.fragmentShader;assign(shaderInfo.uniforms,this.uniforms);options.timeUniform&&(shaderInfo.uniforms[options.timeUniform]={get value(){return Date.now()-epoch}});if(this[privateBeforeCompileProp])this[privateBeforeCompileProp](shaderInfo)},DerivedMaterial=function(){return derive(options.chained?baseMaterial:baseMaterial.clone())},derive=function(base){var derived=Object.create(base,descriptor);Object.defineProperty(derived,\n\"baseMaterial\",{value:baseMaterial});Object.defineProperty(derived,\"id\",{value:materialInstanceId++});var JSCompiler_inline_result=4294967295*Math.random()|0;var d1=4294967295*Math.random()|0,d2=4294967295*Math.random()|0,d3=4294967295*Math.random()|0;JSCompiler_inline_result=(_lut[JSCompiler_inline_result&255]+_lut[JSCompiler_inline_result>>8&255]+_lut[JSCompiler_inline_result>>16&255]+_lut[JSCompiler_inline_result>>24&255]+\"-\"+_lut[d1&255]+_lut[d1>>8&255]+\"-\"+_lut[d1>>16&15|64]+_lut[d1>>24&255]+\n\"-\"+_lut[d2&63|128]+_lut[d2>>8&255]+\"-\"+_lut[d2>>16&255]+_lut[d2>>24&255]+_lut[d3&255]+_lut[d3>>8&255]+_lut[d3>>16&255]+_lut[d3>>24&255]).toUpperCase();derived.uuid=JSCompiler_inline_result;derived.uniforms=assign({},base.uniforms,options.uniforms);derived.defines=assign({},base.defines,options.defines);derived.defines[\"TROIKA_DERIVED_MATERIAL_\".concat(optionsKey)]=\"\";derived.extensions=assign({},base.extensions,options.extensions);derived._listeners=void 0;return derived},descriptor={constructor:{value:DerivedMaterial},\nisDerivedMaterial:{value:!0},customProgramCacheKey:{writable:!0,configurable:!0,value:function(){return optionsKey}},onBeforeCompile:{get:function(){return onBeforeCompile},set:function(fn){this[privateBeforeCompileProp]=fn}},copy:{writable:!0,configurable:!0,value:function(source){baseMaterial.copy.call(this,source);baseMaterial.isShaderMaterial||baseMaterial.isDerivedMaterial||(assign(this.extensions,source.extensions),assign(this.defines,source.defines),assign(this.uniforms,_three.UniformsUtils.clone(source.uniforms)));\nreturn this}},clone:{writable:!0,configurable:!0,value:function(){var newBase=new baseMaterial.constructor;return derive(newBase).copy(this)}},getDepthMaterial:{writable:!0,configurable:!0,value:function(){var depthMaterial=this._depthMaterial;depthMaterial||(depthMaterial=this._depthMaterial=createDerivedMaterial(baseMaterial.isDerivedMaterial?baseMaterial.getDepthMaterial():new _three.MeshDepthMaterial({depthPacking:_three.RGBADepthPacking}),options),depthMaterial.defines.IS_DEPTH_MATERIAL=\"\",depthMaterial.uniforms=\nthis.uniforms);return depthMaterial}},getDistanceMaterial:{writable:!0,configurable:!0,value:function(){var distanceMaterial=this._distanceMaterial;distanceMaterial||(distanceMaterial=this._distanceMaterial=createDerivedMaterial(baseMaterial.isDerivedMaterial?baseMaterial.getDistanceMaterial():new _three.MeshDistanceMaterial,options),distanceMaterial.defines.IS_DISTANCE_MATERIAL=\"\",distanceMaterial.uniforms=this.uniforms);return distanceMaterial}},dispose:{writable:!0,configurable:!0,value:function(){var _depthMaterial=\nthis._depthMaterial,_distanceMaterial=this._distanceMaterial;_depthMaterial&&_depthMaterial.dispose();_distanceMaterial&&_distanceMaterial.dispose();baseMaterial.dispose.call(this)}}};ctorsByDerivation[optionsKey]=DerivedMaterial;return new DerivedMaterial}function upgradeShaders(_ref,options,key){var vertexShader=_ref.vertexShader,fragmentShader=_ref.fragmentShader;_ref=options.vertexDefs;var vertexMainIntro=options.vertexMainIntro,vertexMainOutro=options.vertexMainOutro,vertexTransform=options.vertexTransform,\nfragmentDefs=options.fragmentDefs,fragmentMainIntro=options.fragmentMainIntro,fragmentMainOutro=options.fragmentMainOutro,fragmentColorTransform=options.fragmentColorTransform,customRewriter=options.customRewriter;options=options.timeUniform;_ref=_ref||\"\";vertexMainIntro=vertexMainIntro||\"\";vertexMainOutro=vertexMainOutro||\"\";fragmentDefs=fragmentDefs||\"\";fragmentMainIntro=fragmentMainIntro||\"\";fragmentMainOutro=fragmentMainOutro||\"\";if(vertexTransform||customRewriter)vertexShader=expandShaderIncludes(vertexShader);\nif(fragmentColorTransform||customRewriter)fragmentShader=fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\"\\n//!BEGIN_POST_CHUNK $1\\n$\\x26\\n//!END_POST_CHUNK\\n\"),fragmentShader=expandShaderIncludes(fragmentShader);customRewriter&&(fragmentShader=customRewriter({vertexShader,fragmentShader}),vertexShader=fragmentShader.vertexShader,fragmentShader=fragmentShader.fragmentShader);if(fragmentColorTransform){var postChunks=[];fragmentShader=\nfragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm,function(match){postChunks.push(match);return\"\"});fragmentMainOutro=\"\".concat(fragmentColorTransform,\"\\n\").concat(postChunks.join(\"\\n\"),\"\\n\").concat(fragmentMainOutro)}options&&(fragmentColorTransform=\"\\nuniform float \".concat(options,\";\\n\"),_ref=fragmentColorTransform+_ref,fragmentDefs=fragmentColorTransform+fragmentDefs);vertexTransform&&(vertexShader=\"vec3 troika_position_\".concat(key,\";\\nvec3 troika_normal_\").concat(key,\n\";\\nvec2 troika_uv_\").concat(key,\";\\n\").concat(vertexShader,\"\\n\"),_ref=\"\".concat(_ref,\"\\nvoid troikaVertexTransform\").concat(key,\"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  \").concat(vertexTransform,\"\\n}\\n\"),vertexMainIntro=\"\\ntroika_position_\".concat(key,\" \\x3d vec3(position);\\ntroika_normal_\").concat(key,\" \\x3d vec3(normal);\\ntroika_uv_\").concat(key,\" \\x3d vec2(uv);\\ntroikaVertexTransform\").concat(key,\"(troika_position_\").concat(key,\", troika_normal_\").concat(key,\", troika_uv_\").concat(key,\n\");\\n\").concat(vertexMainIntro,\"\\n\"),vertexShader=vertexShader.replace(/\\b(position|normal|uv)\\b/g,function(match,match1,index,fullStr){return/\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0,index))?match1:\"troika_\".concat(match1,\"_\").concat(key)}));vertexShader=injectIntoShaderCode(vertexShader,key,_ref,vertexMainIntro,vertexMainOutro);fragmentShader=injectIntoShaderCode(fragmentShader,key,fragmentDefs,fragmentMainIntro,fragmentMainOutro);return{vertexShader,fragmentShader}}function injectIntoShaderCode(shaderCode,\nid,defs,intro,outro){if(intro||outro||defs)shaderCode=shaderCode.replace(voidMainRegExp,\"\\n\".concat(defs,\"\\nvoid troikaOrigMain\").concat(id,\"() {\")),shaderCode+=\"\\nvoid main() {\\n  \".concat(intro,\"\\n  troikaOrigMain\").concat(id,\"();\\n  \").concat(outro,\"\\n}\");return shaderCode}function optionsJsonReplacer(key,value){return\"uniforms\"===key?void 0:\"function\"===typeof value?value.toString():value}function getKeyForOptions(options){options=JSON.stringify(options,optionsJsonReplacer);var id=optionsHashesToIds.get(options);\nnull==id&&optionsHashesToIds.set(options,id=++_idCtr);return id}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.createDerivedMaterial=createDerivedMaterial;exports.expandShaderIncludes=expandShaderIncludes;exports.getShaderUniformTypes=function(shader){for(var uniformRE=/\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g,uniforms=Object.create(null),match;null!==(match=uniformRE.exec(shader));)uniforms[match[2]]=match[1];return uniforms};exports.getShadersForMaterial=function(material){var builtinType=\nMATERIAL_TYPES_TO_SHADERS[material.type];return builtinType?_three.ShaderLib[builtinType]:material};exports.invertMatrix4=function(srcMatrix){var tgtMatrix=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new _three.Matrix4;\"function\"===typeof tgtMatrix.invert?tgtMatrix.copy(srcMatrix).invert():tgtMatrix.getInverse(srcMatrix);return tgtMatrix};exports.voidMainRegExp=exports.BezierMesh=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),voidMainRegExp=/\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\nexports.voidMainRegExp=voidMainRegExp;var _lut=[];for(global=0;256>global;global++)_lut[global]=(16>global?\"0\":\"\")+global.toString(16);var assign=Object.assign||function(){for(var target=arguments[0],_i=1,len=arguments.length;_i<len;_i++){var source=arguments[_i];if(source)for(var prop in source)source.hasOwnProperty(prop)&&(target[prop]=source[prop])}return target},epoch=Date.now(),CONSTRUCTOR_CACHE=new WeakMap,SHADER_UPGRADE_CACHE=new Map,materialInstanceId=1E10,_idCtr=0,optionsHashesToIds=new Map,\nMATERIAL_TYPES_TO_SHADERS={MeshDepthMaterial:\"depth\",MeshDistanceMaterial:\"distanceRGBA\",MeshNormalMaterial:\"normal\",MeshBasicMaterial:\"basic\",MeshLambertMaterial:\"lambert\",MeshPhongMaterial:\"phong\",MeshToonMaterial:\"toon\",MeshStandardMaterial:\"physical\",MeshPhysicalMaterial:\"physical\",MeshMatcapMaterial:\"matcap\",LineBasicMaterial:\"basic\",LineDashedMaterial:\"dashed\",PointsMaterial:\"points\",ShadowMaterial:\"shadow\",SpriteMaterial:\"sprite\"},geometry=null,defaultBaseMaterial=new _three.MeshStandardMaterial({color:16777215,\nside:_three.DoubleSide});global=function(_Mesh){function BezierMesh(){if(!(this instanceof BezierMesh))throw new TypeError(\"Cannot call a class as a function\");var _this=_getPrototypeOf(BezierMesh).call(this,BezierMesh.getGeometry(),defaultBaseMaterial);if(!_this||\"object\"!==_typeof(_this)&&\"function\"!==typeof _this){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");_this=this}_this.pointA=new _three.Vector3;_this.controlA=new _three.Vector3;_this.controlB=\nnew _three.Vector3;_this.pointB=new _three.Vector3;_this.radius=.01;_this.dashArray=new _three.Vector2;_this.dashOffset=0;_this.frustumCulled=!1;return _this}_inherits(BezierMesh,_Mesh);_createClass(BezierMesh,null,[{key:\"getGeometry\",value:function(){return geometry||(geometry=(new _three.CylinderBufferGeometry(1,1,1,6,64)).translate(0,.5,0))}}]);_createClass(BezierMesh,[{key:\"onBeforeRender\",value:function(shaderInfo){shaderInfo=this.material.uniforms;var controlA=this.controlA,controlB=this.controlB,\npointB=this.pointB,radius=this.radius,dashArray=this.dashArray,dashOffset=this.dashOffset;shaderInfo.pointA.value.copy(this.pointA);shaderInfo.controlA.value.copy(controlA);shaderInfo.controlB.value.copy(controlB);shaderInfo.pointB.value.copy(pointB);shaderInfo.radius.value=radius;shaderInfo.dashing.value.set(dashArray.x,dashArray.y,dashOffset||0)}},{key:\"raycast\",value:function(raycaster,intersects){}},{key:\"material\",get:function(){var derivedMaterial=this._derivedMaterial,baseMaterial=this._baseMaterial||\nthis._defaultMaterial||(this._defaultMaterial=defaultBaseMaterial.clone());derivedMaterial&&derivedMaterial.baseMaterial===baseMaterial||(derivedMaterial=this._derivedMaterial=createDerivedMaterial(baseMaterial,{chained:!0,uniforms:{pointA:{value:new _three.Vector3},controlA:{value:new _three.Vector3},controlB:{value:new _three.Vector3},pointB:{value:new _three.Vector3},radius:{value:.01},dashing:{value:new _three.Vector3}},vertexDefs:\"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 \\x3d 1.0 - t;\\n  float b0 \\x3d t2 * t2 * t2;\\n  float b1 \\x3d 3.0 * t * t2 * t2;\\n  float b2 \\x3d 3.0 * t * t * t2;\\n  float b3 \\x3d t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 \\x3d 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\",\nvertexTransform:'\\nfloat t \\x3d position.y;\\nbezierT \\x3d t;\\nvec3 bezierCenterPos \\x3d cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir \\x3d normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won\\'t see them: \\nvec3 viewDirection \\x3d normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir \\x3d\\x3d viewDirection) {\\n  bezierDir \\x3d normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t \\x3d\\x3d 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways \\x3d normalize(cross(bezierDir, viewDirection));\\nvec3 upish \\x3d normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz \\x3d sideways * radius;\\ndiscTx[1].xyz \\x3d bezierDir * radius;\\ndiscTx[2].xyz \\x3d upish * radius;\\ndiscTx[3].xyz \\x3d bezierCenterPos;\\ndiscTx[3][3] \\x3d 1.0;\\n\\n// Apply transform, ignoring original y\\nposition \\x3d (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal \\x3d normalize(mat3(discTx) * normal);\\n',\nfragmentDefs:\"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\",fragmentMainIntro:\"\\nif (dashing.x + dashing.y \\x3e 0.0) {\\n  float dashFrac \\x3d mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac \\x3e dashing.x) {\\n    discard;\\n  }\\n}\\n\"}),baseMaterial.addEventListener(\"dispose\",function onDispose(){baseMaterial.removeEventListener(\"dispose\",onDispose);derivedMaterial.dispose()}));return derivedMaterial},set:function(baseMaterial){this._baseMaterial=baseMaterial}},{key:\"customDepthMaterial\",\nget:function(){return this.material.getDepthMaterial()}},{key:\"customDistanceMaterial\",get:function(){return this.material.getDistanceMaterial()}}]);return BezierMesh}(_three.Mesh);exports.BezierMesh=global}","~:source","shadow$provide[\"module$node_modules$troika_three_utils$dist$troika_three_utils_esm\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createDerivedMaterial = createDerivedMaterial;\nexports.expandShaderIncludes = expandShaderIncludes;\nexports.getShaderUniformTypes = getShaderUniformTypes;\nexports.getShadersForMaterial = getShadersForMaterial;\nexports.invertMatrix4 = invertMatrix4;\nexports.voidMainRegExp = exports.BezierMesh = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */\nvar voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */\n\nexports.voidMainRegExp = voidMainRegExp;\n\nfunction expandShaderIncludes(source) {\n  var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\n  function replace(match, include) {\n    var chunk = _three.ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match;\n  }\n\n  return source.replace(pattern, replace);\n}\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */\n\n\nvar _lut = [];\n\nfor (var i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n}\n\nfunction generateUUID() {\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n  var d0 = Math.random() * 0xffffffff | 0;\n  var d1 = Math.random() * 0xffffffff | 0;\n  var d2 = Math.random() * 0xffffffff | 0;\n  var d3 = Math.random() * 0xffffffff | 0;\n  var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.\n\n  return uuid.toUpperCase();\n} // Local assign polyfill to avoid importing troika-core\n\n\nvar assign = Object.assign || function ()\n/*target, ...sources*/\n{\n  var target = arguments[0];\n\n  for (var _i = 1, len = arguments.length; _i < len; _i++) {\n    var source = arguments[_i];\n\n    if (source) {\n      for (var prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n\n  return target;\n};\n\nvar epoch = Date.now();\nvar CONSTRUCTOR_CACHE = new WeakMap();\nvar SHADER_UPGRADE_CACHE = new Map(); // Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\n\nvar materialInstanceId = 1e10;\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object} options.defines - Custom `defines` for the material\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */\n\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  var optionsKey = getKeyForOptions(options); // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n\n  var ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));\n  }\n\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]();\n  }\n\n  var privateBeforeCompileProp = \"_onBeforeCompile\".concat(optionsKey); // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n\n  var onBeforeCompile = function onBeforeCompile(shaderInfo) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo); // Upgrade the shaders, caching the result by incoming source code\n\n    var cacheKey = optionsKey + '|||' + shaderInfo.vertexShader + '|||' + shaderInfo.fragmentShader;\n    var upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n\n    if (!upgradedShaders) {\n      var upgraded = upgradeShaders(shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    } // Inject upgraded shaders and uniforms into the program\n\n\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms); // Inject auto-updating time uniform if requested\n\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {\n          return Date.now() - epoch;\n        }\n\n      };\n    } // Users can still add their own handlers on top of ours\n\n\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  var DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone());\n  };\n\n  var derive = function derive(base) {\n    // Prototype chain to the base material\n    var derived = Object.create(base, descriptor); // Store the baseMaterial for reference; this is always the original even when cloning\n\n    Object.defineProperty(derived, 'baseMaterial', {\n      value: baseMaterial\n    }); // Needs its own ids\n\n    Object.defineProperty(derived, 'id', {\n      value: materialInstanceId++\n    });\n    derived.uuid = generateUUID(); // Merge uniforms, defines, and extensions\n\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[\"TROIKA_DERIVED_MATERIAL_\".concat(optionsKey)] = ''; //force a program change from the base material\n\n    derived.extensions = assign({}, base.extensions, options.extensions); // Don't inherit EventDispatcher listeners\n\n    derived._listeners = undefined;\n    return derived;\n  };\n\n  var descriptor = {\n    constructor: {\n      value: DerivedMaterial\n    },\n    isDerivedMaterial: {\n      value: true\n    },\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        return optionsKey;\n      }\n    },\n    onBeforeCompile: {\n      get: function get() {\n        return onBeforeCompile;\n      },\n      set: function set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function value(source) {\n        baseMaterial.copy.call(this, source);\n\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, _three.UniformsUtils.clone(source.uniforms));\n        }\n\n        return this;\n      }\n    },\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this);\n      }\n    },\n\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var depthMaterial = this._depthMaterial;\n\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new _three.MeshDepthMaterial({\n            depthPacking: _three.RGBADepthPacking\n          }), options);\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return depthMaterial;\n      }\n    },\n\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var distanceMaterial = this._distanceMaterial;\n\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new _three.MeshDistanceMaterial(), options);\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return distanceMaterial;\n      }\n    },\n    dispose: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var _depthMaterial = this._depthMaterial,\n            _distanceMaterial = this._distanceMaterial;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial();\n}\n\nfunction upgradeShaders(_ref, options, key) {\n  var vertexShader = _ref.vertexShader,\n      fragmentShader = _ref.fragmentShader;\n  var vertexDefs = options.vertexDefs,\n      vertexMainIntro = options.vertexMainIntro,\n      vertexMainOutro = options.vertexMainOutro,\n      vertexTransform = options.vertexTransform,\n      fragmentDefs = options.fragmentDefs,\n      fragmentMainIntro = options.fragmentMainIntro,\n      fragmentMainOutro = options.fragmentMainOutro,\n      fragmentColorTransform = options.fragmentColorTransform,\n      customRewriter = options.customRewriter,\n      timeUniform = options.timeUniform;\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || ''; // Expand includes if needed\n\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n');\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  } // Apply custom rewriter function\n\n\n  if (customRewriter) {\n    var res = customRewriter({\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    });\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  } // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n\n\n  if (fragmentColorTransform) {\n    var postChunks = [];\n    fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n    function (match) {\n      postChunks.push(match);\n      return '';\n    });\n    fragmentMainOutro = \"\".concat(fragmentColorTransform, \"\\n\").concat(postChunks.join('\\n'), \"\\n\").concat(fragmentMainOutro);\n  } // Inject auto-updating time uniform if requested\n\n\n  if (timeUniform) {\n    var code = \"\\nuniform float \".concat(timeUniform, \";\\n\");\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  } // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n\n\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = \"vec3 troika_position_\".concat(key, \";\\nvec3 troika_normal_\").concat(key, \";\\nvec2 troika_uv_\").concat(key, \";\\n\").concat(vertexShader, \"\\n\");\n    vertexDefs = \"\".concat(vertexDefs, \"\\nvoid troikaVertexTransform\").concat(key, \"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  \").concat(vertexTransform, \"\\n}\\n\");\n    vertexMainIntro = \"\\ntroika_position_\".concat(key, \" = vec3(position);\\ntroika_normal_\").concat(key, \" = vec3(normal);\\ntroika_uv_\").concat(key, \" = vec2(uv);\\ntroikaVertexTransform\").concat(key, \"(troika_position_\").concat(key, \", troika_normal_\").concat(key, \", troika_uv_\").concat(key, \");\\n\").concat(vertexMainIntro, \"\\n\");\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, function (match, match1, index, fullStr) {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : \"troika_\".concat(match1, \"_\").concat(key);\n    });\n  } // Inject defs and intro/outro snippets\n\n\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n  return {\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader\n  };\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, \"\\n\".concat(defs, \"\\nvoid troikaOrigMain\").concat(id, \"() {\"));\n    shaderCode += \"\\nvoid main() {\\n  \".concat(intro, \"\\n  troikaOrigMain\").concat(id, \"();\\n  \").concat(outro, \"\\n}\");\n  }\n\n  return shaderCode;\n}\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;\n}\n\nvar _idCtr = 0;\nvar optionsHashesToIds = new Map();\n\nfunction getKeyForOptions(options) {\n  var optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  var id = optionsHashesToIds.get(optionsHash);\n\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, id = ++_idCtr);\n  }\n\n  return id;\n} // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\n\n\nvar MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */\n\nfunction getShadersForMaterial(material) {\n  var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? _three.ShaderLib[builtinType] : material; //TODO fallback for unknown type?\n}\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */\n\n\nfunction getShaderUniformTypes(shader) {\n  var uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n  var uniforms = Object.create(null);\n  var match;\n\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n\n  return uniforms;\n}\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */\n\n\nfunction invertMatrix4(srcMatrix) {\n  var tgtMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _three.Matrix4();\n\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n\n  return tgtMatrix;\n}\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/\n\n\nvar vertexDefs = \"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\";\nvar vertexTransform = \"\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \\\"sideways\\\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won't see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n\";\nvar fragmentDefs = \"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\";\nvar fragmentMainIntro = \"\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n\"; // Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(baseMaterial, {\n    chained: true,\n    uniforms: {\n      pointA: {\n        value: new _three.Vector3()\n      },\n      controlA: {\n        value: new _three.Vector3()\n      },\n      controlB: {\n        value: new _three.Vector3()\n      },\n      pointB: {\n        value: new _three.Vector3()\n      },\n      radius: {\n        value: 0.01\n      },\n      dashing: {\n        value: new _three.Vector3()\n      } //on, off, offset\n\n    },\n    vertexDefs: vertexDefs,\n    vertexTransform: vertexTransform,\n    fragmentDefs: fragmentDefs,\n    fragmentMainIntro: fragmentMainIntro\n  });\n}\n\nvar geometry = null;\nvar defaultBaseMaterial =\n/*#__PURE__*/\nnew _three.MeshStandardMaterial({\n  color: 0xffffff,\n  side: _three.DoubleSide\n});\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */\n\nvar BezierMesh =\n/*#__PURE__*/\nfunction (_Mesh) {\n  _inherits(BezierMesh, _Mesh);\n\n  _createClass(BezierMesh, null, [{\n    key: \"getGeometry\",\n    value: function getGeometry() {\n      return geometry || (geometry = new _three.CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n    }\n  }]);\n\n  function BezierMesh() {\n    var _this;\n\n    _classCallCheck(this, BezierMesh);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BezierMesh).call(this, BezierMesh.getGeometry(), defaultBaseMaterial));\n    _this.pointA = new _three.Vector3();\n    _this.controlA = new _three.Vector3();\n    _this.controlB = new _three.Vector3();\n    _this.pointB = new _three.Vector3();\n    _this.radius = 0.01;\n    _this.dashArray = new _three.Vector2();\n    _this.dashOffset = 0; // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n\n    _this.frustumCulled = false;\n    return _this;\n  } // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n\n\n  _createClass(BezierMesh, [{\n    key: \"onBeforeRender\",\n    value: function onBeforeRender(shaderInfo) {\n      var uniforms = this.material.uniforms;\n      var pointA = this.pointA,\n          controlA = this.controlA,\n          controlB = this.controlB,\n          pointB = this.pointB,\n          radius = this.radius,\n          dashArray = this.dashArray,\n          dashOffset = this.dashOffset;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {// TODO - just fail for now\n    }\n  }, {\n    key: \"material\",\n    get: function get() {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial); // dispose the derived material when its base material is disposed:\n\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n\n      return derivedMaterial;\n    },\n    set: function set(baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    } // Create and update material for shadows upon request:\n\n  }, {\n    key: \"customDepthMaterial\",\n    get: function get() {\n      return this.material.getDepthMaterial();\n    }\n  }, {\n    key: \"customDistanceMaterial\",\n    get: function get() {\n      return this.material.getDistanceMaterial();\n    }\n  }]);\n\n  return BezierMesh;\n}(_three.Mesh);\n\nexports.BezierMesh = BezierMesh;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","dashing","extensions","vertexTransform","controlA","SpriteMaterial","frustumCulled","IS_DISTANCE_MATERIAL","getShadersForMaterial","_derivedMaterial","MeshStandardMaterial","copy","prototype","side","MeshBasicMaterial","PointsMaterial","pointA","expandShaderIncludes","key","__esModule","radius","dispose","fragmentMainIntro","id","baseMaterial","IS_DEPTH_MATERIAL","defines","getShaderUniformTypes","_defaultMaterial","voidMainRegExp","vertexShader","configurable","getDepthMaterial","uuid","customProgramCacheKey","value","_depthMaterial","MeshMatcapMaterial","LineDashedMaterial","chained","enumerable","fragmentDefs","MeshPhongMaterial","dashArray","_listeners","writable","ShadowMaterial","vertexDefs","BezierMesh","MeshPhysicalMaterial","MeshDistanceMaterial","onBeforeCompile","__proto__","MeshDepthMaterial","depthPacking","clone","MeshNormalMaterial","_baseMaterial","set","LineBasicMaterial","uniforms","getDistanceMaterial","pointB","dashOffset","controlB","get","MeshToonMaterial","isDerivedMaterial","color","_distanceMaterial","invertMatrix4","createDerivedMaterial","MeshLambertMaterial","constructor"]],"~:compiled-at",1630917516104,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$troika_three_utils$dist$troika_three_utils_esm.js\",\n\"lineCount\":29,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/troika-three-utils/dist/troika-three-utils.esm.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$troika_three_utils$dist$troika_three_utils_esm\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.createDerivedMaterial = createDerivedMaterial;\\nexports.expandShaderIncludes = expandShaderIncludes;\\nexports.getShaderUniformTypes = getShaderUniformTypes;\\nexports.getShadersForMaterial = getShadersForMaterial;\\nexports.invertMatrix4 = invertMatrix4;\\nexports.voidMainRegExp = exports.BezierMesh = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * Regular expression for matching the `void main() {` opener line in GLSL.\\n * @type {RegExp}\\n */\\nvar voidMainRegExp = /\\\\bvoid\\\\s+main\\\\s*\\\\(\\\\s*\\\\)\\\\s*{/g;\\n/**\\n * Recursively expands all `#include <xyz>` statements within string of shader code.\\n * Copied from three's WebGLProgram#parseIncludes for external use.\\n *\\n * @param {string} source - The GLSL source code to evaluate\\n * @return {string} The GLSL code with all includes expanded\\n */\\n\\nexports.voidMainRegExp = voidMainRegExp;\\n\\nfunction expandShaderIncludes(source) {\\n  var pattern = /^[ \\\\t]*#include +<([\\\\w\\\\d./]+)>/gm;\\n\\n  function replace(match, include) {\\n    var chunk = _three.ShaderChunk[include];\\n    return chunk ? expandShaderIncludes(chunk) : match;\\n  }\\n\\n  return source.replace(pattern, replace);\\n}\\n/*\\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\\n */\\n\\n\\nvar _lut = [];\\n\\nfor (var i = 0; i < 256; i++) {\\n  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);\\n}\\n\\nfunction generateUUID() {\\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\\n  var d0 = Math.random() * 0xffffffff | 0;\\n  var d1 = Math.random() * 0xffffffff | 0;\\n  var d2 = Math.random() * 0xffffffff | 0;\\n  var d3 = Math.random() * 0xffffffff | 0;\\n  var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.\\n\\n  return uuid.toUpperCase();\\n} // Local assign polyfill to avoid importing troika-core\\n\\n\\nvar assign = Object.assign || function ()\\n/*target, ...sources*/\\n{\\n  var target = arguments[0];\\n\\n  for (var _i = 1, len = arguments.length; _i < len; _i++) {\\n    var source = arguments[_i];\\n\\n    if (source) {\\n      for (var prop in source) {\\n        if (source.hasOwnProperty(prop)) {\\n          target[prop] = source[prop];\\n        }\\n      }\\n    }\\n  }\\n\\n  return target;\\n};\\n\\nvar epoch = Date.now();\\nvar CONSTRUCTOR_CACHE = new WeakMap();\\nvar SHADER_UPGRADE_CACHE = new Map(); // Material ids must be integers, but we can't access the increment from Three's `Material` module,\\n// so let's choose a sufficiently large starting value that should theoretically never collide.\\n\\nvar materialInstanceId = 1e10;\\n/**\\n * A utility for creating a custom shader material derived from another material's\\n * shaders. This allows you to inject custom shader logic and transforms into the\\n * builtin ThreeJS materials without having to recreate them from scratch.\\n *\\n * @param {THREE.Material} baseMaterial - the original material to derive from\\n *\\n * @param {Object} options - How the base material should be modified.\\n * @param {Object} options.defines - Custom `defines` for the material\\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\\n *        both shaders, and it will automatically be updated on each render frame with a number of\\n *        elapsed milliseconds. The \\\"zero\\\" epoch time is not significant so don't rely on this as a\\n *        true calendar time.\\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\\n *        definitions, above the `void main()` function.\\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\\n *        shader's `void main` function.\\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\\n *        shader's `void main` function.\\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\\n *        those attributes exposed by their normal names as read/write values.\\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\\n *        definitions, above the `void main()` function.\\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\\n *        shader's `void main` function.\\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\\n *        want those to apply to your changes use `fragmentColorTransform` instead.\\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\\n *        output value. Will be injected near the end of the `void main` function, but before any\\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\\n *        `fragmentMainOutro`.\\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\\n *        special that's not covered by the other builtin options. This function will be executed before\\n *        any other transforms are applied.\\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\\n *        material, rather than the default behavior of copying it. This allows the derived material to\\n *        automatically pick up changes made to the base material and its properties. This can be useful\\n *        where the derived material is hidden from the user as an implementation detail, allowing them\\n *        to work with the original material like normal. But it can result in unexpected behavior if not\\n *        handled carefully.\\n *\\n * @return {THREE.Material}\\n *\\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\\n * which can be called to get a variant of the derived material for use in shadow casting. If the\\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\\n */\\n\\nfunction createDerivedMaterial(baseMaterial, options) {\\n  // Generate a key that is unique to the content of these `options`. We'll use this\\n  // throughout for caching and for generating the upgraded shader code. This increases\\n  // the likelihood that the resulting shaders will line up across multiple calls so\\n  // their GL programs can be shared and cached.\\n  var optionsKey = getKeyForOptions(options); // First check to see if we've already derived from this baseMaterial using this\\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\\n\\n  var ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\\n\\n  if (!ctorsByDerivation) {\\n    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));\\n  }\\n\\n  if (ctorsByDerivation[optionsKey]) {\\n    return new ctorsByDerivation[optionsKey]();\\n  }\\n\\n  var privateBeforeCompileProp = \\\"_onBeforeCompile\\\".concat(optionsKey); // Private onBeforeCompile handler that injects the modified shaders and uniforms when\\n  // the renderer switches to this material's program\\n\\n  var onBeforeCompile = function onBeforeCompile(shaderInfo) {\\n    baseMaterial.onBeforeCompile.call(this, shaderInfo); // Upgrade the shaders, caching the result by incoming source code\\n\\n    var cacheKey = optionsKey + '|||' + shaderInfo.vertexShader + '|||' + shaderInfo.fragmentShader;\\n    var upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\\n\\n    if (!upgradedShaders) {\\n      var upgraded = upgradeShaders(shaderInfo, options, optionsKey);\\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\\n    } // Inject upgraded shaders and uniforms into the program\\n\\n\\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\\n    assign(shaderInfo.uniforms, this.uniforms); // Inject auto-updating time uniform if requested\\n\\n    if (options.timeUniform) {\\n      shaderInfo.uniforms[options.timeUniform] = {\\n        get value() {\\n          return Date.now() - epoch;\\n        }\\n\\n      };\\n    } // Users can still add their own handlers on top of ours\\n\\n\\n    if (this[privateBeforeCompileProp]) {\\n      this[privateBeforeCompileProp](shaderInfo);\\n    }\\n  };\\n\\n  var DerivedMaterial = function DerivedMaterial() {\\n    return derive(options.chained ? baseMaterial : baseMaterial.clone());\\n  };\\n\\n  var derive = function derive(base) {\\n    // Prototype chain to the base material\\n    var derived = Object.create(base, descriptor); // Store the baseMaterial for reference; this is always the original even when cloning\\n\\n    Object.defineProperty(derived, 'baseMaterial', {\\n      value: baseMaterial\\n    }); // Needs its own ids\\n\\n    Object.defineProperty(derived, 'id', {\\n      value: materialInstanceId++\\n    });\\n    derived.uuid = generateUUID(); // Merge uniforms, defines, and extensions\\n\\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\\n    derived.defines = assign({}, base.defines, options.defines);\\n    derived.defines[\\\"TROIKA_DERIVED_MATERIAL_\\\".concat(optionsKey)] = ''; //force a program change from the base material\\n\\n    derived.extensions = assign({}, base.extensions, options.extensions); // Don't inherit EventDispatcher listeners\\n\\n    derived._listeners = undefined;\\n    return derived;\\n  };\\n\\n  var descriptor = {\\n    constructor: {\\n      value: DerivedMaterial\\n    },\\n    isDerivedMaterial: {\\n      value: true\\n    },\\n    customProgramCacheKey: {\\n      writable: true,\\n      configurable: true,\\n      value: function value() {\\n        return optionsKey;\\n      }\\n    },\\n    onBeforeCompile: {\\n      get: function get() {\\n        return onBeforeCompile;\\n      },\\n      set: function set(fn) {\\n        this[privateBeforeCompileProp] = fn;\\n      }\\n    },\\n    copy: {\\n      writable: true,\\n      configurable: true,\\n      value: function value(source) {\\n        baseMaterial.copy.call(this, source);\\n\\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\\n          assign(this.extensions, source.extensions);\\n          assign(this.defines, source.defines);\\n          assign(this.uniforms, _three.UniformsUtils.clone(source.uniforms));\\n        }\\n\\n        return this;\\n      }\\n    },\\n    clone: {\\n      writable: true,\\n      configurable: true,\\n      value: function value() {\\n        var newBase = new baseMaterial.constructor();\\n        return derive(newBase).copy(this);\\n      }\\n    },\\n\\n    /**\\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\\n     * transformations and discarded fragments.\\n     */\\n    getDepthMaterial: {\\n      writable: true,\\n      configurable: true,\\n      value: function value() {\\n        var depthMaterial = this._depthMaterial;\\n\\n        if (!depthMaterial) {\\n          depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new _three.MeshDepthMaterial({\\n            depthPacking: _three.RGBADepthPacking\\n          }), options);\\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\\n        }\\n\\n        return depthMaterial;\\n      }\\n    },\\n\\n    /**\\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\\n     * transformations and discarded fragments.\\n     */\\n    getDistanceMaterial: {\\n      writable: true,\\n      configurable: true,\\n      value: function value() {\\n        var distanceMaterial = this._distanceMaterial;\\n\\n        if (!distanceMaterial) {\\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new _three.MeshDistanceMaterial(), options);\\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\\n        }\\n\\n        return distanceMaterial;\\n      }\\n    },\\n    dispose: {\\n      writable: true,\\n      configurable: true,\\n      value: function value() {\\n        var _depthMaterial = this._depthMaterial,\\n            _distanceMaterial = this._distanceMaterial;\\n        if (_depthMaterial) _depthMaterial.dispose();\\n        if (_distanceMaterial) _distanceMaterial.dispose();\\n        baseMaterial.dispose.call(this);\\n      }\\n    }\\n  };\\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\\n  return new DerivedMaterial();\\n}\\n\\nfunction upgradeShaders(_ref, options, key) {\\n  var vertexShader = _ref.vertexShader,\\n      fragmentShader = _ref.fragmentShader;\\n  var vertexDefs = options.vertexDefs,\\n      vertexMainIntro = options.vertexMainIntro,\\n      vertexMainOutro = options.vertexMainOutro,\\n      vertexTransform = options.vertexTransform,\\n      fragmentDefs = options.fragmentDefs,\\n      fragmentMainIntro = options.fragmentMainIntro,\\n      fragmentMainOutro = options.fragmentMainOutro,\\n      fragmentColorTransform = options.fragmentColorTransform,\\n      customRewriter = options.customRewriter,\\n      timeUniform = options.timeUniform;\\n  vertexDefs = vertexDefs || '';\\n  vertexMainIntro = vertexMainIntro || '';\\n  vertexMainOutro = vertexMainOutro || '';\\n  fragmentDefs = fragmentDefs || '';\\n  fragmentMainIntro = fragmentMainIntro || '';\\n  fragmentMainOutro = fragmentMainOutro || ''; // Expand includes if needed\\n\\n  if (vertexTransform || customRewriter) {\\n    vertexShader = expandShaderIncludes(vertexShader);\\n  }\\n\\n  if (fragmentColorTransform || customRewriter) {\\n    // We need to be able to find postprocessing chunks after include expansion in order to\\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\\n    // so we still mark them.\\n    fragmentShader = fragmentShader.replace(/^[ \\\\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\\\\n//!BEGIN_POST_CHUNK $1\\\\n$&\\\\n//!END_POST_CHUNK\\\\n');\\n    fragmentShader = expandShaderIncludes(fragmentShader);\\n  } // Apply custom rewriter function\\n\\n\\n  if (customRewriter) {\\n    var res = customRewriter({\\n      vertexShader: vertexShader,\\n      fragmentShader: fragmentShader\\n    });\\n    vertexShader = res.vertexShader;\\n    fragmentShader = res.fragmentShader;\\n  } // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\\n  // those and re-insert them into the outro in the correct place:\\n\\n\\n  if (fragmentColorTransform) {\\n    var postChunks = [];\\n    fragmentShader = fragmentShader.replace(/^\\\\/\\\\/!BEGIN_POST_CHUNK[^]+?^\\\\/\\\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\\n    function (match) {\\n      postChunks.push(match);\\n      return '';\\n    });\\n    fragmentMainOutro = \\\"\\\".concat(fragmentColorTransform, \\\"\\\\n\\\").concat(postChunks.join('\\\\n'), \\\"\\\\n\\\").concat(fragmentMainOutro);\\n  } // Inject auto-updating time uniform if requested\\n\\n\\n  if (timeUniform) {\\n    var code = \\\"\\\\nuniform float \\\".concat(timeUniform, \\\";\\\\n\\\");\\n    vertexDefs = code + vertexDefs;\\n    fragmentDefs = code + fragmentDefs;\\n  } // Inject a function for the vertexTransform and rename all usages of position/normal/uv\\n\\n\\n  if (vertexTransform) {\\n    // Hoist these defs to the very top so they work in other function defs\\n    vertexShader = \\\"vec3 troika_position_\\\".concat(key, \\\";\\\\nvec3 troika_normal_\\\").concat(key, \\\";\\\\nvec2 troika_uv_\\\").concat(key, \\\";\\\\n\\\").concat(vertexShader, \\\"\\\\n\\\");\\n    vertexDefs = \\\"\\\".concat(vertexDefs, \\\"\\\\nvoid troikaVertexTransform\\\").concat(key, \\\"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\\\n  \\\").concat(vertexTransform, \\\"\\\\n}\\\\n\\\");\\n    vertexMainIntro = \\\"\\\\ntroika_position_\\\".concat(key, \\\" = vec3(position);\\\\ntroika_normal_\\\").concat(key, \\\" = vec3(normal);\\\\ntroika_uv_\\\").concat(key, \\\" = vec2(uv);\\\\ntroikaVertexTransform\\\").concat(key, \\\"(troika_position_\\\").concat(key, \\\", troika_normal_\\\").concat(key, \\\", troika_uv_\\\").concat(key, \\\");\\\\n\\\").concat(vertexMainIntro, \\\"\\\\n\\\");\\n    vertexShader = vertexShader.replace(/\\\\b(position|normal|uv)\\\\b/g, function (match, match1, index, fullStr) {\\n      return /\\\\battribute\\\\s+vec[23]\\\\s+$/.test(fullStr.substr(0, index)) ? match1 : \\\"troika_\\\".concat(match1, \\\"_\\\").concat(key);\\n    });\\n  } // Inject defs and intro/outro snippets\\n\\n\\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\\n  return {\\n    vertexShader: vertexShader,\\n    fragmentShader: fragmentShader\\n  };\\n}\\n\\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\\n  if (intro || outro || defs) {\\n    shaderCode = shaderCode.replace(voidMainRegExp, \\\"\\\\n\\\".concat(defs, \\\"\\\\nvoid troikaOrigMain\\\").concat(id, \\\"() {\\\"));\\n    shaderCode += \\\"\\\\nvoid main() {\\\\n  \\\".concat(intro, \\\"\\\\n  troikaOrigMain\\\").concat(id, \\\"();\\\\n  \\\").concat(outro, \\\"\\\\n}\\\");\\n  }\\n\\n  return shaderCode;\\n}\\n\\nfunction optionsJsonReplacer(key, value) {\\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;\\n}\\n\\nvar _idCtr = 0;\\nvar optionsHashesToIds = new Map();\\n\\nfunction getKeyForOptions(options) {\\n  var optionsHash = JSON.stringify(options, optionsJsonReplacer);\\n  var id = optionsHashesToIds.get(optionsHash);\\n\\n  if (id == null) {\\n    optionsHashesToIds.set(optionsHash, id = ++_idCtr);\\n  }\\n\\n  return id;\\n} // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\\n// TODO how can we keep this from getting stale?\\n\\n\\nvar MATERIAL_TYPES_TO_SHADERS = {\\n  MeshDepthMaterial: 'depth',\\n  MeshDistanceMaterial: 'distanceRGBA',\\n  MeshNormalMaterial: 'normal',\\n  MeshBasicMaterial: 'basic',\\n  MeshLambertMaterial: 'lambert',\\n  MeshPhongMaterial: 'phong',\\n  MeshToonMaterial: 'toon',\\n  MeshStandardMaterial: 'physical',\\n  MeshPhysicalMaterial: 'physical',\\n  MeshMatcapMaterial: 'matcap',\\n  LineBasicMaterial: 'basic',\\n  LineDashedMaterial: 'dashed',\\n  PointsMaterial: 'points',\\n  ShadowMaterial: 'shadow',\\n  SpriteMaterial: 'sprite'\\n};\\n/**\\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\\n * used to render that material.\\n *\\n * @param material - the Material instance\\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\\n */\\n\\nfunction getShadersForMaterial(material) {\\n  var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\\n  return builtinType ? _three.ShaderLib[builtinType] : material; //TODO fallback for unknown type?\\n}\\n/**\\n * Find all uniforms and their types within a shader code string.\\n *\\n * @param {string} shader - The shader code to parse\\n * @return {object} mapping of uniform names to their glsl type\\n */\\n\\n\\nfunction getShaderUniformTypes(shader) {\\n  var uniformRE = /\\\\buniform\\\\s+(int|float|vec[234])\\\\s+([A-Za-z_][\\\\w]*)/g;\\n  var uniforms = Object.create(null);\\n  var match;\\n\\n  while ((match = uniformRE.exec(shader)) !== null) {\\n    uniforms[match[2]] = match[1];\\n  }\\n\\n  return uniforms;\\n}\\n/**\\n * Helper for smoothing out the `m.getInverse(x)` --\\u003e `m.copy(x).invert()` conversion\\n * that happened in ThreeJS r123.\\n * @param {Matrix4} srcMatrix\\n * @param {Matrix4} [tgtMatrix]\\n */\\n\\n\\nfunction invertMatrix4(srcMatrix) {\\n  var tgtMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _three.Matrix4();\\n\\n  if (typeof tgtMatrix.invert === 'function') {\\n    tgtMatrix.copy(srcMatrix).invert();\\n  } else {\\n    tgtMatrix.getInverse(srcMatrix);\\n  }\\n\\n  return tgtMatrix;\\n}\\n/*\\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\\ndivided into a reasonable number of height segments.\\n*/\\n\\n\\nvar vertexDefs = \\\"\\\\nuniform vec3 pointA;\\\\nuniform vec3 controlA;\\\\nuniform vec3 controlB;\\\\nuniform vec3 pointB;\\\\nuniform float radius;\\\\nvarying float bezierT;\\\\n\\\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\\\n  float t2 = 1.0 - t;\\\\n  float b0 = t2 * t2 * t2;\\\\n  float b1 = 3.0 * t * t2 * t2;\\\\n  float b2 = 3.0 * t * t * t2;\\\\n  float b3 = t * t * t;\\\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\\\n}\\\\n\\\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\\\n  float t2 = 1.0 - t;\\\\n  return -3.0 * p1 * t2 * t2 +\\\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\\\n    3.0 * p2 * t * t;\\\\n}\\\\n\\\";\\nvar vertexTransform = \\\"\\\\nfloat t = position.y;\\\\nbezierT = t;\\\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\\\n\\\\n// Make \\\\\\\"sideways\\\\\\\" always perpendicular to the camera ray; this ensures that any twists\\\\n// in the cylinder occur where you won't see them: \\\\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\\\nif (bezierDir == viewDirection) {\\\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\\\n}\\\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\\\nvec3 upish = normalize(cross(sideways, bezierDir));\\\\n\\\\n// Build a matrix for transforming this disc in the cylinder:\\\\nmat4 discTx;\\\\ndiscTx[0].xyz = sideways * radius;\\\\ndiscTx[1].xyz = bezierDir * radius;\\\\ndiscTx[2].xyz = upish * radius;\\\\ndiscTx[3].xyz = bezierCenterPos;\\\\ndiscTx[3][3] = 1.0;\\\\n\\\\n// Apply transform, ignoring original y\\\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\\\nnormal = normalize(mat3(discTx) * normal);\\\\n\\\";\\nvar fragmentDefs = \\\"\\\\nuniform vec3 dashing;\\\\nvarying float bezierT;\\\\n\\\";\\nvar fragmentMainIntro = \\\"\\\\nif (dashing.x + dashing.y > 0.0) {\\\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\\\n  if (dashFrac > dashing.x) {\\\\n    discard;\\\\n  }\\\\n}\\\\n\\\"; // Debugging: separate color for each of the 6 sides:\\n// const fragmentColorTransform = `\\n// float sideNum = floor(vUV.x * 6.0);\\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\\n//   vec3(1.0, 0.0, 1.0);\\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\\n// `\\n\\nfunction createBezierMeshMaterial(baseMaterial) {\\n  return createDerivedMaterial(baseMaterial, {\\n    chained: true,\\n    uniforms: {\\n      pointA: {\\n        value: new _three.Vector3()\\n      },\\n      controlA: {\\n        value: new _three.Vector3()\\n      },\\n      controlB: {\\n        value: new _three.Vector3()\\n      },\\n      pointB: {\\n        value: new _three.Vector3()\\n      },\\n      radius: {\\n        value: 0.01\\n      },\\n      dashing: {\\n        value: new _three.Vector3()\\n      } //on, off, offset\\n\\n    },\\n    vertexDefs: vertexDefs,\\n    vertexTransform: vertexTransform,\\n    fragmentDefs: fragmentDefs,\\n    fragmentMainIntro: fragmentMainIntro\\n  });\\n}\\n\\nvar geometry = null;\\nvar defaultBaseMaterial =\\n/*#__PURE__*/\\nnew _three.MeshStandardMaterial({\\n  color: 0xffffff,\\n  side: _three.DoubleSide\\n});\\n/**\\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\\n * automatically.\\n *\\n * The cubiz bezier path is determined by its four `Vector3` properties:\\n * - `pointA`\\n * - `controlA`\\n * - `controlB`\\n * - `pointB`\\n *\\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\\n *\\n * You can also give the tube a dashed appearance with two properties:\\n *\\n * - `dashArray` - an array of two numbers, defining the length of \\\"on\\\" and \\\"off\\\" parts of\\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\\n *   used as input to the cubic bezier function, not its visible length.)\\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\\n *\\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\\n * thicker tubes.\\n *\\n * TODO: proper geometry bounding sphere and raycasting\\n * TODO: allow control of the geometry's segment counts\\n */\\n\\nvar BezierMesh =\\n/*#__PURE__*/\\nfunction (_Mesh) {\\n  _inherits(BezierMesh, _Mesh);\\n\\n  _createClass(BezierMesh, null, [{\\n    key: \\\"getGeometry\\\",\\n    value: function getGeometry() {\\n      return geometry || (geometry = new _three.CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\\n    }\\n  }]);\\n\\n  function BezierMesh() {\\n    var _this;\\n\\n    _classCallCheck(this, BezierMesh);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BezierMesh).call(this, BezierMesh.getGeometry(), defaultBaseMaterial));\\n    _this.pointA = new _three.Vector3();\\n    _this.controlA = new _three.Vector3();\\n    _this.controlB = new _three.Vector3();\\n    _this.pointB = new _three.Vector3();\\n    _this.radius = 0.01;\\n    _this.dashArray = new _three.Vector2();\\n    _this.dashOffset = 0; // TODO - disabling frustum culling until I figure out how to customize the\\n    //  geometry's bounding sphere that gets used\\n\\n    _this.frustumCulled = false;\\n    return _this;\\n  } // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\\n\\n\\n  _createClass(BezierMesh, [{\\n    key: \\\"onBeforeRender\\\",\\n    value: function onBeforeRender(shaderInfo) {\\n      var uniforms = this.material.uniforms;\\n      var pointA = this.pointA,\\n          controlA = this.controlA,\\n          controlB = this.controlB,\\n          pointB = this.pointB,\\n          radius = this.radius,\\n          dashArray = this.dashArray,\\n          dashOffset = this.dashOffset;\\n      uniforms.pointA.value.copy(pointA);\\n      uniforms.controlA.value.copy(controlA);\\n      uniforms.controlB.value.copy(controlB);\\n      uniforms.pointB.value.copy(pointB);\\n      uniforms.radius.value = radius;\\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\\n    }\\n  }, {\\n    key: \\\"raycast\\\",\\n    value: function raycast(raycaster, intersects) {// TODO - just fail for now\\n    }\\n  }, {\\n    key: \\\"material\\\",\\n    get: function get() {\\n      var derivedMaterial = this._derivedMaterial;\\n      var baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\\n\\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial); // dispose the derived material when its base material is disposed:\\n\\n        baseMaterial.addEventListener('dispose', function onDispose() {\\n          baseMaterial.removeEventListener('dispose', onDispose);\\n          derivedMaterial.dispose();\\n        });\\n      }\\n\\n      return derivedMaterial;\\n    },\\n    set: function set(baseMaterial) {\\n      this._baseMaterial = baseMaterial;\\n    } // Create and update material for shadows upon request:\\n\\n  }, {\\n    key: \\\"customDepthMaterial\\\",\\n    get: function get() {\\n      return this.material.getDepthMaterial();\\n    }\\n  }, {\\n    key: \\\"customDistanceMaterial\\\",\\n    get: function get() {\\n      return this.material.getDistanceMaterial();\\n    }\\n  }]);\\n\\n  return BezierMesh;\\n}(_three.Mesh);\\n\\nexports.BezierMesh = BezierMesh;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"expandShaderIncludes\",\"source\",\"replace\",\"pattern\",\"match\",\"include\",\"chunk\",\"_three\",\"ShaderChunk\",\"createDerivedMaterial\",\"baseMaterial\",\"options\",\"optionsKey\",\"getKeyForOptions\",\"ctorsByDerivation\",\"CONSTRUCTOR_CACHE\",\"get\",\"set\",\"privateBeforeCompileProp\",\"concat\",\"onBeforeCompile\",\"shaderInfo\",\"call\",\"cacheKey\",\"vertexShader\",\"fragmentShader\",\"upgradedShaders\",\"SHADER_UPGRADE_CACHE\",\"upgraded\",\"upgradeShaders\",\"assign\",\"uniforms\",\"timeUniform\",\"Date\",\"now\",\"epoch\",\"DerivedMaterial\",\"derive\",\"chained\",\"clone\",\"base\",\"derived\",\"materialInstanceId\",\"d0\",\"Math\",\"random\",\"d1\",\"d2\",\"d3\",\"toUpperCase\",\"_lut\",\"uuid\",\"defines\",\"extensions\",\"_listeners\",\"undefined\",\"isDerivedMaterial\",\"customProgramCacheKey\",\"fn\",\"copy\",\"isShaderMaterial\",\"UniformsUtils\",\"newBase\",\"getDepthMaterial\",\"depthMaterial\",\"_depthMaterial\",\"MeshDepthMaterial\",\"depthPacking\",\"RGBADepthPacking\",\"IS_DEPTH_MATERIAL\",\"getDistanceMaterial\",\"distanceMaterial\",\"_distanceMaterial\",\"MeshDistanceMaterial\",\"IS_DISTANCE_MATERIAL\",\"dispose\",\"_ref\",\"vertexDefs\",\"vertexMainIntro\",\"vertexMainOutro\",\"vertexTransform\",\"fragmentDefs\",\"fragmentMainIntro\",\"fragmentMainOutro\",\"fragmentColorTransform\",\"customRewriter\",\"res\",\"postChunks\",\"push\",\"join\",\"code\",\"match1\",\"index\",\"fullStr\",\"test\",\"substr\",\"injectIntoShaderCode\",\"shaderCode\",\"id\",\"defs\",\"intro\",\"outro\",\"voidMainRegExp\",\"optionsJsonReplacer\",\"toString\",\"optionsHash\",\"JSON\",\"stringify\",\"optionsHashesToIds\",\"_idCtr\",\"getShaderUniformTypes\",\"shader\",\"uniformRE\",\"exec\",\"getShadersForMaterial\",\"material\",\"builtinType\",\"MATERIAL_TYPES_TO_SHADERS\",\"type\",\"ShaderLib\",\"invertMatrix4\",\"srcMatrix\",\"tgtMatrix\",\"arguments\",\"Matrix4\",\"invert\",\"getInverse\",\"BezierMesh\",\"_i\",\"len\",\"prop\",\"hasOwnProperty\",\"WeakMap\",\"Map\",\"MeshNormalMaterial\",\"MeshBasicMaterial\",\"MeshLambertMaterial\",\"MeshPhongMaterial\",\"MeshToonMaterial\",\"MeshStandardMaterial\",\"MeshPhysicalMaterial\",\"MeshMatcapMaterial\",\"LineBasicMaterial\",\"LineDashedMaterial\",\"PointsMaterial\",\"ShadowMaterial\",\"SpriteMaterial\",\"geometry\",\"defaultBaseMaterial\",\"color\",\"side\",\"DoubleSide\",\"_Mesh\",\"instance\",\"getGeometry\",\"self\",\"ReferenceError\",\"_this\",\"pointA\",\"Vector3\",\"controlA\",\"controlB\",\"pointB\",\"radius\",\"dashArray\",\"Vector2\",\"dashOffset\",\"frustumCulled\",\"translate\",\"CylinderBufferGeometry\",\"onBeforeRender\",\"dashing\",\"x\",\"y\",\"raycast\",\"raycaster\",\"intersects\",\"derivedMaterial\",\"_derivedMaterial\",\"_baseMaterial\",\"_defaultMaterial\",\"addEventListener\",\"onDispose\",\"removeEventListener\",\"Mesh\"]\n}\n"]