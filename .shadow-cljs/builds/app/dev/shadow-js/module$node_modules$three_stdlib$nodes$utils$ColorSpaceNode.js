["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/nodes/utils/ColorSpaceNode.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$nodes$utils$ColorSpaceNode=function(global,require,module,exports){function ColorSpaceNode(input,method){_TempNode.TempNode.call(this,\"v4\");this.input=input;this.method=method||ColorSpaceNode.LINEAR_TO_LINEAR}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ColorSpaceNode=ColorSpaceNode;var _three=require(\"module$node_modules$three$build$three_module\"),_TempNode=require(\"module$node_modules$three_stdlib$nodes$core$TempNode\"),_ConstNode=\nrequire(\"module$node_modules$three_stdlib$nodes$core$ConstNode\"),_FloatNode=require(\"module$node_modules$three_stdlib$nodes$inputs$FloatNode\"),_FunctionNode=require(\"module$node_modules$three_stdlib$nodes$core$FunctionNode\"),_ExpressionNode=require(\"module$node_modules$three_stdlib$nodes$core$ExpressionNode\");ColorSpaceNode.Nodes=function(){var LinearToLinear=new _FunctionNode.FunctionNode(\"vec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\"),GammaToLinear=new _FunctionNode.FunctionNode(\"vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\"),\nLinearToGamma=new _FunctionNode.FunctionNode(\"vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\"),sRGBToLinear=new _FunctionNode.FunctionNode(\"vec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\"),LinearTosRGB=new _FunctionNode.FunctionNode(\"vec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\"),\nRGBEToLinear=new _FunctionNode.FunctionNode(\"vec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\"),LinearToRGBE=new _FunctionNode.FunctionNode(\"vec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent \\x3d max( max( value.r, value.g ), value.b );\\n\\tfloat fExp \\x3d clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\"),RGBMToLinear=new _FunctionNode.FunctionNode(\"vec3 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\"),\nLinearToRGBM=new _FunctionNode.FunctionNode(\"vec3 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB \\x3d max( value.x, max( value.g, value.b ) );\\n\\tfloat M      \\x3d clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM            \\x3d ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\"),RGBDToLinear=new _FunctionNode.FunctionNode(\"vec3 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\"),\nLinearToRGBD=new _FunctionNode.FunctionNode(\"vec3 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB \\x3d max( value.x, max( value.g, value.b ) );\\n\\tfloat D      \\x3d max( maxRange / maxRGB, 1.0 );\\n\\tD            \\x3d clamp( floor( D ) / 255.0, 0.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\"),cLogLuvM=new _ConstNode.ConstNode(\"const mat3 cLogLuvM \\x3d mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\"),LinearToLogLuv=new _FunctionNode.FunctionNode(\"vec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp \\x3d cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp \\x3d max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n\\tvec4 vResult;\\n\\tvResult.xy \\x3d Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le \\x3d 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w \\x3d fract(Le);\\n\\tvResult.z \\x3d (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n\\treturn vResult;\\n}\",\n[cLogLuvM]),cLogLuvInverseM=new _ConstNode.ConstNode(\"const mat3 cLogLuvInverseM \\x3d mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\"),LogLuvToLinear=new _FunctionNode.FunctionNode(\"vec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le \\x3d value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y \\x3d exp2((Le - 127.0) / 2.0);\\n\\tXp_Y_XYZp.z \\x3d Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x \\x3d value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB \\x3d cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max(vRGB, 0.0), 1.0 );\\n}\",\n[cLogLuvInverseM]);return{LinearToLinear,GammaToLinear,LinearToGamma,sRGBToLinear,LinearTosRGB,RGBEToLinear,LinearToRGBE,RGBMToLinear,LinearToRGBM,RGBDToLinear,LinearToRGBD,cLogLuvM,LinearToLogLuv,cLogLuvInverseM,LogLuvToLinear}}();ColorSpaceNode.LINEAR_TO_LINEAR=\"LinearToLinear\";ColorSpaceNode.GAMMA_TO_LINEAR=\"GammaToLinear\";ColorSpaceNode.LINEAR_TO_GAMMA=\"LinearToGamma\";ColorSpaceNode.SRGB_TO_LINEAR=\"sRGBToLinear\";ColorSpaceNode.LINEAR_TO_SRGB=\"LinearTosRGB\";ColorSpaceNode.RGBE_TO_LINEAR=\"RGBEToLinear\";\nColorSpaceNode.LINEAR_TO_RGBE=\"LinearToRGBE\";ColorSpaceNode.RGBM_TO_LINEAR=\"RGBMToLinear\";ColorSpaceNode.LINEAR_TO_RGBM=\"LinearToRGBM\";ColorSpaceNode.RGBD_TO_LINEAR=\"RGBDToLinear\";ColorSpaceNode.LINEAR_TO_RGBD=\"LinearToRGBD\";ColorSpaceNode.LINEAR_TO_LOG_LUV=\"LinearToLogLuv\";ColorSpaceNode.LOG_LUV_TO_LINEAR=\"LogLuvToLinear\";ColorSpaceNode.getEncodingComponents=function(encoding){switch(encoding){case _three.LinearEncoding:return[\"Linear\"];case _three.sRGBEncoding:return[\"sRGB\"];case _three.RGBEEncoding:return[\"RGBE\"];\ncase _three.RGBM7Encoding:return[\"RGBM\",(new _FloatNode.FloatNode(7)).setReadonly(!0)];case _three.RGBM16Encoding:return[\"RGBM\",(new _FloatNode.FloatNode(16)).setReadonly(!0)];case _three.RGBDEncoding:return[\"RGBD\",(new _FloatNode.FloatNode(256)).setReadonly(!0)];case _three.GammaEncoding:return[\"Gamma\",new _ExpressionNode.ExpressionNode(\"float( GAMMA_FACTOR )\",\"f\")]}};ColorSpaceNode.prototype=Object.create(_TempNode.TempNode.prototype);ColorSpaceNode.prototype.constructor=ColorSpaceNode;ColorSpaceNode.prototype.nodeType=\n\"ColorSpace\";ColorSpaceNode.prototype.hashProperties=[\"method\"];ColorSpaceNode.prototype.generate=function(builder,output){var input=this.input.build(builder,\"v4\"),outputType=this.getType(builder),methodNode=ColorSpaceNode.Nodes[this.method],method=builder.include(methodNode);return method===ColorSpaceNode.LINEAR_TO_LINEAR?builder.format(input,outputType,output):2===methodNode.inputs.length?(methodNode=this.factor.build(builder,\"f\"),builder.format(method+\"( \"+input+\", \"+methodNode+\" )\",outputType,\noutput)):builder.format(method+\"( \"+input+\" )\",outputType,output)};ColorSpaceNode.prototype.fromEncoding=function(encoding){encoding=ColorSpaceNode.getEncodingComponents(encoding);this.method=\"LinearTo\"+encoding[0];this.factor=encoding[1]};ColorSpaceNode.prototype.fromDecoding=function(encoding){encoding=ColorSpaceNode.getEncodingComponents(encoding);this.method=encoding[0]+\"ToLinear\";this.factor=encoding[1]};ColorSpaceNode.prototype.copy=function(source){_TempNode.TempNode.prototype.copy.call(this,\nsource);this.input=source.input;this.method=source.method;return this};ColorSpaceNode.prototype.toJSON=function(meta){var data=this.getJSONNode(meta);data||(data=this.createJSONNode(meta),data.input=this.input.toJSON(meta).uuid,data.method=this.method);return data}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$nodes$utils$ColorSpaceNode\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ColorSpaceNode = ColorSpaceNode;\n\nvar _three = require(\"three\");\n\nvar _TempNode = require(\"../core/TempNode.js\");\n\nvar _ConstNode = require(\"../core/ConstNode.js\");\n\nvar _FloatNode = require(\"../inputs/FloatNode.js\");\n\nvar _FunctionNode = require(\"../core/FunctionNode.js\");\n\nvar _ExpressionNode = require(\"../core/ExpressionNode.js\");\n\nfunction ColorSpaceNode(input, method) {\n  _TempNode.TempNode.call(this, 'v4');\n\n  this.input = input;\n  this.method = method || ColorSpaceNode.LINEAR_TO_LINEAR;\n}\n\nColorSpaceNode.Nodes = function () {\n  // For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n  var LinearToLinear = new _FunctionNode.FunctionNode(['vec4 LinearToLinear( in vec4 value ) {', '\treturn value;', '}'].join('\\n'));\n  var GammaToLinear = new _FunctionNode.FunctionNode(['vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {', '\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );', '}'].join('\\n'));\n  var LinearToGamma = new _FunctionNode.FunctionNode(['vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {', '\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );', '}'].join('\\n'));\n  var sRGBToLinear = new _FunctionNode.FunctionNode(['vec4 sRGBToLinear( in vec4 value ) {', '\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );', '}'].join('\\n'));\n  var LinearTosRGB = new _FunctionNode.FunctionNode(['vec4 LinearTosRGB( in vec4 value ) {', '\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );', '}'].join('\\n'));\n  var RGBEToLinear = new _FunctionNode.FunctionNode(['vec4 RGBEToLinear( in vec4 value ) {', '\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );', '}'].join('\\n'));\n  var LinearToRGBE = new _FunctionNode.FunctionNode(['vec4 LinearToRGBE( in vec4 value ) {', '\tfloat maxComponent = max( max( value.r, value.g ), value.b );', '\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );', '\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );', //  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n  '}'].join('\\n')); // reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\n\n  var RGBMToLinear = new _FunctionNode.FunctionNode(['vec3 RGBMToLinear( in vec4 value, in float maxRange ) {', '\treturn vec4( value.xyz * value.w * maxRange, 1.0 );', '}'].join('\\n'));\n  var LinearToRGBM = new _FunctionNode.FunctionNode(['vec3 LinearToRGBM( in vec4 value, in float maxRange ) {', '\tfloat maxRGB = max( value.x, max( value.g, value.b ) );', '\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );', '\tM            = ceil( M * 255.0 ) / 255.0;', '\treturn vec4( value.rgb / ( M * maxRange ), M );', '}'].join('\\n')); // reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\n\n  var RGBDToLinear = new _FunctionNode.FunctionNode(['vec3 RGBDToLinear( in vec4 value, in float maxRange ) {', '\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );', '}'].join('\\n'));\n  var LinearToRGBD = new _FunctionNode.FunctionNode(['vec3 LinearToRGBD( in vec4 value, in float maxRange ) {', '\tfloat maxRGB = max( value.x, max( value.g, value.b ) );', '\tfloat D      = max( maxRange / maxRGB, 1.0 );', '\tD            = clamp( floor( D ) / 255.0, 0.0, 1.0 );', '\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );', '}'].join('\\n')); // LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n  // M matrix, for encoding\n\n  var cLogLuvM = new _ConstNode.ConstNode('const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );');\n  var LinearToLogLuv = new _FunctionNode.FunctionNode(['vec4 LinearToLogLuv( in vec4 value ) {', '\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;', '\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));', '\tvec4 vResult;', '\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;', '\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;', '\tvResult.w = fract(Le);', '\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;', '\treturn vResult;', '}'].join('\\n'), [cLogLuvM]); // Inverse M matrix, for decoding\n\n  var cLogLuvInverseM = new _ConstNode.ConstNode('const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );');\n  var LogLuvToLinear = new _FunctionNode.FunctionNode(['vec4 LogLuvToLinear( in vec4 value ) {', '\tfloat Le = value.z * 255.0 + value.w;', '\tvec3 Xp_Y_XYZp;', '\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);', '\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;', '\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;', '\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;', '\treturn vec4( max(vRGB, 0.0), 1.0 );', '}'].join('\\n'), [cLogLuvInverseM]);\n  return {\n    LinearToLinear: LinearToLinear,\n    GammaToLinear: GammaToLinear,\n    LinearToGamma: LinearToGamma,\n    sRGBToLinear: sRGBToLinear,\n    LinearTosRGB: LinearTosRGB,\n    RGBEToLinear: RGBEToLinear,\n    LinearToRGBE: LinearToRGBE,\n    RGBMToLinear: RGBMToLinear,\n    LinearToRGBM: LinearToRGBM,\n    RGBDToLinear: RGBDToLinear,\n    LinearToRGBD: LinearToRGBD,\n    cLogLuvM: cLogLuvM,\n    LinearToLogLuv: LinearToLogLuv,\n    cLogLuvInverseM: cLogLuvInverseM,\n    LogLuvToLinear: LogLuvToLinear\n  };\n}();\n\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\nColorSpaceNode.GAMMA_TO_LINEAR = 'GammaToLinear';\nColorSpaceNode.LINEAR_TO_GAMMA = 'LinearToGamma';\nColorSpaceNode.SRGB_TO_LINEAR = 'sRGBToLinear';\nColorSpaceNode.LINEAR_TO_SRGB = 'LinearTosRGB';\nColorSpaceNode.RGBE_TO_LINEAR = 'RGBEToLinear';\nColorSpaceNode.LINEAR_TO_RGBE = 'LinearToRGBE';\nColorSpaceNode.RGBM_TO_LINEAR = 'RGBMToLinear';\nColorSpaceNode.LINEAR_TO_RGBM = 'LinearToRGBM';\nColorSpaceNode.RGBD_TO_LINEAR = 'RGBDToLinear';\nColorSpaceNode.LINEAR_TO_RGBD = 'LinearToRGBD';\nColorSpaceNode.LINEAR_TO_LOG_LUV = 'LinearToLogLuv';\nColorSpaceNode.LOG_LUV_TO_LINEAR = 'LogLuvToLinear';\n\nColorSpaceNode.getEncodingComponents = function (encoding) {\n  switch (encoding) {\n    case _three.LinearEncoding:\n      return ['Linear'];\n\n    case _three.sRGBEncoding:\n      return ['sRGB'];\n\n    case _three.RGBEEncoding:\n      return ['RGBE'];\n\n    case _three.RGBM7Encoding:\n      return ['RGBM', new _FloatNode.FloatNode(7.0).setReadonly(true)];\n\n    case _three.RGBM16Encoding:\n      return ['RGBM', new _FloatNode.FloatNode(16.0).setReadonly(true)];\n\n    case _three.RGBDEncoding:\n      return ['RGBD', new _FloatNode.FloatNode(256.0).setReadonly(true)];\n\n    case _three.GammaEncoding:\n      return ['Gamma', new _ExpressionNode.ExpressionNode('float( GAMMA_FACTOR )', 'f')];\n  }\n};\n\nColorSpaceNode.prototype = Object.create(_TempNode.TempNode.prototype);\nColorSpaceNode.prototype.constructor = ColorSpaceNode;\nColorSpaceNode.prototype.nodeType = 'ColorSpace';\nColorSpaceNode.prototype.hashProperties = ['method'];\n\nColorSpaceNode.prototype.generate = function (builder, output) {\n  var input = this.input.build(builder, 'v4');\n  var outputType = this.getType(builder);\n  var methodNode = ColorSpaceNode.Nodes[this.method];\n  var method = builder.include(methodNode);\n\n  if (method === ColorSpaceNode.LINEAR_TO_LINEAR) {\n    return builder.format(input, outputType, output);\n  } else {\n    if (methodNode.inputs.length === 2) {\n      var factor = this.factor.build(builder, 'f');\n      return builder.format(method + '( ' + input + ', ' + factor + ' )', outputType, output);\n    } else {\n      return builder.format(method + '( ' + input + ' )', outputType, output);\n    }\n  }\n};\n\nColorSpaceNode.prototype.fromEncoding = function (encoding) {\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\n  this.method = 'LinearTo' + components[0];\n  this.factor = components[1];\n};\n\nColorSpaceNode.prototype.fromDecoding = function (encoding) {\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\n  this.method = components[0] + 'ToLinear';\n  this.factor = components[1];\n};\n\nColorSpaceNode.prototype.copy = function (source) {\n  _TempNode.TempNode.prototype.copy.call(this, source);\n\n  this.input = source.input;\n  this.method = source.method;\n  return this;\n};\n\nColorSpaceNode.prototype.toJSON = function (meta) {\n  var data = this.getJSONNode(meta);\n\n  if (!data) {\n    data = this.createJSONNode(meta);\n    data.input = this.input.toJSON(meta).uuid;\n    data.method = this.method;\n  }\n\n  return data;\n};\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$module$node_modules$three_stdlib$nodes$core$FunctionNode","~$shadow.js","~$module$node_modules$three_stdlib$nodes$inputs$FloatNode","~$module$node_modules$three_stdlib$nodes$core$ExpressionNode","~$module$node_modules$three_stdlib$nodes$core$ConstNode","~$module$node_modules$three_stdlib$nodes$core$TempNode"]],"~:properties",["^5",["LinearToLinear","ColorSpaceNode","Nodes","fromDecoding","LINEAR_TO_RGBD","sRGBToLinear","copy","prototype","fromEncoding","LinearToGamma","getEncodingComponents","LINEAR_TO_RGBM","LogLuvToLinear","factor","method","__esModule","generate","RGBM_TO_LINEAR","LinearToLogLuv","LinearToRGBM","SRGB_TO_LINEAR","LinearTosRGB","LINEAR_TO_LOG_LUV","nodeType","RGBDToLinear","hashProperties","value","LinearToRGBE","LINEAR_TO_SRGB","LINEAR_TO_RGBE","cLogLuvInverseM","RGBMToLinear","input","RGBE_TO_LINEAR","RGBEToLinear","LOG_LUV_TO_LINEAR","LinearToRGBD","cLogLuvM","RGBD_TO_LINEAR","GammaToLinear","constructor","GAMMA_TO_LINEAR","LINEAR_TO_GAMMA","toJSON","LINEAR_TO_LINEAR"]],"~:compiled-at",1630917515208,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$nodes$utils$ColorSpaceNode.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/nodes/utils/ColorSpaceNode.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$nodes$utils$ColorSpaceNode\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ColorSpaceNode = ColorSpaceNode;\\n\\nvar _three = require(\\\"three\\\");\\n\\nvar _TempNode = require(\\\"../core/TempNode.js\\\");\\n\\nvar _ConstNode = require(\\\"../core/ConstNode.js\\\");\\n\\nvar _FloatNode = require(\\\"../inputs/FloatNode.js\\\");\\n\\nvar _FunctionNode = require(\\\"../core/FunctionNode.js\\\");\\n\\nvar _ExpressionNode = require(\\\"../core/ExpressionNode.js\\\");\\n\\nfunction ColorSpaceNode(input, method) {\\n  _TempNode.TempNode.call(this, 'v4');\\n\\n  this.input = input;\\n  this.method = method || ColorSpaceNode.LINEAR_TO_LINEAR;\\n}\\n\\nColorSpaceNode.Nodes = function () {\\n  // For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\\n  var LinearToLinear = new _FunctionNode.FunctionNode(['vec4 LinearToLinear( in vec4 value ) {', '\\treturn value;', '}'].join('\\\\n'));\\n  var GammaToLinear = new _FunctionNode.FunctionNode(['vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {', '\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );', '}'].join('\\\\n'));\\n  var LinearToGamma = new _FunctionNode.FunctionNode(['vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {', '\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );', '}'].join('\\\\n'));\\n  var sRGBToLinear = new _FunctionNode.FunctionNode(['vec4 sRGBToLinear( in vec4 value ) {', '\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );', '}'].join('\\\\n'));\\n  var LinearTosRGB = new _FunctionNode.FunctionNode(['vec4 LinearTosRGB( in vec4 value ) {', '\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );', '}'].join('\\\\n'));\\n  var RGBEToLinear = new _FunctionNode.FunctionNode(['vec4 RGBEToLinear( in vec4 value ) {', '\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );', '}'].join('\\\\n'));\\n  var LinearToRGBE = new _FunctionNode.FunctionNode(['vec4 LinearToRGBE( in vec4 value ) {', '\\tfloat maxComponent = max( max( value.r, value.g ), value.b );', '\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );', '\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );', //  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\\n  '}'].join('\\\\n')); // reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\\n\\n  var RGBMToLinear = new _FunctionNode.FunctionNode(['vec3 RGBMToLinear( in vec4 value, in float maxRange ) {', '\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );', '}'].join('\\\\n'));\\n  var LinearToRGBM = new _FunctionNode.FunctionNode(['vec3 LinearToRGBM( in vec4 value, in float maxRange ) {', '\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );', '\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );', '\\tM            = ceil( M * 255.0 ) / 255.0;', '\\treturn vec4( value.rgb / ( M * maxRange ), M );', '}'].join('\\\\n')); // reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\\n\\n  var RGBDToLinear = new _FunctionNode.FunctionNode(['vec3 RGBDToLinear( in vec4 value, in float maxRange ) {', '\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );', '}'].join('\\\\n'));\\n  var LinearToRGBD = new _FunctionNode.FunctionNode(['vec3 LinearToRGBD( in vec4 value, in float maxRange ) {', '\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );', '\\tfloat D      = max( maxRange / maxRGB, 1.0 );', '\\tD            = clamp( floor( D ) / 255.0, 0.0, 1.0 );', '\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );', '}'].join('\\\\n')); // LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\\n  // M matrix, for encoding\\n\\n  var cLogLuvM = new _ConstNode.ConstNode('const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );');\\n  var LinearToLogLuv = new _FunctionNode.FunctionNode(['vec4 LinearToLogLuv( in vec4 value ) {', '\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;', '\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));', '\\tvec4 vResult;', '\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;', '\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;', '\\tvResult.w = fract(Le);', '\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;', '\\treturn vResult;', '}'].join('\\\\n'), [cLogLuvM]); // Inverse M matrix, for decoding\\n\\n  var cLogLuvInverseM = new _ConstNode.ConstNode('const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );');\\n  var LogLuvToLinear = new _FunctionNode.FunctionNode(['vec4 LogLuvToLinear( in vec4 value ) {', '\\tfloat Le = value.z * 255.0 + value.w;', '\\tvec3 Xp_Y_XYZp;', '\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);', '\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;', '\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;', '\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;', '\\treturn vec4( max(vRGB, 0.0), 1.0 );', '}'].join('\\\\n'), [cLogLuvInverseM]);\\n  return {\\n    LinearToLinear: LinearToLinear,\\n    GammaToLinear: GammaToLinear,\\n    LinearToGamma: LinearToGamma,\\n    sRGBToLinear: sRGBToLinear,\\n    LinearTosRGB: LinearTosRGB,\\n    RGBEToLinear: RGBEToLinear,\\n    LinearToRGBE: LinearToRGBE,\\n    RGBMToLinear: RGBMToLinear,\\n    LinearToRGBM: LinearToRGBM,\\n    RGBDToLinear: RGBDToLinear,\\n    LinearToRGBD: LinearToRGBD,\\n    cLogLuvM: cLogLuvM,\\n    LinearToLogLuv: LinearToLogLuv,\\n    cLogLuvInverseM: cLogLuvInverseM,\\n    LogLuvToLinear: LogLuvToLinear\\n  };\\n}();\\n\\nColorSpaceNode.LINEAR_TO_LINEAR = 'LinearToLinear';\\nColorSpaceNode.GAMMA_TO_LINEAR = 'GammaToLinear';\\nColorSpaceNode.LINEAR_TO_GAMMA = 'LinearToGamma';\\nColorSpaceNode.SRGB_TO_LINEAR = 'sRGBToLinear';\\nColorSpaceNode.LINEAR_TO_SRGB = 'LinearTosRGB';\\nColorSpaceNode.RGBE_TO_LINEAR = 'RGBEToLinear';\\nColorSpaceNode.LINEAR_TO_RGBE = 'LinearToRGBE';\\nColorSpaceNode.RGBM_TO_LINEAR = 'RGBMToLinear';\\nColorSpaceNode.LINEAR_TO_RGBM = 'LinearToRGBM';\\nColorSpaceNode.RGBD_TO_LINEAR = 'RGBDToLinear';\\nColorSpaceNode.LINEAR_TO_RGBD = 'LinearToRGBD';\\nColorSpaceNode.LINEAR_TO_LOG_LUV = 'LinearToLogLuv';\\nColorSpaceNode.LOG_LUV_TO_LINEAR = 'LogLuvToLinear';\\n\\nColorSpaceNode.getEncodingComponents = function (encoding) {\\n  switch (encoding) {\\n    case _three.LinearEncoding:\\n      return ['Linear'];\\n\\n    case _three.sRGBEncoding:\\n      return ['sRGB'];\\n\\n    case _three.RGBEEncoding:\\n      return ['RGBE'];\\n\\n    case _three.RGBM7Encoding:\\n      return ['RGBM', new _FloatNode.FloatNode(7.0).setReadonly(true)];\\n\\n    case _three.RGBM16Encoding:\\n      return ['RGBM', new _FloatNode.FloatNode(16.0).setReadonly(true)];\\n\\n    case _three.RGBDEncoding:\\n      return ['RGBD', new _FloatNode.FloatNode(256.0).setReadonly(true)];\\n\\n    case _three.GammaEncoding:\\n      return ['Gamma', new _ExpressionNode.ExpressionNode('float( GAMMA_FACTOR )', 'f')];\\n  }\\n};\\n\\nColorSpaceNode.prototype = Object.create(_TempNode.TempNode.prototype);\\nColorSpaceNode.prototype.constructor = ColorSpaceNode;\\nColorSpaceNode.prototype.nodeType = 'ColorSpace';\\nColorSpaceNode.prototype.hashProperties = ['method'];\\n\\nColorSpaceNode.prototype.generate = function (builder, output) {\\n  var input = this.input.build(builder, 'v4');\\n  var outputType = this.getType(builder);\\n  var methodNode = ColorSpaceNode.Nodes[this.method];\\n  var method = builder.include(methodNode);\\n\\n  if (method === ColorSpaceNode.LINEAR_TO_LINEAR) {\\n    return builder.format(input, outputType, output);\\n  } else {\\n    if (methodNode.inputs.length === 2) {\\n      var factor = this.factor.build(builder, 'f');\\n      return builder.format(method + '( ' + input + ', ' + factor + ' )', outputType, output);\\n    } else {\\n      return builder.format(method + '( ' + input + ' )', outputType, output);\\n    }\\n  }\\n};\\n\\nColorSpaceNode.prototype.fromEncoding = function (encoding) {\\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\\n  this.method = 'LinearTo' + components[0];\\n  this.factor = components[1];\\n};\\n\\nColorSpaceNode.prototype.fromDecoding = function (encoding) {\\n  var components = ColorSpaceNode.getEncodingComponents(encoding);\\n  this.method = components[0] + 'ToLinear';\\n  this.factor = components[1];\\n};\\n\\nColorSpaceNode.prototype.copy = function (source) {\\n  _TempNode.TempNode.prototype.copy.call(this, source);\\n\\n  this.input = source.input;\\n  this.method = source.method;\\n  return this;\\n};\\n\\nColorSpaceNode.prototype.toJSON = function (meta) {\\n  var data = this.getJSONNode(meta);\\n\\n  if (!data) {\\n    data = this.createJSONNode(meta);\\n    data.input = this.input.toJSON(meta).uuid;\\n    data.method = this.method;\\n  }\\n\\n  return data;\\n};\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"ColorSpaceNode\",\"input\",\"method\",\"_TempNode\",\"TempNode\",\"call\",\"LINEAR_TO_LINEAR\",\"Object\",\"defineProperty\",\"value\",\"_three\",\"_ConstNode\",\"_FloatNode\",\"_FunctionNode\",\"_ExpressionNode\",\"Nodes\",\"LinearToLinear\",\"FunctionNode\",\"GammaToLinear\",\"LinearToGamma\",\"sRGBToLinear\",\"LinearTosRGB\",\"RGBEToLinear\",\"LinearToRGBE\",\"RGBMToLinear\",\"LinearToRGBM\",\"RGBDToLinear\",\"LinearToRGBD\",\"cLogLuvM\",\"ConstNode\",\"LinearToLogLuv\",\"cLogLuvInverseM\",\"LogLuvToLinear\",\"GAMMA_TO_LINEAR\",\"LINEAR_TO_GAMMA\",\"SRGB_TO_LINEAR\",\"LINEAR_TO_SRGB\",\"RGBE_TO_LINEAR\",\"LINEAR_TO_RGBE\",\"RGBM_TO_LINEAR\",\"LINEAR_TO_RGBM\",\"RGBD_TO_LINEAR\",\"LINEAR_TO_RGBD\",\"LINEAR_TO_LOG_LUV\",\"LOG_LUV_TO_LINEAR\",\"getEncodingComponents\",\"ColorSpaceNode.getEncodingComponents\",\"encoding\",\"LinearEncoding\",\"sRGBEncoding\",\"RGBEEncoding\",\"RGBM7Encoding\",\"setReadonly\",\"FloatNode\",\"RGBM16Encoding\",\"RGBDEncoding\",\"GammaEncoding\",\"ExpressionNode\",\"prototype\",\"create\",\"constructor\",\"nodeType\",\"hashProperties\",\"generate\",\"ColorSpaceNode.prototype.generate\",\"builder\",\"output\",\"build\",\"outputType\",\"getType\",\"methodNode\",\"include\",\"format\",\"inputs\",\"length\",\"factor\",\"fromEncoding\",\"ColorSpaceNode.prototype.fromEncoding\",\"components\",\"fromDecoding\",\"ColorSpaceNode.prototype.fromDecoding\",\"copy\",\"ColorSpaceNode.prototype.copy\",\"source\",\"toJSON\",\"ColorSpaceNode.prototype.toJSON\",\"meta\",\"data\",\"getJSONNode\",\"createJSONNode\",\"uuid\"]\n}\n"]