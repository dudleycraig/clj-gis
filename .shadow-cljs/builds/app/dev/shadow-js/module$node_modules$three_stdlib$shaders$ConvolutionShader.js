["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/ConvolutionShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$ConvolutionShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.ConvolutionShader=void 0;global={defines:{KERNEL_SIZE_FLOAT:\"25.0\",KERNEL_SIZE_INT:\"25\"},uniforms:{tDiffuse:{value:null},uImageIncrement:{value:new (require(\"module$node_modules$three$build$three_module\").Vector2)(.001953125,0)},cKernel:{value:[]}},vertexShader:\"uniform vec2 uImageIncrement;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvUv \\x3d uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\\n\\tgl_Position \\x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",\nfragmentShader:\"uniform float cKernel[ KERNEL_SIZE_INT ];\\nuniform sampler2D tDiffuse;\\nuniform vec2 uImageIncrement;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec2 imageCoord \\x3d vUv;\\n\\tvec4 sum \\x3d vec4( 0.0, 0.0, 0.0, 0.0 );\\n\\tfor( int i \\x3d 0; i \\x3c KERNEL_SIZE_INT; i ++ ) {\\n\\t\\tsum +\\x3d texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\\n\\t\\timageCoord +\\x3d uImageIncrement;\\n\\t}\\n\\tgl_FragColor \\x3d sum;\\n}\",buildKernel:function(sigma){var i,sum,kernelSize=2*Math.ceil(3*sigma)+1;25<kernelSize&&\n(kernelSize=25);var halfWidth=.5*(kernelSize-1);var values=Array(kernelSize);for(i=sum=0;i<kernelSize;++i){var x=i-halfWidth;values[i]=Math.exp(-(x*x)/(2*sigma*sigma));sum+=values[i]}for(i=0;i<kernelSize;++i)values[i]/=sum;return values}};exports.ConvolutionShader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$ConvolutionShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConvolutionShader = void 0;\n\nvar _three = require(\"three\");\n\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\nvar ConvolutionShader = {\n  defines: {\n    KERNEL_SIZE_FLOAT: '25.0',\n    KERNEL_SIZE_INT: '25'\n  },\n  uniforms: {\n    tDiffuse: {\n      value: null\n    },\n    uImageIncrement: {\n      value: new _three.Vector2(0.001953125, 0.0)\n    },\n    cKernel: {\n      value: []\n    }\n  },\n  vertexShader: ['uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['uniform float cKernel[ KERNEL_SIZE_INT ];', 'uniform sampler2D tDiffuse;', 'uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\tvec2 imageCoord = vUv;', '\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );', '\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {', '\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];', '\t\timageCoord += uImageIncrement;', '\t}', '\tgl_FragColor = sum;', '}'].join('\\n'),\n  buildKernel: function buildKernel(sigma) {\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n    function gauss(x, sigma) {\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma));\n    }\n\n    var i,\n        values,\n        sum,\n        halfWidth,\n        kMaxKernelSize = 25,\n        kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n    halfWidth = (kernelSize - 1) * 0.5;\n    values = new Array(kernelSize);\n    sum = 0.0;\n\n    for (i = 0; i < kernelSize; ++i) {\n      values[i] = gauss(i - halfWidth, sigma);\n      sum += values[i];\n    } // normalize the kernel\n\n\n    for (i = 0; i < kernelSize; ++i) {\n      values[i] /= sum;\n    }\n\n    return values;\n  }\n};\nexports.ConvolutionShader = ConvolutionShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","KERNEL_SIZE_FLOAT","uImageIncrement","__esModule","tDiffuse","defines","KERNEL_SIZE_INT","vertexShader","value","ConvolutionShader","buildKernel","uniforms","cKernel"]],"~:compiled-at",1630917515540,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$ConvolutionShader.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,0DAAA,CAA+E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGvHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,iBAAR,CAA4B,IAAK,EAS7BA,OAAAA,CAAoB,CACtBC,QAAS,CACPC,kBAAmB,MADZ,CAEPC,gBAAiB,IAFV,CADa,CAKtBC,SAAU,CACRC,SAAU,CACRN,MAAO,IADC,CADF,CAIRO,gBAAiB,CACfP,MAAO,KAjBAL,OAAAa,CAAQ,8CAARA,CAiBWC,CAAAA,OAAX,EAAmB,UAAnB,CAAgC,CAAhC,CADQ,CAJT,CAORC,QAAS,CACPV,MAAO,EADA,CAPD,CALY,CAgBtBW,aAA4O,8NAhBtN;AAiBtBC,eAA4Z,oZAjBtY,CAkBtBC,YAAaA,QAAoB,CAACC,KAAD,CAAQ,CAAA,IAMnCC,CANmC,CAQnCC,GARmC,CAWnCC,WAAa,CAAbA,CAAiBC,IAAKC,CAAAA,IAAL,CAAkB,CAAlB,CAAUL,KAAV,CAAjBG,CAA0C,CADzBG,GAErB,CAAIH,UAAJ;CAAiCA,UAAjC,CAFqBG,EAErB,CACA,KAAAC,UAA+B,EAA/BA,EAAaJ,UAAbI,CAA0B,CAA1BA,CACA,KAAAC,OAAaC,KAAJ,CAAUN,UAAV,CAGT,KAAKF,CAAL,CAFAC,GAEA,CAFM,CAEN,CAAYD,CAAZ,CAAgBE,UAAhB,CAA4B,EAAEF,CAA9B,CAAiC,CACb,IAAA,EAAAA,CAAA,CAAIM,SAAtBC,OAAA,CAAOP,CAAP,CAAA,CAfOG,IAAKM,CAAAA,GAAL,CAAS,EAAEC,CAAF,CAAMA,CAAN,CAAT,EAAqB,CAArB,CAe0BX,KAf1B,CAe0BA,KAf1B,EAgBPE,IAAA,EAAOM,MAAA,CAAOP,CAAP,CAFwB,CAMjC,IAAKA,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBE,UAAhB,CAA4B,EAAEF,CAA9B,CACEO,MAAA,CAAOP,CAAP,CAAA,EAAaC,GAGf,OAAOM,OA3BgC,CAlBnB,CAgDxBzB,QAAQI,CAAAA,iBAAR,CAA4BA,MA/D2F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/ConvolutionShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$ConvolutionShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.ConvolutionShader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\n/**\\n * Convolution shader\\n * ported from o3d sample to WebGL / GLSL\\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\\n */\\nvar ConvolutionShader = {\\n  defines: {\\n    KERNEL_SIZE_FLOAT: '25.0',\\n    KERNEL_SIZE_INT: '25'\\n  },\\n  uniforms: {\\n    tDiffuse: {\\n      value: null\\n    },\\n    uImageIncrement: {\\n      value: new _three.Vector2(0.001953125, 0.0)\\n    },\\n    cKernel: {\\n      value: []\\n    }\\n  },\\n  vertexShader: ['uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;', '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform float cKernel[ KERNEL_SIZE_INT ];', 'uniform sampler2D tDiffuse;', 'uniform vec2 uImageIncrement;', 'varying vec2 vUv;', 'void main() {', '\\tvec2 imageCoord = vUv;', '\\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );', '\\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {', '\\t\\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];', '\\t\\timageCoord += uImageIncrement;', '\\t}', '\\tgl_FragColor = sum;', '}'].join('\\\\n'),\\n  buildKernel: function buildKernel(sigma) {\\n    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\\n    function gauss(x, sigma) {\\n      return Math.exp(-(x * x) / (2.0 * sigma * sigma));\\n    }\\n\\n    var i,\\n        values,\\n        sum,\\n        halfWidth,\\n        kMaxKernelSize = 25,\\n        kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\\n    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\\n    halfWidth = (kernelSize - 1) * 0.5;\\n    values = new Array(kernelSize);\\n    sum = 0.0;\\n\\n    for (i = 0; i < kernelSize; ++i) {\\n      values[i] = gauss(i - halfWidth, sigma);\\n      sum += values[i];\\n    } // normalize the kernel\\n\\n\\n    for (i = 0; i < kernelSize; ++i) {\\n      values[i] /= sum;\\n    }\\n\\n    return values;\\n  }\\n};\\nexports.ConvolutionShader = ConvolutionShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"ConvolutionShader\",\"defines\",\"KERNEL_SIZE_FLOAT\",\"KERNEL_SIZE_INT\",\"uniforms\",\"tDiffuse\",\"uImageIncrement\",\"_three\",\"Vector2\",\"cKernel\",\"vertexShader\",\"fragmentShader\",\"buildKernel\",\"sigma\",\"i\",\"sum\",\"kernelSize\",\"Math\",\"ceil\",\"kMaxKernelSize\",\"halfWidth\",\"values\",\"Array\",\"exp\",\"x\"]\n}\n"]