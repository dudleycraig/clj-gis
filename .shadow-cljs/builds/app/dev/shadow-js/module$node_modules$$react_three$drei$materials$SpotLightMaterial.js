["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@react-three/drei/materials/SpotLightMaterial.js"],"~:js","shadow$provide.module$node_modules$$react_three$drei$materials$SpotLightMaterial=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:\nfunction(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||\nfunction(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.SpotLightMaterial=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_ShaderMaterial){function SpotLightMaterial(){if(!(this instanceof SpotLightMaterial))throw new TypeError(\"Cannot call a class as a function\");var call=_getPrototypeOf(SpotLightMaterial).call(this,{uniforms:{depth:{value:null},attenuation:{value:2.5},\nanglePower:{value:12},spotPosition:{value:new _three.Vector3(0,0,0)},lightColor:{value:new _three.Color(\"white\")},cameraNear:{value:0},cameraFar:{value:1},resolution:{value:new _three.Vector2(0,0)}},transparent:!0,depthWrite:!1,vertexShader:\"\\n      varying vec3 vNormal;\\n      varying vec3 vWorldPosition;\\n      varying float vViewZ;\\n      varying float vIntensity;\\n      uniform vec3 spotPosition;\\n      uniform float attenuation;\\n\\n      void main() {\\n        // compute intensity\\n        vNormal \\x3d normalize( normalMatrix * normal );\\n        vec4 worldPosition\\t\\x3d modelMatrix * vec4( position, 1.0 );\\n        vWorldPosition \\x3d worldPosition.xyz;\\n        vec4 viewPosition \\x3d viewMatrix * worldPosition;\\n        vViewZ \\x3d viewPosition.z;\\n        float intensity\\t\\x3d distance(worldPosition.xyz, spotPosition) / attenuation;\\n        intensity\\t\\x3d 1.0 - clamp(intensity, 0.0, 1.0);\\n        vIntensity \\x3d intensity;        \\n        // set gl_Position\\n        gl_Position\\t\\x3d projectionMatrix * viewPosition;\\n\\n      }\",\nfragmentShader:\"\\n      #include \\x3cpacking\\x3e\\n\\n      varying vec3 vNormal;\\n      varying vec3 vWorldPosition;\\n      uniform vec3 lightColor;\\n      uniform vec3 spotPosition;\\n      uniform float attenuation;\\n      uniform float anglePower;\\n      uniform sampler2D depth;\\n      uniform vec2 resolution;\\n      uniform float cameraNear;\\n      uniform float cameraFar;\\n      varying float vViewZ;\\n      varying float vIntensity;\\n\\n      float readDepth( sampler2D depthSampler, vec2 coord ) {\\n        float fragCoordZ \\x3d texture2D( depthSampler, coord ).x;\\n        float viewZ \\x3d perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\\n        return viewZ;\\n      }\\n\\n      void main() {\\n        float d \\x3d 1.0;\\n        bool isSoft \\x3d resolution[0] \\x3e 0.0 \\x26\\x26 resolution[1] \\x3e 0.0;\\n        if (isSoft) {\\n          vec2 sUv \\x3d gl_FragCoord.xy / resolution;\\n          d \\x3d readDepth(depth, sUv);\\n        }\\n        float intensity \\x3d vIntensity;\\n        vec3 normal\\t\\x3d vec3(vNormal.x, vNormal.y, abs(vNormal.z));\\n        float angleIntensity\\t\\x3d pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );\\n        intensity\\t*\\x3d angleIntensity;\\n        // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\\n        if (isSoft) {\\n          intensity\\t*\\x3d smoothstep(0., 1., vViewZ - d);\\n        }\\n        gl_FragColor \\x3d vec4(lightColor, intensity);\\n      }\"});\nif(!call||\"object\"!==_typeof(call)&&\"function\"!==typeof call){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");call=this}return call}_inherits(SpotLightMaterial,_ShaderMaterial);return SpotLightMaterial}(_three.ShaderMaterial);exports.SpotLightMaterial=global}","~:source","shadow$provide[\"module$node_modules$$react_three$drei$materials$SpotLightMaterial\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SpotLightMaterial = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar SpotLightMaterial =\n/*#__PURE__*/\nfunction (_ShaderMaterial) {\n  _inherits(SpotLightMaterial, _ShaderMaterial);\n\n  function SpotLightMaterial() {\n    _classCallCheck(this, SpotLightMaterial);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SpotLightMaterial).call(this, {\n      uniforms: {\n        depth: {\n          value: null\n        },\n        attenuation: {\n          value: 2.5\n        },\n        anglePower: {\n          value: 12\n        },\n        spotPosition: {\n          value: new _three.Vector3(0, 0, 0)\n        },\n        lightColor: {\n          value: new _three.Color('white')\n        },\n        cameraNear: {\n          value: 0\n        },\n        cameraFar: {\n          value: 1\n        },\n        resolution: {\n          value: new _three.Vector2(0, 0)\n        }\n      },\n      transparent: true,\n      depthWrite: false,\n      vertexShader:\n      /* glsl */\n      \"\\n      varying vec3 vNormal;\\n      varying vec3 vWorldPosition;\\n      varying float vViewZ;\\n      varying float vIntensity;\\n      uniform vec3 spotPosition;\\n      uniform float attenuation;\\n\\n      void main() {\\n        // compute intensity\\n        vNormal = normalize( normalMatrix * normal );\\n        vec4 worldPosition\\t= modelMatrix * vec4( position, 1.0 );\\n        vWorldPosition = worldPosition.xyz;\\n        vec4 viewPosition = viewMatrix * worldPosition;\\n        vViewZ = viewPosition.z;\\n        float intensity\\t= distance(worldPosition.xyz, spotPosition) / attenuation;\\n        intensity\\t= 1.0 - clamp(intensity, 0.0, 1.0);\\n        vIntensity = intensity;        \\n        // set gl_Position\\n        gl_Position\\t= projectionMatrix * viewPosition;\\n\\n      }\",\n      fragmentShader:\n      /* glsl */\n      \"\\n      #include <packing>\\n\\n      varying vec3 vNormal;\\n      varying vec3 vWorldPosition;\\n      uniform vec3 lightColor;\\n      uniform vec3 spotPosition;\\n      uniform float attenuation;\\n      uniform float anglePower;\\n      uniform sampler2D depth;\\n      uniform vec2 resolution;\\n      uniform float cameraNear;\\n      uniform float cameraFar;\\n      varying float vViewZ;\\n      varying float vIntensity;\\n\\n      float readDepth( sampler2D depthSampler, vec2 coord ) {\\n        float fragCoordZ = texture2D( depthSampler, coord ).x;\\n        float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\\n        return viewZ;\\n      }\\n\\n      void main() {\\n        float d = 1.0;\\n        bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\\n        if (isSoft) {\\n          vec2 sUv = gl_FragCoord.xy / resolution;\\n          d = readDepth(depth, sUv);\\n        }\\n        float intensity = vIntensity;\\n        vec3 normal\\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));\\n        float angleIntensity\\t= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );\\n        intensity\\t*= angleIntensity;\\n        // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\\n        if (isSoft) {\\n          intensity\\t*= smoothstep(0., 1., vViewZ - d);\\n        }\\n        gl_FragColor = vec4(lightColor, intensity);\\n      }\"\n    }));\n  }\n\n  return SpotLightMaterial;\n}(_three.ShaderMaterial);\n\nexports.SpotLightMaterial = SpotLightMaterial;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","lightColor","cameraFar","prototype","anglePower","transparent","__esModule","vertexShader","configurable","value","writable","SpotLightMaterial","depth","__proto__","spotPosition","depthWrite","cameraNear","uniforms","attenuation","constructor","resolution"]],"~:compiled-at",1630917516202,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$react_three$drei$materials$SpotLightMaterial.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@react-three/drei/materials/SpotLightMaterial.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$react_three$drei$materials$SpotLightMaterial\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.SpotLightMaterial = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar SpotLightMaterial =\\n/*#__PURE__*/\\nfunction (_ShaderMaterial) {\\n  _inherits(SpotLightMaterial, _ShaderMaterial);\\n\\n  function SpotLightMaterial() {\\n    _classCallCheck(this, SpotLightMaterial);\\n\\n    return _possibleConstructorReturn(this, _getPrototypeOf(SpotLightMaterial).call(this, {\\n      uniforms: {\\n        depth: {\\n          value: null\\n        },\\n        attenuation: {\\n          value: 2.5\\n        },\\n        anglePower: {\\n          value: 12\\n        },\\n        spotPosition: {\\n          value: new _three.Vector3(0, 0, 0)\\n        },\\n        lightColor: {\\n          value: new _three.Color('white')\\n        },\\n        cameraNear: {\\n          value: 0\\n        },\\n        cameraFar: {\\n          value: 1\\n        },\\n        resolution: {\\n          value: new _three.Vector2(0, 0)\\n        }\\n      },\\n      transparent: true,\\n      depthWrite: false,\\n      vertexShader:\\n      /* glsl */\\n      \\\"\\\\n      varying vec3 vNormal;\\\\n      varying vec3 vWorldPosition;\\\\n      varying float vViewZ;\\\\n      varying float vIntensity;\\\\n      uniform vec3 spotPosition;\\\\n      uniform float attenuation;\\\\n\\\\n      void main() {\\\\n        // compute intensity\\\\n        vNormal = normalize( normalMatrix * normal );\\\\n        vec4 worldPosition\\\\t= modelMatrix * vec4( position, 1.0 );\\\\n        vWorldPosition = worldPosition.xyz;\\\\n        vec4 viewPosition = viewMatrix * worldPosition;\\\\n        vViewZ = viewPosition.z;\\\\n        float intensity\\\\t= distance(worldPosition.xyz, spotPosition) / attenuation;\\\\n        intensity\\\\t= 1.0 - clamp(intensity, 0.0, 1.0);\\\\n        vIntensity = intensity;        \\\\n        // set gl_Position\\\\n        gl_Position\\\\t= projectionMatrix * viewPosition;\\\\n\\\\n      }\\\",\\n      fragmentShader:\\n      /* glsl */\\n      \\\"\\\\n      #include <packing>\\\\n\\\\n      varying vec3 vNormal;\\\\n      varying vec3 vWorldPosition;\\\\n      uniform vec3 lightColor;\\\\n      uniform vec3 spotPosition;\\\\n      uniform float attenuation;\\\\n      uniform float anglePower;\\\\n      uniform sampler2D depth;\\\\n      uniform vec2 resolution;\\\\n      uniform float cameraNear;\\\\n      uniform float cameraFar;\\\\n      varying float vViewZ;\\\\n      varying float vIntensity;\\\\n\\\\n      float readDepth( sampler2D depthSampler, vec2 coord ) {\\\\n        float fragCoordZ = texture2D( depthSampler, coord ).x;\\\\n        float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\\\\n        return viewZ;\\\\n      }\\\\n\\\\n      void main() {\\\\n        float d = 1.0;\\\\n        bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\\\\n        if (isSoft) {\\\\n          vec2 sUv = gl_FragCoord.xy / resolution;\\\\n          d = readDepth(depth, sUv);\\\\n        }\\\\n        float intensity = vIntensity;\\\\n        vec3 normal\\\\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));\\\\n        float angleIntensity\\\\t= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );\\\\n        intensity\\\\t*= angleIntensity;\\\\n        // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\\\\n        if (isSoft) {\\\\n          intensity\\\\t*= smoothstep(0., 1., vViewZ - d);\\\\n        }\\\\n        gl_FragColor = vec4(lightColor, intensity);\\\\n      }\\\"\\n    }));\\n  }\\n\\n  return SpotLightMaterial;\\n}(_three.ShaderMaterial);\\n\\nexports.SpotLightMaterial = SpotLightMaterial;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"defineProperty\",\"SpotLightMaterial\",\"_three\",\"_ShaderMaterial\",\"instance\",\"call\",\"uniforms\",\"depth\",\"attenuation\",\"anglePower\",\"spotPosition\",\"Vector3\",\"lightColor\",\"Color\",\"cameraNear\",\"cameraFar\",\"resolution\",\"Vector2\",\"transparent\",\"depthWrite\",\"vertexShader\",\"fragmentShader\",\"self\",\"ReferenceError\",\"ShaderMaterial\"]\n}\n"]