["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/RGBELoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$RGBELoader=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=\ndescriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _get(target$jscomp$0,property$jscomp$0,receiver$jscomp$0){_get=\"undefined\"!==typeof Reflect&&Reflect.get?Reflect.get:function(target,property,\nreceiver){for(;!Object.prototype.hasOwnProperty.call(target,property)&&(target=_getPrototypeOf(target),null!==target););if(target)return property=Object.getOwnPropertyDescriptor(target,property),property.get?property.get.call(receiver):property.value};return _get(target$jscomp$0,property$jscomp$0,receiver$jscomp$0||target$jscomp$0)}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}\nfunction _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,\np$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.RGBELoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_DataTextureLoader){function RGBELoader(manager){if(!(this instanceof RGBELoader))throw new TypeError(\"Cannot call a class as a function\");manager=_getPrototypeOf(RGBELoader).call(this,manager);if(!manager||\"object\"!==_typeof(manager)&&\"function\"!==typeof manager){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\nmanager=this}manager.type=_three.UnsignedByteType;return manager}_inherits(RGBELoader,_DataTextureLoader);_createClass(RGBELoader,[{key:\"parse\",value:function(buffer$jscomp$0){var rgbe_error=function(rgbe_error_code,msg){switch(rgbe_error_code){case 1:console.error(\"THREE.RGBELoader Read Error: \"+(msg||\"\"));break;case 2:console.error(\"THREE.RGBELoader Write Error: \"+(msg||\"\"));break;case 3:console.error(\"THREE.RGBELoader Bad File Format: \"+(msg||\"\"));break;default:case 4:console.error(\"THREE.RGBELoader: Error: \"+\n(msg||\"\"))}return-1},fgets=function(buffer,lineLimit,consume){lineLimit=lineLimit?lineLimit:1024;for(var p=buffer.pos,i,len=0,s=\"\",chunk=String.fromCharCode.apply(null,new Uint16Array(buffer.subarray(p,p+128)));0>(i=chunk.indexOf(\"\\n\"))&&len<lineLimit&&p<buffer.byteLength;)s+=chunk,len+=chunk.length,p+=128,chunk+=String.fromCharCode.apply(null,new Uint16Array(buffer.subarray(p,p+128)));return-1<i?(!1!==consume&&(buffer.pos+=len+i+1),s+chunk.slice(0,i)):!1},RGBE_ReadPixels_RLE=function(buffer,w,h){if(8>\nw||32767<w||2!==buffer[0]||2!==buffer[1]||buffer[2]&128)return new Uint8Array(buffer);if(w!==(buffer[2]<<8|buffer[3]))return rgbe_error(3,\"wrong scanline width\");var data_rgba=new Uint8Array(4*w*h);if(!data_rgba.length)return rgbe_error(4,\"unable to allocate buffer space\");for(var offset=0,pos=0,ptr_end=4*w,rgbeStart=new Uint8Array(4),scanline_buffer=new Uint8Array(ptr_end);0<h&&pos<buffer.byteLength;){if(pos+4>buffer.byteLength)return rgbe_error(1);rgbeStart[0]=buffer[pos++];rgbeStart[1]=buffer[pos++];\nrgbeStart[2]=buffer[pos++];rgbeStart[3]=buffer[pos++];if(2!=rgbeStart[0]||2!=rgbeStart[1]||(rgbeStart[2]<<8|rgbeStart[3])!=w)return rgbe_error(3,\"bad rgbe scanline format\");for(var ptr=0,count;ptr<ptr_end&&pos<buffer.byteLength;){count=buffer[pos++];var isEncodedRun=128<count;isEncodedRun&&(count-=128);if(0===count||ptr+count>ptr_end)return rgbe_error(3,\"bad scanline data\");if(isEncodedRun){isEncodedRun=buffer[pos++];for(var i=0;i<count;i++)scanline_buffer[ptr++]=isEncodedRun}else scanline_buffer.set(buffer.subarray(pos,\npos+count),ptr),ptr+=count,pos+=count}ptr=w;for(count=0;count<ptr;count++)isEncodedRun=0,data_rgba[offset]=scanline_buffer[count+isEncodedRun],isEncodedRun+=w,data_rgba[offset+1]=scanline_buffer[count+isEncodedRun],isEncodedRun+=w,data_rgba[offset+2]=scanline_buffer[count+isEncodedRun],isEncodedRun+=w,data_rgba[offset+3]=scanline_buffer[count+isEncodedRun],offset+=4;h--}return data_rgba},RGBEByteToRGBFloat=function(sourceArray,sourceOffset,destArray,destOffset){var scale=Math.pow(2,sourceArray[sourceOffset+\n3]-128)/255;destArray[destOffset+0]=sourceArray[sourceOffset+0]*scale;destArray[destOffset+1]=sourceArray[sourceOffset+1]*scale;destArray[destOffset+2]=sourceArray[sourceOffset+2]*scale},RGBEByteToRGBHalf=function(sourceArray,sourceOffset,destArray,destOffset){var scale=Math.pow(2,sourceArray[sourceOffset+3]-128)/255;destArray[destOffset+0]=_three.DataUtils.toHalfFloat(sourceArray[sourceOffset+0]*scale);destArray[destOffset+1]=_three.DataUtils.toHalfFloat(sourceArray[sourceOffset+1]*scale);destArray[destOffset+\n2]=_three.DataUtils.toHalfFloat(sourceArray[sourceOffset+2]*scale)},byteArray=new Uint8Array(buffer$jscomp$0);byteArray.pos=0;buffer$jscomp$0=function(buffer){var gamma_re=/^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,exposure_re=/^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,format_re=/^\\s*FORMAT=(\\S+)\\s*$/,dimensions_re=/^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,header={valid:0,string:\"\",comments:\"\",programtype:\"RGBE\",format:\"\",gamma:1,exposure:1,width:0,height:0},line,match;if(buffer.pos>=buffer.byteLength||!(line=fgets(buffer)))return rgbe_error(1,\n\"no header found\");if(!(match=line.match(/^#\\?(\\S+)/)))return rgbe_error(3,\"bad initial token\");header.valid|=1;header.programtype=match[1];for(header.string+=line+\"\\n\";;){line=fgets(buffer);if(!1===line)break;header.string+=line+\"\\n\";if(\"#\"===line.charAt(0))header.comments+=line+\"\\n\";else{if(match=line.match(gamma_re))header.gamma=parseFloat(match[1],10);if(match=line.match(exposure_re))header.exposure=parseFloat(match[1],10);if(match=line.match(format_re))header.valid|=2,header.format=match[1];\nif(match=line.match(dimensions_re))header.valid|=4,header.height=parseInt(match[1],10),header.width=parseInt(match[2],10);if(header.valid&2&&header.valid&4)break}}return header.valid&2?header.valid&4?header:rgbe_error(3,\"missing image size specifier\"):rgbe_error(3,\"missing format specifier\")}(byteArray);if(-1!==buffer$jscomp$0){var w$jscomp$0=buffer$jscomp$0.width,h$jscomp$0=buffer$jscomp$0.height;RGBE_ReadPixels_RLE=RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos),w$jscomp$0,h$jscomp$0);if(-1!==\nRGBE_ReadPixels_RLE){switch(this.type){case _three.UnsignedByteType:var data=RGBE_ReadPixels_RLE;var format=_three.RGBEFormat;var type=_three.UnsignedByteType;break;case _three.FloatType:data=RGBE_ReadPixels_RLE.length/4*3;RGBEByteToRGBHalf=new Float32Array(data);for(format=0;format<data;format++)RGBEByteToRGBFloat(RGBE_ReadPixels_RLE,4*format,RGBEByteToRGBHalf,3*format);data=RGBEByteToRGBHalf;format=_three.RGBFormat;type=_three.FloatType;break;case _three.HalfFloatType:data=RGBE_ReadPixels_RLE.length/\n4*3;RGBEByteToRGBFloat=new Uint16Array(data);for(format=0;format<data;format++)RGBEByteToRGBHalf(RGBE_ReadPixels_RLE,4*format,RGBEByteToRGBFloat,3*format);data=RGBEByteToRGBFloat;format=_three.RGBFormat;type=_three.HalfFloatType;break;default:console.error(\"THREE.RGBELoader: unsupported type: \",this.type)}return{width:w$jscomp$0,height:h$jscomp$0,data,header:buffer$jscomp$0.string,gamma:buffer$jscomp$0.gamma,exposure:buffer$jscomp$0.exposure,format,type}}}return null}},{key:\"setDataType\",value:function(value){this.type=\nvalue;return this}},{key:\"load\",value:function(url,onLoad,onProgress,onError){return _get(_getPrototypeOf(RGBELoader.prototype),\"load\",this).call(this,url,function(texture,texData){switch(texture.type){case _three.UnsignedByteType:texture.encoding=_three.RGBEEncoding;texture.minFilter=_three.NearestFilter;texture.magFilter=_three.NearestFilter;texture.generateMipmaps=!1;texture.flipY=!0;break;case _three.FloatType:texture.encoding=_three.LinearEncoding;texture.minFilter=_three.LinearFilter;texture.magFilter=\n_three.LinearFilter;texture.generateMipmaps=!1;texture.flipY=!0;break;case _three.HalfFloatType:texture.encoding=_three.LinearEncoding,texture.minFilter=_three.LinearFilter,texture.magFilter=_three.LinearFilter,texture.generateMipmaps=!1,texture.flipY=!0}onLoad&&onLoad(texture,texData)},onProgress,onError)}}]);return RGBELoader}(_three.DataTextureLoader);exports.RGBELoader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$RGBELoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RGBELoader = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n// http://en.wikipedia.org/wiki/RGBE_image_format\nvar RGBELoader =\n/*#__PURE__*/\nfunction (_DataTextureLoader) {\n  _inherits(RGBELoader, _DataTextureLoader);\n\n  function RGBELoader(manager) {\n    var _this;\n\n    _classCallCheck(this, RGBELoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RGBELoader).call(this, manager));\n    _this.type = _three.UnsignedByteType;\n    return _this;\n  } // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\n  _createClass(RGBELoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      var\n      /* return codes for rgbe routines */\n      //RGBE_RETURN_SUCCESS = 0,\n      RGBE_RETURN_FAILURE = -1,\n\n      /* default error routine.  change this to change error handling */\n      rgbe_read_error = 1,\n          rgbe_write_error = 2,\n          rgbe_format_error = 3,\n          rgbe_memory_error = 4,\n          rgbe_error = function rgbe_error(rgbe_error_code, msg) {\n        switch (rgbe_error_code) {\n          case rgbe_read_error:\n            console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n            break;\n\n          case rgbe_write_error:\n            console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n            break;\n\n          case rgbe_format_error:\n            console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n            break;\n\n          default:\n          case rgbe_memory_error:\n            console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n        }\n\n        return RGBE_RETURN_FAILURE;\n      },\n\n      /* offsets to red, green, and blue components in a data (float) pixel */\n      //RGBE_DATA_RED = 0,\n      //RGBE_DATA_GREEN = 1,\n      //RGBE_DATA_BLUE = 2,\n\n      /* number of floats per pixel, use 4 since stored in rgba image format */\n      //RGBE_DATA_SIZE = 4,\n\n      /* flags indicating which fields in an rgbe_header_info are valid */\n      RGBE_VALID_PROGRAMTYPE = 1,\n          RGBE_VALID_FORMAT = 2,\n          RGBE_VALID_DIMENSIONS = 4,\n          NEWLINE = '\\n',\n          fgets = function fgets(buffer, lineLimit, consume) {\n        var chunkSize = 128;\n        lineLimit = !lineLimit ? 1024 : lineLimit;\n        var p = buffer.pos,\n            i = -1,\n            len = 0,\n            s = '',\n            chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n          s += chunk;\n          len += chunk.length;\n          p += chunkSize;\n          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n        }\n\n        if (-1 < i) {\n          /*for (i=l-1; i>=0; i--) {\n          byteCode = m.charCodeAt(i);\n          if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n          else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n          if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n          }*/\n          if (false !== consume) buffer.pos += len + i + 1;\n          return s + chunk.slice(0, i);\n        }\n\n        return false;\n      },\n\n      /* minimal header reading.  modify if you want to parse more information */\n      RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {\n        // regexes to parse header info fields\n        var magic_token_re = /^#\\?(\\S+)/,\n            gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n            dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n            // RGBE format header struct\n        header = {\n          valid: 0\n          /* indicate which fields are valid */\n          ,\n          string: ''\n          /* the actual header string */\n          ,\n          comments: ''\n          /* comments found in header */\n          ,\n          programtype: 'RGBE'\n          /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n          ,\n          format: ''\n          /* RGBE format, default 32-bit_rle_rgbe */\n          ,\n          gamma: 1.0\n          /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n          ,\n          exposure: 1.0\n          /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n          ,\n          width: 0,\n          height: 0\n          /* image dimensions, width/height */\n\n        };\n        var line, match;\n\n        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n          return rgbe_error(rgbe_read_error, 'no header found');\n        }\n        /* if you want to require the magic token then uncomment the next line */\n\n\n        if (!(match = line.match(magic_token_re))) {\n          return rgbe_error(rgbe_format_error, 'bad initial token');\n        }\n\n        header.valid |= RGBE_VALID_PROGRAMTYPE;\n        header.programtype = match[1];\n        header.string += line + '\\n';\n\n        while (true) {\n          line = fgets(buffer);\n          if (false === line) break;\n          header.string += line + '\\n';\n\n          if ('#' === line.charAt(0)) {\n            header.comments += line + '\\n';\n            continue; // comment line\n          }\n\n          if (match = line.match(gamma_re)) {\n            header.gamma = parseFloat(match[1], 10);\n          }\n\n          if (match = line.match(exposure_re)) {\n            header.exposure = parseFloat(match[1], 10);\n          }\n\n          if (match = line.match(format_re)) {\n            header.valid |= RGBE_VALID_FORMAT;\n            header.format = match[1]; //'32-bit_rle_rgbe';\n          }\n\n          if (match = line.match(dimensions_re)) {\n            header.valid |= RGBE_VALID_DIMENSIONS;\n            header.height = parseInt(match[1], 10);\n            header.width = parseInt(match[2], 10);\n          }\n\n          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n        }\n\n        if (!(header.valid & RGBE_VALID_FORMAT)) {\n          return rgbe_error(rgbe_format_error, 'missing format specifier');\n        }\n\n        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n          return rgbe_error(rgbe_format_error, 'missing image size specifier');\n        }\n\n        return header;\n      },\n          RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {\n        var scanline_width = w;\n\n        if ( // run length encoding is not allowed so read flat\n        scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n        2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n          // return the flat buffer\n          return new Uint8Array(buffer);\n        }\n\n        if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n          return rgbe_error(rgbe_format_error, 'wrong scanline width');\n        }\n\n        var data_rgba = new Uint8Array(4 * w * h);\n\n        if (!data_rgba.length) {\n          return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n        }\n\n        var offset = 0,\n            pos = 0;\n        var ptr_end = 4 * scanline_width;\n        var rgbeStart = new Uint8Array(4);\n        var scanline_buffer = new Uint8Array(ptr_end);\n        var num_scanlines = h; // read in each successive scanline\n\n        while (num_scanlines > 0 && pos < buffer.byteLength) {\n          if (pos + 4 > buffer.byteLength) {\n            return rgbe_error(rgbe_read_error);\n          }\n\n          rgbeStart[0] = buffer[pos++];\n          rgbeStart[1] = buffer[pos++];\n          rgbeStart[2] = buffer[pos++];\n          rgbeStart[3] = buffer[pos++];\n\n          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n            return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n          } // read each of the four channels for the scanline into the buffer\n          // first red, then green, then blue, then exponent\n\n\n          var ptr = 0,\n              count = void 0;\n\n          while (ptr < ptr_end && pos < buffer.byteLength) {\n            count = buffer[pos++];\n            var isEncodedRun = count > 128;\n            if (isEncodedRun) count -= 128;\n\n            if (0 === count || ptr + count > ptr_end) {\n              return rgbe_error(rgbe_format_error, 'bad scanline data');\n            }\n\n            if (isEncodedRun) {\n              // a (encoded) run of the same value\n              var byteValue = buffer[pos++];\n\n              for (var i = 0; i < count; i++) {\n                scanline_buffer[ptr++] = byteValue;\n              } //ptr += count;\n\n            } else {\n              // a literal-run\n              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n              ptr += count;\n              pos += count;\n            }\n          } // now convert data from buffer into rgba\n          // first red, then green, then blue, then exponent (alpha)\n\n\n          var l = scanline_width; //scanline_buffer.byteLength;\n\n          for (var _i = 0; _i < l; _i++) {\n            var off = 0;\n            data_rgba[offset] = scanline_buffer[_i + off];\n            off += scanline_width; //1;\n\n            data_rgba[offset + 1] = scanline_buffer[_i + off];\n            off += scanline_width; //1;\n\n            data_rgba[offset + 2] = scanline_buffer[_i + off];\n            off += scanline_width; //1;\n\n            data_rgba[offset + 3] = scanline_buffer[_i + off];\n            offset += 4;\n          }\n\n          num_scanlines--;\n        }\n\n        return data_rgba;\n      };\n\n      var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {\n        var e = sourceArray[sourceOffset + 3];\n        var scale = Math.pow(2.0, e - 128.0) / 255.0;\n        destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n        destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n        destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n      };\n\n      var RGBEByteToRGBHalf = function RGBEByteToRGBHalf(sourceArray, sourceOffset, destArray, destOffset) {\n        var e = sourceArray[sourceOffset + 3];\n        var scale = Math.pow(2.0, e - 128.0) / 255.0;\n        destArray[destOffset + 0] = _three.DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale);\n        destArray[destOffset + 1] = _three.DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale);\n        destArray[destOffset + 2] = _three.DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale);\n      };\n\n      var byteArray = new Uint8Array(buffer);\n      byteArray.pos = 0;\n      var rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n      if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n        var w = rgbe_header_info.width,\n            h = rgbe_header_info.height,\n            image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n        if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n          var data, format, type;\n          var numElements;\n\n          switch (this.type) {\n            case _three.UnsignedByteType:\n              data = image_rgba_data;\n              format = _three.RGBEFormat; // handled as THREE.RGBAFormat in shaders\n\n              type = _three.UnsignedByteType;\n              break;\n\n            case _three.FloatType:\n              numElements = image_rgba_data.length / 4 * 3;\n              var floatArray = new Float32Array(numElements);\n\n              for (var j = 0; j < numElements; j++) {\n                RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n              }\n\n              data = floatArray;\n              format = _three.RGBFormat;\n              type = _three.FloatType;\n              break;\n\n            case _three.HalfFloatType:\n              numElements = image_rgba_data.length / 4 * 3;\n              var halfArray = new Uint16Array(numElements);\n\n              for (var _j = 0; _j < numElements; _j++) {\n                RGBEByteToRGBHalf(image_rgba_data, _j * 4, halfArray, _j * 3);\n              }\n\n              data = halfArray;\n              format = _three.RGBFormat;\n              type = _three.HalfFloatType;\n              break;\n\n            default:\n              console.error('THREE.RGBELoader: unsupported type: ', this.type);\n              break;\n          }\n\n          return {\n            width: w,\n            height: h,\n            data: data,\n            header: rgbe_header_info.string,\n            gamma: rgbe_header_info.gamma,\n            exposure: rgbe_header_info.exposure,\n            format: format,\n            type: type\n          };\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"setDataType\",\n    value: function setDataType(value) {\n      this.type = value;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      function onLoadCallback(texture, texData) {\n        switch (texture.type) {\n          case _three.UnsignedByteType:\n            texture.encoding = _three.RGBEEncoding;\n            texture.minFilter = _three.NearestFilter;\n            texture.magFilter = _three.NearestFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = true;\n            break;\n\n          case _three.FloatType:\n            texture.encoding = _three.LinearEncoding;\n            texture.minFilter = _three.LinearFilter;\n            texture.magFilter = _three.LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = true;\n            break;\n\n          case _three.HalfFloatType:\n            texture.encoding = _three.LinearEncoding;\n            texture.minFilter = _three.LinearFilter;\n            texture.magFilter = _three.LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = true;\n            break;\n        }\n\n        if (onLoad) onLoad(texture, texData);\n      }\n\n      return _get(_getPrototypeOf(RGBELoader.prototype), \"load\", this).call(this, url, onLoadCallback, onProgress, onError);\n    }\n  }]);\n\n  return RGBELoader;\n}(_three.DataTextureLoader);\n\nexports.RGBELoader = RGBELoader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["gamma","width","pos","string","programtype","prototype","height","key","__esModule","encoding","configurable","value","valid","enumerable","magFilter","writable","exposure","type","comments","__proto__","RGBELoader","generateMipmaps","minFilter","flipY","data","header","format","constructor"]],"~:compiled-at",1630917515850,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$RGBELoader.js\",\n\"lineCount\":18,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/RGBELoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$RGBELoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.RGBELoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _get(target, property, receiver) { if (typeof Reflect !== \\\"undefined\\\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\\n\\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n// http://en.wikipedia.org/wiki/RGBE_image_format\\nvar RGBELoader =\\n/*#__PURE__*/\\nfunction (_DataTextureLoader) {\\n  _inherits(RGBELoader, _DataTextureLoader);\\n\\n  function RGBELoader(manager) {\\n    var _this;\\n\\n    _classCallCheck(this, RGBELoader);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RGBELoader).call(this, manager));\\n    _this.type = _three.UnsignedByteType;\\n    return _this;\\n  } // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\\n\\n\\n  _createClass(RGBELoader, [{\\n    key: \\\"parse\\\",\\n    value: function parse(buffer) {\\n      var\\n      /* return codes for rgbe routines */\\n      //RGBE_RETURN_SUCCESS = 0,\\n      RGBE_RETURN_FAILURE = -1,\\n\\n      /* default error routine.  change this to change error handling */\\n      rgbe_read_error = 1,\\n          rgbe_write_error = 2,\\n          rgbe_format_error = 3,\\n          rgbe_memory_error = 4,\\n          rgbe_error = function rgbe_error(rgbe_error_code, msg) {\\n        switch (rgbe_error_code) {\\n          case rgbe_read_error:\\n            console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\\n            break;\\n\\n          case rgbe_write_error:\\n            console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\\n            break;\\n\\n          case rgbe_format_error:\\n            console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\\n            break;\\n\\n          default:\\n          case rgbe_memory_error:\\n            console.error('THREE.RGBELoader: Error: ' + (msg || ''));\\n        }\\n\\n        return RGBE_RETURN_FAILURE;\\n      },\\n\\n      /* offsets to red, green, and blue components in a data (float) pixel */\\n      //RGBE_DATA_RED = 0,\\n      //RGBE_DATA_GREEN = 1,\\n      //RGBE_DATA_BLUE = 2,\\n\\n      /* number of floats per pixel, use 4 since stored in rgba image format */\\n      //RGBE_DATA_SIZE = 4,\\n\\n      /* flags indicating which fields in an rgbe_header_info are valid */\\n      RGBE_VALID_PROGRAMTYPE = 1,\\n          RGBE_VALID_FORMAT = 2,\\n          RGBE_VALID_DIMENSIONS = 4,\\n          NEWLINE = '\\\\n',\\n          fgets = function fgets(buffer, lineLimit, consume) {\\n        var chunkSize = 128;\\n        lineLimit = !lineLimit ? 1024 : lineLimit;\\n        var p = buffer.pos,\\n            i = -1,\\n            len = 0,\\n            s = '',\\n            chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\\n\\n        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\\n          s += chunk;\\n          len += chunk.length;\\n          p += chunkSize;\\n          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\\n        }\\n\\n        if (-1 < i) {\\n          /*for (i=l-1; i>=0; i--) {\\n          byteCode = m.charCodeAt(i);\\n          if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\\n          else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\\n          if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\\n          }*/\\n          if (false !== consume) buffer.pos += len + i + 1;\\n          return s + chunk.slice(0, i);\\n        }\\n\\n        return false;\\n      },\\n\\n      /* minimal header reading.  modify if you want to parse more information */\\n      RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {\\n        // regexes to parse header info fields\\n        var magic_token_re = /^#\\\\?(\\\\S+)/,\\n            gamma_re = /^\\\\s*GAMMA\\\\s*=\\\\s*(\\\\d+(\\\\.\\\\d+)?)\\\\s*$/,\\n            exposure_re = /^\\\\s*EXPOSURE\\\\s*=\\\\s*(\\\\d+(\\\\.\\\\d+)?)\\\\s*$/,\\n            format_re = /^\\\\s*FORMAT=(\\\\S+)\\\\s*$/,\\n            dimensions_re = /^\\\\s*\\\\-Y\\\\s+(\\\\d+)\\\\s+\\\\+X\\\\s+(\\\\d+)\\\\s*$/,\\n            // RGBE format header struct\\n        header = {\\n          valid: 0\\n          /* indicate which fields are valid */\\n          ,\\n          string: ''\\n          /* the actual header string */\\n          ,\\n          comments: ''\\n          /* comments found in header */\\n          ,\\n          programtype: 'RGBE'\\n          /* listed at beginning of file to identify it after \\\"#?\\\". defaults to \\\"RGBE\\\" */\\n          ,\\n          format: ''\\n          /* RGBE format, default 32-bit_rle_rgbe */\\n          ,\\n          gamma: 1.0\\n          /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\\n          ,\\n          exposure: 1.0\\n          /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\\n          ,\\n          width: 0,\\n          height: 0\\n          /* image dimensions, width/height */\\n\\n        };\\n        var line, match;\\n\\n        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\\n          return rgbe_error(rgbe_read_error, 'no header found');\\n        }\\n        /* if you want to require the magic token then uncomment the next line */\\n\\n\\n        if (!(match = line.match(magic_token_re))) {\\n          return rgbe_error(rgbe_format_error, 'bad initial token');\\n        }\\n\\n        header.valid |= RGBE_VALID_PROGRAMTYPE;\\n        header.programtype = match[1];\\n        header.string += line + '\\\\n';\\n\\n        while (true) {\\n          line = fgets(buffer);\\n          if (false === line) break;\\n          header.string += line + '\\\\n';\\n\\n          if ('#' === line.charAt(0)) {\\n            header.comments += line + '\\\\n';\\n            continue; // comment line\\n          }\\n\\n          if (match = line.match(gamma_re)) {\\n            header.gamma = parseFloat(match[1], 10);\\n          }\\n\\n          if (match = line.match(exposure_re)) {\\n            header.exposure = parseFloat(match[1], 10);\\n          }\\n\\n          if (match = line.match(format_re)) {\\n            header.valid |= RGBE_VALID_FORMAT;\\n            header.format = match[1]; //'32-bit_rle_rgbe';\\n          }\\n\\n          if (match = line.match(dimensions_re)) {\\n            header.valid |= RGBE_VALID_DIMENSIONS;\\n            header.height = parseInt(match[1], 10);\\n            header.width = parseInt(match[2], 10);\\n          }\\n\\n          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\\n        }\\n\\n        if (!(header.valid & RGBE_VALID_FORMAT)) {\\n          return rgbe_error(rgbe_format_error, 'missing format specifier');\\n        }\\n\\n        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\\n          return rgbe_error(rgbe_format_error, 'missing image size specifier');\\n        }\\n\\n        return header;\\n      },\\n          RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {\\n        var scanline_width = w;\\n\\n        if ( // run length encoding is not allowed so read flat\\n        scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\\n        2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\\n          // return the flat buffer\\n          return new Uint8Array(buffer);\\n        }\\n\\n        if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\\n          return rgbe_error(rgbe_format_error, 'wrong scanline width');\\n        }\\n\\n        var data_rgba = new Uint8Array(4 * w * h);\\n\\n        if (!data_rgba.length) {\\n          return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\\n        }\\n\\n        var offset = 0,\\n            pos = 0;\\n        var ptr_end = 4 * scanline_width;\\n        var rgbeStart = new Uint8Array(4);\\n        var scanline_buffer = new Uint8Array(ptr_end);\\n        var num_scanlines = h; // read in each successive scanline\\n\\n        while (num_scanlines > 0 && pos < buffer.byteLength) {\\n          if (pos + 4 > buffer.byteLength) {\\n            return rgbe_error(rgbe_read_error);\\n          }\\n\\n          rgbeStart[0] = buffer[pos++];\\n          rgbeStart[1] = buffer[pos++];\\n          rgbeStart[2] = buffer[pos++];\\n          rgbeStart[3] = buffer[pos++];\\n\\n          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\\n            return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\\n          } // read each of the four channels for the scanline into the buffer\\n          // first red, then green, then blue, then exponent\\n\\n\\n          var ptr = 0,\\n              count = void 0;\\n\\n          while (ptr < ptr_end && pos < buffer.byteLength) {\\n            count = buffer[pos++];\\n            var isEncodedRun = count > 128;\\n            if (isEncodedRun) count -= 128;\\n\\n            if (0 === count || ptr + count > ptr_end) {\\n              return rgbe_error(rgbe_format_error, 'bad scanline data');\\n            }\\n\\n            if (isEncodedRun) {\\n              // a (encoded) run of the same value\\n              var byteValue = buffer[pos++];\\n\\n              for (var i = 0; i < count; i++) {\\n                scanline_buffer[ptr++] = byteValue;\\n              } //ptr += count;\\n\\n            } else {\\n              // a literal-run\\n              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\\n              ptr += count;\\n              pos += count;\\n            }\\n          } // now convert data from buffer into rgba\\n          // first red, then green, then blue, then exponent (alpha)\\n\\n\\n          var l = scanline_width; //scanline_buffer.byteLength;\\n\\n          for (var _i = 0; _i < l; _i++) {\\n            var off = 0;\\n            data_rgba[offset] = scanline_buffer[_i + off];\\n            off += scanline_width; //1;\\n\\n            data_rgba[offset + 1] = scanline_buffer[_i + off];\\n            off += scanline_width; //1;\\n\\n            data_rgba[offset + 2] = scanline_buffer[_i + off];\\n            off += scanline_width; //1;\\n\\n            data_rgba[offset + 3] = scanline_buffer[_i + off];\\n            offset += 4;\\n          }\\n\\n          num_scanlines--;\\n        }\\n\\n        return data_rgba;\\n      };\\n\\n      var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {\\n        var e = sourceArray[sourceOffset + 3];\\n        var scale = Math.pow(2.0, e - 128.0) / 255.0;\\n        destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\\n        destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\\n        destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\\n      };\\n\\n      var RGBEByteToRGBHalf = function RGBEByteToRGBHalf(sourceArray, sourceOffset, destArray, destOffset) {\\n        var e = sourceArray[sourceOffset + 3];\\n        var scale = Math.pow(2.0, e - 128.0) / 255.0;\\n        destArray[destOffset + 0] = _three.DataUtils.toHalfFloat(sourceArray[sourceOffset + 0] * scale);\\n        destArray[destOffset + 1] = _three.DataUtils.toHalfFloat(sourceArray[sourceOffset + 1] * scale);\\n        destArray[destOffset + 2] = _three.DataUtils.toHalfFloat(sourceArray[sourceOffset + 2] * scale);\\n      };\\n\\n      var byteArray = new Uint8Array(buffer);\\n      byteArray.pos = 0;\\n      var rgbe_header_info = RGBE_ReadHeader(byteArray);\\n\\n      if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\\n        var w = rgbe_header_info.width,\\n            h = rgbe_header_info.height,\\n            image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\\n\\n        if (RGBE_RETURN_FAILURE !== image_rgba_data) {\\n          var data, format, type;\\n          var numElements;\\n\\n          switch (this.type) {\\n            case _three.UnsignedByteType:\\n              data = image_rgba_data;\\n              format = _three.RGBEFormat; // handled as THREE.RGBAFormat in shaders\\n\\n              type = _three.UnsignedByteType;\\n              break;\\n\\n            case _three.FloatType:\\n              numElements = image_rgba_data.length / 4 * 3;\\n              var floatArray = new Float32Array(numElements);\\n\\n              for (var j = 0; j < numElements; j++) {\\n                RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\\n              }\\n\\n              data = floatArray;\\n              format = _three.RGBFormat;\\n              type = _three.FloatType;\\n              break;\\n\\n            case _three.HalfFloatType:\\n              numElements = image_rgba_data.length / 4 * 3;\\n              var halfArray = new Uint16Array(numElements);\\n\\n              for (var _j = 0; _j < numElements; _j++) {\\n                RGBEByteToRGBHalf(image_rgba_data, _j * 4, halfArray, _j * 3);\\n              }\\n\\n              data = halfArray;\\n              format = _three.RGBFormat;\\n              type = _three.HalfFloatType;\\n              break;\\n\\n            default:\\n              console.error('THREE.RGBELoader: unsupported type: ', this.type);\\n              break;\\n          }\\n\\n          return {\\n            width: w,\\n            height: h,\\n            data: data,\\n            header: rgbe_header_info.string,\\n            gamma: rgbe_header_info.gamma,\\n            exposure: rgbe_header_info.exposure,\\n            format: format,\\n            type: type\\n          };\\n        }\\n      }\\n\\n      return null;\\n    }\\n  }, {\\n    key: \\\"setDataType\\\",\\n    value: function setDataType(value) {\\n      this.type = value;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"load\\\",\\n    value: function load(url, onLoad, onProgress, onError) {\\n      function onLoadCallback(texture, texData) {\\n        switch (texture.type) {\\n          case _three.UnsignedByteType:\\n            texture.encoding = _three.RGBEEncoding;\\n            texture.minFilter = _three.NearestFilter;\\n            texture.magFilter = _three.NearestFilter;\\n            texture.generateMipmaps = false;\\n            texture.flipY = true;\\n            break;\\n\\n          case _three.FloatType:\\n            texture.encoding = _three.LinearEncoding;\\n            texture.minFilter = _three.LinearFilter;\\n            texture.magFilter = _three.LinearFilter;\\n            texture.generateMipmaps = false;\\n            texture.flipY = true;\\n            break;\\n\\n          case _three.HalfFloatType:\\n            texture.encoding = _three.LinearEncoding;\\n            texture.minFilter = _three.LinearFilter;\\n            texture.magFilter = _three.LinearFilter;\\n            texture.generateMipmaps = false;\\n            texture.flipY = true;\\n            break;\\n        }\\n\\n        if (onLoad) onLoad(texture, texData);\\n      }\\n\\n      return _get(_getPrototypeOf(RGBELoader.prototype), \\\"load\\\", this).call(this, url, onLoadCallback, onProgress, onError);\\n    }\\n  }]);\\n\\n  return RGBELoader;\\n}(_three.DataTextureLoader);\\n\\nexports.RGBELoader = RGBELoader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_get\",\"property\",\"receiver\",\"Reflect\",\"get\",\"hasOwnProperty\",\"call\",\"object\",\"_getPrototypeOf\",\"base\",\"desc\",\"getOwnPropertyDescriptor\",\"value\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"_setPrototypeOf\",\"p\",\"RGBELoader\",\"_three\",\"_DataTextureLoader\",\"manager\",\"instance\",\"self\",\"ReferenceError\",\"_this\",\"type\",\"UnsignedByteType\",\"parse\",\"buffer\",\"rgbe_error\",\"rgbe_error_code\",\"msg\",\"rgbe_read_error\",\"console\",\"error\",\"rgbe_write_error\",\"rgbe_format_error\",\"rgbe_memory_error\",\"RGBE_RETURN_FAILURE\",\"fgets\",\"lineLimit\",\"consume\",\"pos\",\"len\",\"s\",\"chunk\",\"String\",\"fromCharCode\",\"apply\",\"Uint16Array\",\"subarray\",\"chunkSize\",\"indexOf\",\"NEWLINE\",\"byteLength\",\"slice\",\"RGBE_ReadPixels_RLE\",\"w\",\"h\",\"Uint8Array\",\"data_rgba\",\"offset\",\"ptr_end\",\"rgbeStart\",\"scanline_buffer\",\"num_scanlines\",\"ptr\",\"count\",\"isEncodedRun\",\"byteValue\",\"set\",\"l\",\"_i\",\"off\",\"RGBEByteToRGBFloat\",\"sourceArray\",\"sourceOffset\",\"destArray\",\"destOffset\",\"scale\",\"Math\",\"pow\",\"e\",\"RGBEByteToRGBHalf\",\"DataUtils\",\"toHalfFloat\",\"byteArray\",\"rgbe_header_info\",\"RGBE_ReadHeader\",\"gamma_re\",\"exposure_re\",\"format_re\",\"dimensions_re\",\"header\",\"valid\",\"string\",\"comments\",\"programtype\",\"format\",\"gamma\",\"exposure\",\"width\",\"height\",\"line\",\"match\",\"magic_token_re\",\"RGBE_VALID_PROGRAMTYPE\",\"charAt\",\"parseFloat\",\"RGBE_VALID_FORMAT\",\"RGBE_VALID_DIMENSIONS\",\"parseInt\",\"image_rgba_data\",\"data\",\"RGBEFormat\",\"FloatType\",\"numElements\",\"floatArray\",\"Float32Array\",\"j\",\"RGBFormat\",\"HalfFloatType\",\"halfArray\",\"_j\",\"setDataType\",\"load\",\"url\",\"onLoad\",\"onProgress\",\"onError\",\"onLoadCallback\",\"texture\",\"texData\",\"encoding\",\"RGBEEncoding\",\"minFilter\",\"NearestFilter\",\"magFilter\",\"generateMipmaps\",\"flipY\",\"LinearEncoding\",\"LinearFilter\",\"DataTextureLoader\"]\n}\n"]