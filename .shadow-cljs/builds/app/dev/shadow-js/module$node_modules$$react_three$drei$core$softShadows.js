["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@react-three/drei/core/softShadows.js"],"~:js","shadow$provide.module$node_modules$$react_three$drei$core$softShadows=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _getRequireWildcardCache(){if(\"function\"!==typeof WeakMap)return null;var cache=new WeakMap;_getRequireWildcardCache=\nfunction(){return cache};return cache}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}));keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(source,!0).forEach(function(key){var value=\nsource[key];key in target?Object.defineProperty(target,key,{value,enumerable:!0,configurable:!0,writable:!0}):target[key]=value}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(source).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}return target}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.softShadows=void 0;var THREE=function(obj){if(obj&&obj.__esModule)return obj;\nif(null===obj||\"object\"!==_typeof(obj)&&\"function\"!==typeof obj)return{\"default\":obj};var cache=_getRequireWildcardCache();if(cache&&cache.has(obj))return cache.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj[\"default\"]=\nobj;cache&&cache.set(obj,newObj);return newObj}(require(\"module$node_modules$three$build$three_module\")),pcss=function(){var _ref=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},_ref$frustum=_ref.frustum;_ref$frustum=void 0===_ref$frustum?3.75:_ref$frustum;var _ref$size=_ref.size,_ref$near=_ref.near;_ref$near=void 0===_ref$near?9.5:_ref$near;var _ref$samples=_ref.samples;_ref$samples=void 0===_ref$samples?17:_ref$samples;_ref=_ref.rings;_ref=void 0===_ref?11:_ref;return\"#define LIGHT_WORLD_SIZE \".concat(void 0===\n_ref$size?.005:_ref$size,\"\\n#define LIGHT_FRUSTUM_WIDTH \").concat(_ref$frustum,\"\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\n#define NEAR_PLANE \").concat(_ref$near,\"\\n\\n#define NUM_SAMPLES \").concat(_ref$samples,\"\\n#define NUM_RINGS \").concat(_ref,\"\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\n  float ANGLE_STEP \\x3d PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n  float INV_NUM_SAMPLES \\x3d 1.0 / float(NUM_SAMPLES);\\n  float angle \\x3d rand(randomSeed) * PI2;\\n  float radius \\x3d INV_NUM_SAMPLES;\\n  float radiusStep \\x3d radius;\\n  for (int i \\x3d 0; i \\x3c NUM_SAMPLES; i++) {\\n    poissonDisk[i] \\x3d vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n    radius +\\x3d radiusStep;\\n    angle +\\x3d ANGLE_STEP;\\n  }\\n}\\n\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\n  return (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\n  float searchRadius \\x3d LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\n  float blockerDepthSum \\x3d 0.0;\\n  int numBlockers \\x3d 0;\\n  for (int i \\x3d 0; i \\x3c BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\n    float shadowMapDepth \\x3d unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n    if (shadowMapDepth \\x3c zReceiver) {\\n      blockerDepthSum +\\x3d shadowMapDepth;\\n      numBlockers++;\\n    }\\n  }\\n  if (numBlockers \\x3d\\x3d 0) return -1.0;\\n  return blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n  float sum \\x3d 0.0;\\n  for (int i \\x3d 0; i \\x3c PCF_NUM_SAMPLES; i++) {\\n    float depth \\x3d unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\n    if (zReceiver \\x3c\\x3d depth) sum +\\x3d 1.0;\\n  }\\n  for (int i \\x3d 0; i \\x3c PCF_NUM_SAMPLES; i++) {\\n    float depth \\x3d unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\n    if (zReceiver \\x3c\\x3d depth) sum +\\x3d 1.0;\\n  }\\n  return sum / (2.0 * float(PCF_NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n  vec2 uv \\x3d coords.xy;\\n  float zReceiver \\x3d coords.z; // Assumed to be eye-space z in this code\\n  initPoissonSamples(uv);\\n  float avgBlockerDepth \\x3d findBlocker(shadowMap, uv, zReceiver);\\n  if (avgBlockerDepth \\x3d\\x3d -1.0) return 1.0;\\n  float penumbraRatio \\x3d penumbraSize(zReceiver, avgBlockerDepth);\\n  float filterRadius \\x3d penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n  return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\")},\ndeployed=!1;exports.softShadows=function(props){if(!deployed){deployed=!0;var shader=THREE.ShaderChunk.shadowmap_pars_fragment;shader=shader.replace(\"#ifdef USE_SHADOWMAP\",\"#ifdef USE_SHADOWMAP\\n\"+pcss(_objectSpread({},props)));shader=shader.replace(\"#if defined( SHADOWMAP_TYPE_PCF )\",\"\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )\");THREE.ShaderChunk.shadowmap_pars_fragment=shader}}}","~:source","shadow$provide[\"module$node_modules$$react_three$drei$core$softShadows\"] = function(global,require,module,exports) {\n\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.softShadows = void 0;\n\nvar THREE = _interopRequireWildcard(require(\"three\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar pcss = function pcss() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$frustum = _ref.frustum,\n      frustum = _ref$frustum === void 0 ? 3.75 : _ref$frustum,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 0.005 : _ref$size,\n      _ref$near = _ref.near,\n      near = _ref$near === void 0 ? 9.5 : _ref$near,\n      _ref$samples = _ref.samples,\n      samples = _ref$samples === void 0 ? 17 : _ref$samples,\n      _ref$rings = _ref.rings,\n      rings = _ref$rings === void 0 ? 11 : _ref$rings;\n\n  return \"#define LIGHT_WORLD_SIZE \".concat(size, \"\\n#define LIGHT_FRUSTUM_WIDTH \").concat(frustum, \"\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\n#define NEAR_PLANE \").concat(near, \"\\n\\n#define NUM_SAMPLES \").concat(samples, \"\\n#define NUM_RINGS \").concat(rings, \"\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\n  float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n  float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\n  float angle = rand(randomSeed) * PI2;\\n  float radius = INV_NUM_SAMPLES;\\n  float radiusStep = radius;\\n  for (int i = 0; i < NUM_SAMPLES; i++) {\\n    poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n    radius += radiusStep;\\n    angle += ANGLE_STEP;\\n  }\\n}\\n\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\n  return (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\n  float searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\n  float blockerDepthSum = 0.0;\\n  int numBlockers = 0;\\n  for (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\n    float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n    if (shadowMapDepth < zReceiver) {\\n      blockerDepthSum += shadowMapDepth;\\n      numBlockers++;\\n    }\\n  }\\n  if (numBlockers == 0) return -1.0;\\n  return blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n  float sum = 0.0;\\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\n    if (zReceiver <= depth) sum += 1.0;\\n  }\\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\n    if (zReceiver <= depth) sum += 1.0;\\n  }\\n  return sum / (2.0 * float(PCF_NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n  vec2 uv = coords.xy;\\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\\n  initPoissonSamples(uv);\\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\n  if (avgBlockerDepth == -1.0) return 1.0;\\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n  float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n  return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\");\n};\n\nvar deployed = false;\n\nvar softShadows = function softShadows(props) {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    deployed = true;\n    var shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss(_objectSpread({}, props)));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\n\nexports.softShadows = softShadows;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["shadowmap_pars_fragment","__esModule","softShadows","configurable","value","enumerable","writable"]],"~:compiled-at",1630917516199,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$react_three$drei$core$softShadows.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@react-three/drei/core/softShadows.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$react_three$drei$core$softShadows\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.softShadows = void 0;\\n\\nvar THREE = _interopRequireWildcard(require(\\\"three\\\"));\\n\\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \\\"function\\\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \\\"object\\\" && typeof obj !== \\\"function\\\") { return { \\\"default\\\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\\\"default\\\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\\n\\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\\n\\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\\n\\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\nvar pcss = function pcss() {\\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\\n      _ref$frustum = _ref.frustum,\\n      frustum = _ref$frustum === void 0 ? 3.75 : _ref$frustum,\\n      _ref$size = _ref.size,\\n      size = _ref$size === void 0 ? 0.005 : _ref$size,\\n      _ref$near = _ref.near,\\n      near = _ref$near === void 0 ? 9.5 : _ref$near,\\n      _ref$samples = _ref.samples,\\n      samples = _ref$samples === void 0 ? 17 : _ref$samples,\\n      _ref$rings = _ref.rings,\\n      rings = _ref$rings === void 0 ? 11 : _ref$rings;\\n\\n  return \\\"#define LIGHT_WORLD_SIZE \\\".concat(size, \\\"\\\\n#define LIGHT_FRUSTUM_WIDTH \\\").concat(frustum, \\\"\\\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\\\n#define NEAR_PLANE \\\").concat(near, \\\"\\\\n\\\\n#define NUM_SAMPLES \\\").concat(samples, \\\"\\\\n#define NUM_RINGS \\\").concat(rings, \\\"\\\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\\\n\\\\nvec2 poissonDisk[NUM_SAMPLES];\\\\n\\\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\\\n  float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\\\n  float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\\\n  float angle = rand(randomSeed) * PI2;\\\\n  float radius = INV_NUM_SAMPLES;\\\\n  float radiusStep = radius;\\\\n  for (int i = 0; i < NUM_SAMPLES; i++) {\\\\n    poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\\\n    radius += radiusStep;\\\\n    angle += ANGLE_STEP;\\\\n  }\\\\n}\\\\n\\\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\\\n  return (zReceiver - zBlocker) / zBlocker;\\\\n}\\\\n\\\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\\\n  float searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\\\n  float blockerDepthSum = 0.0;\\\\n  int numBlockers = 0;\\\\n  for (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\\\n    float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\\\n    if (shadowMapDepth < zReceiver) {\\\\n      blockerDepthSum += shadowMapDepth;\\\\n      numBlockers++;\\\\n    }\\\\n  }\\\\n  if (numBlockers == 0) return -1.0;\\\\n  return blockerDepthSum / float(numBlockers);\\\\n}\\\\n\\\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\\\n  float sum = 0.0;\\\\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\\\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\\\n    if (zReceiver <= depth) sum += 1.0;\\\\n  }\\\\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\\\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\\\n    if (zReceiver <= depth) sum += 1.0;\\\\n  }\\\\n  return sum / (2.0 * float(PCF_NUM_SAMPLES));\\\\n}\\\\n\\\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\\\n  vec2 uv = coords.xy;\\\\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\\\\n  initPoissonSamples(uv);\\\\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\\\n  if (avgBlockerDepth == -1.0) return 1.0;\\\\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\\\n  float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\\\n  return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\\\n}\\\");\\n};\\n\\nvar deployed = false;\\n\\nvar softShadows = function softShadows(props) {\\n  // Avoid adding the effect twice, which may happen in HMR scenarios\\n  if (!deployed) {\\n    deployed = true;\\n    var shader = THREE.ShaderChunk.shadowmap_pars_fragment;\\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\\\n' + pcss(_objectSpread({}, props)));\\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\\\nreturn PCSS(shadowMap, shadowCoord);\\\\n#if defined( SHADOWMAP_TYPE_PCF )');\\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\\n  }\\n};\\n\\nexports.softShadows = softShadows;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_getRequireWildcardCache\",\"WeakMap\",\"cache\",\"ownKeys\",\"object\",\"enumerableOnly\",\"keys\",\"Object\",\"getOwnPropertySymbols\",\"symbols\",\"filter\",\"sym\",\"getOwnPropertyDescriptor\",\"enumerable\",\"push\",\"apply\",\"_objectSpread\",\"target\",\"i\",\"arguments\",\"length\",\"source\",\"forEach\",\"key\",\"defineProperty\",\"value\",\"configurable\",\"writable\",\"getOwnPropertyDescriptors\",\"defineProperties\",\"softShadows\",\"THREE\",\"_interopRequireWildcard\",\"__esModule\",\"has\",\"get\",\"newObj\",\"hasPropertyDescriptor\",\"hasOwnProperty\",\"call\",\"desc\",\"set\",\"pcss\",\"_ref\",\"undefined\",\"_ref$frustum\",\"frustum\",\"_ref$size\",\"size\",\"_ref$near\",\"near\",\"_ref$samples\",\"samples\",\"_ref$rings\",\"rings\",\"concat\",\"deployed\",\"props\",\"shader\",\"ShaderChunk\",\"shadowmap_pars_fragment\",\"replace\"]\n}\n"]