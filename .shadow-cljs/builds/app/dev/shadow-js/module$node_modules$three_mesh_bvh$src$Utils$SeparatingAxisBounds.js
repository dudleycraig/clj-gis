["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-mesh-bvh/src/Utils/SeparatingAxisBounds.js"],"~:js","shadow$provide.module$node_modules$three_mesh_bvh$src$Utils$SeparatingAxisBounds=function(global,require,module,exports){function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,\nprotoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.areIntersecting=exports.SeparatingAxisBounds=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),SeparatingAxisBounds=function(){function SeparatingAxisBounds(){if(!(this instanceof SeparatingAxisBounds))throw new TypeError(\"Cannot call a class as a function\");this.min=Infinity;this.max=-Infinity}_createClass(SeparatingAxisBounds,\n[{key:\"setFromPointsField\",value:function(points,field){for(var min=Infinity,max=-Infinity,i=0,l=points.length;i<l;i++){var val=points[i][field];min=Math.min(val,min);max=Math.max(val,max)}this.min=min;this.max=max}},{key:\"setFromPoints\",value:function(axis,points){for(var min=Infinity,max=-Infinity,i=0,l=points.length;i<l;i++){var val=axis.dot(points[i]);min=Math.min(val,min);max=Math.max(val,max)}this.min=min;this.max=max}},{key:\"isSeparated\",value:function(other){return this.min>other.max||other.min>\nthis.max}}]);return SeparatingAxisBounds}();exports.SeparatingAxisBounds=SeparatingAxisBounds;SeparatingAxisBounds.prototype.setFromBox=function(){var p=new _three.Vector3;return function(axis,box){var boxMin=box.min;box=box.max;for(var min=Infinity,max=-Infinity,x=0;1>=x;x++)for(var y=0;1>=y;y++)for(var z=0;1>=z;z++){p.x=boxMin.x*x+box.x*(1-x);p.y=boxMin.y*y+box.y*(1-y);p.z=boxMin.z*z+box.z*(1-z);var val=axis.dot(p);min=Math.min(val,min);max=Math.max(val,max)}this.min=min;this.max=max}}();global=\nfunction(){var cacheSatBounds=new SeparatingAxisBounds;return function(shape1,shape2){var points1=shape1.points,satAxes1=shape1.satAxes,satBounds1=shape1.satBounds,points2=shape2.points;shape1=shape2.satAxes;shape2=shape2.satBounds;for(var i=0;3>i;i++){var sb=satBounds1[i];cacheSatBounds.setFromPoints(satAxes1[i],points2);if(sb.isSeparated(cacheSatBounds))return!1}for(satAxes1=0;3>satAxes1;satAxes1++)if(satBounds1=shape2[satAxes1],cacheSatBounds.setFromPoints(shape1[satAxes1],points1),satBounds1.isSeparated(cacheSatBounds))return!1}}();\nexports.areIntersecting=global}","~:source","shadow$provide[\"module$node_modules$three_mesh_bvh$src$Utils$SeparatingAxisBounds\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.areIntersecting = exports.SeparatingAxisBounds = void 0;\n\nvar _three = require(\"three\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar SeparatingAxisBounds =\n/*#__PURE__*/\nfunction () {\n  function SeparatingAxisBounds() {\n    _classCallCheck(this, SeparatingAxisBounds);\n\n    this.min = Infinity;\n    this.max = -Infinity;\n  }\n\n  _createClass(SeparatingAxisBounds, [{\n    key: \"setFromPointsField\",\n    value: function setFromPointsField(points, field) {\n      var min = Infinity;\n      var max = -Infinity;\n\n      for (var i = 0, l = points.length; i < l; i++) {\n        var p = points[i];\n        var val = p[field];\n        min = Math.min(val, min);\n        max = Math.max(val, max);\n      }\n\n      this.min = min;\n      this.max = max;\n    }\n  }, {\n    key: \"setFromPoints\",\n    value: function setFromPoints(axis, points) {\n      var min = Infinity;\n      var max = -Infinity;\n\n      for (var i = 0, l = points.length; i < l; i++) {\n        var p = points[i];\n        var val = axis.dot(p);\n        min = Math.min(val, min);\n        max = Math.max(val, max);\n      }\n\n      this.min = min;\n      this.max = max;\n    }\n  }, {\n    key: \"isSeparated\",\n    value: function isSeparated(other) {\n      return this.min > other.max || other.min > this.max;\n    }\n  }]);\n\n  return SeparatingAxisBounds;\n}();\n\nexports.SeparatingAxisBounds = SeparatingAxisBounds;\n\nSeparatingAxisBounds.prototype.setFromBox = function () {\n  var p = new _three.Vector3();\n  return function setFromBox(axis, box) {\n    var boxMin = box.min;\n    var boxMax = box.max;\n    var min = Infinity;\n    var max = -Infinity;\n\n    for (var x = 0; x <= 1; x++) {\n      for (var y = 0; y <= 1; y++) {\n        for (var z = 0; z <= 1; z++) {\n          p.x = boxMin.x * x + boxMax.x * (1 - x);\n          p.y = boxMin.y * y + boxMax.y * (1 - y);\n          p.z = boxMin.z * z + boxMax.z * (1 - z);\n          var val = axis.dot(p);\n          min = Math.min(val, min);\n          max = Math.max(val, max);\n        }\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n  };\n}();\n\nvar areIntersecting = function () {\n  var cacheSatBounds = new SeparatingAxisBounds();\n  return function areIntersecting(shape1, shape2) {\n    var points1 = shape1.points;\n    var satAxes1 = shape1.satAxes;\n    var satBounds1 = shape1.satBounds;\n    var points2 = shape2.points;\n    var satAxes2 = shape2.satAxes;\n    var satBounds2 = shape2.satBounds; // check axes of the first shape\n\n    for (var i = 0; i < 3; i++) {\n      var sb = satBounds1[i];\n      var sa = satAxes1[i];\n      cacheSatBounds.setFromPoints(sa, points2);\n      if (sb.isSeparated(cacheSatBounds)) return false;\n    } // check axes of the second shape\n\n\n    for (var _i = 0; _i < 3; _i++) {\n      var _sb = satBounds2[_i];\n      var _sa = satAxes2[_i];\n      cacheSatBounds.setFromPoints(_sa, points1);\n      if (_sb.isSeparated(cacheSatBounds)) return false;\n    }\n  };\n}();\n\nexports.areIntersecting = areIntersecting;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["areIntersecting","z","min","key","x","__esModule","max","configurable","value","enumerable","SeparatingAxisBounds","setFromBox","writable","y"]],"~:compiled-at",1630917516172,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_mesh_bvh$src$Utils$SeparatingAxisBounds.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-mesh-bvh/src/Utils/SeparatingAxisBounds.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_mesh_bvh$src$Utils$SeparatingAxisBounds\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.areIntersecting = exports.SeparatingAxisBounds = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nvar SeparatingAxisBounds =\\n/*#__PURE__*/\\nfunction () {\\n  function SeparatingAxisBounds() {\\n    _classCallCheck(this, SeparatingAxisBounds);\\n\\n    this.min = Infinity;\\n    this.max = -Infinity;\\n  }\\n\\n  _createClass(SeparatingAxisBounds, [{\\n    key: \\\"setFromPointsField\\\",\\n    value: function setFromPointsField(points, field) {\\n      var min = Infinity;\\n      var max = -Infinity;\\n\\n      for (var i = 0, l = points.length; i < l; i++) {\\n        var p = points[i];\\n        var val = p[field];\\n        min = Math.min(val, min);\\n        max = Math.max(val, max);\\n      }\\n\\n      this.min = min;\\n      this.max = max;\\n    }\\n  }, {\\n    key: \\\"setFromPoints\\\",\\n    value: function setFromPoints(axis, points) {\\n      var min = Infinity;\\n      var max = -Infinity;\\n\\n      for (var i = 0, l = points.length; i < l; i++) {\\n        var p = points[i];\\n        var val = axis.dot(p);\\n        min = Math.min(val, min);\\n        max = Math.max(val, max);\\n      }\\n\\n      this.min = min;\\n      this.max = max;\\n    }\\n  }, {\\n    key: \\\"isSeparated\\\",\\n    value: function isSeparated(other) {\\n      return this.min > other.max || other.min > this.max;\\n    }\\n  }]);\\n\\n  return SeparatingAxisBounds;\\n}();\\n\\nexports.SeparatingAxisBounds = SeparatingAxisBounds;\\n\\nSeparatingAxisBounds.prototype.setFromBox = function () {\\n  var p = new _three.Vector3();\\n  return function setFromBox(axis, box) {\\n    var boxMin = box.min;\\n    var boxMax = box.max;\\n    var min = Infinity;\\n    var max = -Infinity;\\n\\n    for (var x = 0; x <= 1; x++) {\\n      for (var y = 0; y <= 1; y++) {\\n        for (var z = 0; z <= 1; z++) {\\n          p.x = boxMin.x * x + boxMax.x * (1 - x);\\n          p.y = boxMin.y * y + boxMax.y * (1 - y);\\n          p.z = boxMin.z * z + boxMax.z * (1 - z);\\n          var val = axis.dot(p);\\n          min = Math.min(val, min);\\n          max = Math.max(val, max);\\n        }\\n      }\\n    }\\n\\n    this.min = min;\\n    this.max = max;\\n  };\\n}();\\n\\nvar areIntersecting = function () {\\n  var cacheSatBounds = new SeparatingAxisBounds();\\n  return function areIntersecting(shape1, shape2) {\\n    var points1 = shape1.points;\\n    var satAxes1 = shape1.satAxes;\\n    var satBounds1 = shape1.satBounds;\\n    var points2 = shape2.points;\\n    var satAxes2 = shape2.satAxes;\\n    var satBounds2 = shape2.satBounds; // check axes of the first shape\\n\\n    for (var i = 0; i < 3; i++) {\\n      var sb = satBounds1[i];\\n      var sa = satAxes1[i];\\n      cacheSatBounds.setFromPoints(sa, points2);\\n      if (sb.isSeparated(cacheSatBounds)) return false;\\n    } // check axes of the second shape\\n\\n\\n    for (var _i = 0; _i < 3; _i++) {\\n      var _sb = satBounds2[_i];\\n      var _sa = satAxes2[_i];\\n      cacheSatBounds.setFromPoints(_sa, points1);\\n      if (_sb.isSeparated(cacheSatBounds)) return false;\\n    }\\n  };\\n}();\\n\\nexports.areIntersecting = areIntersecting;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"prototype\",\"value\",\"areIntersecting\",\"SeparatingAxisBounds\",\"_three\",\"instance\",\"TypeError\",\"min\",\"Infinity\",\"max\",\"setFromPointsField\",\"points\",\"field\",\"l\",\"val\",\"p\",\"Math\",\"setFromPoints\",\"axis\",\"dot\",\"isSeparated\",\"other\",\"setFromBox\",\"Vector3\",\"box\",\"boxMin\",\"boxMax\",\"x\",\"y\",\"z\",\"cacheSatBounds\",\"shape1\",\"shape2\",\"points1\",\"satAxes1\",\"satAxes\",\"satBounds1\",\"satBounds\",\"points2\",\"satAxes2\",\"satBounds2\",\"sb\",\"sa\",\"_i\",\"_sb\",\"_sa\"]\n}\n"]