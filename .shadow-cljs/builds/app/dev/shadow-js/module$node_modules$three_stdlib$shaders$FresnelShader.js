["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/shaders/FresnelShader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$shaders$FresnelShader=function(global,require,module,exports){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.FresnelShader=void 0;exports.FresnelShader={uniforms:{mRefractionRatio:{value:1.02},mFresnelBias:{value:.1},mFresnelPower:{value:2},mFresnelScale:{value:1},tCube:{value:null}},vertexShader:\"uniform float mRefractionRatio;\\nuniform float mFresnelBias;\\nuniform float mFresnelScale;\\nuniform float mFresnelPower;\\nvarying vec3 vReflect;\\nvarying vec3 vRefract[3];\\nvarying float vReflectionFactor;\\nvoid main() {\\n\\tvec4 mvPosition \\x3d modelViewMatrix * vec4( position, 1.0 );\\n\\tvec4 worldPosition \\x3d modelMatrix * vec4( position, 1.0 );\\n\\tvec3 worldNormal \\x3d normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\\n\\tvec3 I \\x3d worldPosition.xyz - cameraPosition;\\n\\tvReflect \\x3d reflect( I, worldNormal );\\n\\tvRefract[0] \\x3d refract( normalize( I ), worldNormal, mRefractionRatio );\\n\\tvRefract[1] \\x3d refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\\n\\tvRefract[2] \\x3d refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\\n\\tvReflectionFactor \\x3d mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\\n\\tgl_Position \\x3d projectionMatrix * mvPosition;\\n}\",\nfragmentShader:\"uniform samplerCube tCube;\\nvarying vec3 vReflect;\\nvarying vec3 vRefract[3];\\nvarying float vReflectionFactor;\\nvoid main() {\\n\\tvec4 reflectedColor \\x3d textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\\n\\tvec4 refractedColor \\x3d vec4( 1.0 );\\n\\trefractedColor.r \\x3d textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\\n\\trefractedColor.g \\x3d textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\\n\\trefractedColor.b \\x3d textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\\n\\tgl_FragColor \\x3d mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\\n}\"}}","~:source","shadow$provide[\"module$node_modules$three_stdlib$shaders$FresnelShader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FresnelShader = void 0;\n\n/**\n * Based on Nvidia Cg tutorial\n */\nvar FresnelShader = {\n  uniforms: {\n    mRefractionRatio: {\n      value: 1.02\n    },\n    mFresnelBias: {\n      value: 0.1\n    },\n    mFresnelPower: {\n      value: 2.0\n    },\n    mFresnelScale: {\n      value: 1.0\n    },\n    tCube: {\n      value: null\n    }\n  },\n  vertexShader: ['uniform float mRefractionRatio;', 'uniform float mFresnelBias;', 'uniform float mFresnelScale;', 'uniform float mFresnelPower;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );', '\tvec3 I = worldPosition.xyz - cameraPosition;', '\tvReflect = reflect( I, worldNormal );', '\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );', '\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );', '\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );', '\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform samplerCube tCube;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );', '\tvec4 refractedColor = vec4( 1.0 );', '\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;', '\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;', '\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;', '\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );', '}'].join('\\n')\n};\nexports.FresnelShader = FresnelShader;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["fragmentShader","mRefractionRatio","__esModule","mFresnelScale","vertexShader","value","FresnelShader","mFresnelBias","tCube","uniforms","mFresnelPower"]],"~:compiled-at",1630917515592,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$shaders$FresnelShader.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,sDAAA,CAA2E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGnHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,aAAR,CAAwB,IAAK,EA0B7BJ,QAAQI,CAAAA,aAAR,CArBoBA,CAClBC,SAAU,CACRC,iBAAkB,CAChBH,MAAO,IADS,CADV,CAIRI,aAAc,CACZJ,MAAO,EADK,CAJN,CAORK,cAAe,CACbL,MAAO,CADM,CAPP,CAURM,cAAe,CACbN,MAAO,CADM,CAVP,CAaRO,MAAO,CACLP,MAAO,IADF,CAbC,CADQC,CAkBlBO,aAAg+B,w9BAlB98BP;AAmBlBQ,eAAynB,6mBAnBvmBR,CAX+F;\",\n\"sources\":[\"node_modules/three-stdlib/shaders/FresnelShader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$shaders$FresnelShader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.FresnelShader = void 0;\\n\\n/**\\n * Based on Nvidia Cg tutorial\\n */\\nvar FresnelShader = {\\n  uniforms: {\\n    mRefractionRatio: {\\n      value: 1.02\\n    },\\n    mFresnelBias: {\\n      value: 0.1\\n    },\\n    mFresnelPower: {\\n      value: 2.0\\n    },\\n    mFresnelScale: {\\n      value: 1.0\\n    },\\n    tCube: {\\n      value: null\\n    }\\n  },\\n  vertexShader: ['uniform float mRefractionRatio;', 'uniform float mFresnelBias;', 'uniform float mFresnelScale;', 'uniform float mFresnelPower;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );', '\\tvec3 I = worldPosition.xyz - cameraPosition;', '\\tvReflect = reflect( I, worldNormal );', '\\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );', '\\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );', '\\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );', '\\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );', '\\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\\\n'),\\n  fragmentShader: ['uniform samplerCube tCube;', 'varying vec3 vReflect;', 'varying vec3 vRefract[3];', 'varying float vReflectionFactor;', 'void main() {', '\\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );', '\\tvec4 refractedColor = vec4( 1.0 );', '\\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;', '\\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;', '\\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;', '\\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );', '}'].join('\\\\n')\\n};\\nexports.FresnelShader = FresnelShader;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Object\",\"defineProperty\",\"value\",\"FresnelShader\",\"uniforms\",\"mRefractionRatio\",\"mFresnelBias\",\"mFresnelPower\",\"mFresnelScale\",\"tCube\",\"vertexShader\",\"fragmentShader\"]\n}\n"]