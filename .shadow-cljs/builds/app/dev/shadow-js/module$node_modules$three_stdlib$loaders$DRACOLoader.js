["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/loaders/DRACOLoader.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$loaders$DRACOLoader=function(global,require,module$jscomp$0,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];\ndescriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}function _createClass(Constructor,protoProps,staticProps){protoProps&&_defineProperties(Constructor.prototype,protoProps);staticProps&&_defineProperties(Constructor,staticProps);return Constructor}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||\nObject.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,\np){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}function DRACOWorker(){function decodeGeometry(draco$jscomp$0,decoder$jscomp$0,decoderBuffer,taskConfig){var attributeIDs=taskConfig.attributeIDs,attributeTypes=taskConfig.attributeTypes,geometryType=decoder$jscomp$0.GetEncodedGeometryType(decoderBuffer);if(geometryType===draco$jscomp$0.TRIANGULAR_MESH){var dracoGeometry=new draco$jscomp$0.Mesh;decoderBuffer=decoder$jscomp$0.DecodeBufferToMesh(decoderBuffer,dracoGeometry)}else if(geometryType===\ndraco$jscomp$0.POINT_CLOUD)dracoGeometry=new draco$jscomp$0.PointCloud,decoderBuffer=decoder$jscomp$0.DecodeBufferToPointCloud(decoderBuffer,dracoGeometry);else throw Error(\"THREE.DRACOLoader: Unexpected geometry type.\");if(!decoderBuffer.ok()||0===dracoGeometry.ptr)throw Error(\"THREE.DRACOLoader: Decoding failed: \"+decoderBuffer.error_msg());decoderBuffer={index:null,attributes:[]};for(var attributeName in attributeIDs){var attributeType=self[attributeTypes[attributeName]];if(taskConfig.useUniqueIDs){var attributeID=\nattributeIDs[attributeName];var attribute=decoder$jscomp$0.GetAttributeByUniqueId(dracoGeometry,attributeID)}else{attributeID=decoder$jscomp$0.GetAttributeId(dracoGeometry,draco$jscomp$0[attributeIDs[attributeName]]);if(-1===attributeID)continue;attribute=decoder$jscomp$0.GetAttribute(dracoGeometry,attributeID)}attributeID=decoderBuffer.attributes;var JSCompiler_temp_const=attributeID.push,draco=draco$jscomp$0,decoder=decoder$jscomp$0,dracoGeometry$jscomp$0=dracoGeometry,attributeName$jscomp$0=attributeName,\nattribute$jscomp$0=attribute;attribute=attribute$jscomp$0.num_components();var numValues=dracoGeometry$jscomp$0.num_points()*attribute,byteLength=numValues*attributeType.BYTES_PER_ELEMENT,dataType=getDracoDataType(draco,attributeType),ptr=draco._malloc(byteLength);decoder.GetAttributeDataArrayForAllPoints(dracoGeometry$jscomp$0,attribute$jscomp$0,dataType,byteLength,ptr);decoder=(new attributeType(draco.HEAPF32.buffer,ptr,numValues)).slice();draco._free(ptr);JSCompiler_temp_const.call(attributeID,\n{name:attributeName$jscomp$0,array:decoder,itemSize:attribute})}geometryType===draco$jscomp$0.TRIANGULAR_MESH&&(attributeIDs=dracoGeometry,attributeTypes=3*attributeIDs.num_faces(),geometryType=4*attributeTypes,taskConfig=draco$jscomp$0._malloc(geometryType),decoder$jscomp$0.GetTrianglesUInt32Array(attributeIDs,geometryType,taskConfig),decoder$jscomp$0=(new Uint32Array(draco$jscomp$0.HEAPF32.buffer,taskConfig,attributeTypes)).slice(),draco$jscomp$0._free(taskConfig),decoderBuffer.index={array:decoder$jscomp$0,\nitemSize:1});draco$jscomp$0.destroy(dracoGeometry);return decoderBuffer}function getDracoDataType(draco,attributeType){switch(attributeType){case Float32Array:return draco.DT_FLOAT32;case Int8Array:return draco.DT_INT8;case Int16Array:return draco.DT_INT16;case Int32Array:return draco.DT_INT32;case Uint8Array:return draco.DT_UINT8;case Uint16Array:return draco.DT_UINT16;case Uint32Array:return draco.DT_UINT32}}var decoderConfig,decoderPending;onmessage=function(e){var message=e.data;switch(message.type){case \"init\":decoderConfig=\nmessage.decoderConfig;decoderPending=new Promise(function(resolve){decoderConfig.onModuleLoaded=function(draco){resolve({draco})};DracoDecoderModule(decoderConfig)});break;case \"decode\":var buffer=message.buffer,taskConfig=message.taskConfig;decoderPending.then(function(module){module=module.draco;var decoder=new module.Decoder,decoderBuffer=new module.DecoderBuffer;decoderBuffer.Init(new Int8Array(buffer),buffer.byteLength);try{var geometry=decodeGeometry(module,decoder,decoderBuffer,taskConfig),\nbuffers=geometry.attributes.map(function(attr){return attr.array.buffer});geometry.index&&buffers.push(geometry.index.array.buffer);self.postMessage({type:\"decode\",id:message.id,geometry},buffers)}catch(error){console.error(error),self.postMessage({type:\"error\",id:message.id,error:error.message})}finally{module.destroy(decoderBuffer),module.destroy(decoder)}})}}}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.DRACOLoader=void 0;var _three=require(\"module$node_modules$three$build$three_module\"),\n_taskCache=new WeakMap;global=function(_Loader){function DRACOLoader(manager){if(!(this instanceof DRACOLoader))throw new TypeError(\"Cannot call a class as a function\");manager=_getPrototypeOf(DRACOLoader).call(this,manager);if(!manager||\"object\"!==_typeof(manager)&&\"function\"!==typeof manager){if(void 0===this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");manager=this}manager.decoderPath=\"\";manager.decoderConfig={};manager.decoderBinary=null;manager.decoderPending=\nnull;manager.workerLimit=4;manager.workerPool=[];manager.workerNextTaskID=1;manager.workerSourceURL=\"\";manager.defaultAttributeIDs={position:\"POSITION\",normal:\"NORMAL\",color:\"COLOR\",uv:\"TEX_COORD\"};manager.defaultAttributeTypes={position:\"Float32Array\",normal:\"Float32Array\",color:\"Float32Array\",uv:\"Float32Array\"};return manager}_inherits(DRACOLoader,_Loader);_createClass(DRACOLoader,[{key:\"setDecoderPath\",value:function(path){this.decoderPath=path;return this}},{key:\"setDecoderConfig\",value:function(config){this.decoderConfig=\nconfig;return this}},{key:\"setWorkerLimit\",value:function(workerLimit){this.workerLimit=workerLimit;return this}},{key:\"load\",value:function(url,onLoad,onProgress,onError){var _this2=this,loader=new _three.FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType(\"arraybuffer\");loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);loader.load(url,function(buffer){_this2.decodeGeometry(buffer,{attributeIDs:_this2.defaultAttributeIDs,attributeTypes:_this2.defaultAttributeTypes,\nuseUniqueIDs:!1}).then(onLoad)[\"catch\"](onError)},onProgress,onError)}},{key:\"decodeDracoFile\",value:function(buffer,callback,attributeIDs,attributeTypes){this.decodeGeometry(buffer,{attributeIDs:attributeIDs||this.defaultAttributeIDs,attributeTypes:attributeTypes||this.defaultAttributeTypes,useUniqueIDs:!!attributeIDs}).then(callback)}},{key:\"decodeGeometry\",value:function(buffer,taskConfig){var _this3=this;for(attribute in taskConfig.attributeTypes){var type=taskConfig.attributeTypes[attribute];\nvoid 0!==type.BYTES_PER_ELEMENT&&(taskConfig.attributeTypes[attribute]=type.name)}var attribute=JSON.stringify(taskConfig);if(_taskCache.has(buffer)){type=_taskCache.get(buffer);if(type.key===attribute)return type.promise;if(0===buffer.byteLength)throw Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");}var worker,taskID=this.workerNextTaskID++;type=this._getWorker(taskID,buffer.byteLength).then(function(_worker){worker=_worker;return new Promise(function(resolve,\nreject){worker._callbacks[taskID]={resolve,reject};worker.postMessage({type:\"decode\",id:taskID,taskConfig,buffer},[buffer])})}).then(function(message){return _this3._createGeometry(message.geometry)});type[\"catch\"](function(){return!0}).then(function(){worker&&taskID&&_this3._releaseTask(worker,taskID)});_taskCache.set(buffer,{key:attribute,promise:type});return type}},{key:\"_createGeometry\",value:function(geometryData){var geometry=new _three.BufferGeometry;geometryData.index&&geometry.setIndex(new _three.BufferAttribute(geometryData.index.array,\n1));for(var i=0;i<geometryData.attributes.length;i++){var attribute=geometryData.attributes[i];geometry.setAttribute(attribute.name,new _three.BufferAttribute(attribute.array,attribute.itemSize))}return geometry}},{key:\"_loadLibrary\",value:function(url,responseType){var loader=new _three.FileLoader(this.manager);loader.setPath(this.decoderPath);loader.setResponseType(responseType);loader.setWithCredentials(this.withCredentials);return new Promise(function(resolve,reject){loader.load(url,resolve,void 0,\nreject)})}},{key:\"preload\",value:function(){this._initDecoder();return this}},{key:\"_initDecoder\",value:function(){var _this4=this;if(this.decoderPending)return this.decoderPending;var useJS=\"object\"!==(\"undefined\"===typeof WebAssembly?\"undefined\":_typeof(WebAssembly))||\"js\"===this.decoderConfig.type,librariesPending=[];useJS?librariesPending.push(this._loadLibrary(\"draco_decoder.js\",\"text\")):(librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\",\"text\")),librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\",\n\"arraybuffer\")));return this.decoderPending=Promise.all(librariesPending).then(function(libraries){var jsContent=libraries[0];useJS||(_this4.decoderConfig.wasmBinary=libraries[1]);libraries=DRACOWorker.toString();jsContent=[\"/* draco decoder */\",jsContent,\"\\n/* worker */\",libraries.substring(libraries.indexOf(\"{\")+1,libraries.lastIndexOf(\"}\"))].join(\"\\n\");_this4.workerSourceURL=URL.createObjectURL(new Blob([jsContent]))})}},{key:\"_getWorker\",value:function(taskID,taskCost){var _this5=this;return this._initDecoder().then(function(){if(_this5.workerPool.length<\n_this5.workerLimit){var _worker2=new Worker(_this5.workerSourceURL);_worker2._callbacks={};_worker2._taskCosts={};_worker2._taskLoad=0;_worker2.postMessage({type:\"init\",decoderConfig:_this5.decoderConfig});_worker2.onmessage=function(e){e=e.data;switch(e.type){case \"decode\":_worker2._callbacks[e.id].resolve(e);break;case \"error\":_worker2._callbacks[e.id].reject(e);break;default:console.error('THREE.DRACOLoader: Unexpected message, \"'+e.type+'\"')}};_this5.workerPool.push(_worker2)}else _this5.workerPool.sort(function(a,\nb){return a._taskLoad>b._taskLoad?-1:1});var worker=_this5.workerPool[_this5.workerPool.length-1];worker._taskCosts[taskID]=taskCost;worker._taskLoad+=taskCost;return worker})}},{key:\"_releaseTask\",value:function(worker,taskID){worker._taskLoad-=worker._taskCosts[taskID];delete worker._callbacks[taskID];delete worker._taskCosts[taskID]}},{key:\"debug\",value:function(){console.log(\"Task load: \",this.workerPool.map(function(worker){return worker._taskLoad}))}},{key:\"dispose\",value:function(){for(var i=\n0;i<this.workerPool.length;++i)this.workerPool[i].terminate();this.workerPool.length=0;return this}}]);return DRACOLoader}(_three.Loader);exports.DRACOLoader=global}","~:source","shadow$provide[\"module$node_modules$three_stdlib$loaders$DRACOLoader\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DRACOLoader = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar _taskCache = new WeakMap();\n\nvar DRACOLoader =\n/*#__PURE__*/\nfunction (_Loader) {\n  _inherits(DRACOLoader, _Loader);\n\n  function DRACOLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, DRACOLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DRACOLoader).call(this, manager));\n    _this.decoderPath = '';\n    _this.decoderConfig = {};\n    _this.decoderBinary = null;\n    _this.decoderPending = null;\n    _this.workerLimit = 4;\n    _this.workerPool = [];\n    _this.workerNextTaskID = 1;\n    _this.workerSourceURL = '';\n    _this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    _this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n    return _this;\n  }\n\n  _createClass(DRACOLoader, [{\n    key: \"setDecoderPath\",\n    value: function setDecoderPath(path) {\n      this.decoderPath = path;\n      return this;\n    }\n  }, {\n    key: \"setDecoderConfig\",\n    value: function setDecoderConfig(config) {\n      this.decoderConfig = config;\n      return this;\n    }\n  }, {\n    key: \"setWorkerLimit\",\n    value: function setWorkerLimit(workerLimit) {\n      this.workerLimit = workerLimit;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this2 = this;\n\n      var loader = new _three.FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (buffer) {\n        var taskConfig = {\n          attributeIDs: _this2.defaultAttributeIDs,\n          attributeTypes: _this2.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n\n        _this2.decodeGeometry(buffer, taskConfig).then(onLoad)[\"catch\"](onError);\n      }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\n  }, {\n    key: \"decodeDracoFile\",\n    value: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n      var taskConfig = {\n        attributeIDs: attributeIDs || this.defaultAttributeIDs,\n        attributeTypes: attributeTypes || this.defaultAttributeTypes,\n        useUniqueIDs: !!attributeIDs\n      };\n      this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n  }, {\n    key: \"decodeGeometry\",\n    value: function decodeGeometry(buffer, taskConfig) {\n      var _this3 = this;\n\n      // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n      // references (rather than names) to typed array constructors. These must be\n      // serialized before sending them to the worker.\n      for (var attribute in taskConfig.attributeTypes) {\n        var type = taskConfig.attributeTypes[attribute];\n\n        if (type.BYTES_PER_ELEMENT !== undefined) {\n          taskConfig.attributeTypes[attribute] = type.name;\n        }\n      } //\n\n\n      var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n\n      if (_taskCache.has(buffer)) {\n        var cachedTask = _taskCache.get(buffer);\n\n        if (cachedTask.key === taskKey) {\n          return cachedTask.promise;\n        } else if (buffer.byteLength === 0) {\n          // Technically, it would be possible to wait for the previous task to complete,\n          // transfer the buffer back, and decode again with the second configuration. That\n          // is complex, and I don't know of any reason to decode a Draco buffer twice in\n          // different ways, so this is left unimplemented.\n          throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n        }\n      } //\n\n\n      var worker;\n      var taskID = this.workerNextTaskID++;\n      var taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n      // when the task completes.\n\n      var geometryPending = this._getWorker(taskID, taskCost).then(function (_worker) {\n        worker = _worker;\n        return new Promise(function (resolve, reject) {\n          worker._callbacks[taskID] = {\n            resolve: resolve,\n            reject: reject\n          };\n          worker.postMessage({\n            type: 'decode',\n            id: taskID,\n            taskConfig: taskConfig,\n            buffer: buffer\n          }, [buffer]); // this.debug();\n        });\n      }).then(function (message) {\n        return _this3._createGeometry(message.geometry);\n      }); // Remove task from the task list.\n      // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n      geometryPending[\"catch\"](function () {\n        return true;\n      }).then(function () {\n        if (worker && taskID) {\n          _this3._releaseTask(worker, taskID); // this.debug();\n\n        }\n      }); // Cache the task result.\n\n      _taskCache.set(buffer, {\n        key: taskKey,\n        promise: geometryPending\n      });\n\n      return geometryPending;\n    }\n  }, {\n    key: \"_createGeometry\",\n    value: function _createGeometry(geometryData) {\n      var geometry = new _three.BufferGeometry();\n\n      if (geometryData.index) {\n        geometry.setIndex(new _three.BufferAttribute(geometryData.index.array, 1));\n      }\n\n      for (var i = 0; i < geometryData.attributes.length; i++) {\n        var attribute = geometryData.attributes[i];\n        var name = attribute.name;\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        geometry.setAttribute(name, new _three.BufferAttribute(array, itemSize));\n      }\n\n      return geometry;\n    }\n  }, {\n    key: \"_loadLibrary\",\n    value: function _loadLibrary(url, responseType) {\n      var loader = new _three.FileLoader(this.manager);\n      loader.setPath(this.decoderPath);\n      loader.setResponseType(responseType);\n      loader.setWithCredentials(this.withCredentials);\n      return new Promise(function (resolve, reject) {\n        loader.load(url, resolve, undefined, reject);\n      });\n    }\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      this._initDecoder();\n\n      return this;\n    }\n  }, {\n    key: \"_initDecoder\",\n    value: function _initDecoder() {\n      var _this4 = this;\n\n      if (this.decoderPending) return this.decoderPending;\n      var useJS = (typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) !== 'object' || this.decoderConfig.type === 'js';\n      var librariesPending = [];\n\n      if (useJS) {\n        librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n      } else {\n        librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n        librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n      }\n\n      this.decoderPending = Promise.all(librariesPending).then(function (libraries) {\n        var jsContent = libraries[0];\n\n        if (!useJS) {\n          _this4.decoderConfig.wasmBinary = libraries[1];\n        }\n\n        var fn = DRACOWorker.toString();\n        var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        _this4.workerSourceURL = URL.createObjectURL(new Blob([body]));\n      });\n      return this.decoderPending;\n    }\n  }, {\n    key: \"_getWorker\",\n    value: function _getWorker(taskID, taskCost) {\n      var _this5 = this;\n\n      return this._initDecoder().then(function () {\n        if (_this5.workerPool.length < _this5.workerLimit) {\n          var _worker2 = new Worker(_this5.workerSourceURL);\n\n          _worker2._callbacks = {};\n          _worker2._taskCosts = {};\n          _worker2._taskLoad = 0;\n\n          _worker2.postMessage({\n            type: 'init',\n            decoderConfig: _this5.decoderConfig\n          });\n\n          _worker2.onmessage = function (e) {\n            var message = e.data;\n\n            switch (message.type) {\n              case 'decode':\n                _worker2._callbacks[message.id].resolve(message);\n\n                break;\n\n              case 'error':\n                _worker2._callbacks[message.id].reject(message);\n\n                break;\n\n              default:\n                console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n            }\n          };\n\n          _this5.workerPool.push(_worker2);\n        } else {\n          _this5.workerPool.sort(function (a, b) {\n            return a._taskLoad > b._taskLoad ? -1 : 1;\n          });\n        }\n\n        var worker = _this5.workerPool[_this5.workerPool.length - 1];\n        worker._taskCosts[taskID] = taskCost;\n        worker._taskLoad += taskCost;\n        return worker;\n      });\n    }\n  }, {\n    key: \"_releaseTask\",\n    value: function _releaseTask(worker, taskID) {\n      worker._taskLoad -= worker._taskCosts[taskID];\n      delete worker._callbacks[taskID];\n      delete worker._taskCosts[taskID];\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      console.log('Task load: ', this.workerPool.map(function (worker) {\n        return worker._taskLoad;\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.workerPool.length; ++i) {\n        this.workerPool[i].terminate();\n      }\n\n      this.workerPool.length = 0;\n      return this;\n    }\n  }]);\n\n  return DRACOLoader;\n}(_three.Loader);\n/* WEB WORKER */\n\n\nexports.DRACOLoader = DRACOLoader;\n\nfunction DRACOWorker() {\n  var decoderConfig;\n  var decoderPending;\n\n  onmessage = function onmessage(e) {\n    var message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/\n        ) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n\n      case 'decode':\n        var buffer = message.buffer;\n        var taskConfig = message.taskConfig;\n        decoderPending.then(function (module) {\n          var draco = module.draco;\n          var decoder = new draco.Decoder();\n          var decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            var buffers = geometry.attributes.map(function (attr) {\n              return attr.array.buffer;\n            });\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry: geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    var attributeIDs = taskConfig.attributeIDs;\n    var attributeTypes = taskConfig.attributeTypes;\n    var dracoGeometry;\n    var decodingStatus;\n    var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n\n    var geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (var attributeName in attributeIDs) {\n      var attributeType = self[attributeTypes[attributeName]];\n      var attribute = void 0;\n      var attributeID = void 0; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    var numFaces = dracoGeometry.num_faces();\n    var numIndices = numFaces * 3;\n    var byteLength = numIndices * 4;\n\n    var ptr = draco._malloc(byteLength);\n\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n\n    draco._free(ptr);\n\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    var numComponents = attribute.num_components();\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    var dataType = getDracoDataType(draco, attributeType);\n\n    var ptr = draco._malloc(byteLength);\n\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n\n      case Int8Array:\n        return draco.DT_INT8;\n\n      case Int16Array:\n        return draco.DT_INT16;\n\n      case Int32Array:\n        return draco.DT_INT32;\n\n      case Uint8Array:\n        return draco.DT_UINT8;\n\n      case Uint16Array:\n        return draco.DT_UINT16;\n\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["onModuleLoaded","promise","resolve","index","itemSize","prototype","wasmBinary","DRACOLoader","_taskCosts","key","workerPool","__esModule","workerSourceURL","error","id","normal","decoderConfig","buffer","position","taskConfig","name","configurable","useUniqueIDs","value","draco","geometry","enumerable","decoderPath","workerNextTaskID","_taskLoad","writable","_callbacks","defaultAttributeIDs","attributeTypes","length","uv","attributes","attributeIDs","type","decoderBinary","decoderPending","__proto__","reject","defaultAttributeTypes","workerLimit","color","array","onmessage","constructor"]],"~:compiled-at",1630917515933,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$loaders$DRACOLoader.js\",\n\"lineCount\":23,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/loaders/DRACOLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$loaders$DRACOLoader\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.DRACOLoader = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nvar _taskCache = new WeakMap();\\n\\nvar DRACOLoader =\\n/*#__PURE__*/\\nfunction (_Loader) {\\n  _inherits(DRACOLoader, _Loader);\\n\\n  function DRACOLoader(manager) {\\n    var _this;\\n\\n    _classCallCheck(this, DRACOLoader);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DRACOLoader).call(this, manager));\\n    _this.decoderPath = '';\\n    _this.decoderConfig = {};\\n    _this.decoderBinary = null;\\n    _this.decoderPending = null;\\n    _this.workerLimit = 4;\\n    _this.workerPool = [];\\n    _this.workerNextTaskID = 1;\\n    _this.workerSourceURL = '';\\n    _this.defaultAttributeIDs = {\\n      position: 'POSITION',\\n      normal: 'NORMAL',\\n      color: 'COLOR',\\n      uv: 'TEX_COORD'\\n    };\\n    _this.defaultAttributeTypes = {\\n      position: 'Float32Array',\\n      normal: 'Float32Array',\\n      color: 'Float32Array',\\n      uv: 'Float32Array'\\n    };\\n    return _this;\\n  }\\n\\n  _createClass(DRACOLoader, [{\\n    key: \\\"setDecoderPath\\\",\\n    value: function setDecoderPath(path) {\\n      this.decoderPath = path;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"setDecoderConfig\\\",\\n    value: function setDecoderConfig(config) {\\n      this.decoderConfig = config;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"setWorkerLimit\\\",\\n    value: function setWorkerLimit(workerLimit) {\\n      this.workerLimit = workerLimit;\\n      return this;\\n    }\\n  }, {\\n    key: \\\"load\\\",\\n    value: function load(url, onLoad, onProgress, onError) {\\n      var _this2 = this;\\n\\n      var loader = new _three.FileLoader(this.manager);\\n      loader.setPath(this.path);\\n      loader.setResponseType('arraybuffer');\\n      loader.setRequestHeader(this.requestHeader);\\n      loader.setWithCredentials(this.withCredentials);\\n      loader.load(url, function (buffer) {\\n        var taskConfig = {\\n          attributeIDs: _this2.defaultAttributeIDs,\\n          attributeTypes: _this2.defaultAttributeTypes,\\n          useUniqueIDs: false\\n        };\\n\\n        _this2.decodeGeometry(buffer, taskConfig).then(onLoad)[\\\"catch\\\"](onError);\\n      }, onProgress, onError);\\n    }\\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\\n\\n  }, {\\n    key: \\\"decodeDracoFile\\\",\\n    value: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\\n      var taskConfig = {\\n        attributeIDs: attributeIDs || this.defaultAttributeIDs,\\n        attributeTypes: attributeTypes || this.defaultAttributeTypes,\\n        useUniqueIDs: !!attributeIDs\\n      };\\n      this.decodeGeometry(buffer, taskConfig).then(callback);\\n    }\\n  }, {\\n    key: \\\"decodeGeometry\\\",\\n    value: function decodeGeometry(buffer, taskConfig) {\\n      var _this3 = this;\\n\\n      // TODO: For backward-compatibility, support 'attributeTypes' objects containing\\n      // references (rather than names) to typed array constructors. These must be\\n      // serialized before sending them to the worker.\\n      for (var attribute in taskConfig.attributeTypes) {\\n        var type = taskConfig.attributeTypes[attribute];\\n\\n        if (type.BYTES_PER_ELEMENT !== undefined) {\\n          taskConfig.attributeTypes[attribute] = type.name;\\n        }\\n      } //\\n\\n\\n      var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\\n      // again from this thread.\\n\\n      if (_taskCache.has(buffer)) {\\n        var cachedTask = _taskCache.get(buffer);\\n\\n        if (cachedTask.key === taskKey) {\\n          return cachedTask.promise;\\n        } else if (buffer.byteLength === 0) {\\n          // Technically, it would be possible to wait for the previous task to complete,\\n          // transfer the buffer back, and decode again with the second configuration. That\\n          // is complex, and I don't know of any reason to decode a Draco buffer twice in\\n          // different ways, so this is left unimplemented.\\n          throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\\n        }\\n      } //\\n\\n\\n      var worker;\\n      var taskID = this.workerNextTaskID++;\\n      var taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\\n      // when the task completes.\\n\\n      var geometryPending = this._getWorker(taskID, taskCost).then(function (_worker) {\\n        worker = _worker;\\n        return new Promise(function (resolve, reject) {\\n          worker._callbacks[taskID] = {\\n            resolve: resolve,\\n            reject: reject\\n          };\\n          worker.postMessage({\\n            type: 'decode',\\n            id: taskID,\\n            taskConfig: taskConfig,\\n            buffer: buffer\\n          }, [buffer]); // this.debug();\\n        });\\n      }).then(function (message) {\\n        return _this3._createGeometry(message.geometry);\\n      }); // Remove task from the task list.\\n      // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\\n\\n\\n      geometryPending[\\\"catch\\\"](function () {\\n        return true;\\n      }).then(function () {\\n        if (worker && taskID) {\\n          _this3._releaseTask(worker, taskID); // this.debug();\\n\\n        }\\n      }); // Cache the task result.\\n\\n      _taskCache.set(buffer, {\\n        key: taskKey,\\n        promise: geometryPending\\n      });\\n\\n      return geometryPending;\\n    }\\n  }, {\\n    key: \\\"_createGeometry\\\",\\n    value: function _createGeometry(geometryData) {\\n      var geometry = new _three.BufferGeometry();\\n\\n      if (geometryData.index) {\\n        geometry.setIndex(new _three.BufferAttribute(geometryData.index.array, 1));\\n      }\\n\\n      for (var i = 0; i < geometryData.attributes.length; i++) {\\n        var attribute = geometryData.attributes[i];\\n        var name = attribute.name;\\n        var array = attribute.array;\\n        var itemSize = attribute.itemSize;\\n        geometry.setAttribute(name, new _three.BufferAttribute(array, itemSize));\\n      }\\n\\n      return geometry;\\n    }\\n  }, {\\n    key: \\\"_loadLibrary\\\",\\n    value: function _loadLibrary(url, responseType) {\\n      var loader = new _three.FileLoader(this.manager);\\n      loader.setPath(this.decoderPath);\\n      loader.setResponseType(responseType);\\n      loader.setWithCredentials(this.withCredentials);\\n      return new Promise(function (resolve, reject) {\\n        loader.load(url, resolve, undefined, reject);\\n      });\\n    }\\n  }, {\\n    key: \\\"preload\\\",\\n    value: function preload() {\\n      this._initDecoder();\\n\\n      return this;\\n    }\\n  }, {\\n    key: \\\"_initDecoder\\\",\\n    value: function _initDecoder() {\\n      var _this4 = this;\\n\\n      if (this.decoderPending) return this.decoderPending;\\n      var useJS = (typeof WebAssembly === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(WebAssembly)) !== 'object' || this.decoderConfig.type === 'js';\\n      var librariesPending = [];\\n\\n      if (useJS) {\\n        librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\\n      } else {\\n        librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\\n        librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\\n      }\\n\\n      this.decoderPending = Promise.all(librariesPending).then(function (libraries) {\\n        var jsContent = libraries[0];\\n\\n        if (!useJS) {\\n          _this4.decoderConfig.wasmBinary = libraries[1];\\n        }\\n\\n        var fn = DRACOWorker.toString();\\n        var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\\\n');\\n        _this4.workerSourceURL = URL.createObjectURL(new Blob([body]));\\n      });\\n      return this.decoderPending;\\n    }\\n  }, {\\n    key: \\\"_getWorker\\\",\\n    value: function _getWorker(taskID, taskCost) {\\n      var _this5 = this;\\n\\n      return this._initDecoder().then(function () {\\n        if (_this5.workerPool.length < _this5.workerLimit) {\\n          var _worker2 = new Worker(_this5.workerSourceURL);\\n\\n          _worker2._callbacks = {};\\n          _worker2._taskCosts = {};\\n          _worker2._taskLoad = 0;\\n\\n          _worker2.postMessage({\\n            type: 'init',\\n            decoderConfig: _this5.decoderConfig\\n          });\\n\\n          _worker2.onmessage = function (e) {\\n            var message = e.data;\\n\\n            switch (message.type) {\\n              case 'decode':\\n                _worker2._callbacks[message.id].resolve(message);\\n\\n                break;\\n\\n              case 'error':\\n                _worker2._callbacks[message.id].reject(message);\\n\\n                break;\\n\\n              default:\\n                console.error('THREE.DRACOLoader: Unexpected message, \\\"' + message.type + '\\\"');\\n            }\\n          };\\n\\n          _this5.workerPool.push(_worker2);\\n        } else {\\n          _this5.workerPool.sort(function (a, b) {\\n            return a._taskLoad > b._taskLoad ? -1 : 1;\\n          });\\n        }\\n\\n        var worker = _this5.workerPool[_this5.workerPool.length - 1];\\n        worker._taskCosts[taskID] = taskCost;\\n        worker._taskLoad += taskCost;\\n        return worker;\\n      });\\n    }\\n  }, {\\n    key: \\\"_releaseTask\\\",\\n    value: function _releaseTask(worker, taskID) {\\n      worker._taskLoad -= worker._taskCosts[taskID];\\n      delete worker._callbacks[taskID];\\n      delete worker._taskCosts[taskID];\\n    }\\n  }, {\\n    key: \\\"debug\\\",\\n    value: function debug() {\\n      console.log('Task load: ', this.workerPool.map(function (worker) {\\n        return worker._taskLoad;\\n      }));\\n    }\\n  }, {\\n    key: \\\"dispose\\\",\\n    value: function dispose() {\\n      for (var i = 0; i < this.workerPool.length; ++i) {\\n        this.workerPool[i].terminate();\\n      }\\n\\n      this.workerPool.length = 0;\\n      return this;\\n    }\\n  }]);\\n\\n  return DRACOLoader;\\n}(_three.Loader);\\n/* WEB WORKER */\\n\\n\\nexports.DRACOLoader = DRACOLoader;\\n\\nfunction DRACOWorker() {\\n  var decoderConfig;\\n  var decoderPending;\\n\\n  onmessage = function onmessage(e) {\\n    var message = e.data;\\n\\n    switch (message.type) {\\n      case 'init':\\n        decoderConfig = message.decoderConfig;\\n        decoderPending = new Promise(function (resolve\\n        /*, reject*/\\n        ) {\\n          decoderConfig.onModuleLoaded = function (draco) {\\n            // Module is Promise-like. Wrap before resolving to avoid loop.\\n            resolve({\\n              draco: draco\\n            });\\n          };\\n\\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\\n        });\\n        break;\\n\\n      case 'decode':\\n        var buffer = message.buffer;\\n        var taskConfig = message.taskConfig;\\n        decoderPending.then(function (module) {\\n          var draco = module.draco;\\n          var decoder = new draco.Decoder();\\n          var decoderBuffer = new draco.DecoderBuffer();\\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\\n\\n          try {\\n            var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\\n            var buffers = geometry.attributes.map(function (attr) {\\n              return attr.array.buffer;\\n            });\\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\\n            self.postMessage({\\n              type: 'decode',\\n              id: message.id,\\n              geometry: geometry\\n            }, buffers);\\n          } catch (error) {\\n            console.error(error);\\n            self.postMessage({\\n              type: 'error',\\n              id: message.id,\\n              error: error.message\\n            });\\n          } finally {\\n            draco.destroy(decoderBuffer);\\n            draco.destroy(decoder);\\n          }\\n        });\\n        break;\\n    }\\n  };\\n\\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\\n    var attributeIDs = taskConfig.attributeIDs;\\n    var attributeTypes = taskConfig.attributeTypes;\\n    var dracoGeometry;\\n    var decodingStatus;\\n    var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\\n\\n    if (geometryType === draco.TRIANGULAR_MESH) {\\n      dracoGeometry = new draco.Mesh();\\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\\n    } else if (geometryType === draco.POINT_CLOUD) {\\n      dracoGeometry = new draco.PointCloud();\\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\\n    } else {\\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\\n    }\\n\\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\\n    }\\n\\n    var geometry = {\\n      index: null,\\n      attributes: []\\n    }; // Gather all vertex attributes.\\n\\n    for (var attributeName in attributeIDs) {\\n      var attributeType = self[attributeTypes[attributeName]];\\n      var attribute = void 0;\\n      var attributeID = void 0; // A Draco file may be created with default vertex attributes, whose attribute IDs\\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\\n      // a Draco file may contain a custom set of attributes, identified by known unique\\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\\n\\n      if (taskConfig.useUniqueIDs) {\\n        attributeID = attributeIDs[attributeName];\\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\\n      } else {\\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\\n        if (attributeID === -1) continue;\\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\\n      }\\n\\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\\n    } // Add index.\\n\\n\\n    if (geometryType === draco.TRIANGULAR_MESH) {\\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\\n    }\\n\\n    draco.destroy(dracoGeometry);\\n    return geometry;\\n  }\\n\\n  function decodeIndex(draco, decoder, dracoGeometry) {\\n    var numFaces = dracoGeometry.num_faces();\\n    var numIndices = numFaces * 3;\\n    var byteLength = numIndices * 4;\\n\\n    var ptr = draco._malloc(byteLength);\\n\\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\\n    var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\\n\\n    draco._free(ptr);\\n\\n    return {\\n      array: index,\\n      itemSize: 1\\n    };\\n  }\\n\\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\\n    var numComponents = attribute.num_components();\\n    var numPoints = dracoGeometry.num_points();\\n    var numValues = numPoints * numComponents;\\n    var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\\n    var dataType = getDracoDataType(draco, attributeType);\\n\\n    var ptr = draco._malloc(byteLength);\\n\\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\\n    var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\\n\\n    draco._free(ptr);\\n\\n    return {\\n      name: attributeName,\\n      array: array,\\n      itemSize: numComponents\\n    };\\n  }\\n\\n  function getDracoDataType(draco, attributeType) {\\n    switch (attributeType) {\\n      case Float32Array:\\n        return draco.DT_FLOAT32;\\n\\n      case Int8Array:\\n        return draco.DT_INT8;\\n\\n      case Int16Array:\\n        return draco.DT_INT16;\\n\\n      case Int32Array:\\n        return draco.DT_INT32;\\n\\n      case Uint8Array:\\n        return draco.DT_UINT8;\\n\\n      case Uint16Array:\\n        return draco.DT_UINT16;\\n\\n      case Uint32Array:\\n        return draco.DT_UINT32;\\n    }\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_defineProperties\",\"target\",\"props\",\"i\",\"length\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"Object\",\"defineProperty\",\"key\",\"_createClass\",\"Constructor\",\"protoProps\",\"staticProps\",\"_getPrototypeOf\",\"o\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"_setPrototypeOf\",\"p\",\"DRACOWorker\",\"decodeGeometry\",\"draco\",\"decoder\",\"decoderBuffer\",\"taskConfig\",\"attributeIDs\",\"attributeTypes\",\"geometryType\",\"GetEncodedGeometryType\",\"TRIANGULAR_MESH\",\"dracoGeometry\",\"Mesh\",\"decodingStatus\",\"DecodeBufferToMesh\",\"POINT_CLOUD\",\"PointCloud\",\"DecodeBufferToPointCloud\",\"Error\",\"ok\",\"ptr\",\"error_msg\",\"geometry\",\"index\",\"attributes\",\"attributeName\",\"attributeType\",\"self\",\"useUniqueIDs\",\"attributeID\",\"attribute\",\"GetAttributeByUniqueId\",\"GetAttributeId\",\"GetAttribute\",\"push\",\"numComponents\",\"num_components\",\"numValues\",\"num_points\",\"numPoints\",\"byteLength\",\"BYTES_PER_ELEMENT\",\"dataType\",\"getDracoDataType\",\"_malloc\",\"GetAttributeDataArrayForAllPoints\",\"array\",\"slice\",\"HEAPF32\",\"buffer\",\"_free\",\"name\",\"itemSize\",\"numIndices\",\"num_faces\",\"numFaces\",\"GetTrianglesUInt32Array\",\"Uint32Array\",\"destroy\",\"Float32Array\",\"DT_FLOAT32\",\"Int8Array\",\"DT_INT8\",\"Int16Array\",\"DT_INT16\",\"Int32Array\",\"DT_INT32\",\"Uint8Array\",\"DT_UINT8\",\"Uint16Array\",\"DT_UINT16\",\"DT_UINT32\",\"decoderConfig\",\"decoderPending\",\"onmessage\",\"e\",\"message\",\"data\",\"type\",\"Promise\",\"resolve\",\"onModuleLoaded\",\"decoderConfig.onModuleLoaded\",\"DracoDecoderModule\",\"then\",\"Decoder\",\"DecoderBuffer\",\"Init\",\"buffers\",\"map\",\"attr\",\"postMessage\",\"id\",\"error\",\"console\",\"DRACOLoader\",\"_three\",\"_taskCache\",\"WeakMap\",\"_Loader\",\"manager\",\"instance\",\"call\",\"ReferenceError\",\"_this\",\"decoderPath\",\"decoderBinary\",\"workerLimit\",\"workerPool\",\"workerNextTaskID\",\"workerSourceURL\",\"defaultAttributeIDs\",\"position\",\"normal\",\"color\",\"uv\",\"defaultAttributeTypes\",\"setDecoderPath\",\"path\",\"setDecoderConfig\",\"config\",\"setWorkerLimit\",\"load\",\"url\",\"onLoad\",\"onProgress\",\"onError\",\"_this2\",\"loader\",\"FileLoader\",\"setPath\",\"setResponseType\",\"setRequestHeader\",\"requestHeader\",\"setWithCredentials\",\"withCredentials\",\"decodeDracoFile\",\"callback\",\"_this3\",\"undefined\",\"taskKey\",\"JSON\",\"stringify\",\"has\",\"cachedTask\",\"get\",\"promise\",\"worker\",\"taskID\",\"geometryPending\",\"_getWorker\",\"_worker\",\"reject\",\"_callbacks\",\"_createGeometry\",\"_releaseTask\",\"set\",\"geometryData\",\"BufferGeometry\",\"setIndex\",\"BufferAttribute\",\"setAttribute\",\"_loadLibrary\",\"responseType\",\"preload\",\"_initDecoder\",\"_this4\",\"useJS\",\"WebAssembly\",\"librariesPending\",\"all\",\"libraries\",\"jsContent\",\"wasmBinary\",\"fn\",\"toString\",\"body\",\"substring\",\"indexOf\",\"lastIndexOf\",\"join\",\"URL\",\"createObjectURL\",\"Blob\",\"taskCost\",\"_this5\",\"_worker2\",\"Worker\",\"_taskCosts\",\"_taskLoad\",\"_worker2.onmessage\",\"sort\",\"a\",\"b\",\"debug\",\"log\",\"dispose\",\"terminate\",\"Loader\"]\n}\n"]