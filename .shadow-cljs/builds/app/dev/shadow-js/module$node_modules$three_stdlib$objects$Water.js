["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/three-stdlib/objects/Water.js"],"~:js","shadow$provide.module$node_modules$three_stdlib$objects$Water=function(global,require,module,exports){function _typeof(obj$jscomp$0){_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};return _typeof(obj$jscomp$0)}function _possibleConstructorReturn(self,call){return!call||\"object\"!==_typeof(call)&&\"function\"!==typeof call?_assertThisInitialized(self):\ncall}function _getPrototypeOf(o$jscomp$0){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)};return _getPrototypeOf(o$jscomp$0)}function _assertThisInitialized(self){if(void 0===self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return self}function _inherits(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function\");\nsubClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:!0,configurable:!0}});superClass&&_setPrototypeOf(subClass,superClass)}function _setPrototypeOf(o$jscomp$0,p$jscomp$0){_setPrototypeOf=Object.setPrototypeOf||function(o,p){o.__proto__=p;return o};return _setPrototypeOf(o$jscomp$0,p$jscomp$0)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.Water=void 0;var _three=require(\"module$node_modules$three$build$three_module\");global=function(_Mesh){function Water(geometry){var options=\n1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!(this instanceof Water))throw new TypeError(\"Cannot call a class as a function\");var _this=_possibleConstructorReturn(this,_getPrototypeOf(Water).call(this,geometry));var scope=_assertThisInitialized(_this),textureWidth=void 0!==options.textureWidth?options.textureWidth:512,textureHeight=void 0!==options.textureHeight?options.textureHeight:512,clipBias=void 0!==options.clipBias?options.clipBias:0,alpha=void 0!==options.alpha?options.alpha:\n1,time=void 0!==options.time?options.time:0,normalSampler=void 0!==options.waterNormals?options.waterNormals:null,sunDirection=void 0!==options.sunDirection?options.sunDirection:new _three.Vector3(.70707,.70707,0),sunColor=new _three.Color(void 0!==options.sunColor?options.sunColor:16777215),waterColor=new _three.Color(void 0!==options.waterColor?options.waterColor:8355711),eye=void 0!==options.eye?options.eye:new _three.Vector3(0,0,0),distortionScale=void 0!==options.distortionScale?options.distortionScale:\n20,side=void 0!==options.side?options.side:_three.FrontSide,fog=void 0!==options.fog?options.fog:!1;options=void 0!==options.format?options.format:_three.RGBFormat;var mirrorPlane=new _three.Plane,normal=new _three.Vector3,mirrorWorldPosition=new _three.Vector3,cameraWorldPosition=new _three.Vector3,rotationMatrix=new _three.Matrix4,lookAtPosition=new _three.Vector3(0,0,-1),clipPlane=new _three.Vector4,view=new _three.Vector3,target=new _three.Vector3,q=new _three.Vector4,textureMatrix=new _three.Matrix4,\nmirrorCamera=new _three.PerspectiveCamera,renderTarget=new _three.WebGLRenderTarget(textureWidth,textureHeight,{minFilter:_three.LinearFilter,magFilter:_three.LinearFilter,format:options});_three.MathUtils.isPowerOfTwo(textureWidth)&&_three.MathUtils.isPowerOfTwo(textureHeight)||(renderTarget.texture.generateMipmaps=!1);textureWidth=_three.UniformsUtils.merge([_three.UniformsLib.fog,_three.UniformsLib.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},\ndistortionScale:{value:20},textureMatrix:{value:new _three.Matrix4},sunColor:{value:new _three.Color(8355711)},sunDirection:{value:new _three.Vector3(.70707,.70707,0)},eye:{value:new _three.Vector3},waterColor:{value:new _three.Color(5592405)}}]);side=new _three.ShaderMaterial({fragmentShader:\"\\n\\t\\t\\t\\tuniform sampler2D mirrorSampler;\\n\\t\\t\\t\\tuniform float alpha;\\n\\t\\t\\t\\tuniform float time;\\n\\t\\t\\t\\tuniform float size;\\n\\t\\t\\t\\tuniform float distortionScale;\\n\\t\\t\\t\\tuniform sampler2D normalSampler;\\n\\t\\t\\t\\tuniform vec3 sunColor;\\n\\t\\t\\t\\tuniform vec3 sunDirection;\\n\\t\\t\\t\\tuniform vec3 eye;\\n\\t\\t\\t\\tuniform vec3 waterColor;\\n\\n\\t\\t\\t\\tvarying vec4 mirrorCoord;\\n\\t\\t\\t\\tvarying vec4 worldPosition;\\n\\n\\t\\t\\t\\tvec4 getNoise( vec2 uv ) {\\n\\t\\t\\t\\t\\tvec2 uv0 \\x3d ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\\n\\t\\t\\t\\t\\tvec2 uv1 \\x3d uv / 107.0-vec2( time / -19.0, time / 31.0 );\\n\\t\\t\\t\\t\\tvec2 uv2 \\x3d uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\\n\\t\\t\\t\\t\\tvec2 uv3 \\x3d uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\\n\\t\\t\\t\\t\\tvec4 noise \\x3d texture2D( normalSampler, uv0 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv1 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv2 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv3 );\\n\\t\\t\\t\\t\\treturn noise * 0.5 - 1.0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\\n\\t\\t\\t\\t\\tvec3 reflection \\x3d normalize( reflect( -sunDirection, surfaceNormal ) );\\n\\t\\t\\t\\t\\tfloat direction \\x3d max( 0.0, dot( eyeDirection, reflection ) );\\n\\t\\t\\t\\t\\tspecularColor +\\x3d pow( direction, shiny ) * sunColor * spec;\\n\\t\\t\\t\\t\\tdiffuseColor +\\x3d max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t#include \\x3ccommon\\x3e\\n\\t\\t\\t\\t#include \\x3cpacking\\x3e\\n\\t\\t\\t\\t#include \\x3cbsdfs\\x3e\\n\\t\\t\\t\\t#include \\x3cfog_pars_fragment\\x3e\\n\\t\\t\\t\\t#include \\x3clogdepthbuf_pars_fragment\\x3e\\n\\t\\t\\t\\t#include \\x3clights_pars_begin\\x3e\\n\\t\\t\\t\\t#include \\x3cshadowmap_pars_fragment\\x3e\\n\\t\\t\\t\\t#include \\x3cshadowmask_pars_fragment\\x3e\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\t#include \\x3clogdepthbuf_fragment\\x3e\\n\\t\\t\\t\\t\\tvec4 noise \\x3d getNoise( worldPosition.xz * size );\\n\\t\\t\\t\\t\\tvec3 surfaceNormal \\x3d normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\\n\\n\\t\\t\\t\\t\\tvec3 diffuseLight \\x3d vec3(0.0);\\n\\t\\t\\t\\t\\tvec3 specularLight \\x3d vec3(0.0);\\n\\n\\t\\t\\t\\t\\tvec3 worldToEye \\x3d eye-worldPosition.xyz;\\n\\t\\t\\t\\t\\tvec3 eyeDirection \\x3d normalize( worldToEye );\\n\\t\\t\\t\\t\\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\\n\\n\\t\\t\\t\\t\\tfloat distance \\x3d length(worldToEye);\\n\\n\\t\\t\\t\\t\\tvec2 distortion \\x3d surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\\n\\t\\t\\t\\t\\tvec3 reflectionSample \\x3d vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\\n\\n\\t\\t\\t\\t\\tfloat theta \\x3d max( dot( eyeDirection, surfaceNormal ), 0.0 );\\n\\t\\t\\t\\t\\tfloat rf0 \\x3d 0.3;\\n\\t\\t\\t\\t\\tfloat reflectance \\x3d rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\\n\\t\\t\\t\\t\\tvec3 scatter \\x3d max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\\n\\t\\t\\t\\t\\tvec3 albedo \\x3d mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\\n\\t\\t\\t\\t\\tvec3 outgoingLight \\x3d albedo;\\n\\t\\t\\t\\t\\tgl_FragColor \\x3d vec4( outgoingLight, alpha );\\n\\n\\t\\t\\t\\t\\t#include \\x3ctonemapping_fragment\\x3e\\n\\t\\t\\t\\t\\t#include \\x3cfog_fragment\\x3e\\n\\t\\t\\t\\t}\",\nvertexShader:\"\\n\\t\\t\\t\\tuniform mat4 textureMatrix;\\n\\t\\t\\t\\tuniform float time;\\n\\n\\t\\t\\t\\tvarying vec4 mirrorCoord;\\n\\t\\t\\t\\tvarying vec4 worldPosition;\\n\\n\\t\\t\\t\\t#include \\x3ccommon\\x3e\\n\\t\\t\\t\\t#include \\x3cfog_pars_vertex\\x3e\\n\\t\\t\\t\\t#include \\x3cshadowmap_pars_vertex\\x3e\\n\\t\\t\\t\\t#include \\x3clogdepthbuf_pars_vertex\\x3e\\n\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tmirrorCoord \\x3d modelMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t\\tworldPosition \\x3d mirrorCoord.xyzw;\\n\\t\\t\\t\\t\\tmirrorCoord \\x3d textureMatrix * mirrorCoord;\\n\\t\\t\\t\\t\\tvec4 mvPosition \\x3d  modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t\\tgl_Position \\x3d projectionMatrix * mvPosition;\\n\\n\\t\\t\\t\\t#include \\x3cbeginnormal_vertex\\x3e\\n\\t\\t\\t\\t#include \\x3cdefaultnormal_vertex\\x3e\\n\\t\\t\\t\\t#include \\x3clogdepthbuf_vertex\\x3e\\n\\t\\t\\t\\t#include \\x3cfog_vertex\\x3e\\n\\t\\t\\t\\t#include \\x3cshadowmap_vertex\\x3e\\n\\t\\t\\t}\",\nuniforms:_three.UniformsUtils.clone(textureWidth),lights:!0,side,fog});side.uniforms.mirrorSampler.value=renderTarget.texture;side.uniforms.textureMatrix.value=textureMatrix;side.uniforms.alpha.value=alpha;side.uniforms.time.value=time;side.uniforms.normalSampler.value=normalSampler;side.uniforms.sunColor.value=sunColor;side.uniforms.waterColor.value=waterColor;side.uniforms.sunDirection.value=sunDirection;side.uniforms.distortionScale.value=distortionScale;side.uniforms.eye.value=eye;scope.material=\nside;scope.onBeforeRender=function(renderer,scene,camera){mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);rotationMatrix.extractRotation(scope.matrixWorld);normal.set(0,0,1);normal.applyMatrix4(rotationMatrix);view.subVectors(mirrorWorldPosition,cameraWorldPosition);if(!(0<view.dot(normal))){view.reflect(normal).negate();view.add(mirrorWorldPosition);rotationMatrix.extractRotation(camera.matrixWorld);lookAtPosition.set(0,0,\n-1);lookAtPosition.applyMatrix4(rotationMatrix);lookAtPosition.add(cameraWorldPosition);target.subVectors(mirrorWorldPosition,lookAtPosition);target.reflect(normal).negate();target.add(mirrorWorldPosition);mirrorCamera.position.copy(view);mirrorCamera.up.set(0,1,0);mirrorCamera.up.applyMatrix4(rotationMatrix);mirrorCamera.up.reflect(normal);mirrorCamera.lookAt(target);mirrorCamera.far=camera.far;mirrorCamera.updateMatrixWorld();mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);textureMatrix.set(.5,\n0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);textureMatrix.multiply(mirrorCamera.projectionMatrix);textureMatrix.multiply(mirrorCamera.matrixWorldInverse);mirrorPlane.setFromNormalAndCoplanarPoint(normal,mirrorWorldPosition);mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);clipPlane.set(mirrorPlane.normal.x,mirrorPlane.normal.y,mirrorPlane.normal.z,mirrorPlane.constant);var projectionMatrix=mirrorCamera.projectionMatrix;q.x=(Math.sign(clipPlane.x)+projectionMatrix.elements[8])/projectionMatrix.elements[0];\nq.y=(Math.sign(clipPlane.y)+projectionMatrix.elements[9])/projectionMatrix.elements[5];q.z=-1;q.w=(1+projectionMatrix.elements[10])/projectionMatrix.elements[14];clipPlane.multiplyScalar(2/clipPlane.dot(q));projectionMatrix.elements[2]=clipPlane.x;projectionMatrix.elements[6]=clipPlane.y;projectionMatrix.elements[10]=clipPlane.z+1-clipBias;projectionMatrix.elements[14]=clipPlane.w;eye.setFromMatrixPosition(camera.matrixWorld);projectionMatrix=renderer.getRenderTarget();var currentXrEnabled=renderer.xr.enabled,\ncurrentShadowAutoUpdate=renderer.shadowMap.autoUpdate;scope.visible=!1;renderer.xr.enabled=!1;renderer.shadowMap.autoUpdate=!1;renderer.setRenderTarget(renderTarget);renderer.state.buffers.depth.setMask(!0);!1===renderer.autoClear&&renderer.clear();renderer.render(scene,mirrorCamera);scope.visible=!0;renderer.xr.enabled=currentXrEnabled;renderer.shadowMap.autoUpdate=currentShadowAutoUpdate;renderer.setRenderTarget(projectionMatrix);scene=camera.viewport;void 0!==scene&&renderer.state.viewport(scene)}};\nreturn _this}_inherits(Water,_Mesh);return Water}(_three.Mesh);exports.Water=global;global.prototype.isWater=!0}","~:source","shadow$provide[\"module$node_modules$three_stdlib$objects$Water\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Water = void 0;\n\nvar _three = require(\"three\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Work based on :\n * http://slayvin.net : Flat mirror for three.js\n * http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\nvar Water =\n/*#__PURE__*/\nfunction (_Mesh) {\n  _inherits(Water, _Mesh);\n\n  function Water(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Water);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Water).call(this, geometry));\n\n    var scope = _assertThisInitialized(_this);\n\n    var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n    var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n    var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n    var alpha = options.alpha !== undefined ? options.alpha : 1.0;\n    var time = options.time !== undefined ? options.time : 0.0;\n    var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n    var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new _three.Vector3(0.70707, 0.70707, 0.0);\n    var sunColor = new _three.Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\n    var waterColor = new _three.Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\n    var eye = options.eye !== undefined ? options.eye : new _three.Vector3(0, 0, 0);\n    var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n    var side = options.side !== undefined ? options.side : _three.FrontSide;\n    var fog = options.fog !== undefined ? options.fog : false;\n    var format = options.format !== undefined ? options.format : _three.RGBFormat; //\n\n    var mirrorPlane = new _three.Plane();\n    var normal = new _three.Vector3();\n    var mirrorWorldPosition = new _three.Vector3();\n    var cameraWorldPosition = new _three.Vector3();\n    var rotationMatrix = new _three.Matrix4();\n    var lookAtPosition = new _three.Vector3(0, 0, -1);\n    var clipPlane = new _three.Vector4();\n    var view = new _three.Vector3();\n    var target = new _three.Vector3();\n    var q = new _three.Vector4();\n    var textureMatrix = new _three.Matrix4();\n    var mirrorCamera = new _three.PerspectiveCamera();\n    var parameters = {\n      minFilter: _three.LinearFilter,\n      magFilter: _three.LinearFilter,\n      format: format\n    };\n    var renderTarget = new _three.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n    if (!_three.MathUtils.isPowerOfTwo(textureWidth) || !_three.MathUtils.isPowerOfTwo(textureHeight)) {\n      renderTarget.texture.generateMipmaps = false;\n    }\n\n    var mirrorShader = {\n      uniforms: _three.UniformsUtils.merge([_three.UniformsLib['fog'], _three.UniformsLib['lights'], {\n        normalSampler: {\n          value: null\n        },\n        mirrorSampler: {\n          value: null\n        },\n        alpha: {\n          value: 1.0\n        },\n        time: {\n          value: 0.0\n        },\n        size: {\n          value: 1.0\n        },\n        distortionScale: {\n          value: 20.0\n        },\n        textureMatrix: {\n          value: new _three.Matrix4()\n        },\n        sunColor: {\n          value: new _three.Color(0x7f7f7f)\n        },\n        sunDirection: {\n          value: new _three.Vector3(0.70707, 0.70707, 0)\n        },\n        eye: {\n          value: new _three.Vector3()\n        },\n        waterColor: {\n          value: new _three.Color(0x555555)\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      \"\\n\\t\\t\\t\\tuniform mat4 textureMatrix;\\n\\t\\t\\t\\tuniform float time;\\n\\n\\t\\t\\t\\tvarying vec4 mirrorCoord;\\n\\t\\t\\t\\tvarying vec4 worldPosition;\\n\\n\\t\\t\\t\\t#include <common>\\n\\t\\t\\t\\t#include <fog_pars_vertex>\\n\\t\\t\\t\\t#include <shadowmap_pars_vertex>\\n\\t\\t\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t\\tworldPosition = mirrorCoord.xyzw;\\n\\t\\t\\t\\t\\tmirrorCoord = textureMatrix * mirrorCoord;\\n\\t\\t\\t\\t\\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t\\t\\t\\t#include <beginnormal_vertex>\\n\\t\\t\\t\\t#include <defaultnormal_vertex>\\n\\t\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t\\t#include <fog_vertex>\\n\\t\\t\\t\\t#include <shadowmap_vertex>\\n\\t\\t\\t}\",\n      fragmentShader:\n      /* glsl */\n      \"\\n\\t\\t\\t\\tuniform sampler2D mirrorSampler;\\n\\t\\t\\t\\tuniform float alpha;\\n\\t\\t\\t\\tuniform float time;\\n\\t\\t\\t\\tuniform float size;\\n\\t\\t\\t\\tuniform float distortionScale;\\n\\t\\t\\t\\tuniform sampler2D normalSampler;\\n\\t\\t\\t\\tuniform vec3 sunColor;\\n\\t\\t\\t\\tuniform vec3 sunDirection;\\n\\t\\t\\t\\tuniform vec3 eye;\\n\\t\\t\\t\\tuniform vec3 waterColor;\\n\\n\\t\\t\\t\\tvarying vec4 mirrorCoord;\\n\\t\\t\\t\\tvarying vec4 worldPosition;\\n\\n\\t\\t\\t\\tvec4 getNoise( vec2 uv ) {\\n\\t\\t\\t\\t\\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\\n\\t\\t\\t\\t\\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\\n\\t\\t\\t\\t\\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\\n\\t\\t\\t\\t\\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\\n\\t\\t\\t\\t\\tvec4 noise = texture2D( normalSampler, uv0 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv1 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv2 ) +\\n\\t\\t\\t\\t\\t\\ttexture2D( normalSampler, uv3 );\\n\\t\\t\\t\\t\\treturn noise * 0.5 - 1.0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\\n\\t\\t\\t\\t\\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\\n\\t\\t\\t\\t\\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\\n\\t\\t\\t\\t\\tspecularColor += pow( direction, shiny ) * sunColor * spec;\\n\\t\\t\\t\\t\\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t#include <common>\\n\\t\\t\\t\\t#include <packing>\\n\\t\\t\\t\\t#include <bsdfs>\\n\\t\\t\\t\\t#include <fog_pars_fragment>\\n\\t\\t\\t\\t#include <logdepthbuf_pars_fragment>\\n\\t\\t\\t\\t#include <lights_pars_begin>\\n\\t\\t\\t\\t#include <shadowmap_pars_fragment>\\n\\t\\t\\t\\t#include <shadowmask_pars_fragment>\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\t#include <logdepthbuf_fragment>\\n\\t\\t\\t\\t\\tvec4 noise = getNoise( worldPosition.xz * size );\\n\\t\\t\\t\\t\\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\\n\\n\\t\\t\\t\\t\\tvec3 diffuseLight = vec3(0.0);\\n\\t\\t\\t\\t\\tvec3 specularLight = vec3(0.0);\\n\\n\\t\\t\\t\\t\\tvec3 worldToEye = eye-worldPosition.xyz;\\n\\t\\t\\t\\t\\tvec3 eyeDirection = normalize( worldToEye );\\n\\t\\t\\t\\t\\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\\n\\n\\t\\t\\t\\t\\tfloat distance = length(worldToEye);\\n\\n\\t\\t\\t\\t\\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\\n\\t\\t\\t\\t\\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\\n\\n\\t\\t\\t\\t\\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\\n\\t\\t\\t\\t\\tfloat rf0 = 0.3;\\n\\t\\t\\t\\t\\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\\n\\t\\t\\t\\t\\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\\n\\t\\t\\t\\t\\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\\n\\t\\t\\t\\t\\tvec3 outgoingLight = albedo;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4( outgoingLight, alpha );\\n\\n\\t\\t\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t\\t\\t#include <fog_fragment>\\n\\t\\t\\t\\t}\"\n    };\n    var material = new _three.ShaderMaterial({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: _three.UniformsUtils.clone(mirrorShader.uniforms),\n      lights: true,\n      side: side,\n      fog: fog\n    });\n    material.uniforms['mirrorSampler'].value = renderTarget.texture;\n    material.uniforms['textureMatrix'].value = textureMatrix;\n    material.uniforms['alpha'].value = alpha;\n    material.uniforms['time'].value = time;\n    material.uniforms['normalSampler'].value = normalSampler;\n    material.uniforms['sunColor'].value = sunColor;\n    material.uniforms['waterColor'].value = waterColor;\n    material.uniforms['sunDirection'].value = sunDirection;\n    material.uniforms['distortionScale'].value = distortionScale;\n    material.uniforms['eye'].value = eye;\n    scope.material = material;\n\n    scope.onBeforeRender = function (renderer, scene, camera) {\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(mirrorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(mirrorWorldPosition);\n      mirrorCamera.position.copy(view);\n      mirrorCamera.up.set(0, 1, 0);\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\n      mirrorCamera.up.reflect(normal);\n      mirrorCamera.lookAt(target);\n      mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n      mirrorCamera.updateMatrixWorld();\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n      var projectionMatrix = mirrorCamera.projectionMatrix;\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n      q.z = -1.0;\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\n\n      projectionMatrix.elements[2] = clipPlane.x;\n      projectionMatrix.elements[6] = clipPlane.y;\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n      projectionMatrix.elements[14] = clipPlane.w;\n      eye.setFromMatrixPosition(camera.matrixWorld); // Render\n\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      scope.visible = false;\n      renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, mirrorCamera);\n      scope.visible = true;\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\n\n      var viewport = camera.viewport;\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport);\n      }\n    };\n\n    return _this;\n  }\n\n  return Water;\n}(_three.Mesh);\n\nexports.Water = Water;\nWater.prototype.isWater = true;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$three$build$three_module","~$shadow.js"]],"~:properties",["^5",["fragmentShader","z","w","sunDirection","textureMatrix","prototype","waterColor","side","autoUpdate","far","fog","lights","x","__esModule","onBeforeRender","enabled","vertexShader","Water","sunColor","configurable","value","distortionScale","visible","eye","magFilter","writable","time","normalSampler","y","__proto__","alpha","isWater","mirrorSampler","generateMipmaps","size","uniforms","minFilter","format","constructor","material"]],"~:compiled-at",1630917515368,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$three_stdlib$objects$Water.js\",\n\"lineCount\":16,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/three-stdlib/objects/Water.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$three_stdlib$objects$Water\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.Water = void 0;\\n\\nvar _three = require(\\\"three\\\");\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } return _assertThisInitialized(self); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\n/**\\n * Work based on :\\n * http://slayvin.net : Flat mirror for three.js\\n * http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\\n * http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\\n */\\nvar Water =\\n/*#__PURE__*/\\nfunction (_Mesh) {\\n  _inherits(Water, _Mesh);\\n\\n  function Water(geometry) {\\n    var _this;\\n\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n    _classCallCheck(this, Water);\\n\\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Water).call(this, geometry));\\n\\n    var scope = _assertThisInitialized(_this);\\n\\n    var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\\n    var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\\n    var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\\n    var alpha = options.alpha !== undefined ? options.alpha : 1.0;\\n    var time = options.time !== undefined ? options.time : 0.0;\\n    var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\\n    var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new _three.Vector3(0.70707, 0.70707, 0.0);\\n    var sunColor = new _three.Color(options.sunColor !== undefined ? options.sunColor : 0xffffff);\\n    var waterColor = new _three.Color(options.waterColor !== undefined ? options.waterColor : 0x7f7f7f);\\n    var eye = options.eye !== undefined ? options.eye : new _three.Vector3(0, 0, 0);\\n    var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\\n    var side = options.side !== undefined ? options.side : _three.FrontSide;\\n    var fog = options.fog !== undefined ? options.fog : false;\\n    var format = options.format !== undefined ? options.format : _three.RGBFormat; //\\n\\n    var mirrorPlane = new _three.Plane();\\n    var normal = new _three.Vector3();\\n    var mirrorWorldPosition = new _three.Vector3();\\n    var cameraWorldPosition = new _three.Vector3();\\n    var rotationMatrix = new _three.Matrix4();\\n    var lookAtPosition = new _three.Vector3(0, 0, -1);\\n    var clipPlane = new _three.Vector4();\\n    var view = new _three.Vector3();\\n    var target = new _three.Vector3();\\n    var q = new _three.Vector4();\\n    var textureMatrix = new _three.Matrix4();\\n    var mirrorCamera = new _three.PerspectiveCamera();\\n    var parameters = {\\n      minFilter: _three.LinearFilter,\\n      magFilter: _three.LinearFilter,\\n      format: format\\n    };\\n    var renderTarget = new _three.WebGLRenderTarget(textureWidth, textureHeight, parameters);\\n\\n    if (!_three.MathUtils.isPowerOfTwo(textureWidth) || !_three.MathUtils.isPowerOfTwo(textureHeight)) {\\n      renderTarget.texture.generateMipmaps = false;\\n    }\\n\\n    var mirrorShader = {\\n      uniforms: _three.UniformsUtils.merge([_three.UniformsLib['fog'], _three.UniformsLib['lights'], {\\n        normalSampler: {\\n          value: null\\n        },\\n        mirrorSampler: {\\n          value: null\\n        },\\n        alpha: {\\n          value: 1.0\\n        },\\n        time: {\\n          value: 0.0\\n        },\\n        size: {\\n          value: 1.0\\n        },\\n        distortionScale: {\\n          value: 20.0\\n        },\\n        textureMatrix: {\\n          value: new _three.Matrix4()\\n        },\\n        sunColor: {\\n          value: new _three.Color(0x7f7f7f)\\n        },\\n        sunDirection: {\\n          value: new _three.Vector3(0.70707, 0.70707, 0)\\n        },\\n        eye: {\\n          value: new _three.Vector3()\\n        },\\n        waterColor: {\\n          value: new _three.Color(0x555555)\\n        }\\n      }]),\\n      vertexShader:\\n      /* glsl */\\n      \\\"\\\\n\\\\t\\\\t\\\\t\\\\tuniform mat4 textureMatrix;\\\\n\\\\t\\\\t\\\\t\\\\tuniform float time;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvarying vec4 mirrorCoord;\\\\n\\\\t\\\\t\\\\t\\\\tvarying vec4 worldPosition;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t#include <common>\\\\n\\\\t\\\\t\\\\t\\\\t#include <fog_pars_vertex>\\\\n\\\\t\\\\t\\\\t\\\\t#include <shadowmap_pars_vertex>\\\\n\\\\t\\\\t\\\\t\\\\t#include <logdepthbuf_pars_vertex>\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvoid main() {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tworldPosition = mirrorCoord.xyzw;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tmirrorCoord = textureMatrix * mirrorCoord;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tgl_Position = projectionMatrix * mvPosition;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t\\\\t\\\\t#include <defaultnormal_vertex>\\\\n\\\\t\\\\t\\\\t\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t\\\\t\\\\t\\\\t#include <fog_vertex>\\\\n\\\\t\\\\t\\\\t\\\\t#include <shadowmap_vertex>\\\\n\\\\t\\\\t\\\\t}\\\",\\n      fragmentShader:\\n      /* glsl */\\n      \\\"\\\\n\\\\t\\\\t\\\\t\\\\tuniform sampler2D mirrorSampler;\\\\n\\\\t\\\\t\\\\t\\\\tuniform float alpha;\\\\n\\\\t\\\\t\\\\t\\\\tuniform float time;\\\\n\\\\t\\\\t\\\\t\\\\tuniform float size;\\\\n\\\\t\\\\t\\\\t\\\\tuniform float distortionScale;\\\\n\\\\t\\\\t\\\\t\\\\tuniform sampler2D normalSampler;\\\\n\\\\t\\\\t\\\\t\\\\tuniform vec3 sunColor;\\\\n\\\\t\\\\t\\\\t\\\\tuniform vec3 sunDirection;\\\\n\\\\t\\\\t\\\\t\\\\tuniform vec3 eye;\\\\n\\\\t\\\\t\\\\t\\\\tuniform vec3 waterColor;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvarying vec4 mirrorCoord;\\\\n\\\\t\\\\t\\\\t\\\\tvarying vec4 worldPosition;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvec4 getNoise( vec2 uv ) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec4 noise = texture2D( normalSampler, uv0 ) +\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttexture2D( normalSampler, uv1 ) +\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttexture2D( normalSampler, uv2 ) +\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttexture2D( normalSampler, uv3 );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\treturn noise * 0.5 - 1.0;\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tspecularColor += pow( direction, shiny ) * sunColor * spec;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t#include <common>\\\\n\\\\t\\\\t\\\\t\\\\t#include <packing>\\\\n\\\\t\\\\t\\\\t\\\\t#include <bsdfs>\\\\n\\\\t\\\\t\\\\t\\\\t#include <fog_pars_fragment>\\\\n\\\\t\\\\t\\\\t\\\\t#include <logdepthbuf_pars_fragment>\\\\n\\\\t\\\\t\\\\t\\\\t#include <lights_pars_begin>\\\\n\\\\t\\\\t\\\\t\\\\t#include <shadowmap_pars_fragment>\\\\n\\\\t\\\\t\\\\t\\\\t#include <shadowmask_pars_fragment>\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tvoid main() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec4 noise = getNoise( worldPosition.xz * size );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 diffuseLight = vec3(0.0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 specularLight = vec3(0.0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 worldToEye = eye-worldPosition.xyz;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 eyeDirection = normalize( worldToEye );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat distance = length(worldToEye);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat rf0 = 0.3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tvec3 outgoingLight = albedo;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tgl_FragColor = vec4( outgoingLight, alpha );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#include <tonemapping_fragment>\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t#include <fog_fragment>\\\\n\\\\t\\\\t\\\\t\\\\t}\\\"\\n    };\\n    var material = new _three.ShaderMaterial({\\n      fragmentShader: mirrorShader.fragmentShader,\\n      vertexShader: mirrorShader.vertexShader,\\n      uniforms: _three.UniformsUtils.clone(mirrorShader.uniforms),\\n      lights: true,\\n      side: side,\\n      fog: fog\\n    });\\n    material.uniforms['mirrorSampler'].value = renderTarget.texture;\\n    material.uniforms['textureMatrix'].value = textureMatrix;\\n    material.uniforms['alpha'].value = alpha;\\n    material.uniforms['time'].value = time;\\n    material.uniforms['normalSampler'].value = normalSampler;\\n    material.uniforms['sunColor'].value = sunColor;\\n    material.uniforms['waterColor'].value = waterColor;\\n    material.uniforms['sunDirection'].value = sunDirection;\\n    material.uniforms['distortionScale'].value = distortionScale;\\n    material.uniforms['eye'].value = eye;\\n    scope.material = material;\\n\\n    scope.onBeforeRender = function (renderer, scene, camera) {\\n      mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\\n      rotationMatrix.extractRotation(scope.matrixWorld);\\n      normal.set(0, 0, 1);\\n      normal.applyMatrix4(rotationMatrix);\\n      view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\\n\\n      if (view.dot(normal) > 0) return;\\n      view.reflect(normal).negate();\\n      view.add(mirrorWorldPosition);\\n      rotationMatrix.extractRotation(camera.matrixWorld);\\n      lookAtPosition.set(0, 0, -1);\\n      lookAtPosition.applyMatrix4(rotationMatrix);\\n      lookAtPosition.add(cameraWorldPosition);\\n      target.subVectors(mirrorWorldPosition, lookAtPosition);\\n      target.reflect(normal).negate();\\n      target.add(mirrorWorldPosition);\\n      mirrorCamera.position.copy(view);\\n      mirrorCamera.up.set(0, 1, 0);\\n      mirrorCamera.up.applyMatrix4(rotationMatrix);\\n      mirrorCamera.up.reflect(normal);\\n      mirrorCamera.lookAt(target);\\n      mirrorCamera.far = camera.far; // Used in WebGLBackground\\n\\n      mirrorCamera.updateMatrixWorld();\\n      mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix\\n\\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\\n      textureMatrix.multiply(mirrorCamera.projectionMatrix);\\n      textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\\n      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\\n\\n      mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\\n      mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\\n      clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\\n      var projectionMatrix = mirrorCamera.projectionMatrix;\\n      q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\\n      q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\\n      q.z = -1.0;\\n      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector\\n\\n      clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix\\n\\n      projectionMatrix.elements[2] = clipPlane.x;\\n      projectionMatrix.elements[6] = clipPlane.y;\\n      projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\\n      projectionMatrix.elements[14] = clipPlane.w;\\n      eye.setFromMatrixPosition(camera.matrixWorld); // Render\\n\\n      var currentRenderTarget = renderer.getRenderTarget();\\n      var currentXrEnabled = renderer.xr.enabled;\\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\\n      scope.visible = false;\\n      renderer.xr.enabled = false; // Avoid camera modification and recursion\\n\\n      renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\\n\\n      renderer.setRenderTarget(renderTarget);\\n      renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\\n\\n      if (renderer.autoClear === false) renderer.clear();\\n      renderer.render(scene, mirrorCamera);\\n      scope.visible = true;\\n      renderer.xr.enabled = currentXrEnabled;\\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\\n      renderer.setRenderTarget(currentRenderTarget); // Restore viewport\\n\\n      var viewport = camera.viewport;\\n\\n      if (viewport !== undefined) {\\n        renderer.state.viewport(viewport);\\n      }\\n    };\\n\\n    return _this;\\n  }\\n\\n  return Water;\\n}(_three.Mesh);\\n\\nexports.Water = Water;\\nWater.prototype.isWater = true;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_typeof\",\"obj\",\"Symbol\",\"iterator\",\"constructor\",\"prototype\",\"_possibleConstructorReturn\",\"self\",\"call\",\"_assertThisInitialized\",\"_getPrototypeOf\",\"o\",\"Object\",\"setPrototypeOf\",\"getPrototypeOf\",\"__proto__\",\"ReferenceError\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"create\",\"value\",\"writable\",\"configurable\",\"_setPrototypeOf\",\"p\",\"defineProperty\",\"Water\",\"_three\",\"_Mesh\",\"geometry\",\"options\",\"arguments\",\"length\",\"undefined\",\"instance\",\"_this\",\"scope\",\"textureWidth\",\"textureHeight\",\"clipBias\",\"alpha\",\"time\",\"normalSampler\",\"waterNormals\",\"sunDirection\",\"Vector3\",\"sunColor\",\"Color\",\"waterColor\",\"eye\",\"distortionScale\",\"side\",\"FrontSide\",\"fog\",\"format\",\"RGBFormat\",\"mirrorPlane\",\"Plane\",\"normal\",\"mirrorWorldPosition\",\"cameraWorldPosition\",\"rotationMatrix\",\"Matrix4\",\"lookAtPosition\",\"clipPlane\",\"Vector4\",\"view\",\"target\",\"q\",\"textureMatrix\",\"mirrorCamera\",\"PerspectiveCamera\",\"renderTarget\",\"WebGLRenderTarget\",\"parameters\",\"minFilter\",\"LinearFilter\",\"magFilter\",\"MathUtils\",\"isPowerOfTwo\",\"texture\",\"generateMipmaps\",\"UniformsUtils\",\"merge\",\"UniformsLib\",\"mirrorSampler\",\"size\",\"material\",\"ShaderMaterial\",\"fragmentShader\",\"vertexShader\",\"uniforms\",\"clone\",\"lights\",\"onBeforeRender\",\"scope.onBeforeRender\",\"renderer\",\"scene\",\"camera\",\"setFromMatrixPosition\",\"matrixWorld\",\"extractRotation\",\"set\",\"applyMatrix4\",\"subVectors\",\"dot\",\"reflect\",\"negate\",\"add\",\"position\",\"copy\",\"up\",\"lookAt\",\"far\",\"updateMatrixWorld\",\"projectionMatrix\",\"multiply\",\"matrixWorldInverse\",\"setFromNormalAndCoplanarPoint\",\"x\",\"y\",\"z\",\"constant\",\"Math\",\"sign\",\"elements\",\"w\",\"multiplyScalar\",\"currentRenderTarget\",\"getRenderTarget\",\"currentXrEnabled\",\"xr\",\"enabled\",\"currentShadowAutoUpdate\",\"shadowMap\",\"autoUpdate\",\"visible\",\"setRenderTarget\",\"state\",\"buffers\",\"depth\",\"setMask\",\"autoClear\",\"clear\",\"render\",\"viewport\",\"Mesh\",\"isWater\"]\n}\n"]