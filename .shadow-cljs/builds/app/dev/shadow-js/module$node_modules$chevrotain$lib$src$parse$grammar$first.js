["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/chevrotain/lib/src/parse/grammar/first.js"],"~:js","shadow$provide.module$node_modules$chevrotain$lib$src$parse$grammar$first=function(global,require,module,exports){function first(prod){if(prod instanceof gast_public_1.NonTerminal)return first(prod.referencedRule);if(prod instanceof gast_public_1.Terminal)return[prod.terminalType];if(gast_1.isSequenceProd(prod))return firstForSequence(prod);if(gast_1.isBranchingProd(prod))return firstForBranching(prod);throw Error(\"non exhaustive match\");}function firstForSequence(prod){var firstSet=[];prod=prod.definition;\nfor(var nextSubProdIdx=0,hasInnerProdsRemaining=prod.length>nextSubProdIdx,isLastInnerProdOptional=!0;hasInnerProdsRemaining&&isLastInnerProdOptional;)hasInnerProdsRemaining=prod[nextSubProdIdx],isLastInnerProdOptional=gast_1.isOptionalProd(hasInnerProdsRemaining),firstSet=firstSet.concat(first(hasInnerProdsRemaining)),nextSubProdIdx+=1,hasInnerProdsRemaining=prod.length>nextSubProdIdx;return utils_1.uniq(firstSet)}function firstForBranching(prod){prod=utils_1.map(prod.definition,function(innerProd){return first(innerProd)});\nreturn utils_1.uniq(utils_1.flatten(prod))}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.firstForTerminal=exports.firstForBranching=exports.firstForSequence=exports.first=void 0;var utils_1=require(\"module$node_modules$$chevrotain$utils$lib$src$api\"),gast_public_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_public\"),gast_1=require(\"module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast\");exports.first=first;exports.firstForSequence=firstForSequence;\nexports.firstForBranching=firstForBranching;exports.firstForTerminal=function(terminal){return[terminal.terminalType]}}","~:source","shadow$provide[\"module$node_modules$chevrotain$lib$src$parse$grammar$first\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;\nvar utils_1 = require(\"@chevrotain/utils\");\nvar gast_public_1 = require(\"./gast/gast_public\");\nvar gast_1 = require(\"./gast/gast\");\nfunction first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof gast_public_1.NonTerminal) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof gast_public_1.Terminal) {\n        return firstForTerminal(prod);\n    }\n    else if (gast_1.isSequenceProd(prod)) {\n        return firstForSequence(prod);\n    }\n    else if (gast_1.isBranchingProd(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nexports.first = first;\nfunction firstForSequence(prod) {\n    var firstSet = [];\n    var seq = prod.definition;\n    var nextSubProdIdx = 0;\n    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    var currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    var isLastInnerProdOptional = true;\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = gast_1.isOptionalProd(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return utils_1.uniq(firstSet);\n}\nexports.firstForSequence = firstForSequence;\nfunction firstForBranching(prod) {\n    var allAlternativesFirsts = utils_1.map(prod.definition, function (innerProd) {\n        return first(innerProd);\n    });\n    return utils_1.uniq(utils_1.flatten(allAlternativesFirsts));\n}\nexports.firstForBranching = firstForBranching;\nfunction firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\nexports.firstForTerminal = firstForTerminal;\n//# sourceMappingURL=first.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$chevrotain$utils$lib$src$api","~$module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast","~$shadow.js","~$module$node_modules$chevrotain$lib$src$parse$grammar$gast$gast_public"]],"~:properties",["^5",["__esModule","value","firstForSequence","firstForTerminal","firstForBranching","first"]],"~:compiled-at",1630917515682,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$chevrotain$lib$src$parse$grammar$first.js\",\n\"lineCount\":4,\n\"mappings\":\"AAAAA,cAAA,CAAA,0DAAA,CAA+E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAOvHC,QAASA,MAAK,CAACC,IAAD,CAAO,CAEjB,GAAIA,IAAJ,WAAoBC,cAAcC,CAAAA,WAAlC,CASI,MAAOH,MAAA,CAAMC,IAAKG,CAAAA,cAAX,CAEN,IAAIH,IAAJ,WAAoBC,cAAcG,CAAAA,QAAlC,CACD,MAwCG,CAxCqBJ,IAwCXK,CAAAA,YAAV,CAtCF,IAAIC,MAAOC,CAAAA,cAAP,CAAsBP,IAAtB,CAAJ,CACD,MAAOQ,iBAAA,CAAiBR,IAAjB,CAEN,IAAIM,MAAOG,CAAAA,eAAP,CAAuBT,IAAvB,CAAJ,CACD,MAAOU,kBAAA,CAAkBV,IAAlB,CAGP,MAAMW,MAAA,CAAM,sBAAN,CAAN,CAvBa,CA2BrBH,QAASA,iBAAgB,CAACR,IAAD,CAAO,CAC5B,IAAIY,SAAW,EACXC,KAAAA,CAAMb,IAAKc,CAAAA,UAOf;IANA,IAAIC,eAAiB,CAArB,CACIC,uBAAyBH,IAAII,CAAAA,MAA7BD,CAAsCD,cAD1C,CAIIG,wBAA0B,CAAA,CAE9B,CAAOF,sBAAP,EAAiCE,uBAAjC,CAAA,CACIC,sBAIA,CAJcN,IAAA,CAAIE,cAAJ,CAId,CAHAG,uBAGA,CAH0BZ,MAAOc,CAAAA,cAAP,CAAsBD,sBAAtB,CAG1B,CAFAP,QAEA,CAFWA,QAASS,CAAAA,MAAT,CAAgBtB,KAAA,CAAMoB,sBAAN,CAAhB,CAEX,CADiBJ,cACjB,EADkC,CAClC,CAAAC,sBAAA,CAAyBH,IAAII,CAAAA,MAA7B,CAAsCF,cAE1C,OAAOO,QAAQC,CAAAA,IAAR,CAAaX,QAAb,CAhBqB,CAmBhCF,QAASA,kBAAiB,CAACV,IAAD,CAAO,CACzBwB,IAAAA,CAAwBF,OAAQG,CAAAA,GAAR,CAAYzB,IAAKc,CAAAA,UAAjB,CAA6B,QAAS,CAACY,SAAD,CAAY,CAC1E,MAAO3B,MAAA,CAAM2B,SAAN,CADmE,CAAlD,CAG5B;MAAOJ,QAAQC,CAAAA,IAAR,CAAaD,OAAQK,CAAAA,OAAR,CAAgBH,IAAhB,CAAb,CAJsB,CAnDjCI,MAAOC,CAAAA,cAAP,CAAsB/B,OAAtB,CAA+B,YAA/B,CAA6C,CAAEgC,MAAO,CAAA,CAAT,CAA7C,CACAhC,QAAQiC,CAAAA,gBAAR,CAA2BjC,OAAQY,CAAAA,iBAAnC,CAAuDZ,OAAQU,CAAAA,gBAA/D,CAAkFV,OAAQC,CAAAA,KAA1F,CAAkG,IAAK,EACvG,KAAIuB,QAAU1B,OAAA,CAAQ,mDAAR,CAAd,CACIK,cAAgBL,OAAA,CAAQ,uEAAR,CADpB,CAEIU,OAASV,OAAA,CAAQ,gEAAR,CA2BbE,QAAQC,CAAAA,KAAR,CAAgBA,KAmBhBD,QAAQU,CAAAA,gBAAR,CAA2BA,gBAO3BV;OAAQY,CAAAA,iBAAR,CAA4BA,iBAI5BZ,QAAQiC,CAAAA,gBAAR,CAHAA,QAAyB,CAACC,QAAD,CAAW,CAChC,MAAO,CAACA,QAAS3B,CAAAA,YAAV,CADyB,CA5DmF;\",\n\"sources\":[\"node_modules/chevrotain/lib/src/parse/grammar/first.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$chevrotain$lib$src$parse$grammar$first\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\nObject.defineProperty(exports, \\\"__esModule\\\", { value: true });\\nexports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;\\nvar utils_1 = require(\\\"@chevrotain/utils\\\");\\nvar gast_public_1 = require(\\\"./gast/gast_public\\\");\\nvar gast_1 = require(\\\"./gast/gast\\\");\\nfunction first(prod) {\\n    /* istanbul ignore else */\\n    if (prod instanceof gast_public_1.NonTerminal) {\\n        // this could in theory cause infinite loops if\\n        // (1) prod A refs prod B.\\n        // (2) prod B refs prod A\\n        // (3) AB can match the empty set\\n        // in other words a cycle where everything is optional so the first will keep\\n        // looking ahead for the next optional part and will never exit\\n        // currently there is no safeguard for this unique edge case because\\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\\n        return first(prod.referencedRule);\\n    }\\n    else if (prod instanceof gast_public_1.Terminal) {\\n        return firstForTerminal(prod);\\n    }\\n    else if (gast_1.isSequenceProd(prod)) {\\n        return firstForSequence(prod);\\n    }\\n    else if (gast_1.isBranchingProd(prod)) {\\n        return firstForBranching(prod);\\n    }\\n    else {\\n        throw Error(\\\"non exhaustive match\\\");\\n    }\\n}\\nexports.first = first;\\nfunction firstForSequence(prod) {\\n    var firstSet = [];\\n    var seq = prod.definition;\\n    var nextSubProdIdx = 0;\\n    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\\n    var currSubProd;\\n    // so we enter the loop at least once (if the definition is not empty\\n    var isLastInnerProdOptional = true;\\n    // scan a sequence until it's end or until we have found a NONE optional production in it\\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\\n        currSubProd = seq[nextSubProdIdx];\\n        isLastInnerProdOptional = gast_1.isOptionalProd(currSubProd);\\n        firstSet = firstSet.concat(first(currSubProd));\\n        nextSubProdIdx = nextSubProdIdx + 1;\\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\\n    }\\n    return utils_1.uniq(firstSet);\\n}\\nexports.firstForSequence = firstForSequence;\\nfunction firstForBranching(prod) {\\n    var allAlternativesFirsts = utils_1.map(prod.definition, function (innerProd) {\\n        return first(innerProd);\\n    });\\n    return utils_1.uniq(utils_1.flatten(allAlternativesFirsts));\\n}\\nexports.firstForBranching = firstForBranching;\\nfunction firstForTerminal(terminal) {\\n    return [terminal.terminalType];\\n}\\nexports.firstForTerminal = firstForTerminal;\\n//# sourceMappingURL=first.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"first\",\"prod\",\"gast_public_1\",\"NonTerminal\",\"referencedRule\",\"Terminal\",\"terminalType\",\"gast_1\",\"isSequenceProd\",\"firstForSequence\",\"isBranchingProd\",\"firstForBranching\",\"Error\",\"firstSet\",\"seq\",\"definition\",\"nextSubProdIdx\",\"hasInnerProdsRemaining\",\"length\",\"isLastInnerProdOptional\",\"currSubProd\",\"isOptionalProd\",\"concat\",\"utils_1\",\"uniq\",\"allAlternativesFirsts\",\"map\",\"innerProd\",\"flatten\",\"Object\",\"defineProperty\",\"value\",\"firstForTerminal\",\"terminal\"]\n}\n"]