["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/regexp-to-ast/lib/regexp-to-ast.js"],"~:js","shadow$provide.module$node_modules$regexp_to_ast$lib$regexp_to_ast=function(global,require,module,exports){(function(root,factory){\"function\"===typeof define&&define.amd?define([],factory):\"object\"===typeof module&&module.exports?module.exports=factory():root.regexpToAst=factory()})(\"undefined\"!==typeof self?self:this,function(){function RegExpParser(){}function cc(char){return char.charCodeAt(0)}function insertToSet(item,set){void 0!==item.length?item.forEach(function(subItem){set.push(subItem)}):\nset.push(item)}function addFlag(flagObj,flagKey){if(!0===flagObj[flagKey])throw\"duplicate flag \"+flagKey;flagObj[flagKey]=!0}function ASSERT_EXISTS(obj){if(void 0===obj)throw Error(\"Internal Error - Should never get here!\");}function BaseRegExpVisitor(){}RegExpParser.prototype.saveState=function(){return{idx:this.idx,input:this.input,groupIdx:this.groupIdx}};RegExpParser.prototype.restoreState=function(newState){this.idx=newState.idx;this.input=newState.input;this.groupIdx=newState.groupIdx};RegExpParser.prototype.pattern=\nfunction(input){this.idx=0;this.input=input;this.groupIdx=0;this.consumeChar(\"/\");var value=this.disjunction();this.consumeChar(\"/\");for(input={type:\"Flags\",loc:{begin:this.idx,end:input.length},global:!1,ignoreCase:!1,multiLine:!1,unicode:!1,sticky:!1};this.isRegExpFlag();)switch(this.popChar()){case \"g\":addFlag(input,\"global\");break;case \"i\":addFlag(input,\"ignoreCase\");break;case \"m\":addFlag(input,\"multiLine\");break;case \"u\":addFlag(input,\"unicode\");break;case \"y\":addFlag(input,\"sticky\")}if(this.idx!==\nthis.input.length)throw Error(\"Redundant input: \"+this.input.substring(this.idx));return{type:\"Pattern\",flags:input,value,loc:this.loc(0)}};RegExpParser.prototype.disjunction=function(){var alts=[],begin=this.idx;for(alts.push(this.alternative());\"|\"===this.peekChar();)this.consumeChar(\"|\"),alts.push(this.alternative());return{type:\"Disjunction\",value:alts,loc:this.loc(begin)}};RegExpParser.prototype.alternative=function(){for(var terms=[],begin=this.idx;this.isTerm();)terms.push(this.term());return{type:\"Alternative\",\nvalue:terms,loc:this.loc(begin)}};RegExpParser.prototype.term=function(){return this.isAssertion()?this.assertion():this.atom()};RegExpParser.prototype.assertion=function(){var begin=this.idx;switch(this.popChar()){case \"^\":return{type:\"StartAnchor\",loc:this.loc(begin)};case \"$\":return{type:\"EndAnchor\",loc:this.loc(begin)};case \"\\\\\":switch(this.popChar()){case \"b\":return{type:\"WordBoundary\",loc:this.loc(begin)};case \"B\":return{type:\"NonWordBoundary\",loc:this.loc(begin)}}throw Error(\"Invalid Assertion Escape\");\ncase \"(\":this.consumeChar(\"?\");switch(this.popChar()){case \"\\x3d\":var type=\"Lookahead\";break;case \"!\":type=\"NegativeLookahead\"}ASSERT_EXISTS(type);var disjunction=this.disjunction();this.consumeChar(\")\");return{type,value:disjunction,loc:this.loc(begin)}}throw Error(\"Internal Error - Should never get here!\");};RegExpParser.prototype.quantifier=function(isBacktracking){var begin=this.idx;switch(this.popChar()){case \"*\":var range={atLeast:0,atMost:Infinity};break;case \"+\":range={atLeast:1,atMost:Infinity};\nbreak;case \"?\":range={atLeast:0,atMost:1};break;case \"{\":var atLeast=this.integerIncludingZero();switch(this.popChar()){case \"}\":range={atLeast,atMost:atLeast};break;case \",\":this.isDigit()?(range=this.integerIncludingZero(),range={atLeast,atMost:range}):range={atLeast,atMost:Infinity},this.consumeChar(\"}\")}if(!0===isBacktracking&&void 0===range)return;ASSERT_EXISTS(range)}if(!0!==isBacktracking||void 0!==range)return ASSERT_EXISTS(range),\"?\"===this.peekChar(0)?(this.consumeChar(\"?\"),range.greedy=\n!1):range.greedy=!0,range.type=\"Quantifier\",range.loc=this.loc(begin),range};RegExpParser.prototype.atom=function(){var begin=this.idx;switch(this.peekChar()){case \".\":var atom=this.dotAll();break;case \"\\\\\":atom=this.atomEscape();break;case \"[\":atom=this.characterClass();break;case \"(\":atom=this.group()}void 0===atom&&this.isPatternCharacter()&&(atom=this.patternCharacter());ASSERT_EXISTS(atom);atom.loc=this.loc(begin);this.isQuantifier()&&(atom.quantifier=this.quantifier());return atom};RegExpParser.prototype.dotAll=\nfunction(){this.consumeChar(\".\");return{type:\"Set\",complement:!0,value:[cc(\"\\n\"),cc(\"\\r\"),cc(\"\\u2028\"),cc(\"\\u2029\")]}};RegExpParser.prototype.atomEscape=function(){this.consumeChar(\"\\\\\");switch(this.peekChar()){case \"1\":case \"2\":case \"3\":case \"4\":case \"5\":case \"6\":case \"7\":case \"8\":case \"9\":return this.decimalEscapeAtom();case \"d\":case \"D\":case \"s\":case \"S\":case \"w\":case \"W\":return this.characterClassEscape();case \"f\":case \"n\":case \"r\":case \"t\":case \"v\":return this.controlEscapeAtom();case \"c\":return this.controlLetterEscapeAtom();\ncase \"0\":return this.nulCharacterAtom();case \"x\":return this.hexEscapeSequenceAtom();case \"u\":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}};RegExpParser.prototype.decimalEscapeAtom=function(){return{type:\"GroupBackReference\",value:this.positiveInteger()}};RegExpParser.prototype.characterClassEscape=function(){var complement=!1;switch(this.popChar()){case \"d\":var set=digitsCharCodes;break;case \"D\":set=digitsCharCodes;complement=!0;break;case \"s\":set=whitespaceCodes;\nbreak;case \"S\":set=whitespaceCodes;complement=!0;break;case \"w\":set=wordCharCodes;break;case \"W\":set=wordCharCodes,complement=!0}ASSERT_EXISTS(set);return{type:\"Set\",value:set,complement}};RegExpParser.prototype.controlEscapeAtom=function(){switch(this.popChar()){case \"f\":var escapeCode=cc(\"\\f\");break;case \"n\":escapeCode=cc(\"\\n\");break;case \"r\":escapeCode=cc(\"\\r\");break;case \"t\":escapeCode=cc(\"\\t\");break;case \"v\":escapeCode=cc(\"\\v\")}ASSERT_EXISTS(escapeCode);return{type:\"Character\",value:escapeCode}};\nRegExpParser.prototype.controlLetterEscapeAtom=function(){this.consumeChar(\"c\");var letter=this.popChar();if(!1===/[a-zA-Z]/.test(letter))throw Error(\"Invalid \");return{type:\"Character\",value:letter.toUpperCase().charCodeAt(0)-64}};RegExpParser.prototype.nulCharacterAtom=function(){this.consumeChar(\"0\");return{type:\"Character\",value:cc(\"\\x00\")}};RegExpParser.prototype.hexEscapeSequenceAtom=function(){this.consumeChar(\"x\");return this.parseHexDigits(2)};RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom=\nfunction(){this.consumeChar(\"u\");return this.parseHexDigits(4)};RegExpParser.prototype.identityEscapeAtom=function(){var escapedChar=this.popChar();return{type:\"Character\",value:cc(escapedChar)}};RegExpParser.prototype.classPatternCharacterAtom=function(){switch(this.peekChar()){case \"\\n\":case \"\\r\":case \"\\u2028\":case \"\\u2029\":case \"\\\\\":case \"]\":throw Error(\"TBD\");default:var nextChar=this.popChar();return{type:\"Character\",value:cc(nextChar)}}};RegExpParser.prototype.characterClass=function(){var set=\n[],complement=!1;this.consumeChar(\"[\");\"^\"===this.peekChar(0)&&(this.consumeChar(\"^\"),complement=!0);for(;this.isClassAtom();){var from=this.classAtom();if(\"Character\"===from.type&&this.isRangeDash()){this.consumeChar(\"-\");var to=this.classAtom();if(\"Character\"===to.type){if(to.value<from.value)throw Error(\"Range out of order in character class\");set.push({from:from.value,to:to.value})}else insertToSet(from.value,set),set.push(cc(\"-\")),insertToSet(to.value,set)}else insertToSet(from.value,set)}this.consumeChar(\"]\");\nreturn{type:\"Set\",complement,value:set}};RegExpParser.prototype.classAtom=function(){switch(this.peekChar()){case \"]\":case \"\\n\":case \"\\r\":case \"\\u2028\":case \"\\u2029\":throw Error(\"TBD\");case \"\\\\\":return this.classEscape();default:return this.classPatternCharacterAtom()}};RegExpParser.prototype.classEscape=function(){this.consumeChar(\"\\\\\");switch(this.peekChar()){case \"b\":return this.consumeChar(\"b\"),{type:\"Character\",value:cc(\"\\b\")};case \"d\":case \"D\":case \"s\":case \"S\":case \"w\":case \"W\":return this.characterClassEscape();\ncase \"f\":case \"n\":case \"r\":case \"t\":case \"v\":return this.controlEscapeAtom();case \"c\":return this.controlLetterEscapeAtom();case \"0\":return this.nulCharacterAtom();case \"x\":return this.hexEscapeSequenceAtom();case \"u\":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}};RegExpParser.prototype.group=function(){var capturing=!0;this.consumeChar(\"(\");switch(this.peekChar(0)){case \"?\":this.consumeChar(\"?\");this.consumeChar(\":\");capturing=!1;break;default:this.groupIdx++}var value=\nthis.disjunction();this.consumeChar(\")\");value={type:\"Group\",capturing,value};capturing&&(value.idx=this.groupIdx);return value};RegExpParser.prototype.positiveInteger=function(){var number=this.popChar();if(!1===decimalPatternNoZero.test(number))throw Error(\"Expecting a positive integer\");for(;decimalPattern.test(this.peekChar(0));)number+=this.popChar();return parseInt(number,10)};RegExpParser.prototype.integerIncludingZero=function(){var number=this.popChar();if(!1===decimalPattern.test(number))throw Error(\"Expecting an integer\");\nfor(;decimalPattern.test(this.peekChar(0));)number+=this.popChar();return parseInt(number,10)};RegExpParser.prototype.patternCharacter=function(){var nextChar=this.popChar();switch(nextChar){case \"\\n\":case \"\\r\":case \"\\u2028\":case \"\\u2029\":case \"^\":case \"$\":case \"\\\\\":case \".\":case \"*\":case \"+\":case \"?\":case \"(\":case \")\":case \"[\":case \"|\":throw Error(\"TBD\");default:return{type:\"Character\",value:cc(nextChar)}}};RegExpParser.prototype.isRegExpFlag=function(){switch(this.peekChar(0)){case \"g\":case \"i\":case \"m\":case \"u\":case \"y\":return!0;\ndefault:return!1}};RegExpParser.prototype.isRangeDash=function(){return\"-\"===this.peekChar()&&this.isClassAtom(1)};RegExpParser.prototype.isDigit=function(){return decimalPattern.test(this.peekChar(0))};RegExpParser.prototype.isClassAtom=function(howMuch){void 0===howMuch&&(howMuch=0);switch(this.peekChar(howMuch)){case \"]\":case \"\\n\":case \"\\r\":case \"\\u2028\":case \"\\u2029\":return!1;default:return!0}};RegExpParser.prototype.isTerm=function(){return this.isAtom()||this.isAssertion()};RegExpParser.prototype.isAtom=\nfunction(){if(this.isPatternCharacter())return!0;switch(this.peekChar(0)){case \".\":case \"\\\\\":case \"[\":case \"(\":return!0;default:return!1}};RegExpParser.prototype.isAssertion=function(){switch(this.peekChar(0)){case \"^\":case \"$\":return!0;case \"\\\\\":switch(this.peekChar(1)){case \"b\":case \"B\":return!0;default:return!1}case \"(\":return\"?\"===this.peekChar(1)&&(\"\\x3d\"===this.peekChar(2)||\"!\"===this.peekChar(2));default:return!1}};RegExpParser.prototype.isQuantifier=function(){var prevState=this.saveState();\ntry{return void 0!==this.quantifier(!0)}catch(e){return!1}finally{this.restoreState(prevState)}};RegExpParser.prototype.isPatternCharacter=function(){switch(this.peekChar()){case \"^\":case \"$\":case \"\\\\\":case \".\":case \"*\":case \"+\":case \"?\":case \"(\":case \")\":case \"[\":case \"|\":case \"/\":case \"\\n\":case \"\\r\":case \"\\u2028\":case \"\\u2029\":return!1;default:return!0}};RegExpParser.prototype.parseHexDigits=function(howMany){for(var hexString=\"\",i=0;i<howMany;i++){var hexChar=this.popChar();if(!1===hexDigitPattern.test(hexChar))throw Error(\"Expecting a HexDecimal digits\");\nhexString+=hexChar}return{type:\"Character\",value:parseInt(hexString,16)}};RegExpParser.prototype.peekChar=function(howMuch){void 0===howMuch&&(howMuch=0);return this.input[this.idx+howMuch]};RegExpParser.prototype.popChar=function(){var nextChar=this.peekChar(0);this.consumeChar();return nextChar};RegExpParser.prototype.consumeChar=function(char){if(void 0!==char&&this.input[this.idx]!==char)throw Error(\"Expected: '\"+char+\"' but found: '\"+this.input[this.idx]+\"' at offset: \"+this.idx);if(this.idx>=\nthis.input.length)throw Error(\"Unexpected end of input\");this.idx++};RegExpParser.prototype.loc=function(begin){return{begin,end:this.idx}};var hexDigitPattern=/[0-9a-fA-F]/,decimalPattern=/[0-9]/,decimalPatternNoZero=/[1-9]/,i$jscomp$0,digitsCharCodes=[];for(i$jscomp$0=cc(\"0\");i$jscomp$0<=cc(\"9\");i$jscomp$0++)digitsCharCodes.push(i$jscomp$0);var wordCharCodes=[cc(\"_\")].concat(digitsCharCodes);for(i$jscomp$0=cc(\"a\");i$jscomp$0<=cc(\"z\");i$jscomp$0++)wordCharCodes.push(i$jscomp$0);for(i$jscomp$0=cc(\"A\");i$jscomp$0<=\ncc(\"Z\");i$jscomp$0++)wordCharCodes.push(i$jscomp$0);var whitespaceCodes=[cc(\" \"),cc(\"\\f\"),cc(\"\\n\"),cc(\"\\r\"),cc(\"\\t\"),cc(\"\\v\"),cc(\"\\t\"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\" \"),cc(\"\\u2028\"),cc(\"\\u2029\"),cc(\" \"),cc(\" \"),cc(\"　\"),cc(\"﻿\")];BaseRegExpVisitor.prototype.visitChildren=function(node){for(var key in node){var child=node[key];node.hasOwnProperty(key)&&(void 0!==child.type?this.visit(child):Array.isArray(child)&&child.forEach(function(subChild){this.visit(subChild)},\nthis))}};BaseRegExpVisitor.prototype.visit=function(node){switch(node.type){case \"Pattern\":this.visitPattern(node);break;case \"Flags\":this.visitFlags(node);break;case \"Disjunction\":this.visitDisjunction(node);break;case \"Alternative\":this.visitAlternative(node);break;case \"StartAnchor\":this.visitStartAnchor(node);break;case \"EndAnchor\":this.visitEndAnchor(node);break;case \"WordBoundary\":this.visitWordBoundary(node);break;case \"NonWordBoundary\":this.visitNonWordBoundary(node);break;case \"Lookahead\":this.visitLookahead(node);\nbreak;case \"NegativeLookahead\":this.visitNegativeLookahead(node);break;case \"Character\":this.visitCharacter(node);break;case \"Set\":this.visitSet(node);break;case \"Group\":this.visitGroup(node);break;case \"GroupBackReference\":this.visitGroupBackReference(node);break;case \"Quantifier\":this.visitQuantifier(node)}this.visitChildren(node)};BaseRegExpVisitor.prototype.visitPattern=function(node){};BaseRegExpVisitor.prototype.visitFlags=function(node){};BaseRegExpVisitor.prototype.visitDisjunction=function(node){};\nBaseRegExpVisitor.prototype.visitAlternative=function(node){};BaseRegExpVisitor.prototype.visitStartAnchor=function(node){};BaseRegExpVisitor.prototype.visitEndAnchor=function(node){};BaseRegExpVisitor.prototype.visitWordBoundary=function(node){};BaseRegExpVisitor.prototype.visitNonWordBoundary=function(node){};BaseRegExpVisitor.prototype.visitLookahead=function(node){};BaseRegExpVisitor.prototype.visitNegativeLookahead=function(node){};BaseRegExpVisitor.prototype.visitCharacter=function(node){};\nBaseRegExpVisitor.prototype.visitSet=function(node){};BaseRegExpVisitor.prototype.visitGroup=function(node){};BaseRegExpVisitor.prototype.visitGroupBackReference=function(node){};BaseRegExpVisitor.prototype.visitQuantifier=function(node){};return{RegExpParser,BaseRegExpVisitor,VERSION:\"0.5.0\"}})}","~:source","shadow$provide[\"module$node_modules$regexp_to_ast$lib$regexp_to_ast\"] = function(global,require,module,exports) {\n;(function(root, factory) {\n    // istanbul ignore next\n    if (typeof define === \"function\" && define.amd) {\n        // istanbul ignore next\n        define([], factory)\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory()\n    } else {\n        // istanbul ignore next\n        root.regexpToAst = factory()\n    }\n})(\n    typeof self !== \"undefined\"\n        ? // istanbul ignore next\n          self\n        : this,\n    function() {\n        // references\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n        function RegExpParser() {}\n\n        RegExpParser.prototype.saveState = function() {\n            return {\n                idx: this.idx,\n                input: this.input,\n                groupIdx: this.groupIdx\n            }\n        }\n\n        RegExpParser.prototype.restoreState = function(newState) {\n            this.idx = newState.idx\n            this.input = newState.input\n            this.groupIdx = newState.groupIdx\n        }\n\n        RegExpParser.prototype.pattern = function(input) {\n            // parser state\n            this.idx = 0\n            this.input = input\n            this.groupIdx = 0\n\n            this.consumeChar(\"/\")\n            var value = this.disjunction()\n            this.consumeChar(\"/\")\n\n            var flags = {\n                type: \"Flags\",\n                loc: { begin: this.idx, end: input.length },\n                global: false,\n                ignoreCase: false,\n                multiLine: false,\n                unicode: false,\n                sticky: false\n            }\n\n            while (this.isRegExpFlag()) {\n                switch (this.popChar()) {\n                    case \"g\":\n                        addFlag(flags, \"global\")\n                        break\n                    case \"i\":\n                        addFlag(flags, \"ignoreCase\")\n                        break\n                    case \"m\":\n                        addFlag(flags, \"multiLine\")\n                        break\n                    case \"u\":\n                        addFlag(flags, \"unicode\")\n                        break\n                    case \"y\":\n                        addFlag(flags, \"sticky\")\n                        break\n                }\n            }\n\n            if (this.idx !== this.input.length) {\n                throw Error(\n                    \"Redundant input: \" + this.input.substring(this.idx)\n                )\n            }\n            return {\n                type: \"Pattern\",\n                flags: flags,\n                value: value,\n                loc: this.loc(0)\n            }\n        }\n\n        RegExpParser.prototype.disjunction = function() {\n            var alts = []\n            var begin = this.idx\n\n            alts.push(this.alternative())\n\n            while (this.peekChar() === \"|\") {\n                this.consumeChar(\"|\")\n                alts.push(this.alternative())\n            }\n\n            return { type: \"Disjunction\", value: alts, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.alternative = function() {\n            var terms = []\n            var begin = this.idx\n\n            while (this.isTerm()) {\n                terms.push(this.term())\n            }\n\n            return { type: \"Alternative\", value: terms, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.term = function() {\n            if (this.isAssertion()) {\n                return this.assertion()\n            } else {\n                return this.atom()\n            }\n        }\n\n        RegExpParser.prototype.assertion = function() {\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"^\":\n                    return {\n                        type: \"StartAnchor\",\n                        loc: this.loc(begin)\n                    }\n                case \"$\":\n                    return { type: \"EndAnchor\", loc: this.loc(begin) }\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.popChar()) {\n                        case \"b\":\n                            return {\n                                type: \"WordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                        case \"B\":\n                            return {\n                                type: \"NonWordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                    }\n                    // istanbul ignore next\n                    throw Error(\"Invalid Assertion Escape\")\n                // '(?=' or '(?!'\n                case \"(\":\n                    this.consumeChar(\"?\")\n\n                    var type\n                    switch (this.popChar()) {\n                        case \"=\":\n                            type = \"Lookahead\"\n                            break\n                        case \"!\":\n                            type = \"NegativeLookahead\"\n                            break\n                    }\n                    ASSERT_EXISTS(type)\n\n                    var disjunction = this.disjunction()\n\n                    this.consumeChar(\")\")\n\n                    return {\n                        type: type,\n                        value: disjunction,\n                        loc: this.loc(begin)\n                    }\n            }\n            // istanbul ignore next\n            ASSERT_NEVER_REACH_HERE()\n        }\n\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\n            var range\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"*\":\n                    range = {\n                        atLeast: 0,\n                        atMost: Infinity\n                    }\n                    break\n                case \"+\":\n                    range = {\n                        atLeast: 1,\n                        atMost: Infinity\n                    }\n                    break\n                case \"?\":\n                    range = {\n                        atLeast: 0,\n                        atMost: 1\n                    }\n                    break\n                case \"{\":\n                    var atLeast = this.integerIncludingZero()\n                    switch (this.popChar()) {\n                        case \"}\":\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atLeast\n                            }\n                            break\n                        case \",\":\n                            var atMost\n                            if (this.isDigit()) {\n                                atMost = this.integerIncludingZero()\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: atMost\n                                }\n                            } else {\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: Infinity\n                                }\n                            }\n                            this.consumeChar(\"}\")\n                            break\n                    }\n                    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                    // causes severe performance degradations\n                    if (isBacktracking === true && range === undefined) {\n                        return undefined\n                    }\n                    ASSERT_EXISTS(range)\n                    break\n            }\n\n            // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n            // causes severe performance degradations\n            if (isBacktracking === true && range === undefined) {\n                return undefined\n            }\n\n            ASSERT_EXISTS(range)\n\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\")\n                range.greedy = false\n            } else {\n                range.greedy = true\n            }\n\n            range.type = \"Quantifier\"\n            range.loc = this.loc(begin)\n            return range\n        }\n\n        RegExpParser.prototype.atom = function() {\n            var atom\n            var begin = this.idx\n            switch (this.peekChar()) {\n                case \".\":\n                    atom = this.dotAll()\n                    break\n                case \"\\\\\":\n                    atom = this.atomEscape()\n                    break\n                case \"[\":\n                    atom = this.characterClass()\n                    break\n                case \"(\":\n                    atom = this.group()\n                    break\n            }\n\n            if (atom === undefined && this.isPatternCharacter()) {\n                atom = this.patternCharacter()\n            }\n\n            ASSERT_EXISTS(atom)\n\n            atom.loc = this.loc(begin)\n\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier()\n            }\n\n            return atom\n        }\n\n        RegExpParser.prototype.dotAll = function() {\n            this.consumeChar(\".\")\n            return {\n                type: \"Set\",\n                complement: true,\n                value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n            }\n        }\n\n        RegExpParser.prototype.atomEscape = function() {\n            this.consumeChar(\"\\\\\")\n\n            switch (this.peekChar()) {\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    return this.decimalEscapeAtom()\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.decimalEscapeAtom = function() {\n            var value = this.positiveInteger()\n\n            return { type: \"GroupBackReference\", value: value }\n        }\n\n        RegExpParser.prototype.characterClassEscape = function() {\n            var set\n            var complement = false\n            switch (this.popChar()) {\n                case \"d\":\n                    set = digitsCharCodes\n                    break\n                case \"D\":\n                    set = digitsCharCodes\n                    complement = true\n                    break\n                case \"s\":\n                    set = whitespaceCodes\n                    break\n                case \"S\":\n                    set = whitespaceCodes\n                    complement = true\n                    break\n                case \"w\":\n                    set = wordCharCodes\n                    break\n                case \"W\":\n                    set = wordCharCodes\n                    complement = true\n                    break\n            }\n\n            ASSERT_EXISTS(set)\n\n            return { type: \"Set\", value: set, complement: complement }\n        }\n\n        RegExpParser.prototype.controlEscapeAtom = function() {\n            var escapeCode\n            switch (this.popChar()) {\n                case \"f\":\n                    escapeCode = cc(\"\\f\")\n                    break\n                case \"n\":\n                    escapeCode = cc(\"\\n\")\n                    break\n                case \"r\":\n                    escapeCode = cc(\"\\r\")\n                    break\n                case \"t\":\n                    escapeCode = cc(\"\\t\")\n                    break\n                case \"v\":\n                    escapeCode = cc(\"\\v\")\n                    break\n            }\n            ASSERT_EXISTS(escapeCode)\n\n            return { type: \"Character\", value: escapeCode }\n        }\n\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\n            this.consumeChar(\"c\")\n            var letter = this.popChar()\n            if (/[a-zA-Z]/.test(letter) === false) {\n                throw Error(\"Invalid \")\n            }\n\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\n            return { type: \"Character\", value: letterCode }\n        }\n\n        RegExpParser.prototype.nulCharacterAtom = function() {\n            // TODO implement '[lookahead ∉ DecimalDigit]'\n            // TODO: for the deprecated octal escape sequence\n            this.consumeChar(\"0\")\n            return { type: \"Character\", value: cc(\"\\0\") }\n        }\n\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\n            this.consumeChar(\"x\")\n            return this.parseHexDigits(2)\n        }\n\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\n            this.consumeChar(\"u\")\n            return this.parseHexDigits(4)\n        }\n\n        RegExpParser.prototype.identityEscapeAtom = function() {\n            // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n            var escapedChar = this.popChar()\n            return { type: \"Character\", value: cc(escapedChar) }\n        }\n\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \"]\":\n                    throw Error(\"TBD\")\n                default:\n                    var nextChar = this.popChar()\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n\n        RegExpParser.prototype.characterClass = function() {\n            var set = []\n            var complement = false\n            this.consumeChar(\"[\")\n            if (this.peekChar(0) === \"^\") {\n                this.consumeChar(\"^\")\n                complement = true\n            }\n\n            while (this.isClassAtom()) {\n                var from = this.classAtom()\n                var isFromSingleChar = from.type === \"Character\"\n                if (isFromSingleChar && this.isRangeDash()) {\n                    this.consumeChar(\"-\")\n                    var to = this.classAtom()\n                    var isToSingleChar = to.type === \"Character\"\n\n                    // a range can only be used when both sides are single characters\n                    if (isToSingleChar) {\n                        if (to.value < from.value) {\n                            throw Error(\"Range out of order in character class\")\n                        }\n                        set.push({ from: from.value, to: to.value })\n                    } else {\n                        // literal dash\n                        insertToSet(from.value, set)\n                        set.push(cc(\"-\"))\n                        insertToSet(to.value, set)\n                    }\n                } else {\n                    insertToSet(from.value, set)\n                }\n            }\n\n            this.consumeChar(\"]\")\n\n            return { type: \"Set\", complement: complement, value: set }\n        }\n\n        RegExpParser.prototype.classAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"]\":\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                    throw Error(\"TBD\")\n                case \"\\\\\":\n                    return this.classEscape()\n                default:\n                    return this.classPatternCharacterAtom()\n            }\n        }\n\n        RegExpParser.prototype.classEscape = function() {\n            this.consumeChar(\"\\\\\")\n            switch (this.peekChar()) {\n                // Matches a backspace.\n                // (Not to be confused with \\b word boundary outside characterClass)\n                case \"b\":\n                    this.consumeChar(\"b\")\n                    return { type: \"Character\", value: cc(\"\\u0008\") }\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.group = function() {\n            var capturing = true\n            this.consumeChar(\"(\")\n            switch (this.peekChar(0)) {\n                case \"?\":\n                    this.consumeChar(\"?\")\n                    this.consumeChar(\":\")\n                    capturing = false\n                    break\n                default:\n                    this.groupIdx++\n                    break\n            }\n            var value = this.disjunction()\n            this.consumeChar(\")\")\n\n            var groupAst = {\n                type: \"Group\",\n                capturing: capturing,\n                value: value\n            }\n\n            if (capturing) {\n                groupAst.idx = this.groupIdx\n            }\n\n            return groupAst\n        }\n\n        RegExpParser.prototype.positiveInteger = function() {\n            var number = this.popChar()\n\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\n            // still implementing this error checking in case this ever changes.\n            if (decimalPatternNoZero.test(number) === false) {\n                throw Error(\"Expecting a positive integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.integerIncludingZero = function() {\n            var number = this.popChar()\n            if (decimalPattern.test(number) === false) {\n                throw Error(\"Expecting an integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.patternCharacter = function() {\n            var nextChar = this.popChar()\n            switch (nextChar) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"^\":\n                // istanbul ignore next\n                case \"$\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \".\":\n                // istanbul ignore next\n                case \"*\":\n                // istanbul ignore next\n                case \"+\":\n                // istanbul ignore next\n                case \"?\":\n                // istanbul ignore next\n                case \"(\":\n                // istanbul ignore next\n                case \")\":\n                // istanbul ignore next\n                case \"[\":\n                // istanbul ignore next\n                case \"|\":\n                    // istanbul ignore next\n                    throw Error(\"TBD\")\n                default:\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n        RegExpParser.prototype.isRegExpFlag = function() {\n            switch (this.peekChar(0)) {\n                case \"g\":\n                case \"i\":\n                case \"m\":\n                case \"u\":\n                case \"y\":\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isRangeDash = function() {\n            return this.peekChar() === \"-\" && this.isClassAtom(1)\n        }\n\n        RegExpParser.prototype.isDigit = function() {\n            return decimalPattern.test(this.peekChar(0))\n        }\n\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n\n            switch (this.peekChar(howMuch)) {\n                case \"]\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.isTerm = function() {\n            return this.isAtom() || this.isAssertion()\n        }\n\n        RegExpParser.prototype.isAtom = function() {\n            if (this.isPatternCharacter()) {\n                return true\n            }\n\n            switch (this.peekChar(0)) {\n                case \".\":\n                case \"\\\\\": // atomEscape\n                case \"[\": // characterClass\n                // TODO: isAtom must be called before isAssertion - disambiguate\n                case \"(\": // group\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isAssertion = function() {\n            switch (this.peekChar(0)) {\n                case \"^\":\n                case \"$\":\n                    return true\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.peekChar(1)) {\n                        case \"b\":\n                        case \"B\":\n                            return true\n                        default:\n                            return false\n                    }\n                // '(?=' or '(?!'\n                case \"(\":\n                    return (\n                        this.peekChar(1) === \"?\" &&\n                        (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n                    )\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isQuantifier = function() {\n            var prevState = this.saveState()\n            try {\n                return this.quantifier(true) !== undefined\n            } catch (e) {\n                return false\n            } finally {\n                this.restoreState(prevState)\n            }\n        }\n\n        RegExpParser.prototype.isPatternCharacter = function() {\n            switch (this.peekChar()) {\n                case \"^\":\n                case \"$\":\n                case \"\\\\\":\n                case \".\":\n                case \"*\":\n                case \"+\":\n                case \"?\":\n                case \"(\":\n                case \")\":\n                case \"[\":\n                case \"|\":\n                case \"/\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\n            var hexString = \"\"\n            for (var i = 0; i < howMany; i++) {\n                var hexChar = this.popChar()\n                if (hexDigitPattern.test(hexChar) === false) {\n                    throw Error(\"Expecting a HexDecimal digits\")\n                }\n                hexString += hexChar\n            }\n            var charCode = parseInt(hexString, 16)\n            return { type: \"Character\", value: charCode }\n        }\n\n        RegExpParser.prototype.peekChar = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n            return this.input[this.idx + howMuch]\n        }\n\n        RegExpParser.prototype.popChar = function() {\n            var nextChar = this.peekChar(0)\n            this.consumeChar()\n            return nextChar\n        }\n\n        RegExpParser.prototype.consumeChar = function(char) {\n            if (char !== undefined && this.input[this.idx] !== char) {\n                throw Error(\n                    \"Expected: '\" +\n                        char +\n                        \"' but found: '\" +\n                        this.input[this.idx] +\n                        \"' at offset: \" +\n                        this.idx\n                )\n            }\n\n            if (this.idx >= this.input.length) {\n                throw Error(\"Unexpected end of input\")\n            }\n            this.idx++\n        }\n\n        RegExpParser.prototype.loc = function(begin) {\n            return { begin: begin, end: this.idx }\n        }\n\n        // consts and utilities\n        var hexDigitPattern = /[0-9a-fA-F]/\n        var decimalPattern = /[0-9]/\n        var decimalPatternNoZero = /[1-9]/\n\n        function cc(char) {\n            return char.charCodeAt(0)\n        }\n\n        function insertToSet(item, set) {\n            if (item.length !== undefined) {\n                item.forEach(function(subItem) {\n                    set.push(subItem)\n                })\n            } else {\n                set.push(item)\n            }\n        }\n\n        function addFlag(flagObj, flagKey) {\n            if (flagObj[flagKey] === true) {\n                throw \"duplicate flag \" + flagKey\n            }\n\n            flagObj[flagKey] = true\n        }\n\n        function ASSERT_EXISTS(obj) {\n            // istanbul ignore next\n            if (obj === undefined) {\n                throw Error(\"Internal Error - Should never get here!\")\n            }\n        }\n\n        // istanbul ignore next\n        function ASSERT_NEVER_REACH_HERE() {\n            throw Error(\"Internal Error - Should never get here!\")\n        }\n\n        var i\n        var digitsCharCodes = []\n        for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n            digitsCharCodes.push(i)\n        }\n\n        var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes)\n        for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n        var whitespaceCodes = [\n            cc(\" \"),\n            cc(\"\\f\"),\n            cc(\"\\n\"),\n            cc(\"\\r\"),\n            cc(\"\\t\"),\n            cc(\"\\v\"),\n            cc(\"\\t\"),\n            cc(\"\\u00a0\"),\n            cc(\"\\u1680\"),\n            cc(\"\\u2000\"),\n            cc(\"\\u2001\"),\n            cc(\"\\u2002\"),\n            cc(\"\\u2003\"),\n            cc(\"\\u2004\"),\n            cc(\"\\u2005\"),\n            cc(\"\\u2006\"),\n            cc(\"\\u2007\"),\n            cc(\"\\u2008\"),\n            cc(\"\\u2009\"),\n            cc(\"\\u200a\"),\n            cc(\"\\u2028\"),\n            cc(\"\\u2029\"),\n            cc(\"\\u202f\"),\n            cc(\"\\u205f\"),\n            cc(\"\\u3000\"),\n            cc(\"\\ufeff\")\n        ]\n\n        function BaseRegExpVisitor() {}\n\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\n            for (var key in node) {\n                var child = node[key]\n                /* istanbul ignore else */\n                if (node.hasOwnProperty(key)) {\n                    if (child.type !== undefined) {\n                        this.visit(child)\n                    } else if (Array.isArray(child)) {\n                        child.forEach(function(subChild) {\n                            this.visit(subChild)\n                        }, this)\n                    }\n                }\n            }\n        }\n\n        BaseRegExpVisitor.prototype.visit = function(node) {\n            switch (node.type) {\n                case \"Pattern\":\n                    this.visitPattern(node)\n                    break\n                case \"Flags\":\n                    this.visitFlags(node)\n                    break\n                case \"Disjunction\":\n                    this.visitDisjunction(node)\n                    break\n                case \"Alternative\":\n                    this.visitAlternative(node)\n                    break\n                case \"StartAnchor\":\n                    this.visitStartAnchor(node)\n                    break\n                case \"EndAnchor\":\n                    this.visitEndAnchor(node)\n                    break\n                case \"WordBoundary\":\n                    this.visitWordBoundary(node)\n                    break\n                case \"NonWordBoundary\":\n                    this.visitNonWordBoundary(node)\n                    break\n                case \"Lookahead\":\n                    this.visitLookahead(node)\n                    break\n                case \"NegativeLookahead\":\n                    this.visitNegativeLookahead(node)\n                    break\n                case \"Character\":\n                    this.visitCharacter(node)\n                    break\n                case \"Set\":\n                    this.visitSet(node)\n                    break\n                case \"Group\":\n                    this.visitGroup(node)\n                    break\n                case \"GroupBackReference\":\n                    this.visitGroupBackReference(node)\n                    break\n                case \"Quantifier\":\n                    this.visitQuantifier(node)\n                    break\n            }\n\n            this.visitChildren(node)\n        }\n\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\n\n        // Assertion\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\n\n        // atoms\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\n\n        return {\n            RegExpParser: RegExpParser,\n            BaseRegExpVisitor: BaseRegExpVisitor,\n            VERSION: \"0.5.0\"\n        }\n    }\n)\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["visitFlags","groupIdx","quantifier","visitEndAnchor","atomEscape","isAtom","begin","peekChar","visitAlternative","consumeChar","visitGroupBackReference","controlEscapeAtom","hexEscapeSequenceAtom","group","disjunction","visit","term","regExpUnicodeEscapeSequenceAtom","visitStartAnchor","visitGroup","visitWordBoundary","flags","isAssertion","visitCharacter","unicode","saveState","isPatternCharacter","VERSION","isQuantifier","dotAll","atMost","characterClass","value","patternCharacter","classEscape","RegExpParser","nulCharacterAtom","multiLine","BaseRegExpVisitor","visitSet","atom","integerIncludingZero","classPatternCharacterAtom","greedy","ignoreCase","complement","visitNonWordBoundary","popChar","input","classAtom","visitChildren","decimalEscapeAtom","parseHexDigits","pattern","type","loc","visitPattern","visitLookahead","isRangeDash","restoreState","from","visitNegativeLookahead","capturing","atLeast","characterClassEscape","isDigit","regexpToAst","isTerm","assertion","idx","global","sticky","to","alternative","end","visitDisjunction","visitQuantifier","isRegExpFlag","isClassAtom","controlLetterEscapeAtom","positiveInteger","identityEscapeAtom"]],"~:compiled-at",1630917515664,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$regexp_to_ast$lib$regexp_to_ast.js\",\n\"lineCount\":28,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/regexp-to-ast/lib/regexp-to-ast.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$regexp_to_ast$lib$regexp_to_ast\\\"] = function(global,require,module,exports) {\\n;(function(root, factory) {\\n    // istanbul ignore next\\n    if (typeof define === \\\"function\\\" && define.amd) {\\n        // istanbul ignore next\\n        define([], factory)\\n    } else if (typeof module === \\\"object\\\" && module.exports) {\\n        module.exports = factory()\\n    } else {\\n        // istanbul ignore next\\n        root.regexpToAst = factory()\\n    }\\n})(\\n    typeof self !== \\\"undefined\\\"\\n        ? // istanbul ignore next\\n          self\\n        : this,\\n    function() {\\n        // references\\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\\n        function RegExpParser() {}\\n\\n        RegExpParser.prototype.saveState = function() {\\n            return {\\n                idx: this.idx,\\n                input: this.input,\\n                groupIdx: this.groupIdx\\n            }\\n        }\\n\\n        RegExpParser.prototype.restoreState = function(newState) {\\n            this.idx = newState.idx\\n            this.input = newState.input\\n            this.groupIdx = newState.groupIdx\\n        }\\n\\n        RegExpParser.prototype.pattern = function(input) {\\n            // parser state\\n            this.idx = 0\\n            this.input = input\\n            this.groupIdx = 0\\n\\n            this.consumeChar(\\\"/\\\")\\n            var value = this.disjunction()\\n            this.consumeChar(\\\"/\\\")\\n\\n            var flags = {\\n                type: \\\"Flags\\\",\\n                loc: { begin: this.idx, end: input.length },\\n                global: false,\\n                ignoreCase: false,\\n                multiLine: false,\\n                unicode: false,\\n                sticky: false\\n            }\\n\\n            while (this.isRegExpFlag()) {\\n                switch (this.popChar()) {\\n                    case \\\"g\\\":\\n                        addFlag(flags, \\\"global\\\")\\n                        break\\n                    case \\\"i\\\":\\n                        addFlag(flags, \\\"ignoreCase\\\")\\n                        break\\n                    case \\\"m\\\":\\n                        addFlag(flags, \\\"multiLine\\\")\\n                        break\\n                    case \\\"u\\\":\\n                        addFlag(flags, \\\"unicode\\\")\\n                        break\\n                    case \\\"y\\\":\\n                        addFlag(flags, \\\"sticky\\\")\\n                        break\\n                }\\n            }\\n\\n            if (this.idx !== this.input.length) {\\n                throw Error(\\n                    \\\"Redundant input: \\\" + this.input.substring(this.idx)\\n                )\\n            }\\n            return {\\n                type: \\\"Pattern\\\",\\n                flags: flags,\\n                value: value,\\n                loc: this.loc(0)\\n            }\\n        }\\n\\n        RegExpParser.prototype.disjunction = function() {\\n            var alts = []\\n            var begin = this.idx\\n\\n            alts.push(this.alternative())\\n\\n            while (this.peekChar() === \\\"|\\\") {\\n                this.consumeChar(\\\"|\\\")\\n                alts.push(this.alternative())\\n            }\\n\\n            return { type: \\\"Disjunction\\\", value: alts, loc: this.loc(begin) }\\n        }\\n\\n        RegExpParser.prototype.alternative = function() {\\n            var terms = []\\n            var begin = this.idx\\n\\n            while (this.isTerm()) {\\n                terms.push(this.term())\\n            }\\n\\n            return { type: \\\"Alternative\\\", value: terms, loc: this.loc(begin) }\\n        }\\n\\n        RegExpParser.prototype.term = function() {\\n            if (this.isAssertion()) {\\n                return this.assertion()\\n            } else {\\n                return this.atom()\\n            }\\n        }\\n\\n        RegExpParser.prototype.assertion = function() {\\n            var begin = this.idx\\n            switch (this.popChar()) {\\n                case \\\"^\\\":\\n                    return {\\n                        type: \\\"StartAnchor\\\",\\n                        loc: this.loc(begin)\\n                    }\\n                case \\\"$\\\":\\n                    return { type: \\\"EndAnchor\\\", loc: this.loc(begin) }\\n                // '\\\\b' or '\\\\B'\\n                case \\\"\\\\\\\\\\\":\\n                    switch (this.popChar()) {\\n                        case \\\"b\\\":\\n                            return {\\n                                type: \\\"WordBoundary\\\",\\n                                loc: this.loc(begin)\\n                            }\\n                        case \\\"B\\\":\\n                            return {\\n                                type: \\\"NonWordBoundary\\\",\\n                                loc: this.loc(begin)\\n                            }\\n                    }\\n                    // istanbul ignore next\\n                    throw Error(\\\"Invalid Assertion Escape\\\")\\n                // '(?=' or '(?!'\\n                case \\\"(\\\":\\n                    this.consumeChar(\\\"?\\\")\\n\\n                    var type\\n                    switch (this.popChar()) {\\n                        case \\\"=\\\":\\n                            type = \\\"Lookahead\\\"\\n                            break\\n                        case \\\"!\\\":\\n                            type = \\\"NegativeLookahead\\\"\\n                            break\\n                    }\\n                    ASSERT_EXISTS(type)\\n\\n                    var disjunction = this.disjunction()\\n\\n                    this.consumeChar(\\\")\\\")\\n\\n                    return {\\n                        type: type,\\n                        value: disjunction,\\n                        loc: this.loc(begin)\\n                    }\\n            }\\n            // istanbul ignore next\\n            ASSERT_NEVER_REACH_HERE()\\n        }\\n\\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\\n            var range\\n            var begin = this.idx\\n            switch (this.popChar()) {\\n                case \\\"*\\\":\\n                    range = {\\n                        atLeast: 0,\\n                        atMost: Infinity\\n                    }\\n                    break\\n                case \\\"+\\\":\\n                    range = {\\n                        atLeast: 1,\\n                        atMost: Infinity\\n                    }\\n                    break\\n                case \\\"?\\\":\\n                    range = {\\n                        atLeast: 0,\\n                        atMost: 1\\n                    }\\n                    break\\n                case \\\"{\\\":\\n                    var atLeast = this.integerIncludingZero()\\n                    switch (this.popChar()) {\\n                        case \\\"}\\\":\\n                            range = {\\n                                atLeast: atLeast,\\n                                atMost: atLeast\\n                            }\\n                            break\\n                        case \\\",\\\":\\n                            var atMost\\n                            if (this.isDigit()) {\\n                                atMost = this.integerIncludingZero()\\n                                range = {\\n                                    atLeast: atLeast,\\n                                    atMost: atMost\\n                                }\\n                            } else {\\n                                range = {\\n                                    atLeast: atLeast,\\n                                    atMost: Infinity\\n                                }\\n                            }\\n                            this.consumeChar(\\\"}\\\")\\n                            break\\n                    }\\n                    // throwing exceptions from \\\"ASSERT_EXISTS\\\" during backtracking\\n                    // causes severe performance degradations\\n                    if (isBacktracking === true && range === undefined) {\\n                        return undefined\\n                    }\\n                    ASSERT_EXISTS(range)\\n                    break\\n            }\\n\\n            // throwing exceptions from \\\"ASSERT_EXISTS\\\" during backtracking\\n            // causes severe performance degradations\\n            if (isBacktracking === true && range === undefined) {\\n                return undefined\\n            }\\n\\n            ASSERT_EXISTS(range)\\n\\n            if (this.peekChar(0) === \\\"?\\\") {\\n                this.consumeChar(\\\"?\\\")\\n                range.greedy = false\\n            } else {\\n                range.greedy = true\\n            }\\n\\n            range.type = \\\"Quantifier\\\"\\n            range.loc = this.loc(begin)\\n            return range\\n        }\\n\\n        RegExpParser.prototype.atom = function() {\\n            var atom\\n            var begin = this.idx\\n            switch (this.peekChar()) {\\n                case \\\".\\\":\\n                    atom = this.dotAll()\\n                    break\\n                case \\\"\\\\\\\\\\\":\\n                    atom = this.atomEscape()\\n                    break\\n                case \\\"[\\\":\\n                    atom = this.characterClass()\\n                    break\\n                case \\\"(\\\":\\n                    atom = this.group()\\n                    break\\n            }\\n\\n            if (atom === undefined && this.isPatternCharacter()) {\\n                atom = this.patternCharacter()\\n            }\\n\\n            ASSERT_EXISTS(atom)\\n\\n            atom.loc = this.loc(begin)\\n\\n            if (this.isQuantifier()) {\\n                atom.quantifier = this.quantifier()\\n            }\\n\\n            return atom\\n        }\\n\\n        RegExpParser.prototype.dotAll = function() {\\n            this.consumeChar(\\\".\\\")\\n            return {\\n                type: \\\"Set\\\",\\n                complement: true,\\n                value: [cc(\\\"\\\\n\\\"), cc(\\\"\\\\r\\\"), cc(\\\"\\\\u2028\\\"), cc(\\\"\\\\u2029\\\")]\\n            }\\n        }\\n\\n        RegExpParser.prototype.atomEscape = function() {\\n            this.consumeChar(\\\"\\\\\\\\\\\")\\n\\n            switch (this.peekChar()) {\\n                case \\\"1\\\":\\n                case \\\"2\\\":\\n                case \\\"3\\\":\\n                case \\\"4\\\":\\n                case \\\"5\\\":\\n                case \\\"6\\\":\\n                case \\\"7\\\":\\n                case \\\"8\\\":\\n                case \\\"9\\\":\\n                    return this.decimalEscapeAtom()\\n                case \\\"d\\\":\\n                case \\\"D\\\":\\n                case \\\"s\\\":\\n                case \\\"S\\\":\\n                case \\\"w\\\":\\n                case \\\"W\\\":\\n                    return this.characterClassEscape()\\n                case \\\"f\\\":\\n                case \\\"n\\\":\\n                case \\\"r\\\":\\n                case \\\"t\\\":\\n                case \\\"v\\\":\\n                    return this.controlEscapeAtom()\\n                case \\\"c\\\":\\n                    return this.controlLetterEscapeAtom()\\n                case \\\"0\\\":\\n                    return this.nulCharacterAtom()\\n                case \\\"x\\\":\\n                    return this.hexEscapeSequenceAtom()\\n                case \\\"u\\\":\\n                    return this.regExpUnicodeEscapeSequenceAtom()\\n                default:\\n                    return this.identityEscapeAtom()\\n            }\\n        }\\n\\n        RegExpParser.prototype.decimalEscapeAtom = function() {\\n            var value = this.positiveInteger()\\n\\n            return { type: \\\"GroupBackReference\\\", value: value }\\n        }\\n\\n        RegExpParser.prototype.characterClassEscape = function() {\\n            var set\\n            var complement = false\\n            switch (this.popChar()) {\\n                case \\\"d\\\":\\n                    set = digitsCharCodes\\n                    break\\n                case \\\"D\\\":\\n                    set = digitsCharCodes\\n                    complement = true\\n                    break\\n                case \\\"s\\\":\\n                    set = whitespaceCodes\\n                    break\\n                case \\\"S\\\":\\n                    set = whitespaceCodes\\n                    complement = true\\n                    break\\n                case \\\"w\\\":\\n                    set = wordCharCodes\\n                    break\\n                case \\\"W\\\":\\n                    set = wordCharCodes\\n                    complement = true\\n                    break\\n            }\\n\\n            ASSERT_EXISTS(set)\\n\\n            return { type: \\\"Set\\\", value: set, complement: complement }\\n        }\\n\\n        RegExpParser.prototype.controlEscapeAtom = function() {\\n            var escapeCode\\n            switch (this.popChar()) {\\n                case \\\"f\\\":\\n                    escapeCode = cc(\\\"\\\\f\\\")\\n                    break\\n                case \\\"n\\\":\\n                    escapeCode = cc(\\\"\\\\n\\\")\\n                    break\\n                case \\\"r\\\":\\n                    escapeCode = cc(\\\"\\\\r\\\")\\n                    break\\n                case \\\"t\\\":\\n                    escapeCode = cc(\\\"\\\\t\\\")\\n                    break\\n                case \\\"v\\\":\\n                    escapeCode = cc(\\\"\\\\v\\\")\\n                    break\\n            }\\n            ASSERT_EXISTS(escapeCode)\\n\\n            return { type: \\\"Character\\\", value: escapeCode }\\n        }\\n\\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\\n            this.consumeChar(\\\"c\\\")\\n            var letter = this.popChar()\\n            if (/[a-zA-Z]/.test(letter) === false) {\\n                throw Error(\\\"Invalid \\\")\\n            }\\n\\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\\n            return { type: \\\"Character\\\", value: letterCode }\\n        }\\n\\n        RegExpParser.prototype.nulCharacterAtom = function() {\\n            // TODO implement '[lookahead \\u2209 DecimalDigit]'\\n            // TODO: for the deprecated octal escape sequence\\n            this.consumeChar(\\\"0\\\")\\n            return { type: \\\"Character\\\", value: cc(\\\"\\\\0\\\") }\\n        }\\n\\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\\n            this.consumeChar(\\\"x\\\")\\n            return this.parseHexDigits(2)\\n        }\\n\\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\\n            this.consumeChar(\\\"u\\\")\\n            return this.parseHexDigits(4)\\n        }\\n\\n        RegExpParser.prototype.identityEscapeAtom = function() {\\n            // TODO: implement \\\"SourceCharacter but not UnicodeIDContinue\\\"\\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\\n            var escapedChar = this.popChar()\\n            return { type: \\\"Character\\\", value: cc(escapedChar) }\\n        }\\n\\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\\n            switch (this.peekChar()) {\\n                // istanbul ignore next\\n                case \\\"\\\\n\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\r\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\u2028\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\u2029\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\\\\\\\\":\\n                // istanbul ignore next\\n                case \\\"]\\\":\\n                    throw Error(\\\"TBD\\\")\\n                default:\\n                    var nextChar = this.popChar()\\n                    return { type: \\\"Character\\\", value: cc(nextChar) }\\n            }\\n        }\\n\\n        RegExpParser.prototype.characterClass = function() {\\n            var set = []\\n            var complement = false\\n            this.consumeChar(\\\"[\\\")\\n            if (this.peekChar(0) === \\\"^\\\") {\\n                this.consumeChar(\\\"^\\\")\\n                complement = true\\n            }\\n\\n            while (this.isClassAtom()) {\\n                var from = this.classAtom()\\n                var isFromSingleChar = from.type === \\\"Character\\\"\\n                if (isFromSingleChar && this.isRangeDash()) {\\n                    this.consumeChar(\\\"-\\\")\\n                    var to = this.classAtom()\\n                    var isToSingleChar = to.type === \\\"Character\\\"\\n\\n                    // a range can only be used when both sides are single characters\\n                    if (isToSingleChar) {\\n                        if (to.value < from.value) {\\n                            throw Error(\\\"Range out of order in character class\\\")\\n                        }\\n                        set.push({ from: from.value, to: to.value })\\n                    } else {\\n                        // literal dash\\n                        insertToSet(from.value, set)\\n                        set.push(cc(\\\"-\\\"))\\n                        insertToSet(to.value, set)\\n                    }\\n                } else {\\n                    insertToSet(from.value, set)\\n                }\\n            }\\n\\n            this.consumeChar(\\\"]\\\")\\n\\n            return { type: \\\"Set\\\", complement: complement, value: set }\\n        }\\n\\n        RegExpParser.prototype.classAtom = function() {\\n            switch (this.peekChar()) {\\n                // istanbul ignore next\\n                case \\\"]\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\n\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\r\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\u2028\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\u2029\\\":\\n                    throw Error(\\\"TBD\\\")\\n                case \\\"\\\\\\\\\\\":\\n                    return this.classEscape()\\n                default:\\n                    return this.classPatternCharacterAtom()\\n            }\\n        }\\n\\n        RegExpParser.prototype.classEscape = function() {\\n            this.consumeChar(\\\"\\\\\\\\\\\")\\n            switch (this.peekChar()) {\\n                // Matches a backspace.\\n                // (Not to be confused with \\\\b word boundary outside characterClass)\\n                case \\\"b\\\":\\n                    this.consumeChar(\\\"b\\\")\\n                    return { type: \\\"Character\\\", value: cc(\\\"\\\\u0008\\\") }\\n                case \\\"d\\\":\\n                case \\\"D\\\":\\n                case \\\"s\\\":\\n                case \\\"S\\\":\\n                case \\\"w\\\":\\n                case \\\"W\\\":\\n                    return this.characterClassEscape()\\n                case \\\"f\\\":\\n                case \\\"n\\\":\\n                case \\\"r\\\":\\n                case \\\"t\\\":\\n                case \\\"v\\\":\\n                    return this.controlEscapeAtom()\\n                case \\\"c\\\":\\n                    return this.controlLetterEscapeAtom()\\n                case \\\"0\\\":\\n                    return this.nulCharacterAtom()\\n                case \\\"x\\\":\\n                    return this.hexEscapeSequenceAtom()\\n                case \\\"u\\\":\\n                    return this.regExpUnicodeEscapeSequenceAtom()\\n                default:\\n                    return this.identityEscapeAtom()\\n            }\\n        }\\n\\n        RegExpParser.prototype.group = function() {\\n            var capturing = true\\n            this.consumeChar(\\\"(\\\")\\n            switch (this.peekChar(0)) {\\n                case \\\"?\\\":\\n                    this.consumeChar(\\\"?\\\")\\n                    this.consumeChar(\\\":\\\")\\n                    capturing = false\\n                    break\\n                default:\\n                    this.groupIdx++\\n                    break\\n            }\\n            var value = this.disjunction()\\n            this.consumeChar(\\\")\\\")\\n\\n            var groupAst = {\\n                type: \\\"Group\\\",\\n                capturing: capturing,\\n                value: value\\n            }\\n\\n            if (capturing) {\\n                groupAst.idx = this.groupIdx\\n            }\\n\\n            return groupAst\\n        }\\n\\n        RegExpParser.prototype.positiveInteger = function() {\\n            var number = this.popChar()\\n\\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\\n            // still implementing this error checking in case this ever changes.\\n            if (decimalPatternNoZero.test(number) === false) {\\n                throw Error(\\\"Expecting a positive integer\\\")\\n            }\\n\\n            while (decimalPattern.test(this.peekChar(0))) {\\n                number += this.popChar()\\n            }\\n\\n            return parseInt(number, 10)\\n        }\\n\\n        RegExpParser.prototype.integerIncludingZero = function() {\\n            var number = this.popChar()\\n            if (decimalPattern.test(number) === false) {\\n                throw Error(\\\"Expecting an integer\\\")\\n            }\\n\\n            while (decimalPattern.test(this.peekChar(0))) {\\n                number += this.popChar()\\n            }\\n\\n            return parseInt(number, 10)\\n        }\\n\\n        RegExpParser.prototype.patternCharacter = function() {\\n            var nextChar = this.popChar()\\n            switch (nextChar) {\\n                // istanbul ignore next\\n                case \\\"\\\\n\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\r\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\u2028\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\u2029\\\":\\n                // istanbul ignore next\\n                case \\\"^\\\":\\n                // istanbul ignore next\\n                case \\\"$\\\":\\n                // istanbul ignore next\\n                case \\\"\\\\\\\\\\\":\\n                // istanbul ignore next\\n                case \\\".\\\":\\n                // istanbul ignore next\\n                case \\\"*\\\":\\n                // istanbul ignore next\\n                case \\\"+\\\":\\n                // istanbul ignore next\\n                case \\\"?\\\":\\n                // istanbul ignore next\\n                case \\\"(\\\":\\n                // istanbul ignore next\\n                case \\\")\\\":\\n                // istanbul ignore next\\n                case \\\"[\\\":\\n                // istanbul ignore next\\n                case \\\"|\\\":\\n                    // istanbul ignore next\\n                    throw Error(\\\"TBD\\\")\\n                default:\\n                    return { type: \\\"Character\\\", value: cc(nextChar) }\\n            }\\n        }\\n        RegExpParser.prototype.isRegExpFlag = function() {\\n            switch (this.peekChar(0)) {\\n                case \\\"g\\\":\\n                case \\\"i\\\":\\n                case \\\"m\\\":\\n                case \\\"u\\\":\\n                case \\\"y\\\":\\n                    return true\\n                default:\\n                    return false\\n            }\\n        }\\n\\n        RegExpParser.prototype.isRangeDash = function() {\\n            return this.peekChar() === \\\"-\\\" && this.isClassAtom(1)\\n        }\\n\\n        RegExpParser.prototype.isDigit = function() {\\n            return decimalPattern.test(this.peekChar(0))\\n        }\\n\\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\\n            if (howMuch === undefined) {\\n                howMuch = 0\\n            }\\n\\n            switch (this.peekChar(howMuch)) {\\n                case \\\"]\\\":\\n                case \\\"\\\\n\\\":\\n                case \\\"\\\\r\\\":\\n                case \\\"\\\\u2028\\\":\\n                case \\\"\\\\u2029\\\":\\n                    return false\\n                default:\\n                    return true\\n            }\\n        }\\n\\n        RegExpParser.prototype.isTerm = function() {\\n            return this.isAtom() || this.isAssertion()\\n        }\\n\\n        RegExpParser.prototype.isAtom = function() {\\n            if (this.isPatternCharacter()) {\\n                return true\\n            }\\n\\n            switch (this.peekChar(0)) {\\n                case \\\".\\\":\\n                case \\\"\\\\\\\\\\\": // atomEscape\\n                case \\\"[\\\": // characterClass\\n                // TODO: isAtom must be called before isAssertion - disambiguate\\n                case \\\"(\\\": // group\\n                    return true\\n                default:\\n                    return false\\n            }\\n        }\\n\\n        RegExpParser.prototype.isAssertion = function() {\\n            switch (this.peekChar(0)) {\\n                case \\\"^\\\":\\n                case \\\"$\\\":\\n                    return true\\n                // '\\\\b' or '\\\\B'\\n                case \\\"\\\\\\\\\\\":\\n                    switch (this.peekChar(1)) {\\n                        case \\\"b\\\":\\n                        case \\\"B\\\":\\n                            return true\\n                        default:\\n                            return false\\n                    }\\n                // '(?=' or '(?!'\\n                case \\\"(\\\":\\n                    return (\\n                        this.peekChar(1) === \\\"?\\\" &&\\n                        (this.peekChar(2) === \\\"=\\\" || this.peekChar(2) === \\\"!\\\")\\n                    )\\n                default:\\n                    return false\\n            }\\n        }\\n\\n        RegExpParser.prototype.isQuantifier = function() {\\n            var prevState = this.saveState()\\n            try {\\n                return this.quantifier(true) !== undefined\\n            } catch (e) {\\n                return false\\n            } finally {\\n                this.restoreState(prevState)\\n            }\\n        }\\n\\n        RegExpParser.prototype.isPatternCharacter = function() {\\n            switch (this.peekChar()) {\\n                case \\\"^\\\":\\n                case \\\"$\\\":\\n                case \\\"\\\\\\\\\\\":\\n                case \\\".\\\":\\n                case \\\"*\\\":\\n                case \\\"+\\\":\\n                case \\\"?\\\":\\n                case \\\"(\\\":\\n                case \\\")\\\":\\n                case \\\"[\\\":\\n                case \\\"|\\\":\\n                case \\\"/\\\":\\n                case \\\"\\\\n\\\":\\n                case \\\"\\\\r\\\":\\n                case \\\"\\\\u2028\\\":\\n                case \\\"\\\\u2029\\\":\\n                    return false\\n                default:\\n                    return true\\n            }\\n        }\\n\\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\\n            var hexString = \\\"\\\"\\n            for (var i = 0; i < howMany; i++) {\\n                var hexChar = this.popChar()\\n                if (hexDigitPattern.test(hexChar) === false) {\\n                    throw Error(\\\"Expecting a HexDecimal digits\\\")\\n                }\\n                hexString += hexChar\\n            }\\n            var charCode = parseInt(hexString, 16)\\n            return { type: \\\"Character\\\", value: charCode }\\n        }\\n\\n        RegExpParser.prototype.peekChar = function(howMuch) {\\n            if (howMuch === undefined) {\\n                howMuch = 0\\n            }\\n            return this.input[this.idx + howMuch]\\n        }\\n\\n        RegExpParser.prototype.popChar = function() {\\n            var nextChar = this.peekChar(0)\\n            this.consumeChar()\\n            return nextChar\\n        }\\n\\n        RegExpParser.prototype.consumeChar = function(char) {\\n            if (char !== undefined && this.input[this.idx] !== char) {\\n                throw Error(\\n                    \\\"Expected: '\\\" +\\n                        char +\\n                        \\\"' but found: '\\\" +\\n                        this.input[this.idx] +\\n                        \\\"' at offset: \\\" +\\n                        this.idx\\n                )\\n            }\\n\\n            if (this.idx >= this.input.length) {\\n                throw Error(\\\"Unexpected end of input\\\")\\n            }\\n            this.idx++\\n        }\\n\\n        RegExpParser.prototype.loc = function(begin) {\\n            return { begin: begin, end: this.idx }\\n        }\\n\\n        // consts and utilities\\n        var hexDigitPattern = /[0-9a-fA-F]/\\n        var decimalPattern = /[0-9]/\\n        var decimalPatternNoZero = /[1-9]/\\n\\n        function cc(char) {\\n            return char.charCodeAt(0)\\n        }\\n\\n        function insertToSet(item, set) {\\n            if (item.length !== undefined) {\\n                item.forEach(function(subItem) {\\n                    set.push(subItem)\\n                })\\n            } else {\\n                set.push(item)\\n            }\\n        }\\n\\n        function addFlag(flagObj, flagKey) {\\n            if (flagObj[flagKey] === true) {\\n                throw \\\"duplicate flag \\\" + flagKey\\n            }\\n\\n            flagObj[flagKey] = true\\n        }\\n\\n        function ASSERT_EXISTS(obj) {\\n            // istanbul ignore next\\n            if (obj === undefined) {\\n                throw Error(\\\"Internal Error - Should never get here!\\\")\\n            }\\n        }\\n\\n        // istanbul ignore next\\n        function ASSERT_NEVER_REACH_HERE() {\\n            throw Error(\\\"Internal Error - Should never get here!\\\")\\n        }\\n\\n        var i\\n        var digitsCharCodes = []\\n        for (i = cc(\\\"0\\\"); i <= cc(\\\"9\\\"); i++) {\\n            digitsCharCodes.push(i)\\n        }\\n\\n        var wordCharCodes = [cc(\\\"_\\\")].concat(digitsCharCodes)\\n        for (i = cc(\\\"a\\\"); i <= cc(\\\"z\\\"); i++) {\\n            wordCharCodes.push(i)\\n        }\\n\\n        for (i = cc(\\\"A\\\"); i <= cc(\\\"Z\\\"); i++) {\\n            wordCharCodes.push(i)\\n        }\\n\\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\\n        var whitespaceCodes = [\\n            cc(\\\" \\\"),\\n            cc(\\\"\\\\f\\\"),\\n            cc(\\\"\\\\n\\\"),\\n            cc(\\\"\\\\r\\\"),\\n            cc(\\\"\\\\t\\\"),\\n            cc(\\\"\\\\v\\\"),\\n            cc(\\\"\\\\t\\\"),\\n            cc(\\\"\\\\u00a0\\\"),\\n            cc(\\\"\\\\u1680\\\"),\\n            cc(\\\"\\\\u2000\\\"),\\n            cc(\\\"\\\\u2001\\\"),\\n            cc(\\\"\\\\u2002\\\"),\\n            cc(\\\"\\\\u2003\\\"),\\n            cc(\\\"\\\\u2004\\\"),\\n            cc(\\\"\\\\u2005\\\"),\\n            cc(\\\"\\\\u2006\\\"),\\n            cc(\\\"\\\\u2007\\\"),\\n            cc(\\\"\\\\u2008\\\"),\\n            cc(\\\"\\\\u2009\\\"),\\n            cc(\\\"\\\\u200a\\\"),\\n            cc(\\\"\\\\u2028\\\"),\\n            cc(\\\"\\\\u2029\\\"),\\n            cc(\\\"\\\\u202f\\\"),\\n            cc(\\\"\\\\u205f\\\"),\\n            cc(\\\"\\\\u3000\\\"),\\n            cc(\\\"\\\\ufeff\\\")\\n        ]\\n\\n        function BaseRegExpVisitor() {}\\n\\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\\n            for (var key in node) {\\n                var child = node[key]\\n                /* istanbul ignore else */\\n                if (node.hasOwnProperty(key)) {\\n                    if (child.type !== undefined) {\\n                        this.visit(child)\\n                    } else if (Array.isArray(child)) {\\n                        child.forEach(function(subChild) {\\n                            this.visit(subChild)\\n                        }, this)\\n                    }\\n                }\\n            }\\n        }\\n\\n        BaseRegExpVisitor.prototype.visit = function(node) {\\n            switch (node.type) {\\n                case \\\"Pattern\\\":\\n                    this.visitPattern(node)\\n                    break\\n                case \\\"Flags\\\":\\n                    this.visitFlags(node)\\n                    break\\n                case \\\"Disjunction\\\":\\n                    this.visitDisjunction(node)\\n                    break\\n                case \\\"Alternative\\\":\\n                    this.visitAlternative(node)\\n                    break\\n                case \\\"StartAnchor\\\":\\n                    this.visitStartAnchor(node)\\n                    break\\n                case \\\"EndAnchor\\\":\\n                    this.visitEndAnchor(node)\\n                    break\\n                case \\\"WordBoundary\\\":\\n                    this.visitWordBoundary(node)\\n                    break\\n                case \\\"NonWordBoundary\\\":\\n                    this.visitNonWordBoundary(node)\\n                    break\\n                case \\\"Lookahead\\\":\\n                    this.visitLookahead(node)\\n                    break\\n                case \\\"NegativeLookahead\\\":\\n                    this.visitNegativeLookahead(node)\\n                    break\\n                case \\\"Character\\\":\\n                    this.visitCharacter(node)\\n                    break\\n                case \\\"Set\\\":\\n                    this.visitSet(node)\\n                    break\\n                case \\\"Group\\\":\\n                    this.visitGroup(node)\\n                    break\\n                case \\\"GroupBackReference\\\":\\n                    this.visitGroupBackReference(node)\\n                    break\\n                case \\\"Quantifier\\\":\\n                    this.visitQuantifier(node)\\n                    break\\n            }\\n\\n            this.visitChildren(node)\\n        }\\n\\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\\n\\n        // Assertion\\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\\n\\n        // atoms\\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\\n\\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\\n\\n        return {\\n            RegExpParser: RegExpParser,\\n            BaseRegExpVisitor: BaseRegExpVisitor,\\n            VERSION: \\\"0.5.0\\\"\\n        }\\n    }\\n)\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"root\",\"factory\",\"define\",\"amd\",\"regexpToAst\",\"self\",\"RegExpParser\",\"cc\",\"char\",\"charCodeAt\",\"insertToSet\",\"item\",\"set\",\"undefined\",\"length\",\"forEach\",\"subItem\",\"push\",\"addFlag\",\"flagObj\",\"flagKey\",\"ASSERT_EXISTS\",\"obj\",\"Error\",\"BaseRegExpVisitor\",\"prototype\",\"saveState\",\"RegExpParser.prototype.saveState\",\"idx\",\"input\",\"groupIdx\",\"restoreState\",\"RegExpParser.prototype.restoreState\",\"newState\",\"pattern\",\"RegExpParser.prototype.pattern\",\"consumeChar\",\"value\",\"disjunction\",\"flags\",\"type\",\"loc\",\"begin\",\"end\",\"ignoreCase\",\"multiLine\",\"unicode\",\"sticky\",\"isRegExpFlag\",\"popChar\",\"substring\",\"RegExpParser.prototype.disjunction\",\"alts\",\"alternative\",\"peekChar\",\"RegExpParser.prototype.alternative\",\"terms\",\"isTerm\",\"term\",\"RegExpParser.prototype.term\",\"isAssertion\",\"assertion\",\"atom\",\"RegExpParser.prototype.assertion\",\"quantifier\",\"RegExpParser.prototype.quantifier\",\"isBacktracking\",\"range\",\"atLeast\",\"atMost\",\"Infinity\",\"integerIncludingZero\",\"isDigit\",\"greedy\",\"RegExpParser.prototype.atom\",\"dotAll\",\"atomEscape\",\"characterClass\",\"group\",\"isPatternCharacter\",\"patternCharacter\",\"isQuantifier\",\"RegExpParser.prototype.dotAll\",\"complement\",\"RegExpParser.prototype.atomEscape\",\"decimalEscapeAtom\",\"characterClassEscape\",\"controlEscapeAtom\",\"controlLetterEscapeAtom\",\"nulCharacterAtom\",\"hexEscapeSequenceAtom\",\"regExpUnicodeEscapeSequenceAtom\",\"identityEscapeAtom\",\"RegExpParser.prototype.decimalEscapeAtom\",\"positiveInteger\",\"RegExpParser.prototype.characterClassEscape\",\"digitsCharCodes\",\"whitespaceCodes\",\"wordCharCodes\",\"RegExpParser.prototype.controlEscapeAtom\",\"escapeCode\",\"RegExpParser.prototype.controlLetterEscapeAtom\",\"letter\",\"test\",\"toUpperCase\",\"RegExpParser.prototype.nulCharacterAtom\",\"RegExpParser.prototype.hexEscapeSequenceAtom\",\"parseHexDigits\",\"RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom\",\"RegExpParser.prototype.identityEscapeAtom\",\"escapedChar\",\"classPatternCharacterAtom\",\"RegExpParser.prototype.classPatternCharacterAtom\",\"nextChar\",\"RegExpParser.prototype.characterClass\",\"isClassAtom\",\"from\",\"classAtom\",\"isRangeDash\",\"to\",\"RegExpParser.prototype.classAtom\",\"classEscape\",\"RegExpParser.prototype.classEscape\",\"RegExpParser.prototype.group\",\"capturing\",\"groupAst\",\"RegExpParser.prototype.positiveInteger\",\"number\",\"decimalPatternNoZero\",\"decimalPattern\",\"parseInt\",\"RegExpParser.prototype.integerIncludingZero\",\"RegExpParser.prototype.patternCharacter\",\"RegExpParser.prototype.isRegExpFlag\",\"RegExpParser.prototype.isRangeDash\",\"RegExpParser.prototype.isDigit\",\"RegExpParser.prototype.isClassAtom\",\"howMuch\",\"RegExpParser.prototype.isTerm\",\"isAtom\",\"RegExpParser.prototype.isAtom\",\"RegExpParser.prototype.isAssertion\",\"RegExpParser.prototype.isQuantifier\",\"prevState\",\"e\",\"RegExpParser.prototype.isPatternCharacter\",\"RegExpParser.prototype.parseHexDigits\",\"howMany\",\"hexString\",\"i\",\"hexChar\",\"hexDigitPattern\",\"charCode\",\"RegExpParser.prototype.peekChar\",\"RegExpParser.prototype.popChar\",\"RegExpParser.prototype.consumeChar\",\"RegExpParser.prototype.loc\",\"concat\",\"visitChildren\",\"BaseRegExpVisitor.prototype.visitChildren\",\"node\",\"key\",\"child\",\"hasOwnProperty\",\"visit\",\"Array\",\"isArray\",\"subChild\",\"BaseRegExpVisitor.prototype.visit\",\"visitPattern\",\"visitFlags\",\"visitDisjunction\",\"visitAlternative\",\"visitStartAnchor\",\"visitEndAnchor\",\"visitWordBoundary\",\"visitNonWordBoundary\",\"visitLookahead\",\"visitNegativeLookahead\",\"visitCharacter\",\"visitSet\",\"visitGroup\",\"visitGroupBackReference\",\"visitQuantifier\",\"BaseRegExpVisitor.prototype.visitPattern\",\"BaseRegExpVisitor.prototype.visitFlags\",\"BaseRegExpVisitor.prototype.visitDisjunction\",\"BaseRegExpVisitor.prototype.visitAlternative\",\"BaseRegExpVisitor.prototype.visitStartAnchor\",\"BaseRegExpVisitor.prototype.visitEndAnchor\",\"BaseRegExpVisitor.prototype.visitWordBoundary\",\"BaseRegExpVisitor.prototype.visitNonWordBoundary\",\"BaseRegExpVisitor.prototype.visitLookahead\",\"BaseRegExpVisitor.prototype.visitNegativeLookahead\",\"BaseRegExpVisitor.prototype.visitCharacter\",\"BaseRegExpVisitor.prototype.visitSet\",\"BaseRegExpVisitor.prototype.visitGroup\",\"BaseRegExpVisitor.prototype.visitGroupBackReference\",\"BaseRegExpVisitor.prototype.visitQuantifier\",\"VERSION\"]\n}\n"]