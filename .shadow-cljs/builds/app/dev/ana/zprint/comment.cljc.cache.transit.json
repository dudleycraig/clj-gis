["^ ","~:output",["^ ","~:js","goog.provide('zprint.comment');\n/**\n * Produce a blank string of desired size.\n */\nzprint.comment.blanks = (function zprint$comment$blanks(n){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(n,\" \"));\n});\n/**\n * Do split for newlines, instead of using regular expressions.\n */\nzprint.comment.split_lf = (function zprint$comment$split_lf(s){\nvar input = s;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(input)){\nreturn out;\n} else {\nvar next_lf = clojure.string.index_of.cljs$core$IFn$_invoke$arity$2(input,\"\\n\");\nvar chunk = (cljs.core.truth_(next_lf)?cljs.core.subs.cljs$core$IFn$_invoke$arity$3(input,(0),next_lf):input);\nvar G__49514 = (cljs.core.truth_(next_lf)?cljs.core.subs.cljs$core$IFn$_invoke$arity$2(input,(next_lf + (1))):null);\nvar G__49515 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,chunk);\ninput = G__49514;\nout = G__49515;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Given a tag into which you can go down from rewrite-clj, which must be\n *   a collection of some kind, return the size the l-str.  All of the tag\n *   values into which you can go down must be in this list for indent-before\n *   to work correctly.  It uses these values when it steps up out of one of\n *   these things to see how big the thing would have been if it showed up\n *   as characters.\n */\nzprint.comment.tag_l_size = (function zprint$comment$tag_l_size(t){\nvar G__48982 = t;\nvar G__48982__$1 = (((G__48982 instanceof cljs.core.Keyword))?G__48982.fqn:null);\nswitch (G__48982__$1) {\ncase \"list\":\nreturn (1);\n\nbreak;\ncase \"vector\":\nreturn (1);\n\nbreak;\ncase \"set\":\nreturn (2);\n\nbreak;\ncase \"map\":\nreturn (1);\n\nbreak;\ncase \"uneval\":\nreturn (2);\n\nbreak;\ncase \"reader-macro\":\nreturn (1);\n\nbreak;\ncase \"meta\":\nreturn (1);\n\nbreak;\ncase \"quote\":\nreturn (1);\n\nbreak;\ncase \"syntax-quote\":\nreturn (1);\n\nbreak;\ncase \"fn\":\nreturn (2);\n\nbreak;\ncase \"unquote\":\nreturn (1);\n\nbreak;\ncase \"deref\":\nreturn (1);\n\nbreak;\ncase \"namespaced-map\":\nreturn (1);\n\nbreak;\ndefault:\nreturn (0);\n\n}\n});\n/**\n * Take a zloc and move left if possible, or move up if necessary.\n *   Return a vector with [up-size new-zloc]\n */\nzprint.comment.left_or_up = (function zprint$comment$left_or_up(zloc){\nvar ploc = zloc;\nvar total_up = (0);\nwhile(true){\nvar next_left = (zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1(ploc) : zprint.zutil.left_STAR_.call(null,ploc));\nif(cljs.core.truth_(next_left)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [total_up,next_left], null);\n} else {\nvar moving_up = (zprint.zutil.up_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.up_STAR_.cljs$core$IFn$_invoke$arity$1(ploc) : zprint.zutil.up_STAR_.call(null,ploc));\nvar up_tag = (cljs.core.truth_(moving_up)?(zprint.zutil.tag.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.tag.cljs$core$IFn$_invoke$arity$1(moving_up) : zprint.zutil.tag.call(null,moving_up)):null);\nvar up_size = zprint.comment.tag_l_size(up_tag);\nif(cljs.core.not(moving_up)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [total_up,null], null);\n} else {\nvar G__49526 = moving_up;\nvar G__49527 = (total_up + up_size);\nploc = G__49526;\ntotal_up = G__49527;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Given a string, return the number of characters to the right\n *   of any newlines in the string.  Will return nil if no newlines\n *   in the string.\n */\nzprint.comment.length_after_newline = (function zprint$comment$length_after_newline(s){\nvar nl_split = clojure.string.split.cljs$core$IFn$_invoke$arity$2([cljs.core.str.cljs$core$IFn$_invoke$arity$1(s),\" \"].join(''),/\\n/);\nvar nl_num = (cljs.core.count(nl_split) - (1));\nif((nl_num === (0))){\nreturn null;\n} else {\nreturn (cljs.core.count(cljs.core.last(nl_split)) - (1));\n}\n});\n/**\n * Given a zloc, find the amount of printing space before it on its\n *   current line.\n */\nzprint.comment.length_before = (function zprint$comment$length_before(zloc){\nvar vec__49010 = zprint.comment.left_or_up(zloc);\nvar up_size = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49010,(0),null);\nvar next_zloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49010,(1),null);\nvar ploc = next_zloc;\nvar indent_before = up_size;\nwhile(true){\nif(cljs.core.not(ploc)){\nreturn indent_before;\n} else {\nvar zstr = (cljs.core.truth_(ploc)?(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(ploc) : zprint.zfns.zstring.call(null,ploc)):\"\");\nvar length_right_of_newline = zprint.comment.length_after_newline(zstr);\nvar vec__49027 = zprint.comment.left_or_up(ploc);\nvar up_size__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49027,(0),null);\nvar next_zloc__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49027,(1),null);\nif(cljs.core.truth_(length_right_of_newline)){\nreturn (length_right_of_newline + indent_before);\n} else {\nvar G__49535 = next_zloc__$1;\nvar G__49536 = ((indent_before + cljs.core.count(zstr)) + up_size__$1);\nploc = G__49535;\nindent_before = G__49536;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * If this is an inline comment, returns a vector with the amount\n *   of space that was between this and the previous element and the\n *   starting column of this inline comment.  That means that if we\n *   go left, we get something other than whitespace before a newline.\n *   If we get only whitespace before a newline, then this is considered\n *   an inline comment if the comment at the end of the previous line\n *   was an inline comment and we were aligned with that comment.\n *   Assumes zloc is a comment.\n */\nzprint.comment.inlinecomment_QMARK_ = (function zprint$comment$inlinecomment_QMARK_(zloc){\nvar nloc = (zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zutil.left_STAR_.call(null,zloc));\nvar spaces = (0);\nvar passed_nl_QMARK_ = false;\nwhile(true){\nvar vec__49090 = (function (){var tnloc = (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zfns.ztag.call(null,nloc));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))){\nvar nstr = (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zfns.zstring.call(null,nloc));\nvar trim_nstr = clojure.string.trimr(nstr);\nif((((trim_nstr).length) > (0))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745),(spaces + (cljs.core.count(nstr) - ((trim_nstr).length)))], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),spaces], null);\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [tnloc,spaces], null);\n}\n})();\nvar tnloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49090,(0),null);\nvar spaces__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49090,(1),null);\nif((tnloc == null)){\nreturn null;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))){\nvar G__49546 = (zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zutil.left_STAR_.call(null,nloc));\nvar G__49547 = spaces__$1;\nvar G__49548 = true;\nnloc = G__49546;\nspaces = G__49547;\npassed_nl_QMARK_ = G__49548;\ncontinue;\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))))){\nif(cljs.core.truth_((zprint.comment.inlinecomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.comment.inlinecomment_QMARK_.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.comment.inlinecomment_QMARK_.call(null,nloc)))){\nvar nloc_length_before = zprint.comment.length_before(nloc);\nvar zloc_length_before = zprint.comment.length_before(zloc);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(nloc_length_before,zloc_length_before)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [spaces__$1,zloc_length_before], null);\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n} else {\nif(cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))){\nif(cljs.core.truth_(passed_nl_QMARK_)){\nreturn null;\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [spaces__$1,zprint.comment.length_before(zloc)], null);\n}\n} else {\nvar G__49553 = (zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.left_STAR_.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zutil.left_STAR_.call(null,nloc));\nvar G__49554 = ((zprint.zutil.length.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.length.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zutil.length.call(null,nloc)) + spaces__$1);\nvar G__49555 = passed_nl_QMARK_;\nnloc = G__49553;\nspaces = G__49554;\npassed_nl_QMARK_ = G__49555;\ncontinue;\n\n}\n}\n}\n}\nbreak;\n}\n});\n/**\n * Take a string and an index, and look for the last space prior to the\n *   index. If we wanted to tie ourselves to 1.8, we could use \n *   clojure.string/last-index-of, but we don't.  However, we use similar\n *   conventions, i.e., if no space is found, return nil, and if the index\n *   is a space return that value, and accept any from-index, including one\n *   larger than the length of the string.\n */\nzprint.comment.last_space = (function zprint$comment$last_space(s,from_index){\nvar from_index__$1 = (function (){var x__4298__auto__ = (cljs.core.count(s) - (1));\nvar y__4299__auto__ = from_index;\nreturn ((x__4298__auto__ < y__4299__auto__) ? x__4298__auto__ : y__4299__auto__);\n})();\nvar rev_seq = cljs.core.reverse(cljs.core.take.cljs$core$IFn$_invoke$arity$2((from_index__$1 + (1)),s));\nvar seq_after_space = cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((function (p1__49118_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__49118_SHARP_,\" \");\n}),rev_seq);\nvar space_index = (from_index__$1 - cljs.core.count(seq_after_space));\nif((space_index < (0))){\nreturn null;\n} else {\nreturn space_index;\n}\n});\n/**\n * Take a string and an index, and look for the next space *after* the\n *   index. If no space is found, return nil. Accept any from-index, \n *   including one larger than the length of the string.\n */\nzprint.comment.next_space = (function zprint$comment$next_space(s,from_index){\nvar from_index__$1 = (from_index + (1));\nif((from_index__$1 < cljs.core.count(s))){\nvar seq_after_space = cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((function (p1__49130_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__49130_SHARP_,\" \");\n}),cljs.core.drop.cljs$core$IFn$_invoke$arity$2(from_index__$1,cljs.core.seq(s)));\nvar space_index = (from_index__$1 + cljs.core.count(seq_after_space));\nif((space_index >= cljs.core.count(s))){\nreturn null;\n} else {\nreturn space_index;\n}\n} else {\nreturn null;\n}\n});\n/**\n * If this is a comment, and it is too long, word wrap it to the right width.\n *   Note that top level comments may well end with a newline, so remove it\n *   and reapply it at the end if that is the case.\n */\nzprint.comment.wrap_comment = (function zprint$comment$wrap_comment(width,p__49161,start){\nvar vec__49167 = p__49161;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49167,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49167,(1),null);\nvar stype = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49167,(2),null);\nvar element = vec__49167;\nif((!(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(stype,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(stype,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))))))){\nreturn element;\n} else {\nvar comment_width = (width - start);\nvar semi_str = cljs.core.re_find(/;*/,s);\nvar rest_str = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,cljs.core.count(semi_str));\nvar space_str = cljs.core.re_find(/ */,rest_str);\nvar rest_str__$1 = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(rest_str,cljs.core.count(space_str));\nvar newline_QMARK_ = cljs.core.re_find(/\\n$/,s);\nvar comment_width__$1 = ((comment_width - cljs.core.count(semi_str)) - cljs.core.count(space_str));\nvar comment_str = rest_str__$1;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(comment_str)){\nif((cljs.core.count(out) === (0))){\nif(cljs.core.truth_(newline_QMARK_)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [semi_str,color,stype], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(38)], null)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [semi_str,color,stype], null)], null);\n}\n} else {\nreturn cljs.core.persistent_BANG_((cljs.core.truth_(newline_QMARK_)?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(39)], null)):out));\n}\n} else {\nvar last_space_index = (((((comment_str).length) <= comment_width__$1))?(((comment_str).length) - (1)):(((comment_width__$1 <= (0)))?(function (){var or__4212__auto__ = zprint.comment.next_space(comment_str,(0));\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (((comment_str).length) - (1));\n}\n})():(function (){var or__4212__auto__ = zprint.comment.last_space(comment_str,comment_width__$1);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nvar or__4212__auto____$1 = zprint.comment.next_space(comment_str,comment_width__$1);\nif(cljs.core.truth_(or__4212__auto____$1)){\nreturn or__4212__auto____$1;\n} else {\nreturn (((comment_str).length) - (1));\n}\n}\n})()));\nvar next_comment = clojure.string.trimr(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(comment_str,(0),(last_space_index + (1))));\nvar G__49575 = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(comment_str,(last_space_index + (1)));\nvar G__49576 = (((cljs.core.count(out) === (0)))?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1(semi_str),cljs.core.str.cljs$core$IFn$_invoke$arity$1(space_str),next_comment].join(''),color,stype], null)):cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.comment.blanks(start))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(40)], null)),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1(semi_str),cljs.core.str.cljs$core$IFn$_invoke$arity$1(space_str),next_comment].join(''),color,new cljs.core.Keyword(null,\"comment-wrap\",\"comment-wrap\",720664128)], null)));\ncomment_str = G__49575;\nout = G__49576;\ncontinue;\n}\nbreak;\n}\n}\n});\n/**\n * Takes the start of this vector and the vector itself.\n */\nzprint.comment.loc_vec = (function zprint$comment$loc_vec(start,p__49205){\nvar vec__49208 = p__49205;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49208,(0),null);\nvar split = zprint.comment.split_lf(s);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(split),(1))){\nreturn (start + cljs.core.count(s));\n} else {\nreturn cljs.core.count(cljs.core.last(split));\n}\n});\n/**\n * Take a style-vec and produce a style-loc-vec with the starting column\n *   of each element in the style-vec. Accepts a beginning indent.\n */\nzprint.comment.style_loc_vec = (function zprint$comment$style_loc_vec(indent,style_vec){\nreturn cljs.core.butlast(cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(zprint.comment.loc_vec,indent,style_vec));\n});\n/**\n * Take a transient output vector and a vector and lift any style-vec elements\n *   out of the input vector.\n */\nzprint.comment.lift_vec = (function zprint$comment$lift_vec(out_vec,element){\nif(typeof cljs.core.first(element) === 'string'){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out_vec,element);\n} else {\nvar element_vec = element;\nvar out = out_vec;\nwhile(true){\nif(cljs.core.not(element_vec)){\nreturn out;\n} else {\nvar G__49577 = cljs.core.next(element_vec);\nvar G__49578 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(element_vec));\nelement_vec = G__49577;\nout = G__49578;\ncontinue;\n}\nbreak;\n}\n}\n});\n/**\n * Take a style-vec [[s color type] [s color type] [[s color type]\n *   [s color type]] [s color type] ...] and lift out the inner vectors.\n */\nzprint.comment.lift_style_vec = (function zprint$comment$lift_style_vec(style_vec){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.comment.lift_vec,cljs.core.PersistentVector.EMPTY,style_vec);\n});\n/**\n * Take the final output style-vec, and wrap any comments which run over\n *   the width. Looking for \n */\nzprint.comment.fzprint_wrap_comments = (function zprint$comment$fzprint_wrap_comments(p__49236,style_vec){\nvar map__49237 = p__49236;\nvar map__49237__$1 = cljs.core.__destructure_map(map__49237);\nvar options = map__49237__$1;\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49237__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: indent:\",new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1(options)], 0));\n} else {\n}\n\nvar start_col = zprint.comment.style_loc_vec((function (){var or__4212__auto__ = new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1(options);\nif(cljs.core.truth_(or__4212__auto__)){\nreturn or__4212__auto__;\n} else {\nreturn (0);\n}\n})(),style_vec);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: style-vec:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([style_vec], 0))], 0)):null);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: start-col:\",start_col], 0)):null);\nvar wrap_style_vec = cljs.core.mapv.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.comment.wrap_comment,width),style_vec,start_col);\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: wrap:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([style_vec], 0))], 0)):null);\nvar out_style_vec = zprint.comment.lift_style_vec(wrap_style_vec);\nreturn out_style_vec;\n});\n/**\n * Find a the first element of this type working from the end of a \n *   style-vec.  Return the index of the element.\n */\nzprint.comment.find_element_from_end = (function zprint$comment$find_element_from_end(element_pred_QMARK_,style_vec){\nvar index = (cljs.core.count(style_vec) - (1));\nwhile(true){\nif((index < (0))){\nreturn null;\n} else {\nvar vec__49254 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,index);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49254,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49254,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49254,(2),null);\nif(cljs.core.truth_((element_pred_QMARK_.cljs$core$IFn$_invoke$arity$1 ? element_pred_QMARK_.cljs$core$IFn$_invoke$arity$1(e) : element_pred_QMARK_.call(null,e)))){\nreturn index;\n} else {\nvar G__49581 = (index - (1));\nindex = G__49581;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Given a style-vec, how big is it in actual characters.  This doesn't\n *   handle newlines.\n */\nzprint.comment.line_size = (function zprint$comment$line_size(style_vec){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.comment.loc_vec,(0)),style_vec));\n});\n/**\n * Given a style-vec, whose last element in a comment, find the amount\n *   of space before that comment on the line.\n */\nzprint.comment.space_before_comment = (function zprint$comment$space_before_comment(style_vec){\nvar indent_index = zprint.comment.find_element_from_end((function (p1__49268_SHARP_){\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__49268_SHARP_,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__49268_SHARP_,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))));\n}),style_vec);\nvar this_line_vec = (cljs.core.truth_(indent_index)?cljs.core.nthnext(style_vec,indent_index):style_vec);\nreturn zprint.comment.line_size(cljs.core.butlast(this_line_vec));\n});\n/**\n * Try to bring inline comments back onto the line on which they belong.\n */\nzprint.comment.fzprint_inline_comments = (function zprint$comment$fzprint_inline_comments(p__49282,style_vec){\nvar map__49283 = p__49282;\nvar map__49283__$1 = cljs.core.__destructure_map(map__49283);\nvar options = map__49283__$1;\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__49283__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-inline-comments:\",style_vec], 0))], 0));\n} else {\n}\n\nvar cvec = style_vec;\nvar last_out = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",null,null], null);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cvec)){\nreturn out;\n} else {\nvar vec__49318 = cljs.core.first(cvec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49318,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49318,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49318,(2),null);\nvar element = vec__49318;\nvar vec__49321 = cljs.core.second(cvec);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49321,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49321,(1),null);\nvar ne = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49321,(2),null);\nvar nn = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49321,(3),null);\nvar next_element = vec__49321;\nvar vec__49324 = last_out;\nvar ___$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49324,(0),null);\nvar ___$3 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49324,(1),null);\nvar le = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49324,(2),null);\nvar new_element = ((((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ne,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)))))?(((!(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(le,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(le,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)))))))?new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.comment.blanks(nn),c,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(25)], null):new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.comment.blanks(zprint.comment.space_before_comment(out)))].join(''),c,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(41)], null)):element\n);\nvar G__49586 = cljs.core.next(cvec);\nvar G__49587 = new_element;\nvar G__49588 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new_element);\ncvec = G__49586;\nlast_out = G__49587;\nout = G__49588;\ncontinue;\n}\nbreak;\n}\n});\nzprint.comment.max_aligned_inline_comment_distance = (5);\n/**\n * Given a style-vec, find previously aligned inline comments and\n *   output the as a sequence of vectors of comments. The previously\n *   aligned comments do not have to be consecutive, but they can't\n *   be separated by more than max-aligned-inline-comment-distance.\n *   Each comment itself is a vector: [indent-index inline-comment-index],\n *   yielding a [[[indent-index inline-comment-index] [indent-index\n *   inline-comment-index] ...] ...].  The indexes are into the\n *   style-vec.\n */\nzprint.comment.find_aligned_inline_comments = (function zprint$comment$find_aligned_inline_comments(style_vec){\nvar cvec = style_vec;\nvar index = (0);\nvar last_indent = (0);\nvar current_seq = cljs.core.PersistentVector.EMPTY;\nvar current_column = (0);\nvar distance = (0);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cvec)){\nvar out__$1 = (((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out);\nreturn out__$1;\n} else {\nvar vec__49383 = cljs.core.first(cvec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49383,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49383,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49383,(2),null);\nvar spaces = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49383,(3),null);\nvar start_column = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49383,(4),null);\nvar element = vec__49383;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_column,current_column)){\nvar G__49593 = cljs.core.next(cvec);\nvar G__49594 = (index + (1));\nvar G__49595 = null;\nvar G__49596 = (cljs.core.truth_(last_indent)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(current_seq,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [last_indent,index], null)):(function (){\nthrow (new Error([\"find-aligned-inline-comments a:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(index)].join('')));\n\nreturn cljs.core.PersistentVector.EMPTY;\n})()\n);\nvar G__49597 = current_column;\nvar G__49598 = (0);\nvar G__49599 = out;\ncvec = G__49593;\nindex = G__49594;\nlast_indent = G__49595;\ncurrent_seq = G__49596;\ncurrent_column = G__49597;\ndistance = G__49598;\nout = G__49599;\ncontinue;\n} else {\nvar G__49601 = cljs.core.next(cvec);\nvar G__49602 = (index + (1));\nvar G__49603 = null;\nvar G__49604 = (cljs.core.truth_(last_indent)?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [last_indent,index], null)], null):(function (){\nthrow (new Error([\"find-aligned-inline-comments b:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(index)].join('')));\n\nreturn cljs.core.PersistentVector.EMPTY;\n})()\n);\nvar G__49605 = start_column;\nvar G__49606 = (0);\nvar G__49607 = (((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out);\ncvec = G__49601;\nindex = G__49602;\nlast_indent = G__49603;\ncurrent_seq = G__49604;\ncurrent_column = G__49605;\ndistance = G__49606;\nout = G__49607;\ncontinue;\n}\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))){\nif((distance >= zprint.comment.max_aligned_inline_comment_distance)){\nvar G__49608 = cljs.core.next(cvec);\nvar G__49609 = (index + (1));\nvar G__49610 = index;\nvar G__49611 = cljs.core.PersistentVector.EMPTY;\nvar G__49612 = (0);\nvar G__49613 = (0);\nvar G__49614 = (((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out);\ncvec = G__49608;\nindex = G__49609;\nlast_indent = G__49610;\ncurrent_seq = G__49611;\ncurrent_column = G__49612;\ndistance = G__49613;\nout = G__49614;\ncontinue;\n} else {\nvar G__49615 = cljs.core.next(cvec);\nvar G__49616 = (index + (1));\nvar G__49617 = index;\nvar G__49618 = current_seq;\nvar G__49619 = current_column;\nvar G__49620 = (distance + (1));\nvar G__49621 = out;\ncvec = G__49615;\nindex = G__49616;\nlast_indent = G__49617;\ncurrent_seq = G__49618;\ncurrent_column = G__49619;\ndistance = G__49620;\nout = G__49621;\ncontinue;\n}\n} else {\nvar G__49622 = cljs.core.next(cvec);\nvar G__49623 = (index + (1));\nvar G__49624 = last_indent;\nvar G__49625 = current_seq;\nvar G__49626 = current_column;\nvar G__49627 = distance;\nvar G__49628 = out;\ncvec = G__49622;\nindex = G__49623;\nlast_indent = G__49624;\ncurrent_seq = G__49625;\ncurrent_column = G__49626;\ndistance = G__49627;\nout = G__49628;\ncontinue;\n\n}\n}\n}\nbreak;\n}\n});\n/**\n * Given a style-vec, find consecutive inline comments and output\n *   the as a sequence of vectors of comments.  Each comment itself\n *   is a vector: [indent-index inline-comment-index], yielding a\n *   [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n *   ...] ...]\n */\nzprint.comment.find_consecutive_inline_comments = (function zprint$comment$find_consecutive_inline_comments(style_vec){\nvar cvec = style_vec;\nvar index = (0);\nvar last_indent = (0);\nvar current_seq = cljs.core.PersistentVector.EMPTY;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cvec)){\nreturn out;\n} else {\nvar vec__49416 = cljs.core.first(cvec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49416,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49416,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49416,(2),null);\nvar element = vec__49416;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))){\nvar G__49629 = cljs.core.next(cvec);\nvar G__49630 = (index + (1));\nvar G__49631 = null;\nvar G__49632 = (cljs.core.truth_(last_indent)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(current_seq,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [last_indent,index], null)):(function (){\nthrow (new Error([\"find-consecutive-inline-comments:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(index)].join('')));\n\nreturn cljs.core.PersistentVector.EMPTY;\n})()\n);\nvar G__49633 = out;\ncvec = G__49629;\nindex = G__49630;\nlast_indent = G__49631;\ncurrent_seq = G__49632;\nout = G__49633;\ncontinue;\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))){\nvar G__49636 = cljs.core.next(cvec);\nvar G__49637 = (index + (1));\nvar G__49638 = index;\nvar G__49639 = (cljs.core.truth_(last_indent)?cljs.core.PersistentVector.EMPTY:current_seq);\nvar G__49640 = (cljs.core.truth_(last_indent)?(((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out):out);\ncvec = G__49636;\nindex = G__49637;\nlast_indent = G__49638;\ncurrent_seq = G__49639;\nout = G__49640;\ncontinue;\n} else {\nvar G__49641 = cljs.core.next(cvec);\nvar G__49642 = (index + (1));\nvar G__49643 = last_indent;\nvar G__49644 = current_seq;\nvar G__49645 = out;\ncvec = G__49641;\nindex = G__49642;\nlast_indent = G__49643;\ncurrent_seq = G__49644;\nout = G__49645;\ncontinue;\n\n}\n}\n}\nbreak;\n}\n});\n/**\n * Takes a single vector of [indent-index comment-index] and will show the\n *   column on the line in which the comment starts.\n */\nzprint.comment.comment_column = (function zprint$comment$comment_column(p__49427,style_vec){\nvar vec__49428 = p__49427;\nvar indent_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49428,(0),null);\nvar comment_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49428,(1),null);\nif(cljs.core.vector_QMARK_(style_vec)){\n} else {\nthrow (new Error([\"comment-column: style-vec not a vector!! \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(style_vec)].join('')));\n}\n\nvar index = indent_index;\nvar column = (0);\nwhile(true){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(index,comment_index)){\nreturn column;\n} else {\nvar G__49646 = (index + (1));\nvar G__49647 = zprint.comment.loc_vec(column,cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,index));\nindex = G__49646;\ncolumn = G__49647;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Take a single inline comment vector:\n *   [indent-index inline-comment-index] \n *   and replace it with [inline-comment-index start-column spaces-before].\n */\nzprint.comment.comment_vec_column = (function zprint$comment$comment_vec_column(style_vec,p__49436){\nvar vec__49437 = p__49436;\nvar indent_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49437,(0),null);\nvar inline_comment_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49437,(1),null);\nvar comment_vec = vec__49437;\nvar start_column = zprint.comment.comment_column(comment_vec,style_vec);\nvar spaces_before = zprint.comment.loc_vec((0),cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,(inline_comment_index - (1))));\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [inline_comment_index,start_column,spaces_before], null);\n});\n/**\n * Take a single vector of inline comments\n *   [[indent-index inline-comment-index] [indent-index inline-comment-index]\n * ...] and replace it with [[inline-comment-index start-column spaces-before]\n * [inline-comment-index start-column spaces-before] ...]\n */\nzprint.comment.comment_vec_seq_column = (function zprint$comment$comment_vec_seq_column(style_vec,comment_vec_seq){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.comment.comment_vec_column,style_vec),comment_vec_seq);\n});\n/**\n * Take a seq of all of the comments as produced by \n *   find-consecutive-inline-comments, and turn it into:\n *   [[[inline-comment-index start-column spaces-before] [inline-comment-index\n *   start-column spaces-before]\n *   ...] ...]\n */\nzprint.comment.comment_vec_all_column = (function zprint$comment$comment_vec_all_column(style_vec,comment_vec_all){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.comment.comment_vec_seq_column,style_vec),comment_vec_all);\n});\n/**\n * Given a set of inline comments:\n *   [[inline-comment-index start-column spaces-before]\n * [inline-comment-index start-column spaces-before] ...], determine\n * the minimum column at which they could be aligned.\n */\nzprint.comment.minimum_column = (function zprint$comment$minimum_column(comment_vec){\nvar minimum_vec = cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__49446_SHARP_){\nreturn ((cljs.core.second(p1__49446_SHARP_) - cljs.core.nth.cljs$core$IFn$_invoke$arity$2(p1__49446_SHARP_,(2))) + (1));\n}),comment_vec);\nvar minimum_col = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.max,minimum_vec);\nreturn minimum_col;\n});\n/**\n * Given a new start-column, and a vector \n *   [[inline-comment-index start-column spaces-before]\n *   and a style-vec, return a new style-vec with the inline-comment starting\n *   at a new column.\n */\nzprint.comment.change_start_column = (function zprint$comment$change_start_column(new_start_column,style_vec,p__49449){\nvar vec__49452 = p__49449;\nvar inline_comment_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49452,(0),null);\nvar start_column = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49452,(1),null);\nvar spaces_before = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49452,(2),null);\nvar comment_vec = vec__49452;\nvar delta_spaces = (new_start_column - start_column);\nvar new_spaces = (spaces_before + delta_spaces);\nvar previous_element_index = (inline_comment_index - (1));\nvar vec__49469 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,previous_element_index);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49469,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49469,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__49469,(2),null);\nvar previous_element = vec__49469;\nvar new_previous_element = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)))?new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.comment.blanks(new_spaces))].join(''),c,e], null):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)))?new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.comment.blanks(new_spaces)),c,e,(26)], null):(function(){throw (new Error([\"change-start-column: comment preceded by neither\",\" an :indent nor :whitespace!\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(e)].join('')))})()\n));\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(style_vec,previous_element_index,new_previous_element);\n});\n/**\n * Given one set of inline comments: \n *   [[inline-comment-index start-column spaces-before]\n * [inline-comment-index start-column spaces-before] ...], align them \n * as best as possible, and return the modified style-vec.\n */\nzprint.comment.align_comment_vec = (function zprint$comment$align_comment_vec(style_vec,comment_vec){\nvar minimum_col = zprint.comment.minimum_column(comment_vec);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.comment.change_start_column,minimum_col),style_vec,comment_vec);\n});\n/**\n * Given the current style-vec, align all consecutive inline comments.\n */\nzprint.comment.fzprint_align_inline_comments = (function zprint$comment$fzprint_align_inline_comments(options,style_vec){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-align-inline-comments: style-vec:\",style_vec], 0))], 0));\n} else {\n}\n\nvar style = new cljs.core.Keyword(null,\"inline-align-style\",\"inline-align-style\",1548722575).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"none\",\"none\",1333468478))){\nreturn style_vec;\n} else {\nvar comment_vec = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"aligned\",\"aligned\",-1015148916)))?zprint.comment.find_aligned_inline_comments(style_vec):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"consecutive\",\"consecutive\",-1628234596)))?zprint.comment.find_consecutive_inline_comments(style_vec):null));\nvar comment_vec_column = zprint.comment.comment_vec_all_column(style_vec,comment_vec);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.comment.align_comment_vec,style_vec,comment_vec_column);\n}\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","zprint/comment.cljc","~:line",1,"~:column",14,"~:end-line",1,"~:end-column",28,"~:no-doc",true],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.tools.reader.reader-types","~$cljs.tools.reader.reader-types","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index"],"~:use-macros",["^ ","~$dbg","~$zprint.macros","~$dbg-pr","^K","~$dbg-form","^K","~$dbg-print","^K","~$zfuture","^K"],"~:excludes",["~#set",[]],"~:name","~$zprint.comment","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.string","^X","~$s","^X","~$zprint.zfns","^Y","~$zprint.zutil","^Z","~$cljs.core","^[","~$goog","^10"],"~:seen",["^Q",["~:require","~:require-macros"]],"~:uses",["^ ","~$zstring","^Y","~$ztag","^Y"],"^13",["^ ","^K","^K","^[","^["],"~:form",["~#list",["~$ns","^S",["^13",["^K","~:refer",["^J","^L","^M","^N","^O"]]],["^18",["^12",["^X","~:as","~$s"],["^Y","^1:",["^15","^16"]],["^Z"]]]]],"~:flags",["^ ","^13",["^Q",[]],"^12",["^Q",[]]],"~:js-deps",["^ "],"~:deps",["^10","^[","^X","^Y","^Z"]],"^U","^S","~:resource-id",["~:shadow.build.classpath/resource","zprint/comment.cljc"],"~:compiled-at",1630429609083,"~:resource-name","zprint/comment.cljc","~:warnings",[],"~:source","(ns ^:no-doc zprint.comment\n  #?@(:cljs [[:require-macros\n              [zprint.macros :refer [dbg dbg-pr dbg-form dbg-print zfuture]]]])\n  (:require #?@(:clj [[zprint.macros :refer\n                       [dbg-pr dbg dbg-form dbg-print zfuture]]])\n            [clojure.string :as s]\n            [zprint.zfns :refer [zstring ztag]]\n            [zprint.zutil]\n            #_[taoensso.tufte :as tufte :refer (p defnp profiled profile)]))\n\n#_(tufte/add-basic-println-handler! {})\n\n;;\n;; # Utility Functions\n;;\n\n;\n; Interestingly, this is faster than (apply str (repeat n \\space)) by\n; about 30%.\n\n(defn blanks\n  \"Produce a blank string of desired size.\"\n  [n]\n  (apply str (repeat n \" \")))\n\n(defn split-lf\n  \"Do split for newlines, instead of using regular expressions.\"\n  [s]\n  (loop [input s\n         out []]\n    (if-not input\n      out\n      (let [next-lf (clojure.string/index-of input \"\\n\")\n            chunk (if next-lf (subs input 0 next-lf) input)]\n        (recur (if next-lf (subs input (inc next-lf)) nil) (conj out chunk))))))\n\n(defn tag-l-size\n  \"Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters.\"\n  [t]\n  (case t\n    :list 1\n    :vector 1\n    :set 2\n    :map 1\n    :uneval 2\n    :reader-macro 1\n    :meta 1\n    :quote 1\n    :syntax-quote 1\n    :fn 2\n    :unquote 1\n    :deref 1\n    :namespaced-map 1\n    0))\n\n(defn left-or-up\n  \"Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]\"\n  [zloc]\n  (loop [ploc zloc\n         total-up 0]\n    #_(prn \"left-or-up: ploc:\" (zstring ploc) \"total-up:\" total-up)\n    (let [next-left (zprint.zutil/left* ploc)]\n      (if next-left\n        [total-up next-left]\n        ; can't go left, what about up?\n        (let [moving-up (zprint.zutil/up* ploc)\n              up-tag (when moving-up (zprint.zutil/tag moving-up))\n              up-size (tag-l-size up-tag)]\n          #_(prn \"left-or-up: up-tag:\" up-tag)\n          (if-not moving-up\n            ; can't go up, ran out of expression\n            [total-up nil]\n            (recur moving-up (+ total-up up-size))))))))\n\n(defn length-after-newline\n  \"Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string.\"\n  [s]\n  (let [nl-split (clojure.string/split (str s \" \") #\"\\n\")\n        nl-num (dec (count nl-split))]\n    (when-not (zero? nl-num) (dec (count (last nl-split))))))\n\n(defn length-before\n  \"Given a zloc, find the amount of printing space before it on its\n  current line.\"\n  [zloc]\n  (let [[up-size next-zloc] (left-or-up zloc)]\n    (loop [ploc next-zloc\n           indent-before up-size]\n      (if-not ploc\n        (do #_(prn \"length-before: if-not ploc:\" indent-before) indent-before)\n        ; we assume we have a ploc\n        (let [zstr (if ploc (zstring ploc) \"\")\n              length-right-of-newline (length-after-newline zstr)\n              [up-size next-zloc] (left-or-up ploc)]\n          #_(prn \"length-before: (nil? ploc):\" (nil? ploc)\n                 \"zstr:\" zstr\n                 \"up-size:\" up-size\n                 \"length-right-of-newline:\" length-right-of-newline\n                 \"(tag ploc):\" (zprint.zutil/tag ploc)\n                 \"ploc:\" (zstring ploc)\n                 \"next-zloc:\" (zstring next-zloc))\n          (if length-right-of-newline\n            ; hit a newline\n            (do #_(prn \"length-before: length-right-of-newline:\"\n                         length-right-of-newline\n                       \"indent-before:\" indent-before)\n                (+ length-right-of-newline indent-before))\n            (recur next-zloc (+ indent-before (count zstr) up-size))))))))\n\n;;\n;; # Comment Wrap Support\n;;\n\n(defn inlinecomment?\n  \"If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment.\"\n  [zloc]\n  #_(prn \"inlinecomment? zloc:\" (zstring zloc))\n  (loop [nloc (zprint.zutil/left* zloc)\n         spaces 0\n         passed-nl? false]\n    (let\n      #?(:clj [tnloc (ztag nloc)]\n         :cljs [[tnloc spaces]\n                (let [tnloc (ztag nloc)]\n                  (if (= tnloc :whitespace)\n                    ; might be whitespace with an embedded comma in cljs\n                    (let [nstr (zstring nloc)\n                          trim-nstr (clojure.string/trimr nstr)]\n                      (if (pos? (count trim-nstr))\n                        ; it had something besides spaces in it\n                        ; we will assume a comma\n                        ;  correct things\n                        [:comma (+ spaces (- (count nstr) (count trim-nstr)))]\n                        ; it was all whitespace -- don't correct\n                        [:whitespace spaces]))\n                    [tnloc spaces]))])\n      #_(prn \"inlinecomment? tnloc:\" tnloc\n             \"spaces:\" spaces\n             \"nloc:\" (zstring nloc))\n      (cond\n        (nil? tnloc) nil  ; the start of the zloc\n        (= tnloc :newline) (recur (zprint.zutil/left* nloc) spaces true)\n        (or (= tnloc :comment) (= tnloc :comment-inline))\n          ; Two comments in a row don't have a newline showing between\n          ; them, it is captured by the first comment.  Sigh.\n          ; Except now it isn't, as we split the newlines out.\n          (do #_(prn \"inlinecomment? found previous comment!\")\n              ; is it an inline comment?\n              (when (inlinecomment? nloc)\n                ; figure the total alignment from the newline\n                (let [nloc-length-before (length-before nloc)\n                      zloc-length-before (length-before zloc)]\n                  #_(prn \"inlinecomment?:\"\n                         \"nloc-length-before:\" nloc-length-before\n                         \"zloc-length-before:\" zloc-length-before\n                         \"spaces:\" spaces)\n                  (if (= nloc-length-before zloc-length-before)\n                    ; we have a lineup\n                    [spaces zloc-length-before]\n                    nil))))\n        (not= tnloc :whitespace)\n          (if passed-nl? nil [spaces (length-before zloc)])\n        :else (recur (zprint.zutil/left* nloc)\n                     ^long (+ ^long (zprint.zutil/length nloc) spaces)\n                     passed-nl?)))))\n\n(defn last-space\n  \"Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (min (dec (count s)) from-index)\n        rev-seq (reverse (take (inc from-index) s))\n        seq-after-space (take-while #(not= % \\space) rev-seq)\n        space-index (- from-index (count seq-after-space))]\n    (if (neg? space-index) nil space-index)))\n\n(defn next-space\n  \"Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (inc from-index)]\n    (when (< from-index (count s))\n      (let [seq-after-space (take-while #(not= % \\space)\n                                        (drop from-index (seq s)))\n            space-index (+ from-index (count seq-after-space))]\n        (if (>= space-index (count s)) nil space-index)))))\n\n; transient may have made this worse\n(defn wrap-comment\n  \"If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case.\"\n  [width [s color stype :as element] start]\n  (if-not (or (= stype :comment) (= stype :comment-inline))\n    element\n    (let [comment-width (- width start)\n          semi-str (re-find #\";*\" s)\n          rest-str (subs s (count semi-str))\n          space-str (re-find #\" *\" rest-str)\n          rest-str (subs rest-str (count space-str))\n          newline? (re-find #\"\\n$\" s)\n          comment-width (- comment-width (count semi-str) (count space-str))\n          #_(println \"\\ncomment-width:\" comment-width\n                     \"semi-str:\" semi-str\n                     \"space-str:\" space-str\n                     \"rest-str:\" rest-str)]\n      (loop [comment-str rest-str\n             out (transient [])]\n        #_(prn \"comment-str:\" comment-str)\n        (if (empty? comment-str)\n          (if (zero? (count out))\n            (if newline?\n              [[semi-str color stype] [\"\\n\" :none :indent 38]]\n              [[semi-str color stype]])\n            (persistent! (if newline? (conj! out [\"\\n\" :none :indent 39]) out)))\n          (let [last-space-index (if (<= (count comment-str) comment-width)\n                                   (dec (count comment-str))\n                                   (if (<= comment-width 0)\n                                     (or (next-space comment-str 0)\n                                         (dec (count comment-str)))\n                                     (or (last-space comment-str comment-width)\n                                         (next-space comment-str comment-width)\n                                         (dec (count comment-str)))))\n                next-comment (clojure.string/trimr\n                               (subs comment-str 0 (inc last-space-index)))]\n            #_(prn \"last-space-index:\" last-space-index\n                   \"next-comment:\" next-comment)\n            (recur\n              (subs comment-str (inc last-space-index))\n              (if (zero? (count out))\n                ;(empty? out)\n                (conj! out [(str semi-str space-str next-comment) color stype])\n                (conj! (conj! out [(str \"\\n\" (blanks start)) :none :indent 40])\n                       [(str semi-str space-str next-comment) color\n                        :comment-wrap])))))))))\n\n(defn loc-vec\n  \"Takes the start of this vector and the vector itself.\"\n  [start [s]]\n  (let [split (split-lf s)]\n    (if (= (count split) 1) (+ start (count s)) (count (last split)))))\n\n(defn style-loc-vec\n  \"Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent.\"\n  [indent style-vec]\n  (butlast (reductions loc-vec indent style-vec)))\n\n; Transient didn't help here, rather it hurt a bit.\n\n(defn lift-vec\n  \"Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector.\"\n  [out-vec element]\n  (if (string? (first element))\n    (conj out-vec element)\n    (loop [element-vec element\n           out out-vec]\n      (if-not element-vec\n        out\n        (recur (next element-vec) (conj out (first element-vec)))))))\n\n(defn lift-style-vec\n  \"Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors.\"\n  [style-vec]\n  (reduce lift-vec [] style-vec))\n\n(defn fzprint-wrap-comments\n  \"Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for \"\n  [{:keys [width], :as options} style-vec]\n  (dbg options \"fzprint-wrap-comments: indent:\" (:indent options))\n  #_(def wcsv style-vec)\n  (let [start-col (style-loc-vec (or (:indent options) 0) style-vec)\n        #_(def stc start-col)\n        _ (dbg options \"fzprint-wrap-comments: style-vec:\" (pr-str style-vec))\n        _ (dbg options \"fzprint-wrap-comments: start-col:\" start-col)\n        wrap-style-vec (mapv (partial wrap-comment width) style-vec start-col)\n        #_(def wsv wrap-style-vec)\n        _ (dbg options \"fzprint-wrap-comments: wrap:\" (pr-str style-vec))\n        out-style-vec (lift-style-vec wrap-style-vec)]\n    out-style-vec))\n\n(defn find-element-from-end\n  \"Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element.\"\n  [element-pred? style-vec]\n  (loop [index (dec (count style-vec))]\n    (if (neg? index)\n      nil\n      (let [[_ _ e] (nth style-vec index)]\n        (if (element-pred? e) index (recur (dec index)))))))\n\n(defn line-size\n  \"Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines.\"\n  [style-vec]\n  (apply + (map (partial loc-vec 0) style-vec)))\n\n(defn space-before-comment\n  \"Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line.\"\n  [style-vec]\n  (let [indent-index (find-element-from-end #(or (= % :indent) (= % :newline))\n                                            style-vec)\n        this-line-vec\n          (if indent-index (nthnext style-vec indent-index) style-vec)]\n    (line-size (butlast this-line-vec))))\n\n(defn fzprint-inline-comments\n  \"Try to bring inline comments back onto the line on which they belong.\"\n  [{:keys [width], :as options} style-vec]\n  #_(def fic style-vec)\n  (dbg-pr options \"fzprint-inline-comments:\" style-vec)\n  (loop [cvec style-vec\n         last-out [\"\" nil nil]\n         out []]\n    (if-not cvec\n      (do #_(def fico out) out)\n      (let [[s c e :as element] (first cvec)\n            [_ _ ne nn :as next-element] (second cvec)\n            [_ _ le] last-out\n            new-element\n              (cond (and (or (= e :indent) (= e :newline))\n                         (= ne :comment-inline))\n                      (if-not (or (= le :comment) (= le :comment-inline))\n                        ; Regular line to get the inline comment\n                        [(blanks nn) c :whitespace 25]\n                        ; Last element was a comment...\n                        ; Can't put a comment on a comment, but\n                        ; we want to indent it like the last\n                        ; comment.\n                        ; How much space before the last comment?\n                        (do #_(prn \"inline:\" (space-before-comment out))\n                            [(str \"\\n\" (blanks (space-before-comment out))) c\n                             :indent 41]\n                            #_element))\n                    :else element)]\n        (recur (next cvec) new-element (conj out new-element))))))\n\n;;\n;; ## Align inline comments\n;;\n\n(def max-aligned-inline-comment-distance 5)\n\n(defn find-aligned-inline-comments\n  \"Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec.\"\n  [style-vec]\n  #_(def fcic style-vec)\n  (loop [cvec style-vec\n         index 0\n         last-indent 0\n         current-seq []\n         current-column 0\n         distance 0\n         out []]\n    (if-not cvec\n      (let [out (if (> (count current-seq) 1) (conj out current-seq) out)]\n        #_(def fcico out)\n        out)\n      (let [[s c e spaces start-column :as element] (first cvec)]\n        (cond\n          (= e :comment-inline)\n            (if (= start-column current-column)\n              ; include this inline comment in the current-seq, since\n              ; it has the same starting column\n              (recur (next cvec)\n                     (inc index)\n                     nil\n                     (if last-indent\n                       (conj current-seq [last-indent index])\n                       (do (throw\n                             (#?(:clj Exception.\n                                 :cljs js/Error.)\n                              (str \"find-aligned-inline-comments a:\" index)))\n                           []))\n                     current-column\n                     ; distance from last inline comment is zero\n                     0\n                     out)\n              ; start a new current-seq, since this comment's starting\n              ; column doesn't match the current-column of the current-seq\n              (recur (next cvec)\n                     (inc index)\n                     nil\n                     (if last-indent\n                       [[last-indent index]]\n                       (do (throw\n                             (#?(:clj Exception.\n                                 :cljs js/Error.)\n                              (str \"find-aligned-inline-comments b:\" index)))\n                           []))\n                     ; new starting column\n                     start-column\n                     ; distance from the last inline comment is zero\n                     0\n                     ; if we have more than one current inline comments,\n                     ; add them to the out vector\n                     (if (> (count current-seq) 1) (conj out current-seq) out)))\n          (or (= e :indent) (= e :newline))\n            (if (>= distance max-aligned-inline-comment-distance)\n              ; We have gone too far\n              (recur (next cvec)\n                     (inc index)\n                     ; last-indent is this index\n                     index\n                     []\n                     ; current-column\n                     0\n                     ; distance\n                     0\n                     (if (> (count current-seq) 1) (conj out current-seq) out))\n              ; We have not gone too far\n              (recur (next cvec)\n                     (inc index)\n                     ; last-indent is this index\n                     index\n                     current-seq\n                     current-column\n                     ; we've passed another line\n                     (inc distance)\n                     out))\n          :else (recur (next cvec)\n                       (inc index)\n                       last-indent\n                       current-seq\n                       current-column\n                       distance\n                       out))))))\n\n(defn find-consecutive-inline-comments\n  \"Given a style-vec, find consecutive inline comments and output\n  the as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]\"\n  [style-vec]\n  #_(def fcic style-vec)\n  (loop [cvec style-vec\n         index 0\n         last-indent 0\n         current-seq []\n         out []]\n    (if-not cvec\n      (do #_(def fcico out) out)\n      (let [[s c e :as element] (first cvec)]\n        (cond\n          (= e :comment-inline)\n            (recur (next cvec)\n                   (inc index)\n                   nil\n                   (if last-indent\n                     (conj current-seq [last-indent index])\n                     (do (throw\n                           (#?(:clj Exception.\n                               :cljs js/Error.)\n                            (str \"find-consecutive-inline-comments:\" index)))\n                         []))\n                   out)\n          (or (= e :indent) (= e :newline))\n            (recur (next cvec)\n                   (inc index)\n                   index\n                   (if last-indent\n                     ; if we have a last-indent, then we didn't\n                     ; just have a comment\n                     []\n                     ; if we don't have a last-indent, then we\n                     ; did just have a comment previously, so keep\n                     ; collecting comments\n                     current-seq)\n                   (if last-indent\n                     ; if we have a last-indent, then we didn't\n                     ; just have a comment.  But if we have more\n                     ; than one comment vector in current-seq,\n                     ; make sure we keep track of that\n                     (if (> (count current-seq) 1) (conj out current-seq) out)\n                     ; if we didn't have last-indent, then we\n                     ; just had a comment, so keep collecting\n                     ; them\n                     out))\n          :else (recur (next cvec) (inc index) last-indent current-seq out))))))\n\n(defn comment-column\n  \"Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts.\"\n  [[indent-index comment-index] style-vec]\n  (when-not (vector? style-vec)\n    (throw (#?(:clj Exception.\n               :cljs js/Error.)\n            (str \"comment-column: style-vec not a vector!! \" style-vec))))\n  (loop [index indent-index\n         column 0]\n    (if (= index comment-index)\n      column\n      (recur (inc index) (loc-vec column (nth style-vec index))))))\n\n(defn comment-vec-column\n  \"Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before].\"\n  [style-vec [indent-index inline-comment-index :as comment-vec]]\n  (let [start-column (comment-column comment-vec style-vec)\n        spaces-before (loc-vec 0 (nth style-vec (dec inline-comment-index)))]\n    [inline-comment-index start-column spaces-before]))\n\n(defn comment-vec-seq-column\n  \"Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]\"\n  [style-vec comment-vec-seq]\n  (map (partial comment-vec-column style-vec) comment-vec-seq))\n\n(defn comment-vec-all-column\n  \"Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]\"\n  [style-vec comment-vec-all]\n  (map (partial comment-vec-seq-column style-vec) comment-vec-all))\n\n(defn minimum-column\n  \"Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned.\"\n  [comment-vec]\n  (let [minimum-vec (map #(inc (- (second %) (nth % 2))) comment-vec)\n        minimum-col (apply max minimum-vec)]\n    minimum-col))\n\n(defn change-start-column\n  \"Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column.\"\n  [new-start-column style-vec\n   [inline-comment-index start-column spaces-before :as comment-vec]]\n  (let [delta-spaces (- new-start-column start-column)\n        new-spaces (+ spaces-before delta-spaces)\n        previous-element-index (dec inline-comment-index)\n        #_(prn \"change-start-column:\"\n               \"spaces-before:\" spaces-before\n               \"delta-spaces:\" delta-spaces\n               \"new-spaces:\" new-spaces)\n        [s c e :as previous-element] (nth style-vec previous-element-index)\n        new-previous-element\n          (cond (= e :indent) [(str \"\\n\" (blanks new-spaces)) c e]\n                (= e :whitespace) [(str (blanks new-spaces)) c e 26]\n                :else (throw\n                        (#?(:clj Exception.\n                            :cljs js/Error.)\n                         (str \"change-start-column: comment preceded by neither\"\n                              \" an :indent nor :whitespace!\"\n                              e))))]\n    (assoc style-vec previous-element-index new-previous-element)))\n\n(defn align-comment-vec\n  \"Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec.\"\n  [style-vec comment-vec]\n  (let [minimum-col (minimum-column comment-vec)]\n    (reduce (partial change-start-column minimum-col) style-vec comment-vec)))\n\n(defn fzprint-align-inline-comments\n  \"Given the current style-vec, align all consecutive inline comments.\"\n  [options style-vec]\n  (dbg-pr options \"fzprint-align-inline-comments: style-vec:\" style-vec)\n  (let [style (:inline-align-style (:comment options))]\n    (if (= style :none)\n      style-vec\n      (let [comment-vec (cond (= style :aligned) (find-aligned-inline-comments\n                                                   style-vec)\n                              (= style :consecutive)\n                                (find-consecutive-inline-comments style-vec))\n            comment-vec-column (comment-vec-all-column style-vec comment-vec)]\n        (reduce align-comment-vec style-vec comment-vec-column)))))\n\n","~:reader-features",["^Q",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["zprint.comment/blanks","n","cljs.core.apply","cljs.core/str","cljs.core.repeat","zprint.comment/split-lf","s","input","out","cljs.core/not","next-lf","clojure.string.index_of","chunk","cljs.core.subs","cljs.core.conj","zprint.comment/tag-l-size","t","G__48982","cljs.core/Keyword","zprint.comment/left-or-up","zloc","ploc","total-up","next-left","zprint.zutil/left*","moving-up","zprint.zutil/up*","up-tag","zprint.zutil/tag","up-size","zprint.comment/length-after-newline","nl-split","clojure.string.split","nl-num","cljs.core/count","cljs.core/last","zprint.comment/length-before","vec__49010","cljs.core.nth","next-zloc","indent-before","vec__49027","zstr","zprint.zfns/zstring","length-right-of-newline","zprint.comment/inlinecomment?","nloc","spaces","passed-nl?","vec__49090","tnloc","zprint.zfns/ztag","cljs.core._EQ_","nstr","trim-nstr","clojure.string/trimr","nloc-length-before","zloc-length-before","cljs.core.not_EQ_","zprint.zutil/length","zprint.comment/last-space","from-index","x__4298__auto__","y__4299__auto__","rev-seq","cljs.core/reverse","cljs.core.take","seq-after-space","p1__49118#","cljs.core.take_while","space-index","zprint.comment/next-space","p1__49130#","cljs.core.drop","cljs.core/seq","p__49161","vec__49167","zprint.comment/wrap-comment","width","color","stype","element","start","comment-width","semi-str","cljs.core/re-find","rest-str","space-str","newline?","comment-str","cljs.core/transient","cljs.core/empty?","cljs.core/persistent!","cljs.core.conj_BANG_","last-space-index","or__4212__auto__","next-comment","p__49205","vec__49208","zprint.comment/loc-vec","split","zprint.comment/style-loc-vec","indent","style-vec","cljs.core/butlast","cljs.core.reductions","zprint.comment/lift-vec","out-vec","cljs.core/first","element-vec","cljs.core/next","zprint.comment/lift-style-vec","cljs.core.reduce","p__49236","map__49237","cljs.core/--destructure-map","cljs.core.get","zprint.comment/fzprint-wrap-comments","options","cljs.core.println","start-col","_","cljs.core.pr_str","wrap-style-vec","cljs.core.mapv","cljs.core.partial","out-style-vec","zprint.comment/find-element-from-end","element-pred?","index","vec__49254","e","zprint.comment/line-size","cljs.core/+","cljs.core.map","zprint.comment/space-before-comment","indent-index","p1__49268#","this-line-vec","cljs.core/nthnext","p__49282","map__49283","zprint.comment/fzprint-inline-comments","cvec","last-out","vec__49318","vec__49321","vec__49324","c","ne","nn","next-element","cljs.core/second","le","new-element","zprint.comment/max-aligned-inline-comment-distance","zprint.comment/find-aligned-inline-comments","last-indent","current-seq","current-column","distance","vec__49383","start-column","js/Error","zprint.comment/find-consecutive-inline-comments","vec__49416","p__49427","vec__49428","zprint.comment/comment-column","comment-index","cljs.core/vector?","column","p__49436","vec__49437","zprint.comment/comment-vec-column","inline-comment-index","comment-vec","spaces-before","zprint.comment/comment-vec-seq-column","comment-vec-seq","zprint.comment/comment-vec-all-column","comment-vec-all","zprint.comment/minimum-column","minimum-vec","p1__49446#","minimum-col","cljs.core/max","p__49449","vec__49452","zprint.comment/change-start-column","new-start-column","vec__49469","delta-spaces","new-spaces","previous-element-index","previous-element","new-previous-element","cljs.core.assoc","zprint.comment/align-comment-vec","zprint.comment/fzprint-align-inline-comments","style","comment-vec-column"]],"~:used-vars",["^Q",["~$cljs.core/--destructure-map","~$zprint.comment/lift-vec","~$zprint.zutil/tag","~$cljs.core/str","~$zprint.comment/length-before","~$clojure.string/split","~$zprint.comment/fzprint-inline-comments","~$cljs.core/vector?","~$cljs.core/=","~$zprint.comment/blanks","~$cljs.core/partial","~$cljs.core/take-while","~$clojure.string/index-of","~$zprint.zfns/zstring","~$zprint.comment/find-element-from-end","~$cljs.core/count","~$cljs.core/reduce","~$cljs.core/seq","~$cljs.core/apply","~$cljs.core/Keyword","~$cljs.core/take","~$cljs.core/last","~$cljs.core/mapv","~$cljs.core/not=","~$cljs.core/pr-str","~$zprint.comment/comment-column","~$zprint.comment/line-size","~$cljs.core/empty?","~$zprint.comment/change-start-column","~$zprint.zutil/left*","~$zprint.comment/find-aligned-inline-comments","~$zprint.comment/comment-vec-column","~$cljs.core/conj","~$zprint.comment/comment-vec-seq-column","~$zprint.comment/wrap-comment","~$cljs.core/map","~$zprint.zfns/ztag","~$cljs.core/nthnext","~$cljs.core/get","~$clojure.string/trimr","~$zprint.comment/last-space","~$zprint.comment/split-lf","~$cljs.core/conj!","~$zprint.comment/comment-vec-all-column","~$cljs.core/re-find","~$cljs.core/persistent!","~$zprint.comment/fzprint-align-inline-comments","~$cljs.core/nth","~$zprint.zutil/up*","~$cljs.core/max","~$cljs.core/second","~$cljs.core/println","~$cljs.core/next","~$cljs.core/reductions","~$zprint.comment/lift-style-vec","~$cljs.core/transient","~$zprint.comment/tag-l-size","~$zprint.comment/next-space","~$cljs.core/not","~$zprint.comment/length-after-newline","~$zprint.comment/style-loc-vec","~$zprint.comment/space-before-comment","~$cljs.core/assoc","~$zprint.comment/max-aligned-inline-comment-distance","~$zprint.comment/loc-vec","~$zprint.comment/fzprint-wrap-comments","~$cljs.core/reverse","~$zprint.comment/find-consecutive-inline-comments","~$cljs.core/repeat","~$cljs.core/first","~$cljs.core/butlast","~$zprint.comment/minimum-column","~$zprint.comment/align-comment-vec","~$cljs.core/subs","~$cljs.core/+","~$zprint.comment/left-or-up","~$zprint.zutil/length","~$js/Error","~$zprint.comment/inlinecomment?","~$cljs.core/drop"]]],"~:cache-keys",["~#cmap",[["^1@","goog/dom/tagname.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^Q",[]],"~:deps-syms",["^10","~$goog.dom.HtmlElement"]]],["^1@","rewrite_clj/node/token.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","~$rewrite-clj.node.protocols"]]],["^1@","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^X","~$goog.string"]]],["^1@","goog/math/math.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","~$goog.array","~$goog.asserts"]]],["^1@","rewrite_clj/parser/core.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","~$rewrite-clj.node","~$rewrite-clj.reader","~$rewrite-clj.parser.keyword","~$rewrite-clj.parser.string","~$rewrite-clj.parser.token","~$rewrite-clj.parser.whitespace","^@"]]],["^1@","rewrite_clj/parser/string.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3O","^3P","^3L","^X"]]],["^1@","goog/html/trustedtypes.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","goog/labs/useragent/browser.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3M","~$goog.labs.userAgent.util","~$goog.object","~$goog.string.internal"]]],["^1@","goog/html/safeurl.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3N","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^3W"]]],["^1@","goog/array/array.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3N"]]],["^1@","rewrite_clj/zip/seqz.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","~$rewrite-clj.zip.base","~$rewrite-clj.zip.editz","~$rewrite-clj.zip.findz","~$rewrite-clj.zip.insert","~$rewrite-clj.zip.move","~$clojure.zip"]]],["^1@","rewrite_clj/zip/move.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","~$rewrite-clj.zip.whitespace","^47"]]],["^1@","goog/debug/error.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","rewrite_clj/zip.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^42","~$rewrite-clj.parser","^46","^44","^43","^45","~$rewrite-clj.zip.removez","~$rewrite-clj.zip.seqz","^47"]]],["^1@","rewrite_clj/zip/editz.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^42","^46","^4:","~$rewrite-clj.zip.utils","^48","^3O","^47"]]],["^1@","goog/dom/nodetype.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^["]]],["^1@","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^@","~$cljs.tools.reader.impl.utils","~$cljs.tools.reader.impl.commons","~$cljs.tools.reader.impl.errors","^3M","^3L","~$goog.string.StringBuffer"]]],["^1@","rewrite_clj/node/forms.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K"]]],["^1@","rewrite_clj/zip/insert.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^42","^48","^3O","^47"]]],["^1@","goog/string/typedstring.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","rewrite_clj/zip/utils.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^47"]]],["^1@","goog/object/object.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","goog/dom/asserts.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3N"]]],"~:SHADOW-TIMESTAMP",[1630418006000,1630418006000,1627026917000],["^1@","goog/math/long.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3N","~$goog.reflect"]]],["^1@","rewrite_clj/node/reader_macro.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K","~$rewrite-clj.node.whitespace"]]],["^1@","goog/html/trustedresourceurl.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3N","~$goog.fs.blob","^3X","~$goog.html.SafeScript","~$goog.html.trustedtypes","^3Z","^3[","^40","^41"]]],["^1@","goog/string/internal.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","goog/functions/functions.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","rewrite_clj/zip/findz.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^42","^46","^3O","^48","^47"]]],["^1@","goog/html/safestyle.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3M","^3N","~$goog.html.SafeUrl","^40","^41","^3W"]]],["^1@","goog/dom/safe.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3N","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^4E","~$goog.html.SafeStyle","^4G","^3Y","~$goog.html.uncheckedconversions","^40","^3W"]]],["^1@","clojure/walk.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^["]]],["^1@","goog/structs/map.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^1@","rewrite_clj/node/meta.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K","^4C"]]],["^1@","goog/html/safehtml.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3M","^3N","~$goog.dom.TagName","~$goog.dom.tags","^4E","^4K","~$goog.html.SafeStyleSheet","^4G","^3Y","^4F","^3Z","^3[","~$goog.labs.userAgent.browser","^3V","^40","^41","^3W"]]],["^1@","goog/dom/tags.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3V"]]],["^1@","rewrite_clj/node/stringz.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K","~$cljs.tools.reader","^X"]]],["^1@","rewrite_clj/node/comment.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K"]]],["^1@","goog/fs/blob.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3M"]]],["^1@","rewrite_clj/node/keyword.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K"]]],["^1@","goog/asserts/asserts.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1@","zprint/zutil.cljc"],["3bd9bbedb188a66ccf72c1e22819e8e423a6757a","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^X","^Y","^49","^3O","~$rewrite-clj.zip","^42","^48","^46","^4:","^43","^47"]]],["^1@","goog/uri/uri.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3M","^3N","^3L","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1@","goog/i18n/bidi.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","rewrite_clj/node/protocols.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^X"]]],["^1@","rewrite_clj/node/seq.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K"]]],["^1@","rewrite_clj/node/uneval.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K"]]],["^1@","goog/fs/url.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","goog/base.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",[]]],["^1@","goog/structs/structs.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3M","^3V"]]],["^1@","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^@","^X","~$cljs.tools.reader.impl.inspect"]]],["^1@","rewrite_clj/node/whitespace.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K"]]],["^1@","rewrite_clj/node/coercer.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","~$rewrite-clj.node.comment","~$rewrite-clj.node.forms","~$rewrite-clj.node.keyword","~$rewrite-clj.node.quote","~$rewrite-clj.node.stringz","~$rewrite-clj.node.uneval","~$rewrite-clj.node.meta","~$rewrite-clj.node.fn","^3K","~$rewrite-clj.node.reader-macro","~$rewrite-clj.node.seq","~$rewrite-clj.node.token","^4C"]]],["^1@","clojure/string.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3L","^4@"]]],["^1@","rewrite_clj/parser.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","~$rewrite-clj.parser.core","^3O","^3P"]]],["^1@","rewrite_clj/parser/keyword.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3O","^@","^3P"]]],["^1@","zprint/zfns.cljc"],["3bd9bbedb188a66ccf72c1e22819e8e423a6757a","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^["]]],["^1@","rewrite_clj/parser/token.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3O","^3P","^3L"]]],["^1@","zprint/comment.cljc"],["3bd9bbedb188a66ccf72c1e22819e8e423a6757a","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^X","^Y","^Z"]]],["^1@","goog/string/string.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","~$goog.dom.safe","^4L","^40","^3W"]]],["^1@","goog/reflect/reflect.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","rewrite_clj/node/fn.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K","~$clojure.walk"]]],["^1@","goog/labs/useragent/util.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3W"]]],["^1@","rewrite_clj/node.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","~$rewrite-clj.node.coercer","^3K","^53","^5:","^4C","^5;","^51","^52","^57","^55","^59","^54","^56","^58"]]],["^1@","rewrite_clj/zip/removez.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^46","^4<","^48","^47"]]],["^1@","clojure/zip.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^["]]],["^1@","goog/string/stringbuffer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^4=","^3L","^4@"]]],["^1@","goog/iter/iter.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3M","^3N","^4I","~$goog.math"]]],["^1@","goog/html/uncheckedconversions.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3N","^4J","^4E","^4K","^4Q","^4G","^3Y","^40","^3W","^3Z"]]],["^1@","rewrite_clj/reader.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^4S","^@","^4>","^3L","^3K"]]],["^1@","rewrite_clj/node/quote.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3K"]]],["^1@","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^4?","^@","^4="]]],["^1@","goog/dom/htmlelement.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10"]]],["^1@","cljs/core.cljs"],["528fbd795675bc73c189ce8a8429415f03165a3b","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","~$goog.math.Long","~$goog.math.Integer","^3L","^3V","^3M","~$goog.Uri","^4@"]]],["^1@","goog/html/safescript.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^40","^41","^4F","^3N"]]],["^1@","goog/html/safestylesheet.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^40","^4K","^41","^3M","^3V","^3N","^3W"]]],["^1@","goog/math/integer.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^4B"]]],["^1@","goog/uri/utils.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3N","^3L"]]],["^1@","goog/string/const.js"],["b8c673dd84d8ed85c6d857e28afee5524a0ef82c","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^3N","^41"]]],["^1@","rewrite_clj/zip/base.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3O","^49","^48","^47"]]],["^1@","rewrite_clj/zip/whitespace.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3O","^47"]]],["^1@","rewrite_clj/parser/whitespace.cljs"],["c35be115c39dadc71a4de3f584aa8ca295e11257","^3F",["^ ","^3G",null,"^3H",["^Q",[]],"^3I",["^10","^[","^3O","^3P"]]]]],"~:clj-info",["^ ","jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer.cljc",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/passes.cljc",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/core.cljc",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/java/io.clj",1625242111000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/js_deps.cljc",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1627026915000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/edn.clj",1625242111000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/env.cljc",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/compiler.cljc",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1627026915000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/externs.clj",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/data.json/2.4.0/data.json-2.4.0.jar!/clojure/data/json.clj",1627026915000,"jar:file:/home/dudley/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader.clj",1627026915000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/instant.clj",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/core.clj",1625242111000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/pprint.clj",1625242111000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/impl.cljc",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/string.clj",1625242111000,"jar:file:/home/dudley/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1627026915000,"jar:file:/home/dudley/.m2/repository/binaryage/devtools/0.9.7/devtools-0.9.7.jar!/devtools/defaults.clj",1625668616000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/tagged_literals.cljc",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/util.cljc",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/instant.clj",1625242111000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map/base64_vlq.clj",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map/base64.clj",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojure/1.10.3/clojure-1.10.3.jar!/clojure/set.clj",1625242111000,"jar:file:/home/dudley/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/default_data_readers.clj",1627026915000,"jar:file:/home/dudley/.m2/repository/zprint/zprint/1.1.1/zprint-1.1.1.jar!/zprint/macros.cljc",1630429552000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/analyzer/passes/and_or.cljc",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/clojurescript/1.10.879/clojurescript-1.10.879.jar!/cljs/source_map.clj",1627026917000,"jar:file:/home/dudley/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1627026915000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","zprint/comment.cljc","^7",1,"^8",14,"^9",1,"^:",28,"^;",true],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H"],"^I",["^ ","^J","^K","^L","^K","^M","^K","^N","^K","^O","^K"],"^P",["^Q",[]],"^R","^S","^V",null,"^W",["^ ","^X","^X","~$s","^X","^Y","^Y","^Z","^Z","^[","^[","^10","^10"],"^11",["^Q",["^12","^13"]],"~:shadow/js-access-global",["^Q",["Error"]],"^14",["^ ","^15","^Y","^16","^Y"],"~:defs",["^ ","~$fzprint-inline-comments",["^ ","~:protocol-inline",null,"^5",["^ ","^6","zprint/comment.cljc","^7",331,"^8",7,"^9",331,"^:",30,"~:arglists",["^18",["~$quote",["^18",[[["^ ","~:keys",["~$width"],"^1;","~$options"],"~$style-vec"]]]]],"~:doc","Try to bring inline comments back onto the line on which they belong."],"^R","^1R","^6","zprint/comment.cljc","^:",30,"~:method-params",["^18",[["~$p__49282","^6B"]]],"~:protocol-impl",null,"~:arglists-meta",["^18",[null,null]],"^8",1,"~:variadic?",false,"^7",331,"~:ret-tag",["^Q",["~$clj","~$cljs.core/IVector"]],"^9",331,"~:max-fixed-arity",2,"~:fn-var",true,"^6=",["^18",["^6>",["^18",[[["^ ","^6?",["^6@"],"^1;","^6A"],"^6B"]]]]],"^6C","Try to bring inline comments back onto the line on which they belong."],"~$blanks",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",21,"^8",7,"^9",21,"^:",13,"^6=",["^18",["^6>",["^18",[["~$n"]]]]],"^6C","Produce a blank string of desired size."],"^R","^1U","^6","zprint/comment.cljc","^:",13,"^6D",["^18",[["~$n"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",21,"^6I","~$any","^9",21,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["~$n"]]]]],"^6C","Produce a blank string of desired size."],"~$find-element-from-end",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",305,"^8",7,"^9",305,"^:",28,"^6=",["^18",["^6>",["^18",[["~$element-pred?","^6B"]]]]],"^6C","Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element."],"^R","^1Z","^6","zprint/comment.cljc","^:",28,"^6D",["^18",[["^6Q","^6B"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",305,"^6I",["^Q",["~$number","~$clj-nil"]],"^9",305,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6Q","^6B"]]]]],"^6C","Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element."],"~$loc-vec",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",257,"^8",7,"^9",257,"^:",14,"^6=",["^18",["^6>",["^18",[["~$start",["~$s"]]]]]],"^6C","Takes the start of this vector and the vector itself."],"^R","^34","^6","zprint/comment.cljc","^:",14,"^6D",["^18",[["^6U","~$p__49205"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",257,"^6I","^6R","^9",257,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6U",["~$s"]]]]]],"^6C","Takes the start of this vector and the vector itself."],"~$length-before",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",90,"^8",7,"^9",90,"^:",20,"^6=",["^18",["^6>",["^18",[["~$zloc"]]]]],"^6C","Given a zloc, find the amount of printing space before it on its\n  current line."],"^R","^1P","^6","zprint/comment.cljc","^:",20,"^6D",["^18",[["^6X"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",90,"^6I",["^Q",["^6O","^6R"]],"^9",90,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6X"]]]]],"^6C","Given a zloc, find the amount of printing space before it on its\n  current line."],"~$comment-vec-column",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",527,"^8",7,"^9",527,"^:",25,"^6=",["^18",["^6>",["^18",[["^6B",["~$indent-index","~$inline-comment-index","^1;","~$comment-vec"]]]]]],"^6C","Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before]."],"^R","^2?","^6","zprint/comment.cljc","^:",25,"^6D",["^18",[["^6B","~$p__49436"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",527,"^6I","^6K","^9",527,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6B",["^6Z","^6[","^1;","^70"]]]]]],"^6C","Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before]."],"~$wrap-comment",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",209,"^8",7,"^9",209,"^:",19,"^6=",["^18",["^6>",["^18",[["^6@",["~$s","~$color","~$stype","^1;","~$element"],"^6U"]]]]],"^6C","If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case."],"^R","^2B","^6","zprint/comment.cljc","^:",19,"^6D",["^18",[["^6@","~$p__49161","^6U"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",209,"^6I",["^Q",[null,"^6J"]],"^9",209,"^6L",3,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6@",["~$s","^73","^74","^1;","^75"],"^6U"]]]]],"^6C","If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case."],"~$comment-vec-seq-column",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",536,"^8",7,"^9",536,"^:",29,"^6=",["^18",["^6>",["^18",[["^6B","~$comment-vec-seq"]]]]],"^6C","Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]"],"^R","^2A","^6","zprint/comment.cljc","^:",29,"^6D",["^18",[["^6B","^78"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",536,"^6I","~$cljs.core/LazySeq","^9",536,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6B","^78"]]]]],"^6C","Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]"],"~$lift-style-vec",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",283,"^8",7,"^9",283,"^:",21,"^6=",["^18",["^6>",["^18",[["^6B"]]]]],"^6C","Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors."],"^R","^2V","^6","zprint/comment.cljc","^:",21,"^6D",["^18",[["^6B"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",283,"^6I",["^Q",[null,"^6O"]],"^9",283,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6B"]]]]],"^6C","Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors."],"~$lift-vec",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",271,"^8",7,"^9",271,"^:",15,"^6=",["^18",["^6>",["^18",[["~$out-vec","^75"]]]]],"^6C","Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector."],"^R","^1M","^6","zprint/comment.cljc","^:",15,"^6D",["^18",[["^7<","^75"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",271,"^6I",["^Q",[null,"^6J"]],"^9",271,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["^7<","^75"]]]]],"^6C","Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector."],"~$last-space",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",182,"^8",7,"^9",182,"^:",17,"^6=",["^18",["^6>",["^18",[["~$s","~$from-index"]]]]],"^6C","Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string."],"^R","^2H","^6","zprint/comment.cljc","^:",17,"^6D",["^18",[["~$s","^7>"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",182,"^6I",["^Q",["^6R","^6S"]],"^9",182,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["~$s","^7>"]]]]],"^6C","Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string."],"~$comment-vec-all-column",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",544,"^8",7,"^9",544,"^:",29,"^6=",["^18",["^6>",["^18",[["^6B","~$comment-vec-all"]]]]],"^6C","Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]"],"^R","^2K","^6","zprint/comment.cljc","^:",29,"^6D",["^18",[["^6B","^7@"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",544,"^6I","^79","^9",544,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6B","^7@"]]]]],"^6C","Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]"],"~$comment-column",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",513,"^8",7,"^9",513,"^:",21,"^6=",["^18",["^6>",["^18",[[["^6Z","~$comment-index"],"^6B"]]]]],"^6C","Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts."],"^R","^29","^6","zprint/comment.cljc","^:",21,"^6D",["^18",[["~$p__49427","^6B"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",513,"^6I","^6R","^9",513,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[[["^6Z","^7B"],"^6B"]]]]],"^6C","Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts."],"~$line-size",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",315,"^8",7,"^9",315,"^:",16,"^6=",["^18",["^6>",["^18",[["^6B"]]]]],"^6C","Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines."],"^R","^2:","^6","zprint/comment.cljc","^:",16,"^6D",["^18",[["^6B"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",315,"^6I","^6O","^9",315,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6B"]]]]],"^6C","Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines."],"~$minimum-column",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",553,"^8",7,"^9",553,"^:",21,"^6=",["^18",["^6>",["^18",[["^70"]]]]],"^6C","Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned."],"^R","^3;","^6","zprint/comment.cljc","^:",21,"^6D",["^18",[["^70"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",553,"^6I","^6O","^9",553,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["^70"]]]]],"^6C","Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned."],"~$find-aligned-inline-comments",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",368,"^8",7,"^9",368,"^:",35,"^6=",["^18",["^6>",["^18",[["^6B"]]]]],"^6C","Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec."],"^R","^2>","^6","zprint/comment.cljc","^:",35,"^6D",["^18",[["^6B"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",368,"^6I",["^Q",["^6J","^6O"]],"^9",368,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6B"]]]]],"^6C","Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec."],"~$change-start-column",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",563,"^8",7,"^9",563,"^:",26,"^6=",["^18",["^6>",["^18",[["~$new-start-column","^6B",["^6[","~$start-column","~$spaces-before","^1;","^70"]]]]]],"^6C","Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column."],"^R","^2<","^6","zprint/comment.cljc","^:",26,"^6D",["^18",[["^7H","^6B","~$p__49449"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",563,"^6I",["^Q",["^6J","^6O"]],"^9",563,"^6L",3,"^6M",true,"^6=",["^18",["^6>",["^18",[["^7H","^6B",["^6[","^7I","^7J","^1;","^70"]]]]]],"^6C","Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column."],"~$style-loc-vec",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",263,"^8",7,"^9",263,"^:",20,"^6=",["^18",["^6>",["^18",[["~$indent","^6B"]]]]],"^6C","Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent."],"^R","^30","^6","zprint/comment.cljc","^:",20,"^6D",["^18",[["^7M","^6B"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",263,"^6I","~$seq","^9",263,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["^7M","^6B"]]]]],"^6C","Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent."],"~$find-consecutive-inline-comments",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",460,"^8",7,"^9",460,"^:",39,"^6=",["^18",["^6>",["^18",[["^6B"]]]]],"^6C","Given a style-vec, find consecutive inline comments and output\n  the as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]"],"^R","^37","^6","zprint/comment.cljc","^:",39,"^6D",["^18",[["^6B"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",460,"^6I","^6O","^9",460,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6B"]]]]],"^6C","Given a style-vec, find consecutive inline comments and output\n  the as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]"],"~$fzprint-align-inline-comments",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",598,"^8",7,"^9",598,"^:",36,"^6=",["^18",["^6>",["^18",[["^6A","^6B"]]]]],"^6C","Given the current style-vec, align all consecutive inline comments."],"^R","^2N","^6","zprint/comment.cljc","^:",36,"^6D",["^18",[["^6A","^6B"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",598,"^6I",["^Q",[null,"^6O"]],"^9",598,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6A","^6B"]]]]],"^6C","Given the current style-vec, align all consecutive inline comments."],"~$align-comment-vec",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",589,"^8",7,"^9",589,"^:",24,"^6=",["^18",["^6>",["^18",[["^6B","^70"]]]]],"^6C","Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec."],"^R","^3<","^6","zprint/comment.cljc","^:",24,"^6D",["^18",[["^6B","^70"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",589,"^6I",["^Q",[null,"^6O"]],"^9",589,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6B","^70"]]]]],"^6C","Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec."],"~$left-or-up",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",61,"^8",7,"^9",61,"^:",17,"^6=",["^18",["^6>",["^18",[["^6X"]]]]],"^6C","Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]"],"^R","^3?","^6","zprint/comment.cljc","^:",17,"^6D",["^18",[["^6X"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",61,"^6I","^6K","^9",61,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6X"]]]]],"^6C","Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]"],"~$inlinecomment?",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",122,"^8",7,"^9",122,"^:",21,"^6=",["^18",["^6>",["^18",[["^6X"]]]]],"^6C","If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment."],"^R","^3B","^6","zprint/comment.cljc","^:",21,"^6D",["^18",[["^6X"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",122,"^6I",["^Q",["^6K","^6S"]],"^9",122,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6X"]]]]],"^6C","If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment."],"~$tag-l-size",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",37,"^8",7,"^9",37,"^:",17,"^6=",["^18",["^6>",["^18",[["~$t"]]]]],"^6C","Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters."],"^R","^2X","^6","zprint/comment.cljc","^:",17,"^6D",["^18",[["~$t"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",37,"^9",37,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["~$t"]]]]],"^6C","Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters."],"~$next-space",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",196,"^8",7,"^9",196,"^:",17,"^6=",["^18",["^6>",["^18",[["~$s","^7>"]]]]],"^6C","Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string."],"^R","^2Y","^6","zprint/comment.cljc","^:",17,"^6D",["^18",[["~$s","^7>"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",196,"^6I",["^Q",["^6R","^6S"]],"^9",196,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[["~$s","^7>"]]]]],"^6C","Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string."],"~$max-aligned-inline-comment-distance",["^ ","^R","^33","^6","zprint/comment.cljc","^7",366,"^8",1,"^9",366,"^:",41,"^5",["^ ","^6","zprint/comment.cljc","^7",366,"^8",6,"^9",366,"^:",41],"~:tag","^6R"],"~$space-before-comment",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",321,"^8",7,"^9",321,"^:",27,"^6=",["^18",["^6>",["^18",[["^6B"]]]]],"^6C","Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line."],"^R","^31","^6","zprint/comment.cljc","^:",27,"^6D",["^18",[["^6B"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",321,"^6I","^6O","^9",321,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["^6B"]]]]],"^6C","Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line."],"~$length-after-newline",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",81,"^8",7,"^9",81,"^:",27,"^6=",["^18",["^6>",["^18",[["~$s"]]]]],"^6C","Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string."],"^R","^2[","^6","zprint/comment.cljc","^:",27,"^6D",["^18",[["~$s"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",81,"^6I",["^Q",["^6R","^6S"]],"^9",81,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["~$s"]]]]],"^6C","Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string."],"~$fzprint-wrap-comments",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",289,"^8",7,"^9",289,"^:",28,"^6=",["^18",["^6>",["^18",[[["^ ","^6?",["^6@"],"^1;","^6A"],"^6B"]]]]],"^6C","Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for "],"^R","^35","^6","zprint/comment.cljc","^:",28,"^6D",["^18",[["~$p__49236","^6B"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",289,"^6I",["^Q",[null,"^6O"]],"^9",289,"^6L",2,"^6M",true,"^6=",["^18",["^6>",["^18",[[["^ ","^6?",["^6@"],"^1;","^6A"],"^6B"]]]]],"^6C","Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for "],"~$split-lf",["^ ","^6<",null,"^5",["^ ","^6","zprint/comment.cljc","^7",26,"^8",7,"^9",26,"^:",15,"^6=",["^18",["^6>",["^18",[["~$s"]]]]],"^6C","Do split for newlines, instead of using regular expressions."],"^R","^2I","^6","zprint/comment.cljc","^:",15,"^6D",["^18",[["~$s"]]],"^6F",null,"^6G",["^18",[null,null]],"^8",1,"^6H",false,"^7",26,"^6I",["^Q",["^6J","^6K"]],"^9",26,"^6L",1,"^6M",true,"^6=",["^18",["^6>",["^18",[["~$s"]]]]],"^6C","Do split for newlines, instead of using regular expressions."]],"^13",["^ ","^K","^K","^[","^["],"~:cljs.analyzer/constants",["^ ","^11",["^Q",["~:comment-wrap","~:indent","~:whitespace","~:else","~:comma","~:dbg-indent","~:width","~:aligned","~:inline-align-style","~:dbg?","~:comment","~:comment-inline","~:newline","~:consecutive","~:none"]],"~:order",["^84","^86","^8>","^8<","^8=","^85","^8@","^83","^82","^88","^8;","^87","^8:","^89","^8?"]],"^1<",["^ ","^13",["^Q",[]],"^12",["^Q",[]]],"^1=",["^ "],"^1>",["^10","^[","^X","^Y","^Z"]],"^U","^S","~:ns-specs",["^ "],"~:ns-spec-vars",["^Q",[]],"~:compiler-options",["^3E",[["^8D","~:static-fns"],true,["^8D","~:shadow-tweaks"],null,["^8D","~:source-map-inline"],null,["^8D","~:elide-asserts"],false,["^8D","~:optimize-constants"],null,["^8D","^1C"],null,["^8D","~:external-config"],null,["^8D","~:tooling-config"],null,["^8D","~:emit-constants"],null,["^8D","~:load-tests"],null,["^8D","~:form-size-threshold"],null,["^8D","~:data-readers"],null,["^8D","~:infer-externs"],"~:auto",["^8D","^1E"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^8D","~:fn-invoke-direct"],null,["^8D","~:source-map"],"/dev/null"]]]